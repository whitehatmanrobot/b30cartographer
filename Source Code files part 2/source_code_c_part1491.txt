ude "DIUtil.h"
#include "resource.h"
#include "ddraw.h"
#include <tchar.h>
#include <stdio.h>


//-----------------------------------------------------------------------------
// Function prototypes
//-----------------------------------------------------------------------------
BOOL CALLBACK EnumSuitableDevicesCallback(LPCDIDEVICEINSTANCE lpDIDI, LPDIRECTINPUTDEVICE8A pdiDev8A, DWORD dwFlags, DWORD dwDeviceRemaining,  LPVOID lpVoid);
static HRESULT       CreateJoystick( HWND, LPDIRECTINPUTDEVICE2 pdidDevice );
BOOL CALLBACK ConfigureDevicesCallback(LPVOID lpVoid, LPVOID lpUser);


//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
#define NUMBER_OF_SEMANTICS ( sizeof(g_rgGameAction) / sizeof(DIACTION) )

extern LPDIRECTDRAW7 g_pDD;

static DIDEVICEINSTANCE     g_didiDevices[MAX_INPUT_DEVICES+1];
IDirectInput8*       g_pDI          = NULL;    // DirectInput object

IDirectInputDevice8* g_pDevices[NUMBER_OF_PLAYERS][MAX_INPUT_DEVICES+1]; //IDirectInputDevice8 ptrs
DWORD                g_dwNumDevices[NUMBER_OF_PLAYERS];
DIACTIONFORMAT diActF;
 //user name
TCHAR UserName[UNLEN+1];
LPTSTR lpUserName = UserName; 


extern LPDIRECTDRAWSURFACE7 g_pddsFrontBuffer;
extern DWORD dwInputState[NUMBER_OF_PLAYERS]; 

// {238D8220-7A5D-11d3-8FB2-00C04F8EC627}
static const GUID g_AppGuid =
{ 0x238d8220, 0x7a5d, 0x11d3, { 0x8f, 0xb2, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27 } };


DIACTION g_rgGameAction[] = {
        {AXIS_UD,    DIAXIS_FPS_MOVE, 0, TEXT("Forward"),},
        {AXIS_LR,    DIAXIS_FPS_ROTATE, 0, TEXT("Rotate"),},
        {KEY_FIRE,   DIBUTTON_FPS_FIRE, 0, TEXT("Fire"),},
        {KEY_THROW,  DIBUTTON_FPS_WEAPONS, 0, TEXT("Change Weapon"),},
        {KEY_SHIELD, DIBUTTON_FPS_APPLY, 0, TEXT("Shield"),},
        {KEY_STOP,   DIBUTTON_FPS_SELECT, 0, TEXT("Pause"),},
        {KEY_THROW,  DIBUTTON_FPS_CROUCH, 0, TEXT("Hyper space"),},
        {KEY_THROW,  DIBUTTON_FPS_JUMP, 0, TEXT("Launch Probe"),},
        {KEY_DISPLAY,DIBUTTON_FPS_DISPLAY, 0, TEXT("Display"),},
        {KEY_QUIT,   DIBUTTON_FPS_MENU, 0, TEXT("Quit Game"),},
		{KEY_EDIT,   DIBUTTON_FPS_DODGE, 0, TEXT("Edit Configuration"),},

        {KEY_LEFT,   DIKEYBOARD_LEFT, 0, TEXT("Turn +"),},
        {KEY_RIGHT,  DIKEYBOARD_RIGHT, 0, TEXT("Turn -"),},
        {KEY_UP,     DIKEYBOARD_UP, 0, TEXT("Move Up"),},
        {KEY_DOWN,   DIKEYBOARD_DOWN, 0, TEXT("Move Down"),},
        {KEY_STOP,   DIKEYBOARD_S, 0, TEXT("Stop Game"),},
        {KEY_FIRE,   DIKEYBOARD_SPACE, 0, TEXT("Shoot"),},
        {KEY_THROW,  DIKEYBOARD_T, 0, TEXT("Throw"),},
        {KEY_SHIELD, DIKEYBOARD_H, 0, TEXT("Shield"),},
        {KEY_DISPLAY,DIKEYBOARD_D, 0, TEXT("Display"),},
        {KEY_QUIT,   DIKEYBOARD_Q, 0, TEXT("Quit Game"),},
        {KEY_EDIT,   DIKEYBOARD_E, 0, TEXT("Edit Configuration"),},
        {AXIS_LR,    DIMOUSE_XAXIS, 0, TEXT("Turn"), },
        {AXIS_UD,    DIMOUSE_YAXIS, 0, TEXT("Move"), },
        {KEY_FIRE,   DIMOUSE_BUTTON0, 0, TEXT("Fire"), },
        {KEY_SHIELD, DIMOUSE_BUTTON1, 0, TEXT("Shield"),},
        {KEY_THROW,  DIMOUSE_BUTTON2, 0, TEXT("Change Weapon"),},
//        {KEY_THROW,  DIMOUSE_BUTTON3, 0, TEXT("Hyper Space"),},
//        {KEY_THROW,  DIMOUSE_BUTTON4, 0, TEXT("Launch Probe"),},
//        {KEY_THROW,  DIMOUSE_WHEEL, 0, TEXT("Next Level"),},
        };


//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------

BOOL CALLBACK EnumSuitableDevicesCallback(LPCDIDEVICEINSTANCE lpDIDI, LPDIRECTINPUTDEVICE8A pdiDev8A, DWORD dwFlags, DWORD dwDeviceRemaining,  LPVOID lpVoid)
{
	int* ppl = (int*)(lpVoid);
	int pl = *ppl;
	pdiDev8A->AddRef();
	g_pDevices[pl][g_dwNumDevices[pl]] = pdiDev8A;

	//set up the action map
	TCHAR Player [UNLEN+1] = "Player";
	TCHAR nr[10];
	strcat(Player, _itoa(pl+1, nr, 10));
	g_pDevices[pl][g_dwNumDevices[pl]]->BuildActionMap(&diActF, Player, 0);
	g_pDevices[pl][g_dwNumDevices[pl]]->SetActionMap(&diActF, Player, 0);

	g_dwNumDevices[pl]++;

	return TRUE;
}


HRESULT DIUtil_InitEnumHelper()
{
        HRESULT hr = S_OK;
	int pl, dv;

        if (g_pDI == NULL)
                return E_FAIL;

	for (pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
	{
		for (dv=0; dv<MAX_INPUT_DEVICES+1; dv++)
		{
			g_pDevices[pl][dv] = NULL;
		}
	}

        
        //DIACTIONFORMAT diActF;
        ZeroMemory(&diActF, sizeof(DIACTIONFORMAT));

        diActF.dwSize = sizeof(DIACTIONFORMAT);
        diActF.dwActionSize = sizeof(DIACTION);
        diActF.dwDataSize = NUMBER_OF_SEMANTICS * sizeof(DWORD);
        diActF.guidActionMap = g_AppGuid;
        diActF.dwGenre = DIVIRTUAL_FIGHTING_FPS;
        diActF.dwNumActions = NUMBER_OF_SEMANTICS;
        diActF.rgoAction = g_rgGameAction;
        diActF.lAxisMin = -100;
        diActF.lAxisMax = 100;
        diActF.dwBufferSize = 16;
	strcpy(diActF.tszActionMap, "TDonuts");

	//reset the number of devices
	for (pl = 0; pl < NUMBER_OF_PLAYERS; pl ++)
	{
		g_dwNumDevices[pl] = 0;
	}

	// Enumerate suitable DirectInput devices -- per player
	for (pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
	{
		TCHAR Player [UNLEN+1] = "Player";
		TCHAR nr[10];
		strcat(Player, _itoa(pl+1, nr, 10));
		hr = g_pDI->EnumDevicesBySemantics(Player, &diActF, EnumSuitableDevicesCallback, (LPVOID) &pl,
                             DIEDBSFL_THISUSER);
		if( FAILED(hr) )
			return hr;
	}
#define UI_USER_ASSIGNMENT
#ifndef UI_USER_ASSIGNMENT
	//hardcoding to test on my machine because no owner assignment in UI yet.
	//assign user 2 a device
	if (g_pDevices[0][2] != NULL)
	{
		g_pDevices[1][0] = g_pDevices[0][0];
		g_pDevices[0][0] = g_pDevices[0][g_dwNumDevices[0] - 1];
		g_pDevices[0][g_dwNumDevices[0] - 1] = NULL;
		g_dwNumDevices[0] --;
		g_dwNumDevices[1] ++;
	}
#endif

	//draw "ships" for all users
	UpdateShips();
        
	return hr;

}


//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Creates and initializes DirectInput objects
//-----------------------------------------------------------------------------
HRESULT DIUtil_Initialize( HWND hWnd )
{
    HRESULT hr;

    // Create the base DirectInput object
    hr = DirectInput8Create( (HINSTANCE)(GetWindowLongPtr( hWnd,GWLP_HINSTANCE )),
                                    DIRECTINPUT_VERSION, IID_IDirectInput8, (LPVOID*) &g_pDI, NULL );
	if( FAILED(hr) )
        return hr;


	//get and save the user name
	DWORD nBuffSize = UNLEN+1;
	if (!GetUserName(lpUserName, &nBuffSize))
	{
	   lstrcpy(lpUserName, "");
	}

    //enumerate and stuff
    hr = DIUtil_InitEnumHelper();
    if (FAILED(hr))
         return hr;


     //acquire all the devices
    for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
    {
	     for (int dv = 0; dv< (int) g_dwNumDevices[pl]; dv++)
	     {
		if (g_pDevices[pl][dv] != NULL)
		{
		     hr = g_pDevices[pl][dv]->Acquire();
		}
	     }
    }


     return S_OK;
}


HRESULT DIUtil_ReleaseDevices()
{
	HRESULT hr = S_OK;

	for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
	{
	     for (int dv = 0; dv< (int) g_dwNumDevices[pl]; dv++)
	     {
		if (g_pDevices[pl][dv] != NULL)
		{
		     g_pDevices[pl][dv]->Unacquire();
		     hr = g_pDevices[pl][dv]->Release();
		     g_pDevices[pl][dv] = NULL;
		}
	     }
	}


	return hr;
}

void DIUtil_ResetState()
{

   //unset the buttons in the persistent state
	for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl ++)
	{
		DWORD inputState = (dwInputState[pl] & AXIS_MASK);
		
		//blow out all of the axis data
		inputState &= ~(KEY_RIGHT);
		inputState &= ~(KEY_LEFT);
		inputState &= ~(KEY_UP);
		inputState &= ~(KEY_DOWN);

		dwInputState[pl] = inputState;
	}
}


HRESULT DIUtil_SetUpDevices()
{

	//first, release the devices
	HRESULT hr = S_OK;
	hr = DIUtil_ReleaseDevices();

	//reset the persisted state
	DIUtil_ResetState();
	
	//enumerate and stuff
	hr = DIUtil_InitEnumHelper();
	if (FAILED(hr))
        return hr;


	 //acquire all the devices
	 for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
	 {
		for (int dv = 0; dv< (int) g_dwNumDevices[pl]; dv++)
		{
			if (g_pDevices[pl][dv] != NULL)
			{
			     hr = g_pDevices[pl][dv]->Acquire();
			}
		     }
	}

	return hr;
}


HRESULT DIUtil_ConfigureDevices(HWND hWnd, IUnknown FAR * pddsDIConfig, DWORD dwFlags)
{
	HRESULT hr = S_OK;

	DICONFIGUREDEVICESPARAMS diconfparams;
	ZeroMemory(&diconfparams, sizeof(DICONFIGUREDEVICESPARAMS));

	//  for testing, have 2 user names
	TCHAR Names[MAX_PATH];  //BUGBUG this could be too small
	CHAR* lpNames = Names;
	for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl ++)
	{
		char buffer[10];
		_stprintf(lpNames, TEXT("%s%s%c"), "Player", _itoa(pl+1, buffer, 10), TEXT('\0'));
		if (pl < 9)
		{
			lpNames += 8;
		}
		else
		{
			//don't worry about more than 99 players
			lpNames += 9;
		}
	}
	//extra '\0'
	_stprintf(lpNames, TEXT("%c"), TEXT('\0'));

	//for testing, have 2 DIACTIONFORMATs
	DIACTIONFORMAT ActF[NUMBER_OF_ACTIONFORMATS];
	
    for( int i =0x0; i < NUMBER_OF_ACTIONFORMATS; i++)
    {
        ActF[i] = diActF;
    }
	
    //fill in all the params
	diconfparams.dwSize = sizeof(DICONFIGUREDEVICESPARAMS);
	diconfparams.dwcUsers = NUMBER_OF_PLAYERS;
	diconfparams.lptszUserNames = (LPTSTR)&Names;
	diconfparams.dwcFormats = NUMBER_OF_ACTIONFORMATS;
	diconfparams.lprgFormats = (LPDIACTIONFORMAT) &ActF;
	diconfparams.hwnd = hWnd;
	diconfparams.dics.dwSize = sizeof(DICOLORSET);
	diconfparams.lpUnkDDSTarget = pddsDIConfig;


	//unacquire the devices so that mouse doesn't control the game while in control panel
	for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
	{
	     for (int dv = 0; dv< (int) g_dwNumDevices[pl]; dv++)
	     {
		if (g_pDevices[pl][dv] != NULL)
		{
		     hr = g_pDevices[pl][dv]->Unacquire();
		}
	     }
	}

	//and reset the state, since no useful data is coming through anyway
	DIUtil_ResetState();

	//call ConfigureDevices with all the user names!
	switch (dwFlags)
	{
	case DICD_DEFAULT: default:
		{
			hr = g_pDI->ConfigureDevices((LPDICONFIGUREDEVICESCALLBACK)ConfigureDevicesCallback, &diconfparams, DICD_DEFAULT, NULL);

			//re-acquire the devices
			for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
			{
				for (int dv = 0; dv< (int) g_dwNumDevices[pl]; dv++)
				{
					if (g_pDevices[pl][dv] != NULL)
					{
						hr = g_pDevices[pl][dv]->Acquire();
					}
				}
			}

			break;
		}
	case DICD_EDIT:
		{
			hr = g_pDI->ConfigureDevices((LPDICONFIGUREDEVICESCALLBACK)ConfigureDevicesCallback, &diconfparams, DICD_EDIT, NULL);
			//re-set up the devices
			DIUtil_SetUpDevices();
			//re-set up ships
			UpdateShips();
			break;
		}
	}


	return hr;
}

//-----------------------------------------------------------------------------
// Name: DIUtil_CleanupDirectInput()
// Desc: Cleans up DirectInput objects
//-----------------------------------------------------------------------------
VOID DIUtil_CleanupDirectInput()
{
	//release devices
	DIUtil_ReleaseDevices();
	
	// Release() base object
	if( g_pDI )
	{
		g_pDI->Release();
	}
	g_pDI = NULL;

	//call CoUninitialize();
	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\ddutil.h ===
//-----------------------------------------------------------------------------
// File: ddutil.cpp
//
// Desc: Routines for loading bitmap and palettes from resources
//
// Copyright (C) 1998-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef DDUTIL_H
#define DDUTIL_H




LPDIRECTDRAWPALETTE  DDUtil_LoadPalette( LPDIRECTDRAW7 pDD, LPCSTR strBitmap );
LPDIRECTDRAWSURFACE7 DDUtil_LoadBitmap( LPDIRECTDRAW7 pDD, LPCSTR strBitmap,
										int dx, int dy );
HRESULT DDUtil_ReLoadBitmap( LPDIRECTDRAWSURFACE7 pdds, LPCSTR strBitmap );
HRESULT DDUtil_CopyBitmap( LPDIRECTDRAWSURFACE7 pdds, HBITMAP hbm, int x, int y,
					       int dx, int dy );
DWORD   DDUtil_ColorMatch( LPDIRECTDRAWSURFACE7 pdds, COLORREF rgb );
HRESULT DDUtil_SetColorKey( LPDIRECTDRAWSURFACE7 pdds, COLORREF rgb );




#endif // DDUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\diutil.h ===
//-----------------------------------------------------------------------------
// File: diutil.h
//
// Desc: DirectInput support
//
// Copyright (C) 1995-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef DIUTIL_H
#define DIUTIL_H
#include "dinput.h"
#include "lmcons.h"

#define MAX_INPUT_DEVICES 4
#define NUMBER_OF_PLAYERS 1
#define NUMBER_OF_ACTIONFORMATS 1

//for axes commands: AXIS_LR and AXIS_UD
#define AXIS_MASK   0x80000000l
#define AXIS_LR     (AXIS_MASK | 1)
#define AXIS_UD     (AXIS_MASK | 2)


// "Keyboard" commands
#define KEY_STOP    0x00000001l
#define KEY_DOWN    0x00000002l
#define KEY_LEFT    0x00000004l
#define KEY_RIGHT   0x00000008l
#define KEY_UP      0x00000010l
#define KEY_FIRE    0x00000020l
#define KEY_THROW   0x00000040l
#define KEY_SHIELD  0x00000080l
#define KEY_DISPLAY 0x00000100l
#define KEY_QUIT    0x00000200l
#define KEY_EDIT    0x00000400l

// Prototypes
HRESULT DIUtil_Initialize( HWND hWnd );
HRESULT DIUtil_ConfigureDevices(HWND hWnd, IUnknown FAR * pddsDIConfig, DWORD dwFlags);
VOID    DIUtil_CleanupDirectInput();
VOID	UpdateShips();


// Constants used for scaling the input device
#define DEADZONE         2500         // 25% of the axis range
#define RANGE_MAX        1000         // Maximum positive axis value
#define RANGE_MIN       -1000         // Minimum negative axis value




#endif //DIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\dsutil.h ===
//-----------------------------------------------------------------------------
// File: dsutil.cpp
//
// Desc: Routines for dealing with sounds from resources
//
// Copyright (C) 1995-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef DSUTIL_H
#define DSUTIL_H




//-----------------------------------------------------------------------------
// Helper routines
//-----------------------------------------------------------------------------
HRESULT DSUtil_FillSoundBuffer( LPDIRECTSOUNDBUFFER pDSB, BYTE* pbWaveData,
					            DWORD dwWaveSize );
HRESULT DSUtil_ParseWaveResource( VOID* pvRes, WAVEFORMATEX** ppWaveHeader,
						          BYTE** ppbWaveData, DWORD* pdwWaveSize );




//-----------------------------------------------------------------------------
// Name: DSUtil_LoadSoundBuffer()
// Desc: Loads an IDirectSoundBuffer from a Win32 resource in the current
//       application.
//-----------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER DSUtil_LoadSoundBuffer( LPDIRECTSOUND* pDS,
										    LPCTSTR strName );




//-----------------------------------------------------------------------------
// Name: DSUtil_ReloadSoundBuffer()
// Desc: Reloads an IDirectSoundBuffer from a Win32 resource in the current
//       application. normally used to handle a DSERR_BUFFERLOST error.
//-----------------------------------------------------------------------------
HRESULT DSUtil_ReloadSoundBuffer( LPDIRECTSOUNDBUFFER pDSB, LPCTSTR strName );




//-----------------------------------------------------------------------------
// Name: DSUtil_GetWaveResource()
// Desc: Finds a WAV resource in a Win32 module.
//-----------------------------------------------------------------------------
HRESULT DSUtil_GetWaveResource( HMODULE hModule, LPCTSTR strName,
                                WAVEFORMATEX** ppWaveHeader, BYTE** ppbWaveData,
				     		    DWORD* pdwWaveSize );




//-----------------------------------------------------------------------------
// Name: struct SoundObject
// Desc: Used to manage individual sounds which need to be played multiple
//       times concurrently.  A SoundObject represents a queue of
//       IDirectSoundBuffer objects which all refer to the same buffer memory.
//-----------------------------------------------------------------------------
struct SoundObject
{
    BYTE* pbWaveData;                 // Ptr into wave resource (for restore)
    DWORD cbWaveSize;                 // Size of wave data (for restore)
    DWORD dwNumBuffers;               // Number of sound buffers.
    DWORD dwCurrent;                  // Current sound buffer
    LPDIRECTSOUNDBUFFER* pdsbBuffers; // List of sound buffers
};




//-----------------------------------------------------------------------------
// Name: DSUtil_CreateSound()
// Desc: Loads a SoundObject from a Win32 resource in the current application.
//-----------------------------------------------------------------------------
SoundObject* DSUtil_CreateSound( LPDIRECTSOUND pDS, LPCTSTR strName,
								 DWORD dwNumConcurrentBuffers );




//-----------------------------------------------------------------------------
// Name: DSUtil_DestroySound()
// Desc: Frees a SoundObject and releases all of its buffers.
//-----------------------------------------------------------------------------
VOID DSUtil_DestroySound( SoundObject* pSound );




//-----------------------------------------------------------------------------
// Name: DSUtil_PlayPannedSound()
// Desc: Play a sound, but first set the panning according to where the
//       object is on the screen. fScreenXPos is between -1.0f (left) and
//       1.0f (right).
//-----------------------------------------------------------------------------
VOID DSUtil_PlayPannedSound( SoundObject* pSound, FLOAT fScreenXPos );




//-----------------------------------------------------------------------------
// Name: DSUtil_PlaySound()
// Desc: Plays a buffer in a SoundObject.
//-----------------------------------------------------------------------------
HRESULT DSUtil_PlaySound( SoundObject* pSound, DWORD dwPlayFlags );




//-----------------------------------------------------------------------------
// Name: DSUtil_StopSound()
// Desc: Stops one or more buffers in a SoundObject.
//-----------------------------------------------------------------------------
HRESULT DSUtil_StopSound( SoundObject* pSound );




//-----------------------------------------------------------------------------
// Name: DSUtil_GetFreeSoundBuffer()
// Desc: Returns one of the cloned buffers that is not currently playing
//-----------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER DSUtil_GetFreeSoundBuffer( SoundObject* pSound );




#endif // DSUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\dsutil.cpp ===
//-----------------------------------------------------------------------------
// File: dsutil.cpp
//
// Desc: Routines for dealing with sounds from resources
//
// Copyright (C) 1995-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dsutil.h"




//-----------------------------------------------------------------------------
// Name: DSUtil_LoadSoundBuffer()
// Desc:
//-----------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER DSUtil_LoadSoundBuffer( LPDIRECTSOUND pDS, LPCTSTR strName )
{
    LPDIRECTSOUNDBUFFER pDSB = NULL;
    DSBUFFERDESC        dsbd;
    BYTE*               pbWaveData;

	ZeroMemory( &dsbd, sizeof(dsbd) );
    dsbd.dwSize  = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_STATIC | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | 
                   DSBCAPS_CTRLFREQUENCY | DSBCAPS_GETCURRENTPOSITION2;

    if( SUCCEEDED( DSUtil_GetWaveResource( NULL, strName, &dsbd.lpwfxFormat,
		                                   &pbWaveData, &dsbd.dwBufferBytes ) ) )
    {

        if( SUCCEEDED( pDS->CreateSoundBuffer( &dsbd, &pDSB, NULL ) ) )
        {
            if( FAILED( DSUtil_FillSoundBuffer( pDSB, pbWaveData,
				                                dsbd.dwBufferBytes ) ) )
            {
	            pDSB->Release();
		        pDSB = NULL;
            }
        }
        else
        {
            pDSB = NULL;
        }
    }

    return pDSB;
}




//-----------------------------------------------------------------------------
// Name: DSUtil_ReloadSoundBuffer()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_ReloadSoundBuffer( LPDIRECTSOUNDBUFFER pDSB, LPCTSTR strName )
{
    BYTE* pbWaveData;
    DWORD cbWaveSize;

    if( FAILED( DSUtil_GetWaveResource( NULL, strName, NULL, &pbWaveData,
		                                &cbWaveSize ) ) )
		return E_FAIL;

    if( FAILED( pDSB->Restore() ) )
		return E_FAIL;

	if( FAILED( DSUtil_FillSoundBuffer( pDSB, pbWaveData, cbWaveSize ) ) )
		return E_FAIL;

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_GetWaveResource( HMODULE hModule, LPCTSTR strName,
                                WAVEFORMATEX** ppWaveHeader, BYTE** ppbWaveData,
							    DWORD* pcbWaveSize )
{
    HRSRC   hResInfo;
    HGLOBAL hResData;
    VOID*   pvRes;

    if( NULL == ( hResInfo = FindResource( hModule, strName, TEXT("WAV") ) ) )
		return E_FAIL;

	if( NULL == ( hResData = LoadResource( hModule, hResInfo ) ) )
		return E_FAIL;

	if( NULL == ( pvRes = LockResource( hResData ) ) )
		return E_FAIL;

	if(	FAILED( DSUtil_ParseWaveResource( pvRes, ppWaveHeader, ppbWaveData,
		                                  pcbWaveSize ) ) )
		return E_FAIL;

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
SoundObject* DSUtil_CreateSound( LPDIRECTSOUND pDS, LPCTSTR strName,
								 DWORD dwNumConcurrentBuffers )
{
    SoundObject*   pSound = NULL;
    LPWAVEFORMATEX pWaveHeader;
    BYTE*          pbData;
    DWORD          cbData;

	if( NULL == pDS )
		return NULL;

	if( dwNumConcurrentBuffers < 1 )
		dwNumConcurrentBuffers = 1;

    if( SUCCEEDED( DSUtil_GetWaveResource( NULL, strName, &pWaveHeader,
		                                   &pbData, &cbData ) ) )
    {
		pSound = new SoundObject;
		pSound->dwNumBuffers = dwNumConcurrentBuffers;
		pSound->pbWaveData   = pbData;
		pSound->cbWaveSize   = cbData;
		pSound->dwCurrent    = 0;
		pSound->pdsbBuffers  = new LPDIRECTSOUNDBUFFER[dwNumConcurrentBuffers+1];

		pSound->pdsbBuffers[0] = DSUtil_LoadSoundBuffer( pDS, strName );

		for( DWORD i=1; i<pSound->dwNumBuffers; i++ )
		{
			if( FAILED( pDS->DuplicateSoundBuffer( pSound->pdsbBuffers[0],
					                               &pSound->pdsbBuffers[i] ) ) )
			{
				pSound->pdsbBuffers[i] = DSUtil_LoadSoundBuffer( pDS, strName );
				if( NULL == pSound->pdsbBuffers[i] )
				{
					DSUtil_DestroySound( pSound );
					pSound = NULL;
					break;
				}
			}
		}
    }

    return pSound;
}




//-----------------------------------------------------------------------------
// Name: DSUtil_DestroySound()
// Desc: 
//-----------------------------------------------------------------------------
VOID DSUtil_DestroySound( SoundObject* pSound )
{
    if( pSound )
    {
		for( DWORD i=0; i<pSound->dwNumBuffers; i++ )
		{
			if( pSound->pdsbBuffers[i] )
				pSound->pdsbBuffers[i]->Release();
		}
		
		delete pSound->pdsbBuffers;
		delete pSound;
    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER DSUtil_GetFreeSoundBuffer( SoundObject* pSound )
{
	HRESULT hr;
	DWORD   dwStatus;

    if( NULL == pSound )
		return NULL;

    LPDIRECTSOUNDBUFFER pDSB = pSound->pdsbBuffers[pSound->dwCurrent];
	if( NULL == pDSB )
		return NULL;

	hr = pDSB->GetStatus( &dwStatus );
	if( FAILED(hr) )
		dwStatus = 0;

	if( dwStatus & DSBSTATUS_PLAYING )
	{
		if( pSound->dwNumBuffers <= 1 )
			return NULL;

		if( ++pSound->dwCurrent >= pSound->dwNumBuffers )
			pSound->dwCurrent = 0;

		pDSB = pSound->pdsbBuffers[pSound->dwCurrent];
		
		hr = pDSB->GetStatus( &dwStatus);
		if( FAILED(hr) )
			dwStatus = 0;

		if( dwStatus & DSBSTATUS_PLAYING )
		{
			pDSB->Stop();
			pDSB->SetCurrentPosition( 0 );
		}
	}

	if( dwStatus & DSBSTATUS_BUFFERLOST )
	{
		if( FAILED( pDSB->Restore() ) )
			return NULL;
			
		if( FAILED( DSUtil_FillSoundBuffer( pDSB, pSound->pbWaveData,
			                                pSound->cbWaveSize ) ) )
			return NULL;
	}

    return pDSB;
}




//-----------------------------------------------------------------------------
// Name: DSUtil_PlaySound()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_PlaySound( SoundObject* pSound, DWORD dwPlayFlags )
{
    if( NULL == pSound )
		return E_FAIL;

    if( !(dwPlayFlags & DSBPLAY_LOOPING) || (pSound->dwNumBuffers == 1) )
    {
		LPDIRECTSOUNDBUFFER pDSB = DSUtil_GetFreeSoundBuffer( pSound );
		if( pDSB )
		{
			if( SUCCEEDED( pDSB->Play( 0, 0, dwPlayFlags ) ) )
				return S_OK;
		}
    }

	return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: DSUtil_StopSound()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_StopSound( SoundObject* pSound )
{
    if( NULL == pSound )
		return E_FAIL;

    for( DWORD i=0; i<pSound->dwNumBuffers; i++ )
    {
	    pSound->pdsbBuffers[i]->Stop();
		pSound->pdsbBuffers[i]->SetCurrentPosition( 0 );
    }

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_FillSoundBuffer( LPDIRECTSOUNDBUFFER pDSB, BYTE* pbWaveData,
							    DWORD dwWaveSize )
{
	VOID* pMem1;
	VOID* pMem2;
	DWORD dwSize1;
	DWORD dwSize2;

    if( NULL == pDSB || NULL == pbWaveData || 0 == dwWaveSize )
		return E_FAIL;

	if( FAILED( pDSB->Lock( 0, dwWaveSize, &pMem1, &dwSize1, &pMem2,
			                &dwSize2, 0 ) ) )
		return E_FAIL;

	if( 0 != dwSize1 ) CopyMemory( pMem1, pbWaveData, dwSize1 );
	if( 0 != dwSize2 ) CopyMemory( pMem2, pbWaveData+dwSize1, dwSize2 );

	pDSB->Unlock( pMem1, dwSize1, pMem2, dwSize2);

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DSUtil_ParseWaveResource( VOID* pvRes, WAVEFORMATEX** ppWaveHeader,
							      BYTE** ppbWaveData, DWORD* pcbWaveSize )
{
    DWORD* pdw;
    DWORD* pdwEnd;
    DWORD  dwRiff;
    DWORD  dwType;
    DWORD  dwLength;

    if( ppWaveHeader )
		*ppWaveHeader = NULL;

    if( ppbWaveData )
		*ppbWaveData = NULL;

    if( pcbWaveSize )
		*pcbWaveSize = 0;

    pdw      = (DWORD*)pvRes;
    dwRiff   = *pdw++;
    dwLength = *pdw++;
    dwType   = *pdw++;

    if( dwRiff != mmioFOURCC('R', 'I', 'F', 'F') )
		return E_FAIL;

    if( dwType != mmioFOURCC('W', 'A', 'V', 'E') )
		return E_FAIL;

    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    while( pdw < pdwEnd )
    {
	    dwType   = *pdw++;
		dwLength = *pdw++;

		if( dwType == mmioFOURCC('f', 'm', 't', ' ') )
		{
			if (ppWaveHeader && !*ppWaveHeader)
			{
				if( dwLength < sizeof(WAVEFORMAT) )
					return E_FAIL;

			    *ppWaveHeader = (WAVEFORMATEX*)pdw;

			    if( (!ppbWaveData || *ppbWaveData) &&
					(!pcbWaveSize || *pcbWaveSize) )
				{
					return S_OK;
				}
			}
		}

		if( dwType == mmioFOURCC('d', 'a', 't', 'a') )
		{
			if( (ppbWaveData && !*ppbWaveData) ||
				(pcbWaveSize && !*pcbWaveSize) )
			{
				if( ppbWaveData )
					*ppbWaveData = (BYTE*)pdw;

				if( pcbWaveSize )
					*pcbWaveSize = dwLength;

			    if( !ppWaveHeader || *ppWaveHeader )
					return S_OK;
			}
		}

		pdw = (DWORD*)( (BYTE*)pdw + ((dwLength+1)&~1) );
    }

    return E_FAIL;
}





//-----------------------------------------------------------------------------
// Name: DSUtil_PlayPannedSound()
// Desc: Play a sound, but first set the panning according to where the
//       object is on the screen. fScreenXPos is between -1.0f (left) and
//       1.0f (right).
//-----------------------------------------------------------------------------
VOID DSUtil_PlayPannedSound( SoundObject* pSound, FLOAT fScreenXPos )
{
    LPDIRECTSOUNDBUFFER pDSB = DSUtil_GetFreeSoundBuffer( pSound );

    if( pDSB )
    {
		pDSB->SetPan( (LONG)( 10000.0f * fScreenXPos ) );
        pDSB->Play( 0, 0, 0 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\resource.h ===
#define DONUTS_ICON                 101

#define IDD_FORCE                   200
#define IDC_STRENGTHTEXT            201
#define IDC_CHILD                   202
#define IDC_ADULT                   203
#define IDC_BODYBUILDER             204

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\ffdonuts.h ===
//-----------------------------------------------------------------------------
// File: ffdonuts.h
//
// Desc: DirectInput ForceFeedback version of Donuts game
//
// Copyright (C) 1995-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef FFDONUTS_H
#define FFDONUTS_H


// Program states
enum{ PS_SPLASH, PS_ACTIVE, PS_BEGINREST, PS_REST };

// Game object types
enum{ OBJ_DONUT=0, OBJ_PYRAMID, OBJ_CUBE, OBJ_SPHERE, OBJ_SHIP, OBJ_BULLET };




// Object dimensions and fixed properties
#define MAX_SCREEN_X      (g_dwScreenWidth-1)
#define MAX_SCREEN_Y      (g_dwScreenHeight-1)

#define DONUT_WIDTH    64
#define DONUT_HEIGHT   64
#define PYRAMID_WIDTH  32
#define PYRAMID_HEIGHT 32
#define SPHERE_WIDTH   16
#define SPHERE_HEIGHT  16
#define CUBE_WIDTH     16
#define CUBE_HEIGHT    16
#define SHIP_WIDTH     32
#define SHIP_HEIGHT    32
#define BULLET_WIDTH    3
#define BULLET_HEIGHT   3

#define MAX_DONUT_FRAME   30
#define MAX_PYRAMID_FRAME 40
#define MAX_SPHERE_FRAME  40
#define MAX_CUBE_FRAME    40
#define MAX_SHIP_FRAME    40
#define MAX_BULLET_FRAME  400

#define BULLET_XOFFSET   304
#define BULLET_YOFFSET    0

#define NO_PLAYER        -1




//-----------------------------------------------------------------------------
// Name: struct DisplayObject
// Desc: A game object that goes in the display list
//-----------------------------------------------------------------------------
struct DisplayObject
{
    DisplayObject* next;     // Link to next object
    DisplayObject* prev;     // Link to previous object
	BOOL   bVisible;         // Whether the object is visible
    SHORT  type;             // Type of object
    FLOAT  posx, posy;       // X and y position
    FLOAT  velx, vely;       // X and y velocity (pixels/second)
    FLOAT  frame;            // Current animation frame
    FLOAT  delay;            // Frame/second
    RECT   rcSrc, rcDst;     // Source and destination rects
    LPDIRECTDRAWSURFACE7 pddsSurface; // Surface containing bitmap
	int    Player;			 //which player the pbject belongs to -- only for bullets and ships
};


FLOAT Dirx[40] =
{
    0.000000f,
    0.156434f,
    0.309017f,
    0.453991f,
    0.587785f,
    0.707107f,
    0.809017f,
    0.891007f,
    0.951057f,
    0.987688f,
    1.000000f,
    0.987688f,
    0.951057f,
    0.891007f,
    0.809017f,
    0.707107f,
    0.587785f,
    0.453990f,
    0.309017f,
    0.156434f,
    0.000000f,
    -0.156435f,
    -0.309017f,
    -0.453991f,
    -0.587785f,
    -0.707107f,
    -0.809017f,
    -0.891007f,
    -0.951057f,
    -0.987688f,
    -1.000000f,
    -0.987688f,
    -0.951056f,
    -0.891006f,
    -0.809017f,
    -0.707107f,
    -0.587785f,
    -0.453990f,
    -0.309017f,
    -0.156434f
};

FLOAT Diry[40] =
{
    -1.000000f,
    -0.987688f,
    -0.951057f,
    -0.891007f,
    -0.809017f,
    -0.707107f,
    -0.587785f,
    -0.453990f,
    -0.309017f,
    -0.156434f,
    0.000000f,
    0.156434f,
    0.309017f,
    0.453991f,
    0.587785f,
    0.707107f,
    0.809017f,
    0.891007f,
    0.951057f,
    0.987688f,
    1.000000f,
    0.987688f,
    0.951057f,
    0.891006f,
    0.809017f,
    0.707107f,
    0.587785f,
    0.453990f,
    0.309017f,
    0.156434f,
    0.000000f,
    -0.156435f,
    -0.309017f,
    -0.453991f,
    -0.587785f,
    -0.707107f,
    -0.809017f,
    -0.891007f,
    -0.951057f,
    -0.987688f
};




//-----------------------------------------------------------------------------
// Function prototypes
//-----------------------------------------------------------------------------
HRESULT InitializeGame( HWND hWnd );
HRESULT InitializeSound( HWND hWnd );
HRESULT InitializeInput( HWND hWnd );
VOID    DestroyGame();
VOID    DestroySound();
VOID    DestroyInput();


VOID    UpdateFrame(LPDIRECTDRAWSURFACE7 lpddsConfigDlg = NULL);
VOID    CleanupAndDisplayError( CHAR* strError );
HRESULT RestoreSurfaces();
BOOL    IsDisplayListEmpty();
BOOL    IsDisplayListEmptyExceptShips();
VOID    InitializeShips();
VOID    AdvanceLevel();
VOID    UpdateDisplayList();
VOID    DrawDisplayList(LPDIRECTDRAWSURFACE7 lpConfigDlgSurf = NULL);
FLOAT   rnd( FLOAT low=-1.0f, FLOAT high=1.0f );
VOID    CheckForHits();
VOID    BltBitmappedText( CHAR* strScore, int x, int y );
HRESULT DisplaySplashScreen();
VOID    EraseScreen();
HRESULT FlipScreen();
VOID    DisplayLevelIntroScreen( DWORD dwLevel );

DisplayObject* CreateObject( SHORT type, FLOAT x, FLOAT y, FLOAT vx, FLOAT vy, int Player );
VOID    AddToList( DisplayObject* pObject );
VOID    DeleteFromList( DisplayObject* pObject );

VOID   GetDeviceInput(DWORD input[]);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\ffdonuts.cpp ===
//-----------------------------------------------------------------------------
// File: ffdonuts.cpp
//
// Desc: DirectInput Semantic Mapper version of Donuts game
//
// Copyright (C) 1995-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#define STRICT
#define INITGUID
#include <windows.h>
#include <cguid.h>
#include <mmsystem.h>
#include <ddraw.h>
#include <dsound.h>
#include <stdio.h>
#include "DDUtil.h"
#include "DIUtil.h"
#include "DSUtil.h"
#include "resource.h"
#include "ffdonuts.h"


// DirectDraw objects
LPDIRECTDRAW7        g_pDD             = NULL;
LPDIRECTDRAWPALETTE  g_pArtPalette     = NULL;
LPDIRECTDRAWPALETTE  g_pSplashPalette  = NULL;
LPDIRECTDRAWSURFACE7 g_pddsFrontBuffer = NULL;
LPDIRECTDRAWSURFACE7 g_pddsBackBuffer  = NULL;
LPDIRECTDRAWSURFACE7 g_pddsDonut       = NULL;
LPDIRECTDRAWSURFACE7 g_pddsPyramid     = NULL;
LPDIRECTDRAWSURFACE7 g_pddsCube        = NULL;
LPDIRECTDRAWSURFACE7 g_pddsSphere      = NULL;
LPDIRECTDRAWSURFACE7 g_pddsShip        = NULL;
LPDIRECTDRAWSURFACE7 g_pddsNumbers     = NULL;
LPDIRECTDRAWSURFACE7 g_pddsDIConfig    = NULL;

// DirectSound and DSUtil sound objects
LPDIRECTSOUND g_pDS                  = NULL;
SoundObject*  g_pBeginLevelSound     = NULL;
SoundObject*  g_pEngineIdleSound     = NULL;
SoundObject*  g_pEngineRevSound      = NULL;
SoundObject*  g_pSkidToStopSound     = NULL;
SoundObject*  g_pShieldBuzzSound     = NULL;
SoundObject*  g_pShipExplodeSound    = NULL;
SoundObject*  g_pFireBulletSound     = NULL;
SoundObject*  g_pShipBounceSound     = NULL;
SoundObject*  g_pDonutExplodeSound   = NULL;
SoundObject*  g_pPyramidExplodeSound = NULL;
SoundObject*  g_pCubeExplodeSound    = NULL;
SoundObject*  g_pSphereExplodeSound  = NULL;

#if 0 //not used for mapper
BOOL    g_bEngineIdle = FALSE;
BOOL    g_bShieldsOn  = FALSE;
BOOL    g_bThrusting  = FALSE;

DWORD   lastInput        = 0;
BOOL    g_bLastShield    = FALSE;
#endif //not used for mapper
BOOL    lastThrust       = FALSE;
FLOAT   g_fShowDelay     = 0.0f;
HWND    g_hWndMain;
BOOL    g_bIsActive;
BOOL    g_bIsReady       = FALSE;
BOOL    g_bMouseVisible;
DWORD   g_dwLastTickCount;
DWORD   g_dwScore        = 0;
int     g_ProgramState;
DWORD   g_dwLevel        = 0;
DWORD   g_dwFillColor;
BOOL    g_bLeaveTrails   = FALSE;
DWORD   g_dwScreenWidth  = 1024;
DWORD   g_dwScreenHeight = 768;
DWORD   g_dwScreenDepth  = 16;
BOOL    g_bSoundEnabled  = FALSE;

DisplayObject* g_pDisplayList = NULL; // Display List
DisplayObject* g_pShip        = NULL; // Main ship
DisplayObject* g_pShipsArray[NUMBER_OF_PLAYERS]; //array for all the players' ships

extern IDirectInput8*       g_pDI;    // DirectInput object
extern DWORD g_dwNumDevices[NUMBER_OF_PLAYERS];
extern IDirectInputDevice8* g_pDevices[NUMBER_OF_PLAYERS][MAX_INPUT_DEVICES+1];
extern DIACTIONFORMAT diActF;
extern LPTSTR lpUserName;
DWORD dwInputState[NUMBER_OF_PLAYERS]; //to persist the input state


BOOL CALLBACK ConfigureDevicesCallback(LPVOID lpVoid, LPVOID lpUserData)
{
        UpdateFrame((LPDIRECTDRAWSURFACE7)lpVoid);
        return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SetupGame()
// Desc:
//-----------------------------------------------------------------------------
VOID SetupGame()
{
    AdvanceLevel();

    // Set the palette
    g_pddsFrontBuffer->SetPalette( g_pArtPalette );
}




//-----------------------------------------------------------------------------
// Name: MainWndproc()
// Desc: Callback for all Windows messages
//-----------------------------------------------------------------------------
long FAR PASCAL MainWndproc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC         hdc;

    switch( msg )
    {
        case WM_ACTIVATEAPP:
            g_bIsActive = (BOOL) wParam;
            if( g_bIsActive )
            {
                g_bMouseVisible   = FALSE;
                g_dwLastTickCount = GetTickCount();
                g_bLeaveTrails    = FALSE;

                // Need to reacquire the device
#if 0 //not used in the Semantic Mapper demo
                if( g_pdidJoystick )
                    g_pdidJoystick->Acquire();
#endif //not used in the Semantic Mapper demo
            }
            else
            {
                g_bMouseVisible = TRUE;
            }
            break;

        case WM_CREATE:
            break;

        case WM_SETCURSOR:
            if( !g_bMouseVisible && g_bIsReady )
                SetCursor(NULL);
            else
                SetCursor(LoadCursor( NULL, IDC_ARROW ));
            return TRUE;

        case WM_KEYDOWN:
            switch( wParam )
            {
                case VK_F3:
                    if( g_bSoundEnabled )
                        DestroySound();
                    else
                        InitializeSound( hWnd );

                    break;
                             
           
                case VK_ESCAPE:
                case VK_F12:
                    PostMessage( hWnd, WM_CLOSE, 0, 0 );
                    return 0;

                case VK_F1:
                    g_bLeaveTrails = !g_bLeaveTrails;
                    break;

                case VK_F2:
		{
					
			DIUtil_ConfigureDevices(hWnd, g_pddsDIConfig, DICD_DEFAULT);
			break;

		}
		case VK_F4:
		{
			DIUtil_ConfigureDevices(hWnd, g_pddsDIConfig, DICD_EDIT);
			break;
		}
                 }
            break;

#if 0 //not used in the Semantic Mapper demo
        case WM_KEYUP:
            switch( wParam )
            {
                case VK_NUMPAD7:
                    lastInput &= ~KEY_SHIELD;
                    break;
                case VK_NUMPAD5:
                    lastInput &= ~KEY_STOP;
                    break;
                case VK_DOWN:
                case VK_NUMPAD2:
                    lastInput &= ~KEY_DOWN;
                    break;
                case VK_LEFT:
                case VK_NUMPAD4:
                    lastInput &= ~KEY_LEFT;
                    break;
                case VK_RIGHT:
                case VK_NUMPAD6:
                    lastInput &= ~KEY_RIGHT;
                    break;
                case VK_UP:
                case VK_NUMPAD8:
                    lastInput &= ~KEY_UP;
                    break;
                case VK_NUMPAD3:
                    lastInput &= ~KEY_THROW;
                    break;
                case VK_SPACE:
                    lastInput &= ~KEY_FIRE;
                    break;

            }
            break;
#endif //not used in the Semantic Mapper demo

        case WM_ERASEBKGND:
            return 1;

        case WM_PAINT:
            hdc = BeginPaint( hWnd, &ps );
            EndPaint( hWnd, &ps );
            return 1;

        case WM_DESTROY:
#if 0 //not used for mapper
            lastInput=0;
#endif //not used for mapper
            DestroyGame();
            PostQuitMessage( 0 );
            break;
    }

    return (LONG) DefWindowProc( hWnd, msg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Application entry point
//-----------------------------------------------------------------------------
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow )
{

    // Register the window class
    WNDCLASS wndClass = { CS_DBLCLKS, (WNDPROC)MainWndproc, 0, 0, hInstance,
                          LoadIcon( hInstance, MAKEINTRESOURCE(DONUTS_ICON) ),
                          LoadCursor( NULL, IDC_ARROW ),
                          (HBRUSH)GetStockObject( BLACK_BRUSH ),
                          NULL, TEXT("DonutsClass") };
    RegisterClass( &wndClass );

    // Create our main window
    g_hWndMain = CreateWindowEx( 0, TEXT("DonutsClass"), TEXT("Donuts"),
                                 WS_VISIBLE|WS_POPUP|WS_CAPTION|WS_SYSMENU,
                                 0, 0, GetSystemMetrics(SM_CXSCREEN),
                                 GetSystemMetrics(SM_CYSCREEN), NULL, NULL,
                                 hInstance, NULL );
    if( NULL == g_hWndMain )
        return FALSE;
    UpdateWindow( g_hWndMain );

    g_bIsReady  = TRUE;

    if( FAILED( InitializeGame( g_hWndMain ) ) )
    {
        DestroyWindow( g_hWndMain );
        return FALSE;
    }

    while( 1 )
    {
        MSG msg;

        if( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )
        {
            if( FALSE == GetMessage( &msg, NULL, 0, 0 ) )
                return (int) msg.wParam;

            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else if( g_bIsActive )
        {
            UpdateFrame();
        }
        else
        {
            WaitMessage();
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DestroyGame()
// Desc:
//-----------------------------------------------------------------------------
VOID DestroyGame()
{
    DestroySound();
    DestroyInput();
}

//-----------------------------------------------------------------------------
// Name: UpdateShips()
// Desc:
//-----------------------------------------------------------------------------
VOID UpdateShips()
{
	//the main ship will always be there
	//but update all the others, based on whether
	//the particular user has any devices
	for (int pl = 1; pl < NUMBER_OF_PLAYERS; pl ++)
	{
		//if the corresponding player is still playing
		if (g_pDevices[pl][0] != NULL)
		{
			//if not created already, create new
			if (g_pShipsArray[pl] == NULL)
			{
				g_pShipsArray[pl] = CreateObject(OBJ_SHIP, (FLOAT)(g_dwScreenWidth/(pl+1)-16), (FLOAT)(g_dwScreenHeight/(pl+1)-16), 0, 0, pl);
			}
			//if already created, keep it
		}
		else //player is gone
		{
			//if there is a ship for this player, delete it
			if (g_pShipsArray[pl] != NULL)
			{	
				DeleteFromList(g_pShipsArray[pl]);
				g_pShipsArray[pl] = NULL;
			}
		}

	}
}


//-----------------------------------------------------------------------------
// Name: InitializeGame()
// Desc:
//-----------------------------------------------------------------------------
HRESULT InitializeGame( HWND hWnd )
{
    LPDIRECTDRAW    pDD;
    HRESULT         hr;
    DDSURFACEDESC2  ddsd;

    // Create DirectDraw
    if( SUCCEEDED( hr = DirectDrawCreate( NULL, &pDD, NULL ) ) )
    {
        // Get DirectDraw4 interface
        hr = pDD->QueryInterface( IID_IDirectDraw7, (VOID**)&g_pDD );
        pDD->Release();
    }
    if( FAILED(hr) )
    {
        CleanupAndDisplayError("DirectDrawCreate Failed!");
        return E_FAIL;
    }

    // Set the cooperative level for fullscreen mode
    hr = g_pDD->SetCooperativeLevel( hWnd,
                            DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN );
    if( FAILED(hr) )
    {
        CleanupAndDisplayError("SetCooperativeLevel Failed");
        return E_FAIL;
    }

    // Set the display mode
    hr = g_pDD->SetDisplayMode( g_dwScreenWidth, g_dwScreenHeight,
                                g_dwScreenDepth, 0, 0 );
    if( FAILED(hr) )
    {
        CleanupAndDisplayError("SetDisplayMode Failed!");
        return E_FAIL;
    }

    // Create surfaces
    ZeroMemory( &ddsd, sizeof( ddsd ) );
    ddsd.dwSize         = sizeof( ddsd );
    ddsd.dwFlags        = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP |
                          DDSCAPS_COMPLEX;
    ddsd.dwBackBufferCount = 1;

    // Create the front buffer
    hr = g_pDD->CreateSurface( &ddsd, &g_pddsFrontBuffer, NULL );
    if( FAILED(hr) )
    {
        CleanupAndDisplayError("CreateSurface FrontBuffer Failed!");
        return E_FAIL;
    }

    // Get a pointer to the back buffer
    DDSCAPS2 ddscaps;
    ddscaps.dwCaps  = DDSCAPS_BACKBUFFER;
    ddscaps.dwCaps2 = 0;
    ddscaps.dwCaps3 = 0;
    ddscaps.dwCaps4 = 0;
    hr = g_pddsFrontBuffer->GetAttachedSurface( &ddscaps, &g_pddsBackBuffer );
    if( FAILED(hr) )
    {
        CleanupAndDisplayError("GetAttachedSurface Failed!");
        return E_FAIL;
    }

    ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth        = 320;

    // Create the surfaces for the object images. (We're OR'ing the HRESULTs
    // together, so we only need to check for failure once).
    ddsd.dwHeight = 384;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsDonut, NULL );

    ddsd.dwHeight = 128;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsPyramid, NULL );

    ddsd.dwHeight = 32;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsCube, NULL );

    ddsd.dwHeight = 32;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsSphere, NULL );

    ddsd.dwHeight = 256;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsShip, NULL );

    ddsd.dwHeight = 16;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsNumbers, NULL );

    ddsd.dwWidth = 640;
    ddsd.dwHeight = 480;
    hr |= g_pDD->CreateSurface( &ddsd, &g_pddsDIConfig, NULL );

    if( FAILED(hr) )
    {
        CleanupAndDisplayError("Could not create surfaces!");
        return E_FAIL;
    }

    if( FAILED( RestoreSurfaces() ) )
    {
        CleanupAndDisplayError("RestoreSurfaces Failed!");
        return E_FAIL;
    }

    //zero out the ship ptrs
    for (int ship = 0; ship < NUMBER_OF_PLAYERS; ship++)
    {
	g_pShipsArray[ship] = NULL;
    }

    // Add a ship to the displaylist
    g_pDisplayList = new DisplayObject;
    g_pDisplayList->next        = NULL;
    g_pDisplayList->prev        = NULL;
    g_pDisplayList->type        = OBJ_SHIP;
    g_pDisplayList->pddsSurface = g_pddsShip;
    g_pShip = g_pDisplayList;

    //and save the ptr
    g_pShipsArray[0] = g_pShip;

    //initialize input
    for (ship = 0; ship < NUMBER_OF_PLAYERS; ship ++)
    {
	dwInputState[ship] = 0;
    }

    g_dwLastTickCount = GetTickCount();

    if( FAILED( InitializeInput( hWnd ) ) )
        return E_FAIL;
    //if( FAILED( InitializeSound( hWnd ) ) )
    //    return E_FAIL;

    g_ProgramState = PS_SPLASH;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CleanupAndDisplayError()
// Desc:
//-----------------------------------------------------------------------------
VOID CleanupAndDisplayError( CHAR* strError )
{
    CHAR buffer[80];
    sprintf( buffer, "Error: %s\n", strError );
    OutputDebugString( buffer );

    // Make the cursor visible
    SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    g_bMouseVisible = TRUE;

    if( g_pddsDonut )
        g_pddsDonut->Release();

    if( g_pddsPyramid )
        g_pddsPyramid->Release();

    if( g_pddsCube )
        g_pddsCube->Release();

    if( g_pddsSphere )
        g_pddsSphere->Release();

    if( g_pddsShip )
        g_pddsShip->Release();

    if( g_pddsNumbers )
        g_pddsNumbers->Release();

    if( g_pddsDIConfig )
        g_pddsDIConfig->Release();

    if( g_pddsFrontBuffer )
        g_pddsFrontBuffer->Release();

    if( g_pArtPalette )
        g_pArtPalette->Release();

    if( g_pSplashPalette )
        g_pSplashPalette->Release();

    if( g_pDD )
        g_pDD->Release();

    MessageBox( g_hWndMain, strError, "ERROR", MB_OK );
}




//-----------------------------------------------------------------------------
// Name: DisplaySplashScreen()
// Desc:
//-----------------------------------------------------------------------------
HRESULT DisplaySplashScreen()
{
    HBITMAP hbm;
    hbm = (HBITMAP)LoadImage( GetModuleHandle( NULL ), "SPLASH", IMAGE_BITMAP,
                              0, 0, LR_CREATEDIBSECTION );
    if( NULL == hbm )
        return E_FAIL;

    // Set the palette before loading the splash screen
    g_pddsFrontBuffer->SetPalette( g_pSplashPalette );

    // If the surface is lost, DDCopyBitmap will fail and the surface will
    // be restored in FlipScreen().
    DDUtil_CopyBitmap( g_pddsBackBuffer, hbm, 0, 0, 0, 0 );

    // Done with the bitmap
    DeleteObject( hbm );

    // Show the backbuffer contents on the frontbuffer
    if( FAILED( FlipScreen() ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PlayPannedSound()
// Desc: Play a sound, but first set the panning according to where the
//       object is on the screen.
//-----------------------------------------------------------------------------
VOID PlayPannedSound( SoundObject* pSound, DisplayObject* pObject )
{
    if( NULL == pObject )
        return;

    DWORD dwCenter = ( pObject->rcDst.right + pObject->rcDst.left ) / 2;
    FLOAT fCenter  = ( 2.0f * ((FLOAT)dwCenter)/g_dwScreenWidth ) - 1.0f;

    DSUtil_PlayPannedSound( pSound, fCenter );
}




//-----------------------------------------------------------------------------
// Name: UpdateFrame()
// Desc:
//-----------------------------------------------------------------------------
VOID UpdateFrame(LPDIRECTDRAWSURFACE7 lpddsConfigDlg)
{
    static FLOAT fLevelIntroTime;

    switch( g_ProgramState )
    {
        case PS_SPLASH:
            // Display the splash screen
            //DisplaySplashScreen();
            g_ProgramState = PS_BEGINREST;
            SetupGame();

            break;

        case PS_ACTIVE:
            UpdateDisplayList();
            CheckForHits();
            DrawDisplayList(lpddsConfigDlg);

            if( IsDisplayListEmptyExceptShips() )
            {
                DSUtil_StopSound( g_pEngineIdleSound );
                DSUtil_StopSound( g_pEngineRevSound );

#if 0 //not used for the mulit-user mapper
                g_bEngineIdle  = FALSE;
                g_bThrusting   = FALSE;
                lastThrust     = FALSE;
                g_bLastShield  = FALSE;
#endif //not used for the mulit-user mapper
                g_ProgramState = PS_BEGINREST;
                AdvanceLevel();
            }
            break;

        case PS_BEGINREST:
            DSUtil_PlaySound(g_pBeginLevelSound, 0);
            fLevelIntroTime = GetTickCount()/1000.0f;
            g_ProgramState  = PS_REST;

            // Fall through to PS_REST state

        case PS_REST:
            // Show the Level intro screen for 3 seconds
            if( ( GetTickCount()/1000.0f - fLevelIntroTime ) > 3.0f )
            {
                DSUtil_PlaySound( g_pEngineIdleSound, DSBPLAY_LOOPING );
#if 0 //not used for the mulit-user mapper
                g_bEngineIdle     = TRUE;
#endif //not used for the mulit-user mapper
                g_dwLastTickCount = GetTickCount();
                g_ProgramState    = PS_ACTIVE;
            }
            else
            {
                DisplayLevelIntroScreen( g_dwLevel );
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayLevelIntroScreen()
// Desc:
//-----------------------------------------------------------------------------
VOID DisplayLevelIntroScreen( DWORD dwLevel )
{
    // Erase the screen
    EraseScreen();

    // Output the bitmapped letters for the word "Level"
    CHAR buffer[10];
    buffer[0] = 10 + '0';
    buffer[1] = 11 + '0';
    buffer[2] = 12 + '0';
    buffer[3] = 11 + '0';
    buffer[4] = 10 + '0';
    buffer[5] = '\0';
    BltBitmappedText( buffer, g_dwScreenWidth/2-64, g_dwScreenHeight/2-8 );

    // Output the bitmapped numbers for the level number
    buffer[0] = (CHAR)(dwLevel/100) + '0';
    buffer[1] = (CHAR)(dwLevel/ 10) + '0';
    buffer[2] = (CHAR)(dwLevel% 10) + '0';
    buffer[3] = '\0';
    BltBitmappedText( buffer, g_dwScreenWidth/2+22, g_dwScreenHeight/2-8 );

    // Show the backbuffer screen on the front buffer
    FlipScreen();
}




//-----------------------------------------------------------------------------
// Name: BltBitmappedText()
// Desc:
//-----------------------------------------------------------------------------
VOID BltBitmappedText( CHAR* num, int x, int y )
{
    for( CHAR* c = num; *c != '\0'; c++ )
    {
        HRESULT hr = DDERR_WASSTILLDRAWING;
        RECT    rcSrc;

        rcSrc.left   = (*c - '0')*16;
        rcSrc.top    = 0;
        rcSrc.right  = rcSrc.left + 16;
        rcSrc.bottom = rcSrc.top + 16;

        while( hr == DDERR_WASSTILLDRAWING )
        {
            hr = g_pddsBackBuffer->BltFast( x, y, g_pddsNumbers, &rcSrc,
                                            DDBLTFAST_SRCCOLORKEY );
        }

        x += 16;
    }
}




//-----------------------------------------------------------------------------
// Name: CheckForHits()
// Desc:
//-----------------------------------------------------------------------------
VOID CheckForHits()
{
    DisplayObject* pObject;
    DisplayObject* bullet;

    // Update screen rects
    for( pObject = g_pDisplayList; pObject; pObject = pObject->next )
    {
        int frame = (DWORD)pObject->frame;

        switch( pObject->type )
        {
            case OBJ_DONUT:
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + DONUT_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + DONUT_HEIGHT;
                pObject->rcSrc.left   = DONUT_WIDTH * (frame % 5);
                pObject->rcSrc.top    = DONUT_HEIGHT * (frame /5);
                pObject->rcSrc.right  = pObject->rcSrc.left + DONUT_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + DONUT_HEIGHT;
                break;

            case OBJ_PYRAMID:
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + PYRAMID_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + PYRAMID_HEIGHT;
                pObject->rcSrc.left   = PYRAMID_WIDTH * (frame % 10);
                pObject->rcSrc.top    = PYRAMID_HEIGHT * (frame /10);
                pObject->rcSrc.right  = pObject->rcSrc.left + PYRAMID_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + PYRAMID_HEIGHT;
                break;

            case OBJ_SPHERE:
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + SPHERE_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + SPHERE_HEIGHT;
                pObject->rcSrc.left   = SPHERE_WIDTH * (frame % 20);
                pObject->rcSrc.top    = SPHERE_HEIGHT * (frame /20);
                pObject->rcSrc.right  = pObject->rcSrc.left + SPHERE_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + SPHERE_HEIGHT;
                break;
            case OBJ_CUBE:
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + CUBE_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + CUBE_HEIGHT;
                pObject->rcSrc.left   = CUBE_WIDTH * (frame % 20);
                pObject->rcSrc.top    = CUBE_HEIGHT * (frame /20);
                pObject->rcSrc.right  = pObject->rcSrc.left + CUBE_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + CUBE_HEIGHT;
                break;

            case OBJ_SHIP:
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + SHIP_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + SHIP_HEIGHT;
#if 0 //not used for the mulit-user mapper
                if( g_bLastShield )
                    pObject->rcSrc.top = SHIP_HEIGHT * (frame / 10) + 128;
                else
#endif //not used for the mulit-user mapper
                    pObject->rcSrc.top = SHIP_HEIGHT * (frame /10);
                pObject->rcSrc.left   = SHIP_WIDTH * (frame % 10);
                pObject->rcSrc.right  = pObject->rcSrc.left + SHIP_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + SHIP_HEIGHT;
                break;

            case OBJ_BULLET:
                frame = (DWORD)pObject->frame/20 % 4;
                pObject->rcDst.left   = (DWORD)pObject->posx;
                pObject->rcDst.top    = (DWORD)pObject->posy;
                pObject->rcDst.right  = pObject->rcDst.left + BULLET_WIDTH;
                pObject->rcDst.bottom = pObject->rcDst.top + BULLET_HEIGHT;
                pObject->rcSrc.left   = BULLET_XOFFSET + frame*4;
                pObject->rcSrc.top    = BULLET_YOFFSET;
                pObject->rcSrc.right  = pObject->rcSrc.left + BULLET_WIDTH;
                pObject->rcSrc.bottom = pObject->rcSrc.top + BULLET_HEIGHT;
                break;
        }
    }
    for( bullet = g_pDisplayList; bullet; bullet = bullet->next )
    {
        // Only bullet objects and the ship (if shields are on) can hit
        // other objects. Skip all others.
        if( (bullet->type != OBJ_BULLET) && (bullet->type != OBJ_SHIP) )
            continue;

#if 0 //not used for the mulit-user mapper
        // The ship cannot hit anything with shields on
        if( bullet->type == OBJ_SHIP && TRUE == g_bLastShield )
            continue;
#endif //not used for the mulit-user mapper

        BOOL bBulletHit = FALSE;
        WORD wBulletX   = (WORD)(bullet->rcDst.left + bullet->rcDst.right) / 2;
        WORD wBulletY   = (WORD)(bullet->rcDst.top + bullet->rcDst.bottom) / 2;

        for( pObject = g_pDisplayList; pObject; pObject = pObject->next )
        {
            FLOAT left   = (FLOAT)pObject->rcDst.left;
            FLOAT right  = (FLOAT)pObject->rcDst.right;
            FLOAT top    = (FLOAT)pObject->rcDst.top;
            FLOAT bottom = (FLOAT)pObject->rcDst.bottom;

            // Only trying to hit explodable targets
            if( ( pObject->type != OBJ_DONUT ) &&
                ( pObject->type != OBJ_PYRAMID ) &&
                ( pObject->type != OBJ_SPHERE ) &&
				( pObject->type != OBJ_SHIP ) &&
                ( pObject->type != OBJ_CUBE ) )
                continue;

            if( ( wBulletX >= left ) && ( wBulletX < right ) &&
                ( wBulletY >= top ) && ( wBulletY < bottom ) )
            {
                // The object was hit
                switch( pObject->type )
                {
                    case OBJ_DONUT:
                        PlayPannedSound( g_pDonutExplodeSound, pObject );
                        CreateObject( OBJ_PYRAMID, left, top, -1.0f, -1.0f, NO_PLAYER);
                        CreateObject( OBJ_PYRAMID, left, top, -1.0f, -1.0f, NO_PLAYER );
                        CreateObject( OBJ_PYRAMID, left, top, -1.0f, -1.0f, NO_PLAYER );
                        g_dwScore += 10;
                        break;

                    case OBJ_PYRAMID:
                        PlayPannedSound( g_pPyramidExplodeSound, pObject );
                        CreateObject( OBJ_SPHERE, left, top, -1.0f, -1.0f, NO_PLAYER );
                        CreateObject( OBJ_CUBE,   left, top, -1.0f, -1.0f, NO_PLAYER );
                        CreateObject( OBJ_CUBE,   left, top, -1.0f, -1.0f, NO_PLAYER );
                        g_dwScore += 20;
                        break;

                    case OBJ_CUBE:
                        PlayPannedSound( g_pCubeExplodeSound, pObject );
                        CreateObject( OBJ_SPHERE, left, top, -1.0f, -1.0f, NO_PLAYER );
                        CreateObject( OBJ_SPHERE, left, top, -1.0f, -1.0f, NO_PLAYER );
                        g_dwScore += 40;
                        break;

                    case OBJ_SPHERE:
                        PlayPannedSound( g_pSphereExplodeSound, pObject );
                        g_dwScore += 20;
                        break;

					case OBJ_SHIP:
						//can't be hit by bullets that come from us
						if (bullet->Player != pObject->Player)
						{
						if(pObject->bVisible )
						{
							// Ship has exploded
							PlayPannedSound( g_pShipExplodeSound, pObject);
							if( g_dwScore < 150 )
								g_dwScore = 0;
							else
								g_dwScore -= 150;

							FLOAT x = pObject->posx;
							FLOAT y = pObject->posy;

							CreateObject( OBJ_SPHERE, x, y, -1.0f, -1.0f, NO_PLAYER);
							CreateObject( OBJ_SPHERE, x, y, -1.0f, -1.0f, NO_PLAYER);
							CreateObject( OBJ_SPHERE, x, y, -1.0f, -1.0f, NO_PLAYER);
							CreateObject( OBJ_SPHERE, x, y, -1.0f, -1.0f, NO_PLAYER);
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );
							CreateObject( OBJ_BULLET, x, y, rnd()/2, rnd()/2, bullet->Player );

							// Delay for 2 seconds before displaying ship
							InitializeShips();
							g_fShowDelay = 2.0f;
							pObject->bVisible = FALSE;
							}
						}
						break;

                }


				//only delete non-"ships"
				if (pObject->type != OBJ_SHIP)
				{
					DisplayObject* pVictim = pObject;
					pObject = pObject->prev;
					DeleteFromList( pVictim );
					bBulletHit = TRUE;
				}
            }
        }

    }
}




//-----------------------------------------------------------------------------
// Name: EraseScreen()
// Desc:
//-----------------------------------------------------------------------------
VOID EraseScreen()
{
    // Erase the background
    DDBLTFX ddbltfx;
    ZeroMemory( &ddbltfx, sizeof(ddbltfx) );
    ddbltfx.dwSize      = sizeof(ddbltfx);
    ddbltfx.dwFillColor = g_dwFillColor;

    while( 1 )
    {
        HRESULT hr = g_pddsBackBuffer->Blt( NULL, NULL, NULL, DDBLT_COLORFILL,
                                            &ddbltfx );
        if( SUCCEEDED(hr) )
            break;

        if( hr == DDERR_SURFACELOST )
            if( FAILED( RestoreSurfaces() ) )
                return;

        if( hr != DDERR_WASSTILLDRAWING )
            return;
    }
}




//-----------------------------------------------------------------------------
// Name: FlipScreen()
// Desc:
//-----------------------------------------------------------------------------
HRESULT FlipScreen()
{
        HRESULT hr = DDERR_WASSTILLDRAWING;

    // Flip the surfaces
        while( DDERR_WASSTILLDRAWING == hr )
        {
                hr = g_pddsFrontBuffer->Flip( NULL, 0 );

                if( hr == DDERR_SURFACELOST )
                        if( FAILED( RestoreSurfaces() ) )
                                return E_FAIL;
        }

        return hr;
}




//-----------------------------------------------------------------------------
// Name: DrawDisplayList()
// Desc:
//-----------------------------------------------------------------------------
VOID DrawDisplayList(LPDIRECTDRAWSURFACE7 lpConfigDlgSurf)
{
    if( FALSE == g_bLeaveTrails )
        EraseScreen();

    char scorebuf[11];
    int  rem;

    rem = g_dwScore;
    scorebuf[0] = rem/10000000 + '0';
    rem = g_dwScore % 10000000;
    scorebuf[1] = rem/1000000 + '0';
    rem = g_dwScore % 1000000;
    scorebuf[2] = rem/100000 + '0';
    rem = g_dwScore % 100000;
    scorebuf[3] = rem/10000 + '0';
    rem = g_dwScore % 10000;
    scorebuf[4] = rem/1000 + '0';
    rem = g_dwScore % 1000;
    scorebuf[5] = rem/100 + '0';
    rem = g_dwScore % 100;
    scorebuf[6] = rem/10 + '0';
    rem = g_dwScore % 10;
    scorebuf[7] = rem + '0';
    scorebuf[8] = '\0';

    // Draw the sound icon, if sound is enabled
    if( g_bSoundEnabled )
    {
        scorebuf[8]  = 14 + '0';
        scorebuf[9]  = 13 + '0';
        scorebuf[10] = '\0';
    }

    // Display the score
    BltBitmappedText( scorebuf, 10, g_dwScreenHeight-26 );

    // Display all visible objects in the display list
    for( DisplayObject* pObject = g_pDisplayList; pObject;
         pObject = pObject->next )
    {
        if( !pObject->bVisible )
            continue;

        HRESULT hr = DDERR_WASSTILLDRAWING;

        if( pObject->rcSrc.right - pObject->rcSrc.left == 0 )
            continue; // New objects do not have a src rect yet.

        while( hr == DDERR_WASSTILLDRAWING )
        {
            hr = g_pddsBackBuffer->BltFast( pObject->rcDst.left,
                                   pObject->rcDst.top, pObject->pddsSurface,
                                   &pObject->rcSrc, DDBLTFAST_SRCCOLORKEY );

        }
    }

    // Flip the backbuffer contents to the front buffer
                if (lpConfigDlgSurf)
                {
                        g_pddsBackBuffer->BltFast((g_dwScreenWidth-640)/2, (g_dwScreenHeight-480)/2, lpConfigDlgSurf, NULL, DDBLTFAST_WAIT);
                }

    FlipScreen();
}




//-----------------------------------------------------------------------------
// Name: DeleteFromList()
// Desc:
//-----------------------------------------------------------------------------
VOID DeleteFromList( DisplayObject* pObject )
{
    if( pObject->next )
        pObject->next->prev = pObject->prev;
    if( pObject->prev )
        pObject->prev->next = pObject->next;
    delete( pObject );
}




//-----------------------------------------------------------------------------
// Name: UpdateDisplayList()
// Desc:
//-----------------------------------------------------------------------------
VOID UpdateDisplayList()
{
    DisplayObject* thisnode;
    FLOAT          maxx, maxy;
    FLOAT          maxframe;
    DWORD          input[NUMBER_OF_PLAYERS];//= lastInput;
    for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl ++)
    {
	input[pl] = 0;
    }

    // Update the game clock parameters
    DWORD dwTickCount = GetTickCount();
    FLOAT fTickDiff   = ( dwTickCount - g_dwLastTickCount )/1000.0f;
    g_dwLastTickCount = dwTickCount;

    // Read input from the players' devices
    GetDeviceInput(input);

    for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl ++)
    {
		BOOL bShieldState = FALSE;
		BOOL bThrustState = FALSE;
		BOOL bBounce      = FALSE;
		LONG lAngle       = 0;

	    //if KEY_QUIT is pressed, exit
	    if (input[pl] & KEY_QUIT)
	    {
	       PostMessage( g_hWndMain, WM_CLOSE, 0, 0 );
	       return;
	    }

	    //if KEY_DISPLAY is pressed, call ConfigureDevices() in normal mode
	    if (input[pl] & KEY_DISPLAY)
	    {
		    //call ConfigureDevices() in default mode
		    DIUtil_ConfigureDevices(g_hWndMain, g_pddsDIConfig, DICD_DEFAULT);
	    }

	    //if KEY_EDIT is pressed, call ConfigureDevices() in edit mode
	    if (input[pl] & KEY_EDIT)
	    {
		    //call ConfigureDevices() in edit mode
		    DIUtil_ConfigureDevices(g_hWndMain, g_pddsDIConfig, DICD_EDIT);
	    }

	if( g_fShowDelay > 0.0f )
	{
	    g_fShowDelay -= fTickDiff;

	    if( g_fShowDelay < 0.0f )
	    {
		InitializeShips();
#if 0 //not used for the mulit-user mapper
		g_bLastShield = FALSE;
#endif //not used for the mulit-user mapper
		g_fShowDelay  = 0.0f;
		if (g_pShipsArray[pl] != NULL)
		{
		    g_pShipsArray[pl]->bVisible = TRUE;
		}
	    }
	}

	// Update the ships
	if (g_pShipsArray[pl] != NULL)
	{
	    if( g_pShipsArray[pl]->bVisible )
	    {
		g_pShipsArray[pl]->posx += g_pShipsArray[pl]->velx * fTickDiff;
		g_pShipsArray[pl]->posy += g_pShipsArray[pl]->vely * fTickDiff;
	    }
	    if( g_pShipsArray[pl]->posx > (FLOAT)(MAX_SCREEN_X - SHIP_WIDTH) )
	    {
		g_pShipsArray[pl]->posx = (FLOAT)(MAX_SCREEN_X - SHIP_WIDTH);
		g_pShipsArray[pl]->velx = -g_pShipsArray[pl]->velx;

		// Bounce off the right edge of the screen
		bBounce = TRUE;
		lAngle  = 90;
	    }
	    else if( g_pShipsArray[pl]->posx < 0 )
	    {
		g_pShipsArray[pl]->posx = 0;
		g_pShipsArray[pl]->velx = -g_pShipsArray[pl]->velx;

		// Bounce off the left edge of the screen
		bBounce = TRUE;
		lAngle  = 270;
	    }

	    if( g_pShipsArray[pl]->posy > (FLOAT)(MAX_SCREEN_Y - SHIP_HEIGHT) )
	    {
		g_pShipsArray[pl]->posy = (FLOAT)(MAX_SCREEN_Y - SHIP_HEIGHT);
		g_pShipsArray[pl]->vely = -g_pShipsArray[pl]->vely;

		// Bounce off the bottom edge of the screen
		bBounce = TRUE;
		lAngle  = 180;
	    }
	    else if( g_pShipsArray[pl]->posy < 0 )
	    {
		g_pShipsArray[pl]->posy =0;
		g_pShipsArray[pl]->vely = -g_pShipsArray[pl]->vely;

		// Bounce off the top edge of the screen
		bBounce = TRUE;
		lAngle  = 0;
	    }

	    if( bBounce )
	    {
		// "Bounce" the ship
		PlayPannedSound( g_pShipBounceSound, g_pShipsArray[pl] );
	#if 0 //not used in the Semantic Mapper demo
		DIUtil_PlayDirectionalEffect( g_pBounceFFEffect, lAngle );
	#endif //not used in the Semantic Mapper demo
	    }

	    bShieldState = ( !g_pShipsArray[pl]->bVisible || ( input[pl] & KEY_SHIELD ) );

#if 0 //not used for the mulit-user mapper
	    if( bShieldState != g_bLastShield )
	    {
#endif //not used for the mulit-user mapper
		if( bShieldState && g_pShipsArray[pl]->bVisible )
		{
		    DSUtil_PlaySound( g_pShieldBuzzSound, DSBPLAY_LOOPING );
#if 0 //not used for the mulit-user mapper
		    g_bShieldsOn = TRUE;
#endif //not used for the mulit-user mapper
		}
		else
		{
		    DSUtil_StopSound( g_pShieldBuzzSound );
#if 0 //not used for the mulit-user mapper
		    g_bShieldsOn = FALSE;
#endif //not used for the mulit-user mapper
		}
#if 0 //not used for the mulit-user mapper
		g_bLastShield = bShieldState;
	    }
#endif //not used for the mulit-user mapper
	    if( bShieldState )
	    {
		input[pl] &= ~(KEY_FIRE);
	    }

	    if( input[pl] & KEY_FIRE )
	    {
		// Add a bullet to the scene
		if( g_pShipsArray[pl]->bVisible )
		{
		    // Bullets cost one score point
		    if( g_dwScore )
			g_dwScore--;

		    // Play the "fire" sound
		    DSUtil_PlaySound( g_pFireBulletSound, 0);

		    // Play the "fire" forcefeedback effect
	#if 0 //not used in the Semantic Mapper demo
		    DIUtil_PlayEffect( g_pFireFFEffect );
	#endif //not used in the Semantic Mapper demo

		    // Add a bullet to the display list
		    CreateObject( OBJ_BULLET,
				 Dirx[(int)g_pShipsArray[pl]->frame]*6.0f + 16.0f + g_pShipsArray[pl]->posx,
				 Diry[(int)g_pShipsArray[pl]->frame]*6.0f + 16.0f + g_pShipsArray[pl]->posy,
				 Dirx[(int)g_pShipsArray[pl]->frame]*500.0f,
				 Diry[(int)g_pShipsArray[pl]->frame]*500.0f,
				 pl);
		}
	    }

	    if( input[pl] & KEY_LEFT )
	    {
		g_pShipsArray[pl]->frame -= 1.0;
		if( g_pShipsArray[pl]->frame < 0.0 )
		    g_pShipsArray[pl]->frame += MAX_SHIP_FRAME;
	    }
	    if( input[pl] & KEY_RIGHT )
	    {
		g_pShipsArray[pl]->frame += 1.0;
		if( g_pShipsArray[pl]->frame >= MAX_SHIP_FRAME )
		    g_pShipsArray[pl]->frame -= MAX_SHIP_FRAME;
	    }
	    if( input[pl] & KEY_UP )
	    {
		g_pShipsArray[pl]->velx += Dirx[(int)g_pShipsArray[pl]->frame] * 10.0f;
		g_pShipsArray[pl]->vely += Diry[(int)g_pShipsArray[pl]->frame] * 10.0f;
		bThrustState = TRUE;
	    }
	    if( input[pl] & KEY_DOWN )
	    {
		g_pShipsArray[pl]->velx -= Dirx[(int)g_pShipsArray[pl]->frame] * 10.0f;
		g_pShipsArray[pl]->vely -= Diry[(int)g_pShipsArray[pl]->frame] * 10.0f;
		bThrustState = TRUE;
	    }

	    if( bThrustState != lastThrust )
	    {
		if( bThrustState )
		{
		    input[pl] &= ~KEY_STOP;
		    DSUtil_StopSound( g_pSkidToStopSound );
		    DSUtil_PlaySound( g_pEngineRevSound, DSBPLAY_LOOPING );
#if 0 //not used for the mulit-user mapper
		    g_bThrusting = TRUE;
#endif //not used for the mulit-user mapper
		}
		else
		{
		    DSUtil_StopSound( g_pEngineRevSound );
#if 0 //not used for the mulit-user mapper
		    g_bThrusting = FALSE;
#endif //not used for the mulit-user mapper
		}

		lastThrust = bThrustState;
	    }

	    if( input[pl] & KEY_STOP )
	    {
		if( g_pShipsArray[pl]->velx || g_pShipsArray[pl]->vely )
		    PlayPannedSound( g_pSkidToStopSound, g_pShipsArray[pl] );

		g_pShipsArray[pl]->velx = 0.0f;
		g_pShipsArray[pl]->vely = 0.0f;
	    }
	}
    }

    for( thisnode = g_pDisplayList->next; thisnode;  )
    {
	//for things other than ships, which were handled above
	if (thisnode->type != OBJ_SHIP)
	{
	    thisnode->posx  += thisnode->velx  * fTickDiff;
	    thisnode->posy  += thisnode->vely  * fTickDiff;
	    thisnode->frame += thisnode->delay * fTickDiff;
	    switch( thisnode->type )
	    {
		case OBJ_DONUT:
		    maxx     = (FLOAT)(MAX_SCREEN_X - DONUT_WIDTH);
		    maxy     = (FLOAT)(MAX_SCREEN_Y - DONUT_HEIGHT);
		    maxframe = MAX_DONUT_FRAME;
		    break;
		case OBJ_PYRAMID:
		    maxx     = (FLOAT)(MAX_SCREEN_X - PYRAMID_WIDTH);
		    maxy     = (FLOAT)(MAX_SCREEN_Y - PYRAMID_HEIGHT);
		    maxframe = MAX_PYRAMID_FRAME;
		    break;
		case OBJ_SPHERE:
		    maxx     = (FLOAT)(MAX_SCREEN_X - SPHERE_WIDTH);
		    maxy     = (FLOAT)(MAX_SCREEN_Y - SPHERE_HEIGHT);
		    maxframe = MAX_SPHERE_FRAME;
		    break;
		case OBJ_CUBE:
		    maxx     = (FLOAT)(MAX_SCREEN_X - CUBE_WIDTH);
		    maxy     = (FLOAT)(MAX_SCREEN_Y - CUBE_HEIGHT);
		    maxframe = MAX_CUBE_FRAME;
		    break;
		case OBJ_BULLET:
		    maxx     = (FLOAT)(MAX_SCREEN_X - BULLET_WIDTH);
		    maxy     = (FLOAT)(MAX_SCREEN_Y - BULLET_HEIGHT);
		    maxframe = MAX_BULLET_FRAME;

		    // If bullet "expired", removed it from list
		    if( thisnode->frame >= MAX_BULLET_FRAME )
		    {
			DisplayObject* pVictim = thisnode;
			thisnode = thisnode->next;
			DeleteFromList( pVictim );
			continue;
		    }
		    break;
	    }
	    if( thisnode != g_pDisplayList )
	    {
		if( thisnode->posx > maxx )
		{
		    thisnode->posx = maxx;
		    thisnode->velx = -thisnode->velx;
		}
		else if ( thisnode->posx < 0 )
		{
		    thisnode->posx =0;
		    thisnode->velx = -thisnode->velx;
		}
		if( thisnode->posy > maxy )
		{
		    thisnode->posy = maxy;
		    thisnode->vely = -thisnode->vely;
		}
		else if ( thisnode->posy < 0 )
		{
		    thisnode->posy =0;
		    thisnode->vely = -thisnode->vely;
		}
		if( thisnode->frame >= maxframe )
		{
		    thisnode->frame -= maxframe;
		}
	    }
	}
	thisnode = thisnode->next;
    }
}




//-----------------------------------------------------------------------------
// Name: IsDisplayListEmpty()
// Desc:
//-----------------------------------------------------------------------------
BOOL IsDisplayListEmpty()
{
    DisplayObject* pObject = g_pDisplayList->next;

    while( pObject )
    {
        if( pObject->type != OBJ_BULLET )
            return FALSE;

        pObject = pObject->next;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// Name: IsDisplayListEmptyExceptShips()
// Desc:
//-----------------------------------------------------------------------------
BOOL IsDisplayListEmptyExceptShips()
{
    DisplayObject* pObject = g_pDisplayList->next;

    while( pObject )
    {
        if(( pObject->type != OBJ_BULLET ) && (pObject->type != OBJ_SHIP))
            return FALSE;

        pObject = pObject->next;
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
// Name: InitializeShips()
// Desc:
//-----------------------------------------------------------------------------
VOID InitializeShips()
{
	for (int ship = 0; ship < NUMBER_OF_PLAYERS; ship++)
	{
		if (g_pShipsArray[ship] != NULL)
		{
			g_pShipsArray[ship]->posx  = (FLOAT)(g_dwScreenWidth/(ship+2)-16); // Center the ship
			g_pShipsArray[ship]->posy  = (FLOAT)(g_dwScreenHeight/(ship+2)-16);
			g_pShipsArray[ship]->frame = 0.0f;
			g_pShipsArray[ship]->velx  = 0.0f;                          // Not moving
			g_pShipsArray[ship]->vely  = 0.0f;
			g_pShipsArray[ship]->bVisible = TRUE;
			g_pShipsArray[ship]->Player = ship;
		}
	}
}




//-----------------------------------------------------------------------------
// Name: AdvanceLevel()
// Desc:
//-----------------------------------------------------------------------------
VOID AdvanceLevel()
{
    // Up the level
    g_dwLevel++;

    // Clear any stray objects (anything but the ships) out of the display list
    while( (g_pShip->next != NULL) && (g_pShip->next->type != OBJ_SHIP ))
    {
        DeleteFromList( g_pShip->next );
    }

    // Create donuts for the new level
    for( WORD i=0; i<(2*g_dwLevel-1); i++ )
    {
        FLOAT x = rnd( 0.0f, (FLOAT)(MAX_SCREEN_X - DONUT_WIDTH) );
        FLOAT y = rnd( 0.0f, (FLOAT)(MAX_SCREEN_Y - DONUT_HEIGHT) );

        CreateObject( OBJ_DONUT, x, y, 0.0f, 0.0f, NO_PLAYER );
    }

    // Delay for 2 seconds before displaying ships
    InitializeShips();
    g_fShowDelay = 2.0f;
}




//-----------------------------------------------------------------------------
// Name: CreateObject()
// Desc:
//-----------------------------------------------------------------------------
DisplayObject* CreateObject( SHORT type, FLOAT x, FLOAT y, FLOAT vx, FLOAT vy, int Player )
{
    // Create a new display object
    DisplayObject* pObject = new DisplayObject;
    if( NULL == pObject )
        return NULL;

    // Add the object to the global display list
    AddToList( pObject );

    // Set object attributes
    pObject->bVisible = TRUE;
    pObject->type = type;
    pObject->posx = x;
    pObject->posy = y;
    pObject->velx = vx;
    pObject->vely = vy;
	pObject->Player = NO_PLAYER;

    switch( type )
    {
        case OBJ_DONUT:
            pObject->velx  = rnd( -50.0f, 50.0f );
            pObject->vely  = rnd( -50.0f, 50.0f );
            pObject->frame = rnd( 0.0f, 30.0f );
            pObject->delay = rnd( 3.0f, 12.0f );
            pObject->pddsSurface = g_pddsDonut;
            break;

        case OBJ_PYRAMID:
            pObject->velx  = rnd( -75.0f, 75.0f );
            pObject->vely  = rnd( -75.0f, 75.0f );
            pObject->frame = rnd( 0.0f, 30.0f );
            pObject->delay = rnd( 12.0f, 40.0f );
            pObject->pddsSurface = g_pddsPyramid;
            break;

        case OBJ_SPHERE:
            pObject->velx  = rnd( -150.0f, 150.0f );
            pObject->vely  = rnd( -150.0f, 150.0f );
            pObject->frame = rnd( 0.0f, 30.0f );
            pObject->delay = rnd( 60.0f, 80.0f );
            pObject->pddsSurface = g_pddsSphere;
            break;

        case OBJ_CUBE:
            pObject->velx  = rnd( -200.0f, 200.0f );
            pObject->vely  = rnd( -200.0f, 200.0f );
            pObject->frame = rnd( 0.0f, 30.0f );
            pObject->delay = rnd( 32.0f, 80.0f );
            pObject->pddsSurface = g_pddsCube;
            break;
			 
		case OBJ_SHIP:
            pObject->frame = 0.0f;
			pObject->posx  = x;
			pObject->posy  = y;
			pObject->velx  = 0.0f;                          // Not moving
			pObject->vely  = 0.0f;
			pObject->Player = Player;						//which player the ship belongs to
            pObject->pddsSurface = g_pddsShip;
            break;


        case OBJ_BULLET:
            pObject->frame =    0.0f;
            pObject->delay = 1000.0f;
			pObject->Player = Player;						//which player's ship shot the bullet
            pObject->pddsSurface = g_pddsNumbers;
            break;
    }

    return pObject;
};




//-----------------------------------------------------------------------------
// Name: AddToList()
// Desc:
//-----------------------------------------------------------------------------
VOID AddToList( DisplayObject* pObject )
{
    pObject->next = g_pDisplayList->next;
    pObject->prev = g_pDisplayList;

    if( g_pDisplayList->next )
        g_pDisplayList->next->prev = pObject;
    g_pDisplayList->next = pObject;
}




//-----------------------------------------------------------------------------
// Name: RestoreSurfaces()
// Desc:
//-----------------------------------------------------------------------------
HRESULT RestoreSurfaces()
{
    HRESULT hr;
    HBITMAP hbm;

    if( FAILED( hr = g_pddsFrontBuffer->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsDonut->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsPyramid->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsCube->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsSphere->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsShip->Restore() ) )
        return E_FAIL;
    if( FAILED( hr = g_pddsNumbers->Restore() ) )
        return E_FAIL;

    // Create and set the palette for the splash bitmap
    g_pSplashPalette = DDUtil_LoadPalette( g_pDD, "SPLASH" );

    // Create and set the palette for the art bitmap
    g_pArtPalette = DDUtil_LoadPalette( g_pDD, "DONUTS8" );

    if( NULL == g_pSplashPalette || NULL == g_pArtPalette )
    {
        CleanupAndDisplayError("Could not load palettes");
        return E_FAIL;
    }

    // Set the palette before loading the art
    g_pddsFrontBuffer->SetPalette( g_pArtPalette );

    hbm = (HBITMAP)LoadImage( GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0,
                              LR_CREATEDIBSECTION );
    if( NULL == hbm )
    {
        CleanupAndDisplayError("Could not load bitmap");
        return E_FAIL;
    }

    // Copy the bitmaps. (We're OR'ing the hresults together so we only have to
    // do one check for a failure case.)
    hr |= DDUtil_CopyBitmap( g_pddsDonut,   hbm, 0,   0, 320, 384 );
    hr |= DDUtil_CopyBitmap( g_pddsPyramid, hbm, 0, 384, 320, 128 );
    hr |= DDUtil_CopyBitmap( g_pddsSphere,  hbm, 0, 512, 320,  32 );
    hr |= DDUtil_CopyBitmap( g_pddsCube,    hbm, 0, 544, 320,  32 );
    hr |= DDUtil_CopyBitmap( g_pddsShip,    hbm, 0, 576, 320, 256 );
    hr |= DDUtil_CopyBitmap( g_pddsNumbers, hbm, 0, 832, 320,  16 );

    if( FAILED(hr) )
    {
        CleanupAndDisplayError("Could not copy bitmaps to surfaces");
        DeleteObject( hbm );
        return E_FAIL;
    }

    // Done with the bitmap
    DeleteObject( hbm );

    // Set colorfill colors and color keys according to bitmap contents
    g_dwFillColor = DDUtil_ColorMatch( g_pddsDonut, CLR_INVALID );

    DDUtil_SetColorKey( g_pddsDonut,   CLR_INVALID );
    DDUtil_SetColorKey( g_pddsPyramid, CLR_INVALID );
    DDUtil_SetColorKey( g_pddsCube,    CLR_INVALID );
    DDUtil_SetColorKey( g_pddsSphere,  CLR_INVALID );
    DDUtil_SetColorKey( g_pddsShip,    CLR_INVALID );
    DDUtil_SetColorKey( g_pddsNumbers, CLR_INVALID );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: rnd()
// Desc:
//-----------------------------------------------------------------------------
FLOAT rnd( FLOAT low, FLOAT high )
{
    return low + ( high - low ) * ((FLOAT)rand())/RAND_MAX;
}




//-----------------------------------------------------------------------------
// Name: InitializeSound()
// Desc:
//-----------------------------------------------------------------------------
HRESULT InitializeSound( HWND hWnd )
{
    g_bSoundEnabled = FALSE;

    if( FAILED( DirectSoundCreate( NULL, &g_pDS, NULL ) ) )
        //return E_FAIL;
        //per Marcus's request, to run on his machine
                return S_FALSE;

    if( FAILED( g_pDS->SetCooperativeLevel( hWnd, DSSCL_NORMAL ) ) )
    {
        g_pDS->Release();
        g_pDS = NULL;

        return E_FAIL;
    }

    g_pBeginLevelSound     = DSUtil_CreateSound( g_pDS, "BeginLevel",      1 );
    g_pEngineIdleSound     = DSUtil_CreateSound( g_pDS, "EngineIdle",      1 );
    g_pEngineRevSound      = DSUtil_CreateSound( g_pDS, "EngineRev",       1 );
    g_pSkidToStopSound     = DSUtil_CreateSound( g_pDS, "SkidToStop",      1 );
    g_pShieldBuzzSound     = DSUtil_CreateSound( g_pDS, "ShieldBuzz",      1 );
    g_pShipExplodeSound    = DSUtil_CreateSound( g_pDS, "ShipExplode",     1 );
    g_pFireBulletSound     = DSUtil_CreateSound( g_pDS, "Gunfire",        25 );
    g_pShipBounceSound     = DSUtil_CreateSound( g_pDS, "ShipBounce",      4 );
    g_pDonutExplodeSound   = DSUtil_CreateSound( g_pDS, "DonutExplode",   10 );
    g_pPyramidExplodeSound = DSUtil_CreateSound( g_pDS, "PyramidExplode", 12 );
    g_pCubeExplodeSound    = DSUtil_CreateSound( g_pDS, "CubeExplode",    15 );
    g_pSphereExplodeSound  = DSUtil_CreateSound( g_pDS, "SphereExplode",  10 );

    g_bSoundEnabled = TRUE;

    // Start sounds that should be playing
#if 0 //not used for the mulit-user mapper
    if( g_bEngineIdle ) DSUtil_PlaySound( g_pEngineIdleSound, DSBPLAY_LOOPING );
    if( g_bShieldsOn )  DSUtil_PlaySound( g_pShieldBuzzSound, DSBPLAY_LOOPING );
    if( g_bThrusting )  DSUtil_PlaySound( g_pEngineRevSound,  DSBPLAY_LOOPING );
#endif //not used for the mulit-user mapper

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DestroySound()
// Desc:
//-----------------------------------------------------------------------------
VOID DestroySound()
{
    if( g_pDS )
    {
        DSUtil_DestroySound( g_pBeginLevelSound );
        DSUtil_DestroySound( g_pEngineIdleSound );
        DSUtil_DestroySound( g_pEngineRevSound );
        DSUtil_DestroySound( g_pSkidToStopSound );
        DSUtil_DestroySound( g_pShieldBuzzSound );
        DSUtil_DestroySound( g_pShipExplodeSound );
        DSUtil_DestroySound( g_pFireBulletSound );
        DSUtil_DestroySound( g_pShipBounceSound );
        DSUtil_DestroySound( g_pDonutExplodeSound );
        DSUtil_DestroySound( g_pPyramidExplodeSound );
        DSUtil_DestroySound( g_pCubeExplodeSound );
        DSUtil_DestroySound( g_pSphereExplodeSound );

        g_pDS->Release();
    }

    g_pBeginLevelSound     = NULL;
    g_pEngineIdleSound     = NULL;
    g_pEngineRevSound      = NULL;
    g_pSkidToStopSound     = NULL;
    g_pShieldBuzzSound     = NULL;
    g_pShipExplodeSound    = NULL;
    g_pFireBulletSound     = NULL;
    g_pShipBounceSound     = NULL;
    g_pDonutExplodeSound   = NULL;
    g_pPyramidExplodeSound = NULL;
    g_pCubeExplodeSound    = NULL;
    g_pSphereExplodeSound  = NULL;

    g_pDS           = NULL;
    g_bSoundEnabled = FALSE;
}


//-----------------------------------------------------------------------------
// Name: InitializeInput()
// Desc:
//-----------------------------------------------------------------------------
HRESULT InitializeInput( HWND hWnd )
{
    // Initialize DirectInpu
    if( FAILED( DIUtil_Initialize( hWnd ) ) )
    {
        MessageBox( hWnd, "Can't Initialize DirectInput", "TDonuts", MB_OK );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DestroyInput()
// Desc:
//-----------------------------------------------------------------------------
VOID DestroyInput()
{
    // Release DirectInput
    DIUtil_CleanupDirectInput();
}



//-----------------------------------------------------------------------------
// Name: GetDeviceInput(input[])
// Desc: Processes data from the input device.  Uses GetDeviceData().
//-----------------------------------------------------------------------------
VOID GetDeviceInput(DWORD input[NUMBER_OF_PLAYERS])
{
   HRESULT     hr = S_OK;

   for (int pl = 0; pl < NUMBER_OF_PLAYERS; pl++)
   {
		printf("pl = %i", pl);

       for (int dv = 0; dv < (int) g_dwNumDevices[pl]; dv++)
       {

		   printf("dv = %i", dv);

	   if (g_pDevices[pl][dv] != NULL)
	   {
		DWORD dwItems = 10;
		DIDEVICEOBJECTDATA rgdod[10];
		hr = g_pDevices[pl][dv]->Poll();
		if (SUCCEEDED(hr))
		{
		    hr = g_pDevices[pl][dv]->GetDeviceData(
			  sizeof(DIDEVICEOBJECTDATA),
			  rgdod,
			  &dwItems,
			  0);
		    if (SUCCEEDED(hr))
		    {
		      //get the sematics codes
		      for (int j=0; j < (int)dwItems; j++)
		      {
			    //for axes, do axes stuff
			    if (rgdod[j].uAppData & AXIS_MASK)
			    {
				    //blow out all of the axis data
				    dwInputState[pl] &= ~(KEY_RIGHT);
				    dwInputState[pl] &= ~(KEY_LEFT);
				    dwInputState[pl] &= ~(KEY_UP);
				    dwInputState[pl] &= ~(KEY_DOWN);

				    if( ((int)rgdod[j].dwData) > 10 )
				    {
					   dwInputState[pl] |= ( rgdod[j].uAppData == AXIS_LR ) ? KEY_RIGHT : KEY_DOWN;
				    }
				    if( ((int)rgdod[j].dwData) < -10 )
				    {
					   dwInputState[pl] |= ( rgdod[j].uAppData == AXIS_LR ) ? KEY_LEFT : KEY_UP;
				    }

							    
			    }
			    else //do buttons
			    {
				  //if rgdod[j].dwData & 0x80, it means the button went down,
				    //else it went up
				  if (rgdod[j].dwData & 0x80)
				  {
				       //set the new state
				       dwInputState[pl] |= rgdod[j].uAppData;
				  }
				  else
				  {
					dwInputState[pl] &= ~(rgdod[j].uAppData);
				  }
			    }
			    }
			  }
		     }

	   }

	 }
	    //set the new state
	if (SUCCEEDED(hr))
	{
	    input[pl] = dwInputState[pl];
	}

   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dxff\fedit\fedit.cpp ===
// fedit.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "fedit.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "FEditDoc.h"
#include "FEditView.h"
#ifdef TRY_AUTOSETUP
#include "AutoSetupDlg.h"
#endif

#include <stdio.h>
#include <math.h>

#include "..\..\..\dxsdk\samples\multimedia\common\include\DXUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFEditApp

BEGIN_MESSAGE_MAP(CFEditApp, CWinApp)
	//{{AFX_MSG_MAP(CFEditApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)	
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFEditApp construction

CFEditApp::CFEditApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFEditApp object

CFEditApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CFEditApp initialization

BOOL CFEditApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings(7);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_FEDITTYPE,
		RUNTIME_CLASS(CFEditDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CFEditView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// setup if needed
#ifdef TRY_AUTOSETUP
	{
		CAutoSetupDlg dlg;
		if (!dlg.IsSetup())
		{
			dlg.DoModal();
			if (!dlg.WasSuccessful())
			{
				ErrorBox(IDS_APP_NO_SETUP);
				return FALSE;
			}
		}
	}
#endif

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CFEditApp::OnAppAbout()
{
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
	if (pMainFrame != NULL)
		pMainFrame->Stop();
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CFEditApp message handlers

void MyTrace(const TCHAR *lpszMessage)
{
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
	if (pMainFrame == NULL)
		return;
	pMainFrame->OutputString(lpszMessage);
}

/////////////////////////////////////////////////////////////////////////////
// CFEditApp OnFileOpen
//
void CFEditApp::OnFileOpen()
{
	static TCHAR strFileName[MAX_PATH] = TEXT("");
	static TCHAR strPath[MAX_PATH] = TEXT("");
	HWND hWnd = AfxGetMainWnd()->m_hWnd;

    // Setup the OPENFILENAME structure
    OPENFILENAME ofn = { sizeof(OPENFILENAME), hWnd, NULL,
                         TEXT("FEdit Files\0*.ffe\0All Files\0*.*\0\0"), NULL,
                         0, 1, strFileName, MAX_PATH, NULL, 0, strPath,
                         TEXT("Open FEdit File"),
                         OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 0, 0,
                         TEXT(".ffe"), 0, NULL, NULL };

    // Get the default media path (something like C:\MSSDK\SAMPLES\MULTIMEDIA\DINPUT\MEDIA)
    if( TEXT('\0') == strPath[0] )
        _tcscpy( strPath, DXUtil_GetDXSDKMediaPath() );

    // Display the OpenFileName dialog. Then, try to load the specified file
    if (GetOpenFileName( &ofn ) != 0)
	{
		//open file
		OpenDocumentFile(strFileName);
		//and save the path for next time
		strcpy( strPath, strFileName );
		char* strLastSlash = strrchr( strPath, TEXT('\\' ));
		strLastSlash[0] = TEXT('\0');
	}
}

/////////////////////////////////////////////////////////////////////////////
// FEdit Helper Functions
//

DWORD ScaleDurationFromCEffect(ULONG from)
{
	if (CEFFECT_DURATIONSCALE == DI_SECONDS)
		return (DWORD)from;
	else
		return (DWORD)MulDiv(int(from), DI_SECONDS, CEFFECT_DURATIONSCALE);
}

ULONG ScaleDurationToCEffect(DWORD to)
{
	if (CEFFECT_DURATIONSCALE == DI_SECONDS)
		return (ULONG)to;
	else
		return (ULONG)MulDiv(int(to), CEFFECT_DURATIONSCALE, DI_SECONDS);
}

BOOL GetEffectInfo(CEffect *pEffect, EFFECTINFO *pei)
{
	static struct EIBYGUID {
		const GUID *pguid;
		EFFECTINFO ei;
	} eibyguid[] = {
		{ &GUID_ConstantForce,	{ FALSE, FALSE, ET_CONSTANT } },
		{ &GUID_RampForce,		{ FALSE, FALSE, ET_RAMP } },
		// periodics
		{ &GUID_Square,			{ TRUE, FALSE, ET_SQUARE } },
		{ &GUID_Sine,			{ TRUE, FALSE, ET_SINE} },
		{ &GUID_Triangle,		{ TRUE, FALSE, ET_TRIANGLE} },
		{ &GUID_SawtoothUp,		{ TRUE, FALSE, ET_SAWUP } },
		{ &GUID_SawtoothDown,	{ TRUE, FALSE, ET_SAWDOWN } },
		// conditions
		{ &GUID_Spring,			{ FALSE, TRUE, ET_SPRING } },
		{ &GUID_Friction,		{ FALSE, TRUE, ET_FRICTION } },
		{ &GUID_Damper,			{ FALSE, TRUE, ET_DAMPER } },
		{ &GUID_Inertia,		{ FALSE, TRUE, ET_INERTIA } } };
	const int guids = sizeof(eibyguid) / sizeof(EIBYGUID);

	pei->bPeriodic = FALSE;
	pei->nType = ET_UNKNOWN;

	ASSERT(pEffect != NULL && pei != NULL);
	if (pEffect == NULL || pei == NULL)
		return FALSE;

	GUID *pguid = pEffect->GetEffectGuid();
	ASSERT(pguid != NULL);
	if (pguid == NULL)
		return FALSE;

	for (int i = 0; i < guids; i++)
		if (IsEqualGUID(*pguid, *(eibyguid[i].pguid)))
		{
			*pei = eibyguid[i].ei;
			// TODO: get actual num of axes and condition structures
			pei->nAxes = pEffect->GetNumActiveAxes();
			pei->nConditions = pei->nAxes;
			return TRUE;
		}

	return FALSE;
}

int CFEditApp::ExitInstance() 
{
	return CWinApp::ExitInstance();
}

///////////////////////////////////////////
// Allocates and loads a resource string.
// Returns it or NULL if unsuccessful.
//
TCHAR *AllocLoadString(UINT strid)
{
	// allocate
	const int STRING_LENGTHS = 1024;
	TCHAR *str = (TCHAR *)malloc(STRING_LENGTHS * sizeof(TCHAR));

	// use if allocated succesfully
	if (str != NULL)
	{
		// load the string, or free and null if we can't
		if (LoadString(AfxGetInstanceHandle(), strid, str, STRING_LENGTHS) == NULL)
		{
			free(str);
			str = NULL;
		}
	}

	return str;
}

/////////////////////////////////////////////////////////
// Shows a message box with the specified error string.
// (automatically handles getting and freeing string.)
//
static TCHAR g_tmp[1024];
void ErrorBox(UINT strid, ...)
{
	// alloc 'n load
	TCHAR *errmsg = AllocLoadString(strid);

	// format 
	va_list args;
	va_start(args, strid);
	{
		char szDfs[1024]={0};
		if (errmsg == NULL)
			strcpy(szDfs,TEXT("(couldn't load error string)"));
		else
			strcpy(szDfs,errmsg);				// make a local copy of format string
#ifdef WIN95
		char *psz = NULL;
		while (psz = strstr(szDfs,"%p"))		// find each %p
			*(psz+1) = 'x';						// replace each %p with %x
#ifndef _UNICODE
		vsprintf (g_tmp, szDfs, args);			// use the local format string
#else
		vswprintf (g_tmp, szDfs, args);			// use the local format string
#endif //#ifndef _UNICODE
	}
#else

#ifndef _UNICODE
		vsprintf (g_tmp, szDfs, args);
#else
		vswprintf (g_tmp, szDfs, args);
#endif //#ifndef _UNICODE
	}
#endif //#ifdef WIN95

	va_end(args);
	free(errmsg);
	errmsg = _tcsdup(g_tmp);

	// Show error
	AfxMessageBox(errmsg ? errmsg : TEXT("(couldn't form error message)"), MB_OK | MB_ICONSTOP);

	// free which ever strings loaded
	if (NULL != errmsg)
		free(errmsg);
}

/////////////////////////////////////////////////////////
// Shows a message box based on GetLastError().
//
void LastErrorBox(UINT strid, ...)
{
	va_list args;
	LPVOID lpMsgBuf = NULL;
	TCHAR *errmsg = ((strid != NULL) ? AllocLoadString(strid) : NULL);

	if (errmsg != NULL)
	{
		va_start(args, strid);
#ifdef WIN95
		{
			char *psz = NULL;
			char szDfs[1024]={0};
			strcpy(szDfs,errmsg);					// make a local copy of format string
			while (psz = strstr(szDfs,"%p"))		// find each %p
				*(psz+1) = 'x';						// replace each %p with %x
#ifndef _UNICODE
			vsprintf (g_tmp, szDfs, args);			// use the local format string
#else
			vswprintf (g_tmp, szDfs, args);			// use the local format string
#endif
		}
#else
		{
#ifndef _UNICODE
			vsprintf (g_tmp, errmsg, args);
#else
			vswprintf (g_tmp, errmsg, args);
#endif
		}
#endif
		va_end(args);
		free(errmsg);
		errmsg = _tcsdup(g_tmp);
	}

	// format an error message from GetLastError().
	DWORD result = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &lpMsgBuf,
		0,
		NULL);

	if (0 == result)
	{
		ErrorBox(NULL);
	}
	else
	{
		// format 
		CString msg;
		if (errmsg != NULL)
			msg.Format(TEXT("%s\n\nLast System Error:\n\t%s"), errmsg, (LPCTSTR)lpMsgBuf);
		else
			msg.Format(TEXT("Last System Error:\n\t%s"), (LPCTSTR)lpMsgBuf);

		// show the message we just formatted
		AfxMessageBox(msg, MB_OK | MB_ICONSTOP);
	}

	// free whichever strings were allocated
	if (NULL != errmsg)
		free(errmsg);
	if (NULL != lpMsgBuf)
		LocalFree(lpMsgBuf);
}


BOOL GetEffectSustainAndOffset(CEffect *pEffect, int &sustain, int &offset)
{
	ASSERT(pEffect != NULL);
	if (pEffect == NULL)
		return FALSE;

	EFFECTINFO ei;
	VERIFY(GetEffectInfo(pEffect, &ei));

	if (ei.bCondition || ei.nType == ET_UNKNOWN)
	{
		ASSERT(0);
		return FALSE;
	}

	void *param = pEffect->GetParam();
	ASSERT(param != NULL);
	if (param == NULL)
		return FALSE;

	if (ei.bPeriodic)
	{
		sustain = int(((DIPERIODIC *)param)->dwMagnitude);
		offset = int(((DIPERIODIC *)param)->lOffset);
		return TRUE;
	}

	switch (ei.nType)
	{
		case ET_CONSTANT:
			sustain = abs(int(((DICONSTANTFORCE *)param)->lMagnitude));
			offset = 0;
			return TRUE;

		case ET_RAMP:
			sustain = abs(int(((DIRAMPFORCE *)param)->lStart) -
				int(((DIRAMPFORCE *)param)->lEnd)) / 2;
			offset = (int(((DIRAMPFORCE *)param)->lStart) +
				int(((DIRAMPFORCE *)param)->lEnd)) / 2;
			return TRUE;

		default:
			ASSERT(0);
			return FALSE;
	}
}

BOOL IsValidInteger(const CString &s, int min, int max)
{
	if (s.IsEmpty())
		return FALSE;

	int i = atoi(s);
	
	if (i == 0)
	{
		int l = s.GetLength();
		for (int c = 0; c < l; c++)
			if (s[c] != '0')
				return FALSE;
	}

	if (i < min || i > max)
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\ihvmap\sources.inc ===
!IF 0

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources.

    Abstract:

	Causes mapper files to be binplaced

Author:

    MarcAnd

History:
    Date        By          Reason
    ====        ==          ======
    00-11-09    MarcAnd     first version
    01-04-12    TimGill	    357981
        
!ENDIF

!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

!INCLUDE $(DXROOT)\Project.mk

SOURCES= 


MISCFILES=\
    ACTC094.ini \
    ..\ACT_RS.ini\
    ..\ACT_RS.png \
    ..\GlmDA.ini \
    ..\GlmDA.png \
    ..\GlmDA_G.ini \
    ..\GlmDigGP.ini \
    ..\GlmDigGP.png \
    ..\GlmDGP_G.ini \
    ..\GR3001.ini \
    ..\GR3001_G.ini \
    ..\GR3001.png \
    ..\GR4001.ini \
    ..\GR4001.png \
    ..\GR4001_G.ini \
    ..\GR4001_G.png \
    ..\GR4003.ini \
    ..\GR4003.png \
    ..\GR4005.ini \
    ..\GR4005.png \
    ..\Hammer.ini \
    ..\IA3002.ini \
    ..\IA3002_1.png \
    ..\IA3002_2.png \
    ..\IA3002_G.ini \
    ..\LGC202.ini \
    ..\LGC202.png \
    ..\LGC207.ini \
    ..\LGC207.png \
    ..\LGC209.ini \
    ..\LGC209.png \
    ..\LGC20A.ini \
    ..\LGC20A.png \
    ..\LGC291.ini \
    ..\LGC291.png \
    ..\MS1B.ini \
    ..\MS1B.png \
    ..\MS1B_01.png \
    ..\MS1B_02.png \
    ..\MS1B_03.png \
    ..\MS1B_04.png \
    ..\MS1B_05.png \
    ..\MS1B_06.png \
    ..\MS1B_07.png \
    ..\MS1B_08.png \
    ..\MS1B_09.png \
    ..\MS1B_10.png \
    ..\MS26.ini \
    ..\MS26.png \
    ..\MS26_01.png \
    ..\MS26_02.png \
    ..\MS26_03.png \
    ..\MS26_04.png \
    ..\MS26_05.png \
    ..\MS26_06.png \
    ..\MS26_07.png \
    ..\MS26_08.png \
    ..\MS27.ini \
    ..\MS27.png \
    ..\MS27_1.png \
    ..\MS27_2.png \
    ..\MS27_3.png \
    ..\MS27_4.png \
    ..\MS27_5.png \
    ..\MS28.ini \
    ..\MS28.png \
    ..\MS28_1.png \
    ..\MS28_2.png \
    ..\MS28_3.png \
    ..\MS28_4.png \
    ..\MS28_5.png \
    ..\MS28_6.png \
    ..\MS28_7.png \
    ..\MS28_8.png \
    ..\MS34.ini \
    ..\MS34.png \
    ..\MS34_01.png \
    ..\MS34_02.png \
    ..\MS34_03.png \
    ..\MS34_04.png \
    ..\MS34_05.png \
    ..\MS34_06.png \
    ..\MS34_07.png \
    ..\MS34_08.png \
    ..\MS34_G.ini \
    ..\MS3B.ini \
    ..\MS3B.png \
    ..\MS3B_1.png \
    ..\MS3B_2.png \
    ..\MS3B_3.png \
    ..\MS3B_4.png \
    ..\MS3B_a.png \
    ..\MS3B_c.png \
    ..\MS3B_m.png \
    ..\MS3B_t.png \
    ..\MS56.ini \
    ..\MS56.png \
    ..\MS56_1.png \
    ..\MS56_10.png \
    ..\MS56_2.png \
    ..\MS56_3.png \
    ..\MS56_4.png \
    ..\MS56_5.png \
    ..\MS56_6.png \
    ..\MS56_7.png \
    ..\MS56_8.png \
    ..\MS56_9.png \
    ..\MS6.ini \
    ..\MS6.png \
    ..\MS6_1.png \
    ..\MS6_10.png \
    ..\MS6_2.png \
    ..\MS6_3.png \
    ..\MS6_4.png \
    ..\MS6_5.png \
    ..\MS6_6.png \
    ..\MS6_7.png \
    ..\MS6_8.png \
    ..\MS6_9.png \
    ..\MS6_G.ini \
    ..\MS7.ini \
    ..\MS7.png \
    ..\MS7_1.png \
    ..\MS7_2.png \
    ..\MS7_3.png \
    ..\MS7_4.png \
    ..\MS7_5.png \
    ..\MS7_6.png \
    ..\MS7_7.png \
    ..\MS7_8.png \
    ..\MS7_9.png \
    ..\MS7_G.ini \
    ..\MS8.ini \
    ..\MS8.png \
    ..\MS8_1.png \
    ..\MS8_10.png \
    ..\MS8_2.png \
    ..\MS8_3.png \
    ..\MS8_4.png \
    ..\MS8_5.png \
    ..\MS8_6.png \
    ..\MS8_7.png \
    ..\MS8_8.png \
    ..\MS8_9.png \
    ..\MS8_G.ini \
    ..\MSE.ini \
    ..\MSE.png \
    ..\MSE_1.png \
    ..\MSE_10.png \
    ..\MSE_2.png \
    ..\MSE_3.png \
    ..\MSE_4.png \
    ..\MSE_5.png \
    ..\MSE_6.png \
    ..\MSE_7.png \
    ..\MSE_8.png \
    ..\MSE_9.png \
    ..\MSE_G.ini \
    ..\MSF1F.ini \
    ..\MSF1F.png \
    ..\MSF1F_1.png \
    ..\MSF1F_10.png \
    ..\MSF1F_2.png \
    ..\MSF1F_3.png \
    ..\MSF1F_4.png \
    ..\MSF1F_5.png \
    ..\MSF1F_6.png \
    ..\MSF1F_7.png \
    ..\MSF1F_8.png \
    ..\MSF1F_9.png \
    ..\MSPRW.ini \
    ..\MSPRW.png \
    ..\MSPRW_1.png \
    ..\MSPRW_2.png \
    ..\MSPRW_3.png \
    ..\MSPRW_4.png \
    ..\MSPRW_5.png \
    ..\MSPRW_6.png \
    ..\MSPRW_7.png \
    ..\MSPRW_8.png \
    ..\RaiderPD.ini \
    ..\SV-262E1.png \
    ..\SV-262E3.png \
    ..\SV-262E4.png \
    ..\SV2511.png \
    ..\SV2512.png
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\assert.c ===
/*****************************************************************************
 *
 *  Assert.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and squirties.
 *
 *  Contents:
 *
 *      SquirtSqflPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterSqflPszPal
 *      ExitSqflPalHresPpv
 *
 *****************************************************************************/

#include "pidpr.h"

#ifdef XDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszPrefix[] = TEXT("PID: ");

#pragma END_CONST_DATA

void EXTERNAL
WarnPtszV(LPCTSTR ptsz, ...)
{
    va_list ap;
    TCHAR tsz[1024];

    lstrcpy(tsz, c_tszPrefix);
    va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))					// find each %p
			*(psz+1) = 'x';									// replace %p with %x
	    wvsprintf(tsz + cA(c_tszPrefix) - 1, szDfs, ap);	// use the local format string
	}
#else
	{
		wvsprintf(tsz + cA(c_tszPrefix) - 1, ptsz, ap);
	}
#endif
    va_end(ap);
    lstrcat(tsz, TEXT("\r\n"));
    OutputDebugString(tsz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

BYTE g_rgbSqfl[sqflMaxArea];

TCHAR g_tszLogFile[MAX_PATH];

/*****************************************************************************
 *
 *      Sqfl_Init
 *
 *      Load our initial Sqfl settings from win.ini[debug].
 *
 *      We take one sqfl for each area, of the form
 *
 *      dinput.n=v
 *
 *      where n = 0, ..., sqflMaxArea-1, and where v is one of the
 *      hiword sqfl values.
 *
 *      The default value for all areas is to squirt only errors.
 *
 *****************************************************************************/

void EXTERNAL
Sqfl_Init(void)
{
    int sqfl;
    TCHAR tsz[20];

    sqfl = 0x0;
    wsprintf(tsz, TEXT("PID"));
    g_rgbSqfl[sqfl] = (BYTE)
                      GetProfileInt(TEXT("DEBUG"), tsz, HIWORD(0x0));

    for (sqfl = 0; sqfl < sqflMaxArea; sqfl++) {
        wsprintf(tsz, TEXT("PID.%d"), sqfl);
        g_rgbSqfl[sqfl] = (BYTE)
                          GetProfileInt(TEXT("DEBUG"), tsz, g_rgbSqfl[0]);
    }

}

/*****************************************************************************
 *
 *      SquirtPtsz
 *
 *      Squirt a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
SquirtPtsz(LPCTSTR ptsz)
{
    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            _lwrite((HFILE)(UINT_PTR)h, szBuf, UToA(szBuf, cA(szBuf), ptsz));
#else
            _lwrite((HFILE)(UINT_PTR)h, ptsz, cbCtch(lstrlen(ptsz)));
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      SquirtPtszA
 *
 *      Squirt an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
SquirtPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)(UINT_PTR)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define SquirtPtszA                 SquirtPtsz

#endif

/*****************************************************************************
 *
 *      SquirtSqflPtszV
 *
 *      Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (IsSqflSet(sqfl)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))					// find each %p
			*(psz+1) = 'x';									// replace %p with %x
        wvsprintf(tsz, szDfs, ap);							// use the local format string
	}
#else
	{
        wvsprintf(tsz, ptsz, ap);
	}
#endif
        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        SquirtPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because of the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      dwSafeGetPdw
 *
 *      Deference a dword, but don't barf if the dword is bad.
 *
 *****************************************************************************/

DWORD INTERNAL
dwSafeGetPdw(LPDWORD pdw)
{
    if (IsBadReadPtr(pdw, cbX(*pdw))) {
        return 0xBAADBAAD;
    } else {
        return *pdw;
    }
}

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv; *psz; psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32-bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      S   - SCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    SquirtPtsz(pal->ptszProc);
    SquirtPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            SquirtPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* flat pointer */
// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
#ifdef WIN95
            wsprintfA(sz, "%x", pal->rgpv[i]);
#else
			wsprintfA(sz, "%p", pal->rgpv[i]);
#endif
            SquirtPtszA(sz);
            break;
        case 'x':                               /* hex */
            wsprintfA(sz, "%x", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i] && lstrlen(pal->rgpv[i])) {
                SquirtPtsz(pal->rgpv[i]);
            }
            break;

#ifdef  UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'A':                               /* ANSI string */
            if (pal->rgpv[i] && lstrlenA(pal->rgpv[i])) {
                SquirtPtszA(pal->rgpv[i]);
            }
            break;

#ifndef UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'W':                               /* UNICODE string */
            if (pal->rgpv[i] && lstrlenW(pal->rgpv[i])) {
#ifdef  UNICODE
                OutputDebugStringW(pal->rgpv[i]);
#else
                UToA(sz, cA(sz), pal->rgpv[i]);
                SquirtPtszA(sz);
#endif
            }
            break;

        case 'G':                               /* GUID */
            wsprintfA(sz, "%08x",
                      HIWORD((DWORD)(UINT_PTR)pal->rgpv[i])
                        ? dwSafeGetPdw((LPDWORD)pal->rgpv[i])
                        : (UINT_PTR)pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'C':
            if (GetClipboardFormatNameA((UINT)(UINT_PTR)pal->rgpv[i], sz, cA(sz))) {
            } else {
                wsprintfA(sz, "[%04x]", pal->rgpv[i]);
            }
            SquirtPtszA(sz);
            break;

        default: AssertF(0);                    /* Invalid */
        }
    }
    SquirtPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterSqflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      If sqfl contains the sqflBenign flag, then any error we detect
 *      should be classified as sqflBenign and not sqflError.
 *
 *      sqfl     -> squirty flags
 *      ptszProc -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCTSTR ptszProc, PARGLIST pal)
{
    pal->ptszProc = ptszProc;
    sqfl |= sqflIn;
    if (IsSqflSet(sqfl)) {
        EmitPal(pal);
        SquirtPtsz(TEXT("\r\n"));
    }
}

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    SQFL sqflIsError;
    DWORD le = GetLastError();

    if (sqfl & sqflBenign) {
        sqfl &= ~sqflBenign;
        sqflIsError = sqflBenign;
    } else {
        sqflIsError = sqflError;
    }

    sqfl |= sqflOut;
    fInternalError = 0;
    if (ppvObj == ppvVoid || ppvObj == ppvDword) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            sqfl |= sqflIsError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            if (hres == E_NOTIMPL) {    /* E_NOTIMPL is always benign */
                sqfl |= sqflBenign;
            } else {
                sqfl |= sqflIsError;
            }
        }
    }

    if (IsSqflSet(sqfl) || fInternalError) {
        EmitPal(pal);
        SquirtPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            SquirtPtsz(tszBuf);
            if (HIWORD((UINT_PTR)ppvObj)) {
                wsprintf(tszBuf, TEXT(" [%08x]"),
                         dwSafeGetPdw((LPDWORD)ppvObj));
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                SquirtPtsz(tszBuf);
            }
        }
        SquirtPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\clsfact.c ===
/*****************************************************************************
 *
 *  Clsfact.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *
 *  Abstract:
 *
 *      Class factory.
 *
 *****************************************************************************/

#include "PIDpr.h"

/*****************************************************************************
 *
 *      CClassFactory_AddRef
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_AddRef(IClassFactory *pcf)
{
    return DllAddRef();
}


/*****************************************************************************
 *
 *      CClassFactory_Release
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_Release(IClassFactory *pcf)
{
    return DllRelease();
}

/*****************************************************************************
 *
 *      CClassFactory_QueryInterface
 *
 *      Our QI is very simple because we support no interfaces beyond
 *      ourselves.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IClassFactory)) {
        CClassFactory_AddRef(pcf);
        *ppvOut = pcf;
        hres = S_OK;
    } else {
        *ppvOut = 0;
        hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_CreateInstance
 *
 *      Create the effect driver object itself.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter,
                             REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (punkOuter == 0) {
        hres = PID_New(riid, ppvObj);
    } else {
        /*
         *  We don't support aggregation.
         */
        hres = CLASS_E_NOAGGREGATION;
    }

    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_LockServer
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{

    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }

    return S_OK;
}

/*****************************************************************************
 *
 *      The VTBL for our Class Factory
 *
 *****************************************************************************/

IClassFactoryVtbl CClassFactory_Vtbl = {
    CClassFactory_QueryInterface,
    CClassFactory_AddRef,
    CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer,
};

/*****************************************************************************
 *
 *      Our static class factory.
 *
 *****************************************************************************/

IClassFactory g_cf = { &CClassFactory_Vtbl };

/*****************************************************************************
 *
 *      CClassFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_New(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    /*
     *  Attempt to obtain the desired interface.  QueryInterface
     *  will do an AddRef if it succeeds.
     */
    hres = CClassFactory_QueryInterface(&g_cf, riid, ppvOut);

    return hres;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\debug.h ===
/***************************************************************************
 *  Debug.h
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Content:    DirectInput debugging macros
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Somebody had to
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef XDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *      A sqfl is in multiple parts.
 *
 *      The low word specifies the area that is generating the message.
 *
 *      The high word contains flags that describe why this squirty
 *      is being generated.
 *
 *****************************************************************************/

typedef enum _SQFL{
    /*
     *  Areas.
     */
    sqflAlways          = 0x0000,       /* Unconditional */
    sqflDll             = 0x0001,       /* Dll bookkeeping */
    sqflFactory         = 0x0002,       /* IClassFactory */
    sqflDi              = 0x0003,       /* IDirectInput */
    sqflHid             = 0x0004,       
    sqflReg             = 0x0005,       /* Registry Setup */
    sqflInit            = 0x0006,       /* Initialization */
    sqflEff             = 0x0007,       /* Effect Block Download */
    sqflParam           = 0x0008,       /* Parameter Block(s) Download */
    sqflOp              = 0x0009,       /* PID device Operation */
    sqflRead            = 0x000A,
    sqflEffDrv          = 0x000B,
    sqflParams          = 0x000C,       /* Incoming parameters */
    sqflCrit            = 0x000D,       /* Critical Section */
    sqflMaxArea,                        /* Last area */

    /*
     *  Flags which may be combined.  For now, they all fit into a byte.
     */
    sqflTrace           = 0x00010000,   /* Trace squirties */
    sqflIn              = 0x00020000,   /* Function entry */
    sqflOut             = 0x00040000,   /* Function exit */
    sqflBenign          = 0x00080000,   /* Not a bad error */
    sqflError           = 0x00100000,   /* A bad error */
    sqflVerbose         = 0x00200000,   /* Really verbose */
} SQFL;                                 /* squiffle */

#ifdef XDEBUG
void EXTERNAL WarnPtszV(LPCTSTR ptsz, ...);
void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
#endif

#ifndef DEBUG
#define SquirtSqflPtszV sizeof
#endif

#ifdef XDEBUG
    #define RPF WarnPtszV
#else
    #define WarnPtszV sizeof
    #define RPF sizeof
    #define s_tszProc 0
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef XDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_tszProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      No suffix means that the macro should be active only in the
 *      DEBUG build and should vanish in RDEBUG (and RETAIL).
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitProcF();
 *
 *              Procedure returns a BOOL, where FALSE is an error.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *      The ExitBenign* versions consider any error to be benign.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCTSTR ptszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);
void EXTERNAL Sqfl_Init(void);

#ifdef DEBUG

extern BYTE g_rgbSqfl[sqflMaxArea];

BOOL INLINE
IsSqflSet(SQFL sqfl)
{
    WORD wHi;
    if (LOWORD(sqfl) == sqflAlways) {
        return TRUE;
    }
    wHi = HIWORD(sqfl);
    if (wHi == 0) {
        wHi = HIWORD(sqflTrace);
    }

    return g_rgbSqfl[LOWORD(sqfl)] & wHi;
}

#endif

#define _SetupEnterProc(nm)                             \
        static TCHAR s_tszProc[] = TEXT(#nm);           \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_tszProc, _al)           \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#define _ExitBenignOleProcPpv(ppv)                      \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, hres, (PPV)(ppv)) \

#define _ExitBenignOleProc()                            \
        _ExitBenignOleProcPpv(0)                        \

#define _ExitBenignProc()                               \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, 0, ppvVoid) \

#define _ExitBenignProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvDword) \

#define _ExitBenignProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF
#define ExitBenignOleProcPpv    _ExitBenignOleProcPpv
#define ExitBenignOleProc       _ExitBenignOleProc
#define ExitBenignProc          _ExitBenignProc
#define ExitBenignProcX         _ExitBenignProcX
#define ExitBenignProcF         _ExitBenignProcF

#define EnterProcS(nm, v)                               \
        static TCHAR s_tszProc2[] = TEXT(#nm);          \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_tszProc2, _al)          \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF
#define ExitBenignOleProcPpvR   _ExitBenignOleProcPpv
#define ExitBenignOleProcR      _ExitBenignOleProc
#define ExitBenignProcR         _ExitBenignProc
#define ExitBenignProcXR        _ExitBenignProcX
#define ExitBenignProcFR        _ExitBenignProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static TCHAR s_tszProc[] = TEXT("")
#define EnterProcR(nm, v)   static TCHAR s_tszProc[] = TEXT(#nm)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\baggage.h ===
/***************************************************************************
 *  Baggage.h
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pidi.h
 *  Content:    DirectInput PID internal include file
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1999.01.04 OmSharma Lost a bet
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  Debug / RDebug / Retail
 *
 *  If either DEBUG or RDEBUG, set XDEBUG.
 *
 *  Retail defines nothing.
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG) || defined(_DBG)
    #define XDEBUG
#endif

typedef LPUNKNOWN PUNK;
typedef LPVOID PV, *PPV;
typedef CONST VOID *PCV;
typedef REFIID RIID;
typedef CONST GUID *PCGUID;

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/*
 *  Arithmetic on pointers.
 */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert a count of X's (cx) into a count of bytes
 * and vice versa.
 */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

/*
 * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
 * or dwords (cdw) into a count of bytes, and vice versa.
 */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

/*
 * Zero an arbitrary buffer.  It is a common error to get the second
 * and third parameters to memset backwards.
 */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

/*
 * Zero an arbitrary object.
 */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the *nature* of the C language, this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
    #define fLorFF(f1, f2) ((f1) ?: (f2))
#else
    #define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 *  fInOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 *  fHasAllBitsFlFl - checks that all bits in fl2 are set in fl1.
 */
BOOL INLINE
    fHasAllBitsFlFl(DWORD fl1, DWORD fl2)
{
    return (fl1 & fl2) == fl2;
}

/*
 *  fEqualMask - checks that all masked bits are equal
 */
BOOL INLINE
    fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
{
    return ((fl1 ^ fl2) & flMask) == 0;
}

#define NEED_REALLOC

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
    #define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
void EXTERNAL FreePpv(PV ppv);
    #define FreePpv(ppv) FreePpv(ppv)
#endif
#define FreePv(pv) LocalFree((HLOCAL)(pv))



HRESULT EXTERNAL hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst);

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)


/***************************************************************************
 *
 *  Debugging macros needed by inline functions
 *
 *  The build of debugging goo is in debug.h
 *
 ***************************************************************************/

int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DEBUG

    #define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
    #define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
    #define ConfirmF(c) \
	((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

    #define AssertFPtsz(c, ptsz)
    #define ValidateF(c, arg)
    #define ConfirmF(c)     (c)

#endif

/*
 *  CAssertF - compile-time assertion.
 */
#define CAssertF(c)     switch(0) case c: case 0:

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))


#define Clamp( MIN_, VAL_, MAX_ )  ( (VAL_ < MIN_) ? MIN_ : ((VAL_ > MAX_) ? MAX_ : VAL_) )
#define Clip( VAL_, MAX_)          ( (VAL_ > MAX_) ? MAX_ : VAL_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\guids.c ===
#define INITGUID
#include <pidpr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\dimem.c ===
/*****************************************************************************
 *
 *  Dimem.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *      dimem.c - Memory management
 *
 *      WARNING!  These do not go through OLE allocation.  Use these
 *      only for private allocation.
 *
 *****************************************************************************/

#include "PIDpr.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *      ReallocCbPpv
 *
 *      Change the size of some zero-initialized memory.
 *
 *      This is the single place where all memory is allocated, resized,
 *      and freed.
 *
 *      If you realloc from a null pointer, memory is allocated.
 *      If you realloc to zero-size, memory is freed.
 *
 *      These semantics avoid boundary cases.  For example, it is no
 *      longer a problem trying to realloc something down to zero.
 *      You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *      If an error is returned, the original pointer is UNCHANGED.
 *      This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {                       /* Alloc or realloc */
        if (hloc) {                 /* Realloc */
            hloc = LocalReAlloc(*ppv, cb,
                                LMEM_MOVEABLE+LMEM_ZEROINIT);
        } else {                /* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
        hres = hloc ? NOERROR : E_OUTOFMEMORY;
    } else {                    /* Freeing */
        if (hloc) {
            LocalFree(hloc);
            hloc = 0;
            hres = NOERROR;     /* All gone */
        } else {
            hres = NOERROR;     /* Nothing to free */
        }
    }

    if (SUCCEEDED(hres)) {
        *ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

/*****************************************************************************
 *
 *      FreePpv
 *
 *      Free memory from the ppv.
 *
 *****************************************************************************/

void EXTERNAL
FreePpv(PV ppv)
{
    PV pv = (PV)InterlockedExchange(ppv, 0);
    if (pv) {
        FreePv(pv);
    }
}

#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresDupPtszPptsz |
 *
 *          OLEish version of strdup.
 *
 *  @parm   LPCTSTR | ptszSrc |
 *
 *          Source string being duplicated.
 *
 *  @parm   LPTSTR * | pptszDst |
 *
 *          Receives the duplicated string.
 *
 *  @returns
 *
 *          <c S_OK> or an error code.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCtch(lstrlen(ptszSrc) + 1), pptszDst);

    if(SUCCEEDED(hres))
    {
        lstrcpy(*pptszDst, ptszSrc);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\effdrv.c ===
/*****************************************************************************
 *
 *  EffDrv.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Effect driver.
 *
 *      WARNING!  Since the effect driver is marked ThreadingModel="Both",
 *      all methods must be thread-safe.
 *
 *****************************************************************************/
#include "PIDpr.h"

#define sqfl    (sqflEffDrv)
/*****************************************************************************
 *
 *      CPidDrv - Effect driver
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      PID_AddRef
 *
 *      Increment our object reference count (thread-safely) and return
 *      the new reference count.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
PID_AddRef(IDirectInputEffectDriver *ped)
{
    CPidDrv *this = (CPidDrv *)ped;

    InterlockedIncrement((LPLONG)&this->cRef);
    

    return this->cRef;
}


/*****************************************************************************
 *
 *      PID_Release
 *
 *      Decrement our object reference count (thread-safely) and
 *      destroy ourselves if there are no more references.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
PID_Release(IDirectInputEffectDriver *ped)
{
    ULONG ulRc;
    CPidDrv *this = (CPidDrv *)ped;

    if(InterlockedDecrement((LPLONG)&this->cRef) == 0)
    {
		DllRelease(); 
        PID_Finalize(ped);
        LocalFree(this);
        ulRc = 0;
    } else
    {
        ulRc = this->cRef;
    }

    return ulRc;
}

/*****************************************************************************
 *
 *      PID_QueryInterface
 *
 *      Our QI is very simple because we support no interfaces beyond
 *      ourselves.
 *
 *      riid - Interface being requested
 *      ppvOut - receives new interface (if successful)
 *
 *****************************************************************************/

STDMETHODIMP
    PID_QueryInterface(IDirectInputEffectDriver *ped, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    if(IsEqualIID(riid, &IID_IUnknown) ||
       IsEqualIID(riid, &IID_IDirectInputEffectDriver))
    {
        PID_AddRef(ped);
        *ppvOut = ped;
        hres = S_OK;
    } else
    {
        *ppvOut = 0;
        hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      PID_DeviceID
 *
 *          DirectInput uses this method to inform us of
 *          the identity of the device.
 *
 *          For example, if a device driver is passed
 *          dwExternalID = 2 and dwInternalID = 1,
 *          then this means the interface will be used to
 *          communicate with joystick ID number 2, which
 *          corresonds to physical unit 1 in VJOYD.
 *
 *  dwDirectInputVersion
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  dwExternalID
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  fBegin
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  dwInternalID
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *  lpReserved
 *
 *          Reserved for future use (HID).
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DeviceID(IDirectInputEffectDriver *ped,
                     DWORD dwDirectInputVersion,
                     DWORD dwExternalID, DWORD fBegin,
                     DWORD dwInternalID, LPVOID pvReserved)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    LPDIHIDFFINITINFO   init = (DIHIDFFINITINFO*)pvReserved;

    EnterProcI(PID_DeviceID, (_"xxxxxx", ped, dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, pvReserved));
    
    DllEnterCrit();

    if(  init == NULL )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL init == NULL "),
                        s_tszProc );
        hres = DIERR_PID_NOTINITIALIZED;
    }
    
    if(    SUCCEEDED(hres) 
        && (init->dwSize < cbX(*init) ) )
    {
        
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL init->dwSize(%d) expecting(%d) "),
                        s_tszProc, init->dwSize, cbX(*init) );
        hres = DIERR_PID_NOTINITIALIZED;
    
    }

    if( SUCCEEDED(hres) )
    {

#ifdef UNICODE
        lstrcpy(this->tszDeviceInterface, init->pwszDeviceInterface );
#else // !UNICODE
        {
            TCHAR   tszDeviceInterface[MAX_DEVICEINTERFACE];
            UToA(tszDeviceInterface, MAX_DEVICEINTERFACE, init->pwszDeviceInterface);

            lstrcpy(this->tszDeviceInterface, tszDeviceInterface);
        }
#endif

        if( FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL:0x%x Invalid string(%s) "),
                            s_tszProc, hres, init->pwszDeviceInterface );
        }
        
        if( SUCCEEDED(hres) && IsEqualGUID(&init->GuidInstance, &GUID_NULL ) )
        {
            hres = DIERR_PID_NOTINITIALIZED;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL:init->GuidInstance is NULL "),
                            s_tszProc );
        }
        
        this->GuidInstance = init->GuidInstance;

        /* Record the DI version number */
        this->dwDirectInputVersion = dwDirectInputVersion;

        /* Keep the external ID as a cookie for access to the driver functionality */
        this->dwID = dwExternalID;
    }

    if( SUCCEEDED(hres) )
    {
        /* Ping the device to make sure it is fine */
        hres = PID_Init(ped);
    }

    /*
     *  Remember the unit number because that tells us which of
     *  our devices we are talking to.  The DirectInput external
     *  joystick number is useless to us.  (We don't care if we
     *  are joystick 1 or joystick 2.)
     *
     *  Note that although our other methods are given an external
     *  joystick Id, we don't use it.  Instead, we use the unit
     *  number that we were given here.
     *
     *  Our hardware supports only MAX_UNITS units.
     */

     DllLeaveCrit();

     ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_GetVersions
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  pvers
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the dwSize field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          E_NOTIMPL to indicate that DirectInput should retrieve
 *          version information from the VxD driver instead.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetVersions(IDirectInputEffectDriver *ped, LPDIDRIVERVERSIONS pvers)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_GetVersions, (_"xx", ped, pvers));

    DllEnterCrit();

    if(pvers->dwSize >= sizeof(DIDRIVERVERSIONS))
    {
        /*
         *  Tell DirectInput how much of the structure we filled in.
         */
        pvers->dwSize = sizeof(DIDRIVERVERSIONS);

        /*
         *  In real life, we would detect the version of the hardware
         *  that is connected to unit number this->dwUnit.
         */
        pvers->dwFirmwareRevision = 0x0;
        pvers->dwHardwareRevision = this->attr.ProductID;
        pvers->dwFFDriverVersion =  PID_DRIVER_VERSION;
        hres = S_OK;
    } else
    {
        hres = E_INVALIDARG;
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_Escape
 *
 *          DirectInput uses this method to communicate
 *          IDirectInputDevice2::Escape and
 *          IDirectInputEFfect::Escape methods to the driver.
 *
 *  dwId
 *
 *          The joystick ID number being used.
 *
 *  dwEffect
 *
 *          If the application invoked the
 *          IDirectInputEffect::Escape method, then
 *          dwEffect contains the handle (returned by
 *          mf IDirectInputEffectDriver::DownloadEffect)
 *          of the effect at which the command is directed.
 *
 *          If the application invoked the
 *          mf IDirectInputDevice2::Escape method, then
 *          dwEffect is zero.
 *
 *  pesc
 *
 *          Pointer to a DIEFFESCAPE structure which describes
 *          the command to be sent.  On success, the
 *          cbOutBuffer field contains the number
 *          of bytes of the output buffer actually used.
 *
 *          DirectInput has already validated that the
 *          lpvOutBuffer and lpvInBuffer and fields
 *          point to valid memory.
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_Escape(IDirectInputEffectDriver *ped,
                   DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_Escape, (_"xxxx", ped, dwId, dwEffect, pesc));

    hres = E_NOTIMPL;
    
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_GetForceFeedbackState
 *
 *          Retrieve the force feedback state for the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  pds
 *
 *          Receives device state.
 *
 *          DirectInput will set the dwSize field
 *          to sizeof(DIDEVICESTATE) before calling this method.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetForceFeedbackState(IDirectInputEffectDriver *ped,
                                  DWORD dwId, LPDIDEVICESTATE pds)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    USHORT  LinkCollection;

    EnterProcI(PID_GetFFState, (_"xxx", ped, dwId, pds));

    DllEnterCrit();

    hres = PID_GetLinkCollectionIndex(ped,g_PoolReport.UsagePage,g_PoolReport.Collection,0x0,&LinkCollection);
	if (SUCCEEDED(hres))
    {
        hres = PID_GetReport
				(ped, 
				 &g_PoolReport,
				 LinkCollection,
				 this->pReport[g_PoolReport.HidP_Type], 
				 this->cbReport[g_PoolReport.HidP_Type] 
				);

		if (SUCCEEDED(hres))
		{
			 if (FAILED(PID_ParseReport
					(
					ped,
					&g_PoolReport,
					LinkCollection,
					&this->ReportPool,
					cbX(this->ReportPool),
					this->pReport[g_PoolReport.HidP_Type],
					this->cbReport[g_PoolReport.HidP_Type]
					)))
			{
				SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to parse report."),
                        s_tszProc);
			}
		}
		else
		{
			SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to get report."),
                        s_tszProc);

		}
    }
	else
	{
		SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to get Link Collection Index."),
                        s_tszProc);

	}
    
    if( ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded !=  this->ReportPool.uRomETCount )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: PID driver downloaded %d effects, device claims it has %d"),
                        s_tszProc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded, this->ReportPool.uRomETCount );

    }

    if(SUCCEEDED(hres))
    {
        /*
         *  Start out empty and then work our way up.
         */
        pds->dwState = this->dwState;

        /*
         *  If there are no effects, then DIGFFS_EMPTY.
         */
        // ISSUE-2001/03/29-timgill Should use this->ReportPool.uRomETCount == 0x0  
        if(((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded == 0x0 )
        {
            pds->dwState |= DIGFFS_EMPTY;
            
            // No effects playing and device is not paused
            if(!( pds->dwState & DIGFFS_PAUSED ) )
            {
                pds->dwState |= DIGFFS_STOPPED;
            }
        }
    
		//if everything has succeeded, this->ReportPool.uRamPoolSz shouldn't be 0. 
		if (this->ReportPool.uRamPoolSz != 0)
		{
			if( this->uDeviceManaged & PID_DEVICEMANAGED )
			{
				pds->dwLoad = 100 * ( this->dwUsedMem /  this->ReportPool.uRamPoolSz ); 
			}else
			{
				pds->dwLoad = 100 * ( ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cbAlloc / this->ReportPool.uRamPoolSz  ); 
			}
		}
		else
		{
			SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: this->ReportPool.uRamPoolSz = 0."),
                        s_tszProc);
			hres = E_FAIL;
		}
    }

    DllLeaveCrit();
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_StartEffect
 *
 *          Begin playback of an effect.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *          This parameter consists of zero or more
 *          DIES_* flags.  Note, however, that the driver
 *          will never receive the DIES_NODOWNLOAD flag;
 *          the DIES_NODOWNLOAD flag is managed by
 *          DirectInput and not the driver.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_StartEffect(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect,
                        DWORD dwMode, DWORD dwCount)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_StartEffect, (_"xxxxx", ped, dwId, dwEffect, dwMode, dwCount));

    DllEnterCrit();

    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           dwMode | PID_DIES_START, 
           dwCount,
		   TRUE,
		   0,
		   1
           );

	if (SUCCEEDED(hres))
	{
		//set the status to DIEGES_PLAYING.
		//we do this because of the following: if an app calls Start(), and then immediately
		//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
		//would not have time to update the status of the effect to DIEGES_PLAYING
		//(see Whistler bug 287035).
		//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
		//at this point, we know that the call to WriteFile() has succeeded, and that
		//all the data has been written (see PID_SendReportBl() in pidhid.c) --
		//so we might as well set the status.
		PEFFECTSTATE pEffectState =  PeffectStateFromBlockIndex(this, dwEffect); 
		pEffectState->lEfState |= DIEGES_PLAYING;
	}

    
    DllLeaveCrit();
    return hres;

    ExitOleProc();
}

/*****************************************************************************
 *
 *      PID_StopEffect
 *
 *          Halt playback of an effect.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be stopped.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_StopEffect(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_StopEffect, (_"xxxx", ped, dwId, dwEffect));

    DllEnterCrit();

    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           PID_DIES_STOP, 
           0x0,
		   TRUE,
		   0,
		   1
           );

	if (SUCCEEDED(hres))
		{
			//set the status to ~(DIEGES_PLAYING).
			//we do this because of the following: if an app calls Stop(), and then immediately
			//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
			//would not have time to update the status of the effect to DIEGES_PLAYING
			//(see Whistler bug 287035).
			//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
			//at this point, we know that the call to WriteFile() has succeeded, and that
			//all the data has been written (see PID_SendReportBl() in pidhid.c) --
			//so we might as well set the status.
			PEFFECTSTATE pEffectState =  PeffectStateFromBlockIndex(this, dwEffect); 
			pEffectState->lEfState &= ~(DIEGES_PLAYING);
	}

    ExitOleProc();

    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *      PID_GetEffectStatus
 *
 *          Obtain information about an effect.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be queried.
 *
 *  pdwStatus
 *
 *          Receives the effect status in the form of zero
 *          or more DIEGES_* flags.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetEffectStatus(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect,
                            LPDWORD pdwStatus)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_GetEffectStatus, (_"xxxx", ped, dwId, dwEffect, pdwStatus));

    DllEnterCrit();

    *pdwStatus = 0x0;
    hres = PID_ValidateEffectIndex(ped, dwEffect);

    if(SUCCEEDED(hres) )
    {     
        PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect); 
            *pdwStatus = (pEffectState->lEfState & DIEGES_PLAYING);
    }
    
    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      The VTBL for our effect driver
 *
 *****************************************************************************/

IDirectInputEffectDriverVtbl PID_Vtbl = {
    PID_QueryInterface,
    PID_AddRef,
    PID_Release,
    PID_DeviceID,
    PID_GetVersions,
    PID_Escape,
    PID_SetGain,
    PID_SendForceFeedbackCommand,
    PID_GetForceFeedbackState,
    PID_DownloadEffect,
    PID_DestroyEffect,
    PID_StartEffect,
    PID_StopEffect,
    PID_GetEffectStatus,
};

/*****************************************************************************
 *
 *      PID_New
 *
 *****************************************************************************/

STDMETHODIMP
    PID_New(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;
    CPidDrv *this;

    this = LocalAlloc(LPTR, sizeof(CPidDrv));
    if(this)
    {

        /*
         *  Initialize the basic object management goo.
         */
        this->ed.lpVtbl = &PID_Vtbl;
        this->cRef = 1;
        DllAddRef();

        /*
         *  !!IHV!! Do instance initialization here.
         *
         *  (e.g., open the driver you are going to IOCTL to)
         *
         *  DO NOT RESET THE DEVICE IN YOUR CONSTRUCTOR!
         *
         *  Wait for the SendForceFeedbackCommand(SFFC_RESET)
         *  to reset the device.  Otherwise, you may reset
         *  a device that another application is still using.
         */

        this->hdevOvrlp = this->hdev = INVALID_HANDLE_VALUE;
        
        /*
         *  Attempt to obtain the desired interface.  QueryInterface
         *  will do an AddRef if it succeeds.
         */
        hres = PID_QueryInterface(&this->ed, riid, ppvOut);
        PID_Release(&this->ed);

    } else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\makefile.inc ===
$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\main.c ===
/*****************************************************************************
 *
 *  Main.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template effect driver that doesn't actually do anything.
 *
 *****************************************************************************/

#include "PIDpr.h"
/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst = NULL;              /* This DLL's instance handle */
PSHAREDMEMORY g_pshmem = NULL;         /* Our shared memory block */
HANDLE g_hfm = NULL;                   /* Handle to file mapping object */
HANDLE g_hmtxShared = NULL;            /* Handle to mutex that protects g_pshmem */

CANCELIO CancelIo_ = FakeCancelIO;

#ifdef DEBUG
LONG   g_cCrit = 0;
ULONG   g_thidCrit = 0;
PTCHAR   g_rgUsageTxt[PIDUSAGETXT_MAX];    // Cheat sheet for PID usages
#endif
TRYENTERCRITICALSECTION TryEnterCriticalSection_ = FakeTryEnterCriticalSection;

/*****************************************************************************
 *
 *      Dynamic Globals.  There should be as few of these as possible.
 *
 *      All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

LONG g_cRef = 0;                   /* Global reference count */
CRITICAL_SECTION g_crst;        /* Global critical section */

/*****************************************************************************
 *
 *      DllAddRef / DllRelease
 *
 *      Adjust the DLL reference count.
 *
 *****************************************************************************/

STDAPI_(ULONG)
DllAddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&g_cRef);
}

STDAPI_(ULONG)
DllRelease(void)
{
    return (ULONG)InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void EXTERNAL
 DllEnterCrit_(LPCTSTR lptszFile, UINT line)
{            
#ifdef DEBUG
    if( ! TryEnterCriticalSection_(&g_crst) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&g_crst);
    }
    
    if (g_cCrit++ == 0) {
        g_thidCrit = GetCurrentThreadId();
    
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Entered @%s,%d"), lptszFile, line);    
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#else
    EnterCriticalSection(&g_crst);
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit_(LPCTSTR lptszFile, UINT line)
{
#ifdef DEBUG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0) {
        g_thidCrit = 0;
    }
    SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Leaving @%s,%d"), lptszFile, line);    
#endif
    LeaveCriticalSection(&g_crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
DllInCrit(void)
{        
    return g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *      DllGetClassObject
 *
 *      OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (IsEqualGUID(rclsid, &IID_IDirectInputPIDDriver)) {
        hres = CClassFactory_New(riid, ppvObj);
    } else {
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      DllCanUnloadNow
 *
 *      OLE entry point.  Fail iff there are outstanding refs.
 *
 *****************************************************************************/

STDAPI
DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/*****************************************************************************
 *
 *      DllNameFromGuid
 *
 *      Create the string version of a GUID.
 *
 *****************************************************************************/

STDAPI_(void)
DllNameFromGuid(LPTSTR ptszBuf, LPCGUID pguid)
{
    wsprintf(ptszBuf,
             TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
             pguid->Data1, pguid->Data2, pguid->Data3,
             pguid->Data4[0], pguid->Data4[1],
             pguid->Data4[2], pguid->Data4[3],
             pguid->Data4[4], pguid->Data4[5],
             pguid->Data4[6], pguid->Data4[7]);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeCancelIO |
 *
 *          Stub function which doesn't do anything but
 *          keeps us from crashing.
 *
 *  @parm   HANDLE | h |
 *
 *          The handle whose I/O is supposed to be cancelled.
 *
 *****************************************************************************/

BOOL WINAPI
    FakeCancelIO(HANDLE h)
{
    AssertF(0);
    return FALSE;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeTryEnterCriticalSection |
 *
 *          We use TryEnterCriticalSection in DEBUG to detect deadlock
 *          If the function does not exist, just enter CritSection and report
 *          true. This compromises some debug functionality.           
 *
 *  @parm   LPCRITICAL_SECTION | lpCriticalSection |
 *
 *          Address of Critical Section to be entered. 
 *
 *****************************************************************************/

BOOL WINAPI
    FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    return TRUE;
}
/*****************************************************************************
 *
 *      DllOnProcessAttach
 *
 *      Initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(BOOL)
DllOnProcessAttach(HINSTANCE hinst)
{
    TCHAR tszName[256];
    HINSTANCE hinstK32;
    TCHAR c_tszKernel32[] = TEXT("KERNEL32");
    
    // Cache the instance handle
    g_hinst = hinst;
    
    hinstK32 = GetModuleHandle( c_tszKernel32 );
    if(hinstK32 != INVALID_HANDLE_VALUE)
    {
        CANCELIO tmp;
        TRYENTERCRITICALSECTION tmpCrt;

        tmp = (CANCELIO)GetProcAddress(hinstK32, "CancelIo");
        if (tmp) {
            CancelIo_ = tmp;
        } else {
            AssertF(CancelIo_ == FakeCancelIO);
        }

        tmpCrt = (TRYENTERCRITICALSECTION)GetProcAddress(hinstK32, "TryEnterCriticalSection");
        if(tmpCrt)
        {
            TryEnterCriticalSection_ = tmpCrt;            
        }else
        {
            AssertF(TryEnterCriticalSection_ == FakeTryEnterCriticalSection);
        }
    }

    #ifdef DEBUG
    Sqfl_Init();
    #endif
    /*
     *  Performance tweak: We do not need thread notifications.
     */
    DisableThreadLibraryCalls(hinst);

    /*
     *  !!IHV!! Initialize your DLL here.
     */

    __try 
    {
        InitializeCriticalSection(&g_crst);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return FALSE; // usually out of memory condition
    }

    /*
     *  Create our mutex that protects the shared memory block.
     *  If it already exists, then we get access to the one that
     *  already exists.
     *
     *  The name of the shared memory block is GUID_MyMutex.
     */
    DllNameFromGuid(tszName, &GUID_MyMutex);

    g_hmtxShared = CreateMutex(NULL, FALSE, tszName);

    if (g_hmtxShared == NULL) {
        return FALSE;
    }

    /*
     *  Create our shared memory block.  If it already exists,
     *  then we get access to the one that already exists.
     *  If it doesn't already exist, then it gets created
     *  zero-filled (which is what we want anyway).
     *
     *  The name of the shared memory block is GUID_MySharedMemory.
     */
    DllNameFromGuid(tszName, &GUID_MySharedMemory);

    g_hfm = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
                              PAGE_READWRITE, 0,
                              sizeof(SHAREDMEMORY),
                              tszName);

    if (g_hfm == NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;

        return FALSE;
    }

    g_pshmem = MapViewOfFile(g_hfm, FILE_MAP_WRITE | FILE_MAP_READ,
                      0, 0, 0);
    
    if (g_pshmem == NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;

        CloseHandle(g_hfm);
        g_hfm = NULL;
        return FALSE;
    }

    return TRUE;

}

/*****************************************************************************
 *
 *      DllOnProcessDetach
 *
 *      De-initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(void)
DllOnProcessDetach(void)
{
    /*
     *  !!IHV!! De-initialize your DLL here.
     */

    if (g_pshmem != NULL) {
        UnmapViewOfFile(g_pshmem);
        g_pshmem = NULL;
    }

    if (g_hfm != NULL) {
        CloseHandle(g_hfm);
        g_hfm = NULL;
    }

    if (g_hmtxShared != NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;
    }

    DeleteCriticalSection(&g_crst);
}

/*****************************************************************************
 *
 *      DllEntryPoint
 *
 *      DLL entry point.
 *
 *****************************************************************************/

STDAPI_(BOOL)
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        return DllOnProcessAttach(hinst);

    case DLL_PROCESS_DETACH:
        DllOnProcessDetach();
        break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidhid.c ===
/*****************************************************************************
 *  PidHid.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      HID utility routines for PID .
 *
 *****************************************************************************/
#include "PidPr.h"

#define sqfl        (   sqflHid   )

/*****************************************************************************
 *
 *      PID_GetReportId
 *
 *          Obtain the HID report ID given the usage, usagePage and LinkCollection
 *
 *  IDirectInputEffectDriver | ped |
 *
 *          The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *          Address of PIDREPORT structure
 *
 *  USHORT | uLinkCollection |
 *  
 *          LinkCollection ID
 *
 *  OUT UCHAR * | pReportId |
 *
 *          Report ID. Undefined if unsuccessful 
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *
 *****************************************************************************/
STDMETHODIMP
    PID_GetReportId
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport, 
    USHORT  uLinkCollection,
    UCHAR* pReportId
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI(PID_GetReportId, (_"xxxx", ped, pPidReport, pReportId));

    if( SUCCEEDED(hres) )
    {
        HIDP_VALUE_CAPS ValCaps;
        USHORT cAValCaps = 0x1;
        USAGE  Usage = DIGETUSAGE(pPidReport->rgPidUsage->dwUsage);
        USAGE  UsagePage = DIGETUSAGEPAGE(pPidReport->rgPidUsage->dwUsage);

        hres = HidP_GetSpecificValueCaps
               (
               pPidReport->HidP_Type,
               UsagePage,
               uLinkCollection,
               Usage,
               &ValCaps,
               &cAValCaps,
               this->ppd 
               );

        // If the report has no values, only buttons
        if(hres == HIDP_STATUS_USAGE_NOT_FOUND )
        {
            // Guarded Laziness 
            CAssertF(cbX(HIDP_VALUE_CAPS) == cbX(HIDP_BUTTON_CAPS) ); 
            CAssertF(FIELD_OFFSET(HIDP_VALUE_CAPS, ReportID) == FIELD_OFFSET(HIDP_BUTTON_CAPS, ReportID) );

            hres = HidP_GetSpecificButtonCaps
                   (
                   pPidReport->HidP_Type,
                   UsagePage,
                   uLinkCollection,
                   0x0,
                   (PHIDP_BUTTON_CAPS)&ValCaps,
                   &cAValCaps,
                   this->ppd 
                   );
        }

        if( SUCCEEDED(hres ) || ( hres == HIDP_STATUS_BUFFER_TOO_SMALL) )
        {
            (*pReportId) = ValCaps.ReportID;
            hres = S_OK;
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HidP_GetValCaps for CollectionId%d (%x %x:%s) "),
                            s_tszProc, uLinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage) );
        }
    }

    ExitOleProc();

    return hres;
}
/*****************************************************************************
 *
 *      PID_GetCollectionIndex
 *
 *          Obtain the collection index for collection usage page & usage.
 *
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be queried.
 *
 *  pdwStatus
 *
 *          Receives the effect status in the form of zero
 *          or more DIEGES_* flags.
 *
 *  Returns:
 *          Collection Index ( 0 .. NumberLinkCollectionNodes -1 ) on success
 *          0x0 on failure
 *
 *****************************************************************************/
STDMETHODIMP
    PID_GetLinkCollectionIndex
    (
    IDirectInputEffectDriver *ped,
    USAGE UsagePage, 
    USAGE Collection,
    USHORT Parent,
    PUSHORT puLinkCollection )
{
    CPidDrv *this = (CPidDrv *)ped;
    USHORT indx;
    HRESULT hres;
    PHIDP_LINK_COLLECTION_NODE  pLinkCollection;

    EnterProcI(PID_GetLinkCollectionIndex, (_"xxxxx", this, UsagePage, Collection, Parent, puLinkCollection));
    hres = DIERR_PID_USAGENOTFOUND;

    *puLinkCollection = 0x0;
    for(indx = 0x0, pLinkCollection = this->pLinkCollection; 
       indx < this->caps.NumberLinkCollectionNodes; 
       indx++, pLinkCollection++ )
    {

        if( pLinkCollection->LinkUsagePage == UsagePage && 
            pLinkCollection->LinkUsage     == Collection )
        {
            if( Parent && Parent != pLinkCollection->Parent )
            {
                continue;
            }
            *puLinkCollection = indx;
            hres = S_OK;
            break;
        }
    }

    if( FAILED(hres) )
    {
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("%s: FAIL No LinkCollection for (%x %x:%s) "),
                        s_tszProc, UsagePage, Collection, PIDUSAGETXT(UsagePage,Collection) );
    }else
    {
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("%s: LinkCollection for (%x %x:%s)=%x "),
                        s_tszProc, UsagePage, Collection, PIDUSAGETXT(UsagePage,Collection), *puLinkCollection );
    }

    ExitBenignOleProc();
    return (hres) ;
}


//Helper fn to tell us when we're dealing w/ an "absolute" usage, since they require special handling
BOOL PID_IsUsageAbsoluteLike
    (
	IDirectInputEffectDriver *ped,
    USHORT			Usage
    )
{
	//"Absolute-like" usages need special handling, 
	//since we can't simply translate data into logical units by scaling
	//but need to calculate exponent, etc.
	//and then use special procedure to set the values
	//"Absolute" usages are all time usages as well as trigger button usages
	if ((Usage == HID_USAGE_PID_DURATION) || (Usage ==HID_USAGE_PID_SAMPLE_PERIOD ) ||
		(Usage == HID_USAGE_PID_TRIGGER_REPEAT_INTERVAL) || (Usage == HID_USAGE_PID_START_DELAY) ||
		(Usage == HID_USAGE_PID_ATTACK_TIME ) ||(Usage == HID_USAGE_PID_FADE_TIME) || 
		(Usage == HID_USAGE_PID_PERIOD) || (Usage == HID_USAGE_PID_TRIGGER_BUTTON))
	{
		return TRUE;
	}

	return FALSE;
}


//Helper fn to tell us when we're dealing w/ a magnitude that can be both positive and negative, 
//since we have to scale those differently
BOOL PID_IsUsagePositiveNegative
    (
	IDirectInputEffectDriver *ped,
    USHORT			Usage,
	USHORT			LinkCollection
    )
{
	BOOL isPosNeg = FALSE;
	//All the usages corresponding to the structures given by LONGs can be positive or negative.
	//Exception is the direction / angle, which should already be scaled into the range 0 - 360 * DI_DEGREES, 
	//so should be treated as only positive.
	//Another exception is DICONDITION.lDeadband, which is defined as a LONG, but our headers
	//say it can only be in the range 0 to DI_FFNOMINALMAX.
	if ((Usage == HID_USAGE_PID_CP_OFFSET) ||
		(Usage == HID_USAGE_PID_POSITIVE_COEFFICIENT) || (Usage == HID_USAGE_PID_NEGATIVE_COEFFICIENT) ||
		(Usage == HID_USAGE_PID_RAMP_START) ||(Usage == HID_USAGE_PID_RAMP_END) || 
		(Usage == HID_USAGE_PID_OFFSET))
	{
		isPosNeg = TRUE;
	}

	//Magnitude of the constant force and the magnitude of the periodic force are defined to be the same thing,
	//but only the constant force magnitude can be both positive and negative.
	//To distinguish them, need to look at the collection. 
	//Get constant force's collection and compare.
	if (Usage == HID_USAGE_PID_MAGNITUDE)
	{
		USHORT ConstCollection = 0x0;
		PID_GetLinkCollectionIndex(ped, g_Constant.UsagePage, g_Constant.Collection, 0x0, &ConstCollection);
		if (LinkCollection == ConstCollection)
		{
			isPosNeg = TRUE;
		}
	}

	return isPosNeg;
}


STDMETHODIMP
    PID_PackValue
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT     hres;
    PPIDUSAGE   pPidUsage;
    UINT        indx;

    EnterProcI( PID_PackValue, (_"xxxxxxx", ped, pPidReport, LinkCollection, pvData, cbData, pReport, cbReport));

    hres = S_OK;
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if( pPidUsage->DataOffset < cbData )
        {
            LONG        lValue;
            NTSTATUS    ntStat;
            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);

		    lValue = *((LONG*)((UCHAR*)pvData+pPidUsage->DataOffset));

			ntStat = HidP_SetScaledUsageValue 
					 (
					 pPidReport->HidP_Type,
					 UsagePage,
					 LinkCollection,
					 Usage,
					 lValue,
					 this->ppd,
					 pReport,
					 cbReport
					 );

			if( FAILED(ntStat) )
			{
				// HidP_SetScaledUsageValue FAILED

				SquirtSqflPtszV(sqfl | sqflBenign,
							TEXT("%s: FAIL HidP_SetScaledUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
							s_tszProc, ntStat, 
							LinkCollection, UsagePage, Usage,
							PIDUSAGETXT(UsagePage,Usage), 
							lValue );

				// Try to set the unscaled value to get something that might make sense
				if( ntStat != HIDP_STATUS_USAGE_NOT_FOUND )
				{
					lValue = -1;
					// The range could be messed up. 
					ntStat = HidP_SetUsageValue 
							 (
							 pPidReport->HidP_Type,
							 UsagePage,
							 LinkCollection,
							 Usage,
							 lValue,
							 this->ppd,
							 pReport,
							 cbReport
							 );
					if(FAILED(ntStat) )
					{
					SquirtSqflPtszV(sqfl | sqflBenign,
								TEXT("%s: FAIL HidP_SetUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
								s_tszProc, ntStat, 
								LinkCollection, UsagePage, Usage,
								PIDUSAGETXT(UsagePage,Usage), 
								lValue );
					}
				}
			
			} else
			{
				SquirtSqflPtszV(sqfl | sqflVerbose,
							TEXT("%s: HidP_SetScaledUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
							s_tszProc, ntStat, 
							LinkCollection, UsagePage, Usage,
							PIDUSAGETXT(UsagePage,Usage), 
							lValue );
			}
		} else
		{
            //SquirtSqflPtszV(sqfl | sqflBenign,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
		}
    }
    ExitOleProc();
    return hres;
}


//blocking version -- used for creating a new effect or destroying an effect, and for custom forces
STDMETHODIMP 
    PID_SendReportBl
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProcI( PID_SendReportBl, (_"xxxx", ped, pReport, cbReport, HidP_Type));

    hres = S_OK;
    if( HidP_Type == HidP_Output )
    {
        BOOL frc;
        UINT cbWritten;

        frc = WriteFile (this->hdev,
                         pReport,
                         cbReport,
                         &cbWritten,
                         NULL);

        if( frc != TRUE || cbWritten != cbReport )
        {
            LONG lrc = GetLastError();
            hres = hresLe(lrc);
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL WriteFile():%d (cbWritten(0x%x) cbReport(0x%x) Le(0x%x)"),
                            s_tszProc, frc, cbWritten, cbReport, lrc );

        }
    } else if( HidP_Type == HidP_Feature )
    {
        hres = HidD_SetFeature
               (this->hdev,
                pReport,
                cbReport
               );
        if(FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL SendD_Feature() hres:0x%x"),
                            s_tszProc, hres );

        }

    } else
    {
        hres = DIERR_PID_USAGENOTFOUND;
    }
    ExitOleProc();
    return hres;
}


STDMETHODIMP 
    PID_SendReport
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type,
	BOOL	bBlocking,
	UINT	blockNr,
	UINT	totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_SendReport, (_"xxxx", ped, pReport, cbReport, HidP_Type));

	if (bBlocking == TRUE)
	{
		hres = PID_SendReportBl(ped, pReport, cbReport, HidP_Type);
	}
	else
	{
		AssertF(this->hThread != 0x0);
		AssertF(this->hWrite != 0x0);
		AssertF(this->hWriteComplete != 0x0);

		//blockNr is 0-based.
		AssertF(totalBlocks > 0);
		AssertF(blockNr < totalBlocks);

		if( HidP_Type == HidP_Output )
		{
			//WaitForMultipleObjects() till the completion event becomes set.
			//we save each report into the appropriate place in the array.
			//when we get all the reports, we set the event to signal to the other thread to write.
			// Windows bug 627797 -- do not use INFINITE wait, so that we don't hang the app
			//if smth goes wrong w/ the previous write, but instead use the blocking version.
			DWORD dwWait = WaitForMultipleObjects(1, &this->hWriteComplete, FALSE, 1000);
			if (dwWait == WAIT_OBJECT_0)
			{
				AssertF(this->dwWriteAttempt == 0);
				//save the report data
				ZeroMemory(this->pWriteReport[blockNr], this->cbWriteReport[blockNr]);
				memcpy(this->pWriteReport[blockNr], pReport, cbReport);
				this->cbWriteReport[blockNr] = (USHORT)cbReport;
				if (blockNr == totalBlocks-1)
				{
					this->totalBlocks = totalBlocks;
					this->blockNr = 0;
					ResetEvent(this->hWriteComplete);
					SetEvent(this->hWrite);
				}
			}
			else
			{
				//The wait interval has expired, or an error has occured
				RPF( TEXT("Waiting for the write completion event ended without the event being signaled, dwWait = %u"), dwWait);
				//call the blocking version
				hres = PID_SendReportBl(ped, pReport, cbReport, HidP_Type);
			}

		} else if( HidP_Type == HidP_Feature )
		{
			hres = HidD_SetFeature
					 (this->hdev,
					pReport,
					cbReport
					  );
			if(FAILED(hres) )
			{
				SquirtSqflPtszV(sqfl | sqflError,
								TEXT("%s: FAIL SendD_Feature() hres:0x%x"),
								s_tszProc, hres );

			}

		} else
		{
			hres = DIERR_PID_USAGENOTFOUND;
		}
	}

    ExitOleProc();
    return hres;
}

STDMETHODIMP
    PID_ParseReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    PPIDUSAGE   pPidUsage;
    UINT        indx;
    EnterProcI( PID_ParseReport, (_"xxxxxxx", ped, pPidReport, pvData, cbData, pReport, cbReport));

    hres = S_OK;
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if( pPidUsage->DataOffset < cbData )
        {
            LONG        lValue;
            NTSTATUS    ntStat;
            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);

            ntStat = HidP_GetScaledUsageValue 
                     (
                     pPidReport->HidP_Type,
                     UsagePage,
                     LinkCollection,
                     Usage,
                     &lValue,
                     this->ppd,
                     pReport,
                     cbReport
                     );

            if(SUCCEEDED(ntStat))
            {
                *((LONG*)((UCHAR*)pvData+pPidUsage->DataOffset)) = lValue;
            } else
            {
                hres |= E_NOTIMPL;
                                SquirtSqflPtszV(sqfl | sqflBenign,
                                                TEXT("%s: FAIL HidP_GetScaledUsageValue:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                LinkCollection, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage,Usage) );
            }
        } else
        {

            SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
                            s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }
    ExitBenignOleProc();
    return hres;
}



STDMETHODIMP 
    PID_GetReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pReport,
    UINT        cbReport
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    UCHAR       ReportId;
    EnterProcI( PID_GetReport, (_"xxxxx", ped, pPidReport, LinkCollection, pReport, cbReport));

    if( SUCCEEDED(hres) )
    {
        hres = PID_GetReportId(ped, pPidReport, LinkCollection, &ReportId);

        if(SUCCEEDED(hres) )
        {
            AssertF(pPidReport->HidP_Type == HidP_Feature);

            if(SUCCEEDED(hres) )
            {
                ZeroBuf(pReport, cbReport);

                /*
                 *  The Win9x headers do not yet have use HidP_InitializeReportForID 
                 *  use MAXULONG_PTR to tell the header sets apart so that we can still build
                 */

#ifdef WINNT    
                /*hres*=*/HidP_InitializeReportForID 
                    (
                    pPidReport->HidP_Type,  //ReportType,
                    ReportId,               //ReportID,
                    this->ppd,              //PreparsedData
                    pReport,                //Report
                    cbReport                //ReportLength
                    );
#else
                (*(PUCHAR)pReport) = ReportId;
                hres = S_OK;
#endif
                if( FAILED(hres) )
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%s: FAIL HidP_InitializeReportForId:0x%x for Type(%d) CollectionId%d ReportID%d "),
                                    s_tszProc, hres, pPidReport->HidP_Type, LinkCollection, ReportId );
                }

                if(    SUCCEEDED(hres) 
                       && pPidReport->HidP_Type == HidP_Feature )
                {
                    BOOL frc;
                    frc = HidD_GetFeature 
                          (
                          this->hdev,     // HidDeviceObject,
                          pReport,        // ReportBuffer,
                          cbReport       //ReportBufferLength
                          );

                    if( frc != TRUE )
                    {
                        hres = DIERR_PID_USAGENOTFOUND;
                    }
                }
            }
        }
    }
    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *      PID_ComputeScalingFactors
 *
 *      Dinput units for various parameters are well defined. The device may choose
 *      to implement the units that it is most comfortable with. This routine
 *      computes scaling factors that are to be used when scaling DINPUT parameters
 *      before they are send to the device. 
 *
 *  IDirectInputEffectDriver | ped |
 *
 *          The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *          Address of PIDREPORT structure
 *
 *  USHORT | uLinkCollection |
 *  
 *          LinkCollection ID
 *
 *  IN OUT PVOID | pvData | 
 *
 *          Parameter data. On entry value is the nominal scale used by Dinput.
 *          For example: Angles: DI_DEGREES, DI_FFNOMINALMAX, DI_SECONDS 
 *
 *  IN UINT | cbData | 
 *
 *          Number of valid DWORDS in pvData
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *          E_NOTIMPL:						Did not find any usage / usage Page 
 *          DIERR_PID_INVALIDSCALING:		Unsupported device scaling parameters.
 *          S_OK:							Scaling value for at least one parameter was found
 *
 *****************************************************************************/

STDMETHODIMP
    PID_ComputeScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
	PVOID		pvOffset,
	UINT		cbOffset
    )
{
    HRESULT hres = E_NOTIMPL;
    CPidDrv *this = (CPidDrv *)ped;
    UINT indx;
    PPIDUSAGE   pPidUsage;

    EnterProcI( PID_ComputeScalingFactors, (_"xxxxxxx", ped, pPidReport, LinkCollection, pvData, cbData, pvOffset, cbOffset));

    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if (( pPidUsage->DataOffset < cbData ) && (pPidUsage->DataOffset < cbOffset))
        {
            NTSTATUS    ntStat;
            HIDP_VALUE_CAPS ValCaps;
            USHORT      cAValCaps = 0x1;

            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);
            PDWORD      pdwValue;
			PDWORD      pdwOffset;    
            DWORD       dwScale = 0x1;
			DWORD		dwOffset = 0x0;

            pdwValue = ((DWORD*)((UCHAR*)pvData+pPidUsage->DataOffset));
			pdwOffset = ((DWORD*)((UCHAR*)pvOffset+pPidUsage->DataOffset));

            ntStat = HidP_GetSpecificValueCaps 
                     (
                     pPidReport->HidP_Type,
                     UsagePage,
                     LinkCollection,
                     Usage,
                     &ValCaps,
                     &cAValCaps,
                     this->ppd
                     );

            if(SUCCEEDED(ntStat))
            {
		//some units are "absolute" and thus don't need to be scaled to the limits.
				//for them, we just find out the correct units
		if (PID_IsUsageAbsoluteLike(ped, Usage))
		{
			if( ! ValCaps.Units )
			{
				SquirtSqflPtszV(sqfl | sqflVerbose,
						TEXT("%s:No Units(%x,%x %x:%s) Max:%d Scale:%d "),
						s_tszProc, LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage),
						ValCaps.PhysicalMax, dwScale );
				// No units, scaling exponent is default = 1
				hres = S_FALSE;
			} else
			{
				LONG UnitExp;
				UnitExp = (LONG)ValCaps.UnitsExp ;

				if( UnitExp > 0x0 )
				{
					RPF(TEXT("Driver does not support Units (%x,%x %x:%s) Exp:%d Max:%d"),
						LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage), ValCaps.UnitsExp, ValCaps.PhysicalMax ) ;
					hres = DIERR_PID_INVALIDSCALING;
				}else
				{
					hres = S_OK;
				}

				if(SUCCEEDED(hres) )
				{
					dwScale = (*pdwValue);
					for(; UnitExp; UnitExp++ )
				{
					dwScale /= 10;
				}

				if( dwScale == 0 )
				{
					RPF(TEXT("Driver does not support Units (%x,%x %x:%s) Exp:%d Max:%d"),
						LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage), ValCaps.UnitsExp, ValCaps.PhysicalMax ) ;
					dwScale = 0x1;
					hres = DIERR_PID_INVALIDSCALING;
				}else
				{ 
					hres = S_OK;
				}
			}
			SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%s: (%x,%x %x:%s) Exp%d Max:%d Scale:%d "),
                                    s_tszProc, LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage),
                                    ValCaps.UnitsExp, ValCaps.PhysicalMax, (*pdwValue) );
			}
		}
		else
		{
			//for everything else, get Physical and /or Logical  Min/ Max
			//From PID spec, doesn't have to have a Physical / Logical Min, but does have to have either Physical or Logical Max
			if ((!ValCaps.PhysicalMax) && (!ValCaps.LogicalMax))
			{
				RPF(TEXT("Driver does not have either Physical Max or Logical Max for (%x,%x %x:%s)"),
					LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage)) ;
				hres = DIERR_PID_INVALIDSCALING;
			}
			else
			{
				//Compute the scaling value from either Physical or Logical Min/ Max and store it
				int Scale = 0;
				int Min = 0;
				int Max = 0;
				if (ValCaps.PhysicalMax)
				{
					Max = ValCaps.PhysicalMax;
					if (ValCaps.PhysicalMin)
					{
						Min = ValCaps.PhysicalMin;
					}
				}
				else 
				{
					Max = ValCaps.LogicalMax;
					if (ValCaps.LogicalMin)
					{
						Min = ValCaps.LogicalMin;
					}
				}
#ifdef DEBUG
				//if Min/max are not in correct order, print a message so that we know if there are any problems w/ the forces
				if (Min >= Max)
				{
					RPF(TEXT("Maximum of the device's range is %d, not bigger than minimum %d"), Max, Min);
				}
#endif
				//certain magnitudes can be both positive and negative -- for those, we need to know the device's offset
				if (PID_IsUsagePositiveNegative(ped, Usage, LinkCollection))
				{
					
					Scale = (Max - Min)/2; 
					dwOffset = (Max + Min)/2; 

				}
				//other magnitudes can only be positive
				else
				{
					Scale = Max - Min;
					dwOffset = Min;
				}
				//for angular usages, multiply by DI_FFNOMINALMAX and divide by 360 * DI_DEGREES
				//we are doing this since later we will have no way of knowing that the values represent angles,
				//and will thus divide all the values by DI_FFNOMINALMAX
				if (*pdwValue == 360 * DI_DEGREES)
				{
					dwScale = MulDiv(Scale, DI_FFNOMINALMAX, (360 * DI_DEGREES));
				}
				else
				{
					dwScale = Scale;
				}
				hres = S_OK;
			}
		}

            } else
            {
                // HidP_SetScaledUsageValue FAILED
                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpecificValueCaps:0x%x for(%x,%x,%x:%s)=0x%x "),
                                s_tszProc, ntStat, 
                                LinkCollection, UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage), 
                                dwScale );
            }

            (*pdwValue) = dwScale;
			(*pdwOffset) = dwOffset;
        } else
        {
            //SquirtSqflPtszV(sqfl | sqflVerbose,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_ApplyScalingFactors
 *
 *      Dinput units for various parameters are well defined. The device may choose
 *      to implement the units that it is most comfortable with. This routine
 *      apply scaling factors that are to be used when scaling DINPUT parameters
 *      before they are send to the device. 
 *
 *  IDirectInputEffectDriver | ped |
 *
 *      The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *      Address of PIDREPORT structure
 *
 *  IN PVOID | pvScale |
 *  
 *      Scaling values
 *
 *  IN UINT | cbScale | 
 *
 *      Number of scaling values.
 *
 *  IN OUT PVOID | pvData | 
 *
 *      Array of data values.
 *
 *  IN UINT | cbData | 
 *
 *      Number of data values. 
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *          E_NOTIMPL:						Did not find any usage / usage Page 
 *          DIERR_PID_INVALIDSCALING:				Unsupported device scaling parameters.
 *          S_OK:						Scaling value for at least one parameter was found
 *
 *****************************************************************************/


STDMETHODIMP
    PID_ApplyScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    PVOID       pvScale,
    UINT        cbScale,
	PVOID		pvOffset,
	UINT		cbOffset,
    PVOID       pvData,
    UINT        cbData
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    UINT indx;
    PPIDUSAGE   pPidUsage;
    EnterProcI( PID_ApplyScalingFactors, (_"xxxxxxxx", ped, pPidReport, pvScale, cbScale, pvOffset, cbOffset, pvData, cbData));
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure we the offsets are valid
        if( (pPidUsage->DataOffset < cbData) &&
            (pPidUsage->DataOffset < cbScale) && ((pPidUsage->DataOffset < cbOffset) ))
        {
			PUINT      pValue;        
			PUINT      pScale;
			PUINT	   pOffset;

			pValue = ((PUINT)((UCHAR*)pvData    +pPidUsage->DataOffset));
			pScale = ((PUINT)((UCHAR*)pvScale   +pPidUsage->DataOffset));
			pOffset = ((PUINT)((UCHAR*)pvOffset   +pPidUsage->DataOffset));

			//"absolute"-like usages need special handling, because they don't need to be scaled to the max device values
			if (PID_IsUsageAbsoluteLike(ped, DIGETUSAGE(pPidUsage->dwUsage)))
			{
				if( (*pScale) > 0x1 )
				{
					(*pValue) /= (*pScale) ;    
				}
			}
			//for everything else, do a calculation based on Logical or Physical Min/ Max
			else
			{
				(int)(*pValue) = MulDiv((*pScale), (*pValue), DI_FFNOMINALMAX) + (*pOffset);
			}
        } else
        {
            //SquirtSqflPtszV(sqfl | sqflBenign,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }

    ExitOleProc();
    return hres;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidi.h ===
/*****************************************************************************
 *
 *  Pidi.h
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Internal header for PID driver.
 *
 *****************************************************************************/
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))
#define HidP_Max                                        (HidP_Feature+1)

#define REGSTR_PATH_VID_PID_TEMPLATE    REGSTR_PATH_JOYOEM TEXT("\\VID_%04X&PID_%04X")
#define REGSTR_OEM_FF_TEMPLATE          REGSTR_PATH_VID_PID_TEMPLATE TEXT("\\OEMForceFeedback")
#define REGSTR_EFFECTS                  TEXT("Effects")
#define REGSTR_ATTRIBUTES               TEXT("Attributes")
#define REGSTR_CLSID                    TEXT("CLSID")
#define REGSTR_CREATEDBY                TEXT("CreatedBy")
#define MAX_DEVICEINTERFACE             (1024)

#define PIDMAKEUSAGEDWORD(Usage) \
    DIMAKEUSAGEDWORD(HID_USAGE_PAGE_PID, HID_USAGE_PID_##Usage )

#define DIGETUSAGEPAGE(UsageAndUsagePage)   ((USAGE)(HIWORD(UsageAndUsagePage)))
#define DIGETUSAGE(    UsageAndUsagePage)   ((USAGE)(LOWORD(UsageAndUsagePage)))
#define MAKE_PIDUSAGE( Usage, Offset )      { PIDMAKEUSAGEDWORD(Usage), Offset }
#define MAKE_HIDUSAGE( UsagePage, Usage, Offset )   { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_##UsagePage, Usage), Offset }


#define PID_DIES_START      (0x80000000)
#define PID_DIES_STOP       (0x40000000)
#define PIDALLOC_INIT       (0xF)

#define HID_VALUE           (0x01)
#define HID_BUTTON          (0x02)
#define HID_COLLECTION      (0x04)

#define MAX_ORDINALS        (8)
#define MAX_BUTTONS         (0xff)
#define MAX_AXES            (8)

/*
 *  Device-specific errors for USB/PID force feedback devices. 
 */

/*
 *  The requested usage was not found.
 */
#define  DIERR_PID_USAGENOTFOUND	DIERR_DRIVERFIRST + 1

/*
 *  The parameter block couldn't be	downloaded to the device.
 */
#define DIERR_PID_BLOCKLOADERROR	DIERR_DRIVERFIRST + 2

/*
 *  PID initialization failed.
 */
#define DIERR_PID_NOTINITIALIZED	DIERR_DRIVERFIRST + 3

/*
 *  The provided values couldn't be scaled.
 */
#define DIERR_PID_INVALIDSCALING	DIERR_DRIVERFIRST + 4


typedef CONST GUID *LPCGUID;
#ifndef MAXULONG_PTR
typedef DWORD   ULONG_PTR;
typedef DWORD   *PULONG_PTR;
typedef DWORD   UINT_PTR;
typedef DWORD   *PULONG_PTR;
#endif //MAXULONG_PTR


/*****************************************************************************
 *
 *      For each active unit, one of these structures exists to keep
 *      track of which effects are "in use".
 *
 *      Our imaginary hardware does not do dynamic memory allocation;
 *      there are merely 16 "slots", and each "slot" can be "in use"
 *      or "free".
 *
 *****************************************************************************/

#define MAX_UNITS        4
#define GLOBAL_EFFECT_MEMSZ ( 1024 )

typedef struct _PIDMEM{
    ULONG       uOfSz;
    INT_PTR     iNext;
} PIDMEM, *PPIDMEM;


#define PIDMEM_OFFSET(pMem)  ( HIWORD(pMem->uOfSz) )
#define PIDMEM_SIZE(pMem)    ( LOWORD(pMem->uOfSz) )
#define PIDMEM_OFSZ(Offset, Size)    ( MAKELONG((Size), (Offset)) ) 

#define GET_NEXTOFFSET(pMem) ( PIDMEM_OFFSET(pMem) + PIDMEM_SIZE(pMem) )


typedef struct _EFFECTSTATE{
    ULONG   lEfState;
    PIDMEM  PidMem[];
} EFFECTSTATE, *PEFFECTSTATE;


typedef struct _UNITSTATE {
    GUID    GuidInstance;
    USHORT  cEfDownloaded;
    USHORT  nAlloc;
    USHORT  cbAlloc;
    PIDMEM  Guard[2];
    UCHAR   State[GLOBAL_EFFECT_MEMSZ];
} UNITSTATE, *PUNITSTATE;

/*****************************************************************************
 *
 *      Since the information to track each unit is so small, we pack them
 *      together into a single shared memory block to save memory.
 *
 *      We use our own GUID as the name of the memory block to avoid
 *      collisions with other named memory blocks.
 *
 *****************************************************************************/

typedef struct SHAREDMEMORY {
    UNITSTATE rgus[MAX_UNITS];
} SHAREDMEMORY, *PSHAREDMEMORY;



typedef struct _REPORTPOOL
{
    ULONG   uRamPoolSz;
    ULONG   uRomPoolSz;
    ULONG   uRomETCount;
    ULONG   uSimulEfMax;
    ULONG   uPoolAlign;
} REPORTPOOL, *PREPORTPOOL;

typedef struct _SZPOOL
{
    ULONG   uSzEffect;
    ULONG   uSzEnvelope;
    ULONG   uSzCondition;
    ULONG   uSzCustom;
    ULONG   uSzPeriodic;
    ULONG   uSzConstant;
    ULONG   uSzRamp;
    ULONG   uSzCustomData;
} SZPOOL,  *PSZPOOL;

typedef struct _DIUSAGEANDINST
{
    DWORD   dwUsage;
    DWORD   dwType;    
} DIUSAGEANDINST, *PDIUSAGEANDINST;

#define MAX_BLOCKS 4 //we can send up to 4 blocks at a time -- 1 effect block, 2 param blocks & 1 effect operation block

typedef struct CPidDrv
{

    /* Supported interfaces */
    IDirectInputEffectDriver ed;

    ULONG               cRef;           /* Object reference count */

    /*
     *  !!IHV!!  Add additional instance data here.
     *  (e.g., handle to driver you want to IOCTL to)
     */

    DWORD               dwDirectInputVersion;

    DWORD               dwID;

    TCHAR                tszDeviceInterface[MAX_DEVICEINTERFACE];
    GUID                GuidInstance;

    HANDLE              hdev;

    PHIDP_PREPARSED_DATA    \
        ppd;

    HIDD_ATTRIBUTES     attr;

    HIDP_CAPS           caps;

    PUCHAR              pReport[HidP_Max];
    USHORT              cbReport[HidP_Max];

	//here we store reports that need to be written in a non-blocking way
	PUCHAR				pWriteReport[MAX_BLOCKS];  
	USHORT				cbWriteReport[MAX_BLOCKS];

    PHIDP_LINK_COLLECTION_NODE  pLinkCollection;

    USHORT              cMaxEffects;
    USHORT              cMaxParameters;
    /*
     *  We remember the unit number because that tells us
     *  which I/O port we need to send the commands to.
     */
    DWORD               dwUnit;         /* Device unit number */

    UINT                uDeviceManaged;

    UINT                cFFObjMax;
    UINT                cFFObj;
    PDIUSAGEANDINST     rgFFUsageInst;


    REPORTPOOL          ReportPool;             
    SZPOOL              SzPool;

    INT_PTR				iUnitStateOffset;       

    DIEFFECT            DiSEffectScale;
	DIEFFECT            DiSEffectOffset;
    DIENVELOPE          DiSEnvScale;
	DIENVELOPE          DiSEnvOffset;
    DICONDITION         DiSCondScale;
	DICONDITION         DiSCondOffset;
    DIRAMPFORCE         DiSRampScale;
	DIRAMPFORCE         DiSRampOffset;
    DIPERIODIC          DiSPeriodicScale;
	DIPERIODIC          DiSPeriodicOffset;
    DICONSTANTFORCE     DiSConstScale;
	DICONSTANTFORCE     DiSConstOffset;
    DICUSTOMFORCE       DiSCustomScale;
	DICUSTOMFORCE       DiSCustomOffset;

    DWORD               DiSEffectAngleScale[MAX_ORDINALS];
	DWORD               DiSEffectAngleOffset[MAX_ORDINALS];
    DWORD               DiSCustomSample[MAX_ORDINALS];

	HIDP_VALUE_CAPS		customCaps[3];
	HIDP_VALUE_CAPS		customDataCaps;

    HANDLE              hThread;
    DWORD               idThread; 
    ULONG               cThreadRef;
    HANDLE              hdevOvrlp;
    OVERLAPPED          o;
	HANDLE				hWrite;
	HANDLE				hWriteComplete;
	DWORD				dwWriteAttempt;
	UINT				totalBlocks; //how many total blocks we need to write
	UINT				blockNr; //the block we're currently writing
    DWORD               dwState;
    DWORD               dwUsedMem;

} CPidDrv, *PCPidDrv;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct EFFECTMAPINFO |
 *
 *          Information about an effect, much like a
 *          <t DIEFFECTINFO>, but containing the
 *          effect ID, too.
 *
 *  @field  DWORD | dwId |
 *
 *          The effect ID.  This comes first so we can copy
 *          an <t EFFECTMAPINFO> into a <t DIEFFECTINFO>
 *          all at one go.
 *
 *  @field  GUID | guid |
 *
 *          The effect GUID.
 *
 *  @field  DWORD | dwEffType |
 *
 *          The effect type and flags.
 *
 *  @field  WCHAR | wszName[MAX_PATH] |
 *
 *          The name for the effect.
 *
 *****************************************************************************/

typedef struct _EFFECTMAPINFO
{
    DIEFFECTATTRIBUTES attr;
    PCGUID  pcguid;
    TCHAR   tszName[MAX_PATH];
} EFFECTMAPINFO, *PEFFECTMAPINFO;
typedef const EFFECTMAPINFO *PCEFFECTMAPINFO;

typedef struct  _PIDSUPPORT
{
    DWORD   dwDIFlags;
    DWORD   dwPidUsage;
    USAGE   Type;
    HIDP_REPORT_TYPE  HidP_Type;
} PIDSUPPORT, *PPIDSUPPORT;

typedef struct _PIDUSAGE
{
    DWORD   dwUsage;
    UINT    DataOffset;
} PIDUSAGE, *PPIDUSAGE;

typedef struct _PIDREPORT
{
    HIDP_REPORT_TYPE    HidP_Type;    

    USAGE               UsagePage;
    USAGE               Collection;


    UINT                cbXData;
    UINT                cAPidUsage;
    PPIDUSAGE           rgPidUsage;
} PIDREPORT, *PPIDREPORT;

extern  PIDREPORT   g_BlockIndex;
extern  PIDREPORT   g_Effect;
extern  PIDREPORT   g_Condition;
extern  PIDREPORT   g_Periodic;
extern  PIDREPORT   g_Ramp;
extern  PIDREPORT   g_Envelope;
extern  PIDREPORT   g_Constant;
extern  PIDREPORT   g_Direction;
extern  PIDREPORT   g_TypeSpBlockOffset;
extern  PIDREPORT   g_PoolReport;
extern  PIDREPORT   g_BlockIndexIN;
extern  PIDREPORT   g_Custom;
extern  PIDREPORT   g_CustomSample;
extern  PIDREPORT   g_CustomData;

#pragma BEGIN_CONST_DATA
static PIDUSAGE c_rgUsgDirection[]=
{
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RX, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RY, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RZ, 2*cbX(ULONG)),
};
/*
 *  Define translation table for ordinals to HID usages 
 */
static PIDUSAGE     c_rgUsgOrdinals[] =
{
    MAKE_HIDUSAGE(ORDINAL,  0x1, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x2, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x3, 2*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x4, 3*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x5, 4*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x6, 5*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x7, 6*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x8, 7*cbX(ULONG)),
};
#pragma END_CONST_DATA


    typedef BOOL    (WINAPI *CANCELIO)(HANDLE);
    typedef BOOL    (WINAPI *TRYENTERCRITICALSECTION)(LPCRITICAL_SECTION);

    BOOL WINAPI FakeCancelIO(HANDLE h);
    BOOL WINAPI FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCrit_sec);

    extern CANCELIO CancelIo_;
    extern TRYENTERCRITICALSECTION TryEnterCriticalSection_;


/*****************************************************************************
 *
 *      Constant globals:  Never change.  Ever.
 *
 *****************************************************************************/
DEFINE_GUID(GUID_MySharedMemory,    0x1dc900bf,0xbcac,0x11d2,0xa9,0x19,0x00,0xc0,0x4f,0xb9,0x86,0x38); 
DEFINE_GUID(GUID_MyMutex,           0x4368208f,0xbcac,0x11d2,0xa9,0x19,0x00,0xc0,0x4f,0xb9,0x86,0x38);

/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

extern HINSTANCE g_hinst;       /* This DLL's instance handle */
extern PSHAREDMEMORY g_pshmem;  /* Our shared memory block */
extern HANDLE g_hfm;            /* Handle to file mapping object */
extern HANDLE g_hmtxShared;     /* Handle to mutex that protects g_pshmem */

/*****************************************************************************
 *
 *      Prototypes
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    LPDWORD pdwEffect, 
    LPCDIEFFECT peff, 
    DWORD dwFlags
    );


STDMETHODIMP
    PID_DoParameterBlocks
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    DWORD dwEffectIndex, 
    LPCDIEFFECT peff, 
    DWORD dwFlags,
    PUINT puParameter,
	BOOL  bBlocking,
	UINT  totalBlocks
    );

STDMETHODIMP
    PID_EffectOperation
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwEffect,
    DWORD dwMode, 
    DWORD dwCount,
	BOOL  bBlocking,
	UINT  blockNr,
	UINT  totalBlocks
    );

STDMETHODIMP
    PID_SetGain
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwGain
    );


STDMETHODIMP
    PID_SendForceFeedbackCommand
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwCommand
    );


STDMETHODIMP
    PID_GetLinkCollectionIndex
    (
    IDirectInputEffectDriver *ped,
    USAGE UsagePage, 
    USAGE Collection,
    USHORT Parent,
    PUSHORT puLinkCollection 
    );

STDMETHODIMP 
    PID_Init
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP
    PID_InitFFAttributes
    (
    IDirectInputEffectDriver *ped 
    );

STDMETHODIMP 
    PID_Finalize
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP
    PID_InitRegistry
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP 
    PID_Support
    (
    IDirectInputEffectDriver *ped,
    UINT        cAPidSupport,
    PPIDSUPPORT rgPidSupport,
    PDWORD      pdwFlags
    );

STDMETHODIMP
    PID_PackValue
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    );

STDMETHODIMP
    PID_ParseReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    );

STDMETHODIMP 
    PID_SendReport
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type,
	BOOL	bBlocking,
	UINT	blockNr,
	UINT	totalBlocks
    );

STDMETHODIMP 
    PID_GetReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pReport,
    UINT        cbReport
    );


STDMETHODIMP 
    PID_NewEffectIndex
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT  lpdieff,
    DWORD    dwEffectId,
    PDWORD   pdwEffect 
    );

STDMETHODIMP 
    PID_ValidateEffectIndex
    (
    IDirectInputEffectDriver *ped,
    DWORD   pdwEffect 
    );

STDMETHODIMP 
    PID_DestroyEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwId,
    DWORD   dwEffect
    );

STDMETHODIMP
    PID_GetParameterOffset
    (
    IDirectInputEffectDriver *ped,
    DWORD      dwEffectIndex,
    UINT       uParameterBlock,
    DWORD      dwSz,
    PLONG      plValue
    );


STDMETHODIMP
    PID_ComputeScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
	PVOID       pvOffset,
    UINT        cbOffset
    );


STDMETHODIMP
    PID_ApplyScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    PVOID       pvScale,
    UINT        cbScale,
	PVOID       pvOffset,
    UINT        cbOffset,
    PVOID       pvData,
    UINT        cbData
    );

STDMETHODIMP
    PID_GetReportId
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport, 
    USHORT  uLinkCollection,
    UCHAR* pReportId
    );

VOID INTERNAL
    PID_ThreadProc(CPidDrv* this);

STDMETHODIMP_(ULONG)
PID_AddRef(IDirectInputEffectDriver *ped);


STDMETHODIMP_(ULONG)
PID_Release(IDirectInputEffectDriver *ped);


void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid);

#ifdef DEBUG

    #define PIDUSAGETXT_MAX ( 0xAC )

extern PTCHAR   g_rgUsageTxt[PIDUSAGETXT_MAX];    // Cheat sheet for EffectNames
    
    #define PIDUSAGETXT(UsagePage, Usage )  \
        ( ( UsagePage == HID_USAGE_PAGE_PID && Usage < PIDUSAGETXT_MAX) ? g_rgUsageTxt[Usage] : NULL )  

    void PID_CreateUsgTxt();
    
#else

#define  PID_CreateUsgTxt() 
#define  PIDUSAGETXT(UsagePage, Usage)       ( NULL )

#endif


PEFFECTSTATE INLINE PeffectStateFromBlockIndex(PCPidDrv this, UINT Index )
{
    return (PEFFECTSTATE)(&((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->State[0] + (Index-1) * ((FIELD_OFFSET(EFFECTSTATE,PidMem)) + this->cMaxParameters*cbX(PIDMEM)));
}

#define PID_EFFECT_RESET        (0x0000000)
#define PID_EFFECT_BUSY         (0x8000000)
#define PID_EFFECT_STARTED      (0x4000000)
#define PID_EFFECT_STARTED_SOLO (0x2000000)


#define PID_DRIVER_VERSION  (0x0000001)

#define PID_DEVICEMANAGED   (0x1)
#define PID_SHAREDPARAM     (0x2)



/*****************************************************************************
 *
 *      Dll global functions
 *
 *****************************************************************************/

void EXTERNAL DllEnterCrit_(LPCTSTR lptszFile, UINT line);
void EXTERNAL DllLeaveCrit_(LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL EXTERNAL DllInCrit(void);
    #define DllEnterCrit() DllEnterCrit_(TEXT(__FILE__), __LINE__)
    #define DllLeaveCrit() DllLeaveCrit_(TEXT(__FILE__), __LINE__)
#else
    #define DllEnterCrit() DllEnterCrit_(NULL, 0x0)
    #define DllLeaveCrit() DllLeaveCrit_(NULL, 0x0)
#endif

STDAPI_(ULONG) DllAddRef(void);
STDAPI_(ULONG) DllRelease(void);

/*****************************************************************************
 *
 *      Class factory
 *
 *****************************************************************************/

STDAPI CClassFactory_New(REFIID riid, LPVOID *ppvObj);

/*****************************************************************************
 *
 *      Effect driver
 *
 *****************************************************************************/

STDAPI PID_New(REFIID riid, LPVOID *ppvObj);


#ifndef WINNT
    /***************************************************************************
     *
     *      KERNEL32 prototypes missing from Win98 headers.
     *
     ***************************************************************************/
    WINBASEAPI BOOL WINAPI CancelIo( HANDLE hFile );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidop.c ===
/*****************************************************************************
 *
 *  PidOp.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      PID device Operation .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflOp )

#pragma BEGIN_CONST_DATA

static PIDUSAGE    c_rgUsgGain[] =
{
    MAKE_PIDUSAGE(DEVICE_GAIN,  0x0 )
};

static PIDREPORT DeviceGain =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DEVICE_GAIN_REPORT,
    cbX(DWORD),
    cA(c_rgUsgGain),
    c_rgUsgGain
};




PIDUSAGE    c_rgUsgOperationReport[] =
{
    MAKE_PIDUSAGE(LOOP_COUNT,               0x0),
};

static PIDREPORT OperationReport =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_EFFECT_OPERATION_REPORT,
    cbX(DWORD),
    cA(c_rgUsgOperationReport),
    c_rgUsgOperationReport
};


static PIDREPORT DeviceControlReport =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DEVICE_CONTROL,
    0x0,
    0x0,
    NULL
};


#pragma END_CONST_DATA

STDMETHODIMP
    PID_EffectOperation
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwEffect,
    DWORD dwMode, 
    DWORD dwCount,
	BOOL  bBlocking,
	UINT  blockNr,
	UINT  totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_EffectOperation, (_"xxxxx", ped, dwId, dwEffect, dwMode, dwCount ));

    hres = PID_ValidateEffectIndex(ped, dwEffect);
    // Allocate Memory for the report 
    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;

        USHORT LinkCollection;
        AssertF(OperationReport.HidP_Type == HidP_Output);

        cbReport = this->cbReport[OperationReport.HidP_Type];
        pReport = this->pReport[OperationReport.HidP_Type];

        PID_GetLinkCollectionIndex(ped, OperationReport.UsagePage, OperationReport.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            ZeroBuf(pReport, cbReport);

            // Set Effect Operation
            if( SUCCEEDED(hres) )
            {
                USAGE   Usage;
                USAGE   UsagePage;
                NTSTATUS  ntStat;
                UINT    nUsages = 0x1;
                USAGE   LinkCollection0;
                PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect); 

                UsagePage = OperationReport.UsagePage;

                PID_GetLinkCollectionIndex(ped, OperationReport.UsagePage, HID_USAGE_PID_EFFECT_OPERATION, 0x0, &LinkCollection0);

                if( dwMode & DIES_SOLO )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_START_SOLO;
                    pEffectState->lEfState |= PID_EFFECT_STARTED_SOLO;
                } else if( dwMode & PID_DIES_START )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_START;
                    pEffectState->lEfState |= PID_EFFECT_STARTED;
                } else if(dwMode & PID_DIES_STOP )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_STOP;
                    pEffectState->lEfState &= ~(PID_EFFECT_STARTED | PID_EFFECT_STARTED_SOLO);
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%s: FAIL Could not understand dwMode=0x%x"),
                                    s_tszProc, dwMode ); 

                    hres = E_NOTIMPL;
                }

                ntStat = HidP_SetUsages 
                         (
                         OperationReport.HidP_Type,
                         UsagePage,
                         LinkCollection0,
                         &Usage,
                         &nUsages,
                         this->ppd,
                         pReport,
                         cbReport);

                if( FAILED(hres) )
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                    TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                    s_tszProc, ntStat, 
                                    LinkCollection0, UsagePage, Usage,
                                    PIDUSAGETXT(UsagePage,Usage) );
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                    s_tszProc, ntStat, 
                                    LinkCollection0, UsagePage, Usage,
                                    PIDUSAGETXT(UsagePage,Usage) );
                }
            }

            // Set the Loop Count
            if( SUCCEEDED(hres) )
            {
                PID_PackValue
                    (
                    ped,
                    &OperationReport,
                    LinkCollection,
                    &dwCount,
                    cbX(dwCount),
                    pReport,
                    cbReport
                    );

                // Set the Block Index
                PID_PackValue
                    (
                    ped,
                    &g_BlockIndex,
                    LinkCollection,
                    &dwEffect,
                    cbX(dwEffect),
                    pReport,
                    cbReport
                    );
            }

            if( SUCCEEDED(hres) )
            {
				hres = PID_SendReport(ped, pReport, cbReport, OperationReport.HidP_Type, bBlocking, blockNr, totalBlocks); 
            }
        }
    }
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_SetGain
 *
 *          Set the overall device gain.
 *
 *  dwId
 *
 *          The joystick ID number being used.
 *
 *  dwGain
 *
 *          The new gain value.
 *
 *          If the value is out of range for the device, the device
 *          should use the nearest supported value and return
 *          DI_TRUNCATED.
 *
 *  Returns:
 *
 *
 *          S_OK if the operation completed successfully.
 *
 *          DI_TRUNCATED if the value was out of range and was
 *          changed to the nearest supported value.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_SetGain
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwGain
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProc( PID_SetGain, (_"xxx", ped, dwId, dwGain));
    DllEnterCrit();

    // Allocate Memory for the report 
    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;

        USHORT LinkCollection;

        AssertF(DeviceGain.HidP_Type == HidP_Output);
        cbReport = this->cbReport[DeviceGain.HidP_Type];
        pReport = this->pReport[DeviceGain.HidP_Type];

        PID_GetLinkCollectionIndex(ped, DeviceGain.UsagePage, DeviceGain.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            ZeroBuf(pReport, cbReport);

            // Set the Loop Count
            if( SUCCEEDED(hres) )
            {
                hres = PID_PackValue
                       (
                       ped,
                       &DeviceGain,
                       LinkCollection,
                       &dwGain,
                       cbX(dwGain),
                       pReport,
                       cbReport
                       );
            }

            if( SUCCEEDED(hres) )
            {
                hres = PID_SendReport(ped, pReport, cbReport, DeviceGain.HidP_Type, FALSE, 0, 1); 
            }
        }
    }
    DllLeaveCrit();

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_SendForceFeedbackCommand
 *
 *          Send a command to the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwCommand
 *
 *          A DISFFC_* value specifying the command to send.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_SendForceFeedbackCommand
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwCommand
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    USAGE Usages[6];
    PUSAGE pUsages = &Usages[0];
    UINT nUsages;

    EnterProcI( PID_SendForceFeedbackCommand, (_"xxx", ped, dwId, dwCommand));

    DllEnterCrit();

    if( dwCommand & DISFFC_RESET )
    {
        DWORD indx;
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_RESET;
        for(indx = 1 ; 
           (indx <= this->cMaxEffects) && (((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded != 0x0 );
           indx++ )
        {
            PID_DestroyEffect(ped, dwId, indx);
        }
        this->dwState = DIGFFS_STOPPED;
    }
    if( dwCommand & DISFFC_STOPALL )
    {
        *pUsages++ = HID_USAGE_PID_DC_STOP_ALL_EFFECTS;
        this->dwState = DIGFFS_STOPPED;
    }
    if( dwCommand & DISFFC_PAUSE )
    {
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_PAUSE;
    }
    if( dwCommand & DISFFC_CONTINUE )
    {
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_CONTINUE;
    }
    if( dwCommand & DISFFC_SETACTUATORSON)
    {
        *pUsages++ = HID_USAGE_PID_DC_ENABLE_ACTUATORS;
    }
    if(dwCommand & DISFFC_SETACTUATORSOFF)
    {
        *pUsages++ = HID_USAGE_PID_DC_DISABLE_ACTUATORS;
    }

    nUsages = (UINT)(pUsages - &Usages[0]);
    if(nUsages == 0x0 )
    {
        hres = E_NOTIMPL;
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL Do not understand dwCommand(0x%x) "),
                        s_tszProc, dwCommand);
    }

    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;
        USHORT  LinkCollection;

        AssertF(DeviceControlReport.HidP_Type == HidP_Output);

        cbReport = this->cbReport[DeviceControlReport.HidP_Type];
        pReport =  this->pReport[DeviceControlReport.HidP_Type];

        PID_GetLinkCollectionIndex(ped, DeviceControlReport.UsagePage, DeviceControlReport.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            USHORT  UsagePage;
            NTSTATUS    ntStat;
            ZeroBuf(pReport, cbReport);
            UsagePage = OperationReport.UsagePage;

            ntStat = HidP_SetUsages 
                     (
                     OperationReport.HidP_Type,
                     UsagePage,
                     LinkCollection,
                     &Usages[0],
                     &nUsages,
                     this->ppd,
                     pReport,
                     cbReport);

            if( FAILED(ntStat) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat, 
                                LinkCollection, UsagePage, Usages[0],
                                PIDUSAGETXT(UsagePage,Usages[0]) );
                hres = ntStat;
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat, 
                                LinkCollection,UsagePage, Usages[0],
                                PIDUSAGETXT(UsagePage,Usages[0]) );
            }

            if( SUCCEEDED(hres) )
            {
                hres = PID_SendReport(ped, pReport, cbReport, OperationReport.HidP_Type, TRUE, 0, 1); //we block on this call
            }
        }
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidinit.c ===
/*****************************************************************************
 *
 *  PidInit.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *  Abstract:
 *
 *      Initialization code .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflInit )

#define NudgeWorkerThread(thid)                                         \
        PostThreadMessage(thid, WM_NULL, 0x0, (LPARAM)NULL)

#pragma BEGIN_CONST_DATA


static PIDUSAGE    c_rgUsgPool[] =
{
    MAKE_PIDUSAGE(SIMULTANEOUS_EFFECTS_MAX,     FIELD_OFFSET(REPORTPOOL,uSimulEfMax)),
    MAKE_PIDUSAGE(RAM_POOL_SIZE,                FIELD_OFFSET(REPORTPOOL,uRamPoolSz)),
    MAKE_PIDUSAGE(ROM_POOL_SIZE,                FIELD_OFFSET(REPORTPOOL,uRomPoolSz)),
    MAKE_PIDUSAGE(ROM_EFFECT_BLOCK_COUNT,       FIELD_OFFSET(REPORTPOOL,uRomETCount)),
    MAKE_PIDUSAGE(POOL_ALIGNMENT,               FIELD_OFFSET(REPORTPOOL,uPoolAlign)),
};

static PIDUSAGE    c_rgUsgPoolSz[] =
{
    MAKE_PIDUSAGE(SET_CONSTANT_FORCE_REPORT,    FIELD_OFFSET(SZPOOL, uSzConstant)),
    MAKE_PIDUSAGE(SET_ENVELOPE_REPORT,          FIELD_OFFSET(SZPOOL, uSzEnvelope)),
    MAKE_PIDUSAGE(SET_CONDITION_REPORT,         FIELD_OFFSET(SZPOOL, uSzCondition)),                 
    MAKE_PIDUSAGE(SET_CUSTOM_FORCE_REPORT,      FIELD_OFFSET(SZPOOL, uSzCustom)),
    MAKE_PIDUSAGE(SET_PERIODIC_REPORT,          FIELD_OFFSET(SZPOOL, uSzPeriodic)),
    MAKE_PIDUSAGE(SET_RAMP_FORCE_REPORT,        FIELD_OFFSET(SZPOOL, uSzRamp)),
    MAKE_PIDUSAGE(SET_EFFECT_REPORT,            FIELD_OFFSET(SZPOOL, uSzEffect)),
    MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_REPORT,     FIELD_OFFSET(SZPOOL, uSzCustomData)),
};


static PIDREPORT PoolSz =
{
    HidP_Feature,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_PARAMETER_BLOCK_SIZE,
    cbX(SZPOOL),
    cA(c_rgUsgPoolSz),
    c_rgUsgPoolSz
};


PIDREPORT g_PoolReport =
{
    HidP_Feature,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_POOL_REPORT,
    cbX(REPORTPOOL),
    cA(c_rgUsgPool),
    c_rgUsgPool
};

static PIDSUPPORT g_PoolSupport[] =
{
    {PID_DEVICEMANAGED,     PIDMAKEUSAGEDWORD(DEVICE_MANAGED_POOL),         HID_BUTTON,   HidP_Feature},
    {PID_SHAREDPARAM,       PIDMAKEUSAGEDWORD(SHARED_PARAMETER_BLOCKS),     HID_BUTTON,   HidP_Feature},
};


#pragma END_CONST_DATA


/*****************************************************************************
 *
 *      PID_InitSharedMem
 *
 *      Inits our Shared Memory
 *
 *****************************************************************************/

HRESULT  INTERNAL
    PID_InitSharedMem
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_InitSharedMem, (_"x", ped));

    // Get hold of global memory to keep the EffectState 
    if( SUCCEEDED(hres) )
    {
        UINT unitID;
        hres = DIERR_PID_NOTINITIALIZED;
        WaitForSingleObject(g_hmtxShared, INFINITE);
        for(unitID = 0; unitID < MAX_UNITS; unitID++)
        {

            GUID*  pGuid = &g_pshmem->rgus[unitID].GuidInstance;
#ifdef DEBUG
            TCHAR   lpName[MAX_PATH];
            NameFromGUID(lpName, pGuid);

            SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("%s:UnitId(%d): GUID %s"),
                            s_tszProc, unitID, lpName );
#endif

            if(  IsEqualGUID(pGuid, &this->GuidInstance) )
            {
                this->iUnitStateOffset = (&g_pshmem->rgus[unitID] - (PUNITSTATE)g_pshmem);
                hres = S_OK;
            } else if( IsEqualGUID(pGuid, &GUID_NULL ) )
            {
				PUNITSTATE pUnitState;
                this->iUnitStateOffset = (&g_pshmem->rgus[unitID] - (PUNITSTATE)g_pshmem);
				pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
                pUnitState->GuidInstance = this->GuidInstance;
                pUnitState->nAlloc = 0x0;
                ZeroBuf(pUnitState->State,GLOBAL_EFFECT_MEMSZ );
                hres = S_OK;
            }
            if( SUCCEEDED(hres) )
            {
                break;
            }
        }

        if(SUCCEEDED(hres) )
        {
			PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
            PPIDMEM pGuard = pUnitState->Guard;
            INT_PTR iGuard1 = (PUCHAR)&pUnitState->Guard[0] - (PUCHAR)pUnitState, iGuard2 = (PUCHAR)&pUnitState->Guard[1] - (PUCHAR)pUnitState;

            pGuard->uOfSz = PIDMEM_OFSZ(0x0, 0x0 );
            pGuard->iNext =  iGuard2;

            pGuard++;

            pGuard->uOfSz   = PIDMEM_OFSZ(this->ReportPool.uRamPoolSz, 0x0);
            pGuard->iNext   = iGuard1;

            pUnitState->nAlloc = 0x2;

            pUnitState->cEfDownloaded = (USHORT)this->ReportPool.uRomETCount;
        }


        ReleaseMutex(g_hmtxShared);

        if( FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Could not find free unitID"),
                            s_tszProc );

        }
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_InitScaling
 *
 *      Inits Scaling Coefficients
 *
 *****************************************************************************/
PID_InitScaling
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    USHORT LinkCollection;
    UINT indx;
    EnterProc( PID_InitScaling, (_"x", ped));


    // Scaling Exponents and Offsets
    this->DiSEffectScale.dwSize =  this->DiSEffectOffset.dwSize = sizeof(DIEFFECT);     /* sizeof(DIEFFECT)     */
    //this->DiSEffect.dwFlags                /* DiEffect*              */
    this->DiSEffectScale.dwDuration    =  DI_SECONDS ;/* Microseconds         */
    this->DiSEffectScale.dwSamplePeriod = DI_SECONDS ;/* Microseconds         */
    this->DiSEffectScale.dwGain          = DI_FFNOMINALMAX;
    this->DiSEffectScale.dwTriggerButton = 0x0;   /* or DIEB_NOTRIGGER    */
    this->DiSEffectScale.dwTriggerRepeatInterval = DI_SECONDS; /* Microseconds         */
    //this->DiSEffect.cAxes;                       /* Number of axes       */
    //this->DiSEffect.rgdwAxes;                    /* Array of axes        */
    //this->DiSEffect.rglDirection;                /* Array of directions  */
    //this->DiSEffect.lpEnvelope;                  /* Optional             */
    //this->DiSEffect.cbTypeSpecificParams;        /* Size of params       */
    //this->DiSEffect.lpvTypeSpecificParams;       /* Pointer to params    */
#if DIRECTINPUT_VERSION  >= 0x600
    this->DiSEffectScale.dwStartDelay    =   DI_SECONDS;    // Start delay
#endif


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, g_Effect.Collection,     0x0, &LinkCollection )))
    {
        PID_ComputeScalingFactors(ped, &g_Effect,     LinkCollection, &this->DiSEffectScale,   this->DiSEffectScale.dwSize, &this->DiSEffectOffset,   this->DiSEffectOffset.dwSize);
    }

    this->DiSEnvScale.dwSize  = this->DiSEnvOffset.dwSize = sizeof(DIENVELOPE);      /* sizeof(DIENVELOPE)   */
    this->DiSEnvScale.dwAttackLevel   = DI_FFNOMINALMAX;
    this->DiSEnvScale.dwAttackTime    = DI_SECONDS; /* Microseconds         */
    this->DiSEnvScale.dwFadeLevel     = DI_FFNOMINALMAX;
    this->DiSEnvScale.dwFadeTime      = DI_SECONDS; /* Microseconds         */


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Envelope.UsagePage, g_Envelope.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Envelope,   LinkCollection, &this->DiSEnvScale,      this->DiSEnvScale.dwSize, &this->DiSEnvOffset,      this->DiSEnvOffset.dwSize);
    }

    this->DiSPeriodicScale.dwMagnitude    = DI_FFNOMINALMAX;
    this->DiSPeriodicScale.lOffset        = DI_FFNOMINALMAX;
    this->DiSPeriodicScale.dwPhase        = 360 * DI_DEGREES;
    this->DiSPeriodicScale.dwPeriod       = DI_SECONDS;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Periodic.UsagePage, g_Periodic.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Periodic,   LinkCollection, &this->DiSPeriodicScale, cbX(this->DiSPeriodicScale), &this->DiSPeriodicOffset, cbX(this->DiSPeriodicOffset));
    }

    this->DiSRampScale.lStart           =
        this->DiSRampScale.lEnd             = DI_FFNOMINALMAX;


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Ramp.UsagePage,     g_Ramp.Collection,     0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Ramp,       LinkCollection, &this->DiSRampScale, cbX(this->DiSRampScale), &this->DiSRampOffset, cbX(this->DiSRampOffset));
    }

    this->DiSCondScale.lOffset               =
        this->DiSCondScale.lPositiveCoefficient  =
        this->DiSCondScale.lNegativeCoefficient  =
        this->DiSCondScale.dwPositiveSaturation  =
        this->DiSCondScale.dwNegativeSaturation  =
        this->DiSCondScale.lDeadBand             = DI_FFNOMINALMAX;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Condition.UsagePage,g_Condition.Collection,0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Condition,  LinkCollection, &this->DiSCondScale, cbX(this->DiSCondScale), &this->DiSCondOffset, cbX(this->DiSCondOffset));
    }

    this->DiSConstScale.lMagnitude           = DI_FFNOMINALMAX;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Constant.UsagePage, g_Constant.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Constant,   LinkCollection, &this->DiSConstScale,cbX(this->DiSConstScale), &this->DiSConstOffset,cbX(this->DiSConstOffset));
    }

    this->DiSCustomScale.dwSamplePeriod     =      DI_SECONDS;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Custom.UsagePage,   g_Custom.Collection,   0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Custom,   LinkCollection, &this->DiSCustomScale, cbX(this->DiSCustomScale), &this->DiSCustomOffset, cbX(this->DiSCustomOffset));
    }



    // Direction could be ordinals
    g_Direction.cbXData     = cA(c_rgUsgOrdinals)*cbX(DWORD); 
    g_Direction.cAPidUsage  = cA(c_rgUsgOrdinals);
    g_Direction.rgPidUsage  = c_rgUsgOrdinals;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Direction.UsagePage, g_Direction.Collection, 0x0, &LinkCollection)))
    {
        HRESULT hres1;

        for(indx = 0x0; indx < MAX_ORDINALS; indx++)
        {
            this->DiSEffectAngleScale[indx]            = 360 * DI_DEGREES;
        }

        hres1 = PID_ComputeScalingFactors(ped, &g_Direction,   LinkCollection, &this->DiSEffectAngleScale[0], cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset[0], cbX(this->DiSEffectAngleOffset));

        // Direction could be angles
        if(hres1 == E_NOTIMPL )
        {
            g_Direction.cbXData     = cA(c_rgUsgDirection)*cbX(DWORD); 
            g_Direction.cAPidUsage  = cA(c_rgUsgDirection);
            g_Direction.rgPidUsage  = c_rgUsgDirection;

            // Reset the nominal values
            for(indx = 0x0; indx < MAX_ORDINALS; indx++)
            {
                this->DiSEffectAngleScale[indx]            = 360 * DI_DEGREES;
            }

            hres1 = PID_ComputeScalingFactors(ped, &g_Direction,   LinkCollection, &this->DiSEffectAngleScale[0], cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset[0], cbX(this->DiSEffectAngleOffset));    

            if( hres1 == E_NOTIMPL )
            {
                // Could be direction Vectors
                // Not sure how vectors are implemented in PID

                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%s:FAIL Cannot understand the direction collection\n")
                                TEXT("\t\t Supported usages are {Rx, Ry, Rz} or {Ordinals} \n"),
                                s_tszProc );
            }
        }
    }

    for(indx = 0x0; indx < MAX_ORDINALS; indx++)
    {
        this->DiSCustomSample[indx]            = DI_FFNOMINALMAX;
    }

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_CustomSample.UsagePage,   g_CustomSample.Collection,   0x0, &LinkCollection)) )
    {  
		//get the custom data for each axis
   		USHORT  cAValCaps   = 0x1;
  		USAGE   UsagePage;  
		USAGE   Usage[3] = {HID_USAGE_GENERIC_X, HID_USAGE_GENERIC_Y, HID_USAGE_GENERIC_Z};
		NTSTATUS ntSt[3];
		int nAxis = 0;

       	UsagePage = HID_USAGE_PAGE_GENERIC;
       
		for (nAxis = 0; nAxis < 3; nAxis ++)
		{
			cAValCaps = 0x1;
   			ntSt[nAxis] = HidP_GetSpecificValueCaps
       						(
               				g_CustomSample.HidP_Type,
               				UsagePage,
               				LinkCollection,
               				Usage[nAxis],
               				&this->customCaps[nAxis],
               				&cAValCaps,
							this->ppd
               				);

			if (FAILED(ntSt[nAxis]))
			{
				this->customCaps[nAxis].BitSize = 0;
				this->customCaps[nAxis].LogicalMin = this->customCaps[nAxis].LogicalMax = 0;
			}
		}
               			
	

		if ((FAILED(ntSt[0])) && (FAILED(ntSt[1])) && (FAILED(ntSt[2])))
		{
			 SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Cannot understand the download force sample collection\n")
                            TEXT("\t\t Supported usages are {X, Y, Z} \n"),
                            s_tszProc );

		}

		
		//get how many bytes of custom data can send at a time
		if (SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_CustomData.UsagePage, g_CustomData.Collection, 0x0, &LinkCollection )))
		{

			USAGE UsageData = HID_USAGE_PID_CUSTOM_FORCE_DATA;
			NTSTATUS ntst;
			cAValCaps = 0x1;
			UsagePage = HID_USAGE_PAGE_PID;

			ntst = HidP_GetSpecificValueCaps
				   (
				   g_CustomData.HidP_Type,
				   UsagePage,
				   LinkCollection,
				   UsageData,
				   &this->customDataCaps,
				   &cAValCaps,
				   this->ppd
				   );

			if (FAILED(ntst))
			{
				this->customDataCaps.BitSize = 0;
			}
			

		}
	
	

   }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      DIEnumProc
 *
 *      Enum and cache  FF device objects
 *
 *****************************************************************************/

BOOL CALLBACK
    DIEnumProc(LPCDIDEVICEOBJECTINSTANCE pinst, LPVOID pv)
{
    BOOL frc = DIENUM_CONTINUE;
    HRESULT hres = S_OK;
    CPidDrv* this = (CPidDrv*) pv;

    EnterProc( DIEnumProc, (_"xx", pinst, pv ));

    if(  (pinst->dwFlags & DIDOI_FFACTUATOR )
         ||(pinst->dwFlags & DIDOI_FFEFFECTTRIGGER ))
    {
        AssertF(this->cFFObj <= this->cFFObjMax);
        if( this->cFFObj == this->cFFObjMax )
        {
            /* Grow by doubling */
            this->cFFObjMax = max(PIDALLOC_INIT, 2*this->cFFObjMax);
            hres = ReallocCbPpv(this->cFFObjMax * cbX(DIUSAGEANDINST), &this->rgFFUsageInst);
        }

        if( SUCCEEDED(hres) )
        {
            PDIUSAGEANDINST pdiUI = this->rgFFUsageInst + this->cFFObj;
            pdiUI->dwUsage   = DIMAKEUSAGEDWORD(pinst->wUsagePage, pinst->wUsage);
            pdiUI->dwType    = pinst->dwType ;
        }

        this->cFFObj++;
    }
    if( FAILED(hres) )
    {
        frc = DIENUM_STOP;
    }

    ExitProcF(frc);
    return frc;
}

STDMETHODIMP
    PID_InitFFAttributes
    (
    IDirectInputEffectDriver *ped 
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_Init, (_"x", ped));

    // We cannot call this function at init, because DInput call us before the device 
    // has been completely initialized. 
    if( this->cFFObj )
    {
        hres = S_FALSE; // Already initialized
    } else
    {
        // We need to get the Usage & UsagePage 
        // for device objects marked as 
        // FF Triggers and FF Actuators

		//If we are called with DInput version not larger than 7, load dinput.dll w/ IID_DirectInput7
		//else load dinput8.dll.
		if (this->dwDirectInputVersion <= 0x0700)
		{	
			HINSTANCE hinst = LoadLibrary(TEXT("dinput.dll"));
			if (hinst)
			{
				typedef HRESULT ( WINAPI * DIRECTINPUTCREATEEX) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                DIRECTINPUTCREATEEX _DirectInputCreateEx;
				LPDIRECTINPUT   lpDI;
                _DirectInputCreateEx = (DIRECTINPUTCREATEEX)GetProcAddress(hinst, "DirectInputCreateEx");
				if (_DirectInputCreateEx)
				{
					hres = _DirectInputCreateEx(g_hinst, this->dwDirectInputVersion, &IID_IDirectInput7, &lpDI, NULL );
					if( SUCCEEDED(hres) )
					{
						LPDIRECTINPUTDEVICE   pdid;
						hres = IDirectInput_CreateDevice(lpDI, &this->GuidInstance, &pdid, NULL);
						/* Create the device object */
						if( SUCCEEDED(hres) )
						{
							hres = IDirectInputDevice2_EnumObjects
								   (
								   pdid,   
								   DIEnumProc,
								   ped,
								   DIDFT_ALL //DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR
								   );

							IDirectInput_Release(pdid);
						}
						IDirectInput_Release(lpDI);
					}
				}
				else //!DirectInputCreateEx
				{
					//Something is horribly wrong here if we can't find the Create fn!
					//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
					hres = DIERR_UNSUPPORTED;
				}

				FreeLibrary(hinst);
			}
			else // !hinst
			{
				//Something is horribly wrong here if we came through Dinput but can't load it!
				//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
				hres = DIERR_UNSUPPORTED;
			}
		}
		else
		{
			HINSTANCE hinst = LoadLibrary(TEXT("dinput8.dll"));
			if (hinst)
			{
				typedef HRESULT ( WINAPI * DIRECTINPUT8CREATE) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                DIRECTINPUT8CREATE _DirectInput8Create;
				LPDIRECTINPUT8   lpDI;
                _DirectInput8Create = (DIRECTINPUT8CREATE)GetProcAddress(hinst, "DirectInput8Create");
				if (_DirectInput8Create)
				{
					hres = _DirectInput8Create(g_hinst, this->dwDirectInputVersion, &IID_IDirectInput8, &lpDI, NULL );
					if( SUCCEEDED(hres) )
					{
						LPDIRECTINPUTDEVICE8   pdid;
						hres = IDirectInput8_CreateDevice(lpDI, &this->GuidInstance, &pdid, NULL);
						/* Create the device object */
						if( SUCCEEDED(hres) )
						{
							hres = IDirectInputDevice8_EnumObjects
								   (
								   pdid,   
								   DIEnumProc,
								   ped,
								   DIDFT_ALL //DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR
								   );

							IDirectInput_Release(pdid);
						}
						IDirectInput_Release(lpDI);
					}
				}
				else //!DirectInput8Create
				{
					//Something is horribly wrong here if we can't find the Create fn!
					//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
					hres = DIERR_UNSUPPORTED;
				}

				FreeLibrary(hinst);
			}
			else // !hinst
			{
				//Something is horribly wrong here if we came through Dinput but can't load it!
				//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
				hres = DIERR_UNSUPPORTED;
			}
		}
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_Init
 *
 *      Inits PID device
 *
 *****************************************************************************/

STDMETHODIMP 
    PID_Init
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    USHORT LinkCollection;

    EnterProcI( PID_Init, (_"x", ped));

    PID_CreateUsgTxt();

    AssertF( this->hdev == INVALID_HANDLE_VALUE );

    if( SUCCEEDED(hres) )
    {
        this->hdev = CreateFile(this->tszDeviceInterface,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                  /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0x0,                /* attributes */
                                0);                 /* template */

        if( this->hdev == INVALID_HANDLE_VALUE )
        {
            hres = E_HANDLE;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL CreateFile"),
                            s_tszProc );

        }
    }

    if( SUCCEEDED(hres) )
    {
        // Get all the HID goo 
        if( HidD_GetAttributes(this->hdev, &this->attr) &&
            HidD_GetPreparsedData(this->hdev, &this->ppd) &&
            SUCCEEDED(HidP_GetCaps(this->ppd, &this->caps)) )
        {
            // Success
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HID init  "),
                            s_tszProc );

            hres = DIERR_PID_NOTINITIALIZED;
        }
    }

    if( SUCCEEDED(hres) )
    {
        // Get collection info
        hres = AllocCbPpv(cbX(*this->pLinkCollection) * this->caps.NumberLinkCollectionNodes,
                          &this->pLinkCollection); 

        if( SUCCEEDED(hres) && (this->pLinkCollection != NULL) )
        {
            ULONG cALinkCollection=this->caps.NumberLinkCollectionNodes;

            hres = HidP_GetLinkCollectionNodes 
                   (
                   this->pLinkCollection, 
                   &cALinkCollection,
                   this->ppd
                   );        
        }
    }

    if(SUCCEEDED(hres) )
    {
        UINT indx;
        this->cbReport[HidP_Input]    =  this->caps.InputReportByteLength;
        this->cbReport[HidP_Output]   =  this->caps.OutputReportByteLength;
        this->cbReport[HidP_Feature]  =  this->caps.FeatureReportByteLength;
		//write reports are output reports
		for( indx = 0x0; indx < MAX_BLOCKS; indx++ )
        {
			this->cbWriteReport[indx]			  =  this->caps.OutputReportByteLength;
		}

        for( indx = 0x0; indx < HidP_Max; indx++ )
        {
            hres = AllocCbPpv(this->cbReport[indx], &this->pReport[indx]);
            if( FAILED(hres) )
            {
                break;
            }
        }
		for( indx = 0x0; indx < MAX_BLOCKS; indx++ )
        {
            hres = AllocCbPpv(this->cbWriteReport[indx], &this->pWriteReport[indx]);
            if( FAILED(hres) )
            {
                break;
            }
        }	
    }

    if( SUCCEEDED(hres) )
    {
        hres = PID_InitRegistry(ped);
    }

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped,g_PoolReport.UsagePage,g_PoolReport.Collection,0x0,&LinkCollection)))
    {
        PUCHAR pReport =  this->pReport[g_PoolReport.HidP_Type];
        UINT   cbReport = this->cbReport[g_PoolReport.HidP_Type];

        PID_GetReport
            (ped, 
             &g_PoolReport,
             LinkCollection,
             pReport, 
             cbReport 
            );

        PID_ParseReport
            (
            ped,
            &g_PoolReport,
            LinkCollection,
            &this->ReportPool,
            cbX(this->ReportPool),
            pReport,
            cbReport
            );
    }


    SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("%s:RamPoolSz:0x%x"),
                    s_tszProc, this->ReportPool.uRamPoolSz );

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped,PoolSz.UsagePage,PoolSz.Collection,0x0,&LinkCollection)) )
    {
        PUCHAR pReport =  this->pReport[PoolSz.HidP_Type];
        UINT   cbReport = this->cbReport[PoolSz.HidP_Type];

        PID_GetReport
            (ped, 
             &PoolSz,
             LinkCollection,
             pReport,     
             cbReport 
            );

        PID_ParseReport
            (
            ped,
            &PoolSz,
            LinkCollection,
            &this->SzPool,
            cbX(this->SzPool),
            pReport,
            cbReport
            );
    }


    PID_Support(ped, cA(g_PoolSupport), g_PoolSupport,  &this->uDeviceManaged);

    // Determine max number of parameter blocks per effect ? 
    if( SUCCEEDED(hres)  )
    {
        USHORT LinkCollection;
        hres = PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET, 0x0, &LinkCollection );

        if( SUCCEEDED(hres) )
        {
            USHORT cAValCaps;
            cAValCaps = 0x0;

            HidP_GetSpecificValueCaps 
                (
                HidP_Output,
                HID_USAGE_PAGE_ORDINALS,
                LinkCollection,
                0x0,
                NULL,
                &cAValCaps,
                this->ppd
                );
            this->cMaxParameters = cAValCaps;
        } else
        {
            this->cMaxParameters = 0x2;
            hres = S_OK;
        }
    }


    if( SUCCEEDED(hres))
    {
        hres = PID_InitSharedMem(ped);
    }

    if( SUCCEEDED(hres ) )
    {
        hres = PID_InitScaling(ped);
    }

    if( SUCCEEDED(hres) )
    {
        // Determine Max effects that can be downloaded to the device
        HIDP_VALUE_CAPS ValCaps;
        USHORT  cAValCaps   = 0x1;
        USAGE   UsagePage   = DIGETUSAGEPAGE(g_BlockIndex.rgPidUsage[0].dwUsage);
        USAGE   Usage       = DIGETUSAGE(g_BlockIndex.rgPidUsage[0].dwUsage);      
        hres = HidP_GetSpecificValueCaps
               (
               g_BlockIndex.HidP_Type,
               UsagePage,
               0x0,
               Usage,
               &ValCaps,
               &cAValCaps,
               this->ppd
               );

        if( SUCCEEDED(hres) || ( hres == HIDP_STATUS_BUFFER_TOO_SMALL ) )
        {
            hres = S_OK;
            this->cMaxEffects = (USHORT) ( ValCaps.PhysicalMax - ValCaps.PhysicalMin );
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HidP_GetValCaps for  (%x %x:%s) "),
                            s_tszProc , UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage) );
        }
    }

    this->cMaxEffects = (USHORT)min(this->cMaxEffects, 
                                    GLOBAL_EFFECT_MEMSZ / ((FIELD_OFFSET(EFFECTSTATE,PidMem)) + this->cMaxParameters*cbX(PIDMEM)) );


    if( this->ReportPool.uSimulEfMax == 0x0 )
    {
        this->ReportPool.uSimulEfMax  = 0xff;

        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL HID dwSimulEfMax == 0x0 defaults to %d  "),
                        s_tszProc, this->cMaxEffects );
    }


    if( SUCCEEDED(hres) )
    {
        TCHAR tsz[MAX_PATH];

        AssertF(this->hThread == 0x0 );
		AssertF(this->hWrite == 0x0);
		AssertF(this->hWriteComplete == 0x0);

        if( GetModuleFileName(g_hinst, tsz, cA(tsz))
            &&LoadLibrary(tsz) == g_hinst)
        {
            InterlockedIncrement(&this->cThreadRef);
            AssertF(this->cThreadRef == 0x1 );
            AssertF(this->hThread == 0x0 );

			this->hWrite = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (this->hWrite == 0x0)
			{
				goto event_thread_error;
			}
			this->hWriteComplete = CreateEvent(NULL, TRUE, TRUE, NULL);
			if (this->hWriteComplete == 0x0)
			{
				goto event_thread_error;
			}
            this->hThread= CreateThread(0, 0, (LPTHREAD_START_ROUTINE)PID_ThreadProc, this,
                                        0, &this->idThread);
		
            if (this->hThread == 0x0)
            {
event_thread_error:;
				//close the event handles
				if (this->hWrite != 0x0)
				{
					CloseHandle(this->hWrite);
					this->hWrite = 0x0;
				}
				if (this->hWriteComplete != 0x0)
				{
					CloseHandle(this->hWriteComplete);
					this->hWriteComplete = 0x0;
				}

                hres = DIERR_PID_NOTINITIALIZED;
                FreeLibrary(g_hinst);
                InterlockedDecrement(&this->cThreadRef);
            }
        }
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *      PID_Finalize
 *
 *      Destroys PID device specific memory
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_Finalize
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    HANDLE hdev;    
    UINT indx;

    EnterProc( PID_Finalize, (_"x", ped));

    DllEnterCrit();

    // Assasinate the thread
	InterlockedDecrement(&this->cThreadRef);

    AssertF(this->cThreadRef == 0x0 );
    // Wait for the thread to die before we go about releasing
    // memory

    do
    {
		DWORD dwWait;

        NudgeWorkerThread(this->idThread);
        Sleep(0);

		dwWait = WaitForSingleObject(this->hThread, 500 ) ;

        if( WAIT_TIMEOUT == dwWait)
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: Waiting for worker Thread %d to die"),
                            s_tszProc,this->idThread );
        }

		//if didn't timeout, and thread didn't die, then we can get into an infinite loop.
		//so close the handle.
		if ((WAIT_ABANDONED == dwWait) || (WAIT_FAILED == dwWait))
		{
			if( this->hdevOvrlp != INVALID_HANDLE_VALUE )
			{
				HANDLE hdevOvr;
				hdevOvr = this->hdevOvrlp;
				this->hdevOvrlp = INVALID_HANDLE_VALUE;
				CancelIo_(hdevOvr);
				Sleep(0);
				CloseHandle(hdevOvr);
			}

			AssertF(this->hdevOvrlp == INVALID_HANDLE_VALUE);

		}

    }while( this->hdevOvrlp != INVALID_HANDLE_VALUE );

    // Close the handle 
    if( this->hdev != INVALID_HANDLE_VALUE)
    {
        hdev = this->hdev;
        this->hdev = INVALID_HANDLE_VALUE;
        CloseHandle(hdev);
    }

    // Free PreParseData
    if( this->ppd )
    {
        HidD_FreePreparsedData(this->ppd);
        this->ppd = NULL;
    }

    // Free HIDP_VALUE_CAPS data
    FreePpv(&this->rgFFUsageInst);
    FreePpv(&this->pLinkCollection);

    for(indx = 0x0; indx < HidP_Max; indx++ )
    {
        FreePpv(&this->pReport[indx]);
    }
	for(indx = 0x0; indx < MAX_BLOCKS; indx++ )
    {
        FreePpv(&this->pWriteReport[indx]);
    }

    DllLeaveCrit();
    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pideff.c ===
/*****************************************************************************
 *
 *  PidEff.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Download PID Effect Block.
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflEff )

#pragma BEGIN_CONST_DATA

/*
 * The structure c_rgUsgEffects, aids in translating elements in the DIEFFECT
 * structure to PID usages 
 */
static PIDUSAGE c_rgUsgEffect[] =
{
    MAKE_PIDUSAGE(DURATION,               FIELD_OFFSET(DIEFFECT,dwDuration)       ),
    MAKE_PIDUSAGE(SAMPLE_PERIOD,          FIELD_OFFSET(DIEFFECT,dwSamplePeriod)   ),
    MAKE_PIDUSAGE(GAIN,                   FIELD_OFFSET(DIEFFECT,dwGain)           ),
    MAKE_PIDUSAGE(TRIGGER_BUTTON,         FIELD_OFFSET(DIEFFECT,dwTriggerButton)  ), 
    MAKE_PIDUSAGE(TRIGGER_REPEAT_INTERVAL,FIELD_OFFSET(DIEFFECT,dwTriggerRepeatInterval) ),
#if DIRECTINPUT_VERSION  >= 0x600
        MAKE_PIDUSAGE(START_DELAY            ,FIELD_OFFSET(DIEFFECT,dwStartDelay)),
#endif
};

/* 
 * g_Effect provides context to the c_rgUsgEffect struct 
 */
PIDREPORT g_Effect =
{
    HidP_Output,                        // Effect Blocks can only be output reports 
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_SET_EFFECT_REPORT,    // Collection 
    cbX(DIEFFECT),                      // Size of incoming data
    cA(c_rgUsgEffect),                  // number of elements in c_rgUsgEffect
    c_rgUsgEffect                       // how elements of DIEFFECT are translated to PID
}; 

/* 
 *  Effect block index to PID usage 
 */
static PIDUSAGE    c_rgUsgBlockIndex[] =
{
    MAKE_PIDUSAGE(EFFECT_BLOCK_INDEX,  0x0 ),
};

/*
 * For some PID transactions block index is output report 
 */
PIDREPORT g_BlockIndex =
{
    HidP_Output,                        // Report Type
    HID_USAGE_PAGE_PID,                 // Usage Page
    0x0,                                // Any collection                            
    cbX(DWORD),                         // size of incoming data
    cA(c_rgUsgBlockIndex),              // translation table for effect block index to PID usages
    c_rgUsgBlockIndex
};

/* 
 * In the PID state report, block index is an input report
 */

PIDREPORT g_BlockIndexIN =
{
    HidP_Input,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_STATE_REPORT,                                                            
    cbX(DWORD),
    cA(c_rgUsgBlockIndex),
    c_rgUsgBlockIndex
};



//CAssertF(MAX_ORDINALS == cA(c_rgUsgOrdinals));

PIDREPORT   g_TypeSpBlockOffset =
{
    HidP_Output,                        // For PID ordinals output reports
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET,  
    cA(c_rgUsgOrdinals)*cbX(DWORD),     // sizeof incoming data
    cA(c_rgUsgOrdinals),                // number of elements
    c_rgUsgOrdinals                     // translation table 
};

#pragma END_CONST_DATA

PIDREPORT   g_Direction =
{
    HidP_Output,                        // For PID ordinals output reports
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_DIRECTION,            
    0x0,
    0x0,
    NULL
};


/*****************************************************************************
 *
 *      hresFinddwUsageFromdwFlags
 *
 *      Given the flags for a DEVICEOBJECTINSTANCE, find the usage and usage page
 *      On init we enum the device and cache the 
 *      DeviceObjects marked as actuators and Effect Triggers. 
 *
 *****************************************************************************/
HRESULT
    hresFinddwUsageFromdwFlags
    (
    IDirectInputEffectDriver *ped,
    DWORD dwFlags,
    DWORD *pdwUsage
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_hresFinddwUsageFromdwFlags, (_"xxx", ped, dwFlags, pdwUsage ));

    // Init FF attributes 
    hres = PID_InitFFAttributes(ped);

    if( SUCCEEDED(hres) )
    {
        /* Better be a FF object ( actuator / Trigger ) */
        if(   dwFlags & DIDFT_FFACTUATOR 
              || dwFlags & DIDFT_FFEFFECTTRIGGER )
        {
            hres = S_OK;
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL dwFlags(0x%x) not FFACTUATOR | FFEFFECTTRIGGER "),
                            s_tszProc, dwFlags );
            hres = E_UNEXPECTED;
        }

        if( SUCCEEDED(hres) )
        {
            UINT cFFObj;
            hres = E_NOTIMPL;

            /* Loop through the all the objects we found during enum */
            for(cFFObj = 0x0;
               cFFObj < this->cFFObj;
               cFFObj++ )
            {
                PDIUSAGEANDINST pdiUI = this->rgFFUsageInst + cFFObj;

                if( pdiUI->dwType == dwFlags )
                {
                    *pdwUsage = pdiUI->dwUsage;
                    hres = S_OK;
                    break;
                }
            }
        }
    }
    if( FAILED(hres) )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL No mapping for dwFlags(0x%x)  "),
                        s_tszProc, dwFlags );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_NewEffectIndex
 *
 *      Gets a new effect index. 
 *
 *      For host managed devices, we assign an unused effect ID. 
 *      For device managed, we get the effectID from the device 
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_NewEffectIndex
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT  peff,
    DWORD       dwEffectId,
    PDWORD      pdwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    USHORT dwEffect;

    EnterProcI(PID_NewEffectIndex, (_"xx", this, pdwEffect));

    AssertF(*pdwEffect == 0);

    // Default assumption is that the device is full.
    hres = DIERR_DEVICEFULL; 

    if( this->uDeviceManaged & PID_DEVICEMANAGED )
    {
        PVOID   pReport;
        UINT    cbReport;
        USHORT  LinkCollection = 0x0;
        USHORT  TLinkCollection = 0x0;

        UINT    nUsages = 0x1;
        USAGE   Usage;
        USAGE   Collection = HID_USAGE_PID_CREATE_NEW_EFFECT;
        USAGE   UsagePage; 
        HIDP_REPORT_TYPE  HidP_Type = HidP_Feature;

        cbReport = this->cbReport[HidP_Type];
        pReport = this->pReport[HidP_Type];

        ZeroBuf(pReport, cbReport);

        // Usage and Usage page determine type of new effect
        Usage       = DIGETUSAGE(dwEffectId);
        UsagePage   = DIGETUSAGEPAGE(dwEffectId);  

        hres = PID_GetLinkCollectionIndex(ped, UsagePage, Collection, 0x0, &LinkCollection );
        if( SUCCEEDED(hres) )
        {
            Collection = HID_USAGE_PID_EFFECT_TYPE;
            hres = PID_GetLinkCollectionIndex(ped, UsagePage, Collection, LinkCollection, &TLinkCollection ); 
        }

        if( SUCCEEDED(hres) )
        {

            hres = HidP_SetUsages 
                   (
                   HidP_Type,
                   UsagePage,
                   TLinkCollection,
                   &Usage,
                   &nUsages,
                   this->ppd,
                   pReport,
                   cbReport);

        }

        if( SUCCEEDED(hres) && PIDMAKEUSAGEDWORD(ET_CUSTOM) == dwEffectId )
        {
            DICUSTOMFORCE DiParam;
            LONG lValue;
            int nBytes;

            AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
            memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

            //how many bytes do we need per sample?
            nBytes    =    (   this->customCaps[   0].BitSize    +    this->customCaps[   1].BitSize    +    this->customCaps[   2].BitSize)/8;

            lValue = DiParam.cSamples * nBytes;

            hres = HidP_SetScaledUsageValue 
                   (
                   HidP_Type,
                   HID_USAGE_PAGE_GENERIC,
                   LinkCollection,
                   HID_USAGE_GENERIC_BYTE_COUNT,
                   lValue,
                   this->ppd,
                   pReport,
                   cbReport
                   );

        }

        // Send the report
        if( SUCCEEDED(hres) )
        {
            hres = PID_SendReport(ped, pReport, cbReport, HidP_Type, TRUE, 0, 1); 
        }

        // Get back the effect ID
        if( SUCCEEDED(hres) )
        {
            PIDREPORT   BlockIndex = g_BlockIndex;
            USHORT      LinkCollection;

            BlockIndex.Collection = HID_USAGE_PID_BLOCK_LOAD_REPORT;
            BlockIndex.HidP_Type  = HidP_Feature; 

            hres =  PID_GetLinkCollectionIndex
                    (ped,
                     BlockIndex.UsagePage,
                     BlockIndex.Collection,
                     0x0,
                     &LinkCollection);

            if( SUCCEEDED(hres) )
            {
                PUCHAR pReport =  this->pReport[BlockIndex.HidP_Type];
                UINT   cbReport = this->cbReport[BlockIndex.HidP_Type];
                PID_GetReport(ped, &BlockIndex, LinkCollection, pReport, cbReport );

                // Get the EffectIndex
                hres = PID_ParseReport
                       (
                       ped,
                       &BlockIndex,
                       LinkCollection,
                       pdwEffect,
                       cbX(*pdwEffect),
                       pReport,
                       cbReport
                       );

				
                if( SUCCEEDED(hres ) )
                {
                    NTSTATUS ntStat;
                    USAGE   rgUsageList[MAX_BUTTONS];
                    UINT  cUsageList = MAX_BUTTONS;
                    PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_BLOCK_LOAD_STATUS, LinkCollection, &LinkCollection );

                    ntStat = HidP_GetUsages
                             (
                             BlockIndex.HidP_Type,
                             HID_USAGE_PAGE_PID, 
                             LinkCollection, 
                             rgUsageList, 
                             &cUsageList,
                             this->ppd,
                             pReport,
                             cbReport);

                    if(SUCCEEDED(ntStat) )
                    {
						if (cUsageList != 0)
						{
							if( rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_FULL )
							{
								hres = DIERR_DEVICEFULL;
							} else if(rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_ERROR )
							{
								hres = DIERR_PID_BLOCKLOADERROR;
							} else
							{
								AssertF(rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_SUCCESS);
							}
						}
						else
						{
							//because of issues w/ some chipsets (see Whistler bugs 231235, 304863),
							//cUsageList can be 0.
							//so warn the user.
							RPF(TEXT("Unable to get the effect load status -- may be a USB chipset issue!"));
							RPF(TEXT("The effect may not play correctly!"));
						}
                    }
                }

                if(SUCCEEDED(hres))
                {
                    NTSTATUS ntStat;
                    UsagePage = HID_USAGE_PAGE_PID;
                    Usage = HID_USAGE_PID_RAMPOOL_AVAILABLE;

                    ntStat = HidP_GetScaledUsageValue 
                             (
                             HidP_Feature,
                             UsagePage,
                             LinkCollection,
                             Usage,
                             &this->dwUsedMem,
                             this->ppd,
                             pReport,
                             cbReport
                             );

                    if(FAILED(ntStat) )
                    {
                        // Reset the amount of used memory
                        this->dwUsedMem = 0x0 ;

                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%s: FAIL HidP_GetScaledUsageValue:0x%x for(%x, %x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection, UsagePage, Usage, 
                                        PIDUSAGETXT(UsagePage,Usage) );
                    }
                }

            }
        }

	 if( SUCCEEDED(hres) )
        {

            PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,*pdwEffect);    
            // Serialize access to for new effect
            WaitForSingleObject(g_hmtxShared, INFINITE);

            AssertF(! (pEffectState->lEfState & PID_EFFECT_BUSY ));

            pEffectState->lEfState |= PID_EFFECT_BUSY;    
            hres = S_OK;

            ReleaseMutex(g_hmtxShared);

        }
    } else
    {
        // Serialize access to common memory block
        WaitForSingleObject(g_hmtxShared, INFINITE);

        for(dwEffect = 1; 
           dwEffect <= this->cMaxEffects; 
           dwEffect++)
        {
            PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect);    
            if( ! ( pEffectState->lEfState & PID_EFFECT_BUSY ) )
            {
                pEffectState->lEfState |= PID_EFFECT_BUSY;    
                *pdwEffect =  dwEffect;

                ZeroBuf(pEffectState->PidMem, cbX(pEffectState->PidMem[0]) * this->cMaxParameters );
                hres = S_OK;
                break;
            }
        }
        ReleaseMutex(g_hmtxShared);
    }

    if( SUCCEEDED(hres) )
    {
        ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded++;
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL Could not create new effects, already have %d "),
                        s_tszProc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_ValidateEffectIndex
 *
 *      Validates an effect index. 
 *
 *****************************************************************************/
STDMETHODIMP  PID_ValidateEffectIndex
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this, dwEffect);    

    EnterProc(PID_ValidateEffectIndex, (_"xx", this, dwEffect));

    if( pEffectState->lEfState & PID_EFFECT_BUSY )
    {
        hres = S_OK;
    } else
    {
        hres = E_HANDLE;
    }


    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_DestroyEffect
 *
 *          Remove an effect from the device.
 *
 *          If the effect is playing, the driver should stop it
 *          before unloading it.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be destroyed.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *      Makes an effect Index available for reuse. Deallocates parameter block
 *      memory. 
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_DestroyEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwId,
    DWORD   dwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres=S_OK;

    EnterProc(PID_DestroyEffectIndex, (_"xx", this, dwEffect));

    DllEnterCrit();

    // Stop the Effect 
    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           PID_DIES_STOP, 
           0x0,
		   TRUE,
		   0,
		   1
           );


    if(SUCCEEDED(hres) && 
       ( this->uDeviceManaged & PID_DEVICEMANAGED ) )
    {
        // Device Managed memory needs to be freed explicitly. 

        USHORT  cbReport;
        PUCHAR  pReport;
        PIDREPORT   BlockIndex = g_BlockIndex;
        USHORT      LinkCollection;

        cbReport = this->cbReport[BlockIndex.HidP_Type];
        pReport = this->pReport[BlockIndex.HidP_Type];

        ZeroBuf(pReport, cbReport);

        BlockIndex.Collection = HID_USAGE_PID_BLOCK_FREE_REPORT;
        BlockIndex.HidP_Type  = HidP_Output; 

        PID_GetLinkCollectionIndex
            (ped,
             BlockIndex.UsagePage,
             BlockIndex.Collection,
             0x0,
             &LinkCollection);

        hres = PID_PackValue
               (
               ped,
               &BlockIndex,
               LinkCollection,
               &dwEffect,
               cbX(dwEffect),
               pReport,
               cbReport
               );
        if(SUCCEEDED(hres) )
        {
            hres = PID_SendReport(ped, pReport, cbReport, BlockIndex.HidP_Type, TRUE, 0, 1); 
        }
    }

    if( SUCCEEDED(hres) )
    {
        PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect);    
        UINT    nAlloc, uParam;

        WaitForSingleObject(g_hmtxShared, INFINITE);

        pEffectState->lEfState = PID_EFFECT_RESET;

        for( uParam = 0x0; uParam < this->cMaxParameters; uParam++ )
        {
            PPIDMEM         pMem = &pEffectState->PidMem[uParam] ;

            if( PIDMEM_SIZE(pMem) )
            {
                PPIDMEM pTmp;
				PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);

                for(nAlloc = 0x0, pTmp = &(pUnitState->Guard[0]); 
                   nAlloc < pUnitState->nAlloc; 
                   nAlloc++, pTmp = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext))
                {
                    if( (PPIDMEM)(pTmp->iNext) == (PPIDMEM)((PUCHAR)pMem - (PUCHAR)pUnitState ))
                    {
                        pTmp->iNext = pMem->iNext;
                        pUnitState->nAlloc--;
                        pUnitState->cbAlloc -= PIDMEM_SIZE(pMem);
                        pMem->iNext = 0;
                        pMem->uOfSz = 0x0;
                        break;
                    }

                }
            }
        }
        ReleaseMutex(g_hmtxShared);
    }

    if( SUCCEEDED(hres) )
    {
        ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded--;
    }

    DllLeaveCrit();

    ExitOleProc(); 
    return hres;
}


/*****************************************************************************
 *
 *      PID_SanitizeEffect
 *
 *      Sanitize the parameters in the DIEFFECT structure. 
 *      Clip values of magnitude, time, etc .. 
 *      Convert the axes array to usage, usage page from the DINPUT obj instances.
 *      Convert and scale angles. 
 *
 *****************************************************************************/
HRESULT PID_SanitizeEffect
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT lpeff,
    DWORD      dwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    UINT nAxis;
    EnterProc( PID_SanitizeEffect, (_"xxx", ped, lpeff, dwFlags));

    if(   ( dwFlags & DIEP_TRIGGERBUTTON )
          && lpeff->dwTriggerButton != -1 )
    {
        DWORD   dwUsage;
        hres = hresFinddwUsageFromdwFlags(ped, lpeff->dwTriggerButton, &dwUsage);
        if( SUCCEEDED(hres) )
        {
            USAGE Usage = DIGETUSAGE(dwUsage);
            USAGE UsagePage = DIGETUSAGEPAGE(dwUsage);  
            lpeff->dwTriggerButton = Usage;
        } else
        {
            lpeff->dwTriggerButton = 0x0;
        }
    } else
    {
        lpeff->dwTriggerButton = 0x0;
    }


    for(nAxis = 0x0; 
       nAxis < lpeff->cAxes; 
       nAxis++ )
    {
        DWORD   dwUsage;
        hres = hresFinddwUsageFromdwFlags(ped, lpeff->rgdwAxes[nAxis], &dwUsage);
        if(SUCCEEDED(hres) )
        {
            lpeff->rgdwAxes[nAxis] = dwUsage;
        }

		//if we have only 1 axis and direction of 0 or 360, make sure the direction matches the axis!
		//if direction is not 0, we do not know what the app wants, so let it be.
		if ((lpeff->cAxes == 1) && (lpeff->rglDirection[nAxis] % 360*DI_DEGREES == 0))
		{
#ifndef HID_USAGE_SIMULATION_STEERING
#define	HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR 
#define	HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
#define	HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
			//if it is X-axis or steering on the wheel, set direction to 90 degrees
			if ((DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_GENERIC_X) || (DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_STEERING))
			{
				lpeff->rglDirection[nAxis] = 90*DI_DEGREES;
			}
			//if it is Y-axis or accelerator or brake, set direction to 0
			else if ((DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_GENERIC_Y) || (DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_ACCELERATOR) ||
				(DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_BRAKE))
			{
				lpeff->rglDirection[nAxis] = 0x0;
			}
		}
		else
		//we have more than 1 axes or direction is non-0 for 1-axis effect; leave the direction along
		{
			lpeff->rglDirection[nAxis] %= 360*DI_DEGREES;
			if(lpeff->rglDirection[nAxis] < 0)
			{
				lpeff->rglDirection[nAxis] += 360*DI_DEGREES;
			}
		}
    }

	
    // Clip the values to min / max

    lpeff->dwGain   = Clip(lpeff->dwGain,  DI_FFNOMINALMAX);

    // Scale to units that device expects
    PID_ApplyScalingFactors(ped, &g_Effect, &this->DiSEffectScale, this->DiSEffectScale.dwSize, &this->DiSEffectOffset, this->DiSEffectOffset.dwSize, lpeff, lpeff->dwSize );

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      CPidDrv_DownloadEffect
 *
 *          Send an effect to the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffectId
 *
 *          Internal identifier for the effect, taken from
 *          the DIEFFECTATTRIBUTES structure for the effect
 *          as stored in the registry.
 *
 *  pdwEffect
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *          On failure, set to zero if the effect is lost,
 *          or left alone if the effect is still valid with
 *          its old parameters.
 *
 *          Note that zero is never a valid effect handle.
 *
 *  peff
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to object identifiers
 *          as follows:
 *
 *          - One type specifier:
 *
 *              DIDFT_RELAXIS,
 *              DIDFT_ABSAXIS,
 *              DIDFT_PSHBUTTON,
 *              DIDFT_TGLBUTTON,
 *              DIDFT_POV.
 *
 *          - One instance specifier:
 *
 *              DIDFT_MAKEINSTANCE(n).
 *
 *          Other bits are reserved and should be ignored.
 *
 *          For example, the value 0x0200104 corresponds to
 *          the type specifier DIDFT_PSHBUTTON and
 *          the instance specifier DIDFT_MAKEINSTANCE(1),
 *          which together indicate that the effect should
 *          be associated with button 1.  Axes, buttons, and POVs
 *          are each numbered starting from zero.
 *
 *  dwFlags
 *
 *          Zero or more DIEP_* flags specifying which
 *          portions of the effect information has changed from
 *          the effect already on the device.
 *
 *          This information is passed to drivers to allow for
 *          optimization of effect modification.  If an effect
 *          is being modified, a driver may be able to update
 *          the effect in situ and transmit to the device
 *          only the information that has changed.
 *
 *          Drivers are not, however, required to implement this
 *          optimization.  All fields in the DIEFFECT structure
 *          pointed to by the peff parameter are valid, and
 *          a driver may choose simply to update all parameters of
 *          the effect at each download.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          DI_TRUNCATED if the parameters of the effect were
 *          successfully downloaded, but some of them were
 *          beyond the capabilities of the device and were truncated.
 *
 *          DI_EFFECTRESTARTED if the parameters of the effect
 *          were successfully downloaded, but in order to change
 *          the parameters, the effect needed to be restarted.
 *
 *          DI_TRUNCATEDANDRESTARTED if both DI_TRUNCATED and
 *          DI_EFFECTRESTARTED apply.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    LPDWORD pdwEffect, 
    LPCDIEFFECT peff, 
    DWORD dwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    DIEFFECT    eff;
    DWORD       rgdwAxes[MAX_AXES];
    LONG        rglDirection[MAX_AXES];
	UINT        uParameter = 0x0 ;
	UINT		totalBlocks = 0x0;
	BOOL		bBlocking = FALSE;

    EnterProcI( PID_DownloadEffectBlock, (_"xxxxxx", ped, dwId, dwEffectId, pdwEffect, peff, dwFlags));

    AssertF(peff->cAxes <= MAX_AXES);

    DllEnterCrit();

    // If new effect is being downloaded  
    if( *pdwEffect == 0x0 )
    {
        // Verify that dwEffectId is supported
        DWORD dwJunk;
        PIDSUPPORT  pidSupport;
        pidSupport.dwPidUsage = dwEffectId;
        pidSupport.HidP_Type = HidP_Output;
        pidSupport.Type      = HID_BUTTON;

        hres = PID_Support
               (
               ped,
               0x1,
               &pidSupport,
               &dwJunk
               );

        if(FAILED(hres))
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL dwEffectId(0x%x) not supported"),
                            s_tszProc, dwEffectId );
        }
    }


    if( SUCCEEDED(hres) )
    {
        // Make a local copy of the effect structure
        // And sanitize the effect struct
        eff = *peff;
        memcpy(rgdwAxes, peff->rgdwAxes,eff.cAxes*cbX(*(eff.rgdwAxes)));
        memcpy(rglDirection, peff->rglDirection, eff.cAxes*cbX(*(eff.rglDirection)));
        eff.rgdwAxes = rgdwAxes;
        eff.rglDirection = rglDirection;
        hres = PID_SanitizeEffect(ped, &eff, dwFlags);
    }

    // Allocate new effect index or Validate Existing index 
    if( SUCCEEDED(hres) )
    {
        if( *pdwEffect != 0x0 )
        {
             hres = PID_ValidateEffectIndex(ped, *pdwEffect);
        }
        else
        {
             if (! (dwFlags & DIEP_NODOWNLOAD))
             {
                  hres = PID_NewEffectIndex(ped, &eff, dwEffectId, pdwEffect);
				  //block the first time around
				  bBlocking = TRUE;
             }
        }
    }

    if (dwFlags & DIEP_NODOWNLOAD)
    {
        goto done;
    }

	//if the DIEP_NORESTART flag is passed, we have no block because this may fail
	//if the device can't update the parameters on the fly
	if (dwFlags & DIEP_NORESTART)
	{
		bBlocking = TRUE;
	}

    if( SUCCEEDED(hres) )
    {
		//count up how many total blocks we will have in this download
		//check wether we're sending the effect block
		if (dwFlags & ( DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_STARTDELAY ) )
		{
			totalBlocks ++;
		}
		//check whether we're sending the type-specific params
		if (dwFlags & DIEP_TYPESPECIFICPARAMS)
		{
			//this is slightly different, in that conditions can have 1 type-specific block PER AXIS,
			//i.e. currently up to 2
			//so if we have a DICONDITION, we check how many type-specific blocks we've got
			if ((dwEffectId == PIDMAKEUSAGEDWORD(ET_SPRING)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_DAMPER)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_INERTIA)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_FRICTION)))
			{
				totalBlocks +=(eff.cbTypeSpecificParams)/sizeof(DICONDITION);
				//DICONDITIONS also can't have envelopes
				dwFlags &= ~DIEP_ENVELOPE;
			}
			else
			{
				totalBlocks++;
			}
		}
		//check whether we're sending the envelope
		if ((dwFlags & DIEP_ENVELOPE) && (eff.lpEnvelope != NULL))
		{
			totalBlocks++;
		}
		//check whether we need to send the start reprot
		if (dwFlags & DIEP_START)
		{
			totalBlocks++;
		}
		//make sure that we haven't got more than the maximum
		AssertF(totalBlocks <= MAX_BLOCKS);

        // Do the parameter block
        if(     SUCCEEDED(hres) 
                &&  ( dwFlags & ( DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE)  )
          )
        {
            hres =  PID_DoParameterBlocks
                    (
                    ped,
                    dwId, 
                    dwEffectId,
                    *pdwEffect, 
                    &eff, 
                    dwFlags,
                    &uParameter,
					bBlocking,
					totalBlocks
                    );
        }

        // Now do the effect report 
        if( SUCCEEDED(hres) 
            && ( dwFlags & ( DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_STARTDELAY ) ) )
        {
            USHORT  cbReport;
            PUCHAR  pReport;

            AssertF(g_Effect.HidP_Type == HidP_Output);
            cbReport = this->cbReport[g_Effect.HidP_Type];
            pReport = this->pReport[g_Effect.HidP_Type];

            // Set the Effect Structure 
            if( SUCCEEDED(hres) )
            {
                USHORT  LinkCollection;
                PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, g_Effect.Collection, 0x0, &LinkCollection );

                ZeroBuf(pReport, cbReport);

                // Do the common elements of the effect structure
                hres = PID_PackValue
                       (
                       ped,
                       &g_Effect,
                       LinkCollection,
                       &eff,
                       eff.dwSize,
                       pReport,
                       cbReport
                       );


                // Set the Effect Block Index
                if( SUCCEEDED(hres) )
                {
                    hres = PID_PackValue
                           (
                           ped,
                           &g_BlockIndex,
                           LinkCollection,
                           pdwEffect,
                           cbX(*pdwEffect),
                           pReport,
                           cbReport
                           );
                }

                // Set Direction and axis attributes
                if( SUCCEEDED(hres) )
                {
                    USHORT  DirectionCollection;

                    PID_GetLinkCollectionIndex(ped, g_Direction.UsagePage, g_Direction.Collection, 0x0, &DirectionCollection );
                    PID_ApplyScalingFactors(ped, &g_Direction, &this->DiSEffectAngleScale, cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset, cbX(this->DiSEffectAngleOffset), eff.rglDirection, eff.cAxes*cbX(LONG) );

                    hres = PID_PackValue
                           (
                           ped,
                           &g_Direction,
                           DirectionCollection,
                           eff.rglDirection,
                           eff.cAxes * cbX(LONG),
                           pReport,
                           cbReport
                           );


                    if(SUCCEEDED(hres) && 
                      ! ( eff.dwFlags & DIEFF_CARTESIAN ) )
                    {
                        // Direction Enable
                        USHORT  Usage;
                        USHORT  UsagePage;
                        UINT    nUsages = 0x1;
                        NTSTATUS  ntStat;

                        // Direction Enable is in the set effect collection
                        UsagePage = g_Effect.UsagePage;
                        Usage = HID_USAGE_PID_DIRECTION_ENABLE;

                        ntStat = HidP_SetUsages 
                                 (
                                 HidP_Output,
                                 UsagePage,
                                 LinkCollection,
                                 &Usage,
                                 &nUsages,
                                 this->ppd,
                                 pReport,
                                 cbReport);


                        if( FAILED(ntStat) )
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                            s_tszProc, ntStat, 
                                            LinkCollection, UsagePage, Usage,
                                            PIDUSAGETXT(UsagePage,Usage) );

                        } else
                        {
                            SquirtSqflPtszV(sqfl | sqflVerbose,
                                            TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                            s_tszProc, ntStat, 
                                            LinkCollection,UsagePage, Usage,
                                            PIDUSAGETXT(UsagePage,Usage) );
                        }



                    } else  //if(  dwFlags  & DIEP_AXES )
                    {
                        UINT    nAxis;
                        USHORT  LinkCollection_AE=0x0;

                        if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_AXES_ENABLE, 0x0, &LinkCollection_AE)))
                        {
                            // ISSUE-2001/03/29-timgill Need to support axes within pointer collections
                            // PID spec indicates a pointer collection, 
                            // Do we want to support axes enables within a pointer 
                            // collection ? 

                            // See if there is a pointer collection 

                        }

                        for(nAxis = 0x0; 
                           nAxis < eff.cAxes; 
                           nAxis++ )
                        {
                            UINT    nUsages = 0x1;
                            USHORT  Usage = DIGETUSAGE(eff.rgdwAxes[nAxis]);
                            USHORT  UsagePage = DIGETUSAGEPAGE(eff.rgdwAxes[nAxis]);
                            NTSTATUS ntStat;

                            //ISSUE-2001/03/29-timgill For now we assume any collection
                            ntStat = HidP_SetUsages 
                                     (
                                     HidP_Output,
                                     UsagePage,
                                     0x0,       
                                     &Usage,
                                     &nUsages,
                                     this->ppd,
                                     pReport,
                                     cbReport);

                            if( FAILED(ntStat) )
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                0x0, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage,Usage) );
                                hres = ntStat;
                                break;
                            } else
                            {
                                SquirtSqflPtszV(sqfl | sqflVerbose,
                                                TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                0x0, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage, Usage) );
                            }
                        }
                    }
                }
                if(  SUCCEEDED(hres) 
                     && !( this->uDeviceManaged & PID_DEVICEMANAGED ) 
                  )
                {
                    // Need parameter block offsets
                    UINT indx;
                    USHORT LinkCollection;
                    LONG rglValue[MAX_ORDINALS];

                    PID_GetLinkCollectionIndex(ped,  g_Effect.UsagePage, g_TypeSpBlockOffset.Collection, 0x0, &LinkCollection );

                    for(indx = 0x0; indx < this->cMaxParameters; indx++ )
                    {
                        hres = PID_GetParameterOffset(ped, *pdwEffect, indx, 0x0, &rglValue[indx]); 
                        if(FAILED(hres))
                        {
                            break;
                        }
                    }
                    if(SUCCEEDED(hres))
                    {
                        hres = PID_PackValue
                               (
                               ped,
                               &g_TypeSpBlockOffset,
                               LinkCollection,
                               rglValue,
                               this->cMaxParameters*cbX(LONG),
                               pReport,
                               cbReport
                               );
                    }
                }

                // Set the Effect Type
                if( SUCCEEDED(hres) )
                {
                    USAGE   UsagePage = DIGETUSAGEPAGE(dwEffectId);
                    USAGE   Usage     = DIGETUSAGE(dwEffectId);

                    UINT    nUsages = 0x1;
                    USHORT  LinkCollection_ET;
                    NTSTATUS  ntStat;

                    PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, HID_USAGE_PID_EFFECT_TYPE, 0x0, &LinkCollection_ET);

                    ntStat = HidP_SetUsages 
                             (
                             HidP_Output,
                             UsagePage,
                             LinkCollection_ET,
                             &Usage,
                             &nUsages,
                             this->ppd,
                             pReport,
                             cbReport);
                    if( FAILED(ntStat) )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection_ET, UsagePage, Usage,
                                        PIDUSAGETXT(UsagePage,Usage) );
                        hres = ntStat;

                    } else
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                                        TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection_ET, UsagePage, Usage,
                                        PIDUSAGETXT(UsagePage,Usage) );
                    }
                }


                if( SUCCEEDED(hres) )
                {
                    hres = PID_SendReport(ped, pReport, cbReport, g_Effect.HidP_Type, bBlocking, uParameter, totalBlocks);
					uParameter ++;
                }
            }
        }
    }

    if( FAILED(hres) )
    {
        PID_DestroyEffect(ped, dwId, *pdwEffect);
    }

    if(   SUCCEEDED(hres)
          && (dwFlags & DIEP_START) )
    {
        hres = PID_EffectOperation
               (
               ped, 
               dwId, 
               *pdwEffect,
               PID_DIES_START, 
               0x1,
			   bBlocking,
			   uParameter,
			   totalBlocks
               );

		if (SUCCEEDED(hres))
		{

			//set the status to DIEGES_PLAYING.
			//we do this because of the following: if an app calls Start(), and then immediately
			//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
			//would not have time to update the status of the effect to DIEGES_PLAYING
			//(see Whistler bug 287035).
			//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
			//in the blocking case, we know that the call to WriteFile() has succeeded, and that
			//all the data has been written (see PID_SendReportBl() in pidhid.c) --
			//so we might as well set the status.
			//in the non-blocking case, the data can be buffered anyway -- so we might as well set the status.
			PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this, *pdwEffect); 
			pEffectState->lEfState |= DIEGES_PLAYING;
		}
			   
    }

done:;

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidpr.h ===
#ifdef DBG
#define DEBUG
#endif

#include "dinput.h"
#include "dinputd.h"

#include "baggage.h"

#include "hidsdi.h"
#include "regstr.h"
#include "PIDi.h"
#include "PidUsg.h"

#include "debug.h"

//for the LONG_MAX define
#include "limits.h"

#ifdef WINNT
#include "aclapi.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidparam.c ===
/*****************************************************************************
 *
 *  PidParam.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Download PID parameter block(s) .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflParam )

//struct to keep in relevant data for g_Custom
typedef struct PIDCUSTOM
{
	DWORD DataOffset;
	DWORD cSamples;
	DWORD dwSamplePeriod;
} PIDCUSTOM, *PPIDCUSTOM;


#pragma BEGIN_CONST_DATA

static PIDUSAGE  c_rgUsgEnvelope[] =
{
    MAKE_PIDUSAGE(ATTACK_LEVEL,           FIELD_OFFSET(DIENVELOPE,dwAttackLevel)  ),
    MAKE_PIDUSAGE(ATTACK_TIME,            FIELD_OFFSET(DIENVELOPE,dwAttackTime)   ),
    MAKE_PIDUSAGE(FADE_LEVEL,             FIELD_OFFSET(DIENVELOPE,dwFadeLevel)    ),
    MAKE_PIDUSAGE(FADE_TIME,              FIELD_OFFSET(DIENVELOPE,dwFadeTime)     ),
};

PIDREPORT g_Envelope =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_ENVELOPE_REPORT,
    cbX(DIENVELOPE),
    cA(c_rgUsgEnvelope),
    c_rgUsgEnvelope
};

static PIDUSAGE    c_rgUsgCondition[] =
{
    MAKE_PIDUSAGE(CP_OFFSET,              FIELD_OFFSET(DICONDITION, lOffset)      ),
    MAKE_PIDUSAGE(POSITIVE_COEFFICIENT,   FIELD_OFFSET(DICONDITION, lPositiveCoefficient)),
    MAKE_PIDUSAGE(NEGATIVE_COEFFICIENT,   FIELD_OFFSET(DICONDITION, lNegativeCoefficient)),
    MAKE_PIDUSAGE(POSITIVE_SATURATION,    FIELD_OFFSET(DICONDITION, dwPositiveSaturation)),
    MAKE_PIDUSAGE(NEGATIVE_SATURATION,    FIELD_OFFSET(DICONDITION, dwNegativeSaturation)),
    MAKE_PIDUSAGE(DEAD_BAND,              FIELD_OFFSET(DICONDITION, lDeadBand)),
};

PIDREPORT g_Condition =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CONDITION_REPORT,
    cbX(DICONDITION),
    cA(c_rgUsgCondition),
    c_rgUsgCondition
};

static PIDUSAGE    c_rgUsgPeriodic[] =
{
    MAKE_PIDUSAGE(OFFSET,                 FIELD_OFFSET(DIPERIODIC,lOffset)),
    MAKE_PIDUSAGE(MAGNITUDE,              FIELD_OFFSET(DIPERIODIC,dwMagnitude)),
    MAKE_PIDUSAGE(PHASE,                  FIELD_OFFSET(DIPERIODIC,dwPhase)),
    MAKE_PIDUSAGE(PERIOD,                 FIELD_OFFSET(DIPERIODIC,dwPeriod)),
};

PIDREPORT g_Periodic =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_PERIODIC_REPORT,
    cbX(DIPERIODIC),
    cA(c_rgUsgPeriodic),
    c_rgUsgPeriodic
};

static PIDUSAGE    c_rgUsgConstant[] =
{
    MAKE_PIDUSAGE(MAGNITUDE,              FIELD_OFFSET(DICONSTANTFORCE, lMagnitude)),
};

PIDREPORT g_Constant =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CONSTANT_FORCE_REPORT,
    cbX(DICONSTANTFORCE),
    cA(c_rgUsgConstant),
    c_rgUsgConstant
};


static PIDUSAGE    c_rgUsgRamp[] =
{
    MAKE_PIDUSAGE(RAMP_START,             FIELD_OFFSET(DIRAMPFORCE, lStart)),
    MAKE_PIDUSAGE(RAMP_END,               FIELD_OFFSET(DIRAMPFORCE, lEnd)),
};

PIDREPORT g_Ramp =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_RAMP_FORCE_REPORT,
    cbX(DIRAMPFORCE),
    cA(c_rgUsgRamp),
    c_rgUsgRamp
};

static PIDUSAGE c_rgUsgCustom[]=
{
	MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_OFFSET, FIELD_OFFSET(PIDCUSTOM, DataOffset)),
	MAKE_PIDUSAGE(SAMPLE_COUNT,				FIELD_OFFSET(PIDCUSTOM, cSamples)),
	MAKE_PIDUSAGE(SAMPLE_PERIOD,			FIELD_OFFSET(PIDCUSTOM, dwSamplePeriod)),
};

PIDREPORT g_Custom =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CUSTOM_FORCE_REPORT,
    cbX(PIDCUSTOM),
    cA(c_rgUsgCustom),
    c_rgUsgCustom,
};   


static PIDUSAGE c_rgUsgCustomData[]=
{
	MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_OFFSET, 0x0),
	MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_BYTE_COUNT, 0x0),
    MAKE_PIDUSAGE(CUSTOM_FORCE_DATA, 0x0 ),

};

PIDREPORT g_CustomData =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_CUSTOM_FORCE_DATA_REPORT,
    cbX(DWORD),
    cA(c_rgUsgCustomData),
    c_rgUsgCustomData,
};   

static PIDUSAGE c_rgUsgDirectionAxes[]=
{
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_X, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_Y, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_Z, 2*cbX(ULONG)),
};

PIDREPORT g_CustomSample =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DOWNLOAD_FORCE_SAMPLE ,
    cbX(DWORD),
    cA(c_rgUsgDirectionAxes),
    c_rgUsgDirectionAxes,
};   


static PIDUSAGE    c_rgUsgParameterOffset[] =
{
    MAKE_PIDUSAGE(PARAMETER_BLOCK_OFFSET,  0x0 ),
};

static PIDREPORT g_ParameterOffset =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    0x0,
    cbX(DWORD),
    cA(c_rgUsgParameterOffset),
    c_rgUsgParameterOffset
};

#pragma END_CONST_DATA

//global variable to keep in relevant data for g_Custom
PIDCUSTOM g_PidCustom;


STDMETHODIMP
    PID_GetParameterOffset
    (
    IDirectInputEffectDriver *ped,
    DWORD      dwEffectIndex,
    UINT       uParameter,
    DWORD      dwSz,
    PLONG      plValue
    )
{

    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    USHORT  uOffset = (USHORT)-1;
    PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffectIndex);    
    PPIDMEM         pMem = &pEffectState->PidMem[uParameter];

    EnterProcI( PID_GetParameterOffset, (_"xxxxx", ped, dwEffectIndex, uParameter, dwSz, plValue));

    AssertF(uParameter < this->cMaxParameters);

    *plValue = 0x0;
    hres = PID_ValidateEffectIndex(ped, dwEffectIndex);
    if(SUCCEEDED(hres))
    {
        // We have already allocated memory, 
        // Just return the last size
        if( PIDMEM_SIZE(pMem) != 0x0 )
        {
            uOffset = PIDMEM_OFFSET(pMem);
        } else if( dwSz == 0x0 )
        {
            // Logitech device wants parameter blocks to 
            // set to -1 if they do not exist
            uOffset = (USHORT)-1;
        } else
        {
            // New Allocation
            PPIDMEM pTmp, pNext;
            UINT nAlloc;
            USHORT uSz;
			PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
			hres = DIERR_OUTOFMEMORY;

            // Align memory request
            uSz = (USHORT)((dwSz / this->ReportPool.uPoolAlign + 1) * (this->ReportPool.uPoolAlign));

            AssertF(uSz >= (USHORT)this->ReportPool.uPoolAlign);
            //To be doubly sure.
            uSz = max( uSz, (USHORT)this->ReportPool.uPoolAlign);

            WaitForSingleObject(g_hmtxShared, INFINITE);

            for(nAlloc = 0x0, pTmp = &(pUnitState->Guard[0]), pNext = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext);  
               nAlloc < pUnitState->nAlloc && pTmp != &(pUnitState->Guard[1]);
               nAlloc++, pTmp = pNext, pNext = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext))
            {

                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("%d %x(%x), Next:%x (%x) "),
                                nAlloc, pTmp, pTmp->uOfSz, pNext, pNext->uOfSz  );

                AssertF(pNext != NULL );
				// If pNext == pUnitState, it means that the offset is 0.
				// The offset of 0 is invalid.
				AssertF((PUCHAR)pNext != (PUCHAR)pUnitState);

                // Is there space in the cracks
                if( GET_NEXTOFFSET(pTmp) + uSz < PIDMEM_OFFSET(pNext)  )
                {
                    pMem->iNext   = (PUCHAR)pNext - (PUCHAR)pUnitState;
                    pTmp->iNext   = (PUCHAR)pMem - (PUCHAR)pUnitState;

                    uOffset       = GET_NEXTOFFSET(pTmp) ;
                    pMem->uOfSz   = PIDMEM_OFSZ(uOffset, uSz);

                    pUnitState->nAlloc++;
                    pUnitState->cbAlloc += uSz;
                    hres = S_OK;

                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%d %p (%x), Next: %p (%x) "),
                                    nAlloc, pMem, pMem->uOfSz, pNext, pNext->uOfSz  );

                    break;
                }

            }

            ReleaseMutex(g_hmtxShared);
        }
    }

    if( SUCCEEDED(hres) )
    {
        *plValue = (ULONG)uOffset;
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL  Could not allocate %d bytes, UsedMem:%d, Allocs%d"),
                        s_tszProc, dwSz, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cbAlloc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->nAlloc );
    }


    ExitOleProc();

    return hres;
}

HRESULT
    PID_SendParameterBlock
    (
    IDirectInputEffectDriver *ped,
    DWORD       dwEffectIndex,
    DWORD       dwMemSz,
    PUINT       puParameter,
    PPIDREPORT  pPidReport,
    PVOID       pvData,
    UINT        cbData,
	BOOL		bBlocking,
	UINT		totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres=S_OK;

    PUCHAR   pReport;
    UINT    cbReport;

    EnterProcI( PID_SendParameterBlock, (_"xxxxx", ped, dwEffectIndex, dwMemSz, pPidReport, pvData, cbData));

    AssertF(pPidReport->HidP_Type == HidP_Output);

    cbReport = this->cbReport[pPidReport->HidP_Type];
    pReport  = this->pReport[pPidReport->HidP_Type];

    if( *puParameter >= this->cMaxParameters )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL Only support %d parameter blocks per effect "),
                        s_tszProc, *puParameter );

        hres = E_NOTIMPL;
    }

    if( SUCCEEDED(hres) )
    {
        USHORT  LinkCollection;
        ZeroBuf(pReport, cbReport);

        PID_GetLinkCollectionIndex(ped, pPidReport->UsagePage, pPidReport->Collection, 0x0, &LinkCollection);

        hres = PID_PackValue
               (
               ped,
               pPidReport,
               LinkCollection,
               pvData,
               cbData,
               pReport,
               cbReport
			   );

        // For device managed memory, we need to send the 
        // effect index 
        if( SUCCEEDED(hres) )
        {
            if( this->uDeviceManaged & PID_DEVICEMANAGED )
            {
                // Must be a valid effect ID
                AssertF(dwEffectIndex != 0x0 ); 

                /*hres =*/

                PID_PackValue
                    (
                    ped,
                    &g_BlockIndex,
                    LinkCollection,
                    &dwEffectIndex,
                    cbX(dwEffectIndex),
                    pReport,
                    cbReport
                    ); 

                // Send down the paramter block index
                /*hres =*/PID_PackValue
                    (
                    ped,
                    &g_ParameterOffset,
                    LinkCollection,
                    puParameter,
                    cbX(*puParameter),
                    pReport,
                    cbReport
                    );
            } else
            {
                LONG lValue;

                hres = PID_GetParameterOffset(ped, dwEffectIndex, *puParameter, dwMemSz, &lValue); 

                if( SUCCEEDED(hres) )
                {
                    hres = PID_PackValue
                           (
                           ped,
                           &g_ParameterOffset,
                           LinkCollection,
                           &lValue,
                           cbX(lValue),
                           pReport,
                           cbReport
                           );
                }
            }
        }

        if( SUCCEEDED(hres) )
        {
			hres = PID_SendReport(ped, pReport, cbReport, pPidReport->HidP_Type, bBlocking, *puParameter, totalBlocks); 
        }

        if(SUCCEEDED(hres))
        {
            (*puParameter)++;
        }
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_DownloadCustomForceData
 *
 *      Download custom force sample data to the device.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadCustomForceData
    (
    IDirectInputEffectDriver *ped,
    DWORD dwEffectIndex, 
    PUINT puParameter,
    LPCDICUSTOMFORCE pCustom, 
    LPCDIEFFECT     peff
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    PCHAR pData = NULL;
	PCHAR pBuff = NULL;
    USHORT cbData;
	USHORT nBytes;
	USHORT bitsX;
	USHORT bitsY;
	USHORT bitsZ;
	LPLONG pSample;
    
    EnterProcI( PID_DownloadCustomForceData, (_"xxx", ped, dwEffectIndex, pCustom,  puParameter ));

	//zero out g_PidCustom
	g_PidCustom.cSamples = g_PidCustom.DataOffset = g_PidCustom.dwSamplePeriod = 0;

	//get bytes per sample and allocate the buffer
	bitsX = this->customCaps[0].BitSize;
	bitsY = this->customCaps[1].BitSize;
	bitsZ = this->customCaps[2].BitSize;

	//byte count must be multiple of 8!
	if ((bitsX%8 != 0) || (bitsY%8 != 0) || (bitsZ%8 != 0))
	{

		 SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Download Force Sample report fields that are not multiples of 8 are not supported!\n"),
                            s_tszProc );
		hres = E_NOTIMPL;
	}

	//report count shouldn't be bigger than 1!
	AssertF(this->customCaps[0].ReportCount <= 1);
	AssertF(this->customCaps[1].ReportCount <= 1);
	AssertF(this->customCaps[2].ReportCount <= 1);

	if (SUCCEEDED(hres))
	{
		nBytes = (bitsX + bitsY + bitsZ)/8;
		cbData  = (USHORT) (pCustom->cSamples * nBytes);
		hres = AllocCbPpv(cbData, &pBuff);

		if( pBuff != NULL)
		{
			//determine which effect axis corresponds to which report axis
			LONG Offset[3] = {-1, -1, -1};
			int nAxis = 0;
			int nChannel = 0;
			int nSample = 0;
			
			for (nChannel = 0; nChannel < (int)pCustom->cChannels, nChannel < (int)peff->cAxes; nChannel ++)
			{
				for (nAxis = 0; nAxis < 3; nAxis ++)
				{
					if (DIGETUSAGE(peff->rgdwAxes[nChannel]) == DIGETUSAGE(g_CustomSample.rgPidUsage[nAxis].dwUsage))
					{
						Offset[nAxis] = nChannel;
					}
				}
			}
			
			
			
			ZeroBuf(pBuff, cbData);

			pData = pBuff;
			pSample = pCustom->rglForceData;

			//scale all the samples
			//loop through samples
			for (nSample = 0; nSample < (int)pCustom->cSamples; nSample ++)
			{
				//loop through report axis
				for (nAxis = 0; nAxis < 3; nAxis++)
				{
					LONG lSampleValue = 0;

					//check if this axis is used
					if (Offset[nAxis] == -1)
					{
						pData += this->customCaps[nAxis].BitSize/8;
						continue;
					}

					lSampleValue = *(pSample + Offset[nAxis]);


					switch (this->customCaps[nAxis].BitSize)
					{
					case 8:
						//8-bit reports
						{
							(*((BYTE*)pData)) = (BYTE)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					case 16:
						//16-bit reports
						{

							(*((SHORT*)pData)) = (SHORT)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					case 32:
						//assume 32-bit reports as default
						{
							(*((LONG*)pData)) = (LONG)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					default:
						{
							SquirtSqflPtszV(sqfl | sqflError,
								TEXT("%s:FAIL Download Force Sample report fields that are not 8, 16 or 32 are not supported\n"),
								s_tszProc );
							hres = E_NOTIMPL;
						}
					}

				}

				pSample += pCustom->cChannels;


			}

		}

		if(SUCCEEDED(hres))
		{
			PCHAR   pReport;
			UINT    cbReport;
			HIDP_REPORT_TYPE  HidP_Type = HidP_Output;
			USAGE UsagePage = HID_USAGE_PAGE_PID;
			USAGE UsageData = HID_USAGE_PID_CUSTOM_FORCE_DATA;
			USAGE UsageOffset = HID_USAGE_PID_CUSTOM_FORCE_DATA_OFFSET;
			USHORT  LinkCollection = 0x0;

			cbReport = this->cbReport[g_CustomData.HidP_Type];
			pReport  = this->pReport[g_CustomData.HidP_Type];
  
			if ((this->customDataCaps.ReportCount > 0) && (this->customDataCaps.BitSize >=8))
			{
				USHORT nOffset = 0;
				LONG lOffset = 0;
				USHORT nIncrement = (this->customDataCaps.ReportCount * this->customDataCaps.BitSize)/8;
					
				// For memory managed device allocate enough memory
				// holding the custom force samples
				if( ! (this->uDeviceManaged & PID_DEVICEMANAGED ))
				{
					hres = PID_GetParameterOffset(ped, dwEffectIndex, *puParameter, this->SzPool.uSzCustom, &lOffset); 
				}

				pData = pBuff;

				if (SUCCEEDED(hres))
				{

					//send data in a loop
					for (nOffset = 0; nOffset < cbData; nOffset += nIncrement)
					{
						//create a new buffer and copy data into it
						PCHAR pIncrement = NULL;
						hres = AllocCbPpv(nIncrement, &pIncrement);

						if (pIncrement != NULL)
						{
							ZeroBuf(pIncrement, nIncrement);
							memcpy(pIncrement, pData, min((cbData - nOffset), nIncrement));

							ZeroBuf(pReport, cbReport);

							//set the byte count
							hres = HidP_SetScaledUsageValue
								(
								HidP_Type,
								HID_USAGE_PAGE_GENERIC,
								LinkCollection,
								HID_USAGE_GENERIC_BYTE_COUNT,
								(LONG)nIncrement,
								this->ppd,
								pReport,
								cbReport
								);
								


							//set the offset
							hres = HidP_SetScaledUsageValue
								(
								HidP_Type,
								UsagePage,
								0x0,
								//LinkCollection,
								UsageOffset,
								(LONG) (nOffset + lOffset),
								this->ppd,
								pReport,
								cbReport
								);
							
							
					
							//set the data
							hres  = HidP_SetUsageValueArray 
								(
								HidP_Type,          //  IN    HIDP_REPORT_TYPE     ReportType,
								UsagePage, //  IN    USAGE                UsagePage,
								0x0,                //  IN    USHORT               LinkCollection, // Optional
								UsageData,
								pIncrement,              //  IN    PCHAR                UsageValue,
								nIncrement,             //  IN    USHORT               UsageValueByteLength,
								this->ppd,          //  IN    PHIDP_PREPARSED_DATA PreparsedData,
								pReport,            //  OUT   PCHAR                Report,
								cbReport            //  IN    ULONG                ReportLength
								);

			
							//set the effect index
							PID_PackValue
								(
								ped,
								&g_BlockIndex,
								LinkCollection,
								&dwEffectIndex,
								cbX(dwEffectIndex),
								pReport,
								cbReport
								);
															

							//send the report
							hres = PID_SendReport(ped, pReport, cbReport, HidP_Type, TRUE, 0, 1);
					
							pData += nIncrement;

							FreePpv(&pIncrement);
						}
					}

					//put data into g_PidCustom
					g_PidCustom.DataOffset = (DWORD)lOffset;
					g_PidCustom.cSamples = pCustom->cSamples;
					//ISSUE-2001/03/29-timgill May need to do real scaling.
					g_PidCustom.dwSamplePeriod = pCustom->dwSamplePeriod/1000; //in milliseconds

					//and increment puParameter
					(*puParameter)++;

				}			
			}
			else
			{
				//do nothing
			}

			FreePpv(&pBuff);
		}
	
    }

	ExitOleProc();
    return hres;
}



STDMETHODIMP
    PID_DoParameterBlocks
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    DWORD dwEffectIndex, 
    LPCDIEFFECT peff, 
    DWORD dwFlags,
    PUINT puParameter,
	BOOL  bBlocking,
	UINT totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_DoParameterBlocks, (_"xxxxxxx", ped, dwId, dwEffectId, dwEffectIndex, peff, dwFlags, puParameter ));

    if( SUCCEEDED(hres)
        && (dwFlags & DIEP_TYPESPECIFICPARAMS) )
    {
        AssertF(peff->lpvTypeSpecificParams != NULL);        
        AssertF(peff->cbTypeSpecificParams != 0x0 ); 

        switch(dwEffectId)
        {
        case PIDMAKEUSAGEDWORD(ET_CONSTANT) :
            {
                DICONSTANTFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));
                // Constant Force:
                // Scale the magnitude.
                DiParam.lMagnitude = Clamp(-DI_FFNOMINALMAX,  DiParam.lMagnitude, DI_FFNOMINALMAX);

                PID_ApplyScalingFactors(ped, &g_Constant, &this->DiSConstScale, cbX(this->DiSConstScale), &this->DiSConstOffset, cbX(this->DiSConstOffset), &DiParam, cbX(DiParam) );

                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex,
                       this->SzPool.uSzConstant,
                       puParameter,
                       &g_Constant,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,
					   totalBlocks
                       );
                break;
            }

        case PIDMAKEUSAGEDWORD(ET_RAMP):
            {
                // Ramp Force
                DIRAMPFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

                //Scale the magnitude
                DiParam.lStart  = Clamp(-DI_FFNOMINALMAX, DiParam.lStart,    DI_FFNOMINALMAX);
                DiParam.lEnd    = Clamp(-DI_FFNOMINALMAX, DiParam.lEnd,      DI_FFNOMINALMAX);


                PID_ApplyScalingFactors(ped, &g_Ramp, &this->DiSRampScale, cbX(this->DiSRampScale), &this->DiSRampOffset, cbX(this->DiSRampOffset), &DiParam, cbX(DiParam) );
                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex, 
                       this->SzPool.uSzRamp,
                       puParameter,
                       &g_Ramp,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,		
					   totalBlocks
                       );
                break;
            }

        case PIDMAKEUSAGEDWORD(ET_SQUARE):
        case PIDMAKEUSAGEDWORD(ET_SINE):
        case PIDMAKEUSAGEDWORD(ET_TRIANGLE):
        case PIDMAKEUSAGEDWORD(ET_SAWTOOTH_UP):
        case PIDMAKEUSAGEDWORD(ET_SAWTOOTH_DOWN):
            {
                DIPERIODIC DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

                //Scale the parameters
                DiParam.dwMagnitude =   Clip(                 DiParam.dwMagnitude,    DI_FFNOMINALMAX);
                DiParam.lOffset =       Clamp(-DI_FFNOMINALMAX,  DiParam.lOffset,        DI_FFNOMINALMAX);
                //Wrap the phase around
                DiParam.dwPhase %= (360*DI_DEGREES);

                PID_ApplyScalingFactors(ped, &g_Periodic, &this->DiSPeriodicScale, cbX(this->DiSPeriodicScale), &this->DiSPeriodicOffset, cbX(this->DiSPeriodicOffset), &DiParam, cbX(DiParam) );
                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex, 
                       this->SzPool.uSzPeriodic,
                       puParameter,
                       &g_Periodic,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,
					   totalBlocks
                       );
                break;
            }
        case PIDMAKEUSAGEDWORD(ET_SPRING):
        case PIDMAKEUSAGEDWORD(ET_DAMPER):
        case PIDMAKEUSAGEDWORD(ET_INERTIA):
        case PIDMAKEUSAGEDWORD(ET_FRICTION):
            {  
                LPDICONDITION lpCondition;
				DWORD nStruct;
				DWORD cStruct = (peff->cbTypeSpecificParams)/sizeof(DICONDITION);
				AssertF(cStruct <= peff->cAxes);

                for(nStruct = 0x0, lpCondition = (LPDICONDITION)peff->lpvTypeSpecificParams; 
                   nStruct < cStruct && SUCCEEDED(hres);  
                   nStruct++, lpCondition++ )
                {
                    DICONDITION DiCondition;
                    DiCondition = *lpCondition;

                    //Scale the values
                    DiCondition.lOffset =               Clamp(-DI_FFNOMINALMAX,  DiCondition.lOffset,                DI_FFNOMINALMAX);
                    DiCondition.lPositiveCoefficient =  Clamp(-DI_FFNOMINALMAX,  DiCondition.lPositiveCoefficient,   DI_FFNOMINALMAX);
                    DiCondition.lNegativeCoefficient =  Clamp(-DI_FFNOMINALMAX,  DiCondition.lNegativeCoefficient,   DI_FFNOMINALMAX); 
                    DiCondition.dwPositiveSaturation =  Clip(                    DiCondition.dwPositiveSaturation,   DI_FFNOMINALMAX); 
                    DiCondition.dwNegativeSaturation =  Clip(                    DiCondition.dwNegativeSaturation,   DI_FFNOMINALMAX); 
                    DiCondition.lDeadBand =             Clamp(0,				 DiCondition.lDeadBand,              DI_FFNOMINALMAX);

                    PID_ApplyScalingFactors(ped, &g_Condition, &this->DiSCondScale, cbX(this->DiSCondScale), &this->DiSCondOffset, cbX(this->DiSCondOffset), &DiCondition, cbX(DiCondition) );
                    hres = PID_SendParameterBlock
                           (
                           ped,
                           dwEffectIndex,
                           this->SzPool.uSzCondition,
                           puParameter,
                           &g_Condition,
                           &DiCondition,
                           sizeof(DiCondition),
						   bBlocking,
						   totalBlocks
                           );
                }

				//Conditions can't have envelopes! 
                //So if there's a flag indicating an envelope, take it out.
                dwFlags &= ~(DIEP_ENVELOPE);

                break;
            }

        case PIDMAKEUSAGEDWORD(ET_CUSTOM):
            {
                // Custom Force
                DICUSTOMFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

				// Download Custom Force -- always a blocking call
				hres = PID_DownloadCustomForceData(ped, dwEffectIndex, puParameter, &DiParam, peff);

                if( SUCCEEDED(hres) )
                {
					// Set custom Effect parameter block header -- always a blocking call
					hres = PID_SendParameterBlock
						   (
						   ped,
						   dwEffectIndex, 
						   this->SzPool.uSzCustom,
						   puParameter,
						   &g_Custom,
						   &g_PidCustom,
						   cbX(DiParam),
						   TRUE,
						   totalBlocks
						   );
						   
                }

				break;
            }
        default:
           
            hres = DIERR_PID_USAGENOTFOUND;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL  Unknown parameter block for dwEffectId(0x%x)"),
                            s_tszProc, dwEffectId );

            break;

        }
    }

    if(    SUCCEEDED(hres) 
           && (dwFlags & DIEP_ENVELOPE)  
           && peff->lpEnvelope != NULL )
    {
        DIENVELOPE DiEnv;
        DiEnv = *peff->lpEnvelope;

        //Scale the values
        DiEnv.dwAttackLevel =   Clip(DiEnv.dwAttackLevel,    DI_FFNOMINALMAX);
        DiEnv.dwFadeLevel =     Clip(DiEnv.dwFadeLevel,      DI_FFNOMINALMAX);
        
        PID_ApplyScalingFactors(ped, &g_Envelope, &this->DiSEnvScale, cbX(this->DiSEnvScale), &this->DiSEnvOffset, cbX(this->DiSEnvOffset), &DiEnv, DiEnv.dwSize );

        hres = PID_SendParameterBlock
               (
               ped,
               dwEffectIndex,
               this->SzPool.uSzEnvelope,
               puParameter,
               &g_Envelope,
               &DiEnv,
               DiEnv.dwSize,
			   bBlocking,
			   totalBlocks
               );

    }
    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidrd.c ===
/*****************************************************************************
 *
 *  PidRd.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *
 *
 *  Abstract:
 *
 *      Read input data from PID device .
 *
 *****************************************************************************/

#include "pidpr.h"

#define sqfl    (sqflRead)

BOOL INTERNAL
    PID_IssueRead(PCPidDrv this);

BOOL INTERNAL
    PID_IssueWrite(PCPidDrv this);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPo |
 *
 *          Given an interior pointer to an <t OVERLAPPED>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCPidDrv INLINE
    pCPidDrvFromPo(LPOVERLAPPED po)
{
    return (CPidDrv*) pvSubPvCb(po, FIELD_OFFSET(CPidDrv, o));
}

void CALLBACK
    PID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
    PCPidDrv this = pCPidDrvFromPo(po);

    //EnterProc( PID_ReadComplete, (_"xxx", dwError, cbRead, po ));

    if( !IsBadReadPtr(this, cbX(this))
        &&this->cThreadRef
        && dwError == 0
        //&&( this->o.InternalHigh == this->cbReport[HidP_Input] )
        &&( this->hdevOvrlp != INVALID_HANDLE_VALUE ) )
    {
		HRESULT hres;
		PUCHAR  pReport;
		UINT    cbReport;

		USHORT  LinkCollection = 0x0;
		USAGE   rgUsages[MAX_BUTTONS] ;
		USAGE   UsagePage   =   HID_USAGE_PAGE_PID;
		ULONG   cAUsages    =  MAX_BUTTONS;
		BOOL    fEffectPlaying = FALSE;
		LONG    lEffectIndex;

		pReport  = this->pReport[HidP_Input];
		cbReport = this->cbReport[HidP_Input];
	
		// If the report does not belong to the PID usage page
		// we should be out of here really quick.
		hres = HidP_GetUsages
				   (HidP_Input,
					UsagePage,
					LinkCollection,
					rgUsages,
					&cAUsages,
					this->ppd,
					pReport,
					cbReport
				   );
		if( SUCCEEDED(hres ) )
		{
			UINT indx;
			DWORD dwState =  DIGFFS_ACTUATORSOFF | DIGFFS_USERFFSWITCHOFF | DIGFFS_POWEROFF | DIGFFS_SAFETYSWITCHOFF;
			for(indx = 0x0; indx < cAUsages; indx++ )
			{
				USAGE Usage = rgUsages[indx];
				switch(Usage)
				{
				case HID_USAGE_PID_EFFECT_PLAYING:
					fEffectPlaying = TRUE;
					break;
				case  HID_USAGE_PID_DEVICE_PAUSED:
					dwState |= DIGFFS_PAUSED;
					break;
				case  HID_USAGE_PID_ACTUATORS_ENABLED:
					dwState |= DIGFFS_ACTUATORSON;
					dwState &= ~(DIGFFS_ACTUATORSOFF);
					break;
				case  HID_USAGE_PID_ACTUATOR_OVERRIDE_SWITCH:
					dwState |= DIGFFS_USERFFSWITCHON;
					dwState &= ~(DIGFFS_USERFFSWITCHOFF);
					break;
				case  HID_USAGE_PID_SAFETY_SWITCH:
					dwState |= DIGFFS_SAFETYSWITCHON;
					dwState &= ~(DIGFFS_SAFETYSWITCHOFF);
					break;
				case  HID_USAGE_PID_ACTUATOR_POWER:
					dwState |= DIGFFS_POWERON;
					dwState &= ~(DIGFFS_POWEROFF);
					break;
				default:
					SquirtSqflPtszV(sqfl | sqflVerbose,
										TEXT("%s: Unsupported input status usage (%x,%x:%s) "),
										TEXT("PID_ReadComplete"),
										UsagePage, Usage,
										PIDUSAGETXT(UsagePage,Usage) );

					break;
				}

				this->dwState = dwState;
			}

			hres = PID_ParseReport(
									  &this->ed,
									  &g_BlockIndexIN,
									  LinkCollection,
									  &lEffectIndex,
									  cbX(lEffectIndex),
									  pReport,
									  cbReport
									  );

			if( SUCCEEDED(hres) )
			{
				PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,lEffectIndex);

				if(fEffectPlaying)
				{
					pEffectState->lEfState |= DIEGES_PLAYING;
				} else
				{
					pEffectState->lEfState &= ~(DIEGES_PLAYING);
				}
			}
		}

        // Issue another read
        PID_IssueRead(this);
    } else
    {
        // Boo!
    }
    //ExitProc();
}


BOOL INTERNAL
    PID_IssueRead(PCPidDrv this)
{
    BOOL fRc = FALSE;

    if(  !IsBadReadPtr(this, cbX(this))
       && this->cThreadRef )
    {
        fRc = ReadFileEx(this->hdevOvrlp, this->pReport[HidP_Input],
                         this->cbReport[HidP_Input], &this->o,
                         PID_ReadComplete);
        if (fRc == FALSE)
		{
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("FAIL ReadFileEx"));
        }
    }
	else
	{
		RPF(TEXT("Bad this pointer or thread ref count!"));
	}
    return fRc;
}


void CALLBACK
    PID_WriteComplete(DWORD dwError, DWORD cbWritten, LPOVERLAPPED po)
{
    PCPidDrv this = pCPidDrvFromPo(po);

    //EnterProc( PID_ReadComplete, (_"xxx", dwError, cbRead, po ));

    if( !IsBadReadPtr(this, cbX(this))
        &&(this->cThreadRef)
        //&&( this->o.InternalHigh == this->cbWriteReport[this->blockNr] )
		&&(this->hWriteComplete)
		&&(this->hWrite)
        &&( this->hdevOvrlp != INVALID_HANDLE_VALUE ) )
    {
		//if we didn't get an error & wrote everything -- or if we already tried
		//twice -- we move on
		if ( ((dwError == 0) && (cbWritten == this->cbWriteReport [this->blockNr]))
			|| (this->dwWriteAttempt != 0)
			)
		{
			//print a message if couldn't write a particular block
			if ((dwError != 0) || (cbWritten != this->cbWriteReport [this->blockNr]))
			{
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Couldn't write block %u after two tries, giving up on this block."), 
                    this->blockNr);
			}
			//move on
			this->dwWriteAttempt = 0;
			this->blockNr++;
			if (this->blockNr < this->totalBlocks)
			{
				//write the next block
				if (PID_IssueWrite(this) == FALSE)
				{
					//in case of failure, the callback will never be called and the completion event never set,
					//so need to set it here.
					SetEvent(this->hWriteComplete);
				}
			}
			else
			{
				//we are done w/ this update
				AssertF(this->blockNr == this->totalBlocks);
				SetEvent(this->hWriteComplete);
			}
		}
		else
		{
			//this is the first time we tried to write a particular block, and we failed;
			//we will try once more
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Couldn't write block %u on first attempt, retrying."), 
                this->blockNr);
			this->dwWriteAttempt = 1;
			if (PID_IssueWrite(this) == FALSE)
			{
				//in case of failure, the callback will never be called and the completion event never set,
				//so need to set it here.
				this->dwWriteAttempt = 0;
				SetEvent(this->hWriteComplete);
			}
		}
    } else
    {
        //need to set the completion event, otherwise we will keep waiting...
		RPF(TEXT("Bad this pointer or thread ref count or handle!"));
		this->dwWriteAttempt = 0;
		SetEvent(this->hWriteComplete);
    }
    //ExitProc();
}


BOOL INTERNAL
    PID_IssueWrite(PCPidDrv this)
{
    BOOL fRc = FALSE;
	
    if(  !IsBadReadPtr(this, cbX(this))
       && this->cThreadRef )
    {
        fRc = WriteFileEx(this->hdevOvrlp, this->pWriteReport[this->blockNr],
                         this->cbWriteReport[this->blockNr], &this->o,
                         PID_WriteComplete);
		if (fRc == FALSE)
		{
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("FAIL WriteFileEx"));
        }
    }
	else
	{
		RPF(TEXT("Bad this pointer or thread ref count!"));
	}
    return fRc;
}

VOID INTERNAL
    PID_ThreadProc(CPidDrv* this)
{
    MSG msg;

    EnterProc( PID_ThreadProc, (_"x", this ));
    AssertF(this->hdevOvrlp == INVALID_HANDLE_VALUE );

    this->hdevOvrlp = CreateFile(this->tszDeviceInterface,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 0,                      /* no SECURITY_ATTRIBUTES */
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,   /* attributes */
                                 0);                     /* template */


    if( this->hdevOvrlp == INVALID_HANDLE_VALUE )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL CreateFile(OverLapped)"),
                        s_tszProc );
    }
	else
	//fix for mb 35282 -- no use calling PID_IssueRead() w/ an INVALID_HANDLE_VALUE for a file handle
	{

		if( PID_IssueRead(this) )
		{
			do
			{
				DWORD dwRc;
				do
				{
					AssertF(this->hWrite != 0x0);
					AssertF(this->hWriteComplete != 0x0);

					dwRc = MsgWaitForMultipleObjectsEx(1, &this->hWrite, INFINITE, QS_ALLINPUT,
													   MWMO_ALERTABLE);

					if (dwRc == WAIT_OBJECT_0)
					{
						if (PID_IssueWrite(this) == FALSE)
						{
							//in case of failure, the callback will never be called and the completion event never set,
							//so need to set it here.
							SetEvent(this->hWriteComplete);
						}
					}

				} while ((dwRc == WAIT_IO_COMPLETION) || (dwRc == WAIT_OBJECT_0));

				while(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}

			} while(this->cThreadRef);

			if( this->hdevOvrlp != INVALID_HANDLE_VALUE )
			{
				HANDLE hdev;
				hdev = this->hdevOvrlp;
                                this->hdevOvrlp = INVALID_HANDLE_VALUE;
				CancelIo_(hdev);
				Sleep(0);
				CloseHandle(hdev);
			}
		}
	}

	//close the event handles as well
	if (this->hWrite != 0x0)
	{
		CloseHandle(this->hWrite);
		this->hWrite = 0x0;
	}
	if (this->hWriteComplete != 0x0)
	{
		CloseHandle(this->hWriteComplete);
		this->hWriteComplete = 0x0;
	}

    if(this->hThread)
    {
        HANDLE hdev = this->hThread;
        this->hThread = NULL;
        CloseHandle(hdev);
    }


    FreeLibraryAndExitThread(g_hinst, 0);
    ExitProc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\usgtxt.c ===
/*****************************************************************************
 *
 *  UsgTxt.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      PID usages strings for help with debugging.
 *
 *****************************************************************************/
#include "pidpr.h"

#ifdef DEBUG

void PID_CreateUsgTxt()
{
    g_rgUsageTxt[0x01]=    TEXT("Physical Interface Device");

    g_rgUsageTxt[0x20]=    TEXT("Normal");
    g_rgUsageTxt[0x21]=    TEXT("Set Effect Report");
    g_rgUsageTxt[0x22]=    TEXT("Effect Block Index");
    g_rgUsageTxt[0x23]=    TEXT("Parameter Block Offset");
    g_rgUsageTxt[0x24]=    TEXT("ROM Flag");
    g_rgUsageTxt[0x25]=    TEXT("Effect Type");
    g_rgUsageTxt[0x26]=    TEXT("ET Constant Force");
    g_rgUsageTxt[0x27]=    TEXT("ET Ramp");
    g_rgUsageTxt[0x28]=    TEXT("ET Custom Force Data");


    g_rgUsageTxt[0x30]=    TEXT("ET Square");
    g_rgUsageTxt[0x31]=    TEXT("ET Sine");
    g_rgUsageTxt[0x32]=    TEXT("ET Triangle");
    g_rgUsageTxt[0x33]=    TEXT("ET SawTooth Up");
    g_rgUsageTxt[0x34]=    TEXT("ET SawTooth Down");

    g_rgUsageTxt[0x40]=    TEXT("ET Spring");
    g_rgUsageTxt[0x41]=    TEXT("ET Damper");
    g_rgUsageTxt[0x42]=    TEXT("ET Inertia");
    g_rgUsageTxt[0x43]=    TEXT("ET Friction");

    g_rgUsageTxt[0x50]=    TEXT("Duration");
    g_rgUsageTxt[0x51]=    TEXT("Sample Period");
    g_rgUsageTxt[0x52]=    TEXT("Gain");
    g_rgUsageTxt[0x53]=    TEXT("Trigger Button");
    g_rgUsageTxt[0x54]=    TEXT("Trigger Repeat Interval");
    g_rgUsageTxt[0x55]=    TEXT("Axes Enable");
    g_rgUsageTxt[0x56]=    TEXT("Direction Enable");
    g_rgUsageTxt[0x57]=    TEXT("Direction");
    g_rgUsageTxt[0x58]=    TEXT("Type Specific Block Offset");
    g_rgUsageTxt[0x59]=    TEXT("Block Type");
    g_rgUsageTxt[0x5A]=    TEXT("Set Envelope Report");
    g_rgUsageTxt[0x5B]=    TEXT("Attack Level");
    g_rgUsageTxt[0x5C]=    TEXT("Attack Time");
    g_rgUsageTxt[0x5D]=    TEXT("Fade Level");
    g_rgUsageTxt[0x5E]=    TEXT("Fade Time");
    g_rgUsageTxt[0x5F]=    TEXT("Set Condition Report");

    g_rgUsageTxt[0x60]=    TEXT("CP Offset");
    g_rgUsageTxt[0x61]=    TEXT("Positive Coefficient");
    g_rgUsageTxt[0x62]=    TEXT("Negative Coefficient");
    g_rgUsageTxt[0x63]=    TEXT("Positive Saturation");
    g_rgUsageTxt[0x64]=    TEXT("Negative Saturation");
    g_rgUsageTxt[0x65]=    TEXT("Dead Band");
    g_rgUsageTxt[0x66]=    TEXT("Download Force Sample");
    g_rgUsageTxt[0x67]=    TEXT("Isoch Custom Force Enable");
    g_rgUsageTxt[0x68]=    TEXT("Custom Force Data Report");
    g_rgUsageTxt[0x69]=    TEXT("Custom Force Data");
    g_rgUsageTxt[0x6A]=    TEXT("Custom Force Vendor Defined Data");
    g_rgUsageTxt[0x6B]=    TEXT("Set Custom Force Report");
    g_rgUsageTxt[0x6C]=    TEXT("Custom Force Data Offset");
    g_rgUsageTxt[0x6D]=    TEXT("Sample Count");
    g_rgUsageTxt[0x6E]=    TEXT("Set Periodic Report");
    g_rgUsageTxt[0x6F]=    TEXT("Offset");

    g_rgUsageTxt[0x70]=    TEXT("Magnitude");
    g_rgUsageTxt[0x71]=    TEXT("Phase");
    g_rgUsageTxt[0x72]=    TEXT("Period");
    g_rgUsageTxt[0x73]=    TEXT("Set Constant Force Report");
    g_rgUsageTxt[0x74]=    TEXT("Set Ramp Force Report");
    g_rgUsageTxt[0x75]=    TEXT("Ramp Start");
    g_rgUsageTxt[0x76]=    TEXT("Ramp End");
    g_rgUsageTxt[0x77]=    TEXT("Effect Operation Report");
    g_rgUsageTxt[0x78]=    TEXT("Effect Operation");
    g_rgUsageTxt[0x79]=    TEXT("Op Effect Start");
    g_rgUsageTxt[0x7A]=    TEXT("Op Effect Start Solo");
    g_rgUsageTxt[0x7B]=    TEXT("Op Effect Stop");
    g_rgUsageTxt[0x7C]=    TEXT("Loop Count");
    g_rgUsageTxt[0x7D]=    TEXT("Device Gain Report");
    g_rgUsageTxt[0x7E]=    TEXT("Device Gain");
    g_rgUsageTxt[0x7F]=    TEXT("PID Pool Report");

    g_rgUsageTxt[0x80]=    TEXT("RAM Pool Size");
    g_rgUsageTxt[0x81]=    TEXT("ROM Pool Size");
    g_rgUsageTxt[0x82]=    TEXT("ROM Effect Block Count");
    g_rgUsageTxt[0x83]=    TEXT("Simultaneous Effects Max");
    g_rgUsageTxt[0x84]=    TEXT("Pool Alignment");
    g_rgUsageTxt[0x85]=    TEXT("PID Pool Move Report");
    g_rgUsageTxt[0x86]=    TEXT("Move Source");
    g_rgUsageTxt[0x87]=    TEXT("Move Destination");
    g_rgUsageTxt[0x88]=    TEXT("Move Length");
    g_rgUsageTxt[0x89]=    TEXT("PID Block Load Report");
    g_rgUsageTxt[0x8A]=    TEXT("Handshake Key");
    g_rgUsageTxt[0x8B]=    TEXT("Block Load Status");
    g_rgUsageTxt[0x8C]=    TEXT("Block Load Success");
    g_rgUsageTxt[0x8D]=    TEXT("Block Load Full");
    g_rgUsageTxt[0x8E]=    TEXT("Blodk Load Error");
    g_rgUsageTxt[0x8F]=    TEXT("Block Handle");

    g_rgUsageTxt[0x90]=    TEXT("PID Block Free Report");
    g_rgUsageTxt[0x91]=    TEXT("Type Specific Block Handle");
    g_rgUsageTxt[0x92]=    TEXT("PID State Report");
    g_rgUsageTxt[0x93]=    TEXT("PID Effect State");
    g_rgUsageTxt[0x94]=    TEXT("ES Playing");
    g_rgUsageTxt[0x95]=    TEXT("ES Stopped");
    g_rgUsageTxt[0x96]=    TEXT("PID Device Control");
    g_rgUsageTxt[0x97]=    TEXT("DC Enable Actuators");
    g_rgUsageTxt[0x98]=    TEXT("DC Disable Actuators");
    g_rgUsageTxt[0x99]=    TEXT("DC Stop All Effects");
    g_rgUsageTxt[0x9A]=    TEXT("DC Device Reset");
    g_rgUsageTxt[0x9B]=    TEXT("DV Device Pause");
    g_rgUsageTxt[0x9C]=    TEXT("DC Device Continue");
    g_rgUsageTxt[0x9D]=    TEXT("Device State");

    g_rgUsageTxt[0x9F]=    TEXT("Device Paused");

    g_rgUsageTxt[0xA0]=    TEXT("Actuators Enabled");
    g_rgUsageTxt[0xA4]=    TEXT("Safety Switch");
    g_rgUsageTxt[0xA5]=    TEXT("Actuator Override Switch");
    g_rgUsageTxt[0xA6]=    TEXT("Actuator Power");
    g_rgUsageTxt[0xA7]=    TEXT("Start Delay");
    g_rgUsageTxt[0xA8]=    TEXT("Parameter Block Size");
    g_rgUsageTxt[0xA9]=    TEXT("Device Managed Pool");
    g_rgUsageTxt[0xAA]=    TEXT("Shared Parameter Blocks");
    g_rgUsageTxt[0xAB]=    TEXT("Create New Effect Report");
    g_rgUsageTxt[0xAC]=    TEXT("RAM pool avaliable");

    CAssertF( 0xAC == PIDUSAGETXT_MAX);
    
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidreg.c ===
/*****************************************************************************
 *
 *  PidReg.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Update registry information for PID device.
 *
 *****************************************************************************/

#include "pidpr.h"

#define sqfl            ( sqflReg )

#pragma BEGIN_CONST_DATA
/*
;---------------------------------------
;
;   Force feedback registry settings for GUID_Sine.
;
;   GUID_Sine is a predefined GUID; applications which want
;   to use a sine effect independent of hardware will
;   request a GUID_Sine.
;
;   The default value is the friendly name for the effect.
;
HKLM,%KEY_OEM%\XYZZY.FFDrv1\OEMForceFeedback\Effects\%GUID_Sine%,,,"%Sine.Desc%"
;
;   The Attributes value contains a DIEFFECTATTRIBUTES structure.
;
;   The effect ID is the number that is passed by DirectInput to the
;   effect driver to identify the effect (thereby saving the effect
;   driver the trouble of parsing GUIDs all the time).
;
;   Our effect is a periodic effect whose optional envelope
;   supports attack and fade.
;
;   Our hardware supports changing the following parameters when
;   the effect is not playing (static): Duration, gain, trigger button,
;   axes, direction, envelope, type-specific parameters.  We do not
;   support sample period or trigger repeat interval.
;
;   Our hardware does not support changing any parameters while an
;   effect is playing (dynamic).
;
;   Our hardware prefers receiving multiple-axis direction information
;   in polar coordinates.
;
;   dwEffectId      = EFFECT_SINE
;                   = 723               = D3,02,00,00
;   dwEffType       = DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY
;                   = 0x00000603        = 03,06,00,00
;   dwStaticParams  = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON |
;                     DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE |
;                     DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY
;                   = 0x000001ED        = ED,01,00,00
;   dwDynamicParams = 0x00000000        = 00,00,00,00
;   dwCoords        = DIEFF_POLAR
;                   = 0x00000020        = 20,00,00,00
*/
static EFFECTMAPINFO g_EffectMapInfo[] =
{
    {
        PIDMAKEUSAGEDWORD(ET_CONSTANT),
        DIEFT_CONSTANTFORCE | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_ConstantForce,
        TEXT("GUID_ConstantForce"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_RAMP),
        DIEFT_RAMPFORCE | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_RampForce,
        TEXT("GUID_RampForce"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SQUARE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Square,
        TEXT("GUID_Square"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SINE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Sine,
        TEXT("GUID_Sine"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_TRIANGLE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Triangle,
        TEXT("GUID_Triangle"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SAWTOOTH_UP),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_SawtoothUp,
        TEXT("GUID_SawtoothUp"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SAWTOOTH_DOWN),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_SawtoothDown,
        TEXT("GUID_SawtoothDown"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SPRING),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Spring,
        TEXT("GUID_Spring"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_DAMPER),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Damper,
        TEXT("GUID_Damper"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_INERTIA),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Inertia,
        TEXT("GUID_Inertia"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_FRICTION),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Friction,
        TEXT("GUID_Friction"),
    },


    {
        PIDMAKEUSAGEDWORD(ET_CUSTOM),
        DIEFT_CUSTOMFORCE | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_CustomForce,
        TEXT("GUID_CustomForce"),
    },
};


static PIDSUPPORT g_DIeft[] =
{
    {DIEFT_CONSTANTFORCE,           PIDMAKEUSAGEDWORD(SET_CONSTANT_FORCE_REPORT),   HID_COLLECTION, 0x0},
    {DIEFT_RAMPFORCE,               PIDMAKEUSAGEDWORD(SET_RAMP_FORCE_REPORT),       HID_COLLECTION, 0x0},
    {DIEFT_PERIODIC,                PIDMAKEUSAGEDWORD(SET_PERIODIC_REPORT),         HID_COLLECTION, 0x0},
    {DIEFT_CONDITION,               PIDMAKEUSAGEDWORD(SET_CONDITION_REPORT),        HID_COLLECTION, 0x0},
    {DIEFT_CUSTOMFORCE,             PIDMAKEUSAGEDWORD(SET_CUSTOM_FORCE_REPORT),     HID_COLLECTION, 0x0},
    //{DIEFT_HARDWARE,              ????                                                   },
    {DIEFT_FFATTACK,                PIDMAKEUSAGEDWORD(ATTACK_LEVEL),                HID_VALUE,      HidP_Output},
    {DIEFT_FFFADE,                  PIDMAKEUSAGEDWORD(FADE_LEVEL),                  HID_VALUE,      HidP_Output},
    {DIEFT_SATURATION,              PIDMAKEUSAGEDWORD(POSITIVE_SATURATION),         HID_VALUE,      HidP_Output},
    {DIEFT_POSNEGCOEFFICIENTS,      PIDMAKEUSAGEDWORD(NEGATIVE_COEFFICIENT),        HID_VALUE,      HidP_Output},
    {DIEFT_POSNEGSATURATION,        PIDMAKEUSAGEDWORD(NEGATIVE_SATURATION),         HID_VALUE,      HidP_Output},
    {DIEFT_DEADBAND,                PIDMAKEUSAGEDWORD(DEAD_BAND),                   HID_VALUE,      HidP_Output},
#if DIRECTINPUT_VERSION  >= 0x600
    {DIEFT_STARTDELAY,              PIDMAKEUSAGEDWORD(START_DELAY),                 HID_VALUE,      HidP_Output},
#endif
};


static PIDSUPPORT g_DIep[] =
{
    {DIEP_DURATION,                 PIDMAKEUSAGEDWORD(DURATION),                    HID_VALUE,      HidP_Output},
    {DIEP_SAMPLEPERIOD,             PIDMAKEUSAGEDWORD(SAMPLE_PERIOD),               HID_VALUE,      HidP_Output},
    {DIEP_GAIN,                     PIDMAKEUSAGEDWORD(GAIN),                        HID_VALUE,      HidP_Output},
    {DIEP_TRIGGERBUTTON,            PIDMAKEUSAGEDWORD(TRIGGER_BUTTON),              HID_VALUE,      HidP_Output},
    {DIEP_TRIGGERREPEATINTERVAL,    PIDMAKEUSAGEDWORD(TRIGGER_REPEAT_INTERVAL),     HID_VALUE,      HidP_Output},
    {DIEP_AXES,                     PIDMAKEUSAGEDWORD(AXES_ENABLE),                 HID_COLLECTION, 0x0},
    {DIEP_DIRECTION,                PIDMAKEUSAGEDWORD(DIRECTION),                   HID_COLLECTION, 0x0},
    {DIEP_ENVELOPE,                 PIDMAKEUSAGEDWORD(SET_ENVELOPE_REPORT),         HID_COLLECTION, 0x0},
#if DIRECTINPUT_VERSION  >= 0x600
    {DIEP_STARTDELAY,              PIDMAKEUSAGEDWORD(START_DELAY),                 HID_VALUE,      HidP_Output},
#endif
};


static PIDSUPPORT g_DIeff[] =
{
    {DIEFF_POLAR,                 PIDMAKEUSAGEDWORD(DIRECTION_ENABLE),         HID_BUTTON,   HidP_Output},
// PID devices do not support Cartesian
//    {DIEFF_ CARTESIAN,             PIDMAKEUSAGEDWORD(AXES_ENABLE),              HID_COLLECTION,0x0},
};

#pragma END_CONST_DATA

//our own version of KEY_ALL_ACCESS, that does not use WRITE_DAC and WRITE_OWNER (see Whistler bug 318865, 370734)
#define DI_DAC_OWNER (WRITE_DAC | WRITE_OWNER)
#define DI_KEY_ALL_ACCESS (KEY_ALL_ACCESS & ~DI_DAC_OWNER) 
// we need to know on which OS we're running, to to have appropriate reg key permissions (see Whistler bug  318865, 370734)
#define WIN_UNKNOWN_OS 0
#define WIN95_OS       1
#define WIN98_OS       2
#define WINME_OS       3
#define WINNT_OS       4
#define WINWH_OS       5


STDMETHODIMP
    PID_Support
    (
    IDirectInputEffectDriver *ped,
    UINT        cAPidSupport,
    PPIDSUPPORT rgPidSupport,
    PDWORD      pdwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    UINT    indx;
    PPIDSUPPORT pPidSupport;

    EnterProcI(PID_Support, (_"xxxx", ped, cAPidSupport, rgPidSupport, pdwFlags));

    hres = S_OK;
    for( indx = 0x0, pPidSupport = rgPidSupport;
       indx < cAPidSupport;
       indx++, pPidSupport++
       )
    {

        USAGE   Usage = DIGETUSAGE(pPidSupport->dwPidUsage);
        USAGE   UsagePage = DIGETUSAGEPAGE(pPidSupport->dwPidUsage);

        if( pPidSupport->Type == HID_COLLECTION )
        {
            HRESULT hres0;
            USHORT  LinkCollection;
            hres0 = PID_GetLinkCollectionIndex(ped, UsagePage, Usage , 0x0, &LinkCollection);
            if( SUCCEEDED(hres0) )
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL PID_GetCollectionIndex:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, hres0,
                                LinkCollection,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else if( pPidSupport->Type == HID_VALUE   )
        {
            NTSTATUS ntStat;
            HIDP_VALUE_CAPS ValCaps;
            USHORT  cAValCaps = 0x1;

            ntStat = HidP_GetSpecificValueCaps
                     (
                     pPidSupport->HidP_Type,                     //ReportType
                     UsagePage,                                  //UsagePage
                     0x0,                                        //LinkCollection,
                     Usage,                                      //Usage
                     &ValCaps,                                   //ValueCaps,
                     &cAValCaps,                                 //ValueCapsLength,
                     this->ppd                                   //Preparsed Data
                     );

            if(    SUCCEEDED(ntStat )
                   || ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpValCaps:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat,
                                0x0,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else if( pPidSupport->Type == HID_BUTTON )
        {
            NTSTATUS ntStat;
            HIDP_BUTTON_CAPS ButtonCaps;
            USHORT    cAButtonCaps = 0x1;

            ntStat = HidP_GetSpecificButtonCaps
                     (
                     pPidSupport->HidP_Type,                     //ReportType
                     UsagePage,                                  //UsagePage
                     0x0,                                        //LinkCollection,
                     Usage,                                      //Usage
                     &ButtonCaps,                                //ValueCaps,
                     &cAButtonCaps,                              //ValueCapsLength,
                     this->ppd                                   //Preparsed Data
                     );

            if(    SUCCEEDED(ntStat )
                   || ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;
                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpButtonCaps:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat,
                                0x0,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else
        {
            hres |= DIERR_PID_USAGENOTFOUND;
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | NameFromGUID |
 *
 *          Convert a GUID into an ASCII string that will be used
 *          to name it in the global namespace.
 *
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          Output buffer to receive the converted name.  It must
 *          be <c ctchNameGuid> characters in size.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to convert.
 *
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

/* Note: If you change this string, you need to change ctchNameGuid to match */
TCHAR c_tszNameFormat[] =
    TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

#pragma END_CONST_DATA

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid)
{
    int ctch;

    ctch = wsprintf(ptszBuf, c_tszNameFormat,
                    pguid->Data1, pguid->Data2, pguid->Data3,
                    pguid->Data4[0], pguid->Data4[1],
                    pguid->Data4[2], pguid->Data4[3],
                    pguid->Data4[4], pguid->Data4[5],
                    pguid->Data4[6], pguid->Data4[7]);

    AssertF(ctch == ctchGuid - 1);
}

#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

BOOL INLINE
    IsWriteSam(REGSAM sam)
{
    return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | PID_GetOSVersion |
 *
 *          Return the OS version on which pid.dll is running.
 *          
 *  @returns
 *
 *          WIN95_OS, WIN98_OS, WINME_OS, WINNT_OS, WINWH_OS, or WIN_UNKNOWN_OS.
 *
 *****************************************************************************/

DWORD PID_GetOSVersion()
{
    OSVERSIONINFO osVerInfo;
    DWORD dwVer;

    if( GetVersion() < 0x80000000 ) {
        dwVer = WINNT_OS;
    } else {
        dwVer = WIN95_OS;  //assume Windows 95 for safe
    }

    osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    // If GetVersionEx is supported, then get more details.
    if( GetVersionEx( &osVerInfo ) )
    {
        // Win2K
        if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Whistler: Major = 5 & Build # > 2195
            if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
            {
                dwVer = WINWH_OS;
            } else {
                dwVer = WINNT_OS;
            }
        }
        // Win9X
        else
        {
            if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) ) 
            {
                // WinMe: Major = 4, Minor = 90
                if( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
                {
                    dwVer = WINME_OS;
                } else if ( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) > 0) ) {
                    dwVer = WIN98_OS;
                } else {
                    dwVer = WIN95_OS;
                }
            }
        }
    }

    return dwVer;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;
	BOOL bWinXP = FALSE;


    EnterProc(hresMumbleKeyEx, (_"xsxxx", hk, ptszKey, sam, dwOptions, phk));
    /*
     *  If caller is requesting write access, then create the key.
     *  Else just open it.
     */
    if(IsWriteSam(sam))
    {
		// on WinXP, we strip out WRITE_DAC and WRITE_OWNER bits
		if (PID_GetOSVersion() == WINWH_OS)
		{
			sam &= ~DI_DAC_OWNER;
			bWinXP = TRUE;
		}

        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists
        } else
        {
#ifdef WINNT
            EXPLICIT_ACCESS     ExplicitAccess;
            PACL                pACL;
            DWORD               dwErr;
            SECURITY_DESCRIPTOR SecurityDesc;
            DWORD               dwDisposition;
            SECURITY_ATTRIBUTES sa;
			PSID pSid = NULL;
			SID_IDENTIFIER_AUTHORITY authority = SECURITY_WORLD_SID_AUTHORITY;


            // Describe the access we want to create the key with
            ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
            //set the access depending on the OS (see Whistler bug 318865)
			if (bWinXP == TRUE)
			{
				ExplicitAccess.grfAccessPermissions = DI_KEY_ALL_ACCESS;
			}
			else
			{
				ExplicitAccess.grfAccessPermissions = KEY_ALL_ACCESS;
			}
            ExplicitAccess.grfAccessMode = GRANT_ACCESS;     
            ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

			if (AllocateAndInitializeSid(
						&authority,
						1, 
						SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
						&pSid
						))
			{
				BuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

				dwErr = SetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );


				if( dwErr == ERROR_SUCCESS )
				{
					AssertF( pACL );

					if( InitializeSecurityDescriptor( &SecurityDesc, SECURITY_DESCRIPTOR_REVISION ) )
					{
						if( SetSecurityDescriptorDacl( &SecurityDesc, TRUE, pACL, FALSE ) )
						{
							// Initialize a security attributes structure.
							sa.nLength = sizeof (SECURITY_ATTRIBUTES);
							sa.lpSecurityDescriptor = &SecurityDesc;
							sa.bInheritHandle = TRUE;// Use the security attributes to create a key.

							lRc = RegCreateKeyEx
								  (
								  hk,									// handle of an open key
								  ptszKey,								// address of subkey name
								  0,									// reserved
								  NULL,									// address of class string
								  dwOptions,							// special options flag
								  ExplicitAccess.grfAccessPermissions,	// desired security access
								  &sa,									// address of key security structure
								  phk,									// address of buffer for opened handle
								  &dwDisposition						// address of disposition value buffer);
								  );

						}
						else
						{
							SquirtSqflPtszV( sqflError | sqflReg,
											 TEXT("SetSecurityDescriptorDacl failed lastError=0x%x "),
											 GetLastError());
						}
					}
					else
					{
						SquirtSqflPtszV( sqflError | sqflReg,
										 TEXT("InitializeSecurityDescriptor failed lastError=0x%x "),
										 GetLastError());
					}

					LocalFree( pACL );
				}
				else
				{
					SquirtSqflPtszV( sqflError | sqflReg,
									 TEXT("SetEntriesInACL failed, dwErr=0x%x"), dwErr );
				}
			}
			else
			{
			   SquirtSqflPtszV( sqflError | sqflReg,
				   TEXT("AllocateAndInitializeSid failed"));

			}

			//Cleanup pSid
			if (pSid != NULL)
			{
				FreeSid(pSid);
			}

            if( lRc != ERROR_SUCCESS )
            {
				SquirtSqflPtszV( sqflError,
							TEXT("Failed to create regkey %s with security descriptor, lRc=0x%x "),
							ptszKey, lRc);
            }
#else
            lRc = RegCreateKeyEx(hk, ptszKey, 0, 0,
                                 dwOptions,
                                 sam, 0, phk, 0);
#endif
        }

    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if(lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    ExitOleProc();
    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | PID_CreateFFKeys |
 *
 *          Given a handle to a PID device, create the registry entries to enable
 *          force feedback.
 *
 *  @parm   HANDLE | hdev |
 *
 *          Handle to the PID device.
 *
 *  @parm   HKEY | hkFF |
 *
 *          Force Feedback registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: Couldn't open the key.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_CreateFFKeys
    (
    IDirectInputEffectDriver *ped,
    HKEY        hkFF
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    UINT uEffect;
    HKEY hkEffect;

    EnterProc(PID_CreateFFKey, (_"xx", ped, hkFF));

    hres = hresMumbleKeyEx(hkFF, REGSTR_EFFECTS, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkEffect);

    if( SUCCEEDED(hres) )
    {
        DWORD   dwDIef, dwDIep, dwDIeff;
        dwDIef = dwDIep = dwDIeff = 0x0;

        /*
         * Determine supported flags for effectType and Effect Params
         * based on the PID descriptors
         */
        PID_Support(ped, cA(g_DIeft), g_DIeft,  &dwDIef);
        PID_Support(ped, cA(g_DIep),  g_DIep,   &dwDIep);
        PID_Support(ped, cA(g_DIeff), g_DIeff,  &dwDIeff);

        // All effects support DIEP_TYPESPECIFICPARAMS
        dwDIep |= DIEP_TYPESPECIFICPARAMS;

        for( uEffect = 0x0; uEffect < cA(g_EffectMapInfo); uEffect++ )
        {
            EFFECTMAPINFO   emi = g_EffectMapInfo[uEffect];
            PIDSUPPORT  PidSupport;
            DWORD   dwJunk;
            HRESULT hres0;

            PidSupport.dwPidUsage = emi.attr.dwEffectId;
            PidSupport.Type       = HID_BUTTON;
            PidSupport.HidP_Type  = HidP_Output;

            hres0 = PID_Support(ped, 0x1, &PidSupport, &dwJunk);

            if( SUCCEEDED(hres0) )
            {
                TCHAR tszName[ctchGuid];
                HKEY hk;

                NameFromGUID(tszName, emi.pcguid);

                hres = hresMumbleKeyEx(hkEffect, tszName, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hk);

                if( SUCCEEDED(hres) )
                {
                    LONG lRc;
                    lRc = RegSetValueEx(hk, 0x0, 0x0, REG_SZ, (char*)emi.tszName, lstrlen(emi.tszName) * cbX(emi.tszName[0]));

                    if( lRc == ERROR_SUCCESS )
                    {
                        /*
                         * Modify generic attribute flags depending
                         * on PID firmware descriptors
                         */
                        emi.attr.dwEffType          &= dwDIef;
                        emi.attr.dwStaticParams     &= dwDIep;
                        emi.attr.dwDynamicParams    &= dwDIep;
                        emi.attr.dwCoords           &= dwDIeff;

                        lRc = RegSetValueEx(hk, REGSTR_ATTRIBUTES, 0x0, REG_BINARY, (char*)&emi.attr, cbX(emi.attr) ) ;

                        if( lRc == ERROR_SUCCESS )
                        {

                        } else
                        {
                            hres = REGDB_E_WRITEREGDB;
                        }
                    } else
                    {
                        hres = REGDB_E_WRITEREGDB;
                    }
                    RegCloseKey(hk);
                }
            }
        }
        RegCloseKey(hkEffect);
    }

    ExitOleProc();
    return hres;
}
/*****************************************************************************
 *
 *      PID_InitRegistry
 *
 *      This function updates the registry for a specified device.
 *
 *  LPTSTR  ptszDeviceInterface
 *
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_InitRegistry
    (
    IDirectInputEffectDriver *ped
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    TCHAR tszType[MAX_JOYSTRING];
    HKEY hkFF;

    EnterProc(PID_InitRegistry, (_"x", ped));

    wsprintf(tszType, REGSTR_OEM_FF_TEMPLATE, this->attr.VendorID, this->attr.ProductID);

	//If there is no pid version written, -- or it is less then the "last known good version" (today it is 0x0720), 
	//overwrite the previous key.
    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tszType, KEY_READ, REG_OPTION_NON_VOLATILE, &hkFF );
    if( SUCCEEDED(hres) )
    {
		DWORD dwCreatedBy = 0x0;
		DWORD dwSize = cbX(dwCreatedBy);

		hres = E_FAIL;
		if ((RegQueryValueEx(hkFF, REGSTR_CREATEDBY, 0x0, 0x0, (BYTE*)&dwCreatedBy, &dwSize) == ERROR_SUCCESS) &&
			(dwCreatedBy >= 0x0720))
		{
			hres = S_OK;
		}
		RegCloseKey(hkFF);
    }
	if (FAILED(hres))
    {
		
        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tszType, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkFF);

        if( SUCCEEDED(hres)  )
        {
            hres = PID_CreateFFKeys(ped, hkFF );
            if( SUCCEEDED(hres) )
            {
				DWORD dwCreatedBy = DIRECTINPUT_HEADER_VERSION;
                LONG lRc;
                DWORD dwSize;
                DWORD dwType;

                //DX8a Do not overwrite an existing CLSID as we may have 
                //been loaded by an IHV with their own CLSID.  In DX8, this 
                //was always written causing some IHV drivers to be ignored.
                //Allow long values as a lot of people write strings with 
                //garbage after a null terminated string 
                //For now, DInput won't load such a CLSID but just in case
        		lRc = RegQueryValueEx( hkFF, REGSTR_CLSID, NULL, &dwType, NULL, &dwSize );
                if( ( lRc == ERROR_SUCCESS ) 
                 && ( dwType == REG_SZ )
                 && ( dwSize >= ctchGuid - 1 ) )
                {
#ifdef DEBUG
                    TCHAR tszDbg[MAX_PATH];
                    dwSize = cbX(tszDbg);
        		    if( RegQueryValueEx( hkFF, REGSTR_CLSID, NULL, NULL, (BYTE*)tszDbg, &dwSize ) 
                     || !dwSize )
                    {
                        tszDbg[0] = TEXT('?');
                        tszDbg[1] = TEXT('\0');
                    }
                    SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("RegistryInit: Not overwiting existing CLSID %s"), tszDbg );
#endif
                }
                else
                {
                    TCHAR tszGuid[ctchGuid];

                    NameFromGUID(tszGuid, &IID_IDirectInputPIDDriver);

                    AssertF( lstrlen(tszGuid) * cbX(tszGuid[0]) == cbX(tszGuid) - cbX(tszGuid[0]) );

                    lRc = RegSetValueEx(hkFF, REGSTR_CLSID, 0x0, REG_SZ, (char*)tszGuid, cbX(tszGuid) - cbX(tszGuid[0]));
                    if( lRc == ERROR_SUCCESS )
                    {

                    } else
                    {
                        hres = REGDB_E_WRITEREGDB;
                    }
                }

				//set "CreatedBy" value
				lRc = RegSetValueEx(hkFF, REGSTR_CREATEDBY, 0x0, REG_BINARY, (BYTE*) &dwCreatedBy, cbX(dwCreatedBy));
                if( lRc == ERROR_SUCCESS )
                {

                } else
                {
                    hres = REGDB_E_WRITEREGDB;
                }
            }

            if(SUCCEEDED(hres) )
            {
                DIFFDEVICEATTRIBUTES diff;
                LONG lRc;

                diff.dwFlags = 0x0;
                diff.dwFFSamplePeriod       =
                diff.dwFFMinTimeResolution  = DI_SECONDS;

                lRc = RegSetValueEx(hkFF, REGSTR_ATTRIBUTES, 0x0, REG_BINARY, (char*)&diff, cbX(diff) ) ;
                if(lRc == ERROR_SUCCESS)
                {

                } else
                {
                    hres = REGDB_E_WRITEREGDB;
                }
            }
            RegCloseKey(hkFF);
        }
    }
    ExitOleProc();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk
MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=pid
TARGETTYPE=DYNLINK
TARGETPATH=obj

!ifndef DXROOT
DXROOT=..\..
!endif

INCLUDES=$(INCLUDES); \
         ..\; \
         $(DXROOT)\inc;\

NTTARGETFILES=

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib     \
	   $(SDK_LIB_PATH)\advapi32.lib     \
	   $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\hid.lib          \
           $(SDK_LIB_PATH)\uuid.lib         \

DLLENTRY=DllEntryPoint

LINKER_FLAGS=-SECTION:share,RWS

SOURCES=                \
        ..\pid.rc       \
        ..\assert.c     \
        ..\clsfact.c    \
        ..\dimem.c      \
        ..\effdrv.c     \
        ..\guids.c      \
        ..\main.c       \
        ..\pidHid.c     \
        ..\pidOp.c      \
        ..\pidParam.c   \
        ..\pideff.c     \
        ..\pidinit.c    \
        ..\pidreg.c     \
        ..\pidrd.c      \
        ..\usgtxt.c     \

DLLDEF=..\pid.def

PRECOMPILED_INCLUDE=..\PIDpr.h         

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\test\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	systest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\dinput.c ===
/*--
Copyright (c) 1998. 1999  Microsoft Corporation

Module Name:

    dinput.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/
#define INITGUID
//#define UNICODE
//#define _UNICODE

#include <wdm.h>
#include <ntdef.h>
#include <stdio.h>
#include <tchar.h>
#include <devguid.h>

typedef ULONG DWORD;
typedef void *HWND;

typedef struct DIDEVICEOBJECTDATA_DX3 {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
} DIDEVICEOBJECTDATA_DX3, *LPDIDEVICEOBJECTDATA_DX3;
typedef const DIDEVICEOBJECTDATA_DX3 *LPCDIDEVICEOBJECTDATA_DX;

typedef struct DIDEVICEOBJECTDATA {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
#if(DIRECTINPUT_VERSION >= 0x0701)
    UINT_PTR    uAppData;
#endif /* DIRECTINPUT_VERSION >= 0x0701 */
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIMOUSESTATE2 {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    UCHAR   rgbButtons[8];
} DIMOUSESTATE2, *LPDIMOUSESTATE2;
#define DIMOUSESTATE_INT DIMOUSESTATE2      //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE2  //

#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE2, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE2, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE2, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 3)
#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)

#include "..\\dx8\\dll\\dinputv.h"
#include "dinputs.h"
#include "disysdef.h"

#define DIK_LCONTROL        0x1D
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */

#define PVOIDATOFFSET(buffer, ofs) (*(PVOID*)(((UCHAR*)(buffer)) + (ofs)))
#define ULONGATOFFSET(buffer, ofs) (*(ULONG*)(((UCHAR*)(buffer)) + (ofs)))

#define DI_ExAllocatePool(PoolType, Size) \
	ExAllocatePoolWithTag(PoolType, Size, 'PNID'); \
	ReportError(_T("Allocating %u bytes\n"), Size)

enum DI_DeviceType {DI_DeviceKeyboard, DI_DeviceMouse};

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);
void DI_AddDevice(PDRIVER_OBJECT pDriver);
void DI_RemoveDevice();
NTSTATUS DI_AddToList(PDEVICE_OBJECT pDev);
NTSTATUS DI_RemoveFromList(PDEVICE_OBJECT pDev);
// IOCTL functions
NTSTATUS DI_DestroyInstance(PVXDINSTANCE pVI);
NTSTATUS DI_AcquireInstance(LPDI_DEVINSTANCE pDevInst);
NTSTATUS DI_UnacquireInstance(LPDI_DEVINSTANCE pDevInst);
NTSTATUS DI_SetBufferSize(LPDI_DEVINSTANCE pDevInst, ULONG ulSize);
NTSTATUS DI_SetNotifyHandle(LPDI_DEVINSTANCE pDevInst, PVOID pEvent);
NTSTATUS DI_CreateInstanceHelper(PSYSDEVICEFORMAT pSysDevFormat, void **ppInstanceHandle, enum DI_DeviceType DeviceType);
NTSTATUS DI_CreateKeyboardInstance(PSYSDEVICEFORMAT pSysDevFormat, UCHAR *pbTranslationTable, void **ppInstanceHandle);
NTSTATUS DI_CreateMouseInstance(PSYSDEVICEFORMAT pSysDevFormat, void **ppInstanceHandle);
NTSTATUS DI_SetDataFormat(LPDI_DEVINSTANCE pDevInst, ULONG ulSize, ULONG *pulDataFormat);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, KbdMou_AddDevice)
#pragma alloc_text (PAGE, KbdMou_CreateClose)
#pragma alloc_text (PAGE, KbdMou_IoCtl)
#pragma alloc_text (PAGE, KbdMou_InternIoCtl)
#pragma alloc_text (PAGE, KbdMou_Unload)
#pragma alloc_text (PAGE, KbdMou_DispatchPassThrough)
#pragma alloc_text (PAGE, KbdMou_PnP)
#pragma alloc_text (PAGE, KbdMou_Power)
#pragma alloc_text (PAGE, DI_AddDevice)
#pragma alloc_text (PAGE, DI_RemoveDevice)
#pragma alloc_text (PAGE, DI_AddToList)
#pragma alloc_text (PAGE, DI_RemoveFromList)
#pragma alloc_text (PAGE, DI_DestroyInstance)
#pragma alloc_text (PAGE, DI_AcquireInstance)
#pragma alloc_text (PAGE, DI_UnacquireInstance)
#pragma alloc_text (PAGE, DI_SetBufferSize)
#pragma alloc_text (PAGE, DI_SetNotifyHandle)
#pragma alloc_text (PAGE, DI_CreateInstanceHelper)
#pragma alloc_text (PAGE, DI_CreateKeyboardInstance)
#pragma alloc_text (PAGE, DI_CreateMouseInstance)
#pragma alloc_text (PAGE, DI_SetDataFormat)
#endif

// Globals

BOOLEAN g_bDebugLog = TRUE;
WCHAR g_wszKbdClassGuid[] = L"{4D36E96B-E325-11CE-BFC1-08002BE10318}";
WCHAR g_wszMouClassGuid[] = L"{4D36E96F-E325-11CE-BFC1-08002BE10318}";
PDEVICE_OBJECT g_pUserDevObj = NULL;  // Device that communicates with user mode app (DINPUT)
BOOLEAN g_bKbExclusive = FALSE;  // Whether a device holds exclusive access to keyboard
UNICODE_STRING g_SymbolicName;
WCHAR g_wszSymbolicNameBuffer[260] = L"\\DosDevices\\DINPUT.SYS";  // Buffer used by g_SymbolicName
ULONG g_ulNumOpenedDevices = 0;  // Number of opened devices
DI_DEVINSTANCE *g_pKbdDevInstList = NULL;  // list of keyboard device instances
DI_DEVINSTANCE *g_pMouDevInstList = NULL;  // list of mouse device instances
PDEVICE_OBJECT g_pKbdDevList = NULL;  // A list of PDEVICE_OBJECT for all keyboard devices
PDEVICE_OBJECT g_pMouDevList = NULL;  // A list of PDEVICE_OBJECT for all mouse devices
KEYBOARD_INPUT_DATA g_rgCtrlAltDelSequence[6] =
	{{0, 0x1D, 0, 0, 0},
	 {0, 0x38, 0, 0, 0},
	 {0, 0x53, 0, 0, 0},
	 {0, 0x53, KEY_BREAK, 0, 0},
	 {0, 0x38, KEY_BREAK, 0, 0},
	 {0, 0x1D, KEY_BREAK, 0, 0}};

/*void TRACE(LPCTSTR szFmt, ...)
{
  va_list argptr;
  TCHAR szBuf[1024];
	UNICODE_STRING Unicode;
	ANSI_STRING Ansi;
//	CHAR szAnsi[1024];
//	CHAR *pcPtr = szAnsi;
//	TCHAR *ptcPtr;

	// Print the identation first
//	for (DWORD i = 0; i < s_dwLevels; ++i)
//	{
//		OutputDebugString(_T("  "));
//		if (s_pLogFile)
//			_ftprintf(s_pLogFile, _T("  "));
//	}
	// Then print the content
    va_start(argptr, szFmt);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,szFmt);				// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))	// find each %p
			*(psz+1) = 'x';					// replace %p with %x
	    _vstprintf(szBuf, szDfs, argptr);	// use the local format string
	}
#else
	{
	    _vstprintf(szBuf, szFmt, argptr);
	}
#endif

	// Convert string to ANSI
#ifdef UNICODE
	Unicode.Length = _tcslen(szBuf);
	Unicode.MaximumLength = 1023;
	Unicode.Buffer = szBuf;
	RtlUnicodeStringToAnsiString(&Ansi, &Unicode, TRUE);
	DebugPrint((Ansi.Buffer));
	RtlFreeAnsiString(&Ansi);
#else
	DebugPrint((szBuf));
#endif

//	ptcPtr = szBuf;
//	while (*ptcPtr)
//	{
//		if (*ptcPtr & 0xFF00) DebugPrint(("UNICODE\n"));
//		*pcPtr = *(CHAR*)ptcPtr;
//		++pcPtr;
//		++ptcPtr;
//	}
//	*pcPtr = '\0';

  va_end(argptr);
}
*/
#ifdef DBG
#define TRACE DebugOut
#else
#define TRACE 1 ? 0 :
#endif

void DebugOut(LPTSTR tszDbgMsg)
{
	CHAR szAnsi[260];
	CHAR *pcPtr = szAnsi;
	TCHAR *ptcPtr = tszDbgMsg;
	ANSI_STRING Ansi;
	UNICODE_STRING Unicode;
	NTSTATUS Ret;

	// Convert string to ANSI
#ifdef UNICODE
	Unicode.Length = _tcslen(tszDbgMsg);
	Unicode.MaximumLength = Unicode.Length;
	Unicode.Buffer = tszDbgMsg;
	Ret = RtlUnicodeStringToAnsiString(&Ansi, &Unicode, TRUE);
	if (Ret != STATUS_SUCCESS)
		DebugPrint(("Convertion failed\n"));
	DebugPrint((Ansi.Buffer));
	RtlFreeAnsiString(&Ansi);
#else
	DebugPrint((tszDbgMsg));
#endif

/*	while (*ptcPtr)
	{
		if (*ptcPtr & 0xFF00) DebugPrint(("UNICODE\n"));
		*pcPtr = *(CHAR*)ptcPtr;
		++pcPtr;
		++ptcPtr;
	}
	*pcPtr = '\0';
*/
}

#ifdef DBG
#define ReportError DebugOut1
#else
#define ReportError 1 ? 0 :
#endif

void DebugOut1(LPTSTR tszMsg, long dwCode)
{
	TCHAR tszBuffer[1024];

	if (g_bDebugLog)
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,tszMsg);					// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))		// find each %p
			*(psz+1) = 'x';						// replace %p with %x
		_stprintf(tszBuffer, szDfs, dwCode);	// use the local format string
		TRACE(tszBuffer);
	}
#else
	{
		_stprintf(tszBuffer, tszMsg, dwCode);
		TRACE(tszBuffer);
	}
#endif
}

void UnicodeToAnsi(LPSTR szAnsi, LPWSTR wszUnicode)
{
	CHAR *pcPtr = szAnsi;
	USHORT *pwcPtr = wszUnicode;

	while (*pwcPtr)
	{
		*pcPtr = *(CHAR*)pwcPtr;
		++pcPtr;
		++pwcPtr;
	}
	*pcPtr = '\0';
}

NTSTATUS DI_AddToList(PDEVICE_OBJECT pDev)
{
	PDEVICE_EXTENSION pExt = pDev->DeviceExtension;
	PDEVICE_OBJECT pDevList;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_AddToList(0x%P)\n"), pDev);
	ReportError(_T("DeviceType = 0x%X\n"), pDev->DeviceType);
	switch(pDev->DeviceType)
	{
		case FILE_DEVICE_KEYBOARD:
			pExt->pLink = g_pKbdDevList;
			pExt->pPrevLink = NULL;
			InterlockedExchangePointer(&g_pKbdDevList, pDev);  // Insert ourselves to beginning of list
			if (pExt->pLink)
				InterlockedExchangePointer(&((PDEVICE_EXTENSION)pExt->pLink->DeviceExtension)->pPrevLink, pDev);  // Make the next obj backpoint to us
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			ReportError(_T("g_pKbdDevList = 0x%P\n"), g_pKbdDevList);
			break;

		case FILE_DEVICE_MOUSE:
			pExt->pLink = g_pMouDevList;
			pExt->pPrevLink = NULL;
			InterlockedExchangePointer(&g_pMouDevList, pDev);  // Insert ourselves to beginning of list
			if (pExt->pLink)
				InterlockedExchangePointer(&((PDEVICE_EXTENSION)pExt->pLink->DeviceExtension)->pPrevLink, pDev);  // Make the next obj backpoint to us
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			ReportError(_T("g_pMouDevList = 0x%P\n"), g_pMouDevList);
			break;

	}

	return STATUS_SUCCESS;
}

NTSTATUS DI_RemoveFromList(PDEVICE_OBJECT pDev)
{
	PDEVICE_EXTENSION pExt = pDev->DeviceExtension;

	if (pExt->pLink)
		((PDEVICE_EXTENSION)pExt->pLink->DeviceExtension)->pPrevLink = pExt->pPrevLink;
	if (pExt->pPrevLink)
		((PDEVICE_EXTENSION)pExt->pPrevLink->DeviceExtension)->pLink = pExt->pLink;
	// If we are the first device, make the head pointer point to the next device.
	switch(pDev->DeviceType)
	{
		case FILE_DEVICE_KEYBOARD:
			if (pDev == g_pKbdDevList)
				InterlockedExchangePointer(&g_pKbdDevList, pExt->pLink);
			break;

		case FILE_DEVICE_MOUSE:
			if (pDev == g_pMouDevList)
				InterlockedExchangePointer(&g_pMouDevList, pExt->pLink);
			break;
	}

	return STATUS_SUCCESS;
}

// GetDevInstFromUserVxdInst searches the global device instance list for the instance
// that has the specified user mode Vxd instance, then returns a pointer to the dev instance.
// If none is found, it returns NULL.
LPDI_DEVINSTANCE GetDevInstFromUserVxdInst(PVXDINSTANCE pVIUser)
{
	LPDI_DEVINSTANCE pDevInst = g_pKbdDevInstList;

	// Search through keyboard list
	while (pDevInst)
	{
		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		ReportError(_T("Searching 0x%P\n"), pDevInst);
		if (pDevInst->pVIUser == pVIUser)
			return pDevInst;
		pDevInst = pDevInst->pLink;
	}

	// Not found in keyboard list. Now search through mouse list.
	pDevInst = g_pMouDevInstList;
	while (pDevInst)
	{
		if (pDevInst->pVIUser == pVIUser)
			return pDevInst;
		pDevInst = pDevInst->pLink;
	}

	return NULL;
}


NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
	ULONG i;
	CHAR DriverNameAnsi[260];
	BOOLEAN bDebugLog = g_bDebugLog;

	UNREFERENCED_PARAMETER (RegistryPath);

	g_bDebugLog = TRUE;
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("g_bDebugLog located at 0x%P\n"), &g_bDebugLog);
	g_bDebugLog = bDebugLog;

	// 
	// Fill in all the dispatch entry points with the pass through function
	// and the explicitly fill in the functions we are going to intercept
	// 
	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
		DriverObject->MajorFunction[i] = KbdMou_DispatchPassThrough;
	}

	DriverObject->MajorFunction [IRP_MJ_CREATE] =
	DriverObject->MajorFunction [IRP_MJ_CLOSE] =        KbdMou_CreateClose;
	DriverObject->MajorFunction [IRP_MJ_PNP] =          KbdMou_PnP;
	DriverObject->MajorFunction [IRP_MJ_POWER] =        KbdMou_Power;
	DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
																											KbdMou_InternIoCtl;
	//
	// If you are planning on using this function, you must create another
	// device object to send the requests to.  Please see the considerations 
	// comments for KbdMou_DispatchPassThrough for implementation details.
	//
	DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = KbdMou_IoCtl;

	DriverObject->DriverUnload = KbdMou_Unload;
	DriverObject->DriverExtension->AddDevice = KbdMou_AddDevice;

	UnicodeToAnsi(DriverNameAnsi, DriverObject->DriverName.Buffer);
	TRACE(DriverNameAnsi);

	DI_AddDevice(DriverObject);

	ReportError(_T("First IOCTL = %u\n"), IOCTL_INPUTLOST);
	ReportError(_T("Last IOCTL = %u\n"), IOCTL_JOY_CONFIGCHANGED);

	return STATUS_SUCCESS;
}

NTSTATUS
KbdMou_AddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
	PDEVICE_EXTENSION        devExt;
	IO_ERROR_LOG_PACKET      errorLogEntry;
	PDEVICE_OBJECT           device = NULL;
	NTSTATUS                 status = STATUS_SUCCESS;
	UNICODE_STRING KbdClassGuid;
	UNICODE_STRING MouClassGuid;
	UNICODE_STRING PDOClassGuid;
	WCHAR wszPDOClassGuid[260];
	ULONG ulGuidLength;
	CHAR szSymName[260];

	PAGED_CODE();

	IoGetDeviceProperty(PDO, DevicePropertyClassGuid, sizeof(WCHAR) * 260, wszPDOClassGuid, &ulGuidLength);
	RtlInitUnicodeString(&PDOClassGuid, wszPDOClassGuid);
	RtlInitUnicodeString(&KbdClassGuid, g_wszKbdClassGuid);  // Initialize Keyboard GUID string
	RtlInitUnicodeString(&MouClassGuid, g_wszMouClassGuid);  // Initialize Mouse GUID string

#ifdef DBG
	{
		CHAR szPDOClassGuid[260];
		UnicodeToAnsi(szPDOClassGuid, wszPDOClassGuid);
#ifdef UNICODE
		TRACE(wszPDOClassGuid);
#else
		TRACE(szPDOClassGuid);
#endif
		TRACE(_T("\n"));
	}
#endif

	if (!RtlCompareUnicodeString(&KbdClassGuid, &PDOClassGuid, TRUE))
	{
		// Keyboard device
		TRACE(_T("Adding keyboard device...\n"));
		status = IoCreateDevice(Driver,
														sizeof(DEVICE_EXTENSION),
														NULL,
														FILE_DEVICE_KEYBOARD,
														0,
														FALSE,
														&device
														);
		if (!status)
			device->DeviceType = FILE_DEVICE_KEYBOARD;
	} else
	if (!RtlCompareUnicodeString(&MouClassGuid, &PDOClassGuid, TRUE))
	{
		// Mouse device
		TRACE(_T("Adding mouse device...\n"));
		status = IoCreateDevice(Driver,
														sizeof(DEVICE_EXTENSION),
														NULL,
														FILE_DEVICE_MOUSE,
														0,
														FALSE,
														&device
														);
		if (!status)
			device->DeviceType = FILE_DEVICE_MOUSE;
	} else
	{
		ReportError(_T("IoCreateDevice() failed: 0x%08X\n"), status);
//		return STATUS_SUCCESS;  // This is a device that we don't care about.  Simply return success.
	}

	if (!NT_SUCCESS(status)) {
			return (status);
	}

	RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

	devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
	devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

	ASSERT(devExt->TopOfStack);

	devExt->Self =          device;
	devExt->PDO =           PDO;
	devExt->DeviceState =   PowerDeviceD0;

	devExt->SurpriseRemoved = FALSE;
	devExt->Removed =         FALSE;
	devExt->Started =         FALSE;

	device->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
	device->Flags &= ~DO_DEVICE_INITIALIZING;

	TRACE(_T("AddDevice successful\n"));
	return status;
}

NTSTATUS
KbdMou_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    Generic completion routine that allows the driver to send the irp down the 
    stack, catch it on the way up, and do more processing at the original IRQL.
    
--*/
{
	PKEVENT  event;
	DebugPrint(("KbdMou_Complete()\n"));

	event = (PKEVENT) Context;

	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	//
	// We could switch on the major and minor functions of the IRP to perform
	// different functions, but we know that Context is an event that needs
	// to be set.
	//
	KeSetEvent(event, 0, FALSE);

	//
	// Allows the caller to use the IRP after it is completed
	//
	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KbdMou_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device
    
--*/
{
	PIO_STACK_LOCATION  irpStack;
	NTSTATUS            status;
	PDEVICE_EXTENSION   devExt;

	PAGED_CODE();
	DebugPrint(("KbdMou_CreateClose\n"));

	irpStack = IoGetCurrentIrpStackLocation(Irp);
	devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

	status = Irp->IoStatus.Status;

	switch (irpStack->MajorFunction) {
	case IRP_MJ_CREATE:

		DebugPrint(("IRP_MJ_CREATE\n"));
			if (NULL == devExt->UpperConnectData.ClassService) {
					//
					// No Connection yet.  How can we be enabled?
					//
					if (DeviceObject != g_pUserDevObj)
						status = STATUS_INVALID_DEVICE_STATE;
			}
			else if ( 1 == InterlockedIncrement(&devExt->EnableCount)) {
					//
					// first time enable here
					//
			}
			else {
					//
					// More than one create was sent down
					//
			}

			break;

	case IRP_MJ_CLOSE:
		DebugPrint(("IRP_MJ_CLOSE\n"));

			if (0 == InterlockedDecrement(&devExt->EnableCount)) {
					//
					// successfully closed the device, do any appropriate work here
					//
			}

			break;
	}

	Irp->IoStatus.Status = status;

	//
	// Pass on the create and the close
	//
	return KbdMou_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbdMou_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

    Passes a request on to the lower driver.
     
Considerations:
     
    If you are creating another device object (to communicate with user mode
    via IOCTLs), then this function must act differently based on the intended 
    device object.  If the IRP is being sent to the solitary device object, then
    this function should just complete the IRP (becuase there is no more stack
    locations below it).  If the IRP is being sent to the PnP built stack, then
    the IRP should be passed down the stack. 
    
    These changes must also be propagated to all the other IRP_MJ dispatch
    functions (create, close, cleanup, etc) as well!

--*/
{
// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
//	ReportError(_T("DispatchPassThrough(0x%P)\n"), DeviceObject);
	if (DeviceObject == g_pUserDevObj)
	{
		NTSTATUS status = Irp->IoStatus.Status;
		// Secondary device
//		ReportError(_T("DispatchPassThrough completed with status 0x%08X\n"), Irp->IoStatus.Status);
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return status;  // Must use a local to save the return value as IoCompleteRequest frees the IRP.
	}
	else
	{
		PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

		//
		// Pass the IRP to the target
		//
		IoSkipCurrentIrpStackLocation(Irp);

		return IoCallDriver(((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack, Irp);
	}
}

NTSTATUS
KbdMou_InternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    There are two specific control codes that are of interest:
    
    IOCTL_INTERNAL_KEYBOARD_CONNECT:
        Store the old context and function pointer and replace it with our own.
        This makes life much simpler than intercepting IRPs sent by the RIT and
        modifying them on the way back up.
                                      
    IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
        Add in the necessary function pointers and context values so that we can
        alter how the ps/2 keyboard is initialized.  
                                            
    NOTE:  Handling IOCTL_INTERNAL_I8042_HOOK_KEYBOARD is *NOT* necessary if 
           all you want to do is filter KEYBOARD_INPUT_DATAs.  You can remove
           the handling code and all related device extension fields and 
           functions to conserve space.
                                         
Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
	PIO_STACK_LOCATION              irpStack;
	PDEVICE_EXTENSION               devExt;
	PINTERNAL_I8042_HOOK_KEYBOARD   hookKeyboard;
	PINTERNAL_I8042_HOOK_MOUSE      hookMouse;
	KEVENT                          event;
	PCONNECT_DATA                   connectData;
	NTSTATUS                        status = STATUS_SUCCESS;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("KbdMou_InternIoCtl(0x%P)\n"), DeviceObject);

	devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
	Irp->IoStatus.Information = 0;
	irpStack = IoGetCurrentIrpStackLocation(Irp);

	switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

	//
	// Connect a keyboard class device driver to the port driver.
	//
	case IOCTL_INTERNAL_KEYBOARD_CONNECT:
	case IOCTL_INTERNAL_MOUSE_CONNECT:
		if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_KEYBOARD_CONNECT)
			TRACE(_T("  IOCTL_INTERNAL_KEYBOARD_CONNECT\n"));
		else
			TRACE(_T("  IOCTL_INTERNAL_MOUSE_CONNECT\n"));
			//
			// Only allow one connection.
			//
			if (devExt->UpperConnectData.ClassService != NULL) {
					status = STATUS_SHARING_VIOLATION;
					break;
			}
			else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
							sizeof(CONNECT_DATA)) {
					//
					// invalid buffer
					//
					status = STATUS_INVALID_PARAMETER;
					break;
			}

			//
			// Copy the connection parameters to the device extension.
			//
			connectData = ((PCONNECT_DATA)
					(irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

			devExt->UpperConnectData = *connectData;

			//
			// Hook into the report chain.  Everytime a keyboard packet is reported
			// to the system, Kbd_ServiceCallback will be called
			//
			connectData->ClassDeviceObject = devExt->Self;
			if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_KEYBOARD_CONNECT)
				connectData->ClassService = Kbd_ServiceCallback;
			else
				connectData->ClassService = Mou_ServiceCallback;

			break;

	//
	// Disconnect a keyboard class device driver from the port driver.
	//
	case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:
	case IOCTL_INTERNAL_MOUSE_DISCONNECT:
		if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_KEYBOARD_DISCONNECT)
			TRACE(_T("  IOCTL_INTERNAL_KEYBOARD_DISCONNECT\n"));
		else
			TRACE(_T("  IOCTL_INTERNAL_MOUSE_DISCONNECT\n"));

			//
			// Clear the connection parameters in the device extension.
			//
			// devExt->UpperConnectData.ClassDeviceObject = NULL;
			// devExt->UpperConnectData.ClassService = NULL;

			status = STATUS_NOT_IMPLEMENTED;
			break;

	//
	// Attach this driver to the initialization and byte processing of the 
	// i8042 (ie PS/2) keyboard.  This is only necessary if you want to do PS/2
	// specific functions, otherwise hooking the CONNECT_DATA is sufficient
	//
	case IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
	case IOCTL_INTERNAL_I8042_HOOK_MOUSE:
	{
		ULONG ulCorrectSize;

		if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_I8042_HOOK_KEYBOARD)
			TRACE(_T("  IOCTL_INTERNAL_I8042_HOOK_KEYBOARD\n"));
		else
			TRACE(_T("  IOCTL_INTERNAL_I8042_HOOK_MOUSE\n"));

		if (IOCTL_INTERNAL_I8042_HOOK_KEYBOARD == irpStack->Parameters.DeviceIoControl.IoControlCode)
		{
			// ******* KEYBOARD CASE *******
			TRACE(_T("hook keyboard received!\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(INTERNAL_I8042_HOOK_KEYBOARD))
			{
				TRACE(_T("InternalIoctl error - invalid buffer length\n"));

				status = STATUS_INVALID_PARAMETER;
				break;
			}

			hookKeyboard = (PINTERNAL_I8042_HOOK_KEYBOARD)
					irpStack->Parameters.DeviceIoControl.Type3InputBuffer;
      
			//
			// Enter our own initialization routine and record any Init routine
			// that may be above us.  Repeat for the isr hook
			// 
			devExt->UpperContext = hookKeyboard->Context;

			//
			// replace old Context with our own
			//
			hookKeyboard->Context = (PVOID) DeviceObject;

			if (hookKeyboard->InitializationRoutine) {
					devExt->UpperInitializationRoutine =
							hookKeyboard->InitializationRoutine;
			}
			hookKeyboard->InitializationRoutine =
					(PI8042_KEYBOARD_INITIALIZATION_ROUTINE) 
					Kbd_InitializationRoutine;

			if (hookKeyboard->IsrRoutine) {
					devExt->UpperKbdIsrHook = hookKeyboard->IsrRoutine;
			}
			hookKeyboard->IsrRoutine = (PI8042_KEYBOARD_ISR) Kbd_IsrHook;

			//
			// Store all of the other important stuff
			//
			devExt->IsrWritePort = hookKeyboard->IsrWritePort;
			devExt->QueuePacket = hookKeyboard->QueueKeyboardPacket;
			devExt->CallContext = hookKeyboard->CallContext;
		} else
		{
			// ******* MOUSE CASE *******
			TRACE(_T("hook mouse received!\n"));
      if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(INTERNAL_I8042_HOOK_MOUSE)) {
          //
          // invalid buffer
          //
          status = STATUS_INVALID_PARAMETER;
          break;
      }

      //
      // Copy the connection parameters to the device extension.
      //
      hookMouse = (PINTERNAL_I8042_HOOK_MOUSE)
          (irpStack->Parameters.DeviceIoControl.Type3InputBuffer);

      //
      // Set isr routine and context and record any values from above this driver
      //
      devExt->UpperContext = hookMouse->Context;
      hookMouse->Context = (PVOID) DeviceObject;

      if (hookMouse->IsrRoutine) {
          devExt->UpperMouIsrHook = hookMouse->IsrRoutine;
      }
      hookMouse->IsrRoutine = (PI8042_MOUSE_ISR) Mou_IsrHook;

      //
      // Store all of the other functions we might need in the future
      //
      devExt->IsrWritePort = hookMouse->IsrWritePort;
      devExt->CallContext = hookMouse->CallContext;
      devExt->QueuePacket = hookMouse->QueueMousePacket;
		}

		status = STATUS_SUCCESS;
		break;
	}

	//
	// These internal ioctls are not supported by the new PnP model.
	//
#if 0       // obsolete
	case IOCTL_INTERNAL_KEYBOARD_ENABLE:
	case IOCTL_INTERNAL_KEYBOARD_DISABLE:
	case IOCTL_INTERNAL_MOUSE_ENABLE:
	case IOCTL_INTERNAL_MOUSE_DISABLE:
			status = STATUS_NOT_SUPPORTED;
			break;
#endif  // obsolete

	//
	// Might want to capture these in the future.  For now, then pass them down
	// the stack.  These queries must be successful for the RIT to communicate
	// with the keyboard/mouse.
	//
	case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
	case IOCTL_MOUSE_QUERY_ATTRIBUTES:
	case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
	case IOCTL_KEYBOARD_QUERY_INDICATORS:
	case IOCTL_KEYBOARD_SET_INDICATORS:
	case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
	case IOCTL_KEYBOARD_SET_TYPEMATIC:
			break;
	}

	if (!NT_SUCCESS(status))
	{
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return status;
	}

	return KbdMou_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbdMou_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps 

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
	PDEVICE_EXTENSION           devExt; 
	PIO_STACK_LOCATION          irpStack;
	NTSTATUS                    status = STATUS_SUCCESS;
	KIRQL                       oldIrql;
	KEVENT                      event;        

	PAGED_CODE();
	DebugPrint(("KbdMou_PnP\n"));

	devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
	irpStack = IoGetCurrentIrpStackLocation(Irp);

	switch (irpStack->MinorFunction) {
	case IRP_MN_START_DEVICE: {
		DebugPrint(("IRP_MN_START_DEVICE\n"));

		//
		// The device is starting.
		//
		// We cannot touch the device (send it any non pnp irps) until a
		// start device has been passed down to the lower drivers.
		//
		IoCopyCurrentIrpStackLocationToNext(Irp);
		KeInitializeEvent(&event,
		                  NotificationEvent,
		                  FALSE
		                  );

		IoSetCompletionRoutine(Irp,
		                       (PIO_COMPLETION_ROUTINE) KbdMou_Complete, 
		                       &event,
		                       TRUE,
		                       TRUE,
		                       TRUE); // No need for Cancel

		status = IoCallDriver(devExt->TopOfStack, Irp);

		if (STATUS_PENDING == status) {
			KeWaitForSingleObject(
			                      &event,
			                      Executive, // Waiting for reason of a driver
			                      KernelMode, // Waiting in kernel mode
			                      FALSE, // No allert
			                      NULL); // No timeout
		}

		if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status))
		{
			//
			// As we are successfully now back from our start device
			// we can do work.
			//
			devExt->Started = TRUE;
			devExt->Removed = FALSE;
			devExt->SurpriseRemoved = FALSE;

			// Add ourselves to the global device list
			DI_AddToList(DeviceObject);

			// Enable the interface
//			IoSetDeviceInterfaceState(&g_SymbolicName, TRUE);
		}

		//
		// We must now complete the IRP, since we stopped it in the
		// completetion routine with MORE_PROCESSING_REQUIRED.
		//
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		break;
	}

	case IRP_MN_SURPRISE_REMOVAL:
		DebugPrint(("IRP_MN_SURPRISE_REMOVAL\n"));
			//
			// Same as a remove device, but don't call IoDetach or IoDeleteDevice
			//
			devExt->SurpriseRemoved = TRUE;

			// Remove code here

			// Remove ourselves from the global device list
			DI_RemoveFromList(DeviceObject);

//			IoSetDeviceInterfaceState(&g_SymbolicName, FALSE);  // Enable the interface
//			DI_RemoveDevice();

			IoSkipCurrentIrpStackLocation(Irp);
			status = IoCallDriver(devExt->TopOfStack, Irp);
			break;

	case IRP_MN_REMOVE_DEVICE:
		DebugPrint(("IRP_MN_REMOVE_DEVICE\n"));
    
			devExt->Removed = TRUE;

			// remove code here

			// Remove ourselves from the global device list
			DI_RemoveFromList(DeviceObject);

//			IoSetDeviceInterfaceState(&g_SymbolicName, FALSE);  // Enable the interface
//			DI_RemoveDevice();
		
			IoSkipCurrentIrpStackLocation(Irp);
			IoCallDriver(devExt->TopOfStack, Irp);

			IoDetachDevice(devExt->TopOfStack); 
			IoDeleteDevice(DeviceObject);

			status = STATUS_SUCCESS;
			break;

	case IRP_MN_QUERY_REMOVE_DEVICE:
	case IRP_MN_QUERY_STOP_DEVICE:
	case IRP_MN_CANCEL_REMOVE_DEVICE:
	case IRP_MN_CANCEL_STOP_DEVICE:
	case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
	case IRP_MN_STOP_DEVICE:
	case IRP_MN_QUERY_DEVICE_RELATIONS:
	case IRP_MN_QUERY_INTERFACE:
	case IRP_MN_QUERY_CAPABILITIES:
	case IRP_MN_QUERY_DEVICE_TEXT:
	case IRP_MN_QUERY_RESOURCES:
	case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
	case IRP_MN_READ_CONFIG:
	case IRP_MN_WRITE_CONFIG:
	case IRP_MN_EJECT:
	case IRP_MN_SET_LOCK:
	case IRP_MN_QUERY_ID:
	case IRP_MN_QUERY_PNP_DEVICE_STATE:
	default:
			//
			// Here the filter driver might modify the behavior of these IRPS
			// Please see PlugPlay documentation for use of these IRPs.
			//
			IoSkipCurrentIrpStackLocation(Irp);
			status = IoCallDriver(devExt->TopOfStack, Irp);
			break;
	}

	return status;
}

NTSTATUS
KbdMou_Power(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
	PIO_STACK_LOCATION  irpStack;
	PDEVICE_EXTENSION   devExt;
	POWER_STATE         powerState;
	POWER_STATE_TYPE    powerType;

	PAGED_CODE();
	DebugPrint(("KbdMou_Power\n"));

	devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
	irpStack = IoGetCurrentIrpStackLocation(Irp);

	powerType = irpStack->Parameters.Power.Type;
	powerState = irpStack->Parameters.Power.State;

	switch (irpStack->MinorFunction) {
	case IRP_MN_SET_POWER:
			if (powerType  == DevicePowerState) {
					devExt->DeviceState = powerState.DeviceState;
			}

	case IRP_MN_POWER_SEQUENCE:
	case IRP_MN_WAIT_WAKE:
	case IRP_MN_QUERY_POWER:
	default:
			break;
	}

	PoStartNextPowerIrp(Irp);
	IoSkipCurrentIrpStackLocation(Irp);
	return PoCallDriver(devExt->TopOfStack, Irp);
}

NTSTATUS
Kbd_InitializationRoutine(
    IN PDEVICE_OBJECT                  DeviceObject,    
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    )
/*++

Routine Description:

    This routine gets called after the following has been performed on the kb
    1)  a reset
    2)  set the typematic
    3)  set the LEDs
    
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function
    
Arguments:

    DeviceObject - Context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD
    
    SynchFuncContext - Context to pass when calling Read/WritePort
    
    Read/WritePort - Functions to synchronoulsy read and write to the kb
    
    TurnTranslationOn - If TRUE when this function returns, i8042prt will not
                        turn on translation on the keyboard

Return Value:

    Status is returned.

--*/
{
	PDEVICE_EXTENSION  devExt;
	NTSTATUS            status = STATUS_SUCCESS;
	DebugPrint(("Kbd_InitializationRoutine\n"));

	devExt = DeviceObject->DeviceExtension;

	//
	// Do any interesting processing here.  We just call any other drivers
	// in the chain if they exist.  Make Translation is turned on as well
	//
	if (devExt->UpperInitializationRoutine) {
			status = (*devExt->UpperInitializationRoutine) (
					devExt->UpperContext,
					SynchFuncContext,
					ReadPort,
					WritePort,
					TurnTranslationOn
					);

			if (!NT_SUCCESS(status)) {
					return status;
			}
	}

	*TurnTranslationOn = TRUE;
	return status;
}

BOOLEAN
Kbd_IsrHook(
    PDEVICE_OBJECT         DeviceObject,               
    PKEYBOARD_INPUT_DATA   CurrentInput, 
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    )
/*++

Routine Description:

    This routine gets called at the beginning of processing of the kb interrupt.
    
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function
    
Arguments:

    DeviceObject - Our context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD
    
    CurrentInput - Current input packet being formulated by processing all the
                    interrupts

    CurrentOutput - Current list of bytes being written to the keyboard or the
                    i8042 port.
                    
    StatusByte    - Byte read from I/O port 60 when the interrupt occurred                                            
    
    DataByte      - Byte read from I/O port 64 when the interrupt occurred. 
                    This value can be modified and i8042prt will use this value
                    if ContinueProcessing is TRUE

    ContinueProcessing - If TRUE, i8042prt will proceed with normal processing of
                         the interrupt.  If FALSE, i8042prt will return from the
                         interrupt after this function returns.  Also, if FALSE,
                         it is this functions responsibilityt to report the input
                         packet via the function provided in the hook IOCTL or via
                         queueing a DPC within this driver and calling the
                         service callback function acquired from the connect IOCTL
                                             
Return Value:

    Status is returned.

--*/
{
	PDEVICE_EXTENSION devExt;
	BOOLEAN           retVal = TRUE;

//	ReportError(_T("ISR(0x%02X)\n"), *DataByte);

	devExt = DeviceObject->DeviceExtension;

	if (devExt->UpperKbdIsrHook) {
		retVal = (*devExt->UpperKbdIsrHook) (
			devExt->UpperContext,
			CurrentInput,
			CurrentOutput,
			StatusByte,
			DataByte,
			ContinueProcessing,
			ScanState
			);

		if (!retVal || !(*ContinueProcessing))
			return retVal;
	}

	*ContinueProcessing = TRUE;
	return retVal;
}

BOOLEAN
Mou_IsrHook (
    PDEVICE_OBJECT          DeviceObject, 
    PMOUSE_INPUT_DATA       CurrentInput, 
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  DataByte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
)
/*++

Remarks:
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function

Arguments:

    DeviceObject - Our context passed during IOCTL_INTERNAL_I8042_HOOK_MOUSE
    
    CurrentInput - Current input packet being formulated by processing all the
                    interrupts

    CurrentOutput - Current list of bytes being written to the mouse or the
                    i8042 port.
                    
    StatusByte    - Byte read from I/O port 60 when the interrupt occurred                                            
    
    DataByte      - Byte read from I/O port 64 when the interrupt occurred. 
                    This value can be modified and i8042prt will use this value
                    if ContinueProcessing is TRUE

    ContinueProcessing - If TRUE, i8042prt will proceed with normal processing of
                         the interrupt.  If FALSE, i8042prt will return from the
                         interrupt after this function returns.  Also, if FALSE,
                         it is this functions responsibilityt to report the input
                         packet via the function provided in the hook IOCTL or via
                         queueing a DPC within this driver and calling the
                         service callback function acquired from the connect IOCTL
                                             
Return Value:

    Status is returned.

  --+*/
{
    PDEVICE_EXTENSION   devExt;
    BOOLEAN             retVal = TRUE;

    devExt = DeviceObject->DeviceExtension;

    if (devExt->UpperMouIsrHook) {
        retVal = (*devExt->UpperMouIsrHook) (
            devExt->UpperContext,
            CurrentInput,
            CurrentOutput,
            StatusByte,
            DataByte,
            ContinueProcessing,
            MouseState,
            ResetSubState
            );

        if (!retVal || !(*ContinueProcessing)) {
            return retVal;
        }
    }

    *ContinueProcessing = TRUE;
    return retVal;
}

#define IsDeleteDown() \
	(devExt->arbKbdState[DIK_DELETE] || devExt->arbKbdState[DIK_DECIMAL])
#define IsCtrlDown() \
	(devExt->arbKbdState[DIK_LCONTROL] || devExt->arbKbdState[DIK_RCONTROL])
#define IsAltDown() \
	(devExt->arbKbdState[DIK_LMENU] || devExt->arbKbdState[DIK_RMENU])

VOID
Kbd_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
/*++

Routine Description:

    Called when there are keyboard packets to report to the RIT.  You can do 
    anything you like to the packets.  For instance:
    
    o Drop a packet altogether
    o Mutate the contents of a packet 
    o Insert packets into the stream 
                    
Arguments:

    DeviceObject - Context passed during the connect IOCTL
    
    InputDataStart - First packet to be reported
    
    InputDataEnd - One past the last packet to be reported.  Total number of
                   packets is equal to InputDataEnd - InputDataStart
    
    InputDataConsumed - Set to the total number of packets consumed by the RIT
                        (via the function pointer we replaced in the connect
                        IOCTL)

Return Value:

    Status is returned.

Remark:

	This routine filters out packets with contents as follows:

	It drops packets with MakeCode 0x2A and E0 flag on.
	It drops packets with MakeCode 0x45 that immediately follows an E1 packet.

--*/
{
	PDEVICE_EXTENSION   devExt;
	PKEYBOARD_INPUT_DATA pKid = InputDataStart;
	KEYBOARD_INPUT_DATA CurrPacket;
	BOOLEAN bEatPacket = FALSE;
	static BOOLEAN bE1Set;  // Static flag that indicates whether the previous packet is an E1 packet.
	BOOLEAN bCtrlAltDel = FALSE;  // We set this flag when we detect that Ctrl + Alt + Del is issued.
	LPDI_DEVINSTANCE pInst;
	LARGE_INTEGER TickCount;
	ULONG ulTimeStamp;

	KeQueryTickCount(&TickCount);
	ulTimeStamp = (ULONG)(TickCount.QuadPart * KeQueryTimeIncrement() / 1000000);  // KeQueryIncrement() returns time in nanosecond

	devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

	while (pKid != InputDataEnd)
	{
//		TCHAR tszMsg[255];
//		_stprintf(tszMsg, _T("In callback (%hu:0x%02hX:%s) La La La!\n"), pKid->UnitId, pKid->MakeCode, pKid->Flags & KEY_BREAK ? _T("Up") : _T("Down"));
//		TRACE(tszMsg);

		CurrPacket = *pKid;  // Get our own copy so we don't tamper packets sent to RIT
		// First check if current packet needs to be dropped.  This is true if a previous packet set the E1 flag.
		if (!bE1Set)
		{
			// Check for E1 flag
			if (CurrPacket.Flags & KEY_E1)
			{
				// E1 flag set.  This is a pause key packet.
				CurrPacket.MakeCode = DIK_PAUSE;
				bE1Set = TRUE;  // Set E1 flag to true so the next packet will be dropped.
			} else
			// Check for E0 flag
			if (CurrPacket.Flags & KEY_E0)
			{
				// E0 flag set
				// If MakeCode == 0x2A, drop the packet
				if (CurrPacket.MakeCode == 0x2A)
				{
					++pKid;  // Next packet is to be processed
					continue;
				}
				// Set the high bit of MakeCode then continue as normal.
				CurrPacket.MakeCode |= 0x80;
			}

			// Now CurrPacket.MakeCode contains DIK_ code
			// Check if this is a repeat call
			if (((CurrPacket.Flags & KEY_BREAK) && devExt->arbKbdState[CurrPacket.MakeCode]) ||
					(!(CurrPacket.Flags & KEY_BREAK) && !devExt->arbKbdState[CurrPacket.MakeCode]))
			{
				// Not a repeat interrupt. Continue processing.
//				TCHAR tszMsg[255];
//				_stprintf(tszMsg, _T("Kb(%hu:0x%02hX:%s:0x%X)\n"), CurrPacket.UnitId, CurrPacket.MakeCode, CurrPacket.Flags & KEY_BREAK ? _T("Up") : _T("Down"), (ULONG)CurrPacket.Flags);
//				TRACE(tszMsg);

				// Normal processing
//				ReportError(_T("  DI sees 0x%02X "), CurrPacket.MakeCode);
//				TRACE(CurrPacket.Flags & KEY_BREAK ? _T("Up\n") : _T("Dn\n"));
				devExt->arbKbdState[CurrPacket.MakeCode] = !(CurrPacket.Flags & KEY_BREAK) ? 0x80 : 0x00;  // Record the new state (0x00 if key is up; 0x80 if key is down)

				// Now check if this is a Delete with Ctrl and Alt down.
				if (IsCtrlDown() && IsAltDown() &&
				    (CurrPacket.MakeCode == DIK_DELETE || CurrPacket.MakeCode == DIK_DECIMAL) && !(CurrPacket.Flags & KEY_BREAK))
				{
					// Ctrl + Alt + Delete sequenced started.
					bCtrlAltDel = TRUE;
				}

				// Now put the event to all instances' buffers
				// Note: If an instance has non-exclusive access before another device claims exclusive access, the
				//       first instance should be fed data even though exclusive access is claimed.  However, if yet
				//       another instance tries to claim exclusive access after it's already claimed, the attempt will
				//       fail.  In other words, non-exclusive instances acquired before exclusive access takes effect
				//       will continue to get data, while non-exclusive instances acquired after exclusive access
				//       takes effect will not get data.
				//       What this means is we still have to traverse the list of instances even if an instance has
				//       exclusive access.  Only the SIFL_ACQUIRED flag determines if the instance receives data.

				//
				// Now we iterate thru the instances and do our work.
				//
				pInst = g_pKbdDevInstList;
				while (pInst &&
							 pInst->pVI->fl & VIFL_ACQUIRED)
				{
					// Check for NOWINKEY and CAPTURED flag
					if ((pInst->pVI->fl & VIFL_CAPTURED) ||
					    ((pInst->pVI->fl & VIFL_NOWINKEY) &&
					    (CurrPacket.MakeCode == DIK_LWIN || CurrPacket.MakeCode == DIK_RWIN)))
						bEatPacket = TRUE;

					// Update the instance's state buffer
					((UCHAR*)pInst->pState)[CurrPacket.MakeCode] = devExt->arbKbdState[CurrPacket.MakeCode];
					// Synchronize pTail with user mode version.
					pInst->pTail = pInst->pBuffer + (pInst->pVI->pTail - pInst->pVI->pBuffer);
					// Queue the packet only if the instance is buffered.
					if (pInst->pBuffer &&
							pInst->pTail != pInst->pHead + 1 &&	// full condition
							pInst->pHead != pInst->pTail + pInst->ulBufferSize - 1)  // full condition with wrapping
					{
						ULONG dwOfs = CurrPacket.MakeCode;;

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
//						ReportError(_T("Inst 0x%P  "), pInst);
//						ReportError(_T("pHead at 0x%P  "), &pInst->pHead);
//						ReportError(_T("pHead -> 0x%P\n"), pInst->pHead);
						if (pInst->pExtra)  // If there is a xlat table, use the table to translate scancode to DIK constant
							dwOfs = ((UCHAR*)pInst->pExtra)[dwOfs];
						if (pInst->pulOffsets)  // If there is a data format, use it to translate.
							dwOfs = pInst->pulOffsets[dwOfs];
						pInst->pHead->dwOfs = dwOfs;
						pInst->pHead->dwData = !(CurrPacket.Flags & KEY_BREAK) << 7;  // High bit of low byte is 1 if key is down; 0 if up
						pInst->pHead->dwTimeStamp = ulTimeStamp;
						pInst->pHead->dwSequence = pInst->ulSequence++;
						++pInst->ulEventCount;
						if (++pInst->pVI->pHead, ++pInst->pHead == pInst->pEnd)
						{
							pInst->pVI->pHead = pInst->pVI->pBuffer;
							pInst->pHead = pInst->pBuffer;
						}
// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
//						ReportError(_T("Inst 0x%P now has "), pInst);
//						ReportError(_T("%u events\n"), pInst->ulEventCount);
					}

					// Set the event for this instance if one exists.
					if (pInst->pEvent)
					{
// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
//						ReportError(_T("Setting event 0x%P\n"), pInst->pEvent);
						KeSetEvent(pInst->pEvent, 0, FALSE);
//						TRACE(_T("Event set\n"));
					}

					pInst = pInst->pLink;  // Next instance
				}  // while (instance iterator)
			} else // End of non-repeat packet
			{
				// Repeat packet. We still need to check for NOWINKEY and CAPTURED flag
				pInst = g_pKbdDevInstList;
				while (pInst &&
							 pInst->pVI->fl & VIFL_ACQUIRED)
				{
					// Check for NOWINKEY flag
					if ((pInst->pVI->fl & VIFL_CAPTURED) ||
					    ((pInst->pVI->fl & VIFL_NOWINKEY) &&
					    (CurrPacket.MakeCode == DIK_LWIN || CurrPacket.MakeCode == DIK_RWIN)))
						bEatPacket = TRUE;
					pInst = pInst->pLink;  // Next instance
				}
			}  // End of repeat packet
		} // if (!bE1Set)
		else
			bE1Set = FALSE; // Clear the E1 flag to avoid incorrectly dropping more than one packet.

		++pKid;
	}

	if (!bEatPacket)
		(*(PSERVICE_CALLBACK_ROUTINE)devExt->UpperConnectData.ClassService)(
			devExt->UpperConnectData.ClassDeviceObject,
			InputDataStart,
			InputDataEnd,
			InputDataConsumed);
	else
	{
		// We don't send anything to RIT, but we must send Ctrl + Alt + Delete if issued.
		if (bCtrlAltDel)
		{
			(*(PSERVICE_CALLBACK_ROUTINE)devExt->UpperConnectData.ClassService)(
				devExt->UpperConnectData.ClassDeviceObject,
				g_rgCtrlAltDelSequence,
				g_rgCtrlAltDelSequence + 6,
				InputDataConsumed);
//			// Now reset the state for LCtrl, RCtrl, LAlt, RAlt, Delete, and Decimal because when
//			// issued the sequence to Windows, input is lost and the break code of these keys
//			// were not received by us.
		}
	}
//	ReportError(_T("RIT consumed %u packets\n"), *InputDataConsumed);
	*InputDataConsumed = InputDataEnd - InputDataStart;
}

// AddMouseEvent adds a mouse event to the instance passed to it.  It checks for full condition and
// update the buffer pointers appropriately.
#define AddMouseEvent(pInst, Ofs, Data, TimeStamp) \
	do { \
		/* Queue the packet only if the instance is buffered. */ \
		if (pInst->pBuffer && \
				pInst->pTail != pInst->pHead + 1 &&	/* full condition */ \
				pInst->pHead != pInst->pTail + pInst->ulBufferSize - 1)  /* full condition with wrapping */ \
		{ \
			pInst->pHead->dwOfs = Ofs; \
			pInst->pHead->dwData = Data; \
			pInst->pHead->dwTimeStamp = TimeStamp; \
			pInst->pHead->dwSequence = pInst->ulSequence++; \
			++pInst->ulEventCount; \
			/* Advance head pointer */ \
			if (++pInst->pVI->pHead, ++pInst->pHead == pInst->pEnd) \
			{ \
				pInst->pVI->pHead = pInst->pVI->pBuffer; \
				pInst->pHead = pInst->pBuffer; \
			} \
		} \
	} while (0)


VOID
Mou_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
/*++

Routine Description:

    Called when there are mouse packets to report to the RIT.  You can do 
    anything you like to the packets.  For instance:
    
    o Drop a packet altogether
    o Mutate the contents of a packet 
    o Insert packets into the stream 
                    
Arguments:

    DeviceObject - Context passed during the connect IOCTL
    
    InputDataStart - First packet to be reported
    
    InputDataEnd - One past the last packet to be reported.  Total number of
                   packets is equal to InputDataEnd - InputDataStart
    
    InputDataConsumed - Set to the total number of packets consumed by the RIT
                        (via the function pointer we replaced in the connect
                        IOCTL)

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION   devExt;
		PMOUSE_INPUT_DATA pMid;
		LPDI_DEVINSTANCE pInst;
		LPDIMOUSESTATE_INT pState = &((PDEVICE_EXTENSION)DeviceObject->DeviceExtension)->MouseState;
		LARGE_INTEGER TickCount;
		ULONG ulTimeStamp;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
		KeQueryTickCount(&TickCount);
		ulTimeStamp = (ULONG)(TickCount.QuadPart * KeQueryTimeIncrement() / 1000000);  // KeQueryIncrement() returns time in nanosecond

		pMid = InputDataStart;
		while (pMid != InputDataEnd)
		{
/*			ReportError(_T("%u["), pMid->UnitId);
			ReportError(_T("%d,"), pMid->LastX);
			ReportError(_T("%d]"), pMid->LastY);
			ReportError(_T("%X "), pMid->RawButtons);
			ReportError(_T("%X "), pMid->ButtonData);
			ReportError(_T("%X\n"), pMid->ButtonFlags);*/

			// Update the state of the device object
			pState->lX += pMid->LastX;
			pState->lY += pMid->LastY;
			if (pMid->ButtonFlags & MOUSE_WHEEL)
				pState->lZ += (SHORT)pMid->ButtonData;
			if ((MOUSE_BUTTON_1_DOWN|MOUSE_BUTTON_1_UP) & pMid->ButtonFlags)
				pState->rgbButtons[0] = MOUSE_BUTTON_1_DOWN & pMid->ButtonFlags ? 0x80 : 0;
			if ((MOUSE_BUTTON_2_DOWN|MOUSE_BUTTON_2_UP) & pMid->ButtonFlags)
				pState->rgbButtons[1] = MOUSE_BUTTON_2_DOWN & pMid->ButtonFlags ? 0x80 : 0;
			if ((MOUSE_BUTTON_3_DOWN|MOUSE_BUTTON_3_UP) & pMid->ButtonFlags)
				pState->rgbButtons[2] = MOUSE_BUTTON_3_DOWN & pMid->ButtonFlags ? 0x80 : 0;
			if ((MOUSE_BUTTON_4_DOWN|MOUSE_BUTTON_4_UP) & pMid->ButtonFlags)
				pState->rgbButtons[3] = MOUSE_BUTTON_4_DOWN & pMid->ButtonFlags ? 0x80 : 0;
			if ((MOUSE_BUTTON_5_DOWN|MOUSE_BUTTON_5_UP) & pMid->ButtonFlags)
				pState->rgbButtons[4] = MOUSE_BUTTON_5_DOWN & pMid->ButtonFlags ? 0x80 : 0;

			// Now we inspect the input packet and fill in the instance buffers.
			pInst = g_pMouDevInstList;
			while (pInst && pInst->pVI->fl & VIFL_ACQUIRED)
			{
				// Synchronize pTail with user mode version.
				pInst->pTail = pInst->pBuffer + (pInst->pVI->pTail - pInst->pVI->pBuffer);

				// Queue the axes movement
				if (pMid->LastX)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_X], pState->lX - ((LPDIMOUSESTATE_INT)pInst->pState)->lX, ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->lX = pState->lX;
				}
				if (pMid->LastY)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_Y], pState->lY - ((LPDIMOUSESTATE_INT)pInst->pState)->lY, ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->lY = pState->lY;
				}
				if (pMid->ButtonFlags & MOUSE_WHEEL)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_Z], pState->lZ - ((LPDIMOUSESTATE_INT)pInst->pState)->lZ, ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->lZ = pState->lZ;
				}

				// Queue the button changes
				if ((MOUSE_BUTTON_1_DOWN|MOUSE_BUTTON_1_UP) & pMid->ButtonFlags)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_BUTTON0], pState->rgbButtons[0], ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->rgbButtons[0] = pState->rgbButtons[0];
				}

				if ((MOUSE_BUTTON_2_DOWN|MOUSE_BUTTON_2_UP) & pMid->ButtonFlags)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_BUTTON1], pState->rgbButtons[1], ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->rgbButtons[1] = pState->rgbButtons[1];
				}

				if ((MOUSE_BUTTON_3_DOWN|MOUSE_BUTTON_3_UP) & pMid->ButtonFlags)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_BUTTON2], pState->rgbButtons[2], ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->rgbButtons[2] = pState->rgbButtons[2];
				}

				if ((MOUSE_BUTTON_4_DOWN|MOUSE_BUTTON_4_UP) & pMid->ButtonFlags)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_BUTTON3], pState->rgbButtons[3], ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->rgbButtons[3] = pState->rgbButtons[3];
				}

				if ((MOUSE_BUTTON_5_DOWN|MOUSE_BUTTON_5_UP) & pMid->ButtonFlags)
				{
					AddMouseEvent(pInst, pInst->pulOffsets[DIMOFS_BUTTON4], pState->rgbButtons[4], ulTimeStamp);
					((LPDIMOUSESTATE_INT)pInst->pState)->rgbButtons[4] = pState->rgbButtons[4];
				}

				// Set event if one is given
				if (pInst->pEvent)
					KeSetEvent(pInst->pEvent, 0, FALSE);

				pInst = pInst->pLink;
			}

			++pMid;
		}

    //
    // UpperConnectData must be called at DISPATCH
    //
    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        InputDataConsumed
        );
}

VOID
KbdMou_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
	PAGED_CODE();
	DebugPrint(("KbdMou_Unload\n"));

	DI_RemoveDevice();

	UNREFERENCED_PARAMETER(Driver);

	ASSERT(NULL == Driver->DeviceObject);
}

///////////////////////////////////////////////////////////////
// DINPUT Specific
///////////////////////////////////////////////////////////////

// All IOCTLs that takes an instance handle as input actually takes a pointer to a
// VXDINSTANCE structure.  We then find the corresponding device instance pointer
// by calling GetDevInstFromUserVxdInst.
NTSTATUS
KbdMou_IoCtl(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
	LPDI_DEVINSTANCE hInst = NULL;
	NTSTATUS Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION irpStack;
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("KbdMou_IoCtl(0x%P)\n"), DeviceObject);

	// If this is not the secondary device object, we just pass it down to the next driver.
	if (DeviceObject != g_pUserDevObj)
			return KbdMou_DispatchPassThrough(DeviceObject, Irp);
	irpStack = IoGetCurrentIrpStackLocation(Irp);
	switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_GETVERSION:
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
/*			ReportError(_T("About to write to user buffer at 0x%P\n"), Irp->AssociatedIrp.SystemBuffer);
			ReportError(_T("  Currently 0x%P"), *Irp->AssociatedIrp.SystemBuffer);
			ReportError(_T("  Input Buffer length = %u\n"), irpStack->Parameters.DeviceIoControl.InputBufferLength);
			ReportError(_T("  Output Buffer length = %u\n"), irpStack->Parameters.DeviceIoControl.OutputBufferLength);*/
			*(ULONG*)Irp->AssociatedIrp.SystemBuffer = 0x12345678;
			Irp->IoStatus.Information = sizeof(ULONG);
			TRACE(_T("Written to user buffer.\n"));
			break;

		case IOCTL_DESTROYINSTANCE:
			// Input is a buffer containing a pointer to VXDINSTANCE
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(void*))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			Status = DI_DestroyInstance(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			break;

		case IOCTL_SETDATAFORMAT:
			// Input is a buffer containing the instance handle followed by a DWORD indicating number of elements
			// in the data format, followed by the address of the array of DWORDs defining the data format.
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(void*) + sizeof(ULONG) + sizeof(void*))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!PVOIDATOFFSET(Irp->AssociatedIrp.SystemBuffer, sizeof(PVOID) + sizeof(ULONG)))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			Status = DI_SetDataFormat(hInst,
			                          ULONGATOFFSET(Irp->AssociatedIrp.SystemBuffer, sizeof(PVOID)),
			                          PVOIDATOFFSET(Irp->AssociatedIrp.SystemBuffer, sizeof(PVOID) + sizeof(ULONG)));
			break;

		case IOCTL_ACQUIREINSTANCE:
			// Input is a buffer containing the instance handle
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(void*))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			Status = DI_AcquireInstance(hInst);
			break;

		case IOCTL_UNACQUIREINSTANCE:
			// Input is a buffer containing the instance handle
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(void*))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			Status = DI_UnacquireInstance(hInst);
			break;

		case IOCTL_SETNOTIFYHANDLE:
			// Input is a buffer containing the instance handle followed by an event object.
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			Status = DI_SetNotifyHandle(hInst,
			                            PVOIDATOFFSET(Irp->AssociatedIrp.SystemBuffer, sizeof(PVOID)));
			break;

		case IOCTL_SETBUFFERSIZE:
			// Input is a buffer containing the instance handle followed by the size (DWORD) in element.
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(PVOID) + sizeof(DWORD))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (!*(PVOID*)Irp->AssociatedIrp.SystemBuffer)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			hInst = GetDevInstFromUserVxdInst(*(VXDINSTANCE**)Irp->AssociatedIrp.SystemBuffer);
			if (!hInst)
				{ Status = STATUS_INVALID_PARAMETER; break; }
			DI_SetBufferSize(hInst, *(ULONG*)((UCHAR*)Irp->AssociatedIrp.SystemBuffer + sizeof(PVOID)));
			break;

		case IOCTL_KBD_CREATEINSTANCE:
		case IOCTL_MOUSE_CREATEINSTANCE:
		{
			// Input is a buffer containing a SYSDEVICEFORMAT structure
			void *pInstanceHandle;

			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			if (irpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(SYSDEVICEFORMAT))
				{ Status = STATUS_INVALID_PARAMETER; break; }
			if (irpStack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(void*))
				{ Status = STATUS_INVALID_PARAMETER; break; }

			if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KBD_CREATEINSTANCE)
				Status = DI_CreateKeyboardInstance(Irp->AssociatedIrp.SystemBuffer,
				                                   ((PSYSDEVICEFORMAT)Irp->AssociatedIrp.SystemBuffer)->pExtra,
				                                   &pInstanceHandle);
			else
				Status = DI_CreateMouseInstance(Irp->AssociatedIrp.SystemBuffer, &pInstanceHandle);
			*(void **)Irp->AssociatedIrp.SystemBuffer = pInstanceHandle;
			Irp->IoStatus.Information = sizeof(PVOID);
			break;
		}

		case IOCTL_KBD_INITKEYS:
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			break;

		case IOCTL_MOUSE_INITBUTTONS:
			if (KeGetCurrentIrql() > PASSIVE_LEVEL)
				TRACE(_T("WARNING WARNING WARNING: IOCTL called at IRQL > PASSIVE_LEVEL\n"));
			break;

		default:
			ReportError(_T("Unsupported IOCTL (0x%08X) called\n"), irpStack->Parameters.DeviceIoControl.IoControlCode);
			Status = STATUS_INVALID_PARAMETER;
			break;
	}

	if (Status) Irp->IoStatus.Status = Status;
	return KbdMou_DispatchPassThrough(DeviceObject, Irp);
}

void DI_AddDevice(PDRIVER_OBJECT pDriver)
{
	NTSTATUS status;

	if (g_ulNumOpenedDevices++ == 0)
	{
		// Create the secondary device object
		USHORT wszDevNameString[] = L"\\Device\\DINPUT1";
		UNICODE_STRING DevName;
		RtlInitUnicodeString(&DevName, wszDevNameString);

		status = IoCreateDevice(pDriver,
														sizeof(DEVICE_EXTENSION),
														&DevName,
														FILE_DEVICE_UNKNOWN,
														0,
														FALSE,
														&g_pUserDevObj
														);

		if (status)
		{
			ReportError(_T("IoCreateDevice on second device failed: 0x%08X\n"), status);
		}

		ReportError(_T("User Device Object at 0x%P\n"), g_pUserDevObj);
		// Register device interface
//		IoRegisterDeviceInterface(PDO, &DINPUT_INTERFACE_GUID, NULL, &g_SymbolicName);
		// Correct 2nd and 3rd characters in the name returned.
//		g_SymbolicName.Buffer[1] = _T('\\');
//		g_SymbolicName.Buffer[2] = _T('.');
//		UnicodeToAnsi(szSymName, g_SymbolicName.Buffer);
//		TRACE(szSymName);
//		TRACE(_T("\n"));

		if (!status)
		{
			ANSI_STRING AnsiName;
			// Create a symbolic link
//			NTSTATUS ret;
//			USHORT wszBuffer[260] = L"\\DosDevices\\DINPUT1";
//			UNICODE_STRING NewName;

			g_pUserDevObj->DeviceType = FILE_DEVICE_UNKNOWN;

			RtlInitUnicodeString(&g_SymbolicName, g_wszSymbolicNameBuffer);
			RtlUnicodeStringToAnsiString(&AnsiName, &g_SymbolicName, TRUE);
			ReportError(_T("Symbolic name used: \"%s\"\n"), (ULONG)AnsiName.Buffer);
			status = IoCreateSymbolicLink(&g_SymbolicName, &DevName);
			if (status)
			{
				ReportError(_T("IoCreateSymbolicLink failed: 0x%08X\n"), status);
//				ReportError(_T("  2nd character is 0x%02X\n"), (char)g_SymbolicName.Buffer[1]);
//				ReportError(_T("  3rd character is 0x%02X\n"), (char)g_SymbolicName.Buffer[2]);
			}
			else
				TRACE(_T("IoCreateSymbolicLink successful\n"));
/*			else
			{
				status = IoDeleteSymbolicLink(&g_SymbolicName);
				if (status)
					ReportError(_T("IoDeleteSymbolicLink() failed: 0x%08X\n"), status);
			}*/

//			IoDeleteDevice(g_pUserDevObj);
		}
	}
}

void DI_RemoveDevice()
{
	DebugPrint(("DI_RemoveDevice()\n"));

	if (--g_ulNumOpenedDevices == 0)
	{
		// Delete the secondary device object
		IoSetDeviceInterfaceState(&g_SymbolicName, FALSE);
		IoDeleteDevice(g_pUserDevObj);
	}
}

// DI_CreateInstanceHelper does the following:
// 1. Allocate memory for VXDINSTANCE and makes it user mode accessible.
// 2. Allocate memory for device instance structure.
// 3. Allocate memory for device state and makes it user mode accessible.
// 4. Insert the instance to the appropriate instance list.
// 5. Initialize ppInstanceHandle with the user mode address of VXDINSTANCE.
NTSTATUS DI_CreateInstanceHelper(PSYSDEVICEFORMAT pSysDevFormat, void **ppInstanceHandle, enum DI_DeviceType DeviceType)
{
	PVXDINSTANCE pVI;
	PVXDINSTANCE pVIUser;
	PMDL pMdlForVI;
	LPDI_DEVINSTANCE pDevInst;
	BOOLEAN bFailed = FALSE;
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_CreateInstanceHelper(0x%P, "), pSysDevFormat);
	ReportError(_T("0x%P)\n"), ppInstanceHandle);

	// First thing we do is allocate memory for VXDINSTANCE and make it usermode accessible
	pVI = DI_ExAllocatePool(PagedPool, sizeof(VXDINSTANCE));
	if (!pVI)
		return STATUS_INSUFFICIENT_RESOURCES;
	RtlZeroMemory(pVI, sizeof(VXDINSTANCE));
	pMdlForVI = IoAllocateMdl(pVI, sizeof(VXDINSTANCE), FALSE, FALSE, NULL);
	__try
	{
		MmProbeAndLockPages(pMdlForVI, KernelMode, IoReadAccess);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		// Cannot lock pages.  Free Mdl and pool, then bail out.
		IoFreeMdl(pMdlForVI);
		ExFreePool(pVI);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	pVIUser = MmMapLockedPages(pMdlForVI, UserMode);
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("User VI at 0x%P\n"), pVIUser);

	// Now allocate and initialize DI_DEVINSTANCE
	pDevInst = DI_ExAllocatePool(PagedPool, sizeof(DI_DEVINSTANCE));
	if (!pDevInst)
		return STATUS_INSUFFICIENT_RESOURCES;

	// NOTE: Right now, make all instances use the first keyboard.  Later, caller will supply a parameter
	//       telling us which keyboard it's interested in.
	RtlZeroMemory(pDevInst, sizeof(DI_DEVINSTANCE));
	pDevInst->pDev = DeviceType == DI_DeviceKeyboard ? g_pKbdDevList : g_pMouDevList;
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("pDev = 0x%P\n"), pDevInst->pDev);
	pDevInst->pBuffer = pDevInst->pEnd = pDevInst->pHead = pDevInst->pTail = NULL;
	pDevInst->pVIUser = pVIUser;  // Save the user mode VI address
	pDevInst->pVI = pVI;  // Save the kernel mode address of our VI
	pDevInst->pMdlForVI = pMdlForVI;  // Save the Mdl for use by DestroyInstance
//	pVI->hInst = pDevInst;  // Make VI point to the device instance struct

	__try
	{
		__try
		{
			// Allocate memory to hold the state information
			ULONG ulStateSize = DeviceType == DI_DeviceKeyboard ? sizeof(UCHAR) * 256 : sizeof(DIMOUSESTATE_INT);
			pDevInst->pState = DI_ExAllocatePool(PagedPool, ulStateSize);
			if (!pDevInst->pState)
			{
				bFailed = TRUE;
				return STATUS_INSUFFICIENT_RESOURCES;
			}
			RtlZeroMemory(pDevInst->pState, ulStateSize);
			// Lock the state buffer for sharing with the DLL
			pDevInst->pMdlForState = IoAllocateMdl(pDevInst->pState, ulStateSize, FALSE, FALSE, NULL);
			MmProbeAndLockPages(pDevInst->pMdlForState, KernelMode, IoReadAccess);
			pVI->pState = MmMapLockedPages(pDevInst->pMdlForState, UserMode);
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			ReportError(_T("Usermode state buffer at 0x%P\n"), pVI->pState);

			// Insert the intance to the keyboard list
			if (DeviceType == DI_DeviceKeyboard)
			{
				if (!g_pKbdDevInstList)
				{
					// This is the first instance
					pDevInst->pLink = NULL;
					pDevInst->pPrevLink = NULL;
					InterlockedExchangePointer(&g_pKbdDevInstList, pDevInst);
				} else
				{
					// Insert this instance to the beginning of the list
					pDevInst->pPrevLink = NULL;
					pDevInst->pLink = g_pKbdDevInstList;
					InterlockedExchangePointer(&g_pKbdDevInstList->pPrevLink, pDevInst);
					InterlockedExchangePointer(&g_pKbdDevInstList, pDevInst);
				}
			} else
			{
				// Insert this instance to the mouse list
				if (!g_pMouDevInstList)
				{
					// This is the first instance
					pDevInst->pLink = NULL;
					pDevInst->pPrevLink = NULL;
					InterlockedExchangePointer(&g_pMouDevInstList, pDevInst);
				} else
				{
					// Insert this instance to the beginning of the list
					pDevInst->pPrevLink = NULL;
					pDevInst->pLink = g_pMouDevInstList;
					InterlockedExchangePointer(&g_pMouDevInstList->pPrevLink, pDevInst);
					InterlockedExchangePointer(&g_pMouDevInstList, pDevInst);
				}
			}

			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			ReportError(_T("New instance = 0x%P\n"), pDevInst);
			*ppInstanceHandle = pVIUser;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// MmProbeAndLockPages failed
			bFailed = TRUE;
			IoFreeMdl(pDevInst->pMdlForState);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	__finally
	{
		if (bFailed)
		{
			TRACE(_T("Create failed\n"));
			if (pDevInst->pState)
			{
				TRACE(_T("Freeing pState"));
				ExFreePool(pDevInst->pState);
			}
			if (pDevInst->pExtra)
			{
				TRACE(_T("Freeing pExtra"));
				ExFreePool(pDevInst->pExtra);
			}
			// Free instance memory
			ExFreePool(pDevInst);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS DI_CreateKeyboardInstance(PSYSDEVICEFORMAT pSysDevFormat, UCHAR *pbTranslationTable, void **ppInstanceHandle)
{
	NTSTATUS status;
	BOOLEAN bFailed = FALSE;
	LPDI_DEVINSTANCE pDevInst;
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_CreateKeyboardInstance(0x%P, "), pSysDevFormat);
	ReportError(_T("0x%P, "), pbTranslationTable);
	ReportError(_T("0x%P)\n"), ppInstanceHandle);

	status = DI_CreateInstanceHelper(pSysDevFormat, ppInstanceHandle, DI_DeviceKeyboard);
	if (status) return status;

	pDevInst = GetDevInstFromUserVxdInst(*ppInstanceHandle);
	__try
	{
		// Allocate memory to hold the translation table
		if (pbTranslationTable)
		{
			pDevInst->pExtra = DI_ExAllocatePool(PagedPool, sizeof(UCHAR) * 256);
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			ReportError(_T("Translation table at 0x%P\n"), pDevInst->pExtra);
			if (!pDevInst->pExtra)
			{
				bFailed = TRUE;
				return STATUS_INSUFFICIENT_RESOURCES;
			}
			RtlMoveMemory(pDevInst->pExtra, pbTranslationTable, sizeof(UCHAR) * 256);
		}
	}
	__finally
	{
		if (bFailed)
			DI_DestroyInstance(*ppInstanceHandle);
	}
	return STATUS_SUCCESS;
}

NTSTATUS DI_CreateMouseInstance(PSYSDEVICEFORMAT pSysDevFormat, void **ppInstanceHandle)
{
	NTSTATUS status;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_CreateMouseInstance(0x%P, "), pSysDevFormat);
	ReportError(_T("0x%P)\n"), ppInstanceHandle);

	status = DI_CreateInstanceHelper(pSysDevFormat, ppInstanceHandle, DI_DeviceMouse);
	if (status) return status;

	return STATUS_SUCCESS;
}

NTSTATUS DI_DestroyInstance(PVXDINSTANCE pVI)
{
	LPDI_DEVINSTANCE pDevInst = GetDevInstFromUserVxdInst(pVI);

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_DestroyInstance(0x%P)\n"), pVI);
	ReportError(_T("  DEVINSTANCE at 0x%P\n"), pDevInst);

	// Dereference the event pointer so the resource can be freed.
	if (pDevInst->pEvent)
	{
		ObDereferenceObject(pDevInst->pEvent);
		pDevInst->pEvent = NULL;
	}

	// If there is a data format, destroy it.
	if (pDevInst->pulOffsets)
		ExFreePool(pDevInst->pulOffsets);

	// Remove it from the global list
	if (pDevInst->pLink)
		pDevInst->pLink->pPrevLink = pDevInst->pPrevLink;
	if (pDevInst->pPrevLink)
		pDevInst->pPrevLink->pLink = pDevInst->pLink;
	// If we are the first instance, the global list will now begin at the next instance.
	// Note that we check for both the keyboard and mouse lists anyway, but only one of these IFs
	// will satisfy since an instance cannot be in both lists.
	if (g_pKbdDevInstList == pDevInst)
		g_pKbdDevInstList = pDevInst->pLink;
	if (g_pMouDevInstList == pDevInst)
		g_pMouDevInstList = pDevInst->pLink;

	// Clean up for state buffer
	if (pDevInst->pState)
	{
		MmUnmapLockedPages(pDevInst->pVI->pState, pDevInst->pMdlForState);
		IoFreeMdl(pDevInst->pMdlForState);
		ExFreePool(pDevInst->pState);
	}

	if (pDevInst->pBuffer) ExFreePool(pDevInst->pBuffer);
	if (pDevInst->pExtra) ExFreePool(pDevInst->pExtra);

	// Now unlock the memory for VI
	MmUnmapLockedPages(pVI, pDevInst->pMdlForVI);
	IoFreeMdl(pDevInst->pMdlForVI);
	ExFreePool(pDevInst->pVI);
	ExFreePool(pDevInst);

	return STATUS_SUCCESS;
}

NTSTATUS DI_AcquireInstance(LPDI_DEVINSTANCE pDevInst)
{
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_AcquireInstance(0x%P)\n"), pDevInst);
	// Synchronize with the current key state
	if (pDevInst->pDev->DeviceType == FILE_DEVICE_KEYBOARD)
	{
		ReportError(_T("Copying %u bytes\n"), sizeof(UCHAR) * 256);
		RtlCopyMemory(pDevInst->pState, ((PDEVICE_EXTENSION)pDevInst->pDev->DeviceExtension)->arbKbdState, sizeof(UCHAR) * 256);
	}
	else
	{
		ReportError(_T("Copying %u bytes\n"), sizeof(DIMOUSESTATE_INT));
		RtlCopyMemory(pDevInst->pState, &((PDEVICE_EXTENSION)pDevInst->pDev->DeviceExtension)->MouseState, sizeof(DIMOUSESTATE_INT));
	}
	pDevInst->pVI->fl |= VIFL_ACQUIRED;
	return STATUS_SUCCESS;
}

NTSTATUS DI_UnacquireInstance(LPDI_DEVINSTANCE pDevInst)
{
	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_UnaquireInstance(0x%P)\n"), pDevInst);
	pDevInst->pVI->fl &= ~VIFL_ACQUIRED;
	return STATUS_SUCCESS;
}

NTSTATUS DI_SetBufferSize(LPDI_DEVINSTANCE pDevInst, ULONG ulSize)
{
	DIDEVICEOBJECTDATA_DX3 *pNewBuffer;
	PVOID pOldBuffer;
	PMDL pOldMdlForBuffer;
	PVOID pOldUserBuffer;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_SetBufferSize(0x%P, "), pDevInst);
	ReportError(_T("%u)\n"), ulSize);
	if (!ulSize)
	{
		// If there is a buffer, free it.
		if (pDevInst->pBuffer)
		{
			pOldBuffer = pDevInst->pBuffer;
			MmUnmapLockedPages(pDevInst->pVI->pBuffer, pDevInst->pMdlForBuffer);
			IoFreeMdl(pDevInst->pMdlForBuffer);
			pDevInst->pMdlForBuffer = NULL;

			pDevInst->pVI->pBuffer =   // User mode pointers
				pDevInst->pVI->pEnd = 
				pDevInst->pVI->pHead = 
				pDevInst->pVI->pTail = NULL;
			InterlockedExchangePointer(&pDevInst->pBuffer, NULL);  // Kernel mode pointers
			InterlockedExchangePointer(&pDevInst->pEnd, NULL);
			InterlockedExchangePointer(&pDevInst->pHead, NULL);
			InterlockedExchangePointer(&pDevInst->pTail, NULL);
			ExFreePool(pOldBuffer);
		}
		pDevInst->ulBufferSize = 0;
		return STATUS_SUCCESS;
	}

	// First thing we do is see if we can get the new buffer
	pNewBuffer = DI_ExAllocatePool(PagedPool, sizeof(DIDEVICEOBJECTDATA_DX3) * ulSize);
	if (!pNewBuffer)
		return STATUS_INSUFFICIENT_RESOURCES;  // If we can't, exit without changing anything.
	// Lock and map the buffer for DLL's access
	pDevInst->pMdlForBuffer = IoAllocateMdl(pNewBuffer, sizeof(DIDEVICEOBJECTDATA_DX3) * ulSize, FALSE, FALSE, NULL);
	__try
	{
		MmProbeAndLockPages(pDevInst->pMdlForBuffer, KernelMode, IoReadAccess);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		// MmProbeAndLockPages failed
		IoFreeMdl(pDevInst->pMdlForBuffer);
		ExFreePool(pNewBuffer);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// These don't need to be protected by InterlockedXXX since only user mode code accesses them.
	pOldUserBuffer = pDevInst->pVI->pBuffer;
	pDevInst->pVI->pBuffer = MmMapLockedPages(pDevInst->pMdlForBuffer, UserMode);
	pDevInst->pVI->pEnd = pDevInst->pVI->pBuffer + ulSize;
	pDevInst->pVI->pHead = pDevInst->pVI->pTail = pDevInst->pVI->pBuffer;

	RtlZeroMemory(pNewBuffer, sizeof(DIDEVICEOBJECTDATA_DX3) * ulSize);  // Initialize the buffer with 0s
	pOldBuffer = pDevInst->pBuffer;
	pOldMdlForBuffer = pDevInst->pMdlForBuffer;
	// Initialize the pointers
	InterlockedExchange(&pDevInst->ulBufferSize, ulSize);
	InterlockedExchangePointer(&pDevInst->pEnd, pNewBuffer + ulSize);
	InterlockedExchangePointer(&pDevInst->pTail, pNewBuffer);
	InterlockedExchangePointer(&pDevInst->pHead, pNewBuffer);
	InterlockedExchangePointer(&pDevInst->pBuffer, pNewBuffer);

	// If there is already a buffer, free it.
	if (pOldBuffer)
	{
		MmUnmapLockedPages(pOldUserBuffer, pOldMdlForBuffer);
		IoFreeMdl(pOldMdlForBuffer);
		ExFreePool(pOldBuffer);
	}

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
//	ReportError(_T("pBuffer at 0x%P\n"), pDevInst->pBuffer);
//	ReportError(_T("pEnd at 0x%P\n"), pDevInst->pEnd);
//	ReportError(_T("pHead at 0x%P\n"), pDevInst->pHead);
//	ReportError(_T("pTail at 0x%P\n"), pDevInst->pTail);
//	ReportError(_T("User pBuffer at 0x%P\n"), pDevInst->pVI->pBuffer);
//	ReportError(_T("User pEnd at 0x%P\n"), pDevInst->pVI->pEnd);
//	ReportError(_T("User pHead at 0x%P\n"), pDevInst->pVI->pHead);
//	ReportError(_T("User pTail at 0x%P\n"), pDevInst->pVI->pTail);
	return STATUS_SUCCESS;
}

NTSTATUS DI_SetNotifyHandle(LPDI_DEVINSTANCE pDevInst, PVOID pEvent)
{
	NTSTATUS status;
	PVOID pNewPointer = NULL;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_SetNotifyHandle(0x%P, "), pDevInst);
	ReportError(_T("0x%P)\n"), pEvent);

	// Obtain a kernel mode pointer to the passed event and save it.
	if (pEvent)
	{
		status = ObReferenceObjectByHandle(pEvent, STANDARD_RIGHTS_WRITE, *ExEventObjectType,
		                                   KernelMode, &pNewPointer, NULL);

		if (status != STATUS_SUCCESS)
			return status;
	}

	// If a previous handle is passed to us, we must dereference it first.
	if (pDevInst->pEvent)
		ObDereferenceObject(pDevInst->pEvent);

	pDevInst->pEvent = pNewPointer;

	return STATUS_SUCCESS;
}

NTSTATUS DI_SetDataFormat(LPDI_DEVINSTANCE pDevInst, ULONG ulSize, ULONG *pulDataFormat)
{
	ULONG *pulNewFormat = NULL;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	ReportError(_T("DI_SetDataFormat(0x%P, "), pDevInst);
	ReportError(_T("%u, "), ulSize);
	ReportError(_T("0x%P)\n"), pulDataFormat);

	// Allocate memory to store the new format
	if (pulDataFormat)
	{
		pulNewFormat = DI_ExAllocatePool(PagedPool, ulSize * sizeof(ULONG));
		if (!pulNewFormat)
			return STATUS_INSUFFICIENT_RESOURCES;
		RtlMoveMemory(pulNewFormat, pulDataFormat, ulSize * sizeof(ULONG));
	}

#ifdef DBG
	{
		ULONG i;
		TRACE(_T("******************\n"));
		for (i = 0; i < ulSize; ++i)
			ReportError(_T("*** %10d ***\n"), pulDataFormat[i]);
		TRACE(_T("******************\n"));
	}
#endif

	// If there is an existing data format, destroy it.
	if (pDevInst->pulOffsets)
		ExFreePool(pDevInst->pulOffsets);
	pDevInst->pulOffsets = pulNewFormat;
	pDevInst->ulDataFormatSize = ulSize;
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\pid\pidusg.h ===
#include "hidusage.h"

#ifndef HID_USAGE_PAGE_ORDINALS
    #define HID_USAGE_PAGE_ORDINALS                         ((USAGE) 0x0A)
#endif


#define HID_USAGE_PAGE_PID                                  ((USAGE) 0x0F)

#define HID_USAGE_PID_PHYSICAL_INTERFACE_DEVICE             ((USAGE) 0x01) 


#define HID_USAGE_PID_NORMAL                                ((USAGE) 0x20) 
#define HID_USAGE_PID_SET_EFFECT_REPORT                     ((USAGE) 0x21)
#define HID_USAGE_PID_EFFECT_BLOCK_INDEX                    ((USAGE) 0x22)
#define HID_USAGE_PID_PARAMETER_BLOCK_OFFSET                ((USAGE) 0x23)
#define HID_USAGE_PID_ROM_FLAG                              ((USAGE) 0x24)
#define HID_USAGE_PID_EFFECT_TYPE                           ((USAGE) 0x25)
#define HID_USAGE_PID_ET_CONSTANT                           ((USAGE) 0x26)
#define HID_USAGE_PID_ET_RAMP                               ((USAGE) 0x27)
#define HID_USAGE_PID_ET_CUSTOM                             ((USAGE) 0x28)


#define HID_USAGE_PID_ET_SQUARE                             ((USAGE) 0x30)
#define HID_USAGE_PID_ET_SINE                               ((USAGE) 0x31)
#define HID_USAGE_PID_ET_TRIANGLE                           ((USAGE) 0x32)
#define HID_USAGE_PID_ET_SAWTOOTH_UP                        ((USAGE) 0x33)
#define HID_USAGE_PID_ET_SAWTOOTH_DOWN                      ((USAGE) 0x34)


#define HID_USAGE_PID_ET_SPRING                             ((USAGE) 0x40)
#define HID_USAGE_PID_ET_DAMPER                             ((USAGE) 0x41)
#define HID_USAGE_PID_ET_INERTIA                            ((USAGE) 0x42)
#define HID_USAGE_PID_ET_FRICTION                           ((USAGE) 0x43)



#define HID_USAGE_PID_DURATION                              ((USAGE) 0x50)
#define HID_USAGE_PID_SAMPLE_PERIOD                         ((USAGE) 0x51)
#define HID_USAGE_PID_GAIN                                  ((USAGE) 0x52)
#define HID_USAGE_PID_TRIGGER_BUTTON                        ((USAGE) 0x53)
#define HID_USAGE_PID_TRIGGER_REPEAT_INTERVAL               ((USAGE) 0x54)
#define HID_USAGE_PID_AXES_ENABLE                           ((USAGE) 0x55)
#define HID_USAGE_PID_DIRECTION_ENABLE                      ((USAGE) 0x56)
#define HID_USAGE_PID_DIRECTION                             ((USAGE) 0x57)
#define HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET            ((USAGE) 0x58)
#define HID_USAGE_PID_BLOCK_TYPE                            ((USAGE) 0x59)
#define HID_USAGE_PID_SET_ENVELOPE_REPORT                   ((USAGE) 0x5A)
#define HID_USAGE_PID_ATTACK_LEVEL                          ((USAGE) 0x5B)
#define HID_USAGE_PID_ATTACK_TIME                           ((USAGE) 0x5C)
#define HID_USAGE_PID_FADE_LEVEL                            ((USAGE) 0x5D)
#define HID_USAGE_PID_FADE_TIME                             ((USAGE) 0x5E)
#define HID_USAGE_PID_SET_CONDITION_REPORT                  ((USAGE) 0x5F)


#define HID_USAGE_PID_CP_OFFSET                             ((USAGE) 0x60)
#define HID_USAGE_PID_POSITIVE_COEFFICIENT                  ((USAGE) 0x61)
#define HID_USAGE_PID_NEGATIVE_COEFFICIENT                  ((USAGE) 0x62)
#define HID_USAGE_PID_POSITIVE_SATURATION                   ((USAGE) 0x63)
#define HID_USAGE_PID_NEGATIVE_SATURATION                   ((USAGE) 0x64)
#define HID_USAGE_PID_DEAD_BAND                             ((USAGE) 0x65)
#define HID_USAGE_PID_DOWNLOAD_FORCE_SAMPLE                 ((USAGE) 0x66)
#define HID_USAGE_PID_ISOCH_CUSTOM_FORCE_ENABLE             ((USAGE) 0x67)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA_REPORT              ((USAGE) 0x68)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA                     ((USAGE) 0x69)
#define HID_USAGE_PID_CUSTOM_FORCE_VENDOR_DEFINED           ((USAGE) 0x6A)
#define HID_USAGE_PID_SET_CUSTOM_FORCE_REPORT               ((USAGE) 0x6B)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA_OFFSET				((USAGE) 0x6C)
#define HID_USAGE_PID_SAMPLE_COUNT                          ((USAGE) 0x6D)
#define HID_USAGE_PID_SET_PERIODIC_REPORT                   ((USAGE) 0x6E)
#define HID_USAGE_PID_OFFSET                                ((USAGE) 0x6F)


#define HID_USAGE_PID_MAGNITUDE                             ((USAGE) 0x70)
#define HID_USAGE_PID_PHASE                                 ((USAGE) 0x71)
#define HID_USAGE_PID_PERIOD                                ((USAGE) 0x72)
#define HID_USAGE_PID_SET_CONSTANT_FORCE_REPORT             ((USAGE) 0x73)
#define HID_USAGE_PID_SET_RAMP_FORCE_REPORT                 ((USAGE) 0x74)
#define HID_USAGE_PID_RAMP_START                            ((USAGE) 0x75)
#define HID_USAGE_PID_RAMP_END                              ((USAGE) 0x76)
#define HID_USAGE_PID_EFFECT_OPERATION_REPORT               ((USAGE) 0x77)
#define HID_USAGE_PID_EFFECT_OPERATION                      ((USAGE) 0x78)
#define HID_USAGE_PID_OP_EFFECT_START                       ((USAGE) 0x79)
#define HID_USAGE_PID_OP_EFFECT_START_SOLO                  ((USAGE) 0x7A)
#define HID_USAGE_PID_OP_EFFECT_STOP                        ((USAGE) 0x7B)
#define HID_USAGE_PID_LOOP_COUNT                            ((USAGE) 0x7C)
#define HID_USAGE_PID_DEVICE_GAIN_REPORT                    ((USAGE) 0x7D)
#define HID_USAGE_PID_DEVICE_GAIN                           ((USAGE) 0x7E)
#define HID_USAGE_PID_POOL_REPORT                           ((USAGE) 0x7F)


#define HID_USAGE_PID_RAM_POOL_SIZE                         ((USAGE) 0x80)
#define HID_USAGE_PID_ROM_POOL_SIZE                         ((USAGE) 0x81)
#define HID_USAGE_PID_ROM_EFFECT_BLOCK_COUNT                ((USAGE) 0x82)
#define HID_USAGE_PID_SIMULTANEOUS_EFFECTS_MAX              ((USAGE) 0x83)
#define HID_USAGE_PID_POOL_ALIGNMENT                        ((USAGE) 0x84)
#define HID_USAGE_PID_POOL_MOVE_REPORT                      ((USAGE) 0x85)
#define HID_USAGE_PID_MOVE_SOURCE                           ((USAGE) 0x86)
#define HID_USAGE_PID_MOVE_DESTINATION                      ((USAGE) 0x87)
#define HID_USAGE_PID_MOVE_LENGTH                           ((USAGE) 0x88)
#define HID_USAGE_PID_BLOCK_LOAD_REPORT                     ((USAGE) 0x89)
#define HID_USAGE_PID_HANDSHAKE_KEY                         ((USAGE) 0x8A)
#define HID_USAGE_PID_BLOCK_LOAD_STATUS                     ((USAGE) 0x8B)
#define HID_USAGE_PID_BLOCK_LOAD_SUCCESS                    ((USAGE) 0x8C)
#define HID_USAGE_PID_BLOCK_LOAD_FULL                       ((USAGE) 0x8D)
#define HID_USAGE_PID_BLOCK_LOAD_ERROR                      ((USAGE) 0x8E)
#define HID_USAGE_PID_BLOCK_HANDLE                          ((USAGE) 0x8F)


#define HID_USAGE_PID_BLOCK_FREE_REPORT                     ((USAGE) 0x90)
#define HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_HANDLE            ((USAGE) 0x91)
#define HID_USAGE_PID_STATE_REPORT                          ((USAGE) 0x92)
#define HID_USAGE_PID_EFFECT_STATE                          ((USAGE) 0x93)
#define HID_USAGE_PID_EFFECT_PLAYING                        ((USAGE) 0x94)

#define HID_USAGE_PID_DEVICE_CONTROL                        ((USAGE) 0x96)
#define HID_USAGE_PID_DC_ENABLE_ACTUATORS                   ((USAGE) 0x97)
#define HID_USAGE_PID_DC_DISABLE_ACTUATORS                  ((USAGE) 0x98)
#define HID_USAGE_PID_DC_STOP_ALL_EFFECTS                   ((USAGE) 0x99)
#define HID_USAGE_PID_DC_DEVICE_RESET                       ((USAGE) 0x9A)
#define HID_USAGE_PID_DC_DEVICE_PAUSE                       ((USAGE) 0x9B)
#define HID_USAGE_PID_DC_DEVICE_CONTINUE                    ((USAGE) 0x9C)

#define HID_USAGE_PID_DEVICE_PAUSED                         ((USAGE) 0x9F)


#define HID_USAGE_PID_ACTUATORS_ENABLED                     ((USAGE) 0xA0)

#define HID_USAGE_PID_SAFETY_SWITCH                         ((USAGE) 0xA4)
#define HID_USAGE_PID_ACTUATOR_OVERRIDE_SWITCH              ((USAGE) 0xA5)
#define HID_USAGE_PID_ACTUATOR_POWER                        ((USAGE) 0xA6)
#define HID_USAGE_PID_START_DELAY                           ((USAGE) 0xA7)
#define HID_USAGE_PID_PARAMETER_BLOCK_SIZE                  ((USAGE) 0xA8)
#define HID_USAGE_PID_DEVICE_MANAGED_POOL                   ((USAGE) 0xA9)
#define HID_USAGE_PID_SHARED_PARAMETER_BLOCKS               ((USAGE) 0xAA)
#define HID_USAGE_PID_CREATE_NEW_EFFECT                     ((USAGE) 0xAB)
#define HID_USAGE_PID_RAMPOOL_AVAILABLE                     ((USAGE) 0xAC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//
#include <wmidata.h>

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\dinputs.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    Dinputs.h

Abstract:

    This module contains the common private declarations for the keyboard
    packet filter

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef DINPUTS_H
#define DINPUTS_H

//#ifdef _WIN32
//#define COM_NO_WINDOWS_H
//#include <objbase.h>
//#endif

#include "ntddk.h"
#include "kbdmou.h"
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntdd8042.h>

#define DIRECTINPUT_VERSION 0x800

#define KbdMou_POOL_TAG (ULONG) 'PNID'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KbdMou_POOL_TAG)

DEFINE_GUID(DINPUT_INTERFACE_GUID,0x0C64D244,0xCBE4,0x4F74,0xA2,0x13,0x99,0x65,0xBC,0x84,0x6E,0x03);


#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)

#define DebugPrint(_x_) DbgPrint _x_

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#define DebugPrint(_x_) 

#endif

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


/*typedef struct _DEVICELIST
{
	PDEVICE_OBJECT pDev;
	struct _DEVICELIST *pLink;  // Links to the next device
	struct _DEVICELIST *pPrev;  // Back link
} DEVICELIST, *PDEVICELIST;
*/
typedef struct _DEVICE_EXTENSION
{
	//
	// A backpointer to the device object for which this is the extension
	//
	PDEVICE_OBJECT  Self;

	//
	// "THE PDO"  (ejected by the root bus or ACPI)
	//
	PDEVICE_OBJECT  PDO;

	//
	// The top of the stack before this filter was added.  AKA the location
	// to which all IRPS should be directed.
	//
	PDEVICE_OBJECT  TopOfStack;

	//
	// The secondary device object to IO control
	//
	PDEVICE_OBJECT IoctlDevice;

	//
	// Number of creates sent down
	//
	LONG EnableCount;

	//
	// The real connect data that this driver reports to
	//
	CONNECT_DATA UpperConnectData;

	//
	// Previous initialization and hook routines (and context)
	//                               
	PVOID UpperContext;
	PI8042_KEYBOARD_INITIALIZATION_ROUTINE UpperInitializationRoutine;
	union {
		PI8042_KEYBOARD_ISR UpperKbdIsrHook;
		PI8042_MOUSE_ISR UpperMouIsrHook;
	};

	//
	// Write function from within KbdMou_IsrHook
	//
	IN PI8042_ISR_WRITE_PORT IsrWritePort;

	//
	// Queue the current packet (ie the one passed into KbdMou_IsrHook)
	//
	IN PI8042_QUEUE_PACKET QueuePacket;

	//
	// Context for IsrWritePort, QueueKeyboardPacket
	//
	IN PVOID CallContext;

	//
	// current power state of the device
	//
	DEVICE_POWER_STATE  DeviceState;

	BOOLEAN         Started;
	BOOLEAN         SurpriseRemoved;
	BOOLEAN         Removed;

	// Link to the next and previous PDEVICE_OBJECT of the same type
	PDEVICE_OBJECT pLink;
	PDEVICE_OBJECT pPrevLink;

	// Current device state (for detecting state change)
	union
	{
		UCHAR arbKbdState[256];
		DIMOUSESTATE_INT MouseState;
	};

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct SYSDEVICEFORMAT { /* devf */
    ULONG cbData;             /* Size of device data */
    ULONG cObj;               /* Number of objects in data format */
    DIOBJECTDATAFORMAT *rgodf;  /* Array of descriptions */
    void *pExtra;            /* Extra pointer for private communication */
    DWORD dwEmulation;        /* Flags controlling emulation */
} SYSDEVICEFORMAT, *PSYSDEVICEFORMAT;

///////////////////////////////////////////////////
// Definitions for device instances
///////////////////////////////////////////////////


typedef struct VXDINSTANCE;

typedef struct _DI_DEVINSTANCE
{
	PDEVICE_OBJECT pDev;  // Pointer to the device object that this instance is interested in
	void *pState;  // Indicate the current state of the device (Kernel mode virtual address)
	PMDL pMdlForState;  // Mdl for state buffer
	ULONG ulBufferSize;  // Size of the buffer to hold events
	PRKEVENT pEvent;  // pointer to event that receives notification

	// If pHead == pTail, no data are in the buffer
	// The buffer can actually only hold ulBufferSize - 1 objects, as if ulBufferSize objects
	// are in buffer, pHead == pTail and it can be confusing with the empty buffer case.

	DIDEVICEOBJECTDATA_DX3 *pBuffer;  // Array of DIDEVICEOBJECTDATA_DX3 to store key events
	DIDEVICEOBJECTDATA_DX3 *pEnd;  // One past the last element in the array
	DIDEVICEOBJECTDATA_DX3 *pHead;  // Where the next entry is to be written
	DIDEVICEOBJECTDATA_DX3 *pTail;  // Oldest data
	PMDL pMdlForBuffer;  // Mdl for device data buffer
	ULONG ulEventCount;  // Number of events queued in buffer
	ULONG ulSequence;  // Records the sequence number for the next event
	ULONG ulOverflow;  // Whether overflow occurred (0 or 1)
	void *pExtra;  // For extra information  (translation table for keyboard devices; NULL if no translation needed)
	HWND hWnd;  // Window
	ULONG ulDataFormatSize;  // Size of data format array
	ULONG *pulOffsets;  // Offsets of the data format
	struct VXDINSTANCE *pVIUser;  // Points to the corresponding VXDINSTANCE for this instance (User mode virtual address)
	struct VXDINSTANCE *pVI;  // Points to the corresponding VXDINSTANCE for this instance (Kernel mode virtual address)
	PMDL pMdlForVI;  // Mdl for pVI
	struct _DI_DEVINSTANCE *pLink;  // Link to the next device instance on the list
	struct _DI_DEVINSTANCE *pPrevLink;  // Link to the previous device instance on the list
} DI_DEVINSTANCE, *LPDI_DEVINSTANCE;


//
// Prototypes
//

NTSTATUS
KbdMou_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
KbdMou_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdMou_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
   
NTSTATUS
KbdMou_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdMou_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdMou_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdMou_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Kbd_InitializationRoutine(
    IN PDEVICE_OBJECT                 DeviceObject,    // InitializationContext
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    );

BOOLEAN
Kbd_IsrHook(
    PDEVICE_OBJECT         DeviceObject,               // IsrContext
    PKEYBOARD_INPUT_DATA   CurrentInput, 
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    );

BOOLEAN
Mou_IsrHook(
    PDEVICE_OBJECT          DeviceObject, 
    PMOUSE_INPUT_DATA       CurrentInput, 
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  DataByte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
);

VOID
Kbd_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
Mou_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
KbdMou_Unload (
    IN PDRIVER_OBJECT DriverObject
    );

#endif  // DINPUTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\test\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__360587DF_EDED_4AAD_A0B1_2BCFB66283FD__INCLUDED_)
#define AFX_STDAFX_H__360587DF_EDED_4AAD_A0B1_2BCFB66283FD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__360587DF_EDED_4AAD_A0B1_2BCFB66283FD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\sys\test\systest.cpp ===
// systest.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <dinput.h>
#include "disysdef.h"
#define WINNT
#include "dinputv.h"

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)

BYTE g_arbTable[256] =
	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF};

HANDLE hFile;

void OpenDevice(LPCTSTR tszDevName)
{
	HANDLE hFile;

	hFile = CreateFile(tszDevName, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
//	hFile = CreateFile(tszDevName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("Error opening using symbolic link %s: %u\n"), tszDevName, dwError);
	}
	else
	{
		_tprintf(_T("Driver opened successfully using symbolic link %s!\n"), tszDevName);
		CloseHandle(hFile);
	}
}

DWORD GetDiSysVerion()
{
	DWORD dwReturned;
	DWORD dwVersion;
	DWORD dwInput = 0x87654321;
	if (!DeviceIoControl(hFile, IOCTL_GETVERSION, &dwInput, sizeof(DWORD), &dwVersion, sizeof(DWORD), &dwReturned, NULL))
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("DeviceIoControl() failed: %u\n"), dwError);
	} else
		_tprintf(_T("DINPUT.SYS Version 0x%08X\n"), dwVersion);
	return dwVersion;
}

HANDLE CreateKbdInstance(PSYSDEVICEFORMAT pSysDevFormat)
{
	DWORD dwReturned;
	PVXDINSTANCE pVxdInst;
	BYTE arbInBuffer[sizeof(SYSDEVICEFORMAT) + 256 * sizeof(BYTE)];

	if (!pSysDevFormat) return NULL;
	MoveMemory(arbInBuffer, pSysDevFormat, sizeof(SYSDEVICEFORMAT));
	MoveMemory(arbInBuffer + sizeof(SYSDEVICEFORMAT), pSysDevFormat->pExtra, sizeof(BYTE) * 256);
	pVxdInst = new VXDINSTANCE;
	if (!pVxdInst) return NULL;
	if (!DeviceIoControl(hFile, IOCTL_KBD_CREATEINSTANCE,
	                     arbInBuffer, sizeof(SYSDEVICEFORMAT)/* + 256 * sizeof(BYTE)*/,
	                     &pVxdInst->hInst, sizeof(pVxdInst->hInst), &dwReturned, NULL))
	{
		_tprintf(_T("DeviceIoControl failed: %u\n"), GetLastError());
		return NULL;
	}

#ifdef WIN95
	_tprintf(_T("hInst = 0x%08X\n"), pVxdInst->hInst);
	_tprintf(_T("arbInBuffer : 0x%08X\n"), *(LPDWORD)arbInBuffer);
#else
	_tprintf(_T("hInst = 0x%P\n"), pVxdInst->hInst);
	_tprintf(_T("arbInBuffer : 0x%P\n"), *(LPDWORD)arbInBuffer);
#endif

	return pVxdInst;
}

void DestroyInstance(HANDLE hInst)
{
	DWORD dwReturned;
	if (!DeviceIoControl(hFile, IOCTL_DESTROYINSTANCE, &hInst, sizeof(HANDLE*), NULL, 0, &dwReturned, NULL))
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("DestroyInstance failed: %u\n"), dwError);
	} else
	{
		delete hInst;
	}
}

BOOL AcquireInstance(HANDLE hInst)
{
	DWORD dwReturned;
	if (!DeviceIoControl(hFile, IOCTL_ACQUIREINSTANCE, &hInst, sizeof(HANDLE*), NULL, 0, &dwReturned, NULL))
		return FALSE;
	return TRUE;
}

BOOL UnacquireInstance(HANDLE hInst)
{
	DWORD dwReturned;
	if (!DeviceIoControl(hFile, IOCTL_UNACQUIREINSTANCE, &hInst, sizeof(HANDLE*), NULL, 0, &dwReturned, NULL))
		return FALSE;
	return TRUE;
}

BOOL SetBufferSize(HANDLE hInst, DWORD dwSize)
{
	HANDLE arBuffer[2];
	DWORD dwReturned;
	arBuffer[0] = hInst;
	*(LPDWORD)&arBuffer[1] = dwSize;
	if (!DeviceIoControl(hFile, IOCTL_SETBUFFERSIZE, arBuffer, sizeof(HANDLE) * 2, NULL, 0, &dwReturned, NULL))
		return FALSE;
	return TRUE;
}

// Returns the number of events actually returned
DWORD GetDeviceData(HANDLE hInst, DIDEVICEOBJECTDATA *pDevData, DWORD dwLength)
{
	DWORD dwReturned;

	if (!DeviceIoControl(hFile, IOCTL_GETDATA, &hInst, sizeof(HANDLE*), pDevData, dwLength * sizeof(DIDEVICEOBJECTDATA), &dwReturned, NULL))
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("Error getting device data: %u\n"), dwError);
		return 0;
	}
	return dwReturned / sizeof(DIDEVICEOBJECTDATA);
}

int main(int argc, char* argv[])
{
//	OpenDevice(_T("\\\\.\\DINPUT1"));

//	hFile = CreateFile(_T("\\\\.\\Root#*PNP030b#1_0_22_0_32_0#{0c64d244-cbe4-4f74-a213-9965bc846e03}"), 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
	hFile = CreateFile(_T("\\\\.\\DINPUT1"), 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("Error: %u\n"), dwError);
		return 0;
	}
	_tprintf(_T("Driver opened successfully!\n"));

	DWORD dwVersion = GetDiSysVerion();
	_tprintf(_T("Version = 0x%08X\n"), dwVersion);

	SYSDEVICEFORMAT SysDevFormat;
	SysDevFormat.cbData = sizeof(SysDevFormat);
	SysDevFormat.pExtra = g_arbTable;
	HANDLE hKb = CreateKbdInstance(&SysDevFormat);
#ifdef WIN95
	_tprintf(_T("Instance Handle = 0x%08X\n"), hKb);
#else
	_tprintf(_T("Instance Handle = 0x%P\n"), hKb);
#endif
	if (hKb)
	{
		DIDEVICEOBJECTDATA arDevData[8];
		DWORD dwNumEvents;
		DWORD i;

		SetBufferSize(hKb, 64);
		AcquireInstance(hKb);
		do
		{
			dwNumEvents = GetDeviceData(hKb, arDevData, 8);
//			if (dwNumEvents) _tprintf(_T("%u events\n"), dwNumEvents);
			for (i = 0; i < dwNumEvents; ++i)
			{
				_tprintf(_T("Key %s (%X)\n"), arDevData[i].dwData & 0x80 ? _T("Down") : _T("Up  "), arDevData[i].dwOfs);
				if (arDevData[i].dwOfs == 1) break;
			}
		} while (arDevData[i].dwOfs != 1);
		UnacquireInstance(hKb);
		DestroyInstance(hKb);
	}
	else
	{
		DWORD dwError = GetLastError();
		_tprintf(_T("CreateKbdInstance() failed %u\n"), dwError);
	}
	CloseHandle(hFile);
	_tprintf(_T("Handle closed\n"));
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic.inc ===
#
# Makefile things everyone needs
#
!ifndef DXROOT
DXROOT=$(BASEDIR)\multimedia\DirectX
!endif

#
# Include correct verinfo.h
# 
INCLUDES=$(DXROOT)\inc;$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\bandinst.h ===
//
// bandinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Originally written by Robert K. Amenn
//

#ifndef BANDINST_H
#define BANDINST_H

#include "dmusicc.h"
#include "alist.h"

struct IDirectMusicPerformance;
struct IDirectMusicPerformanceP;
struct IDirectMusicAudioPath;
class CBandInstrumentList;
class CBand;
class CBandTrk;

class CDownloadedInstrument : public AListItem
{
public:
	CDownloadedInstrument() 
    {
	    m_pDLInstrument = NULL; 
	    m_pPort = NULL; 
	    m_cRef = 1;
    }
	~CDownloadedInstrument();
	CDownloadedInstrument* GetNext(){return(CDownloadedInstrument*)AListItem::GetNext();}

public:
	IDirectMusicDownloadedInstrument* m_pDLInstrument;
	IDirectMusicPort*				  m_pPort;
	long							  m_cRef;

}; 

class CDownloadList : public AList
{
public:
	CDownloadList(){}
    ~CDownloadList() { Clear(); }
    void Clear();
    CDownloadedInstrument* GetHead(){return(CDownloadedInstrument *)AList::GetHead();}
	CDownloadedInstrument* GetItem(LONG lIndex){return(CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return(CDownloadedInstrument *)AList::RemoveHead();}
	void Remove(CDownloadedInstrument* pDownloadedInstrument){AList::Remove((AListItem *)pDownloadedInstrument);}
	void AddTail(CDownloadedInstrument* pDownloadedInstrument){AList::AddTail((AListItem *)pDownloadedInstrument);}
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrument

class CBandInstrument : public AListItem
{
friend CBand;
friend CBandTrk;

public:
	CBandInstrument();
	~CBandInstrument();
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    HRESULT Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMIDIMode);
    HRESULT Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath);

private:
    HRESULT DownloadAddRecord(IDirectMusicPort *pPort);
    HRESULT BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges);
	DWORD								m_dwPatch;			// Patch used with DLS Collection		
	DWORD								m_dwAssignPatch;	// Patch used with Download overrides m_dwPatch
	DWORD								m_dwChannelPriority;
	BYTE								m_bPan;
	BYTE								m_bVolume;
	short								m_nTranspose;
	BOOL								m_fGMOnly;
	BOOL								m_fNotInFile;
	DWORD								m_dwFullPatch; // if m_fGMOnly is true, this contains the original, premodified, m_dwPatch
	DWORD								m_dwPChannel;
	DWORD								m_dwFlags;
	DWORD								m_dwNoteRanges[4];
	short								m_nPitchBendRange;
	IDirectMusicCollection*				m_pIDMCollection;
	CDownloadList                  		m_DownloadList;
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrumentList

class CBandInstrumentList : public AList
{
public:
	CBandInstrumentList(){}
    ~CBandInstrumentList() { Clear(); }
    void Clear();
    CBandInstrument* GetHead(){return(CBandInstrument *)AList::GetHead();}
	CBandInstrument* GetItem(LONG lIndex){return(CBandInstrument*)AList::GetItem(lIndex);}
    CBandInstrument* RemoveHead(){return(CBandInstrument *)AList::RemoveHead();}
	void Remove(CBandInstrument* pBandInstrument){AList::Remove((AListItem *)pBandInstrument);}
	void AddTail(CBandInstrument* pBandInstrument){AList::AddTail((AListItem *)pBandInstrument);}
};

// CDestination keeps track of which performance or audiopath the band was downloaded to.

class CDestination : public AListItem
{
public:
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    IUnknown *          m_pDestination; // Performance or audiopath this download was sent to. This is a weak reference, no AddRef.
};

class CDestinationList : public AList
{
public:
	CDestinationList(){}
    ~CDestinationList() { Clear(); }
    void Clear();
    CDestination* GetHead(){return(CDestination *)AList::GetHead();}
	CDestination* GetItem(LONG lIndex){return(CDestination*)AList::GetItem(lIndex);}
    CDestination* RemoveHead(){return(CDestination *)AList::RemoveHead();}
	void Remove(CDestination* pDestination){AList::Remove((AListItem *)pDestination);}
	void AddTail(CDestination* pDestination){AList::AddTail((AListItem *)pDestination);}
};


#endif // #ifndef BANDINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\bandinst.cpp ===
//
// bandinst.cpp
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//

#include "debug.h"
#include "bandinst.h"

//////////////////////////////////////////////////////////////////////
// Class CDownloadedInstrument

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::CDownloadedInstrument

CDownloadedInstrument::~CDownloadedInstrument()
{
	if(m_pDLInstrument)
	{
		if (m_pPort)
        {
            if (FAILED(m_pPort->UnloadInstrument(m_pDLInstrument)))
            {
                Trace(1,"Error: UnloadInstrument failed\n");    
            }
        }
        m_pDLInstrument->Release();
	}

	if(m_pPort)
	{
		m_pPort->Release();
	}
}


//////////////////////////////////////////////////////////////////////
// Class CBandInstrument

//////////////////////////////////////////////////////////////////////
// CBandInstrument::CBandInstrument

CBandInstrument::CBandInstrument() 
{
    m_dwPatch = 0;
    m_dwAssignPatch = 0;
    m_bPan = 0;
    m_bVolume = 0;
    m_dwPChannel = 0;
    m_dwFlags = 0;
    m_nTranspose = 0;
    m_fGMOnly = false;
    m_fNotInFile = false;
    m_pIDMCollection = NULL;
	ZeroMemory(m_dwNoteRanges, sizeof(m_dwNoteRanges));
}

//////////////////////////////////////////////////////////////////////
// CBandInstrument::~CBandInstrument

CBandInstrument::~CBandInstrument()
{
	if(m_pIDMCollection)
	{
		m_pIDMCollection->Release();
	}
}

void CDownloadList::Clear()

{
    CDownloadedInstrument *pDownload;
    while (pDownload = RemoveHead())
    {
        delete pDownload;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\bandtrk.cpp ===
//
// bandtrk.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"
#include "bandtrk.h"

extern long g_cComponent;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::CBandTrk

CBandTrk::CBandTrk() :
m_dwValidate(0),
m_bAutoDownload(false),
m_fLockAutoDownload(false),
m_dwFlags(0),
m_cRef(1),
m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    // (Not all calls to 'new CBandTrk' are protected in handlers.)

    m_fCSInitialized = TRUE;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::~CBandTrk

CBandTrk::~CBandTrk()
{
    if (m_fCSInitialized)
    {
        m_MidiModeList.CleanUp();
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }

        DeleteCriticalSection(&m_CriticalSection);
    }

    InterlockedDecrement(&g_cComponent);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBandTrk::QueryInterface

STDMETHODIMP CBandTrk::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBandTrk::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    }
    else if(iid == IID_IDirectMusicBandTrk)
    {
        *ppv = static_cast<IDirectMusicBandTrk*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else
    {
        Trace(4,"Warning: Request to query unknown interface on Band Track object\n");
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddRef

STDMETHODIMP_(ULONG) CBandTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Release

STDMETHODIMP_(ULONG) CBandTrk::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CBandTrk::GetClassID( CLSID* pClassID )
{
    V_INAME(CBandTrk::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicBandTrack;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBandTrk::Load

STDMETHODIMP CBandTrk::Load(IStream* pIStream)
{
    V_INAME(CBandTrk::Load);
    V_PTR_READ(pIStream, IStream);

    HRESULT hrDLS = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    m_MidiModeList.CleanUp();
    // If we have been previously loaded, cleanup bands
    if(!BandList.IsEmpty())
    {
        m_bAutoDownload = true;
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }

        ++m_dwValidate;
    }

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if ((ckMain.ckid == FOURCC_RIFF) &&
            (ckMain.fccType == DMUS_FOURCC_BANDTRACK_FORM))
        {
            RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                case DMUS_FOURCC_BANDTRACK_CHUNK:
                    DMUS_IO_BAND_TRACK_HEADER ioDMBndTrkHdr;
                    hr = Parser.Read(&ioDMBndTrkHdr, sizeof(DMUS_IO_BAND_TRACK_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_bAutoDownload = ioDMBndTrkHdr.bAutoDownload ? true : false;
                        m_fLockAutoDownload = true;
                    }
                    break;
                case FOURCC_LIST:
                    switch(ckNext.fccType)
                    {
                    case  DMUS_FOURCC_BANDS_LIST:
                        hr = BuildDirectMusicBandList(&Parser);
                        if (hr != S_OK)
                        {
                            hrDLS = hr;
                        }
                        break;
                    }
                }
            }
            Parser.LeaveList();
        }
    }
    Parser.LeaveList();

    LeaveCriticalSection(&m_CriticalSection);

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

//////////////////////////////////////////////////////////////////////
// CBandTrk::Init

STDMETHODIMP CBandTrk::Init(IDirectMusicSegment* pSegment)
{
    V_INAME(CBandTrk::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    DWORD dwNumPChannels = 0;
    DWORD *pdwPChannels = NULL;

    EnterCriticalSection(&m_CriticalSection);

    CBand* pBand = BandList.GetHead();
    for(; pBand; pBand = pBand->GetNext())
    {
        dwNumPChannels += pBand->GetPChannelCount();
    }

    if(dwNumPChannels > 0)
    {
        pdwPChannels = new DWORD[dwNumPChannels];
        if(pdwPChannels)
        {
            pBand = BandList.GetHead();
            for(DWORD dwPos = 0; pBand; pBand = pBand->GetNext())
            {
                DWORD dwNumWritten;
                pBand->GetPChannels(pdwPChannels + dwPos, &dwNumWritten);
                dwPos += dwNumWritten;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            hr = pSegment->SetPChannelsUsed(dwNumPChannels, pdwPChannels);
        }

        delete [] pdwPChannels;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InitPlay

STDMETHODIMP CBandTrk::InitPlay(IDirectMusicSegmentState* pSegmentState,
                                           IDirectMusicPerformance* pPerformance,
                                           void** ppStateData,
                                           DWORD dwVirtualTrackID,
                                           DWORD dwFlags)
{
    V_INAME(CBandTrk::InitPlay);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);
    assert(ppStateData);

    EnterCriticalSection(&m_CriticalSection);

    CBandTrkStateData* pBandTrkStateData = new CBandTrkStateData;

    // If we can not allocate the memory we need to set ppStateData to NULL
    // and return S_OK since the caller always expects S_OK;
    *ppStateData = pBandTrkStateData;
    if(pBandTrkStateData == NULL)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return E_OUTOFMEMORY;
    }

    // Need to save State Data
    pBandTrkStateData->m_pSegmentState = pSegmentState;
    pBandTrkStateData->m_pPerformance = pPerformance;
    pBandTrkStateData->m_dwVirtualTrackID = dwVirtualTrackID; // Determines instance of Band Track

    CBand* pBand = BandList.GetHead();
    pBandTrkStateData->m_pNextBandToSPE = pBand;

    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerformance->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_bAutoDownload = fGlobal,
            // but that's bitten me before, so I'm being paranoid today. (markburt)
            if( fGlobal )
            {
                m_bAutoDownload = true;
            }
            else
            {
                m_bAutoDownload = false;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_bAutoDownload = false;
    }
    // Call SetParam to download all instruments used by the track's bands
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_bAutoDownload)
    {
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath)
        {
            SetParam(GUID_DownloadToAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else
        {
            SetParam(GUID_DownloadToAudioPath, 0, (void *)pPerformance);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::EndPlay

STDMETHODIMP CBandTrk::EndPlay(void* pStateData)
{
    assert(pStateData);

    EnterCriticalSection(&m_CriticalSection);

    // Call SetParam to unload all instruments used by the track's bands
    // This is the auto-unload feature that can be turned off with a call to SetParam
    if(m_bAutoDownload)
    {
        IDirectMusicPerformance *pPerformance = ((CBandTrkStateData *)pStateData)->m_pPerformance;
        IDirectMusicSegmentState *pSegmentState = ((CBandTrkStateData *)pStateData)->m_pSegmentState;
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath)
        {
            SetParam(GUID_UnloadFromAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else
        {
            SetParam(GUID_UnloadFromAudioPath, 0, (void *)pPerformance);
        }
    }

    if(pStateData)
    {
        delete ((CBandTrkStateData *)pStateData);
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::PlayEx

STDMETHODIMP CBandTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Play

STDMETHODIMP CBandTrk::Play(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID)
{
    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = PlayMusicOrClock(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    assert(pPerf);
    assert(pSegSt);
    assert(pStateData);

    // Caller expects S_OK or S_END. Since we have no state info we can not do anything
    if(pStateData == NULL)
    {
        return DMUS_S_END;
    }

    EnterCriticalSection(&m_CriticalSection);
    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        CBand* pBand = BandList.GetHead();
        DWORD dwGroupBits = 0xffffffff;
        IDirectMusicSegment* pSeg;
        if( SUCCEEDED(pSegSt->GetSegment(&pSeg)))
        {
            pSeg->GetTrackGroup(this, &dwGroupBits);
            pSeg->Release();
        }

        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->m_PChMap.Reset();
            pBand->m_dwGroupBits = dwGroupBits;
        }
    }

    CBandTrkStateData* pBandTrkStateData = (CBandTrkStateData *)pStateData;

    // Seek if we're starting, looping, or if we've been reloaded
    if ((dwFlags & DMUS_TRACKF_LOOP) || (dwFlags & DMUS_TRACKF_START) || (pBandTrkStateData->dwValidate != m_dwValidate))
    {
        // When we start playing a segment, we need to catch up with all the band changes
        // that happened before the start point.  The instruments that sound when we start
        // playing in the middle of a segment should sound the same as if we had played the
        // segment to that point from the beginning.
        pBandTrkStateData->m_fPlayPreviousInSeek = !!(dwFlags & DMUS_TRACKF_START);

        Seek(pBandTrkStateData, mtStart, mtOffset, rtOffset, fClockTime);

        pBandTrkStateData->dwValidate = m_dwValidate; // if we were reloading, we're now adjusted
    }

    // Send all Patch changes between mtStart & mtEnd
    // If any fail try next one
    CBand* pBand = (CBand *)(pBandTrkStateData->m_pNextBandToSPE);

    for( ; pBand && pBand->m_lTimeLogical < mtEnd;
            pBand = pBand->GetNext())
    {
        pBand->SendMessages(pBandTrkStateData, mtOffset, rtOffset, fClockTime);
    }

    // Save position for next time
    pBandTrkStateData->m_pNextBandToSPE = pBand;

    LeaveCriticalSection(&m_CriticalSection);

    return pBand == NULL ? DMUS_S_END : S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParam

STDMETHODIMP CBandTrk::GetParam(REFGUID rguidDataType,
                                           MUSIC_TIME mtTime,
                                           MUSIC_TIME* pmtNext,
                                           void* pData)
{
    V_INAME(CBandTrk::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_REFGUID(rguidDataType);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (rguidDataType == GUID_BandParam)
    {
        CBand* pScan = BandList.GetHead();
        if (pScan)
        {
            CBand* pBand = pScan;
            for (pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                if (mtTime < pScan->m_lTimeLogical) break;
                pBand = pScan;
            }
            // make a copy of the band found
            CBand *pNewBand = new CBand;

            if (pNewBand)
            {
                CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                {
                    hr = pNewBand->Load(pBandInstrument);
                }
                if (FAILED(hr))
                {
                    // Don't leak.
                    delete pNewBand;
                }
                else
                {
                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                IDirectMusicBand* pIDMBand = NULL;
                pNewBand->QueryInterface(IID_IDirectMusicBand, (void**)&pIDMBand);
                // The constructor initialized the ref countto 1, so release the QI
                pNewBand->Release();
                DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
                pBandParam->pBand = pIDMBand;
                pBandParam->mtTimePhysical = pBand->m_lTimePhysical;
                if (pmtNext)
                {
                    *pmtNext = (pScan != NULL) ? pScan->m_lTimeLogical : 0;
                }
                hr = S_OK;
            }
        }
        else
        {
            Trace(4,"Warning: Band Track unable to find Band for GetParam call.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParam

STDMETHODIMP CBandTrk::SetParam(REFGUID rguidDataType,
                                           MUSIC_TIME mtTime,
                                           void* pData)
{
    V_INAME(CBandTrk::SetParam);
    V_REFGUID(rguidDataType);

    HRESULT hr = S_OK;

    if((pData == NULL)
       && (rguidDataType != GUID_Enable_Auto_Download)
       && (rguidDataType != GUID_Disable_Auto_Download)
       && (rguidDataType != GUID_Clear_All_Bands)
       && (rguidDataType != GUID_IgnoreBankSelectForGM))
    {
        Trace(1,"Error: Invalid NULL pointer passed to Band Track for SetParam call.\n");
        return E_POINTER;
    }

    EnterCriticalSection(&m_CriticalSection);

    if(rguidDataType == GUID_DownloadToAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (FAILED(hr = pBand->DownloadEx(pPath))) // If not S_OK, download is only partial.
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            hr = S_FALSE;
        }
    }
    else if(rguidDataType == GUID_UnloadFromAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPath);
        }
    }
    else if(rguidDataType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (pBand->DownloadEx(pPerf) != S_OK) // If not S_OK, download is only partial.
            {
                hr = S_FALSE;
            }
        }
    }
    else if(rguidDataType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPerf);
        }
    }
    else if(rguidDataType == GUID_Enable_Auto_Download)
    {
        m_bAutoDownload = true;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Disable_Auto_Download)
    {
        m_bAutoDownload = false;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Clear_All_Bands)
    {
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }
    }
    else if(rguidDataType == GUID_BandParam)
    {
        DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
        IDirectMusicBand *pBand = pBandParam->pBand;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate
        // pBand is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);

        if(FAILED(hr))
        {
            LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }

        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandParam->mtTimePhysical;

        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IDirectMusicBand)
    {
        IDirectMusicBand *pBand = (IDirectMusicBand *)pData;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate
        // pData is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);

        if(FAILED(hr))
        {
            LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }

        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandObject->m_lTimeLogical;

        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IgnoreBankSelectForGM)
    {
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->MakeGMOnly();
        }
    }
    else if(rguidDataType == GUID_ConnectToDLSCollection)
    {
        IDirectMusicCollection* pCollect = (IDirectMusicCollection*)pData;
        V_INTERFACE(pData);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->ConnectToDLSCollection(pCollect);
        }
    }
    else
    {
        Trace(3,"Warning: Invalid SetParam call on Band Track, GUID is unknown.\n");
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParamEx

STDMETHODIMP CBandTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParamEx

STDMETHODIMP CBandTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime, pParam);
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::IsParamSupported

STDMETHODIMP CBandTrk::IsParamSupported(REFGUID rguidDataType)
{
    V_INAME(CBandTrk::IsParamSupported);
    V_REFGUID(rguidDataType);

    // Return S_OK if the object supports the GUID and S_FALSE otherwise
    if(rguidDataType == GUID_Download ||
       rguidDataType == GUID_Unload ||
       rguidDataType == GUID_DownloadToAudioPath ||
       rguidDataType == GUID_UnloadFromAudioPath ||
       rguidDataType == GUID_Enable_Auto_Download ||
       rguidDataType == GUID_Disable_Auto_Download ||
       rguidDataType == GUID_Clear_All_Bands ||
       rguidDataType == GUID_IDirectMusicBand ||
       rguidDataType == GUID_BandParam ||
       rguidDataType == GUID_IgnoreBankSelectForGM ||
       rguidDataType == GUID_ConnectToDLSCollection)
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddNotificationType

STDMETHODIMP CBandTrk::AddNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::RemoveNotificationType

STDMETHODIMP CBandTrk::RemoveNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Clone

STDMETHODIMP CBandTrk::Clone(MUSIC_TIME mtStart,
                                        MUSIC_TIME mtEnd,
                                        IDirectMusicTrack** ppTrack)
{
    V_INAME(CBandTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    if ((mtStart < 0 ) || (mtStart > mtEnd))
    {
        Trace(1,"Error: Invalid range %ld to %ld sent to Band Track Clone command.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicBandTrk *pBandTrack = NULL;
    CBandTrk *pNew = new CBandTrk;
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_IDirectMusicBandTrk,(void**)&pBandTrack);
        if(SUCCEEDED(hr))
        {
            hr = LoadClone(pBandTrack, mtStart, mtEnd);
            if(SUCCEEDED(hr))
            {
                hr = pBandTrack->QueryInterface(IID_IDirectMusicTrack, (void **)ppTrack);
                if (SUCCEEDED(hr))
                {
                    pBandTrack->Release();
                }
            }
            pBandTrack->Release();
        }
        if (FAILED(hr))
        {
            delete pNew;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicCommon

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetName

STDMETHODIMP CBandTrk::GetName(BSTR* pbstrName)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand

STDMETHODIMP CBandTrk::AddBand(DMUS_IO_PATCH_ITEM* pPatchEvent)
{
    if(pPatchEvent == NULL)
    {
        return E_POINTER;
    }

    CBand *pNewBand = new CBand;

    HRESULT hr;

    if(pNewBand == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNewBand->Load(*pPatchEvent);
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertBand(pNewBand);
    }

    if(FAILED(hr) && pNewBand)
    {
        delete pNewBand;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand

HRESULT CBandTrk::AddBand(IDirectMusicBand* pIDMBand)
{
    if(pIDMBand == NULL)
    {
        return E_POINTER;
    }

    // If you can QI pIDMBand for private interface IDirectMusicBandPrivate
    // pIDMBand is of type CBand.
    IDirectMusicBandPrivate* pIDMBandP = NULL;
    HRESULT hr = pIDMBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);

    if(SUCCEEDED(hr))
    {
        pIDMBandP->Release();

        CBand *pNewBand = (CBand *) pIDMBand;
        pNewBand->AddRef();

        hr = InsertBand(pNewBand);

        if(FAILED(hr))
        {
            pNewBand->Release();
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBandTrk::BuildDirectMusicBandList
// This method loads all of the bands.

HRESULT CBandTrk::BuildDirectMusicBandList(CRiffParser *pParser)
{
    RIFFIO ckNext;

    HRESULT hrDLS = S_OK;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST :
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_LIST:
                hr = ExtractBand(pParser);
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        }
    }
    pParser->LeaveList();
    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::ExtractBand

HRESULT
CBandTrk::ExtractBand(CRiffParser *pParser)
{
    HRESULT hrDLS = S_OK;

    RIFFIO ckNext;
    CBand *pBand = new CBand;
    if(pBand == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    bool fFoundChunk2 = false;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_BANDITEM_CHUNK2:
            fFoundChunk2 = true;
            DMUS_IO_BAND_ITEM_HEADER2 ioDMBndItemHdr2;
            hr = pParser->Read(&ioDMBndItemHdr2, sizeof(DMUS_IO_BAND_ITEM_HEADER2));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr2.lBandTimeLogical;
                pBand->m_lTimePhysical = ioDMBndItemHdr2.lBandTimePhysical;
            }
            break;
        case DMUS_FOURCC_BANDITEM_CHUNK:
            // if there is both a CHUNK and a CHUNK2, use the info from CHUNK2
            if (fFoundChunk2)
                break;
            DMUS_IO_BAND_ITEM_HEADER ioDMBndItemHdr;
            hr = pParser->Read(&ioDMBndItemHdr, sizeof(DMUS_IO_BAND_ITEM_HEADER));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr.lBandTime;
                pBand->m_lTimePhysical = pBand->m_lTimeLogical;
            }
            break;
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_FORM:
                pParser->SeekBack();
                hr = LoadBand(pParser->GetStream(), pBand);
                pParser->SeekForward();
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        default:
            break;

        }

    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        hr = AddBand(pBand);
    }

    pBand->Release();

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadBand

HRESULT CBandTrk::LoadBand(IStream *pIStream, CBand* pBand)
{
    assert(pIStream);
    assert(pBand);

    IPersistStream *pIPersistStream = NULL;

    HRESULT hr = pBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pIStream);
        pIPersistStream->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadClone

HRESULT CBandTrk::LoadClone(IDirectMusicBandTrk* pBandTrack,
                                       MUSIC_TIME mtStart,
                                       MUSIC_TIME mtEnd)
{
    assert(pBandTrack);
    assert(mtStart <= mtEnd);

    EnterCriticalSection(&m_CriticalSection);

    HRESULT hr = S_OK;

    if (mtStart > 0)
    {
        // We will take all the bands before the start time and create a single new band
        // at logical time zero, physical time either -1 or one tick before the physical time
        // of the first band after the start time, that accumulates all the instrument changes
        // from the earlier bands.

        TList<SeekEvent> SEList; // Build a list of all the instrument changes for the new band
        DWORD dwLastMidiMode = 0; // Keep track of the MIDI mode of the last band we encounter

        for( CBand* pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            for(CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
                    pInstrument && SUCCEEDED(hr);
                    pInstrument = pInstrument->GetNext())
            {
                // replace if we already have an entry on that channel
                hr = FindSEReplaceInstr(SEList,
                                        pInstrument->m_dwPChannel,
                                        pInstrument);

                // otherwise add an entry
                if(hr == S_FALSE)
                {
                    TListItem<SeekEvent>* pSEListItem = new TListItem<SeekEvent>;
                    if(pSEListItem)
                    {
                        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                        rSeekEvent.m_dwPChannel = pInstrument->m_dwPChannel;
                        rSeekEvent.m_pInstrument = pInstrument;
                        rSeekEvent.m_pParentBand = pBand;
                        dwLastMidiMode = pBand->m_dwMidiMode;
                        SEList.AddHead(pSEListItem);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        // Make sure the physical time of the new band is less than any bands being cloned.
        MUSIC_TIME mtNewPhysicalTime = -1;
        if (pBand && pBand->m_lTimePhysical <= mtStart)
        {
            mtNewPhysicalTime = (pBand->m_lTimePhysical - mtStart) - 1;
        }

        // Create the new band from the instrument list
        TListItem<SeekEvent>* pSEListItem = SEList.GetHead();
        if(SUCCEEDED(hr) && pSEListItem)
        {
            CBand *pNewBand = new CBand;

            if(pNewBand)
            {
                for(; pSEListItem && SUCCEEDED(hr); pSEListItem = pSEListItem->GetNext())
                {
                    SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                    hr = pNewBand->Load(rSeekEvent.m_pInstrument);
                }

                pNewBand->m_lTimeLogical = 0;
                pNewBand->m_lTimePhysical = mtNewPhysicalTime;
                pNewBand->m_dwFlags |= DMB_LOADED;
                pNewBand->m_dwMidiMode = dwLastMidiMode;

                if(SUCCEEDED(hr))
                {
                    hr = pBandTrack->AddBand(pNewBand);
                }

                pNewBand->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Copy all the bands between the start and the end time
    if(SUCCEEDED(hr))
    {
        for(CBand* pBand = BandList.GetHead();
                pBand && SUCCEEDED(hr);
                pBand = pBand->GetNext())
        {
            // If mtStart is 0, accept bands with negative times.
            if ((!mtStart || (pBand->m_lTimeLogical >= mtStart)) && pBand->m_lTimeLogical < mtEnd)
            {
                CBand *pNewBand = new CBand;

                if (pNewBand)
                {
                    CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                    for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                    {
                        hr = pNewBand->Load(pBandInstrument);
                    }

                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical - mtStart;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical - mtStart;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

                    if(SUCCEEDED(hr))
                    {
                        hr = pBandTrack->AddBand(pNewBand);
                    }

                    pNewBand->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Seek

HRESULT CBandTrk::Seek(CBandTrkStateData* pBandTrkStateData,
                       MUSIC_TIME mtStart,
                       MUSIC_TIME mtOffset,
                       REFERENCE_TIME rtOffset,
                       bool fClockTime)
{
    assert(pBandTrkStateData);

    EnterCriticalSection(&m_CriticalSection);

    HRESULT hr = S_OK;

    CBand *pBand;

    int iPrevBandCount = 0; // count how many bands before mtStart
    for (pBand = BandList.GetHead();
            pBand && pBand->m_lTimeLogical < mtStart;
            pBand = pBand->GetNext())
    {
        ++iPrevBandCount;
    }

    // pBand now holds the first band >= mtStart (or NULL if none)
    // This is the next band that will be played.
    assert(!pBand || pBand->m_lTimeLogical >= mtStart);

    if (pBandTrkStateData->m_fPlayPreviousInSeek)
    {
        // When this flag is on not only do we need to find the first band, but we also
        // need to play all the bands before the start point and schedule them to play
        // in the correct order just beforehand.

        // (Note that we're going to order them according to their logical times.  If
        //  two bands's logical/physical times cross each other we'll play them in
        //  incorrect order in terms of physical time.  That's OK because giving
        //  band A with a logical time before band B, yet giving A a physical time
        //  after B is considered an authoring inconsistency.  We'll play band A first.)

        // We will line up the bands just before the following time...
        MUSIC_TIME mtPrevBandQueueStart =
            (pBand && pBand->m_lTimePhysical < mtStart)
                ? pBand->m_lTimePhysical    // put previous bands before next band to play if (due to anticipation) its physical time precedes the start time we're seeking
                : mtStart;                  // otherwise put them just before the start time

        for (pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
            for (; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
            {
                pBand->SendInstrumentAtTime(pInstrument, pBandTrkStateData, mtPrevBandQueueStart - iPrevBandCount, mtOffset, rtOffset, fClockTime);
            }
            --iPrevBandCount;
        }
        assert(iPrevBandCount == 0);
    }

    if(SUCCEEDED(hr))
    {
        // Set the state data to the next band to play
        assert(!pBand || pBand->m_lTimeLogical >= mtStart);
        pBandTrkStateData->m_pNextBandToSPE = pBand;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::FindSEReplaceInstr

// If SEList contains an entry on channel dwPChannel, replace the instrument with pInstrument and return S_OK
// Otherwise return S_FALSE
HRESULT CBandTrk::FindSEReplaceInstr(TList<SeekEvent>& SEList,
                                                DWORD dwPChannel,
                                                CBandInstrument* pInstrument)
{
    assert(pInstrument);

    EnterCriticalSection(&m_CriticalSection);

    TListItem<SeekEvent>* pSEListItem = SEList.GetHead();

    for( ; pSEListItem; pSEListItem = pSEListItem->GetNext())
    {
        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
        if(rSeekEvent.m_dwPChannel == dwPChannel)
        {
            rSeekEvent.m_pInstrument = pInstrument;
            LeaveCriticalSection(&m_CriticalSection);
            return S_OK;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InsertBand

HRESULT CBandTrk::InsertBand(CBand* pNewBand)
{
    if (!pNewBand) return E_POINTER;

    EnterCriticalSection(&m_CriticalSection);

    TListItem<StampedGMGSXG>* pPair = m_MidiModeList.GetHead();
    for ( ; pPair; pPair = pPair->GetNext() )
    {
        StampedGMGSXG& rPair = pPair->GetItemValue();
        if (rPair.mtTime > pNewBand->m_lTimeLogical)
        {
            break;
        }
        pNewBand->SetGMGSXGMode(rPair.dwMidiMode);
    }

    CBand* pBand = BandList.GetHead();
    CBand* pPrevBand = NULL;

    if(pBand == NULL)
    {
        // Handles case where there is no band in the list
        BandList.AddHead(pNewBand);
    }
    else
    {
        while(pBand != NULL && pNewBand->m_lTimeLogical > pBand->m_lTimeLogical)
        {
            pPrevBand = pBand;
            pBand = pBand->GetNext();
        }

        if(pPrevBand)
        {
            // Handles the cases of inserting a band in the middle of list
            // and at the end
            CBand* pTemp = pPrevBand->GetNext();
            pPrevBand->SetNext(pNewBand);
            pNewBand->SetNext(pTemp);
        }
        else
        {
            // Handles case where pNewBand->m_lTimeLogical < all pBand->m_lTimeLogical in list
            BandList.AddHead(pNewBand);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}


STDMETHODIMP CBandTrk::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBandTrk::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CBandTrk*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CBandTrk* pOtherTrack = (CBandTrk*)pNewTrack;
    for(CBand* pBand = pOtherTrack->BandList.GetHead();
            pBand && SUCCEEDED(hr);
            pBand = pBand->GetNext())
    {
        CBand *pNewBand = new CBand;
        if (pNewBand)
        {
            CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
            for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pNewBand->Load(pBandInstrument);
            }

            pNewBand->m_lTimeLogical = pBand->m_lTimeLogical + mtJoin;
            pNewBand->m_lTimePhysical = pBand->m_lTimePhysical + mtJoin;
            pNewBand->m_dwFlags |= DMB_LOADED;
            pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

            if(SUCCEEDED(hr))
            {
                hr = AddBand(pNewBand);
            }

            pNewBand->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMBAND"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\bandtrk.h ===
//
// bandtrk.h
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//

#ifndef BANDTRK_H
#define BANDTRK_H

#include "dmbndtrk.h"
#include "dmbandp.h"

class SeekEvent;

struct IDirectMusicPerformance;
class CRiffParser;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

class CBandTrk : public IDirectMusicTrack8, public IDirectMusicBandTrk, public IPersistStream
{
    friend CBand;
public:
	// IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistStream
    STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack
	STDMETHODIMP Init(IDirectMusicSegment* pSegment);

	STDMETHODIMP InitPlay(IDirectMusicSegmentState* pSegmentState,
						  IDirectMusicPerformance* pPerformance,
						  void** ppStateData,
						  DWORD dwVirtualTrackID,
                          DWORD dwFlags);

	STDMETHODIMP EndPlay(void* pStateData);

	STDMETHODIMP Play(void* pStateData,
					  MUSIC_TIME mtStart,
					  MUSIC_TIME mtEnd,
					  MUSIC_TIME mtOffset,
					  DWORD dwFlags,
					  IDirectMusicPerformance* pPerf, 
					  IDirectMusicSegmentState* pSegSt, 
					  DWORD dwVirtualID);

	STDMETHODIMP GetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 MUSIC_TIME* pmtNext,
						 void* pData);

	STDMETHODIMP SetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 void* pData);
	
	STDMETHODIMP IsParamSupported(REFGUID rguidDataType);

	STDMETHODIMP AddNotificationType(REFGUID rguidNotify);

	STDMETHODIMP RemoveNotificationType(REFGUID rguidNotify);

	STDMETHODIMP Clone(	MUSIC_TIME mtStart,
						MUSIC_TIME mtEnd,
						IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

	// IDirectMusicCommon
	STDMETHODIMP GetName(BSTR* pbstrName);

	// IDirectMusicBandTrk (Private Interface)
	STDMETHODIMP AddBand(DMUS_IO_PATCH_ITEM* BandEvent);
	STDMETHODIMP AddBand(IDirectMusicBand* pIDMBand);
	STDMETHODIMP SetGMGSXGMode(MUSIC_TIME mtTime, DWORD dwMidiMode)
	{
		TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
		if (!pPair) return E_OUTOFMEMORY;
		pPair->GetItemValue().mtTime = mtTime;
		pPair->GetItemValue().dwMidiMode = dwMidiMode;

		TListItem<StampedGMGSXG>* pScan = m_MidiModeList.GetHead();
		TListItem<StampedGMGSXG>* pPrev = NULL;
		
		if(!pScan)
		{
			// Empty list
			m_MidiModeList.AddHead(pPair);
		}
		else
		{
			while(pScan && pPair->GetItemValue().mtTime > pScan->GetItemValue().mtTime)
			{
				pPrev = pScan;
				pScan = pScan->GetNext();
			}	
			
			if(pPrev)
			{
				// Insert in the middle or end of list
				pPair->SetNext(pScan);
				pPrev->SetNext(pPair);
			}
			else
			{
				// Insert at beginning
				m_MidiModeList.AddHead(pPair);
			}
		}

		CBand* pBand = BandList.GetHead();
		for(; pBand; pBand = pBand->GetNext())
		{
			// only set bands affected by new mode
			if ( (pBand->m_lTimeLogical >= pPair->GetItemValue().mtTime) &&
				 ( !pScan || pBand->m_lTimeLogical < pScan->GetItemValue().mtTime) )
			{
				pBand->SetGMGSXGMode(dwMidiMode);
			}
		}
		return S_OK;
	}

	// Class
	CBandTrk();
	~CBandTrk();

private:
	HRESULT BuildDirectMusicBandList(CRiffParser *pParser);
	

	HRESULT  ExtractBand(CRiffParser *pParser);

	HRESULT LoadBand(IStream *pIStream, CBand* pBand);

	HRESULT LoadClone(IDirectMusicBandTrk* pBandTrack,
					  MUSIC_TIME mtStart, 
					  MUSIC_TIME mtEnd);

	HRESULT InsertBand(CBand* pNewBand);
	HRESULT Seek(CBandTrkStateData* pBandTrkStateData,
				 MUSIC_TIME mtStart, 
				 MUSIC_TIME mtOffset,
				 REFERENCE_TIME rtOffset,
				 bool fClockTime);

	HRESULT FindSEReplaceInstr(TList<SeekEvent>& SEList,
							   DWORD dwPChannel,
							   CBandInstrument* pInstrument);

	// Shared implentation of play for either music or clock time.
    HRESULT PlayMusicOrClock(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        bool fClockTime);

	HRESULT CBandTrk::JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

private:
	CRITICAL_SECTION m_CriticalSection;
    BOOL m_fCSInitialized;
	DWORD m_dwValidate; // used to validate state data
	CBandList BandList;
	bool m_bAutoDownload;
	bool m_fLockAutoDownload; // if true, this flag indicates that we've specifically
								// commanded the band to autodownload. Otherwise,
								// it gets its preference from the performance via
								// GetGlobalParam.
	DWORD m_dwFlags;
	TList<StampedGMGSXG> m_MidiModeList; // List of time-stamped midi mode messages
	long m_cRef;
};

//////////////////////////////////////////////////////////////////////
// Class BandTrkStateData

class CBandTrkStateData
{
public: 
	CBandTrkStateData() : 
	m_pSegmentState(NULL),
	m_pPerformance(NULL),
	m_pNextBandToSPE(NULL),
	m_fPlayPreviousInSeek(FALSE),
	m_dwVirtualTrackID(0),
	dwValidate(0){}

	~CBandTrkStateData(){}

public:		
	IDirectMusicSegmentState*	m_pSegmentState;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicBand*			m_pNextBandToSPE;
	DWORD						m_dwVirtualTrackID;
	BOOL						m_fPlayPreviousInSeek;
	DWORD						dwValidate;
};

//////////////////////////////////////////////////////////////////////
// Class SeekEvent

class SeekEvent
{
public:
	SeekEvent() :
	m_pParentBand(NULL),
	m_pInstrument(NULL),
	m_dwPChannel(0) {}
	
	~SeekEvent(){}

public:
	CBand*	m_pParentBand;
	CBandInstrument*	m_pInstrument;
	DWORD				m_dwPChannel;
};

#endif // #ifndef BANDTRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\dmbndtrk.h ===
/*
   dmbndtrk.h
   
   Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.

   Note: Contains private interfaces support by objects contained within 
		 dmband.dll. Originally written by Robert K. Amenn 
*/

#ifndef DMBNDTRK_H
#define DMBNDTRK_H

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

struct IDirectMusicBand;

typedef struct _DMUS_IO_PATCH_ITEM
{
    MUSIC_TIME                  lTime;
    BYTE                        byStatus;
    BYTE                        byPChange;
    BYTE                        byMSB;
    BYTE                        byLSB;
    DWORD                       dwFlags;
	BOOL						fNotInFile; // set to true if this patch item was automatically generated
    IDirectMusicCollection*     pIDMCollection;
    struct _DMUS_IO_PATCH_ITEM* pNext;  
} DMUS_IO_PATCH_ITEM;

typedef enum enumDMUS_MIDIMODEF_FLAGS
{       
    DMUS_MIDIMODEF_GM = 0x1,
    DMUS_MIDIMODEF_GS = 0x2,
    DMUS_MIDIMODEF_XG = 0x4,
} DMUS_MIDIMODEF_FLAGS;

struct StampedGMGSXG
{
	MUSIC_TIME mtTime;
	DWORD dwMidiMode;
};

/* Private Interface IDirectMusicBandTrk */

interface IDirectMusicBandTrk;

#ifndef __cplusplus 
typedef interface IDirectMusicBandTrk IDirectMusicBandTrk;
#endif

typedef IDirectMusicBandTrk __RPC_FAR *LPDIRECTMUSICBANDTRK;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandTrk
DECLARE_INTERFACE_(IDirectMusicBandTrk, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandTrk */
	STDMETHOD(AddBand)				(THIS_ DMUS_IO_PATCH_ITEM*) PURE;
	STDMETHOD(AddBand)				(THIS_ IDirectMusicBand* pIDMBand) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ MUSIC_TIME mtTime, DWORD dwMidiMode) PURE;
};

/* Private Interface IDirectMusicBandPrivate */

interface IDirectMusicBandPrivate;

#ifndef __cplusplus 
typedef interface IDirectMusicBandPrivate IDirectMusicBandPrivate;
#endif

typedef IDirectMusicBandPrivate __RPC_FAR *LPDIRECTMUSICBANDP;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandPrivate 
DECLARE_INTERFACE_(IDirectMusicBandPrivate, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandPrivate */
	STDMETHOD(GetFlags)				(THIS_ DWORD* dwFlags) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ DWORD dwMidiMode) PURE;
};

DEFINE_GUID(IID_IDirectMusicBandTrk, 0x53466056, 0x6dc4, 0x11d1, 0xbf, 0x7b, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(IID_IDirectMusicBandPrivate,0xda54db81, 0x837d, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef DMBNDTRK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\dmband.cpp ===
//
// dmband.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//

#define INITGUID
#include <objbase.h>

#include "debug.h"
#include "dmksctrl.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "..\shared\dmstrm.h"
#include "dmbandp.h"
#include "bandtrk.h"
#include "debug.h"

#define MAX_LEGACY_BAND_NAME 20
#define MAX_LEGACY_COLLECTION_NAME 32

extern long g_cComponent;

static GUID nullGUID = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

//////////////////////////////////////////////////////////////////////
// Class CBand

//////////////////////////////////////////////////////////////////////
// CBand::CBand

CBand::CBand() 
{
    m_lTimeLogical = 0;
    m_lTimePhysical = 0;
    m_dwFlags = 0;
    m_dwGroupBits = 0xffffffff;
    m_dwMidiMode = 0;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
    InterlockedIncrement(&g_cComponent);
    // Do this first since it can throw an exception
    //
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
    m_dwValidData = 0;
}

//////////////////////////////////////////////////////////////////////
// CBand::~CBand

CBand::~CBand()
{
    if (m_fCSInitialized)
    {
        m_BandInstrumentList.Clear();
        DeleteCriticalSection(&m_CriticalSection);  
    }
    
    InterlockedDecrement(&g_cComponent);
}

void CBandInstrumentList::Clear()

{
    CBandInstrument* pBandInstrument;
    while(pBandInstrument = RemoveHead())
    {
        delete pBandInstrument;
    }
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBand::QueryInterface

STDMETHODIMP 
CBand::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBand::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;

    if(iid == IID_IUnknown || iid == IID_IDirectMusicBand)
    {
        *ppv = static_cast<IDirectMusicBand*>(this);
    } 
    else if(iid == IID_IDirectMusicBandP)
    {
        *ppv = static_cast<IDirectMusicBandP*>(this);
    }
    else if(iid == IID_IDirectMusicBandPrivate)
    {
        *ppv = static_cast<IDirectMusicBandPrivate*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::AddRef

STDMETHODIMP_(ULONG)
CBand::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBand::Release

STDMETHODIMP_(ULONG)
CBand::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBand::Load

STDMETHODIMP CBand::Load(IStream* pStream)
{
    V_INAME(CBand::Load);
    V_PTR_READ(pStream, IStream);

    // Get the loader from stream if it has one
    // so we can open required collections
    IDirectMusicLoader* pIDMLoader = NULL;
    IDirectMusicGetLoader *pIDMGetLoader = NULL;
    
    if (SUCCEEDED(pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pIDMGetLoader)))
    {
        pIDMGetLoader->GetLoader(&pIDMLoader);
        pIDMGetLoader->Release();
    }
    else
    {
        Trace(1,"Error: Band unable to reference DLS Collections because IStream does not support Loader.\n");
        return DMUS_E_UNSUPPORTED_STREAM;
    }

    EnterCriticalSection(&m_CriticalSection);

    // If we have been previously loaded, clean up instruments
    if(m_dwFlags & DMB_LOADED)
    {
        m_dwValidData = 0;
        m_BandInstrumentList.Clear();
        m_lTimeLogical = 0;
        m_lTimePhysical = 0;
        m_dwFlags = 0;
    }

    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == FOURCC_BAND_FORM)
        {
            hr = LoadLegacyBand(&Parser, pIDMLoader);       
        }
        else if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
        {
            hr = LoadDirectMusicBand(&Parser, pIDMLoader);
        }
        else
        {
            Trace(1,"Error: Failure Parsing Band - invalid chunk ID.\n");
            hr = DMUS_E_INVALID_BAND;
        }
    }
    
    if(FAILED(hr))
    {
        m_BandInstrumentList.Clear();
    }
    
    if(pIDMLoader)
    {
        pIDMLoader->Release();
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBand

//////////////////////////////////////////////////////////////////////
// CBand::CreateSegment

STDMETHODIMP CBand::CreateSegment(IDirectMusicSegment** ppSegment)   
{
    V_INAME(IDirectMusicBand::CreateSegment);
    V_PTRPTR_WRITE(ppSegment);

    HRESULT hr = CoCreateInstance(CLSID_DirectMusicSegment,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicSegment,
                                  (void**)ppSegment);

    if(SUCCEEDED(hr))
    {
        IDirectMusicTrack* pDMTrack = NULL;
        CBandTrk *pBandTrack;

        // Create Band track

        pBandTrack = new CBandTrk;

        if (pBandTrack)
        {
            pBandTrack->QueryInterface(IID_IDirectMusicTrack,(void**)&pDMTrack);
            // Add band to track
            m_lTimePhysical--; // Subtract one from the time when creating the segment.  This is somewhat arbitrary.  (See NT5 bug 226848.)
            hr = pBandTrack->AddBand(static_cast<IDirectMusicBand*>(this));
            m_lTimePhysical++; // add the one back in
            // Set Auto-download to off
            pBandTrack->m_bAutoDownload = false;
            pBandTrack->m_fLockAutoDownload = true;

            // Insert track into segment
            hr = (*ppSegment)->InsertTrack(pDMTrack, 1);
            pDMTrack->Release();
            pBandTrack->Release(); // We don't need the original count created by the constructor.
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(FAILED(hr))
    {
        if(*ppSegment)
        {
            (*ppSegment)->Release();
            *ppSegment = NULL;
        }
    }

    return hr;
}


HRESULT CBandInstrument::Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMidiMode)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be downloading to. 
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;
    BOOL fDownload = TRUE;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    // Once we know the port, we can find out whether a download has
    // already occured. And, if not, we'll use that to do the download.
    if (SUCCEEDED(hr))
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
            if (pDLInstrument->m_pPort == pPort)
            {
                // Increment reference counter and leave.
                pDLInstrument->m_cRef++;
                pPort->Release();
                return S_OK;
            }
        }

        // Okay, didn't find it, so we need to create a download record and download it. 

        if(m_fNotInFile && !m_fGMOnly)
        {
            // Unless we've set the GMOnly flag, don't download an instrument 
            // that was automatically generated from the midi
            // parsing to give a patchless channel an instrument.
            fDownload = FALSE;
        }

        else if (m_pIDMCollection == NULL)
        {
            // Can not download this instrument but still want to add a record and continue with others.
            // If instrument is a GM and GS instrument it may still play if GM or GS is supported in hardware.
            fDownload = FALSE;
            Trace(2,"Warning: No collection, unable to download instrument %lx on PChannel %ld\n",m_dwPatch,m_dwPChannel);
        }

        if (m_dwFlags & DMUS_IO_INST_GS)
        {
            // If this is a GS instrument, determine whether it needs to be downloaded.
            if ((dwGMFlags & DM_PORTFLAGS_GM) && (m_dwFlags & DMUS_IO_INST_GM))
            {
                // The synth has a GM set in ROM, and this is a GM instrument,
                // and the instrument does not specifically requests that it use the
                // DLS version in gm.dls.
                if (!(m_dwFlags & DMUS_IO_INST_USE_DEFAULT_GM_SET) )
                {
                    fDownload = FALSE;
                }
            }
            else if (dwGMFlags & DM_PORTFLAGS_GS)
            {
                // If the synth has a GS set, the problem is simpler, since it is going to be very similar to our 
                // gm.dls set, so it is okay to use it.
                fDownload = FALSE;
            }
        }

        if( dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
        {
            // if we're not an XG file, make sure channel 9 is drums
            if( (dwMidiMode != DMUS_MIDIMODEF_XG) &&
                (m_dwPChannel == 9) )
            {
                m_dwPatch |= 0x80000000;
            }
        }

        // Okay, ready to download...

        if (fDownload)
        {
            hr = DownloadAddRecord(pPort);
            // Use fallbacks for XG mode
            if( FAILED(hr) && dwMidiMode == DMUS_MIDIMODEF_XG )
            {
                DWORD dwOldPatch = m_dwPatch;
                DWORD dwOldFlags = m_dwFlags;
                DWORD dwOldAssignPatch = m_dwAssignPatch;
                // If this band failed, try clearing the MSB. If it was an XG or GS instrument,
                // and the collection doesn't have the instrument, clearing the MSB is a
                // good fallback. If that doesn't work, try clearing the LSB.
                // Also, if this band is XG see if it is on the drum channel. If so, 
                // try setting the drum bit.
                if( (m_dwPatch & 0x00ff0000) == 0x007f0000 )
                {
                    // XG drums. Try GM drums instead, but keep program change
                    m_dwPatch &= 0xff0000ff; // clear MSB and LSB
                    m_dwPatch |= 0x80000000; // set drum bit
                    m_dwFlags |= DMUS_IO_INST_ASSIGN_PATCH;
                    m_dwAssignPatch = dwOldPatch & 0x00ffffff;
                    hr = DownloadAddRecord(pPort);
                    if( FAILED(hr) )
                    {
                        // If that didn't work, try unsetting the program change
                        m_dwPatch = 0x80000000;
                        hr = DownloadAddRecord(pPort);
                    }
                }
                else
                {
                    if( (m_dwPatch & 0x00ff0000) != 0x007e0000 )
                    {
                        m_dwPatch &= 0xffff00ff; // clear LSB
                        hr = DownloadAddRecord(pPort);
                        if( FAILED(hr) )
                        {
                            if( m_dwPatch & 0x0000ff00 )
                            {
                                m_dwPatch &= 0xff0000ff; // clear MSB & LSB
                                hr = DownloadAddRecord(pPort);
                            }
                        }
                    }
                }
                if (FAILED(hr))
                {
                    // Revert back to original values
                    m_dwPatch = dwOldPatch;
                    m_dwFlags = dwOldFlags;
                    m_dwAssignPatch = dwOldAssignPatch;
                }
            }
        }
        pPort->Release();
    }
    else
    {
        Trace(1,"Error: Unable to download to Performance because pchannel %ld is not initialized on the performance.\n",m_dwPChannel);
    }
    return hr;
}



//////////////////////////////////////////////////////////////////////
// CBand::DownloadEx

STDMETHODIMP
CBand::DownloadEx(IUnknown *pAudioPath)  
{
    V_INAME(CBand::DownloadEx);
    V_PTR_READ(pAudioPath, IUnknown);
    BOOL fGotOneDown = FALSE;
    BOOL fNoInit = FALSE;
    IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    // If the band doesn't have any instruments, return immediately with S_FALSE.
    if (m_BandInstrumentList.IsEmpty())
    {
        Trace(2,"Warning: Trying to download an empty band\n");
        return S_FALSE;
    }
    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
        hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
            DWORD dwSuccess = 0;
            HRESULT hrTemp = S_OK;
            CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
            for( ; SUCCEEDED(hr) && pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pBandInstrument->Download(pPerfp,pPath,m_dwMidiMode);
                if (FAILED(hr))
                {
                    if (hr == DMUS_E_NOT_INIT)
                    {
                        Trace(1,"Error: Performance is not initialized - Band download terminated.\n");
                        // Performance is not initialized. Leave now.
                        break;
                    }
                    hrTemp = hr;
                    hr = S_FALSE;
                }
                else
                {
                    // At least one succeeded.
                    dwSuccess++;
                }
            }
            // If we had a failure but it was not performance not initialized and we did have at least one
            // successful download, return a partial download success code.
            if (FAILED(hrTemp))
            {
                // Was this a partial download?
                if ((hr != DMUS_E_NOT_INIT) &&  dwSuccess)
                {
                    hr = DMUS_S_PARTIALDOWNLOAD;
                }
                // Otherwise, make sure we don't return S_FALSE for hr!
                else
                {
                    hr = hrTemp;
                }
            }
            pPerfp->Release();
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
    return hr;
}

STDMETHODIMP
CBand::Download(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to download instruments
                                            // to. The performance manages the mapping
                                            // of PChannels to DirectMusic ports.
{
    V_INAME(CBand::Download);
    V_PTR_READ(pPerformance, IDirectMusicPerformance);
    return DownloadEx(pPerformance);
}

HRESULT CBandInstrument::Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be unloading from.
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Just in case we don't find the download record.
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
            if (pDLInstrument->m_pPort == pPort)
            {
                pDLInstrument->m_cRef--;
                if(!pDLInstrument->m_cRef)
                {
                    m_DownloadList.Remove(pDLInstrument);
                    if (FAILED(pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
                    {
                        Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
                    }
                    pDLInstrument->m_pDLInstrument->Release();
                    pDLInstrument->m_pDLInstrument = NULL;
                    delete pDLInstrument;
                }
                hr = S_OK;
                break;
            }
        }
        pPort->Release();
    } 
    else if (!pPath && m_DownloadList.GetCount() == 1)
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        pDLInstrument->m_cRef--;

        if (!pDLInstrument->m_cRef)
        {
            m_DownloadList.Remove(pDLInstrument);
            if (FAILED(pDLInstrument->m_pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
            {
                Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
            }
            pDLInstrument->m_pDLInstrument->Release();
            pDLInstrument->m_pDLInstrument = NULL;
            delete pDLInstrument;
        }
        hr = S_OK;
    }

    return hr;        
}



//////////////////////////////////////////////////////////////////////
// CBand::UnloadEx

STDMETHODIMP
CBand::UnloadEx(IUnknown *pAudioPath)  

{
    V_INAME(CBand::UnloadEx);
    V_PTR_READ(pAudioPath, IUnknown);

    IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Returns this for empty band.
        EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
        hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
            CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
            
            for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pBandInstrument->Unload(pPerfp,pPath);
            }
            pPerfp->Release();
        }
        
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
    return hr;
}

STDMETHODIMP
CBand::Unload(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to unload instruments
                                            // from. The performance manages the mapping
         
                                            // of PChannels to DirectMusic ports.
{
    V_INAME(CBand::Unload);
    V_PTR_READ(pPerformance, IDirectMusicPerformance);
    return UnloadEx(pPerformance);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CBand::GetDescriptor

STDMETHODIMP CBand::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CBand::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
    pDesc->guidClass = CLSID_DirectMusicBand;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::SetDescriptor

STDMETHODIMP CBand::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CBand::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
    
    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
    {
        m_guidObject = pDesc->guidObject;
        dw |= DMUS_OBJ_OBJECT;
    }
    if( pDesc->dwValidData & DMUS_OBJ_NAME )
    {
        memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
        dw |= DMUS_OBJ_NAME;
    }
    if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
    {
        memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
        dw |= DMUS_OBJ_CATEGORY;
    }
    if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
        ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
    {
        memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
        dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
    }
    if( pDesc->dwValidData & DMUS_OBJ_VERSION )
    {
        m_vVersion = pDesc->vVersion;
        dw |= DMUS_OBJ_VERSION;
    }
    if( pDesc->dwValidData & DMUS_OBJ_DATE )
    {
        m_ftDate = pDesc->ftDate;
        dw |= DMUS_OBJ_DATE;
    }
    m_dwValidData |= dw;
    if( pDesc->dwValidData & (~dw) )
    {
        hr = S_FALSE; // there were extra fields we didn't parse;
        pDesc->dwValidData = dw;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::ParseDescriptor

STDMETHODIMP CBand::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CBand::ParseDescriptor);
    V_PTR_READ(pStream, IStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
    
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        pDesc->guidClass = CLSID_DirectMusicBand;
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
        if (ckMain.fccType == FOURCC_BAND_FORM)
        {
            hr = ParseLegacyDescriptor(&Parser, pDesc);             
        }
        else if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
        {
            hr = ParseDirectMusicDescriptor(&Parser, pDesc);
        }
        else
        {
            Trace(2,"Warning: ParseDescriptor failed because this is not a Band file.\n"); 
            hr = DMUS_E_INVALID_BAND;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBand::ParseLegacyDescriptor

HRESULT CBand::ParseLegacyDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
            hr = pParser->Read( &Band, sizeof(Band) );
            if( SUCCEEDED(hr) )
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
                wcsncpy(pDesc->wszName, Band.wstrName, MAX_LEGACY_BAND_NAME);
                pDesc->wszName[MAX_LEGACY_BAND_NAME - 1] = 0;
            }
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::ParseDirectMusicDescriptor
HRESULT CBand::ParseDirectMusicDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData = pDesc->dwValidData;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &pDesc->guidObject, sizeof(GUID) );
            dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
            dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
            pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            dwValidData |= DMUS_OBJ_CATEGORY;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &pDesc->ftDate, sizeof(FILETIME) );
            dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckUNFO);
                while (pParser->NextChunk(&hr))
                {
                    if (( ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckUNFO.ckid == mmioFOURCC('I','N','A','M')))
                    {
                        hr = pParser->Read(&pDesc->wszName, sizeof(pDesc->wszName));
                        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;
                        dwValidData |= DMUS_OBJ_NAME;
                    }
                }
                pParser->LeaveList();
                break;            
            }
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::LoadLegacyBand

HRESULT CBand::LoadLegacyBand(CRiffParser *pParser, IDirectMusicLoader* pIDMLoader)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
            hr = pParser->Read( &Band, sizeof(Band) );
            if( SUCCEEDED(hr) )
            {
                wcsncpy(m_wszName, Band.wstrName, MAX_LEGACY_BAND_NAME);
                m_wszName[MAX_LEGACY_BAND_NAME - 1] = 0;
                m_dwValidData |= DMUS_OBJ_NAME;
                hr = BuildLegacyInstrumentList(Band, pIDMLoader);
                if (SUCCEEDED(hr))
                {
                    m_dwFlags |= DMB_LOADED;
                    if(Band.fDefault)
                    {
                        m_dwFlags |= DMB_DEFAULT;
                    }
                }
            }
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::LoadDirectMusicBand

HRESULT CBand::LoadDirectMusicBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader)
{
    HRESULT hrDLS = S_OK;

    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &m_guidObject, sizeof(GUID) );
            m_dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
            m_dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            m_wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            m_dwValidData |= DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
            m_dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    if (( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckChild.ckid == mmioFOURCC('I','N','A','M')))
                    {
                        hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                        m_wszName[DMUS_MAX_NAME - 1] = 0;
                        m_dwValidData |= DMUS_OBJ_NAME;
                    }
                }
                pParser->LeaveList();
                break;
            case DMUS_FOURCC_INSTRUMENTS_LIST:
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    if ((ckChild.ckid == FOURCC_LIST) && 
                        (ckChild.fccType == DMUS_FOURCC_INSTRUMENT_LIST))
                    {
                        hr = ExtractBandInstrument(pParser, pIDMLoader);
                        if (hr != S_OK)
                        {
                            hrDLS = hr;
                        }
                    }
                }
                pParser->LeaveList();
                break;
            }
        }
    }
    pParser->LeaveList();

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::BuildLegacyInstrumentList

HRESULT CBand::BuildLegacyInstrumentList(const ioBandLegacy& iob,
                                            IDirectMusicLoader* pIDMLoader)
{
    // Legacy band channel to pchannel translation table
    static char sj_translation_table[] = { -1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3 };

    HRESULT hrGM = S_OK;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    char szCollection[DM_LEGACY_BAND_COLLECTION_NAME_LEN];
    
    for(DWORD i = 0; SUCCEEDED(hr) && i < DMBAND_NUM_LEGACY_INSTRUMENTS; i++)
    {
        CBandInstrument* pBandInstrument = new CBandInstrument();
        if(pBandInstrument)
        {
            if(iob.awDLSBank[i] & 0x8000) 
            {
                // We have a plain old GM collection where MSB & LSB are both zero
                pBandInstrument->m_dwPatch = 0;
                pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
                pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
            }
            else
            {
                if(iob.awDLSBank[i] & 0x4000)
                {
                    // We has a GS collection with valid MSB and LSB numbers
                    pBandInstrument->m_dwPatch = 0;
                    pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
                    pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
                    pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
                    pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_GS | DMUS_IO_INST_GM);
                }
                else
                {
                    if(iob.szCollection[0] == '\0')
                    {
                        // We have no unique DLS file so we will assume GM
                        pBandInstrument->m_dwPatch = 0;
                        pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
                        pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
                    }
                    else
                    {
                        // We have a unique DLS file
                        pBandInstrument->m_dwPatch = 0;
                        pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
                        pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
                        pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
                        pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT);
                        lstrcpyn(szCollection, iob.szCollection, MAX_LEGACY_COLLECTION_NAME);
                        szCollection[MAX_LEGACY_COLLECTION_NAME - 1] = '\0';
                    }
                }
            }
            
            pBandInstrument->m_dwFlags |= (DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_PAN | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PATCH);
            pBandInstrument->m_bPan = iob.abPan[i];
            pBandInstrument->m_bVolume = iob.abVolume[i];
            pBandInstrument->m_dwPChannel = sj_translation_table[i + 1];
            // Set drum-kit bit if a drum-kit
            if(pBandInstrument->m_dwPChannel % 16 == 9)
            {
                pBandInstrument->m_dwPatch |= 0x80000000;
            }

            pBandInstrument->m_nTranspose = iob.achOctave[i];
            
            pBandInstrument->m_pIDMCollection = NULL;

            // We will try to load the collection but if we can not we will continure
            // and use the default GM on the card
            
            if(pIDMLoader && (pBandInstrument->m_dwFlags & DMUS_IO_INST_GM || pBandInstrument->m_dwFlags & DMUS_IO_INST_GS))
            {
                HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                    NULL,
                                    pIDMLoader);
                if (FAILED(hrTemp))
                {
                    hrGM = hrTemp;
                }
            }
            else if(pIDMLoader)
            {
                HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                    szCollection,
                                    pIDMLoader);
                if (FAILED(hrTemp))
                {
                    hrGM = hrTemp;
                }
            }
            
            m_BandInstrumentList.AddHead(pBandInstrument);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    // This function expects the caller to cleanup m_BandInstrumentList on any errors
    if (SUCCEEDED(hrGM) || hr != S_OK)
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

//////////////////////////////////////////////////////////////////////
// CBand::ExtractBandInstrument

HRESULT CBand::ExtractBandInstrument(CRiffParser *pParser,
                                    IDirectMusicLoader* pIDMLoader)
{
    CBandInstrument* pBandInstrument = new CBandInstrument();
    
    if(pBandInstrument == NULL)
    {
        return E_OUTOFMEMORY;
    }


    RIFFIO ckNext;
    HRESULT hrGM = S_OK;
    HRESULT hr = S_OK;
    
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case  DMUS_FOURCC_INSTRUMENT_CHUNK:
            {
                DMUS_IO_INSTRUMENT ioDMInst;
                ZeroMemory( &ioDMInst, sizeof(DMUS_IO_INSTRUMENT) );
                hr = pParser->Read(&ioDMInst, sizeof(DMUS_IO_INSTRUMENT));
                if(SUCCEEDED(hr))
                {
                    pBandInstrument->m_dwPatch = ioDMInst.dwPatch;
                    pBandInstrument->m_dwAssignPatch = ioDMInst.dwAssignPatch;
                    pBandInstrument->m_bPan = ioDMInst.bPan;
                    pBandInstrument->m_bVolume = ioDMInst.bVolume;
                    pBandInstrument->m_dwPChannel = ioDMInst.dwPChannel;
                    pBandInstrument->m_nTranspose = ioDMInst.nTranspose;
                    pBandInstrument->m_dwFlags = ioDMInst.dwFlags;
                    pBandInstrument->m_dwChannelPriority = ioDMInst.dwChannelPriority;
                    pBandInstrument->m_nPitchBendRange = ioDMInst.nPitchBendRange;

                    CopyMemory(&(pBandInstrument->m_dwNoteRanges[0]),
                               &(ioDMInst.dwNoteRanges[0]),
                               (sizeof(DWORD) * 4));
                    
                    pBandInstrument->m_pIDMCollection = NULL;

                }
            }
            break;
        case FOURCC_LIST :
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_REF_LIST:
                // We can only load if we have a valid loader
                if(pIDMLoader)
                {
                    HRESULT hrTemp = GetCollectionRefAndLoad(pParser,pIDMLoader,pBandInstrument);
                    if (FAILED(hrTemp))
                    {
                        hrGM = hrTemp;
                    }

                }
                break;
            }
            break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        if(pIDMLoader && 
           pBandInstrument->m_pIDMCollection == NULL &&
           (pBandInstrument->m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)) )
        {
            HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                NULL,
                                pIDMLoader);
            if (FAILED(hrTemp))
            {
                hrGM = hrTemp;
            }
        }

        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        delete pBandInstrument;
    }

    if (SUCCEEDED(hrGM) || hr != S_OK)
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

//////////////////////////////////////////////////////////////////////
// CBand::GetCollectionRefAndLoad

HRESULT CBand::GetCollectionRefAndLoad(CRiffParser *pParser,
                                        IDirectMusicLoader *pIDMLoader, 
                                        CBandInstrument *pBandInstrument)
{
    DMUS_OBJECTDESC desc;
    desc.dwValidData = 0;
    desc.dwSize = sizeof(desc);

    RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case  DMUS_FOURCC_REF_CHUNK:
            DMUS_IO_REFERENCE ioDMRef;
            hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
            desc.guidClass = ioDMRef.guidClassID;
            desc.dwValidData |= ioDMRef.dwValidData;
            desc.dwValidData |= DMUS_OBJ_CLASS;
            break;
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
            desc.dwValidData |=  DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read(&(desc.ftDate), sizeof(FILETIME));
            desc.dwValidData |=  DMUS_OBJ_DATE;
            break;
        case DMUS_FOURCC_NAME_CHUNK:
            hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
            desc.wszName[DMUS_MAX_NAME - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_NAME;
            break;
        case DMUS_FOURCC_FILE_CHUNK:
            hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
            desc.wszFileName[DMUS_MAX_FILENAME - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_FILENAME;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
            desc.wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            DMUS_IO_VERSION dmioVer;
            hr = pParser->Read(&dmioVer, sizeof(DMUS_IO_VERSION));
            desc.vVersion.dwVersionMS = dmioVer.dwVersionMS;
            desc.vVersion.dwVersionLS = dmioVer.dwVersionLS;
            desc.dwValidData |= DMUS_OBJ_VERSION;
            break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)&(pBandInstrument->m_pIDMCollection));
    }
#ifdef DBG
    if (FAILED(hr))
    {
        if (desc.dwValidData &  DMUS_OBJ_FILENAME)
        {
            Trace(1,"Error: Unable to load DLS Collection from file %ls for instrument %lx\n",
                desc.wszFileName, pBandInstrument->m_dwPatch);
        }
        else if (desc.dwValidData & DMUS_OBJ_NAME)
        {
            Trace(1,"Error: Unable to load DLS Collection %ls for instrument %lx\n",
                desc.wszName, pBandInstrument->m_dwPatch);
        }
        else
        {
            Trace(1,"Error: Unable to load DLS Collection for instrument %lx\n",
                pBandInstrument->m_dwPatch);
        }
    }
#endif
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::Load

HRESULT CBand::Load(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
    // This method is used to load PatchEvents generated by the parsing of a MIDI file.
    // Each PatchEvent represents a program change and possibly a bank select. Using 
    // this information this method will generate a band with one instrument.

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    CBandInstrument* pBandInstrument = NULL;

    pBandInstrument = new CBandInstrument();
        
    if(pBandInstrument)
    {
        pBandInstrument->m_dwFlags |= rPatchEvent.dwFlags;

        if(pBandInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
        {
            pBandInstrument->m_dwPatch |= (rPatchEvent.byPChange & 0x7F); // Program change
        }

        if(pBandInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
        {
            pBandInstrument->m_dwPatch |= (rPatchEvent.byLSB & 0x7F) << 8; // Set LSB
            pBandInstrument->m_dwPatch |= (rPatchEvent.byMSB & 0x7F) << 16; // Set MSB
        }

        if(IsGS(rPatchEvent))
        {
            pBandInstrument->m_dwFlags |= DMUS_IO_INST_GS;
            if( (rPatchEvent.byLSB == 0) && (rPatchEvent.byMSB == 0) )
            {
                pBandInstrument->m_dwFlags |= DMUS_IO_INST_GM;
            }
        }

        pBandInstrument->m_dwPChannel = (rPatchEvent.byStatus & 0xF);
        pBandInstrument->m_pIDMCollection = rPatchEvent.pIDMCollection;
        pBandInstrument->m_fNotInFile = rPatchEvent.fNotInFile;
        if(pBandInstrument->m_pIDMCollection)
        {
            (pBandInstrument->m_pIDMCollection)->AddRef();
        }
        
        // Set the time for the band. Since this band will have only one instrument in
        // it we use the time for PatchEvent as the time for the band
        m_lTimeLogical = rPatchEvent.lTime;
        m_lTimePhysical = m_lTimeLogical;
        
        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if(SUCCEEDED(hr))
    {
        m_dwFlags |= DMB_LOADED;
    }
    else
    {
        if(pBandInstrument)
        {
            delete pBandInstrument;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::Load

HRESULT CBand::Load(CBandInstrument* pInstrument)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    CBandInstrument* pBandInstrument = NULL;

    pBandInstrument = new CBandInstrument();
        
    if(pBandInstrument)
    {
        pBandInstrument->m_dwPatch = pInstrument->m_dwPatch;
        pBandInstrument->m_dwAssignPatch = pInstrument->m_dwAssignPatch;
        pBandInstrument->m_dwPChannel = pInstrument->m_dwPChannel;
        pBandInstrument->m_dwFlags = pInstrument->m_dwFlags;
        pBandInstrument->m_bPan = pInstrument->m_bPan;
        pBandInstrument->m_bVolume = pInstrument->m_bVolume;
        pBandInstrument->m_nTranspose = pInstrument->m_nTranspose;
        pBandInstrument->m_pIDMCollection = pInstrument->m_pIDMCollection;

        CopyMemory(pBandInstrument->m_dwNoteRanges, pInstrument->m_dwNoteRanges, sizeof(pInstrument->m_dwNoteRanges)); 
        if(pBandInstrument->m_pIDMCollection)
        {
            (pBandInstrument->m_pIDMCollection)->AddRef();
        }

        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        m_dwFlags |= DMB_LOADED;
    }
    else
    {
        if(pBandInstrument)
        {
            delete pBandInstrument;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::SendMessages

HRESULT CBand::SendMessages(CBandTrkStateData* pBTStateData,
                               MUSIC_TIME mtOffset,
                               REFERENCE_TIME rtOffset,
                               bool fClockTime)
{
    if(pBTStateData == NULL)
    {   
        return E_POINTER;
    }
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for( ; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
    {
        if( pInstrument->m_fNotInFile && !pInstrument->m_fGMOnly )
        {
            // don't send program changes for instruments that were automatically
            // generated by midi file parsing, unless we've set GMOnly.
            continue;
        }
        hr = SendInstrumentAtTime(pInstrument, pBTStateData, m_lTimePhysical, mtOffset, rtOffset, fClockTime);
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CBand::AllocPMsgFromGenericTemplate(
    DWORD dwType,
    IDirectMusicPerformance *pPerformance,
    DMUS_PMSG **ppMsg,
    ULONG cb,
    DMUS_PMSG *pMsgGenericFields)
{
    HRESULT hr = pPerformance->AllocPMsg(cb, ppMsg);
    if (SUCCEEDED(hr))
    {
        DWORD dwSize = (*ppMsg)->dwSize; // Remember the size.
        assert(dwSize == cb);
        ZeroMemory(*ppMsg, cb); // Clear it - ensures we zero the non-DMUS_PMSG_PART fields.
        CopyMemory(*ppMsg, pMsgGenericFields, sizeof(*pMsgGenericFields)); // Copy the DMUS_PMSG_PART fields.

        // Fill in the correct size and type
        (*ppMsg)->dwSize = dwSize;
        (*ppMsg)->dwType = dwType;
    }
    return hr;
}

HRESULT CBand::StampSendFreePMsg(
                IDirectMusicPerformance *pPerformance,
                IDirectMusicGraph *pGraph,
                DMUS_PMSG *pMsg)
{
    // Let the graph set the delivery parameters.
    HRESULT hr = pGraph->StampPMsg(pMsg);
    if (SUCCEEDED(hr))
        hr = pPerformance->SendPMsg(pMsg);
    if (FAILED(hr))
        hr = pPerformance->FreePMsg(pMsg);
    return hr;
}

HRESULT CBand::SendInstrumentAtTime(CBandInstrument* pInstrument, 
                                       CBandTrkStateData* pBTStateData, 
                                       MUSIC_TIME mtTimeToPlay,
                                       MUSIC_TIME mtOffset,
                                       REFERENCE_TIME rtOffset,
                                       bool fClockTime)
{
    if(pInstrument == NULL || pBTStateData == NULL)
    {
        return E_POINTER;
    }

    IDirectMusicGraph *pGraph = NULL;
    IDirectMusicPerformance *pPerformance = pBTStateData->m_pPerformance;
    DWORD dwVirtualTrackID = pBTStateData->m_dwVirtualTrackID;
    DWORD dwPatch = 0;
    BOOL fMute;
    DWORD dwPChannel;

    // Get the mute/pchannel reassignment.
    MUSIC_TIME mtParam = ( m_lTimeLogical < 0 ) ? 0 : m_lTimeLogical;
    m_PChMap.GetInfo( pInstrument->m_dwPChannel, mtParam, mtOffset, m_dwGroupBits,
        pPerformance, &fMute, &dwPChannel, fClockTime );
    if( fMute )
        return S_OK;

    HRESULT hr = pBTStateData->m_pSegmentState->QueryInterface(IID_IDirectMusicGraph,
                                                               reinterpret_cast<void**>(&pGraph));
    if(FAILED(hr))
        return hr;

    EnterCriticalSection(&m_CriticalSection);

    DMUS_PMSG pmsgGeneric; // template for stamping out the common fields in the various specific kinds of messages
    ZeroMemory(&pmsgGeneric, sizeof(pmsgGeneric));
    if (fClockTime)
    {
        pmsgGeneric.rtTime =  mtTimeToPlay * REF_PER_MIL + rtOffset;
        pmsgGeneric.dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
    }
    else
    {
        pmsgGeneric.mtTime =  mtTimeToPlay + mtOffset;
        pmsgGeneric.dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    pmsgGeneric.dwPChannel = dwPChannel;
    pmsgGeneric.dwVirtualTrackID = dwVirtualTrackID;
    pmsgGeneric.dwGroupID = m_dwGroupBits;

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
    {
        if(pInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
        {
            if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
            {
                dwPatch = pInstrument->m_dwAssignPatch & 0x007F7F00;            
            }
            else
            {
                dwPatch = pInstrument->m_dwPatch & 0x007F7F00;

                // if the m_fGMOnly flag is set, and either we're GS or we're XG and
                // the instument's port supports XG, use the full patch
                if (pInstrument->m_fGMOnly || (pInstrument->m_dwFlags & DMUS_IO_INST_XG))
                {
                    bool fXG = XGInHardware(pPerformance,pBTStateData->m_pSegmentState,pInstrument->m_dwPChannel);
                    if(pInstrument->m_fGMOnly)
                    {
                        if ( m_dwMidiMode & DMUS_MIDIMODEF_GS )
                        {
                            dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
                        }
                        if ( (m_dwMidiMode & DMUS_MIDIMODEF_XG) && fXG )
                        {
                            dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
                        }
                    }
                    // If the instrument is an XG instrument and the hardware doesn't support
                    // XG, strip off the bank selects.
                    if ( (pInstrument->m_dwFlags & DMUS_IO_INST_XG) && !fXG)
                    {
                        dwPatch = 0;
                    }
                }
            }
        }

        // Now, get the program change.
        if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
        {
            dwPatch |= pInstrument->m_dwAssignPatch & 0x7f; 
        }
        else
        {
            dwPatch |= pInstrument->m_dwPatch & 0x7f;   
        }

        DMUS_PATCH_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_PATCH, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_PATCH_PMSG members that need to be initialized 
            pMsg->byInstrument = (BYTE) dwPatch & 0x7F;
            pMsg->byMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
            pMsg->byLSB = (BYTE) ((dwPatch >> 8) & 0x7F);

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_TRANSPOSE)
    {
        DMUS_TRANSPOSE_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_TRANSPOSE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_TRANSPOSE_PMSG members that need to be initialized 
            pMsg->nTranspose = pInstrument->m_nTranspose;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_VOLUME)
    {
        // Set Volume
        DMUS_MIDI_PMSG* pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

        if(SUCCEEDED(hr))
        {
            // DMUS_MIDI_PMSG members that need to be initialized 
            pMsg->bStatus = MIDI_CONTROL_CHANGE;
            pMsg->bByte1 = MIDI_CC_VOLUME;
            pMsg->bByte2 = pInstrument->m_bVolume;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PAN)
    {
        // Set Pan
        DMUS_MIDI_PMSG* pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

        if(SUCCEEDED(hr))
        {
            // DMUS_MIDI_PMSG members that need to be initialized 
            pMsg->bStatus = MIDI_CONTROL_CHANGE;
            pMsg->bByte1 = MIDI_CC_PAN;
            pMsg->bByte2 = pInstrument->m_bPan;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_CHANNEL_PRIORITY)
    {
        DMUS_CHANNEL_PRIORITY_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CHANNEL_PRIORITY, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_CHANNEL_PRIORITY_PMSG members that need to be initialized 
            pMsg->dwChannelPriority = pInstrument->m_dwChannelPriority;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PITCHBENDRANGE)
    {
        DMUS_CURVE_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CURVE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            pMsg->dwFlags |= DMUS_PMSGF_DX8; // pitch band is a DX8-only flag

            // DMUS_CURVE_PMSG members that need to be initialized 
            pMsg->nEndValue = pInstrument->m_nPitchBendRange << 7;
            pMsg->nOffset = static_cast<short>(m_lTimePhysical - m_lTimeLogical);
            pMsg->bType = DMUS_CURVET_RPNCURVE;
            pMsg->bCurveShape = DMUS_CURVES_INSTANT;
            pMsg->wParamType = RPN_PITCHBEND;
            // Leave as zero: mtDuration, mtOriginalStart, mtResetDuration, nStartValue, nResetValue,
            //                wMeasure, bBeat, bGrid, wMergeIndex

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    pGraph->Release();
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::LoadCollection

HRESULT CBand::LoadCollection(IDirectMusicCollection** ppIDMCollection,
                                 char* pszCollection,
                                 IDirectMusicLoader* pIDMLoader)
{
    // Any changes made to this function should also be made to LoadCollection
    // in dmime.dll

    assert(ppIDMCollection);
    assert(pIDMLoader);

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize = sizeof(desc);

    desc.guidClass = CLSID_DirectMusicCollection;

    if(pszCollection == NULL)
    {
        desc.guidObject = GUID_DefaultGMCollection;
        desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszCollection, -1, desc.wszName, DMUS_MAX_NAME);
        desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_NAME);
    }

    HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannelCount

DWORD CBand::GetPChannelCount()
{
    EnterCriticalSection(&m_CriticalSection);

    DWORD dwCount = 0;
    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for( ; pInstrument; pInstrument = pInstrument->GetNext())
    {
        dwCount++;
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return dwCount;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannels

HRESULT CBand::GetPChannels(DWORD *pdwPChannels, DWORD *pdwNumWritten)
{
    assert(pdwPChannels);
    assert(pdwNumWritten);

    EnterCriticalSection(&m_CriticalSection);
    
    *pdwNumWritten = 0;

    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for(; pInstrument; pInstrument = pInstrument->GetNext())
    {
        *pdwPChannels++ = pInstrument->m_dwPChannel;
        (*pdwNumWritten)++;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

HRESULT CBandInstrument::BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges)
{
    const int c_iIn = 0;
    const int c_iOut = 1;

    HRESULT hr = S_OK;

    // Count the number of DMUS_NOTERANGE structures we need to allocate
    DWORD dwNRNum = 0;
    int nState = c_iOut;
    for(int i = 0; i < 4; i++)
    {
        DWORD dwTemp = pNoteRangeMap[i];
        DWORD dwBitPos = 0;
        while(dwBitPos < 32)
        {
            if(dwTemp & 0x1ul)
            {
                if(nState == c_iOut)
                {
                    nState = c_iIn;
                    dwNRNum++;
                }
            }
            else
            {
                nState = c_iOut;
            }
            
            dwTemp = dwTemp >> 1;
            dwBitPos++;
        }   
    }

    // If the NoteRangeMap is empty or full we do nothing
    // since this will cause NULL to be returned which means we 
    // want to download the complete instrument
    if(dwNRNum && dwNRNum < 128)
    {
        *ppNoteRanges = new DMUS_NOTERANGE[dwNRNum];
        if(*ppNoteRanges)
        {
            DWORD dwNRIdx = 0;

            for(dwNRIdx = 0; dwNRIdx < dwNRNum; dwNRIdx++)
            {
                (*ppNoteRanges)[dwNRIdx].dwLowNote = 0;
                (*ppNoteRanges)[dwNRIdx].dwHighNote = 127;
            }

            dwNRIdx = 0;
            nState = c_iOut;
            for(int i = 0; i < 4; i++)
            {
                DWORD dwTemp = pNoteRangeMap[i];
                DWORD dwBitPos = 0;
                while(dwBitPos < 32)
                {
                    if(dwTemp & 0x1ul)
                    {
                        if(nState == c_iOut)
                        {
                            nState = c_iIn;
                            (*ppNoteRanges)[dwNRIdx].dwLowNote = dwBitPos + (i * 32);
                        }
                    }
                    else if(nState == c_iIn)
                    {
                        (*ppNoteRanges)[dwNRIdx].dwHighNote = dwBitPos + (i * 32) - 1;
                        nState = c_iOut;
                        dwNRIdx++;
                    }
                    
                    dwTemp = dwTemp >> 1;
                    dwBitPos++;
                }   
            }

            assert(nState == c_iIn ? dwNRIdx == dwNRNum - 1 : dwNRIdx == dwNRNum);

            *pdwNumNoteRanges = dwNRNum;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppNoteRanges = NULL;
        *pdwNumNoteRanges = 0;
    }
    
    return hr;  
}


//////////////////////////////////////////////////////////////////////
// CBand::IsGS

bool CBand::IsGS(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
    BYTE    bMSB = 0;
    BYTE    bPatch = 0;

    if( rPatchEvent.dwFlags & DMUS_IO_INST_BANKSELECT )
    {
        if( rPatchEvent.byLSB != 0 ) return FALSE; // LSB must be 0 for GS
        bMSB = rPatchEvent.byMSB;
    }
    if( rPatchEvent.dwFlags & DMUS_IO_INST_PATCH )
    {
        bPatch = rPatchEvent.byPChange & 0x7F;
    }

    if( bMSB == 0)
    {
        // If this is a drum kit (on MIDI channel 10)
        if( (rPatchEvent.byStatus  & 0xF) == 10 )
        {
            if ((bPatch == 0x0)  ||
                (bPatch == 0x08) ||
                (bPatch == 0x10) ||
                (bPatch == 0x18) ||
                (bPatch == 0x19) ||
                (bPatch == 0x20) ||
                (bPatch == 0x28) ||
                (bPatch == 0x30) || 
                (bPatch == 0x38) )
            {
                return  true;
            }
            else
                return false;
        }
        else return true;//is GM
    }
    // check for GS
    switch (bMSB)
    {
        case 6:
        case 7:
            if (bPatch == 0x7D) return true;
            break;
        case 24:
            if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
            break;
        case 9:
            if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
            break;
        case 2:
            if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
            break;
        case 3:
            if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
            break;
        case 4:
        case 5:
            if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
            break;
        case 32:
            if ((bPatch == 0x10) ||
                (bPatch == 0x11) ||
                (bPatch == 0x18) ||
                (bPatch == 0x34) ) return true;
            break;
        case 1:
            if ((bPatch == 0x26) ||
                (bPatch == 0x39) ||
                (bPatch == 0x3C) ||
                (bPatch == 0x50) ||
                (bPatch == 0x51) ||
                (bPatch == 0x62) ||
                (bPatch == 0x66) ||
                (bPatch == 0x68) ||
                ((bPatch > 0x77) && (bPatch < 0x80))) return true;
                break;
        case 16:
            switch (bPatch)
            {
                case 0x00:
                    return true;
                    break;
                case 0x04:
                    return true;
                    break;
                case 0x05:
                    return true;
                    break;
                case 0x06:
                    return true;
                    break;
                case 0x10:
                    return true;
                    break;
                case 0x13:
                    return true;
                    break;
                case 0x18:
                    return true;
                    break;
                case 0x19:
                    return true;
                    break;
                case 0x1C:
                    return true;
                    break;
                case 0x27:
                    return true;
                    break;
                case 0x3E:
                    return true;
                    break;
                case 0x3F:
                    return true;
                    break;
                default:
                    return false;
            }
            break;
        case 8:
            if ((bPatch < 0x07) || ((bPatch == 0x7D)))
            {
                return true;
            }
            else if ((bPatch > 0x3F) && (bPatch < 0x50))
            {
                return false;
            }
            else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
            {
                if ((bPatch == 0x50) || 
                    (bPatch == 0x51) ||
                    (bPatch == 0x6B))
                {
                    return true;
                }
                return false;
            }
            else if ((bPatch > 0x1F) && (bPatch < 0x40))
            {
                if ((bPatch > 0x25) && (bPatch < 0x29) ||
                    (bPatch > 0x3C)  ||
                    (bPatch == 0x30) || 
                    (bPatch == 0x32) )
                {
                    return true;
                }
                return false;
            }
            else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
                     (bPatch != 0x0D) && (bPatch != 0x0F))
            {
                return true;
            }
            else if ((bPatch > 0x0F) && (bPatch < 0x20))
            {
                if (bPatch > 0x17)
                {
                    return true;
                }
                else if ( (bPatch == 0x13) || (bPatch == 0x15) )
                    return true;
                else
                    return false;
            }
            break;
        default:
            return false;
    }
    return false;
}

HRESULT CBandInstrument::DownloadAddRecord(IDirectMusicPort *pPort)

{
    IDirectMusicInstrument* pInstrument = NULL;
    
    HRESULT hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
    
    if (FAILED(hr) && (m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)))
    {
        // If drums, set to standard drums.
        if (m_dwPatch & 0x80000000)
        {
            m_dwPatch = 0;
        }
        // Else make this a GM melodic instrument.
        else
        {
            m_dwPatch &= 0x7F;
        }
        hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
    }

    if(SUCCEEDED(hr) && m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
    {
        hr = pInstrument->SetPatch(m_dwAssignPatch);
    }
    
    if(SUCCEEDED(hr))
    {
        CDownloadedInstrument* pDLInstrument = new CDownloadedInstrument;

        if(pDLInstrument)
        {
            pDLInstrument->m_pPort = pPort;
            pPort->AddRef();
            pDLInstrument->m_cRef = 1;

            DMUS_NOTERANGE *pNoteRanges = NULL;
            DWORD dwNumNoteRanges = 0;
            if(m_dwFlags & DMUS_IO_INST_NOTERANGES)
            {
                BuildNoteRangeArray(m_dwNoteRanges, &pNoteRanges, &dwNumNoteRanges);
            }
            hr = pPort->DownloadInstrument( pInstrument, 
                                            &pDLInstrument->m_pDLInstrument, 
                                            pNoteRanges, 
                                            dwNumNoteRanges );
            if (pNoteRanges)
            {
                delete [] pNoteRanges;
            }

            if(SUCCEEDED(hr))
            {
                m_DownloadList.AddHead(pDLInstrument);              
            }
            else
            {
                delete pDLInstrument;
#ifdef DBG
                if (hr == DMUS_E_NOT_INIT)
                {
                    Trace(0,"Error: Download failed because performance not initialized\n"); 
                }
                else
                {
                    Trace(1,"Error: Unable to download instrument %lx to PChannel %ld\n",
                        m_dwPatch,m_dwPChannel); 
                }
#endif
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            Trace(0,"Error: Memory allocation failure - Unable to download instrument\n"); 
        }
    }
    else
    {
        Trace(1,"Error: Unable to download instrument %lx; not in dls collection\n",m_dwPatch);
    }

    if (pInstrument)
    {
        pInstrument->Release();
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::XGInHardware

bool CBand::XGInHardware(
            IDirectMusicPerformance *pPerformance,
            IDirectMusicSegmentState *pSegState,
            DWORD dwPChannel)
{
    DWORD dwGMFlags = 0;        
    // If this is playing via an audiopath, we need to access the audiopath to 
    // convert the pchannels so we can use them to access the right port.
    IDirectMusicSegmentState8 *pState8;
    if (SUCCEEDED(pSegState->QueryInterface(IID_IDirectMusicSegmentState8,(void **) &pState8)))
    {
        IDirectMusicAudioPath *pAudioPath;
        if (SUCCEEDED(pState8->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_AUDIOPATH,0,
            GUID_All_Objects,0,IID_IDirectMusicAudioPath,(void **) &pAudioPath)))
        {
            pAudioPath->ConvertPChannel(dwPChannel, &dwPChannel);
            pAudioPath->Release();
        }
        pState8->Release();
    }
    // Now, use the PChannel and the performance to read the flags.
    IDirectMusicPort *pPort = NULL;
    IDirectMusicPerformanceP *pPerfp;
    if (SUCCEEDED(pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp)))
    {
        if (SUCCEEDED(pPerfp->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags)))
        {
            pPort->Release();
        }
        pPerfp->Release();
    }
    return ((dwGMFlags & DM_PORTFLAGS_XG) && TRUE);
}


//////////////////////////////////////////////////////////////////////
// CBand::MakeGMOnly

HRESULT CBand::MakeGMOnly()
{
    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

    for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
    {
        pBandInstrument->m_fGMOnly = true;
        pBandInstrument->m_dwFullPatch = pBandInstrument->m_dwPatch;

        DWORD dwTemp = pBandInstrument->m_dwPatch;
        pBandInstrument->m_dwPatch = (dwTemp & 0x7F);

        // If a drum kit set drum kit flag
        if( m_dwMidiMode == DMUS_MIDIMODEF_XG )
        {
            if( (dwTemp & 0x00ff0000) == 0x007f0000 )
            {
                // XG drums. Keep this msb, as it is taken care of in the :Download function.
                pBandInstrument->m_dwPatch |= 0x007f0000;
            }
        }
        if(dwTemp & 0x80000000)
        {
            pBandInstrument->m_dwPatch |= 0x80000000;
        }
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::ConnectToDLSCollection

HRESULT CBand::ConnectToDLSCollection(IDirectMusicCollection *pCollection)
{
    assert(pCollection);

    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

    for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
    {
        if(pBandInstrument->m_pIDMCollection == NULL)
        {
            pCollection->AddRef();
            pBandInstrument->m_pIDMCollection = pCollection;
        }
        else
        {
            if( m_dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
            {
                // if we're not an XG file, make sure channel 9 is drums
                if( (m_dwMidiMode != DMUS_MIDIMODEF_XG) &&
                    (pBandInstrument->m_dwPChannel == 9) )
                {
                    pBandInstrument->m_dwPatch |= 0x80000000;
                }
            }
            // if we get an instrument from this collection, set the band's collection
            // pointer to it instead.
            IDirectMusicInstrument* pInstrument = NULL;
            
            if( SUCCEEDED( pCollection->GetInstrument(pBandInstrument->m_dwPatch, &pInstrument)))
            {
                pBandInstrument->m_pIDMCollection->Release();
                pBandInstrument->m_pIDMCollection = pCollection;
                pCollection->AddRef();
                pInstrument->Release();
            }
        }
    }

    LeaveCriticalSection(&m_CriticalSection);   
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\dmbandp.h ===
//
// dmbandp.h
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//
//

#ifndef DMBANDP_H
#define DMBANDP_H

#include "dmusici.h"
#include "dmusicf.h"
#include "bandinst.h"
#include "dmbndtrk.h"
#include "..\shared\validate.h"
#include "PChMap.h"
#include "..\shared\dmusicp.h"

class CRiffParser;

#define REF_PER_MIL		10000		// For converting from reference time to mils 

#define DM_LEGACY_BAND_COLLECTION_NAME_LEN	(32)

#define MIDI_PROGRAM_CHANGE	0xc0
#define MIDI_CONTROL_CHANGE	0xb0
#define MIDI_CC_BS_MSB		0x00
#define MIDI_CC_BS_LSB		0x20
#define MIDI_CC_VOLUME		0x07
#define MIDI_CC_PAN			0x0a

// registered parameter numbers
#define RPN_PITCHBEND   0x00

#define FOURCC_BAND_FORM	mmioFOURCC('A','A','B','N')
#define FOURCC_BAND         mmioFOURCC('b','a','n','d')

// This structure is the format used by band files created with SuperJam and
// earlier versions of Jazz. It was taken from band.h found in the Band Editor 
// subdirectory of the Jazz project tree.

#pragma pack(2)

typedef struct ioBandLegacy
{
    wchar_t wstrName[20];		// Band name
    BYTE    abPatch[16];		// GM
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;			// This band is the style's default band
    char    chPad;			
    WORD    awDLSBank[16];		// if GM bit set use abPatch
								// if GS bit set, use this plus abDLSPatch
								// else use both as a DLS
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//  wchar_t wstrCollection[16];
    char    szCollection[32];  // this only needs to be single-wide chars
} ioBandLegacy;

#pragma pack()

#define DMB_LOADED	 (1 << 0)	/* Set when band has been loaded */
#define DMB_DEFAULT	 (1 << 1)	/* Set when band is default band for a style */

class CBandInstrument;
class CBandTrkStateData;

//////////////////////////////////////////////////////////////////////
// Class CBand

class CBand : 
	public IDirectMusicBand,
	public IDirectMusicBandP,
	public IDirectMusicBandPrivate, 
	public IPersistStream, 
	public IDirectMusicObject, 
	public AListItem
{
friend class CBandTrk;

public:
	enum {DMBAND_NUM_LEGACY_INSTRUMENTS = 16};

	// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream functions
    STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicBand
	STDMETHODIMP CreateSegment(IDirectMusicSegment** ppSegment);
	STDMETHODIMP Download(IDirectMusicPerformance* pPerformance);
	STDMETHODIMP Unload(IDirectMusicPerformance* pPerformance);

    /* IDirectMusicBand8 */
    STDMETHODIMP DownloadEx( IUnknown *pAudioPath) ;     
    STDMETHODIMP UnloadEx( IUnknown *pAudioPath) ;  

	// IDirectMusicBandPrivate
	STDMETHODIMP GetFlags(DWORD* dwFlags)
	{
		V_INAME(CBand::GetFlags);

		// Make sure we have a valid pointer
		V_PTR_WRITE(dwFlags, DWORD);

		*dwFlags = m_dwFlags;

		return S_OK;
	}
	STDMETHODIMP SetGMGSXGMode(DWORD dwMidiMode)
	{
		m_dwMidiMode = dwMidiMode;
		return S_OK;
	}

	// Class
	CBand();
	~CBand();

private:
	CBand* GetNext(){return(CBand*)AListItem::GetNext();}

	HRESULT ParseLegacyDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc);
	HRESULT ParseDirectMusicDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc);

	HRESULT LoadDirectMusicBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader);
	HRESULT LoadLegacyBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader);

	HRESULT BuildLegacyInstrumentList(const ioBandLegacy& iob,
									  IDirectMusicLoader* pIDMLoader);

	HRESULT	ExtractBandInstrument(CRiffParser *pParser,
								  IDirectMusicLoader* pIDMLoader);
	
	HRESULT	GetCollectionRefAndLoad(CRiffParser *pParser,
									IDirectMusicLoader *pIDMLoader, 
									CBandInstrument *pBandInstrument);
	
	HRESULT Load(DMUS_IO_PATCH_ITEM& rPatchEvent); // Assumes event come from a MIDI file
	HRESULT Load(CBandInstrument* pInstrument); // Assumes Instrument come from a band during cloning

	HRESULT SendMessages(CBandTrkStateData* pBTStateData,
						 MUSIC_TIME mtOffset,
						 REFERENCE_TIME rtOffset,
						 bool fClockTime);

    HRESULT AllocPMsgFromGenericTemplate(
	                    DWORD dwType,
	                    IDirectMusicPerformance *pPerformance,
	                    DMUS_PMSG **ppMsg,
	                    ULONG cb,
	                    DMUS_PMSG *pMsgGenericFields);

    HRESULT StampSendFreePMsg(
				        IDirectMusicPerformance *pPerformance,
				        IDirectMusicGraph *pGraph,
				        DMUS_PMSG *pMsg);

	HRESULT SendInstrumentAtTime(CBandInstrument* pInstrument,
								 CBandTrkStateData* pBTStateData,
								 MUSIC_TIME mtTimeToPlay,
								 MUSIC_TIME mtOffset,
								 REFERENCE_TIME rtOffset,
								 bool fClockTime);
	HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
						   char* szCollection,
						   IDirectMusicLoader* pIDMLoader);
	DWORD GetPChannelCount();
	HRESULT GetPChannels(DWORD *pdwPChannels, DWORD *pdwNumWritten);
	bool IsGS(DMUS_IO_PATCH_ITEM& rPatchEvent);
	bool XGInHardware(
			IDirectMusicPerformance *pPerformance,
            IDirectMusicSegmentState *pSegState,
			DWORD dwPChannel);
	HRESULT ConnectToDLSCollection(IDirectMusicCollection *pCollection);
	HRESULT MakeGMOnly();

private:
	CRITICAL_SECTION			m_CriticalSection;
    BOOL                        m_fCSInitialized;
	CBandInstrumentList			m_BandInstrumentList;
	MUSIC_TIME					m_lTimeLogical;
	MUSIC_TIME					m_lTimePhysical;
	DWORD						m_dwFlags;				
	long						m_cRef;
	CPChMap						m_PChMap;
	DWORD						m_dwGroupBits;
	DWORD						m_dwMidiMode; // midi mode message
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */

};

//////////////////////////////////////////////////////////////////////
// Class CBandList

class CBandList : public AList
{

public:
	CBandList(){}
	~CBandList() 
	{
		while(!IsEmpty())
		{
			CBand* pBand = RemoveHead();
			delete pBand;
		}
	}

    CBand* GetHead(){return(CBand *)AList::GetHead();}
	CBand* GetItem(LONG lIndex){return(CBand*)AList::GetItem(lIndex);}
    CBand* RemoveHead(){return(CBand *)AList::RemoveHead();}
	void Remove(CBand* pBand){AList::Remove((AListItem *)pBand);}
	void AddTail(CBand* pBand){AList::AddTail((AListItem *)pBand);}
};

class CClassFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_BAND          1
#define CLASS_BANDTRACK     2

#endif // #ifndef DMBANDP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\dmbdll.cpp ===
//
// dmbdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well IDirectMusicBandFactory & 
// IDirectMusicBandTrkFactory implementations.
// Originally written by Robert K. Amenn with significant parts
// stolen from code written by Jim Geist
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"
#include "..\shared\oledll.h"
#include "dmbandp.h"
#include "bandtrk.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Registry Info (band)
TCHAR g_szBandFriendlyName[]    = TEXT("DirectMusicBand");
TCHAR g_szBandVerIndProgID[]    = TEXT("Microsoft.DirectMusicBand");
TCHAR g_szBandProgID[]          = TEXT("Microsoft.DirectMusicBand.1");

// Registry Info (band track)
TCHAR g_szBandTrackFriendlyName[]    = TEXT("DirectMusicBandTrack");
TCHAR g_szBandTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicBandTrack");
TCHAR g_szBandTrackProgID[]          = TEXT("Microsoft.DirectMusicBandTrack.1");

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if(g_cComponent || g_cLock) 
	{
		return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;
    if(clsid == CLSID_DirectMusicBand)
    {
        dwTypeID = CLASS_BAND;
    }
    else if(clsid == CLSID_DirectMusicBandTrack) 
    {
        dwTypeID = CLASS_BANDTRACK;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
	HRESULT hr = UnregisterServer(CLSID_DirectMusicBand,
								  g_szBandFriendlyName,
								  g_szBandVerIndProgID,
								  g_szBandProgID);

	if(SUCCEEDED(hr))
	{
		hr = UnregisterServer(CLSID_DirectMusicBandTrack,
							  g_szBandTrackFriendlyName,
							  g_szBandTrackVerIndProgID,
							  g_szBandTrackProgID);  
	}

	return hr;

}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
	HRESULT hr = RegisterServer(g_hModule,
								CLSID_DirectMusicBand,
								g_szBandFriendlyName,
								g_szBandVerIndProgID,
								g_szBandProgID);
	if(SUCCEEDED(hr))
	{
		hr = RegisterServer(g_hModule,
							CLSID_DirectMusicBandTrack,
							g_szBandTrackFriendlyName,
							g_szBandTrackVerIndProgID,
							g_szBandTrackProgID);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
				      DWORD dwReason,
				      void *lpReserved)
{
	static int nReferenceCount = 0;

#ifdef DBG
    if(dwReason < nReasons)
    {
		Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
		Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
		case DLL_PROCESS_ATTACH:
		    if(++nReferenceCount == 1)
			{

			#ifdef DBG
				DebugInit();
			#endif

				if(!DisableThreadLibraryCalls(hModule))
				{
					Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;
			}
			break;

#ifdef DBG
		case DLL_PROCESS_DETACH:
		    if(--nReferenceCount == 0)
			{
				TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
			}
			break;
#endif
    
    }
	
    return TRUE;
}

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
	m_cRef = 1;
    m_dwClassType = dwClassType;
	InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }
    if(ppv == NULL)
	{
		return E_POINTER;
	}

    switch (m_dwClassType)
    {
    case CLASS_BAND:
        {
            CBand *pDMB;
    
            try
            {
                pDMB = new CBand;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if(pDMB == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMB->QueryInterface(iid, ppv);
            pDMB->Release();
        }
        break;
    case CLASS_BANDTRACK:
        {
            CBandTrk *pDMBT;

            try 
            {
                pDMBT = new CBandTrk;
            } 
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
    
	        if(pDMBT == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMBT->QueryInterface(iid, ppv);
    
            pDMBT->Release();
        }
        break;
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr) && (long)m_pChunk->cksize < 0)
        {
            // This size is clearly too big for a valid chunk.
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusici.h"
#include "..\dmstyle\tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\pchmap.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */
#include "PChMap.h"
#include "debug.h"
#include "dmusicf.h"

CPChMap::CPChMap()
{
}

CPChMap::~CPChMap()
{
}

// Reset sets all item's mtNext time values to -1, so they are gotten again.
void CPChMap::Reset(void)
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rItem = pItem->GetItemValue();
		rItem.mtNext = -1;
		rItem.dwPChMap = rItem.dwPChannel;
        rItem.fMute = 0;
	}
}

// GetInfo calls the performance's GetData to get the current Mute Track information.
// Reset() will be called upon any invalidation or seek, which will set the
// internal times to -1 so this will be accurate in case of a new controlling segment.
// You must provide the pfMute and pdwNewPCh parameters to this function, or
// it will crash.
void CPChMap::GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
					   IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh, BOOL fClockTime )
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rCheck = pItem->GetItemValue();
		if( rCheck.dwPChannel == dwPCh ) break;
	}
	if( NULL == pItem )
	{
		PCHMAP_ITEM item;
		item.mtNext = -1;
		item.dwPChannel = item.dwPChMap = dwPCh;
		item.fMute = FALSE;
		pItem = new TListItem<PCHMAP_ITEM>(item);
		if( NULL == pItem )
		{
			// error, out of memory.
			*pfMute = FALSE;
			*pdwNewPCh = dwPCh;
			return;
		}
		m_PChMapList.AddHead(pItem);
	}
	PCHMAP_ITEM& rItem = pItem->GetItemValue();
	if( mtTime >= rItem.mtNext )
	{
		DMUS_MUTE_PARAM muteParam;
		MUSIC_TIME mtNext;
		muteParam.dwPChannel = dwPCh;
        if (fClockTime)
        {
            MUSIC_TIME mtMusic;
            REFERENCE_TIME rtTime = (mtTime + mtOffset) * 10000;
            pPerf->ReferenceToMusicTime(rtTime,&mtMusic);
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtMusic, 
			    &mtNext, (void*)&muteParam )))
		    {
                REFERENCE_TIME rtNext;
                // Convert to absolute reference time.
                pPerf->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                rtNext -= rtTime;   // Subtract out to get the delta.
			    rItem.mtNext = (MUSIC_TIME)(rtTime / 10000);  // Convert to delta in milliseconds. BUGBUG What if there's a tempo change?
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }

        }
        else
        {
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtTime + mtOffset, 
			    &mtNext, (void*)&muteParam )))
		    {
			    rItem.mtNext = mtNext;
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }
        }
	}
	*pfMute = rItem.fMute;
	*pdwNewPCh = rItem.dwPChMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\composin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       composin.h
//
//--------------------------------------------------------------------------

// ComposIn.h --- include file for the composition engine

#ifndef __COMPOSINH__
#define __COMPOSINH__

#include "dmusici.h"
#include "dmusicf.h"
#include "str.h"
#include "tlist.h"

#include "aariff.h"
#include "templats.h"

#include "sjpers.h"

#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#include <objbase.h>

#ifndef __AARIFF__
#define __AARIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};

struct CFileStream : IStream
{
///// object state
    ULONG           m_cRef;         // object reference count
    HANDLE          m_hfile;        // file handle

// construction and destruction
    CFileStream( HANDLE hfile ) : m_cRef( 1 ), m_hfile( hfile ) {}
#ifdef _MAC
    ~CFileStream() { FSClose( (int) m_hfile ); }
#else
    ~CFileStream() { CloseHandle( m_hfile ); }
#endif

///// IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *) this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
       return m_cRef;
    }

    /* IStream methods */
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
    {
		DWORD dw;

		if( ReadFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbRead != NULL )
			{
				*pcbRead = dw;
			}
			return S_OK;
		}
		return E_FAIL;
    }
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
    {
		DWORD dw;

		if( WriteFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbWritten != NULL )
			{
				*pcbWritten = dw;
			}
			return S_OK;
		}
        return E_FAIL;
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
    {
		DWORD dw;

		dw = SetFilePointer( m_hfile, dlibMove.LowPart, &dlibMove.HighPart, dwOrigin );
		if( dw == (DWORD)-1 )
		{
			return E_FAIL;
		}
		if( plibNewPosition != NULL )
		{
			plibNewPosition->LowPart = dw;
	        plibNewPosition->HighPart = dlibMove.HighPart;
		}
        return S_OK;
	}
    STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Revert()
    { return E_NOTIMPL; }
    STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/)
    { return E_NOTIMPL; }
    STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Clone( IStream** /*ppstm*/ )
    { return E_NOTIMPL; }
};

struct CRIFFStream : IAARIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IAARIFFStream ) )
        {
            *ppvObj = (IAARIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmband\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME = dmband

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmband.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES);   \
    ..\..\shared


SOURCES=..\bandinst.cpp        \
..\alist.cpp				   \
..\bandtrk.cpp                 \
..\debug.cpp                   \
..\dmband.cpp                  \
..\dmbdll.cpp                  \
..\oledll.cpp                  \
..\pchmap.cpp                  \
..\dmstrm.cpp				   \
..\dmband.rc                   \
..\opnew.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMCOMPOS"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmcmpdll.cpp ===
//
// dmcmpdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as Class Factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "..\shared\oledll.h"

#include <initguid.h>
#include "dmusici.h"
#include "DMCompP.h"
#include "dmpers.h"
#include "dmcompos.h"
#include "dmtempl.h"
#include "spsttrk.h"
#include "perstrk.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\dmime\dmgraph.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information 
//
TCHAR g_szComposerFriendlyName[]    = TEXT("DirectMusicComposer");
TCHAR g_szComposerVerIndProgID[]    = TEXT("Microsoft.DirectMusicComposer");
TCHAR g_szComposerProgID[]          = TEXT("Microsoft.DirectMusicComposer.1");

TCHAR g_szChordMapFriendlyName[]    = TEXT("DirectMusicChordMap");
TCHAR g_szChordMapVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMap");
TCHAR g_szChordMapProgID[]          = TEXT("Microsoft.DirectMusicChordMap.1");

TCHAR g_szChordMapTrackFriendlyName[]    = TEXT("DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackProgID[]          = TEXT("Microsoft.DirectMusicChordMapTrack.1");

TCHAR g_szSignPostTrackFriendlyName[]    = TEXT("DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackProgID[]          = TEXT("Microsoft.DirectMusicSignPostTrack.1");

TCHAR g_szTemplateFriendlyName[]    = TEXT("DirectMusicTemplate");
TCHAR g_szTemplateVerIndProgID[]    = TEXT("Microsoft.DirectMusicTemplate");
TCHAR g_szTemplateProgID[]          = TEXT("Microsoft.DirectMusicTemplate.1");

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::Release

ULONG __stdcall
CDirectMusicPersonalityFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMPers *pDM;
    
    try
    {    
        pDM = new CDMPers;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::QueryInterface

HRESULT __stdcall
CDirectMusicComposerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicComposerFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::AddRef

ULONG __stdcall
CDirectMusicComposerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::Release

ULONG __stdcall
CDirectMusicComposerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::CreateInstance

HRESULT __stdcall
CDirectMusicComposerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMCompos *pDM = new CDMCompos;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::LockServer

HRESULT __stdcall
CDirectMusicComposerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::QueryInterface

HRESULT __stdcall
CDirectMusicTemplateFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicTemplateFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::AddRef

ULONG __stdcall
CDirectMusicTemplateFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::Release

ULONG __stdcall
CDirectMusicTemplateFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::CreateInstance

HRESULT __stdcall
CDirectMusicTemplateFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMTempl *pDM;

    try
    {
        pDM = new CDMTempl;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::LockServer

HRESULT __stdcall
CDirectMusicTemplateFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicSignPostTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::AddRef

ULONG __stdcall
CDirectMusicSignPostTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::Release

ULONG __stdcall
CDirectMusicSignPostTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CSPstTrk *pDM;

    try
    {
        pDM = new CSPstTrk;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::Release

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CPersonalityTrack *pDM;

    try
    {
        pDM = new CPersonalityTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusicChordMap)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicComposer) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicComposerFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DMTempl) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicTemplateFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicSignPostTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicSignPostTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicChordMapTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    UnregisterServer(CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    UnregisterServer(CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    UnregisterServer(CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);
 
	UnregisterServer(CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);


    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    RegisterServer(g_hModule,
                   CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

            }
			break;


#ifdef DBG
        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }

            break;
#endif            
            
    }

        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmcompos.h ===
// DMCompos.h : Declaration of the CDMCompos
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMCOMPOS_H_
#define __DMCOMPOS_H_

#include "ComposIn.h"
#include "DMCompP.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\shared\dmusicp.h"

#define SUBCHORD_STANDARD_CHORD 1
#define SUBCHORD_BASS 0

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.

#define COMPOSEF_USING_DX8  1

inline WORD ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return DMUS_PPQ * 4 / TimeSig.bBeat; }

inline DWORD ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline WORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (WORD) (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

struct DMSignPostStruct
{
    MUSIC_TIME  m_mtTime;
    DWORD       m_dwChords;
    WORD        m_wMeasure;
};

struct DMExtendedChord
{
    DMExtendedChord() { m_nRefCount = 0; }
    void AddRef() { m_nRefCount++; }
    BOOL Release() { m_nRefCount--; if (m_nRefCount <= 0) { delete this; return TRUE; } else return FALSE; }
    BOOL    Equals(DMExtendedChord& rhsChord);  

    DWORD   m_dwChordPattern;
    DWORD   m_dwScalePattern;
    DWORD   m_dwInvertPattern;
    BYTE    m_bRoot;
    BYTE    m_bScaleRoot;
    WORD    m_wCFlags;
    DWORD   m_dwParts;
    int     m_nRefCount;
};

struct DMChordData
{
    DMChordData() : m_pSubChords(NULL) {}   // Default constructor
    DMChordData(DMChordData& rChord);       // Copy constructor
    DMChordData(DMUS_CHORD_PARAM& DMC);         // conversion from DMUS_CHORD_PARAM
    HRESULT Read(IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB);
    void    Release();
    BOOL    Equals(DMChordData& rhsChord);  
    DWORD   GetChordPattern();
    char    GetRoot();
    void    SetRoot(char chNewRoot);

    String                          m_strName;      // Name of the chord
    TListItem<DMExtendedChord*>*        m_pSubChords;   // List of pointers to subchords of the chord
};

struct DMChordEntry;
struct SearchInfo; 

struct DMChordLink
{
    BOOL                        Walk(SearchInfo *pSearch);

    TListItem<DMChordEntry>*    m_pChord;   // pointer to an entry in the Chord Map list
    DWORD                       m_dwFlags;  // (?) 
    short                       m_nID;  // ID for matching up pointers
    WORD                        m_wWeight;      
    WORD                        m_wMinBeats;
    WORD                        m_wMaxBeats;
};

struct DMChordEntry
{
    TListItem<DMChordLink>* ChooseNextChord();
    BOOL                Walk(SearchInfo *pSearch);

    DWORD               m_dwFlags;      // Flags (first chord in path, last chord in path, etc.)
    short               m_nID;          // ID for matching up pointers
    DMChordData         m_ChordData;    // Chord body
    TList<DMChordLink>  m_Links;        // List of links from this chord
};

struct DMSignPost
{
    DWORD               m_dwChords; // Which kinds of signposts are supported.
    DWORD               m_dwFlags;
    DWORD               m_dwTempFlags;
    DMChordData         m_ChordData;
    DMChordData         m_aCadence[2];
};

struct PlayChord
{
    HRESULT Save(IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig);
    char GetRoot();
    void SetRoot(char chNewRoot);

    DMChordData*                m_pChord;       // Chord to perform.
    TListItem<DMChordLink>*     m_pNext;        // Next chord
    DWORD                       m_dwFlags;
    short                       m_nMeasure;
    short                       m_nBeat;
    short                       m_nMinbeats;
    short                       m_nMaxbeats;
    bool                        m_fSilent;
};

struct FailSearch
{
    FailSearch() : 
        m_nTooManybeats(0), m_nTooFewbeats(0), m_nTooManychords(0), m_nTooFewchords(0)
    {}

    short   m_nTooManybeats;
    short   m_nTooFewbeats;
    short   m_nTooManychords;
    short   m_nTooFewchords;
};

struct SearchInfo 
{
    SearchInfo() : m_pFirstChord(NULL), m_pPlayChord(NULL) {}

    //DMChordEntry              m_Start;
    //DMChordEntry              m_End;
    DMChordData                 m_Start;
    DMChordData                 m_End;
    TListItem<PlayChord>*       m_pPlayChord;
    TListItem<DMChordEntry>*    m_pFirstChord;
    short                       m_nBeats;
    short                       m_nMinBeats;
    short                       m_nMaxBeats;
    short                       m_nChords;
    short                       m_nMinChords;
    short                       m_nMaxChords;
    short                       m_nActivity;
    FailSearch                  m_Fail;
};

struct TemplateCommand
{
    TemplateCommand() : m_nMeasure(0), m_dwChord(0)
    { 
        m_Command.bCommand = m_Command.bGrooveLevel = m_Command.bGrooveRange = 0;
        m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    short           m_nMeasure;    // Which measure
    DMUS_COMMAND_PARAM m_Command;    // Command type
    DWORD           m_dwChord;     // Signpost flags
};

struct CompositionCommand : TemplateCommand
{
    TListItem<DMSignPost>*      m_pSignPost;
    TListItem<DMChordEntry>*    m_pFirstChord;
    TList<PlayChord>            m_PlayList;
    SearchInfo                  m_SearchInfo;
};

/*
@interface IDirectMusicComposer | 
The <i IDirectMusicComposer> interface permits access to the Direct Music composition 
engine which 
composes chord progression to generate section segments. In addition to building new 
section segments from templates and personalities, it can generate transition segments to 
transition between different section segments. And, it can apply a ChordMap to an 
existing section segment to convert the chord progression to match the harmonic behavior 
of the ChordMap, a great way to alter the mood of a section while it plays.

The composition engine uses template segments or predefined shapes to determine the 
structure of the composed section segment and personalities to determine the content of 
the segment.


@base public | IUnknown

@meth HRESULT | ComposeSegmentFromTemplate | Creates an original section segment from a 
style, ChordMap and template.
@meth HRESULT | ComposeSegmentFromShape | Creates an original section segment from a 
style and ChordMap based on a predefined shape. 
@meth HRESULT | ComposeTransition |  Composes a transition from a measure inside one 
Section Segment to another.
@meth HRESULT | AutoTransition | Composes and performs a transition from one
Section Segment to another.
@meth HRESULT | ComposeTemplateFromShape | Allocates and composes a new template segment 
based on a predefined shape.
@meth HRESULT | ChangeChordMap | Modifies the chords and scale pattern of an existing 
section segment to reflect the new ChordMap.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMCompos
class CDMCompos : 
    public IDirectMusicComposer8,
    public IDirectMusicComposer8P
{
friend class CSPstTrk;
public:
    CDMCompos();
    ~CDMCompos();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicComposer
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, 
                    IDirectMusicSegment*        pTempSeg,   
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wNumMeasures,
                    WORD                        wShape,
                    WORD                        wActivity,
                    BOOL                        fComposeIntro,
                    BOOL                        fComposeEnding,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTransition(
                    IDirectMusicSegment*    pFromSeg, 
                    IDirectMusicSegment*    pToSeg,     
                    MUSIC_TIME              mtTime,
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE AutoTransition(
                    IDirectMusicPerformance*    pPerformance,
                    IDirectMusicSegment*    pToSeg,     
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppTransSeg,
                    IDirectMusicSegmentState**  ppToSegState,
                    IDirectMusicSegmentState**  ppTransSegState
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShape(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    WORD                    wEndLength,
                    IDirectMusicSegment**   ppTempSeg   
            );

    HRESULT STDMETHODCALLTYPE ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg,
                    BOOL                        fTrackScale,
                    IDirectMusicChordMap*   pChordMap
            );

    // IDirectMusicComposer8
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, 
                    IDirectMusicSegment*    pTempSeg, 
                    DWORD                   dwFlags, // are we using activity levels?  
                                                     // Are we creating a new seg. or composing into the current one?
                    DWORD                   dwActivity,
                    IDirectMusicChordMap*   pChordMap, 
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            );

protected: // member functions
    void CleanUp();
    void AddChord(DMChordData* pChord);
    TListItem<PlayChord> *AddChord(TList<PlayChord>& rList, DMChordData *pChord, int nMeasure,int nBeat);
    TListItem<PlayChord> *AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax);
    void ChordConnections(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ChordConnections2(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ComposePlayList(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity);
    void ComposePlayList2(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList);
    HRESULT ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                );
    BOOL Compose(TList<DMChordEntry>& ChordMap, 
                SearchInfo *pSearch, 
                CompositionCommand& rCommand);

    void JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats);

    BOOL AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes);

    void ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass);

    TListItem<CompositionCommand> *GetNextChord(TListItem<CompositionCommand> *pCommand);

    void FindEarlierSignpost(TListItem<CompositionCommand> *pCommand, 
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch);

    void CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand);

    HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern);

    HRESULT GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers);

    HRESULT ExtractCommandList(TList<TemplateCommand>& CommandList,
                               IDirectMusicTrack*   pSignPostTrack,
                               IDirectMusicTrack*   pCommandTrack,
                               DWORD dwGroupBits);

    HRESULT AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale, 
                            double* pdblTempo = NULL,
                            IDirectMusicBand* pCurrentBand = NULL,
                            bool fAlign = false,
                            IDirectMusicGraph* pGraph = NULL,
                            IUnknown* pPath = NULL);

    HRESULT SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig);
    HRESULT TransitionCommon(
                IDirectMusicStyle*      pFromStyle,
                IDirectMusicBand*       pCurrentBand,
                double*                 pdblFromTempo,
                DMUS_COMMAND_PARAM_2&   rFromCommand,
                DMUS_CHORD_PARAM&       rLastChord,
                DMUS_CHORD_PARAM&       rNextChord,

                IDirectMusicSegment*    pToSeg,
                WORD                    wCommand,
                DWORD                   dwFlags,
                IDirectMusicChordMap*   pChordMap,
                IDirectMusicGraph*      pFromGraph,
                IDirectMusicGraph*      pToGraph,
                IUnknown*               pFromPath,
                IUnknown*               pToPath,
                IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nBreakLength,
                    int                     nFillLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            );

    bool HasDX8Content(IDirectMusicStyle* pFromStyle, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        // Currently this will return true if the Style is DX8.  Should be sufficient (when called from
        // AutoTransition, at least), since the style is primarily responsible for the way the transition 
        // will sound.
        bool fResult = false;
        IDMStyle* pDMStyle = NULL;
        if (pFromStyle && SUCCEEDED(pFromStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            if (pDMStyle->IsDX8() == S_OK) fResult = true;
            pDMStyle->Release();
        }
        return fResult;
    }

    bool UsingDX8(IDirectMusicStyle* pFromStyle = NULL, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        return 
            (m_dwFlags & COMPOSEF_USING_DX8) || 
            HasDX8Content(pFromStyle, pFromChordMap, pFromSegment, pCommand, pLastChord);
    }

    TListItem<DMSignPost>* ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot);

    HRESULT ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                        IDirectMusicChordMap* pChordMap,
                                        IDirectMusicTrack* pChordMapTrack,
                                        IDirectMusicTrack* pSignPostTrack,
                                        IDirectMusicTrack* pCommandTrack,
                                        DWORD dwGroupBits,
                                        MUSIC_TIME mtLength,
                                        bool fUseActivity,
                                        DWORD dwActivity,
                                        TList<PlayChord>& rPlayList,
                                        BYTE& rbRoot,
                                        DWORD& rdwScale);

    IDirectMusicGraph* CloneSegmentGraph(IDirectMusicSegment* pSegment);
    IUnknown* GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath = NULL);


protected: // attributes
    long m_cRef;
    TListItem<DMChordData*>* m_pChords;
    DWORD                   m_dwFlags;              // variaous flags
    CRITICAL_SECTION        m_CriticalSection;      // for i/o
    BOOL                    m_fCSInitialized;
};

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection);

#endif //__DMCOMPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmcompos.cpp ===
//
// DMCompos.cpp : Implementation of CDMCompos
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include <time.h>   // to seed random number generator
#include "DMCompos.h"
#include "debug.h"
#include "DMPers.h"
#include "DMTempl.h"

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\iostru.h"
#include "..\dmime\dmgraph.h"

#include "..\shared\Validate.h"
#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;

BOOL Less(TemplateCommand& TC1, TemplateCommand& TC2)
{
    return TC1.m_nMeasure < TC2.m_nMeasure;
}

BOOL Less(PlayChord& PC1, PlayChord& PC2)
{
    return PC1.m_nMeasure < PC2.m_nMeasure ||
           (PC1.m_nMeasure == PC2.m_nMeasure && PC1.m_nBeat < PC2.m_nBeat);
}

static void Free(TListItem<DMExtendedChord*>*& pSubChord)
{
    TListItem<DMExtendedChord*> *pScan = pSubChord;
    for (; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        pScan->GetItemValue() = NULL;
    }
    TListItem<DMExtendedChord*>::Delete(pSubChord);
    pSubChord = NULL;
}

TListItem<DMExtendedChord*>* Copy(TListItem<DMExtendedChord*>* pChord)
{
    if (!pChord) return NULL;
    TListItem<DMExtendedChord*>* pNext = new TListItem<DMExtendedChord*>;
    if (pNext)
    {
        DMExtendedChord* pNew = new DMExtendedChord;
        if (pNew)
        {
            DMExtendedChord*& rChord = pChord->GetItemValue();
            DMExtendedChord*& rNext = pNext->GetItemValue();
            rNext = pNew;
            rNext->m_dwChordPattern = rChord->m_dwChordPattern;
            rNext->m_dwScalePattern = rChord->m_dwScalePattern;
            rNext->m_dwInvertPattern = rChord->m_dwInvertPattern;
            rNext->m_bRoot = rChord->m_bRoot;
            rNext->m_bScaleRoot = rChord->m_bScaleRoot;
            rNext->m_wCFlags = rChord->m_wCFlags;
            rNext->m_dwParts = rChord->m_dwParts;
            rNext->m_nRefCount = 1;
            pNext->SetNext(Copy(pChord->GetNext()));
        }
        else
        {
            delete pNext;
            pNext = NULL;
        }
    }
    return pNext;
}

DMChordData::DMChordData(DMChordData& rChordData)
{
    m_strName = rChordData.m_strName;
    m_pSubChords = Copy(rChordData.m_pSubChords);
}

DMChordData::DMChordData(DMUS_CHORD_PARAM& DMC)
{
    m_strName = DMC.wszName;
    m_pSubChords = NULL;
    for (BYTE n = 0; n < DMC.bSubChordCount; n++)
    {
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = DMC.SubChordList[n].dwChordPattern;
                rSubChord->m_dwScalePattern = DMC.SubChordList[n].dwScalePattern;
                rSubChord->m_dwInvertPattern = DMC.SubChordList[n].dwInversionPoints;
                rSubChord->m_dwParts = DMC.SubChordList[n].dwLevels;
                rSubChord->m_bRoot = DMC.SubChordList[n].bChordRoot;
                rSubChord->m_bScaleRoot = DMC.SubChordList[n].bScaleRoot;
                m_pSubChords = m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                // no need continuing in the loop if we ran out of memory
                break;
            }
        }
    }
}

// At the moment, this assumes that the pattern of the chord is the pattern of the
// first subchord in the chord's subchord list.
DWORD DMChordData::GetChordPattern()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_dwChordPattern;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
char DMChordData::GetRoot()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_bRoot;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
void DMChordData::SetRoot(char chNewRoot)
{
    if (m_pSubChords)
    {
        m_pSubChords->GetItemValue()->m_bRoot = chNewRoot;
    }
}


void DMChordData::Release()
{
    Free(m_pSubChords);
}

// Two chords are equal if they have the same number of subchords and each
// corresponding subchord is equal
BOOL DMChordData::Equals(DMChordData& rhsChord)
{
    TListItem<DMExtendedChord*> *pLeft = m_pSubChords;
    TListItem<DMExtendedChord*> *pRight = rhsChord.m_pSubChords;
    for(; pLeft; pLeft = pLeft->GetNext(), pRight = pRight->GetNext())
    {
        if (pRight == NULL || !pLeft->GetItemValue()->Equals(*pRight->GetItemValue()))
            return FALSE;
    }
    return pRight == NULL;
}


BOOL DMExtendedChord::Equals(DMExtendedChord& rhsChord)
{
    char a = m_bRoot;
    char b = rhsChord.m_bRoot;
    while (a > 11) a -= 12;
    while (b > 11) b -= 12;
    return ((m_dwChordPattern == rhsChord.m_dwChordPattern) && (a == b));
}

BOOL DMChordLink::Walk(SearchInfo *pSearch)
{
    BOOL fResult = FALSE;
    if (m_pChord)
    {
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats + m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + m_wMaxBeats );
        pSearch->m_nChords++;
        fResult = m_pChord->GetItemValue().Walk(pSearch);
        pSearch->m_nChords--;
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats - m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats - m_wMaxBeats );
    }
    return(fResult);
}

TListItem<DMChordLink> *DMChordEntry::ChooseNextChord()

{
    int total = 0;
    int choice;
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) total += pNext->GetItemValue().m_wWeight;
        }
    }
    if (!total) return(NULL);
    choice = rand() % total;
    pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) choice -= pNext->GetItemValue().m_wWeight;
            if (choice < 0) return(pNext);
        }
    }
    return(NULL);
}

BOOL DMChordEntry::Walk(SearchInfo *pSearch)
{
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    if (pSearch->m_nChords > pSearch->m_nMaxChords)
    {
        pSearch->m_Fail.m_nTooManychords++;
        return (FALSE);
    }
    for (; pNext; pNext = pNext->GetNext())
    {
        pNext->GetItemValue().m_dwFlags &= ~(NC_PATH | NC_NOPATH);
    }
    if ((m_dwFlags & CE_END) && (m_ChordData.Equals(pSearch->m_End)))
    {
        if (pSearch->m_nChords >= pSearch->m_nMinChords)
        {
            if (pSearch->m_nBeats <= pSearch->m_nMaxBeats)
            {
                if (pSearch->m_nBeats >= pSearch->m_nMinBeats)
                {
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else pSearch->m_Fail.m_nTooManybeats++;
            }
            else pSearch->m_Fail.m_nTooFewbeats++;
        }
        else
        {
            pSearch->m_Fail.m_nTooFewchords++;
        }
    }
    m_dwFlags &= ~CE_PATH;
    if (pSearch->m_pPlayChord)
    {
        pSearch->m_pPlayChord = pSearch->m_pPlayChord->GetNext();
    }
    if (pSearch->m_pPlayChord)
    {
        TListItem<PlayChord> *pPlay = pSearch->m_pPlayChord;
        if (pPlay->GetItemValue().m_pChord)
        {
            pNext = pPlay->GetItemValue().m_pNext;
            if (pNext)
            {
                if (pNext->GetItemValue().Walk(pSearch))
                {
                    pNext->GetItemValue().m_dwFlags |= NC_PATH;
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else
                {
                    pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
                    pSearch->m_pPlayChord = NULL;
                }
            }
        }
    }
    while( ( pNext = ChooseNextChord() ) != NULL )
    {
        if (pNext->GetItemValue().Walk(pSearch))
        {
            pNext->GetItemValue().m_dwFlags |= NC_PATH;
            m_dwFlags |= CE_PATH;
            return(TRUE);
        }
        else
        {
            pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
        }
    }
    return (FALSE);
}

#define MAX_CHORD_NAME 16

HRESULT PlayChord::Save( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    DWORD       cb;
    DMUS_IO_CHORD   iChord;
    DMUS_IO_SUBCHORD    iSubChord;
    DWORD        dwSize;
    HRESULT hr = E_FAIL;

    if ( !m_pChord || !m_pChord->m_pSubChords )
    {
        Trace(1, "ERROR: Attempt to save an empty chord list.\n");
        return E_FAIL;
    }
    pStream = pRIFF->GetStream();
    ck.ckid = mmioFOURCC('c','r','d','b');
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        memset( &iChord, 0, sizeof( iChord ) );
        if (m_pChord->m_strName)
        {
            wcsncpy( iChord.wszName, m_pChord->m_strName, MAX_CHORD_NAME );
            iChord.wszName[MAX_CHORD_NAME - 1] = 0;
        }
        iChord.mtTime = ClocksPerBeat(rTimeSig) * m_nBeat + ClocksPerMeasure(rTimeSig) * m_nMeasure;
        iChord.wMeasure = m_nMeasure;
        iChord.bBeat = (BYTE)m_nBeat;
        iChord.bFlags = 0;
        if (m_fSilent) iChord.bFlags |= DMUS_CHORDKEYF_SILENT;
        dwSize = sizeof( iChord );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( SUCCEEDED(hr) &&
            SUCCEEDED( pStream->Write( &iChord, sizeof( iChord), &cb ) ) &&
            cb == sizeof( iChord) )
        {
            {
                DWORD dwCount = (WORD) m_pChord->m_pSubChords->GetCount();
                hr = pStream->Write( &dwCount, sizeof( dwCount ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                dwSize = sizeof( iSubChord );
                hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                for (TListItem<DMExtendedChord*>* pSub = m_pChord->m_pSubChords; pSub != NULL; pSub = pSub->GetNext())
                {
                    DMExtendedChord*& rSubChord = pSub->GetItemValue();
                    memset( &iSubChord, 0, sizeof( iSubChord ) );
                    iSubChord.dwChordPattern = rSubChord->m_dwChordPattern;
                    iSubChord.dwScalePattern = rSubChord->m_dwScalePattern;
                    iSubChord.dwInversionPoints = rSubChord->m_dwInvertPattern;
                    iSubChord.dwLevels = rSubChord->m_dwParts;
                    iSubChord.bChordRoot = rSubChord->m_bRoot;
                    iSubChord.bScaleRoot = rSubChord->m_bScaleRoot;
                    if( FAILED( pStream->Write( &iSubChord, sizeof( iSubChord ), &cb ) ) ||
                        cb != sizeof( iSubChord ) )
                    {
                        break;
                    }
                }
                // ascend from chord body chunk
                if( pSub == NULL &&
                    pRIFF->Ascend( &ck, 0 ) != 0 )
                {
                    hr = S_OK;
                }
            }
        }
    }
    pStream->Release();
    return hr;
}

char PlayChord::GetRoot()
{
    if (m_pChord)
    {
        return m_pChord->GetRoot();
    }
    else return 0;
}

void PlayChord::SetRoot(char chNewRoot)
{
    if (m_pChord)
    {
        m_pChord->SetRoot(chNewRoot);
    }
}



HRESULT LoadChordChunk(LPSTREAM pStream, PlayChord& rChord)
{
    DWORD           dwChordSize;
    DWORD           dwSubChordSize;
    DWORD           dwSubChordCount;
    DWORD           cb;
    HRESULT         hr;
    DMUS_IO_CHORD       iChord;
    DMUS_IO_SUBCHORD    iSubChord;

    memset(&iChord , 0, sizeof(iChord));
    memset(&iSubChord , 0, sizeof(iSubChord));

    hr = pStream->Read( &dwChordSize, sizeof( dwChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwChordSize ) )
    {
        return E_FAIL;
    }
    if( dwChordSize <= sizeof( DMUS_IO_CHORD ) )
    {
        pStream->Read( &iChord, dwChordSize, NULL );
    }
    else
    {
        pStream->Read( &iChord, sizeof( DMUS_IO_CHORD ), NULL );
        StreamSeek( pStream, dwChordSize - sizeof( DMUS_IO_CHORD ), STREAM_SEEK_CUR );
    }
    memset( &rChord, 0, sizeof( rChord) );
    rChord.m_nMeasure = iChord.wMeasure;
    rChord.m_nBeat = iChord.bBeat;
    rChord.m_fSilent = (iChord.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    rChord.m_pChord = new DMChordData;
    if (!rChord.m_pChord) return E_OUTOFMEMORY;
    rChord.m_pChord->m_strName = iChord.wszName;
    rChord.m_pChord->m_pSubChords = NULL;
    hr = pStream->Read( &dwSubChordCount, sizeof( dwSubChordCount ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordCount ) )
    {
        return E_FAIL;
    }
    hr = pStream->Read( &dwSubChordSize, sizeof( dwSubChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordSize ) )
    {
        return E_FAIL;
    }
    for (; dwSubChordCount > 0; dwSubChordCount--)
    {
        if( dwSubChordSize <= sizeof( DMUS_IO_SUBCHORD ) )
        {
            pStream->Read( &iSubChord, dwSubChordSize, NULL );
        }
        else
        {
            pStream->Read( &iSubChord, sizeof( DMUS_IO_SUBCHORD ), NULL );
            StreamSeek( pStream, dwSubChordSize - sizeof( DMUS_IO_SUBCHORD ), STREAM_SEEK_CUR );
        }
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = iSubChord.dwChordPattern;
                rSubChord->m_dwScalePattern = iSubChord.dwScalePattern;
                rSubChord->m_dwInvertPattern = iSubChord.dwInversionPoints;
                rSubChord->m_dwParts = iSubChord.dwLevels;
                rSubChord->m_bRoot = iSubChord.bChordRoot;
                rSubChord->m_bScaleRoot = iSubChord.bScaleRoot;
                rChord.m_pChord->m_pSubChords = rChord.m_pChord->m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                pSub = NULL;
            }
        }
        if (!pSub)
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

HRESULT LoadChordList(TList<PlayChord>& ChordList, LPSTREAM pStream,
                      BYTE &bRoot, DWORD &dwScalePattern)
{
    long lFileSize = 0;
    DWORD dwChunkSize;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    MMCKINFO        ckHeader;
    IAARIFFStream*  pRIFF;
    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;

    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );


    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            lFileSize = ckMain.cksize - 4; // subtract off the list type
            DWORD dwScale;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0 &&
                ckHeader.ckid == DMUS_FOURCC_CHORDTRACKHEADER_CHUNK )
            {
                lFileSize -= 8;  // chunk id + chunk size: double words
                lFileSize -= ckHeader.cksize;
                hr = pStream->Read( &dwScale, sizeof( dwScale ), &cb );
                if (FAILED(hr) || cb != sizeof( dwScale ) )
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pRIFF->Ascend( &ckHeader, 0 );
                    pRIFF->Release();
                    return hr;
                }
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            bRoot = (BYTE) (dwScale >> 24);
            dwScalePattern = dwScale & 0xffffff;
            while (lFileSize > 0)
            {
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0 &&
                    ck.ckid == mmioFOURCC('c','r','d','b') )
                {
                    dwChunkSize = ck.cksize;
                    TListItem<PlayChord>* pChord = new TListItem<PlayChord>;
                    if (!pChord) break;
                    PlayChord& rChord = pChord->GetItemValue();
                    if (FAILED(LoadChordChunk(pStream, rChord))) break;
                    ChordList.AddTail(pChord);
                    if (pRIFF->Ascend( &ck, 0 ) != 0) break;
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= dwChunkSize;
                }
                else break;
            }
            if (lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0)
            {
                hr = S_OK;
            }
        }
    }
    ChordList.MergeSort(Less);
    pRIFF->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDMCompos

CDMCompos::CDMCompos( )
  : m_cRef(1),
    m_dwFlags(0)
{
    InterlockedIncrement(&g_cComponent);
    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    srand((unsigned int)time(NULL));
    m_pChords = NULL;
}

CDMCompos::~CDMCompos()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

void CDMCompos::CleanUp()
{
    TListItem<DMChordData*>* pScan = m_pChords;
    for(; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        delete pScan->GetItemValue();
    }
    if (m_pChords)
    {
        TListItem<DMChordData*>::Delete(m_pChords);
        m_pChords = NULL;
    }
}

void CDMCompos::AddChord(DMChordData* pChord)
{
    TListItem<DMChordData*>* pNew = new TListItem<DMChordData*>(pChord);
    if (pNew)
    {
        pNew->SetNext(m_pChords);
        m_pChords = pNew;
    }
}


void CDMCompos::ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass)

{
    //TempCommand *ptcom = tclist->GetHead();
    TListItem<DMSignPost> *pSignPost;
    for (;pTempCommand; pTempCommand = pTempCommand->GetNext())
    {
        CompositionCommand& rTempCommand = pTempCommand->GetItemValue();
        short nTotal = 0;
        if ((rTempCommand.m_dwChord & dwType) == 0)
        {
            continue;   // Only command, no chord.
        }
        pSignPost = pSignPostHead;
        for (; pSignPost; pSignPost = pSignPost->GetNext())
        {
            DMSignPost& rSignPost = pSignPost->GetItemValue();
            if (rSignPost.m_dwTempFlags & rTempCommand.m_dwChord & dwType)
            {
                break;
            }
            else
            {
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass) nTotal++;
                }
            }
        }
        if (!pSignPost)
        {
            if (nTotal) nTotal = rand() % nTotal;
            else nTotal = 0;
            nTotal++;
            pSignPost = pSignPostHead;
            for (; pSignPost; pSignPost = pSignPost->GetNext())
            {
                DMSignPost& rSignPost = pSignPost->GetItemValue();
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass)
                    {
                        nTotal--;
                        if (!nTotal)
                        {
                            break;
                        }
                    }
                }
            }
        }
        if (pSignPost && !rTempCommand.m_pSignPost)
        {
            pSignPost->GetItemValue().m_dwTempFlags |= rTempCommand.m_dwChord;
            rTempCommand.m_pSignPost = pSignPost;
        }
    }
}

TListItem<CompositionCommand> *CDMCompos::GetNextChord(TListItem<CompositionCommand> *pCommand)

{
    if (pCommand) pCommand = pCommand->GetNext();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        if (pCommand->GetItemValue().m_dwChord == 0) continue;   // Only command, no chord.
        if (pCommand->GetItemValue().m_pSignPost) break;
    }
    return(pCommand);
}

void CDMCompos::FindEarlierSignpost(TListItem<CompositionCommand> *pCommand,
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch)

{
    CompositionCommand& rThis = pThis->GetItemValue();
    TListItem<CompositionCommand> *pBest = NULL;
    pSearch->m_pPlayChord = NULL;
    pSearch->m_pFirstChord = NULL;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (pCommand == pThis) break;
        if (!UsingDX8() || rCommand.m_dwChord == rThis.m_dwChord)
        {
            if (rCommand.m_pSignPost == rThis.m_pSignPost)
            {
                if (rCommand.m_SearchInfo.m_End.Equals(
                    rThis.m_SearchInfo.m_End))
                {
                        pSearch->m_pPlayChord = rCommand.m_PlayList.GetHead();
                        pSearch->m_pFirstChord = rCommand.m_pFirstChord;
                        return;
                }
                pBest = pCommand;
            }
        }
    }
    if (pBest)
    {
        pSearch->m_pPlayChord = pBest->GetItemValue().m_PlayList.GetHead();
        pSearch->m_pFirstChord = pBest->GetItemValue().m_pFirstChord;
    }
}


static void ClearChordFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)
{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_dwFlags &= ~dwFlag;
    }
}

static void ClearNextFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)

{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        TListItem<DMChordLink> *pScan = pChord->GetItemValue().m_Links.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            pScan->GetItemValue().m_dwFlags &= ~dwFlag;
        }
    }
}

// rCommand will hold the first chord and playlist
BOOL CDMCompos::Compose(TList<DMChordEntry>& ChordMap, SearchInfo *pSearch, CompositionCommand& rCommand)

{
    TListItem<PlayChord> *pDupe;
    TListItem<DMChordEntry> *pChord = NULL;
    SearchInfo tempSearch;
    FailSearch tempFail;
    tempSearch = *pSearch;
    int i = 0;
    // First, if we have a previous instance with the same starting point,
    // try to come up with a solution using its path.
    if (pSearch->m_pPlayChord && pSearch->m_pFirstChord)
    {
        pChord = pSearch->m_pFirstChord;
        ClearNextFlags(ChordMap, NC_PATH);
        ClearChordFlags(ChordMap, CE_PATH);
        if (pChord->GetItemValue().Walk(pSearch))
        {
        }
        else
        {
            pChord = NULL;
        }
    }
    if (!pChord)
    {
        pChord = ChordMap.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            DMChordEntry& rChord = pChord->GetItemValue();
            if (rChord.m_dwFlags & CE_START)
            {
                if (rChord.m_ChordData.Equals(pSearch->m_Start))
                {
                    ClearNextFlags(ChordMap, NC_PATH);
                    ClearChordFlags(ChordMap, CE_PATH);
                    tempFail = pSearch->m_Fail;
                    *pSearch = tempSearch;
                    pSearch->m_Fail = tempFail;
                    if (rChord.Walk(pSearch)) break;
                }
            }
        }
    }
    if (!pChord)
    {
        return(FALSE);
    }
    pDupe = new TListItem<PlayChord>;
    if (pDupe)
    {
        PlayChord& rDupe = pDupe->GetItemValue();
        rDupe.m_fSilent = false;
        rDupe.m_pChord = &pChord->GetItemValue().m_ChordData;
        rDupe.m_nMeasure = (short)i++;
        rDupe.m_nMinbeats = rDupe.m_nMaxbeats = 0;
        rDupe.m_pNext = NULL;
        pDupe->SetNext(NULL);
        rCommand.m_pFirstChord = pChord;
        rCommand.m_PlayList.AddTail(pDupe);
    }
    for (; pChord; )
    {
        TListItem<DMChordLink> *pNext = pChord->GetItemValue().m_Links.GetHead();
        for (; pNext; )
        {
            DMChordLink& rNext = pNext->GetItemValue();
            if (rNext.m_dwFlags & NC_PATH)
            {
                pDupe = new TListItem<PlayChord>;
                if (pDupe)
                {
                    PlayChord& rDupe = pDupe->GetItemValue();
                    rDupe.m_fSilent = false;
                    rDupe.m_pChord = &rNext.m_pChord->GetItemValue().m_ChordData;
                    rDupe.m_nMeasure = (short)i++;
                    rDupe.m_nMinbeats = (short)rNext.m_wMinBeats;
                    rDupe.m_nMaxbeats = (short)rNext.m_wMaxBeats;
                    rDupe.m_pNext = pNext;
                    pDupe->SetNext(NULL);
                    rCommand.m_PlayList.AddTail(pDupe);
                }
                break;
            }
            else
            {
                pNext = pNext->GetNext();
            }
        }
        if (pNext)
        {
            pChord = pNext->GetItemValue().m_pChord;
        }
        else pChord = NULL;
    }
    return(TRUE);
}

TListItem<PlayChord> *CDMCompos::AddChord(TList<PlayChord>& rList, DMChordData *pChord,
                    int nMeasure,int nBeat)

{
    if (pChord->m_pSubChords)
    {
        TListItem<PlayChord> *pNext = new TListItem<PlayChord>;
        if (pNext)
        {
            pNext->GetItemValue().m_pChord = new DMChordData(*pChord);
            if (pNext->GetItemValue().m_pChord)
            {
                AddChord(pNext->GetItemValue().m_pChord);
                pNext->GetItemValue().m_fSilent = false;
                pNext->GetItemValue().m_nMeasure = (short)nMeasure;
                pNext->GetItemValue().m_nBeat = (short)nBeat;
                pNext->GetItemValue().m_nMinbeats = 1;
                pNext->GetItemValue().m_pNext = NULL;
                rList.AddTail(pNext);
            }
            else
            {
                delete pNext;
                pNext = NULL;
            }
        }
        return (pNext);
    }
    else return NULL;
}

TListItem<PlayChord> *CDMCompos::AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax)

{
    TListItem<PlayChord> *pNext = AddChord(rList, pChord, 0, 0);
    if (pNext)
    {
        pNext->GetItemValue().m_nMaxbeats = (short)nMax;
    }
    return (pNext);
}

void CDMCompos::JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats)

{
    PlayChord& rChord = pChord->GetItemValue();
    TListItem<PlayChord> *pLast = rList.GetPrev(pChord);
    if (nBeats && pLast)
    {
        int distance;
        rChord.m_nBeat = (short)( rChord.m_nBeat + nBeats );
        distance = rChord.m_nBeat - pLast->GetItemValue().m_nBeat;
        if (distance > rChord.m_nMaxbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMaxbeats);
        }
        else if (distance < rChord.m_nMinbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMinbeats);
        }
    }
}

static BOOL inline InRange(TListItem<PlayChord> *pChord,int nLastbeat)

{
    PlayChord& rChord = pChord->GetItemValue();
    int time = rChord.m_nBeat - nLastbeat;
    return ((time >= rChord.m_nMinbeats) && (time <= rChord.m_nMaxbeats));
}

BOOL CDMCompos::AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes)

{
    if (pChord)
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (!(pChord->GetNext()))
        {
            return (InRange(pChord, nLastbeat));
        }
        if ((rChord.m_nBeat % nRes) == 0)
        {
            if (InRange(pChord, nLastbeat))
            {
                return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
            }
            return(FALSE);
        }
        BOOL tryright = rand() % 2;
        int old = rChord.m_nBeat;
        rChord.m_nBeat = (short)( ( rChord.m_nBeat / nRes ) * nRes );
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        else rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (!tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        rChord.m_nBeat = (short)( rChord.m_nBeat + ( ( nRes + 1 ) >> 1 ) );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        rChord.m_nBeat = (short)old;
        if (InRange(pChord, nLastbeat))
        {
            return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
        }
    }
    return (FALSE);
}

void CDMCompos::ChordConnections(TList<DMChordEntry>& ChordMap,
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2)

{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    if (pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    tempSearch = *pSearch;
    for (total = 0;total < 4;total++)
    {
        rCommand.m_PlayList.RemoveAll();
        Compose(ChordMap, pSearch, rCommand);
        pChord = rCommand.m_PlayList.GetHead();
        if (pChord) break;
        if (pSearch->m_Fail.m_nTooManybeats > pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats >> 1 );
        }
        else if (pSearch->m_Fail.m_nTooManybeats < pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats << 1 );
        }
        else if (pSearch->m_Fail.m_nTooManychords > pSearch->m_Fail.m_nTooFewchords)
        {
            break;      // Can't possibly get better.  Use Cadence.
        }
        else if (pSearch->m_Fail.m_nTooManychords < pSearch->m_Fail.m_nTooFewchords)
        {
            tempSearch.m_nMinChords = (short)( tempSearch.m_nMinChords >> 1 );
        }
        else break;
        *pSearch = tempSearch;
    }
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // It should not be the case that total is 0 after this loop, but it is possible.
    // (particularly if the playlist contains a single chord).  If this happens, give
    // total a value of 1 to make the computations in the following loop work correctly.
    if (!total) total = 1;
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        rChord.m_nBeat = (short)newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord && (int)pSearch->m_nBeats >= total)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure =
            (short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

static TListItem<PlayChord> *FindChordInMeasure(TList<PlayChord>& PlayList,int nMeasure)

{
    TListItem<PlayChord> *pChord = PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (rChord.m_nMeasure > nMeasure) break;
        if (rChord.m_nMeasure == nMeasure)
        {
            if (rChord.m_nBeat) return(pChord);
        }
    }
    return(NULL);
}

void CDMCompos::CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand)
{
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if ((rCommand.m_Command.bCommand == DMUS_COMMANDT_BREAK) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_END) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_INTRO) )
        {
            TListItem<PlayChord> *pChord;

            while( ( pChord = FindChordInMeasure( PlayList, rCommand.m_nMeasure ) ) != NULL )
            {
                PlayList.Remove(pChord);
                delete pChord;
            }
        }
    }
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pCStream)
{
    HRESULT         hr = E_FAIL;
    IAARIFFStream*  pRIFF;
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;

    StreamSeek(pCStream, 0, STREAM_SEEK_SET);

    if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == FOURCC_COMMAND)
    {
        DMUS_IO_COMMAND iCommand;
        lFileSize = ck.cksize;
        hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<TemplateCommand>* pCommand;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pCommand = new TListItem<TemplateCommand>;
                    if( pCommand )
                    {
                        TemplateCommand& rCommand = pCommand->GetItemValue();
                        if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                        {
                            pCStream->Read( &iCommand, dwNodeSize, NULL );
                        }
                        else
                        {
                            pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                            StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                        }
                        memset( &rCommand, 0, sizeof( rCommand ) );
                        rCommand.m_nMeasure = iCommand.wMeasure;
                        rCommand.m_Command.bCommand = iCommand.bCommand;
                        rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                        rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                        rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                        rCommand.m_dwChord = 0;
                        CommandList.AddTail(pCommand);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pRIFF->Release();
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pSPStream, LPSTREAM pCStream)
{
    TList<DMSignPostStruct> SignPostList;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF = NULL;

    dwPos = StreamTell( pSPStream );
    StreamSeek( pSPStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    DMUS_IO_SIGNPOST        iSignPost;

    if( SUCCEEDED( AllocRIFFStream( pSPStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == DMUS_FOURCC_SIGNPOST_TRACK_CHUNK)
    {
        lFileSize = ck.cksize;
        hr = pSPStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMSignPostStruct>* pSignPost;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pSignPost = new TListItem<DMSignPostStruct>;
                    if( pSignPost )
                    {
                        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
                        if( dwNodeSize <= sizeof( iSignPost ) )
                        {
                            pSPStream->Read( &iSignPost, dwNodeSize, NULL );
                        }
                        else
                        {
                            pSPStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
                            StreamSeek( pSPStream, lFileSize - sizeof( iSignPost ), STREAM_SEEK_CUR );
                        }
                        memset( &rSignPost, 0, sizeof( rSignPost ) );
                        rSignPost.m_mtTime = iSignPost.mtTime;
                        rSignPost.m_wMeasure = iSignPost.wMeasure;
                        rSignPost.m_dwChords = iSignPost.dwChords;
                        SignPostList.AddTail(pSignPost);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (pRIFF)
    {
        pRIFF->Release();
        pRIFF = NULL;
    }

    // If a command stream exists, load the commands into the command list.
    if (pCStream)
    {
        StreamSeek(pCStream, 0, STREAM_SEEK_SET);

        if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
            pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
            ck.ckid == FOURCC_COMMAND)
        {
            DMUS_IO_COMMAND iCommand;
            lFileSize = ck.cksize;
            hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
            if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
            {
                lFileSize -= 4; // for the size dword
                TListItem<TemplateCommand>* pCommand;
                if (lFileSize % dwNodeSize)
                {
                    hr = E_FAIL;
                }
                else
                {
                    while( lFileSize > 0 )
                    {
                        pCommand = new TListItem<TemplateCommand>;
                        if( pCommand )
                        {
                            TemplateCommand& rCommand = pCommand->GetItemValue();
                            if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                            {
                                pCStream->Read( &iCommand, dwNodeSize, NULL );
                            }
                            else
                            {
                                pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                                StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                            }
                            memset( &rCommand, 0, sizeof( rCommand ) );
                            rCommand.m_nMeasure = iCommand.wMeasure;
                            rCommand.m_Command.bCommand = iCommand.bCommand;
                            rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                            rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                            rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                            CommandList.AddTail(pCommand);
                            lFileSize -= dwNodeSize;
                        }
                        else break;
                    }
                }
            }
            if( lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if (pRIFF) pRIFF->Release();
    }

    // Now, go through the signpost list, making sure that every signpost has a corresponding
    // command.  If this is not the case for some signpost, insert a groove with the last
    // current groove level into the list (default this to 67).  Give each command's m_dwChord
    // the m_dwChords value from the corresponding signpost.
    BYTE bGrooveLevel = 62;
    TListItem<DMSignPostStruct>* pSignPost = SignPostList.GetHead();
    for( ; pSignPost; pSignPost = pSignPost->GetNext())
    {
        bool fFoundInList = false;
        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
        TListItem<TemplateCommand>* pPrevious = NULL;
        TListItem<TemplateCommand>* pCommand = CommandList.GetHead();
        for ( ; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rSignPost.m_wMeasure == rCommand.m_nMeasure)
            {
                rCommand.m_dwChord = rSignPost.m_dwChords;
                fFoundInList = true;
                break;
            }
            else if (rSignPost.m_wMeasure < rCommand.m_nMeasure)
            {
                // We went too far in the command list, so break out
                break;
            }
            if (rCommand.m_Command.bGrooveLevel)
            {
                bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            }
            pPrevious = pCommand;
        }
        if ( !fFoundInList )
        {
            // We need to create a new command and stick it between pPrevious and pCommand
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if( pNew )
            {
                TemplateCommand& rNew = pNew->GetItemValue();
                memset( &rNew, 0, sizeof( rNew ) );
                rNew.m_nMeasure = rSignPost.m_wMeasure;
                rNew.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                rNew.m_Command.bGrooveLevel = bGrooveLevel;
                rNew.m_Command.bGrooveRange = 0;
                rNew.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                rNew.m_dwChord = rSignPost.m_dwChords;
                if (pPrevious)
                {
                    pPrevious->SetNext(pNew);
                    pNew->SetNext(pCommand);
                }
                else
                {
                    CommandList.AddHead(pNew);
                }
            }
        }
    }
}

HRESULT CDMCompos::SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    HRESULT     hr;
    TListItem<PlayChord>*   pChord;
    DWORD cb;


    pStream = pRIFF->GetStream();

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {

        DWORD dwRoot = bRoot;
        dwScale |= (dwRoot << 24);

        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (SUCCEEDED(hr))
        {
            hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
            if (SUCCEEDED(hr))
            {
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (hr == S_OK)
                {
                    pChord = rPlayList.GetHead();
                    for( ; pChord != NULL ; pChord = pChord->GetNext() )
                    {
                        hr = pChord->GetItemValue().Save(pRIFF, rTimeSig);
                        if (FAILED(hr))
                        {
                            pStream->Release();
                            return hr;
                        }
                    }
                    if( pChord == NULL &&
                        pRIFF->Ascend( &ck, 0 ) == 0 )
                    {
                        hr = S_OK;
                    }
                }

            }
        }
    }

    pStream->Release();
    return hr;
}

static HRESULT SaveCommandList( IAARIFFStream* pRIFF,  TList<TemplateCommand>& rCommandList,
                               DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release( );
            return E_FAIL;
        }
        for( pCommand = rCommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
            iCommand.wMeasure = rCommand.m_nMeasure;
            iCommand.bBeat = 0;
            iCommand.bCommand = rCommand.m_Command.bCommand;
            iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
            iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release( );
    return hr;
}

static HRESULT SaveStartMarkers( IAARIFFStream* pRIFF,  TemplateCommand& rCommand,
                               IDMStyle* pStyle)
{
    IStream*    pStream;
    MMCKINFO    ckMain;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_VALID_START oValidStart;
    bool fWroteOne = false;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ckMain.ckid = FOURCC_LIST;
    ckMain.fccType = DMUS_FOURCC_MARKERTRACK_LIST;
    if( pRIFF->CreateChunk( &ckMain, MMIO_CREATELIST ) == 0 )
    {
        ck.ckid = DMUS_FOURCC_VALIDSTART_CHUNK;
        if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
        {
            dwSize = sizeof( DMUS_IO_VALID_START );
            hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
            if( FAILED( hr ) || cb != sizeof( dwSize ) )
            {
                pStream->Release( );
                return E_FAIL;
            }
            DWORD dwIndex = 0;
            MUSIC_TIME mtTime = 0;
            while(S_OK == (hr = pStyle->EnumStartTime(dwIndex, &rCommand.m_Command, &mtTime)))
            {
                memset( &oValidStart, 0, sizeof( oValidStart ) );
                oValidStart.mtTime = mtTime;
                if( FAILED( hr = pStream->Write( &oValidStart, sizeof( oValidStart ), &cb ) ) ||
                    cb != sizeof( oValidStart ) )
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    break;
                }
                fWroteOne = true;
                dwIndex++;
            }
            if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (!fWroteOne) hr = E_FAIL;

    pStream->Release( );
    return hr;
}

void CDMCompos::ComposePlayList(TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity)
{
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if (wActivity < 0) wActivity = 0;
    if (wActivity > 3) wActivity = 3;
    short nBPM = TimeSig.bBeatsPerMeasure;
    IDMPers* pDMP;
    pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
    DMPersonalityStruct* pPers;
    pDMP->GetPersonalityStruct((void**)&pPers);
    TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
    TList<CompositionCommand> CommandList;
    TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
    for(; pTC; pTC = pTC->GetNext())
    {
        TemplateCommand& rTC = pTC->GetItemValue();
        TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
        if (pNew)
        {
            CompositionCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rTC.m_nMeasure;
            rNew.m_Command = rTC.m_Command;
            rNew.m_dwChord = rTC.m_dwChord;
            rNew.m_pSignPost = NULL;
            rNew.m_pFirstChord = NULL;
            CommandList.AddTail(pNew);
        }
    }
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
   // Now, we should have a chord assigned for each node in the template.
    TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
        if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
                CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    TListItem<DMSignPost> *pLocalSign = rNext.m_pSignPost;
                    DMSignPost& rSign = pLocalSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats >> wActivity );
                pSearch->m_nMinChords = (short)( pSearch->m_nBeats >> (wActivity + 1) );
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
                // rCommand holds the playlist and the measure used by ChordConnections
                // (it should be passed by reference since the playlist changes)
                ChordConnections(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
            }
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
                    rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
    pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
    pDMP->Release();
}

HRESULT CDMCompos::ExtractCommandList(TList<TemplateCommand>& CommandList,
                                      IDirectMusicTrack*    pSignPostTrack,
                                      IDirectMusicTrack*    pCommandTrack,
                                      DWORD dwGroupBits)
{
    HRESULT             hr              = S_OK;
    IPersistStream*     pPS1            = NULL;
    IPersistStream*     pPS2            = NULL;
    IStream*            pStream1        = NULL;
    IStream*            pStream2        = NULL;

    // First, get the signpost track from the template segment and persist it to a stream
    if (!pSignPostTrack)
    {
        Trace(1, "ERROR: No signpost track to use for chord composition.\n");
        hr = E_POINTER;
        goto ON_END;
    }
    hr = pSignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pPS1);
    if (hr != S_OK) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream1);
    if (hr != S_OK) goto ON_END;
    hr = pPS1->Save(pStream1, FALSE);
    if (hr != S_OK) goto ON_END;
    StreamSeek(pStream1, 0, STREAM_SEEK_SET);


    // Next, get the command track from the template segment and persist it to a stream.
    // If there is no command track, we'll just use a NULL stream.
    if (pCommandTrack)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS2);
        if (hr != S_OK) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream2);
        if (hr != S_OK) goto ON_END;
        hr = pPS2->Save(pStream2, FALSE);
        if (hr != S_OK) goto ON_END;
        StreamSeek(pStream2, 0, STREAM_SEEK_SET);
    }

    // Finally, call LoadCommandList, passing in the two streams.
    LoadCommandList(CommandList, pStream1, pStream2);

ON_END:
    if (pPS1) pPS1->Release();
    if (pPS2) pPS2->Release();
    if (pStream1) pStream1->Release();
    if (pStream2) pStream2->Release();
    return hr;
}

// This will modify an existing segment by adding *only* a chord track to it.
// Any existing chord tracks with conflicting group bits will be removed.
HRESULT CDMCompos::AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;

    /////////////////////////////////////////////////////////////
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        // if there exists a chord track with these group bits, reload these chords into that
        // track (use the first track that's found).  Otherwise, create a new chord track
        // to load these chords into.
        hr = pTempSeg->GetTrack(CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIChordTrack);
        if (S_OK != hr)
        {
            // create a new chord track
            hr = ::CoCreateInstance(
                CLSID_DirectMusicChordTrack,
                NULL,
                CLSCTX_INPROC,
                IID_IDirectMusicTrack,
                (void**)&pIChordTrack
                );
            if (!SUCCEEDED(hr)) goto ON_END;
            // insert the new chord track.
            pTempSeg->InsertTrack(pIChordTrack, dwGroupBits);
        }
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    return hr;
}

HRESULT CDMCompos::CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    DWORD dwStyleGroupBits = 1;
    if (UsingDX8(pStyle, pChordMap))
    {
        for (int i = 0; i < 32; i++)
        {
            if (dwGroupBits & (1 << i))
            {
                dwStyleGroupBits = 1 << i;
                break;
            }
        }
    }
    else
    {
        dwGroupBits = 1;
    }

    pTempSeg->GetLength(&nClocks);
    /////////////////////////////////////////////////////////////
    // clone the template segment to get a section segment
    hr = pTempSeg->Clone(0, nClocks, ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        (*ppSectionSeg)->InsertTrack(pIChordTrack, dwGroupBits);
    }

    // If the passed-in Style is not from the template segment,
    // remove all style tracks from the new segment and add a new Style track.
    if (!fStyleFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pIStyleTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIStyleTrack);
                pIStyleTrack->Release();
            }
        } while (S_OK == hr);
        hr = ::CoCreateInstance(
            CLSID_DirectMusicStyleTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIStyleTrack
        );
        if (FAILED(hr)) goto ON_END;
        pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);
        (*ppSectionSeg)->InsertTrack(pIStyleTrack, dwStyleGroupBits);
    }

    // If the passed-in ChordMap is not from the template segment,
    // remove all ChordMap tracks from the new segment and add a new ChordMap track.
    if (!fChordMapFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicChordMapTrack, ALL_TRACK_GROUPS, 0, &pIChordMapTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIChordMapTrack);
                pIChordMapTrack->Release();
            }
        } while (S_OK == hr);
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordMapTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordMapTrack
        );
        if (FAILED(hr)) goto ON_END;
        pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);
        (*ppSectionSeg)->InsertTrack(pIChordMapTrack, dwGroupBits);
    }

    // if there's no tempo track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pDMTrack)))
    {
        // Create a Tempo Track in which to store the tempo events
        DMUS_TEMPO_PARAM tempo;
        tempo.mtTime = 0; //ConvertTime( dwTime );

        pStyle->GetTempo(&tempo.dblTempo);
        if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
            NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
            (void**)&pDMTrack )))
        {
            if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
            {
                (*ppSectionSeg)->InsertTrack( pDMTrack, dwGroupBits );
            }
        }
    }
    // if there's no band track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicBandTrack, ALL_TRACK_GROUPS, 0, &pBandTrack)))
    {
        // Create band track
        hr = ::CoCreateInstance(
            CLSID_DirectMusicBandTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pBandTrack
            );

        if(!SUCCEEDED(hr)) goto ON_END;

        // Load default band from style into track
        // If for some reason the style doesn't have a default band (could happend
        // if the style came from a pattern track), don't make a band track.
        if (pStyle->GetDefaultBand(&pBand) == S_OK)
        {
            DMBandParam.mtTimePhysical = -64;
            DMBandParam.pBand = pBand;
            hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
            if (!SUCCEEDED(hr)) goto ON_END;
            (*ppSectionSeg)->InsertTrack(pBandTrack, dwGroupBits);
        }
    }

    // Initialize the segment
    (*ppSectionSeg)->SetRepeats(0); // still needed for dx7
    TraceI(4, "Segment Length: %d\n", nClocks);
    (*ppSectionSeg)->SetLength(nClocks);
    if (UsingDX8(pStyle, pChordMap))
    {
        DWORD dwLoopRepeats = 0;
        pTempSeg->GetRepeats( &dwLoopRepeats );
        (*ppSectionSeg)->SetRepeats( dwLoopRepeats );
        MUSIC_TIME mtLoopStart = 0, mtLoopEnd = 0;
        pTempSeg->GetLoopPoints( &mtLoopStart, &mtLoopEnd );
        (*ppSectionSeg)->SetLoopPoints( mtLoopStart, mtLoopEnd );
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pDMTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pDMTrack->Release();
    }
    if (pBandTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pBandTrack->Release();
    }
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

HRESULT CDMCompos::BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale,
                            double* pdblTempo,
                            IDirectMusicBand* pCurrentBand,
                            bool fAlign,
                            IDirectMusicGraph* pGraph,
                            IUnknown* pPath)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pICommandTrack          = NULL;
    IAARIFFStream*          pCommandRIFF            = NULL;
    IStream*                pICommandStream         = NULL;
    IPersistStream*         pICommandTrackStream    = NULL;
    IDirectMusicTrack*      pIMarkerTrack           = NULL;
    IAARIFFStream*          pMarkerRIFF             = NULL;
    IStream*                pIMarkerStream          = NULL;
    IPersistStream*         pIMarkerTrackStream     = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    // create a section segment
    hr = ::CoCreateInstance(
        CLSID_DirectMusicSegment,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicSegment,
        (void**)ppSectionSeg
    );
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    nClocks = (lMeasures) * TimeSig.bBeatsPerMeasure * (DMUS_PPQ * 4 / TimeSig.bBeat);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }
    // Convert CommandList into a Command Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicCommandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pICommandTrack
        );
    if (!SUCCEEDED(hr)) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (S_OK != hr) goto ON_END;
    SaveCommandList(pCommandRIFF, CommandList, TimeSig);
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if (!SUCCEEDED(hr)) goto ON_END;

    // If the align flag's been set, create a marker track
    if (fAlign)
    {
        TListItem<TemplateCommand>* pCommandItem = CommandList.GetHead();
        IDMStyle* pDMStyle = NULL;
        if (pCommandItem &&
            pStyle &&
            SUCCEEDED(pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            hr = ::CoCreateInstance(
                CLSID_DirectMusicMarkerTrack,
                NULL,
                CLSCTX_INPROC,
                IID_IDirectMusicTrack,
                (void**)&pIMarkerTrack
                );

            if (!SUCCEEDED(hr))
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = CreateStreamOnHGlobal(NULL, TRUE, &pIMarkerStream);
            if (S_OK != hr)
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = AllocRIFFStream( pIMarkerStream, &pMarkerRIFF);
            if (S_OK != hr)
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = SaveStartMarkers(pMarkerRIFF, pCommandItem->GetItemValue(), pDMStyle);
            // If the above fails, it means the style doesn't have any markers, so just
            // continue without creating a marker track.
            if (SUCCEEDED(hr))
            {
                hr = pIMarkerTrack->QueryInterface(IID_IPersistStream, (void**)&pIMarkerTrackStream);
                if (!SUCCEEDED(hr))
                {
                    pDMStyle->Release();
                    goto ON_END;
                }

                StreamSeek(pIMarkerStream, 0, STREAM_SEEK_SET);
                hr = pIMarkerTrackStream->Load(pIMarkerStream);
                if (!SUCCEEDED(hr))
                {
                    pDMStyle->Release();
                    goto ON_END;
                }

            }

            pDMStyle->Release();
        }
    }

    // Use the passed-in Style to create a Style Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicStyleTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIStyleTrack
    );
    if (FAILED(hr)) goto ON_END;
    pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);

    // Use the passed-in ChordMap to create a ChordMap Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicChordMapTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIChordMapTrack
    );
    if (FAILED(hr)) goto ON_END;
    pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);

    // Create a Tempo Track in which to store the tempo events
    ////////////////////////////////////////////////////////////
    DMUS_TEMPO_PARAM tempo;
    tempo.mtTime = 0; //ConvertTime( dwTime );

    if (!pdblTempo)
    {
        pStyle->GetTempo(&tempo.dblTempo);
    }
    else
    {
        tempo.dblTempo = *pdblTempo;
    }
    ////////////////////////////////////////////////////////////
    if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
        NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
        (void**)&pDMTrack )))
    {
        if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
        {
            (*ppSectionSeg)->InsertTrack( pDMTrack, 1 );
        }
    }
    // Create a new band track.
    hr = ::CoCreateInstance(
        CLSID_DirectMusicBandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pBandTrack
        );

    if(!SUCCEEDED(hr)) goto ON_END;

    // Add either the band passed in, or the style's default band.
    if (pCurrentBand)
    {
        pBand = pCurrentBand;
        pBand->AddRef(); // Needed because we release the band before returning
    }
    else
    {
        hr = pStyle->GetDefaultBand(&pBand);
    }
    DMBandParam.mtTimePhysical = -64;
    DMBandParam.pBand = pBand;
    hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
    if (!SUCCEEDED(hr)) goto ON_END;

    // Initialize the segment and insert the above tracks
    (*ppSectionSeg)->SetRepeats(0);
    (*ppSectionSeg)->SetLength(nClocks);
    (*ppSectionSeg)->InsertTrack(pBandTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIStyleTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIChordMapTrack, 1);
    (*ppSectionSeg)->InsertTrack(pICommandTrack, 1);
    if (pIMarkerTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIMarkerTrack, 1);
    }
    if (pIChordTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIChordTrack, 1);
    }
    // Add the graph
    if (pGraph)
    {
        (*ppSectionSeg)->SetGraph(pGraph);
    }
    // Add the Audio Path
    if (pPath)
    {
        IDirectMusicSegment8P* pSegP = NULL;
        if (SUCCEEDED((*ppSectionSeg)->QueryInterface(IID_IDirectMusicSegment8P, (void**)&pSegP)))
        {
            pSegP->SetAudioPathConfig(pPath);
            pSegP->Release();
        }
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pICommandTrack) pICommandTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pDMTrack) pDMTrack->Release();
    if (pBandTrack) pBandTrack->Release();
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIMarkerTrack) pIMarkerTrack->Release();
    if (pMarkerRIFF) pMarkerRIFF->Release();
    if (pIMarkerStream) pIMarkerStream->Release();
    if (pIMarkerTrackStream) pIMarkerTrackStream->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection)

{
    BYTE bGrooveLevel = 0;
    BYTE bRiff = 0;

    if (nDirection > 0)
    {
        while (nDirection > 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 37; break;
                case 37 : bGrooveLevel = 62; break;
                case 62 : bGrooveLevel = 87; break;
                case 87 : bGrooveLevel = 87; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_FILL; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_FILL; break;
                default: bRiff = rCommand.bCommand;
            }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection--;
        }
    }
    else if (nDirection == 0)
    {
        rResult.bGrooveLevel = rCommand.bGrooveLevel;
        rResult.bCommand = rCommand.bCommand;
    }
    else if (nDirection < 0)
    {
        while (nDirection < 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 12; break;
                case 37 : bGrooveLevel = 12; break;
                case 62 : bGrooveLevel = 37; break;
                case 87 : bGrooveLevel = 62; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_BREAK; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_BREAK; break;
                default: bRiff = rCommand.bCommand;
           }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection++;
        }
    }
}

static void InsertStuff(int nMeasure,
        TListItem<TemplateCommand> *pCommands,
        TListItem<PlayChord> *pPlayChord,
        TList<TemplateCommand> &rCommandList,
        TList<PlayChord> &rChordList,
        int nDirection)

{
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            rCommandList.AddHead(pNew);
        }
    }
    for (; pPlayChord; pPlayChord = pPlayChord->GetNext())
    {
        PlayChord& rChord = pPlayChord->GetItemValue();
        TListItem<PlayChord>* pNew = new TListItem<PlayChord>;
        if (pNew)
        {
            PlayChord& rNew = pNew->GetItemValue();
            rNew.m_fSilent = rChord.m_fSilent;
            rNew.m_pChord = rChord.m_pChord;
            rNew.m_pNext = rChord.m_pNext;
            rNew.m_dwFlags = rChord.m_dwFlags;
            rNew.m_nMeasure = rChord.m_nMeasure + (short)nMeasure;
            rNew.m_nBeat = rChord.m_nBeat;
            rNew.m_nMinbeats = rChord.m_nMinbeats;
            rNew.m_nMaxbeats = rChord.m_nMaxbeats;
            rChordList.AddHead(pNew);
        }
    }
}

void InsertCommand(int nMeasure, int nLength, TList<TemplateCommand> &rCommandList, BYTE bCommand)

{
    // insert nLength bars before nMeasure
    nMeasure -= nLength;
    TListItem<TemplateCommand> *pTarget = NULL;
    TListItem<TemplateCommand> *pCommand = rCommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_nMeasure == nMeasure)
        {
            pTarget = pCommand;
        }
        // return if another command would interupt this one
        else if ( (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel) &&
                  (rCommand.m_nMeasure > nMeasure) &&
                  (rCommand.m_nMeasure < nMeasure + nLength) )
        {
            return;
        }
    }
    if (pTarget)
    {
        pTarget->GetItemValue().m_Command.bCommand = bCommand;
    }
    else
    {
        pCommand = new TListItem<TemplateCommand>;
        if (pCommand)
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            rCommand.m_nMeasure = (short)nMeasure;
            rCommand.m_Command.bCommand = bCommand;
            rCommandList.AddHead(pCommand);
        }
    }
}

int WeightedRand(int nRange);

HRESULT CDMCompos::ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle,
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                )
{
    HRESULT hr = S_OK;
    TListItem<TemplateCommand>* pCommand = NULL;

    int nOriginalMeasures = 0;
    if (fComposeIntro)
    {
        lNumMeasures -= nIntroLength;
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = (int)lNumMeasures;
        lNumMeasures -= (nLength - 1);
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    TemplateStruct Template;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (lNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) lNumMeasures++;
        Template.m_nMeasures = (short)lNumMeasures;
        Template.CreateSignPosts();
        Template.CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            lNumMeasures--;
            Template.m_nMeasures = (short)lNumMeasures;
        }
        ComposePlayList(PlayList, pStyle, pPersonality, Template.m_CommandList, wActivity);
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        TListItem<TemplateCommand> *apCommands[8];
        TList<PlayChord> aPlayList[8];
        TListItem<PlayChord>* apChords[8];
        int anLengths[8];
        int anGrooveLevel[8];
        int anPlayCount[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) lNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[rand() % 10];

            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[nTypeIndex], pStyle, pPersonality, apTempl[nTypeIndex]->m_CommandList, wActivity);
                apCommands[nTypeIndex] = apTempl[nTypeIndex]->m_CommandList.GetHead();
                apChords[nTypeIndex] = aPlayList[nTypeIndex].GetHead();
                anPlayCount[nTypeIndex] = 0;
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
            else
            {
                apCommands[nTypeIndex] = NULL;
            }
        }
        anPlayCount[0] = 1;
        anGrooveLevel[0] = 0;
        Template.m_nMeasures = (short)lNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < lNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((lNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = (short) (lNumMeasures - nMeasure);
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[0], pStyle, pPersonality, apTempl[0]->m_CommandList, wActivity);
                apCommands[0] = apTempl[0]->m_CommandList.GetHead();
                apChords[0] = aPlayList[0].GetHead();
                anPlayCount[0] = 0;
                anGrooveLevel[0] = 0;
                if (rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            InsertStuff(nMeasure, apCommands[nChoice], apChords[nChoice],
                Template.m_CommandList, PlayList, nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (rand() % 3)
                {
                    if (rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            anPlayCount[nChoice]++;
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((lNumMeasures - nMeasure) > nShortestLength)
            {
                while ((lNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        Template.m_CommandList.MergeSort(Less);
        PlayList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (lNumMeasures != nOriginalMeasures)
        {
            Template.m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        Template.AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        Template.AddIntro(PlayList, nIntroLength);
    }
    pCommand = Template.m_CommandList.GetHead();
    for(; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel)
        {
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if (!pNew)
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            pNew->GetItemValue().m_nMeasure = rCommand.m_nMeasure;
            pNew->GetItemValue().m_Command = rCommand.m_Command;
            pNew->GetItemValue().m_dwChord = rCommand.m_dwChord;
            CommandList.AddTail(pNew);
        }
    }

ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}


static short ChordMisses(DWORD dwScalePattern, DWORD dwChordPattern, char chRoot)

{
    short nErrors = 0;
    dwScalePattern &= 0xFFF;
    dwScalePattern |= (dwScalePattern << 12);
    while (chRoot < 0) chRoot += 12;
    while (chRoot > 11) chRoot -= 12;
    dwChordPattern = dwChordPattern << chRoot;
    for (short index = 0;index < 24;index++)
    {
        DWORD dwScaleBit = dwScalePattern & 1;
        DWORD dwChordBit = dwChordPattern & 1;
        dwScalePattern = dwScalePattern >> 1;
        dwChordPattern = dwChordPattern >> 1;
        if (dwChordBit && !dwScaleBit) nErrors++;
    }
    return(nErrors);
}

static short CompareSPToChord(DMSignPost& rSign,
                                DWORD dwLastScale,
                                DMChordData& rNextChord,
                                char chLastRoot)

{
    BYTE bLastRoot = chLastRoot % 12;
    short nResult = 50;
    if (rNextChord.Equals(rSign.m_ChordData))
    {
        nResult = 0;
    }
    else if (rSign.m_dwChords & DMUS_SIGNPOSTF_1)
    {
        nResult = 25;
    }

    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
    {
        DMChordData& rChord = rSign.m_aCadence[0];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
    {
        DMChordData& rChord = rSign.m_aCadence[1];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else nResult += 30;

    return (nResult);
}

static HRESULT ChordListFromSegment(TList<PlayChord>& ChordList, IDirectMusicSegment* pSeg,
                                 BYTE &bRoot, DWORD &dwScale)
{
    HRESULT             hr          = S_OK;
    IDirectMusicTrack*  pChordTrack = NULL;
    IPersistStream*     pPS         = NULL;
    IStream*            pStream     = NULL;

    // Get the segment's chord track.
    hr = pSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;

    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bRoot, dwScale);

ON_END:
    if (pStream) pStream->Release();
    if (pChordTrack) pChordTrack->Release();
    if (pPS) pPS->Release();
    return hr;
}

static void Clear(TList<PlayChord>& ChordList)
{
    for (TListItem<PlayChord>* pChord = ChordList.GetHead(); pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_pChord->Release();
        delete pChord->GetItemValue().m_pChord;
    }
}

static char TwelveToScale(DWORD dwPattern, char chRoot, char *pchOffset)

{
    char i;
    *pchOffset = 0;
    char chResult = -1;
    while (chRoot < 0) chRoot += 12;
    while (chRoot >= 24) chRoot -= 12;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            chResult++;
            *pchOffset = 0;
        }
        else
        {
            *pchOffset = (char)( *pchOffset + 1 );
        }
        if (i == chRoot)
        {
            return(chResult);
        }
    }
    return(0);
}

static char ScaleToTwelve(DWORD dwPattern, char chRoot, char chOffset)

{
    char i;
    char chResult = 0;
    while (chRoot < 0) chRoot += 7;
    while (chRoot >= 14) chRoot -= 7;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            if (chResult == chRoot) break;
            chResult++;
        }
    }
    i = (char)( i + chOffset );
    while (i >= 24) i -= 12;    // RSW: fix for bug 173304
    return(i);
}

/*HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = S_OK;
    // Get the segment's style track.
    IDirectMusicTrack* pStyleTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicStyleTrack, dwGroupBits, 0, &pStyleTrack);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetTrack(CLSID_DirectMusicPatternTrack, dwGroupBits, 0, &pStyleTrack);
    }
    if (S_OK != hr) return hr;
    // Get the style from the style track
    hr = pStyleTrack->GetParam(GUID_IDirectMusicStyle, mt, NULL, (void*) &rpStyle);
    pStyleTrack->Release();
    return hr;
}*/

HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = pFromSeg->GetParam(GUID_IDirectMusicStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetParam(GUID_IDirectMusicPatternStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    }
    return hr;
}

HRESULT CDMCompos::GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers)
{
    HRESULT hr = S_OK;
    // Get the segment's personality track.
    IDirectMusicTrack* pPersTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBits, 0, &pPersTrack);
    if (S_OK != hr) return hr;
    // Get the personality from the personality track
    hr = pPersTrack->GetParam(GUID_IDirectMusicChordMap, mt, NULL, (void*) &rpPers);
    pPersTrack->Release();
    return hr;
}

HRESULT GetTempo(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, double* pdblTempo)
{
    HRESULT hr = S_OK;
    // Get the segment's tempo track.
    IDirectMusicTrack* pTempoTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
    if (S_OK != hr) return hr;
    // Get the tempo from the tempo track
    DMUS_TEMPO_PARAM Tempo;
    hr = pTempoTrack->GetParam(GUID_TempoParam, mt, NULL, (void*) &Tempo);
    pTempoTrack->Release();
    if (SUCCEEDED(hr))
    {
        *pdblTempo = Tempo.dblTempo;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL,
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track.
The length of the section segment is equal to the length of the template section
passed in.
*/

/*
DX8 changes in track group bits, etc. (activated by dx8 content)
0. The signpost track is used to determine dwCompositionGroupBits.
1. Composed chords are placed in track groups dwCompositionGroupBits.
2. If a style is passed in, all style ref tracks in the composed segment are removed (as before).
   The new style is placed in the track group with the lowest value matching dwCompositionGroupBits.
   If a chord map is passed in, all chord map ref tracks in the composed segment are removed (as
   before).  The new chord map is placed in track groups dwCompositionGroupBits.
3. If the Style is pulled from a StyleRef track, the StyleRef tracks are copied from the template
   segment.  Ditto for chord maps.  The StyleRef track used is the first one that matches
   dwCompositionGroupBits.  Ditto for chord maps.
4. The groove track used is the first one that matches dwCompositionGroupBits.
5. The time signature of the style chosen to compose with is the one used to determine chord
   placement.
6. If there are no tempo tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's tempo is set to play at time 0.
7. If there are no band tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's default band is set to play at physical time -64,
   logical time 0.
8. Loops are handled correctly.
NOTE: Leaving other Composition methods as they are (they put everything in track group 1).  It's
easy enough to change things programmatically, and since these segments are all created from scratch,
they don't rely on existing behavior in segments.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*        pTempSeg, // @parm The template from which to create the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    return ComposeSegmentFromTemplateEx(
                pStyle,
                pTempSeg,
                (DMUS_COMPOSE_TEMPLATEF_ACTIVITY | DMUS_COMPOSE_TEMPLATEF_CLONE),
                wActivity,
                pChordMap,
                ppSectionSeg
        );

}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL,
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track.
The length of the section segment is equal to the length of the template section
passed in.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*    pTempSeg, // @parm The template from which to create the section segment.
                    DWORD                   dwFlags, // @parm Various composition options.
                    DWORD                   dwActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**   ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromTemplateEx)
    V_PTR_WRITE_OPT(pStyle, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pTempSeg, 1);
    V_PTRPTR_WRITE_OPT(ppSectionSeg);
    if ((dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) && !ppSectionSeg)
    {
        Trace(1, "ERROR (ComposeSegmentFromTemplateEx): CLONE flag set but ppSectionSeg is NULL\n");
        return E_POINTER;
    }

    bool fUseActivity = (dwFlags & DMUS_COMPOSE_TEMPLATEF_ACTIVITY) ? true : false;
    bool fCloneSegment = (dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) ? true : false;

    HRESULT hr = S_OK;
    DWORD dwGroupBitsRead = ALL_TRACK_GROUPS; // fallback to dx7 behavior
    DWORD dwGroupBitsWrite = 1; // fallback to dx7 behavior
    IDirectMusicTrack* pSignPostTrack = NULL;
    IDirectMusicTrack* pCommandTrack = NULL;
    IDirectMusicTrack* pChordMapTrack = NULL;

    EnterCriticalSection( &m_CriticalSection );

    // Look for a style and chord map, just to determine DX8 content
    BOOL fStyleFromTrack = FALSE;
    BOOL fPersFromTrack = FALSE;
    if (!pStyle)
    {
        if (FAILED(GetStyle(pTempSeg, 0, ALL_TRACK_GROUPS, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
        else fStyleFromTrack = TRUE;
    }
    if (SUCCEEDED(hr) && !pChordMap)
    {
        if (FAILED(GetPersonality(pTempSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chord map.\n");
            hr = E_INVALIDARG;
        }
        else fPersFromTrack = TRUE;
    }

    // Get track group bits from the signpost track
    if (SUCCEEDED(hr))
    {
        HRESULT hrTemp = pTempSeg->GetTrack(CLSID_DirectMusicSignPostTrack, ALL_TRACK_GROUPS, 0, &pSignPostTrack);
        if (hrTemp == S_OK && UsingDX8(pStyle, pChordMap))
        {
            hrTemp = pTempSeg->GetTrackGroup(pSignPostTrack, &dwGroupBitsWrite);
            if (hrTemp != S_OK) dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
            else dwGroupBitsRead = dwGroupBitsWrite;
        }
        else if (UsingDX8(pStyle, pChordMap)) // no signpost track, DX8 content
        {
            dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
        }
    }

    // Now that we know the group bits, get a style and chord map that match them.
    if (SUCCEEDED(hr) && fStyleFromTrack)
    {
        pStyle->Release();
        pStyle = NULL;
        if (FAILED(GetStyle(pTempSeg, 0, dwGroupBitsRead, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr) && fPersFromTrack)
    {
        pChordMap->Release();
        pChordMap = NULL;
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBitsRead, 0, &pChordMapTrack)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chordmap.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwGroupBitsRead, 0, &pCommandTrack)))
        {
            // If there is no command track, use a NULL command track for ExtractCommandList
            pCommandTrack = NULL;
        }
    }

    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtLength = 0;
        pTempSeg->GetLength(&mtLength);
        TList<PlayChord> PlayList;
        BYTE bRoot = 0;
        DWORD dwScale = 0;
        hr = ComposePlayListFromTemplate(
            pStyle, pChordMap, pChordMapTrack, pSignPostTrack, pCommandTrack, dwGroupBitsRead,
            mtLength, fUseActivity, dwActivity, PlayList, bRoot, dwScale);

        if (SUCCEEDED(hr))
        {
            // Build a section segment from the playlist and command list.
            if (fCloneSegment)
            {
                hr = CopySegment(pTempSeg, ppSectionSeg, PlayList, pStyle, pChordMap, fStyleFromTrack, fPersFromTrack, dwGroupBitsWrite, bRoot, dwScale);
            }
            else
            {
                hr = AddToSegment(pTempSeg, PlayList, pStyle, dwGroupBitsWrite, bRoot, dwScale);
            }
            if (!PlayList.GetHead() && UsingDX8(pStyle, pChordMap))
            {
                hr = S_FALSE;
            }
        }
    }
    CleanUp();
    if (pSignPostTrack) pSignPostTrack->Release();
    if (pCommandTrack) pCommandTrack->Release();
    if (pChordMapTrack) pChordMapTrack->Release();
    if (fStyleFromTrack && pStyle) pStyle->Release();
    if (fPersFromTrack && pChordMap) pChordMap->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMCompos::ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                               IDirectMusicChordMap* pChordMap,
                                               IDirectMusicTrack* pChordMapTrack,
                                               IDirectMusicTrack* pSignPostTrack,
                                               IDirectMusicTrack* pCommandTrack,
                                               DWORD dwGroupBits,
                                               MUSIC_TIME mtLength,
                                               bool fUseActivity,
                                               DWORD dwActivity,
                                               TList<PlayChord>& rPlayList,
                                               BYTE& rbRoot,
                                               DWORD& rdwScale)
{
    HRESULT hr = S_OK;
    // Note: assumes time signature doesn't change.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if (!TimeSig.bBeatsPerMeasure) TimeSig.bBeatsPerMeasure = 4;
    if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    // tics  per bar
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = TimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != TimeSig.bBeatsPerMeasure) nSecondBeat++;
    // Get the command list from the template segment.
    TList<TemplateCommand> CommandList;
    ExtractCommandList(CommandList, pSignPostTrack, pCommandTrack, dwGroupBits);
    // For each chordmap in the chordmap track, compose a playlist from only the commands
    // in the range of the chordmap
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    HRESULT hrChordMap = S_OK;
    IDirectMusicChordMap* pLastChordMap = NULL;
    while (SUCCEEDED(hrChordMap) && SUCCEEDED(hr) && mtNext < mtLength)
    {
        bool fChordMapPassedIn = false;
        if (!pChordMap)
        {
            if (pChordMapTrack)
            {
                hrChordMap = pChordMapTrack->GetParam(GUID_IDirectMusicChordMap, mtNow, &mtNext, (void*) &pChordMap);
                if (!mtNext) mtNext = mtLength;
                else mtNext += mtNow;
            }
            else
            {
                Trace(1, "ERROR: No chord map track to use for chord composition.\n");
                hr = hrChordMap = E_POINTER;
            }
        }
        else // a chordmap got passed in; make sure it's the only one we use
        {
            mtNext = mtLength;
            fChordMapPassedIn = true;
        }
        if (SUCCEEDED(hrChordMap))
        {
            if (!mtNow)
            {
                pChordMap->GetScale(&rdwScale);
                rbRoot = (BYTE) (rdwScale >> 24);
                rdwScale &= 0xffffff;
            }
            // get the commands in the range of this chordmap.
            TList<TemplateCommand> CurrentCommandList;
            TListItem<TemplateCommand>* pScan = CommandList.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                TemplateCommand& rScan = pScan->GetItemValue();
                MUSIC_TIME mtScanBar = rScan.m_nMeasure * mtBar;
                if ( mtScanBar >= mtNow && mtScanBar < mtNext )
                {
                    TListItem<TemplateCommand>* pNew = new  TListItem<TemplateCommand>;
                    if (pNew)
                    {
                        pNew->GetItemValue() = rScan;
                        CurrentCommandList.AddTail(pNew);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                // Compose a playlist for this chordmap.
                TList<PlayChord> CurrentPlayList; // playlist for this chordmap.
                if (fUseActivity)
                {
                    ComposePlayList(CurrentPlayList, pStyle, pChordMap, CurrentCommandList, (WORD)dwActivity);
                }
                else
                {
                    ComposePlayList2(CurrentPlayList, pStyle, pChordMap, CurrentCommandList);
                }
                // if we're past the first bar, compose a cadence to the first chord
                // of the current playlist via a call to ChooseSignPost (using the last
                // chordmap) and add it to the current playlist.
                int nCurrentBar = mtNow / mtBar;
                if (rPlayList.GetHead() && nCurrentBar &&  pLastChordMap)
                {
                    DWORD dwScale = 0;
                    pLastChordMap->GetScale(&dwScale);
                    BYTE bRoot = (BYTE) (dwScale >> 24);
                    dwScale &= 0xffffff;
                    int nBar = nCurrentBar - 1;
                    bool fCadence1 = false;
                    bool fCadence2 = false;
                    TListItem<DMSignPost> *pSignChoice = NULL;
                    if (CurrentPlayList.GetHead())
                    {
                        DMChordData* pFirstChord = CurrentPlayList.GetHead()->GetItemValue().m_pChord;
                        pSignChoice = ChooseSignPost(pChordMap, pFirstChord, false, dwScale, bRoot);
                    }
                    else
                    {
                        pSignChoice = ChooseSignPost(pChordMap, NULL, true, dwScale, bRoot);
                    }
                    if (pSignChoice)
                    {
                        DMSignPost& rSignChoice = pSignChoice->GetItemValue();
                        fCadence1 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                        fCadence2 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
                        if (fCadence1)
                        {
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[0], nBar, 0 );
                        }
                        if (fCadence2)
                        {
                            int nBeat = fCadence1 ? nSecondBeat : 0;
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[1], nBar, nBeat );
                        }
                    }
                }
                // Add the current playlist to the end of the master playlist.
                rPlayList.AddTail(CurrentPlayList.GetHead());
                CurrentPlayList.RemoveAll();
            }
            // clear out the chord map for the next iteration
            if (pLastChordMap) pLastChordMap->Release();
            pLastChordMap = pChordMap;
            if (pLastChordMap) pLastChordMap->AddRef();
            if (!fChordMapPassedIn) pChordMap->Release();
            pChordMap = NULL;
        }
        mtNow = mtNext;
    }
    if (pLastChordMap) pLastChordMap->Release();
    return hr;
}


/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromShape |  Creates
an original section segment from a style and ChordMap based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pStyle>, <p pChordMap>, and <p ppSectionSeg>
is an invalid pointer.

@comm Creates an original section segment from a style and a ChordMap based on a
predefined shape.  Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/

HRESULT CDMCompos::ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to compose the section segment.
                    WORD                        wNumMeasures, // @parm The length, in measures, to compose the section segment.
                    WORD                        wShape, // @parm The shape to compose the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    BOOL                        fComposeIntro, // @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                        fComposeEnding, // @parm TRUE if an ending is to be composed for the section segment.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromShape)
    V_PTR_WRITE(pStyle, 1);
    V_PTR_WRITE(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);

    EnterCriticalSection( &m_CriticalSection );

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;

    // Get the maximum ending length from the style.
    DWORD dwMin, dwMax;
    HRESULT hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
    if (FAILED(hr)) // remain consistent with old behavior and fail.
    {
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    if (hr == S_OK) nEndLength = (int) dwMax;
    if ( UsingDX8(pStyle) )
    {
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0)  wNumMeasures = 1;
    int nNumMeasures = wNumMeasures;
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }

    if (fComposeIntro)
    {
        if (nIntroLength <= 0) nIntroLength = 1;
        if ( nIntroLength >= nNumMeasures )
        {
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
        if ( nEndLength >= nNumMeasures )
        {
            nNumMeasures = nEndLength;
            if (fComposeIntro) nNumMeasures += nIntroLength;
        }
    }

    // Compose playlists for sections of the segment.
    TList<TemplateCommand> CommandList;
    TList<PlayChord> PlayList;
    hr = ComposePlayListFromShape(
        nNumMeasures, wShape, fComposeIntro, fComposeEnding,
        nIntroLength, nFillLength, nBreakLength, nEndLength, pStyle, wActivity,
        pChordMap, CommandList, PlayList);
    if (SUCCEEDED(hr))
    {
        // Build a segment from the resulting command lists and playlists.
        BYTE bRoot = 0;
        DWORD dwScale;
        pChordMap->GetScale(&dwScale);
        bRoot = (BYTE) (dwScale >> 24);
        dwScale &= 0xffffff;
        hr = BuildSegment(CommandList, PlayList, pStyle, pChordMap, nNumMeasures, ppSectionSeg, bRoot, dwScale);
        CleanUp();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT GetCommandList(IDirectMusicSegment* pFromSeg, TList<TemplateCommand>& CommandList)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack* pCommandTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicCommandTrack, ALL_TRACK_GROUPS, 0, &pCommandTrack);
    if (S_OK != hr) return hr;
    // Write the track to a stream, and read from the stream into a command list.
    IPersistStream* pPS;
    IStream *pStream;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK == hr)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
        if (S_OK == hr)
        {
            hr = pPS->Save(pStream, FALSE);
            if (S_OK == hr)
            {
                StreamSeek(pStream, 0, STREAM_SEEK_SET);
                LoadCommandList(CommandList, pStream);
            }
            pPS->Release();
        }
        pStream->Release();
    }
    pCommandTrack->Release();
    return hr;
}

// New flags:
// DMUS_COMPOSEF_ENTIRE_TRANSITION: play the transition pattern in its entirety.
// DMUS_COMPOSEF_1BAR_TRANSITION: play one bar of the the transition pattern.
// the following two are ignored unless DMUS_COMPOSEF_LONG is set:
// DMUS_COMPOSEF_ENTIRE_ADDITION: play the additional pattern in its entirety.
// DMUS_COMPOSEF_1BAR_ADDITION: play one bar of the additional pattern.
// Default behavior will be the same as dx7:
// DMUS_COMPOSEF_1BAR_TRANSITION unless pattern is an ending
// DMUS_COMPOSEF_1BAR_ADDITION always

// Used by both ComposeTransition and AutoTransition
HRESULT CDMCompos::TransitionCommon(
    IDirectMusicStyle*      pFromStyle,
    IDirectMusicBand*       pCurrentBand,
    double*                 pdblFromTempo,
    DMUS_COMMAND_PARAM_2&   rFromCommand,
    DMUS_CHORD_PARAM&       rLastChord,
    DMUS_CHORD_PARAM&       rNextChord,

    IDirectMusicSegment*    pToSeg,
    WORD                    wCommand,
    DWORD                   dwFlags,
    IDirectMusicChordMap*   pChordMap,
    IDirectMusicGraph*      pFromGraph,
    IDirectMusicGraph*      pToGraph,
    IUnknown*               pFromPath,
    IUnknown*               pToPath,
    IDirectMusicSegment**   ppSectionSeg
            )
{
    IDirectMusicGraph* pGraph = NULL;
    IUnknown* pPath = NULL;
    BYTE bRoot = rLastChord.bKey;
    DWORD dwScale = rLastChord.dwScale;
    DMChordData LastChord = rLastChord;
    DMChordData NextChord = rNextChord;
    HRESULT hr = S_OK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fEntireTransition = false;
    if ((dwFlags & DMUS_COMPOSEF_ENTIRE_TRANSITION) ||
        (fEnding && !(dwFlags & DMUS_COMPOSEF_1BAR_TRANSITION)))
    {
        fEntireTransition = true;
    }
    bool fEntireAddition = (dwFlags & DMUS_COMPOSEF_ENTIRE_ADDITION) ? true : false;
    bool fAlign = (dwFlags & DMUS_COMPOSEF_ALIGN) ? true : false;

    // Get the ending segment's style
    IDirectMusicStyle* pToStyle = NULL;
    if (pToSeg)
    {
        hr = GetStyle(pToSeg, 0, ALL_TRACK_GROUPS, pToStyle, false);
        if (FAILED(hr)) pToStyle = NULL;
    }
    if (!pToStyle && !pFromStyle) // Not much to do...
    {
        *ppSectionSeg = NULL;
        return S_OK;
    }

    // Get tempo from the end segment.  This will be passed into BuildSegment.
    double dblFromTempo = 120.0;
    double dblToTempo = 120.0;
    double* pdblToTempo = &dblToTempo;
    if (pdblFromTempo)
    {
        dblFromTempo = *pdblFromTempo;
    }
    // If there is no To tempo, set it to the From tempo (or keep it at the fallback).
    if (!pToSeg || FAILED(GetTempo(pToSeg, 0, &dblToTempo)))
    {
        if (pdblFromTempo) dblToTempo = dblFromTempo; // otherwise use fallback of 120
    }
    // If there is no From tempo, set it to the To tempo.
    if (!pdblFromTempo)
    {
        dblFromTempo = dblToTempo;
        pdblFromTempo = &dblFromTempo;
    }

    EnterCriticalSection( &m_CriticalSection );

    // Extract the starting style's time signature.
    DMUS_TIMESIGNATURE FromTimeSig;
    if (pFromStyle)
    {
        pFromStyle->GetTimeSignature(&FromTimeSig);
    }
    else
    {
        FromTimeSig.bBeat = 4;
        FromTimeSig.bBeatsPerMeasure = 4;
        FromTimeSig.wGridsPerBeat = 4;
        FromTimeSig.mtTime = 0;
    }
    // Extract the ending style's time signature.
    DMUS_TIMESIGNATURE ToTimeSig;
    if (pToStyle)
    {
        pToStyle->GetTimeSignature(&ToTimeSig);
    }
    else
    {
        ToTimeSig.bBeat = 4;
        ToTimeSig.bBeatsPerMeasure = 4;
        ToTimeSig.wGridsPerBeat = 4;
        ToTimeSig.mtTime = 0;
    }
    if (!ToTimeSig.bBeatsPerMeasure) ToTimeSig.bBeatsPerMeasure = 4;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = ToTimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != ToTimeSig.bBeatsPerMeasure) nSecondBeat++;
    MUSIC_TIME mtIntro = 0;
    TList<PlayChord> PlayList;
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (!pCommand)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    TListItem<TemplateCommand> *pLast = pCommand;
    // Intros get their chords when adding commands
    if (wCommand != DMUS_COMMANDT_INTRO)
    {
        if ( fModulate )
        {
            bool fCadence1 = false;
            bool fCadence2 = false;
            TListItem<DMSignPost> *pSignChoice = ChooseSignPost(pChordMap, &NextChord, fEnding, dwScale, bRoot);
            if (pSignChoice)
            {
                fCadence1 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                fCadence2 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
            }
            if (fCadence1 || fCadence2)
            {
                if ( fCadence1 && (fLong || !fEnding || !fCadence2) )
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[0], 0, 0 );
                }
                else
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, 0 );
                }
                if (fCadence1 && fCadence2)
                {
                    if (fLong == fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, nSecondBeat );
                    }
                    if (fLong && !fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 1, 0 );
                    }
                }
                if ( fEnding )
                {
                    if (fLong)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 1, 0 );
                    }
                    else
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 0, nSecondBeat );
                    }
                }
            }
            else
            {
                AddChord( PlayList, &LastChord, 0 , 0 );
            }
        }
        else
        {
            AddChord( PlayList, &LastChord, 0 , 0 );
        }
    }
    int nLength = 0;
    int nPreIntro = 0;
    if (pCommand)
    {
        DWORD dwMax = 1;
        DWORD dwMin;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_Command.bCommand = rFromCommand.bCommand;
        rCommand.m_Command.bGrooveLevel = rFromCommand.bGrooveLevel;
        rCommand.m_Command.bGrooveRange = rFromCommand.bGrooveRange;
        rCommand.m_Command.bRepeatMode = rFromCommand.bRepeatMode;
        rCommand.m_nMeasure = 0;
        if (pFromStyle)
        {
            if (wCommand != DMUS_COMMANDT_INTRO)
            {
                WORD wTempCommand = wCommand;
                if ( wCommand == DMUS_COMMANDT_END || wCommand == DMUS_COMMANDT_ENDANDINTRO )
                {
                    wTempCommand = DMUS_COMMANDT_END;
                }
                if (fEntireTransition)
                {
                    HRESULT hrTemp = pFromStyle->GetEmbellishmentLength(wTempCommand, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hrTemp != S_OK) dwMax = 1;
                    nLength = dwMax;
                }
                else
                {
                    nLength = 1;
                }
            }
            if ( fLong )
            {
                if (fEntireAddition)
                {
                    HRESULT hrTemp = pFromStyle->GetEmbellishmentLength(DMUS_COMMANDT_GROOVE, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hrTemp != S_OK) dwMax = 1;
                }
                else
                {
                    dwMax = 1;
                }
                nLength += dwMax;
                if (wCommand == DMUS_COMMANDT_GROOVE && UsingDX8(pFromStyle)) // Just have one long groove.
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                }
                else if (wCommand != DMUS_COMMANDT_INTRO)
                {
                    TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                    if (pSecond)
                    {
                        TemplateCommand& rSecond = pSecond->GetItemValue();
                        rSecond.m_nMeasure = (short) dwMax;
                        if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                        {
                            rSecond.m_Command.bCommand = DMUS_COMMANDT_END;
                        }
                        else
                        {
                            rSecond.m_Command.bCommand = (BYTE)wCommand;
                        }
                        rSecond.m_Command.bGrooveLevel = 0;
                        rSecond.m_Command.bGrooveRange = 0;
                        rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                        pLast->SetNext(pSecond);
                        pLast = pSecond;
                    }
                }
            }
            else if (wCommand != DMUS_COMMANDT_INTRO)
            {
                if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
                }
                else
                {
                    rCommand.m_Command.bCommand = (BYTE)wCommand;
                }
            }
        }
        if ( pToStyle && fHasIntro)
        {
            nPreIntro = nLength;
            if (fEntireTransition)
            {
                // Check that this is the correct thing to do if pFromStyle is NULL.
                HRESULT hrTemp = pToStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                if (hrTemp != S_OK) dwMax = 1;
                nLength += dwMax;
            }
            else
            {
                nLength++;
            }
            AddChord( PlayList, &NextChord, nPreIntro , 0 );
            if ( nPreIntro > 0 )
            {
                if (wCommand == DMUS_COMMANDT_INTRO) AddChord( PlayList, &LastChord, 0 , 0 );
                TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                if (pSecond)
                {
                    TemplateCommand& rSecond = pSecond->GetItemValue();
                    rSecond.m_nMeasure = (short)nPreIntro;
                    rSecond.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                    rSecond.m_Command.bGrooveLevel = 0;
                    rSecond.m_Command.bGrooveRange = 0;
                    rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                    pLast->SetNext(pSecond);
                }
            }
            else
            {
                rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            }
        }
    }
    TList<TemplateCommand> CommandList2;
    CommandList2.Cat(pCommand);
    *ppSectionSeg = NULL;
    if (fHasIntro && !fEnding && UsingDX8(pToStyle))
    {
        pGraph = pToGraph;
        pPath = pToPath;
    }
    else if (UsingDX8(pFromStyle))
    {
        pGraph = pFromGraph;
        pPath = pFromPath;
    }
    if (fHasIntro)
    {
        if (pFromStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
            if (SUCCEEDED(hr) && pToStyle)
            {
                mtIntro = ClocksPerMeasure(FromTimeSig) * nPreIntro;
                IDirectMusicTrack* pStyleTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pStyleTrack);
                if (SUCCEEDED(hr))
                {
                    pStyleTrack->SetParam(GUID_IDirectMusicStyle, mtIntro, (void*) pToStyle);
                    pStyleTrack->Release();
                }
                IDirectMusicTrack* pTempoTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
                if (SUCCEEDED(hr))
                {
                    DMUS_TEMPO_PARAM tempo;
                    tempo.mtTime = mtIntro;
                    tempo.dblTempo = dblToTempo;
                    pTempoTrack->SetParam(GUID_TempoParam, mtIntro, (void*) &tempo);
                    pTempoTrack->Release();
                }
                // I also need to add a band (from the To segment) to the band track at the appropriate time...
                if ( UsingDX8(pToStyle) )
                {
                    if (mtIntro == 0) // Intro is the first thing to play; don't need any other bands
                    {
                        (*ppSectionSeg)->SetParam(GUID_Clear_All_Bands, ALL_TRACK_GROUPS, 0, 0, NULL);
                    }
                    DMUS_BAND_PARAM DMBand;
                    if (pToSeg && SUCCEEDED(pToSeg->GetParam(GUID_BandParam, ALL_TRACK_GROUPS, DMUS_SEG_ANYTRACK, 0, NULL, (void*)&DMBand)))
                    {
                        DMBand.mtTimePhysical = mtIntro;
                        (*ppSectionSeg)->SetParam(GUID_BandParam, ALL_TRACK_GROUPS, 0, mtIntro, (void*)&DMBand);
                        DMBand.pBand->Release();
                    }
                }
                // readjust the length to account for differences in the two styles's time signatures
                if ( nLength > nPreIntro && (UsingDX8(pFromStyle) || UsingDX8(pToStyle)) )
                {
                    MUSIC_TIME mtNewLength = mtIntro + ((nLength - nPreIntro) * ClocksPerMeasure(ToTimeSig));
                    (*ppSectionSeg)->SetLength(mtNewLength);
                }
            }
        }
        else if (pToStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pToStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblToTempo, pCurrentBand, fAlign, pGraph, pPath);
        }
    }
    else if (pFromStyle)
    {
        hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
    }
    else
    {
        hr = S_OK; // don't build anything, but return OK
    }
    CommandList2.RemoveAll();
    TListItem<TemplateCommand>::Delete(pCommand);
    if (pToStyle) pToStyle->Release();
    CleanUp();
    NextChord.Release();
    LastChord.Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

TListItem<DMSignPost>* CDMCompos::ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot)
{
    if (!fEnding && !pNextChord) return NULL;
    DMPersonalityStruct* pPers = NULL;
    if (pChordMap)
    {
        IDMPers* pDMP;
        if (FAILED(pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP))) return NULL;
        pDMP->GetPersonalityStruct((void**)&pPers);
        pDMP->Release();
    }
    if (!pPers) return NULL;

    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    TListItem<DMSignPost> *pSignChoice = pSign;
    int nMin = 100;
    int nHit = 100;
    int nMatches = 0;
    if (fEnding)
    {
        for (;pSign; pSign = pSign->GetNext())
        {
            if ( (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) )
            {
                pSignChoice = pSign;
                nMatches = 0;
                for (; pSign; pSign = pSign->GetNext())
                {
                    if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) nMatches++;
                }
                break;
            }
        }
    }
    else
    {
        DMChordData& rNextChord = *pNextChord;
        for (;pSign; pSign = pSign->GetNext())
        {
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin) nMatches++;
            else if (nHit < nMin)
            {
                nMin = nHit;
                pSignChoice = pSign;
                nMatches = 1;
            }
        }
    }
    // Pick a winning signpost at random
    pSign = pSignChoice;
    if (nMatches) nMatches = rand() % nMatches;
    for (int i = 0; i <= nMatches && pSign; pSign = pSign->GetNext())
    {
        if (fEnding)
        {
            if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1)
            {
                i++;
                pSignChoice = pSign;
            }
        }
        else
        {
            DMChordData& rNextChord = *pNextChord;
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin)
            {
                i++;
                pSignChoice = pSign;
            }
        }
    }
    // If the signpost that was found doesn't match the chord we're going to, discard it
    if (!fEnding &&
        pSignChoice &&
        (!(*pNextChord).Equals(pSignChoice->GetItemValue().m_ChordData)))
    {
        pSignChoice = NULL;
    }
    return pSignChoice;
}

IDirectMusicGraph* CDMCompos::CloneSegmentGraph(IDirectMusicSegment* pSegment)
{
    if (!pSegment)
    {
        return NULL;
    }
    IDirectMusicGraph* pGraph = NULL;
    HRESULT hr = pSegment->GetGraph(&pGraph);
    if (FAILED(hr) || !pGraph)
    {
        return NULL;
    }
    IGraphClone *pGraph8 = NULL;
    hr = pGraph->QueryInterface(IID_IGraphClone, (void**)&pGraph8);
    pGraph->Release();
    if (FAILED(hr) || !pGraph8)
    {
        return NULL;
    }
    hr = pGraph8->Clone(&pGraph);
    pGraph8->Release();
    if (SUCCEEDED(hr))
    {
        return pGraph;
    }
    else
    {
        return NULL;
    }
}

IUnknown* CDMCompos::GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath)
{
    if (!pSegment)
    {
        return NULL;
    }
    if (!(dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH))
    {
        DWORD dwDefault = 0;
        pSegment->GetDefaultResolution(&dwDefault);
        if ( pdwAudioPath && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
        {
            *pdwAudioPath = DMUS_SEGF_USE_AUDIOPATH;
        }
        return NULL;
    }
    IUnknown* pPath = NULL;
    IDirectMusicSegment8* pSeg8 = NULL;
    HRESULT hr = pSegment->QueryInterface(IID_IDirectMusicSegment8, (void**)&pSeg8);
    if (FAILED(hr)) return NULL;
    hr = pSeg8->GetAudioPathConfig(&pPath);
    pSeg8->Release();
    if (FAILED(hr) || !pPath)
    {
        return NULL;
    }
    else
    {
        return pPath;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeTransition |  Composes a
transition from inside one section segment to another segment.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pFromSeg>, <p pToSeg> and <p ppSectionSeg>
is not a valid pointer.
@flag E_INVALIDARG | <p pToSeg> is NULL and
  DMUS_COMPOSEF_MODULATE is set in <p dwFlags>.
@flag E_OUTOFMEMORY | An attempt to allocate memory failed.

@comm Allowable values for <p dwFlags> are:

  @flag DMUS_COMPOSEF_LONG | Composes a long transition.  If the flag is not included, the length
  of the transition is the combined lengths of valid embellishments specified by <p wCommand>.
  If the flag is included and <p pFromSeg> is non-null, the length of the transition
  increases by 1.
  @flag DMUS_COMPOSEF_MODULATE | Composes a transition that modulates smoothly from
  <p pFromSeg> to <p pToSeg>.
  @flag DMUS_COMPOSEF_ALIGN | Align transition to the time signature of the currently playing
    segment.
  @flag DMUS_COMPOSEF_OVERLAP | Overlap the transition into <p pToSeg>.


  <p pToSeg> may be NULL, as long as
  <p dwFlags> does not include DMUS_COMPOSEF_MODULATE.
  If <p pToSeg> is NULL or doesn't contain a style track, intro embellishments are not valid.
  If <p pFromSeg> is NULL or doesn't contain a style track,
  fill, break, end, and groove embellishments are not valid.
  Note that the above implies that it is possible for both <p pFromSeg> and <p pToSeg> to be
  NULL or to be
  segments that don't contain style tracks.  If so, all embellishments are invalid.  When all
  embellishments are invalid, a NULL transition segment is returned.

  <p pChordMap> may be NULL.  If so, an attempt is made to obtain a ChordMap from a
  ChordMap track, first from <p pToSeg>, and then from <p pFromSeg>.  If neither of these
  segments contains a ChordMap track, the chord occuring at <p mtTime> in <p pFromSeg> is
  used as the chord in the transition.
*/

HRESULT CDMCompos::ComposeTransition(
    IDirectMusicSegment*    pFromSeg, // @parm
                            // The section from which to compose the transition.
    IDirectMusicSegment*    pToSeg,  // @parm
                            // The section to which the transition should smoothly flow.
    MUSIC_TIME              mtTime, // @parm
                            // The time in <p pFromSeg> from which to compose the transition.
    WORD                    wCommand, // @parm
                            // The embellishment to use when composing the transition.
                            // DMUS_COMMANDT_ENDANDINTRO means compose a segment containing
                            // an end to <p pFromSeg> and an intro to <p pToSeg>.
    DWORD                   dwFlags, // @parm
                            // Various composition options.
    IDirectMusicChordMap* pChordMap, // @parm
                             // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**   ppSectionSeg // @parm
                            // Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pFromSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);
    HRESULT hr = S_OK;
    bool fHaveChordMap = pChordMap ? true : false;

    DWORD dwGroupBits = ALL_TRACK_GROUPS;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (ComposeTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }

    // Get Tool graphs from the To and From segments
    IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSeg);
    IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

    // Get Audiopaths from the To and From segments
    IUnknown* pFromPath = GetSegmentAudioPath(pFromSeg, dwFlags);
    IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags);

    // Get the starting segment's style
    IDirectMusicStyle* pFromStyle = NULL;
    if (pFromSeg)
    {
        hr = GetStyle(pFromSeg, mtTime, ALL_TRACK_GROUPS, pFromStyle, false);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one from the segments (first the
    // TO segment, then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            if (!pFromSeg || FAILED(GetPersonality(pFromSeg, mtTime, ALL_TRACK_GROUPS, pChordMap)))
                pChordMap = NULL;
        }
    }

    // Get a tempo from the From segment.
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    if (pFromSeg && SUCCEEDED(GetTempo(pFromSeg, mtTime, &dblFromTempo)))
    {
        pdblFromTempo = &dblFromTempo;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else if (pFromSeg)
    {
        hr = pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        hr = E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        NextChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }

    hr = TransitionCommon(pFromStyle, NULL, pdblFromTempo, Command, LastChord, NextChord,
                pToSeg, wCommand, dwFlags, pChordMap, pFromGraph, pToGraph, pFromPath, pToPath, ppSectionSeg);

    if (pFromStyle) pFromStyle->Release();
    if (!fHaveChordMap && pChordMap) pChordMap->Release();
    if (pFromGraph) pFromGraph->Release();
    if (pToGraph) pToGraph->Release();
    if (pFromPath) pFromPath->Release();
    if (pToPath) pToPath->Release();

    return hr;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | AutoTransition |  Composes a
transition from inside a performance's primary segment to another segment, and then
queues the transition and the second segment to play.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pPerformance>, <p pToSeg>, <p pChordMap>,
<p ppTransSeg>, <p ppToSegState>, and <p ppTransSegState> is not a valid pointer.

@comm Allowable values for <p dwFlags> include all values allowed for
<om IDirectMusicComposer::ComposeTransition>.  Additionally, the following values are
allowed:

  @flag DMUS_COMPOSEF_IMMEDIATE | Start transition on music or reference time boundary.
  @flag DMUS_COMPOSEF_GRID | Start transition on grid boundary.
  @flag DMUS_COMPOSEF_BEAT | Start transition on beat boundary.
  @flag DMUS_COMPOSEF_MEASURE | Start transition on measure boundary.
  @flag DMUS_COMPOSEF_AFTERPREPARETIME | Use the DMUS_SEGF_AFTERPREPARETIME flag when
     queueing the transition.


  <p ppTransSeg may be NULL.  In this case, the transition segment is not returned.
  <p pToSeg> may be NULL as long as <p dwFlags> does not include DMUS_COMPOSEF_MODULATE.
  If <p pToSeg> is NULL or doesn't contain a style track, intro embellishments are not valid.
  If the currently playing segment is NULL or doesn't contain a style track,
  fill, break, end, and groove embellishments are not valid.
  Note that the above implies that it is possible for both the currently playing segment and
  <p pToSeg> to be NULL or to be
  segments that don't contain style tracks.  If so, all embellishments are invalid.  When all
  embellishments are invalid, no transition occurs between the currently playing segment
  and <p pToSeg>.
  <p pChordMap> may be NULL.  If so, an attempt is made to obtain a ChordMap from a
  ChordMap track, first from <p pToSeg>, and then from the performance's primary segment.
  If neither of these
  segments contains a ChordMap track, the chord occuring at <p mtTime> in the primary
  segment is
  used as the chord in the transition.
*/

HRESULT CDMCompos::AutoTransition(
    IDirectMusicPerformance*    pPerformance,   // @parm
                                // The performance in which to do the transition.
    IDirectMusicSegment*        pToSeg,         // @parm
                                // The section to which the transition should smoothly flow.
    WORD                        wCommand,       // @parm
                                // The embellishment to use when composing the transition.
    DWORD                       dwFlags,        // @parm
                                // Various composition options.
    IDirectMusicChordMap*       pChordMap,  // @parm
                                // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**       ppTransSeg,     // @parm
                                // Returns the created section segment.
    IDirectMusicSegmentState**  ppToSegState,   // @parm
                                // Returns the segment state for the transition segment.
    IDirectMusicSegmentState**  ppTransSegState // @parm
                                // Returns the segment state for the segment following the transition.
            )
{
    // ppToSegState and ppTransSegState are checked in Performance::PlaySegment,
    // BUT I need to check them here as well.
    V_INAME(IDirectMusicComposer::AutoTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pPerformance, 1);
    V_PTR_WRITE_OPT(ppTransSeg, 1);
    V_PTR_WRITE_OPT(ppToSegState, 1);
    V_PTR_WRITE_OPT(ppTransSegState, 1);

    DWORD dwGroupBits = 0xffffffff;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    DWORD dwResolution;
    if (dwFlags & DMUS_COMPOSEF_MEASURE) dwResolution = DMUS_SEGF_MEASURE;
    else if (dwFlags & DMUS_COMPOSEF_BEAT) dwResolution = DMUS_SEGF_BEAT;
    else if (dwFlags & DMUS_COMPOSEF_GRID) dwResolution = DMUS_SEGF_GRID;
    else if (dwFlags & DMUS_COMPOSEF_DEFAULT) dwResolution = DMUS_SEGF_DEFAULT;
    else if (dwFlags & DMUS_COMPOSEF_IMMEDIATE) dwResolution = 0;
    else dwResolution = DMUS_SEGF_MEASURE;

    if (dwFlags & DMUS_COMPOSEF_ALIGN) dwResolution |= DMUS_SEGF_ALIGN;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_MEASURE) dwResolution |= DMUS_SEGF_VALID_START_MEASURE;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_BEAT) dwResolution |= DMUS_SEGF_VALID_START_BEAT;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_GRID) dwResolution |= DMUS_SEGF_VALID_START_GRID;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_TICK) dwResolution |= DMUS_SEGF_VALID_START_TICK;

    if (dwFlags & DMUS_COMPOSEF_AFTERPREPARETIME) dwResolution |= DMUS_SEGF_AFTERPREPARETIME;
    if (dwFlags & DMUS_COMPOSEF_NOINVALIDATE) dwResolution |= DMUS_SEGF_NOINVALIDATE;
    if (dwFlags & DMUS_COMPOSEF_INVALIDATE_PRI) dwResolution |= DMUS_SEGF_INVALIDATE_PRI;
    if (dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH) dwResolution |= DMUS_SEGF_USE_AUDIOPATH;

    DWORD dwUseAudioPath = dwResolution & DMUS_SEGF_USE_AUDIOPATH;

    IDirectMusicSegment* pTransSeg = NULL;
    if (!ppTransSeg)
    {
        ppTransSeg = &pTransSeg;
    }

    IDirectMusicChordMap* pFromChordMap = NULL;
    bool bReleaseFromChordMap = false;
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    IDirectMusicStyle* pFromStyle = NULL;
    IDirectMusicBand* pBand = NULL;
    IDirectMusicSegmentState* pSegState = NULL;
    IDirectMusicSegment* pFromSegment = NULL;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (AutoTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }
    MUSIC_TIME mtTime, mt;
    MUSIC_TIME mtStart;
    REFERENCE_TIME rt, rtResolved;
    HRESULT hr = pPerformance->GetQueueTime(&rt);
    if (SUCCEEDED(hr)) hr = pPerformance->GetResolvedTime(rt, &rtResolved, dwResolution);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rtResolved, &mtTime);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rt, &mt);

    if (!SUCCEEDED(hr)) return hr;
    if (rtResolved > rt) mtTime--;
    hr = pPerformance->GetSegmentState(&pSegState, mtTime);
    if (SUCCEEDED(hr))
    {
        hr = pSegState->GetStartTime(&mtStart);
        TraceI(3, "Time: %d Resolved Time: %d\n", mt - mtStart, mtTime - mtStart);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        hr = pSegState->GetSegment(&pFromSegment);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND)
        {
            MUSIC_TIME mtLength;
            if( SUCCEEDED( pFromSegment->GetLength( &mtLength ) ) )
            {
                mtTime = mtLength - 1;
                mtStart = 0;
            }
        }
    }
    else pSegState = NULL;

    // Get the starting segment's style
    if (pPerformance)
    {
        hr = pPerformance->GetParam(GUID_IDirectMusicStyle, dwGroupBits, dwIndex, mtTime, NULL, (void*)&pFromStyle);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one (first from the TO segment,
    // then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, dwGroupBits, pFromChordMap)))
        {
            if (!pFromSegment || FAILED(GetPersonality(pFromSegment, 0, dwGroupBits, pFromChordMap)))
            {
                pFromChordMap = NULL;
            }
        }

        if(pFromChordMap)
        {
            bReleaseFromChordMap = true;
        }
    }
    else
    {
        pFromChordMap = pChordMap;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (FAILED(pPerformance->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (FAILED(pPerformance->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        // Check that this is the correct thing to do if pFromSegment is NULL.
        hr = pFromSegment ? pFromSegment->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord) : E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        NextChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }
    // If < DX8 content for From segment (or playing transition from segment end),
    // call ComposeTransition; otherwise, call TransitionCommon
    if (!UsingDX8(pFromStyle, pFromChordMap, pFromSegment, &Command, &LastChord) ||
        (dwFlags & DMUS_COMPOSEF_SEGMENTEND) )
    {
        if (pSegState)
        {
            hr = ComposeTransition(pFromSegment, pToSeg, mtTime - mtStart, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
        else
        {
            hr = ComposeTransition(NULL, pToSeg, 0, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
    }
    else
    {
        // Get Tool graphs from the To and From segments
        IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSegment);
        IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

        // Get Audiopaths from the To and From segments
        IUnknown* pFromPath = GetSegmentAudioPath(pFromSegment, dwFlags);
        IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags, &dwUseAudioPath);

        // Get a tempo from the performance.
        DMUS_TEMPO_PARAM Tempo;
        if (SUCCEEDED(pPerformance->GetParam(GUID_TempoParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&Tempo)))
        {
            dblFromTempo = Tempo.dblTempo;
            pdblFromTempo = &dblFromTempo;
        }

        // Get the currently playing band
        DMUS_BAND_PARAM DMBand;
        if (SUCCEEDED(pPerformance->GetParam(GUID_BandParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&DMBand)))
        {
            pBand = DMBand.pBand;
        }

        hr = TransitionCommon(pFromStyle, pBand, pdblFromTempo, Command, LastChord, NextChord,
                    pToSeg, wCommand, dwFlags, pFromChordMap, pFromGraph, pToGraph,  pFromPath, pToPath, ppTransSeg);
        if (pFromGraph) pFromGraph->Release();
        if (pToGraph) pToGraph->Release();
        if (pFromPath) pFromPath->Release();
        if (pToPath) pToPath->Release();
    }

    if (SUCCEEDED(hr))
    {
        if (*ppTransSeg && pToSeg)
        {
            DMUS_COMMAND_PARAM_2 CommandParam;
            if (SUCCEEDED(pToSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, 0, NULL, (void*) &CommandParam)))
            {
                (*ppTransSeg)->SetParam(GUID_CommandParamNext, dwGroupBits, 0, 0, (void*) &CommandParam);
            }
        }

        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND) dwResolution |= DMUS_SEGF_SEGMENTEND;
        if (dwFlags & DMUS_COMPOSEF_MARKER) dwResolution |= DMUS_SEGF_MARKER;
        DWORD dwQueueResolution = DMUS_SEGF_QUEUE | dwUseAudioPath;

        hr = S_OK;
        if (*ppTransSeg)
        {
            hr = pPerformance->PlaySegment(*ppTransSeg, dwResolution, 0, ppTransSegState);
            if (SUCCEEDED(hr) && pToSeg)
            {
                hr = pPerformance->PlaySegment(pToSeg, dwQueueResolution, 0, ppToSegState);
            }
        }
        else
        {
            if (!pToSeg)
            {
                if (!(dwFlags & DMUS_COMPOSEF_SEGMENTEND))
                {
                    hr = pPerformance->Stop(pFromSegment, NULL, 0, dwResolution);
                }
            }
            else
            {
                hr = pPerformance->PlaySegment(pToSeg, dwResolution, 0, ppToSegState);
            }
        }
    }

ON_END:
    if (pFromStyle) pFromStyle->Release();
    if (pBand) pBand->Release();
    if (pTransSeg) pTransSeg->Release();
    if (pSegState) pSegState->Release();
    if (pFromSegment) pFromSegment->Release();
    if (bReleaseFromChordMap) pFromChordMap->Release();
    return hr;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeTemplateFromShape |  Creates
a new template segment based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | <p ppTempSeg> is not a valid pointer.
@flag E_OUTOFMEMORY | An attempt to allocate memory failed.
@flag E_INVALIDARG | <p wNumMeasures> is 0, or <p fComposeEnding> is TRUE and either
  <p wEndLength> is 0 or <p wEndLength> is greater than the number of non-intro measures.

@comm Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/
HRESULT CDMCompos::ComposeTemplateFromShape(
                    WORD                    wNumMeasures, // @parm The length, in measures, to compose the section segment
                    WORD                    wShape,// @parm The shape to compose the section segment.
                    BOOL                    fComposeIntro,// @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                    fComposeEnding,// @parm TRUE if an ending is to be composed for the section segment.
                    WORD                    wEndLength, // @parm Length in measures of the ending, if one is to be composed.
                    IDirectMusicSegment**   ppTempSeg   // @parm Returns the created template segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShape)
    V_PTRPTR_WRITE(ppTempSeg);
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fComposeIntro, fComposeEnding,
        1, 1, 1, (int)wEndLength, ppTempSeg);
}

HRESULT CDMCompos::ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShapeEx)
    V_PTRPTR_WRITE(ppTemplate);
    V_PTR_WRITE_OPT(pStyle, 1);
    HRESULT hr = S_OK;

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;
    if (pStyle)
    {
        DWORD dwMin, dwMax;

        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
        if (hr == S_OK) nEndLength = (int) dwMax;
    }
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fIntro, fEnd,
        nIntroLength, nFillLength, nBreakLength, nEndLength, ppTemplate);
}

HRESULT CDMCompos::ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            )
{
    HRESULT hr;
    if ( !wNumMeasures ||
         (fComposeEnding && !nEndLength) ||
         (fComposeIntro && !nIntroLength) ||
         (fComposeEnding && fComposeIntro && (nEndLength + nIntroLength) > wNumMeasures) ||
         (fComposeEnding && (nEndLength > wNumMeasures)) ||
         (fComposeIntro && (nIntroLength > wNumMeasures)) )
    {
        Trace(1, "ERROR (ComposeTemplateFromShape): Invalid template length.\n");
        return E_INVALIDARG;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0) wNumMeasures = 1;
    int nNumMeasures = (int)wNumMeasures;
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
    }
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }


    int nOriginalMeasures = 0;
    bool f1Bar = false;
    if (fComposeIntro)
    {
        nNumMeasures -= nIntroLength;
        if (nNumMeasures < nIntroLength)
        {
            f1Bar = true;
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = nNumMeasures;
        nNumMeasures -= (nLength - 1);
        if (nNumMeasures < 1)
        {
            nNumMeasures = 1;
        }
    }
    TemplateStruct* pTemplate = new TemplateStruct;
    if (!pTemplate) return E_OUTOFMEMORY;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (nNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) nNumMeasures++;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        pTemplate->CreateSignPosts();
        pTemplate->CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            nNumMeasures--;
            pTemplate->m_nMeasures = (short)nNumMeasures;
        }
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        int anLengths[8];
        int anGrooveLevel[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) nNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[rand() % 10];

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
        }
        anGrooveLevel[0] = 0;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < nNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((nNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = nNumMeasures - nMeasure;
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                anGrooveLevel[0] = 0;
                if (rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            pTemplate->IncorporateTemplate((short)nMeasure, apTempl[nChoice], (short)nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (rand() % 3)
                {
                    if (rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((nNumMeasures - nMeasure) > nShortestLength)
            {
                while ((nNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        pTemplate->m_CommandList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (nNumMeasures != nOriginalMeasures)
        {
            pTemplate->m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        pTemplate->AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        pTemplate->AddIntro(f1Bar, nIntroLength);
    }
    // build the template segment...
    IDMTempl* pITemplate;
    hr = S_OK;
    hr = CoCreateInstance(
        CLSID_DMTempl,
        NULL,
        CLSCTX_INPROC,
        IID_IDMTempl,
        (void**)&pITemplate);
    if (SUCCEEDED(hr))
    {
        pITemplate->Init(pTemplate);
        hr = CoCreateInstance(
            CLSID_DirectMusicSegment,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicSegment,
            (void**)ppTempSeg);
        if (SUCCEEDED(hr))
        {
            pITemplate->CreateSegment(*ppTempSeg);
        }
        pITemplate->Release();
    }
ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}

inline char ShiftRoot(DWORD dwScale, BYTE bRoot)
{
    switch (dwScale & 0xfff)
    {
    case 0x56b: bRoot += 1; break;  // C#
    case 0xad6: bRoot += 2; break;  // D
    case 0x5ad: bRoot += 3; break;  // D#

    case 0xb5a: bRoot += 4; break;  // E
    case 0x6b5: bRoot += 5; break;  // F
    case 0xd6a: bRoot += 6; break;  // F#
    case 0xad5: bRoot += 7; break;  // G

    case 0x5ab: bRoot += 8; break;  // G#
    case 0xb56: bRoot += 9; break;  // A
    case 0x6ad: bRoot += 10; break; // A#
    case 0xd5a: bRoot += 11; break; // B
    }

    return (char) (bRoot %= 12);
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ChangeChordMap |  Modifies the chords
and scale pattern of an existing section segment to reflect the new ChordMap.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | Either <p pSectionSeg> or <p pChordMap> is not a valid pointer.

@comm
*/
HRESULT CDMCompos::ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg, // @parm The section to change the ChordMap upon.
                    BOOL                        fTrackScale, // @parm If TRUE, does scale tracking.
                    IDirectMusicChordMap*   pChordMap // @parm The ChordMap to change the section.
            )
{
    V_INAME(IDirectMusicComposer::ChangeChordMap)
    V_PTR_WRITE(pSectionSeg, 1);
    V_PTR_WRITE(pChordMap, 1);

    HRESULT                 hr              = S_OK;
    IDMPers*                pDMP            = NULL;
    IDirectMusicTrack*      pChordTrack     = NULL;
    IDirectMusicStyle*      pStyle          = NULL;
    IPersistStream*         pPS             = NULL;
    IStream*                pStream         = NULL;
    IAARIFFStream*          pChordRIFF      = NULL;
    TList<PlayChord>        ChordList;
    BYTE                    bSectionRoot    = 0;
    DWORD                   dwSectionScale  = 0;
    TListItem<PlayChord>*   pChords         = NULL;
    DMPersonalityStruct*    pPers           = NULL;
    BYTE                    bNewRoot        = 0;
    DWORD                   dwNewScale      = 0;
    char                    chOffset        = 0;

    EnterCriticalSection( &m_CriticalSection );
    pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP);
    pDMP->GetPersonalityStruct((void**)&pPers);
    if (!pPers)
    {
        Trace(1, "ERROR (ChangeChordMap): Chord map not properly initialized.\n");
        hr = DMUS_E_NOT_INIT;
        goto ON_END;
    }
    // Get the segment's chord track.
    hr = pSectionSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;
    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bSectionRoot, dwSectionScale);
    bSectionRoot %= 24;

    pChordMap->GetScale(&dwNewScale);
    bNewRoot = (BYTE) (dwNewScale >> 24);
    dwNewScale &= 0xffffff;
    if (pPers->m_dwChordMapFlags & DMUS_CHORDMAPF_VERSION8)
    {
        BYTE bTempRoot = bSectionRoot % 12;
        if (bNewRoot < bTempRoot) bNewRoot += 12;
        chOffset = (bNewRoot - bTempRoot) % 12;
    }
    else
    {
        chOffset = ShiftRoot(dwNewScale, bNewRoot) - ShiftRoot(dwSectionScale, bSectionRoot);
    }
    // Modify the chords in the chord list to match the new personality's chord palette.
    for (pChords = ChordList.GetHead(); pChords; pChords = pChords->GetNext())
    {
        PlayChord& rChord = pChords->GetItemValue();
        char chRoot = rChord.GetRoot();
        if (fTrackScale)
        {
            chRoot += chOffset;
        }
        TListItem<DMChordData> *pPalette;
        char chNewRoot = chRoot - bSectionRoot;
        while (chNewRoot < 0) chNewRoot += 12;
        while (chNewRoot > 23) chNewRoot -= 12;
        pPalette = pPers->m_aChordPalette[chNewRoot].GetHead();
        if (!pPalette)
        {
            Trace(1, "ERROR (ChangeChordMap): No Chord Pallette for root %d.\n", chNewRoot);
            hr = E_POINTER;
            goto ON_END;
        }
        if (rChord.m_pChord)
        {
            rChord.m_pChord->Release();
            delete rChord.m_pChord;
        }
        rChord.m_pChord = new DMChordData(pPalette->GetItemValue());
        if (!rChord.m_pChord)
        {
            hr = E_OUTOFMEMORY;
            goto ON_END;
        }
    }
    pStream->Release();
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pStream, &pChordRIFF);
    if (S_OK != hr) goto ON_END;
    // Get the segment's first style
    hr = GetStyle(pSectionSeg, 0, ALL_TRACK_GROUPS, pStyle, true);
    if (FAILED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    SaveChordList(pChordRIFF, ChordList, bNewRoot, dwNewScale, TimeSig);
    pPS->Release();
    pPS = NULL;
    // Load the modified chord list into the chord track
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    hr = pPS->Load(pStream);
ON_END:
    //ChordList.RemoveAll();
    Clear(ChordList);
    if (pPS)
    {
        pPS->Release();
    }
    if (pChordTrack)
    {
        pChordTrack->Release();
    }
    if (pChordRIFF)
    {
        pChordRIFF->Release();
    }
    if (pStyle)
    {
        pStyle->Release();
    }
    if (pStream)
    {
        pStream->Release();
    }
    if (pDMP)
    {
        pDMP->Release();
    }
    CleanUp();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

STDMETHODIMP CDMCompos::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CDMCompos::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicComposer)
    {
        *ppv = static_cast<IDirectMusicComposer*>(this);
    }
    else if (iid == IID_IDirectMusicComposer8)
    {
        *ppv = static_cast<IDirectMusicComposer8*>(this);
        m_dwFlags |= COMPOSEF_USING_DX8;
    }
    else if (iid == IID_IDirectMusicComposer8P)
    {
        *ppv = static_cast<IDirectMusicComposer8P*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMCompos::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMCompos::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmcomp2.cpp ===
//
// DMComp2.cpp : Further implementation of CDMCompos
//
// Copyright (c) 1999-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMCompos.h"
#include "debug.h"

#include "DMPers.h"
#include "DMTempl.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\iostru.h"

V_INAME(DMCompose)

void CDMCompos::ChordConnections2(TList<DMChordEntry>& ChordMap,
                                  CompositionCommand& rCommand,
                                  SearchInfo *pSearch,
                                  short nBPM,
                                  DMChordData *pCadence1,
                                  DMChordData *pCadence2)
{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1 || pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = nBPM;
        pSearch->m_nChords++;
        if (pCadence1 && pCadence2)
        {
            pSearch->m_nMinBeats++;
            pSearch->m_nChords++;
        }
    }
    tempSearch = *pSearch;
    rCommand.m_PlayList.RemoveAll();
    Compose(ChordMap, pSearch, rCommand);
    pChord = rCommand.m_PlayList.GetHead();
    /////////
    *pSearch = tempSearch;
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
    // But DON'T violate min/max for each chord.
    pChord = rCommand.m_PlayList.GetHead();
    int lastbeat = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        if ((newbeat - lastbeat) < rChord.m_nMinbeats) newbeat = lastbeat + rChord.m_nMinbeats;
        if ((newbeat - lastbeat) > rChord.m_nMaxbeats) newbeat = lastbeat + rChord.m_nMaxbeats;
        rChord.m_nBeat = (short)newbeat;
        lastbeat = newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure =
            (short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

void CDMCompos::ComposePlayList2(TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList)
{
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    short nBPM = TimeSig.bBeatsPerMeasure;
    IDMPers* pDMP;
    pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
    DMPersonalityStruct* pPers;
    pDMP->GetPersonalityStruct((void**)&pPers);
    TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
    TList<CompositionCommand> CommandList;
    TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
    for(; pTC; pTC = pTC->GetNext())
    {
        TemplateCommand& rTC = pTC->GetItemValue();
        TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
        if (pNew)
        {
            CompositionCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rTC.m_nMeasure;
            rNew.m_Command = rTC.m_Command;
            rNew.m_dwChord = rTC.m_dwChord;
            rNew.m_pSignPost = NULL;
            rNew.m_pFirstChord = NULL;
            CommandList.AddTail(pNew);
        }
    }
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
    // Now, we should have a chord assigned for each node in the template.
    TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
        if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
                CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    pSign = rNext.m_pSignPost;
                    DMSignPost& rSign = pSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                //**********pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats  );
                pSearch->m_nMinChords = 0;  // should be 1?
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
                // rCommand holds the playlist and the measure used by ChordConnections
                // (it should be passed by reference since the playlist changes)
                ChordConnections2(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
            }
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
                    rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
    pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
    pDMP->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmtempl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmtempl.h
//
//--------------------------------------------------------------------------

// DMTempl.h : Declaration of the CDMTempl

#ifndef __DMTEMPL_H_
#define __DMTEMPL_H_

#include "DMCompos.h"

struct TemplateStruct
{
	void AddIntro(bool f1Bar, int nLength);
	void AddIntro(TList<PlayChord>& PlayList, int nIntroLength);
	void AddEnd(int nLength);
	void InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand);
	void AddChord(int nMeasure, DWORD dwChord);
	void AddCommand(int nMeasure, DWORD dwCommand);
	void CreateSignPosts();
    void CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength);
	void IncorporateTemplate(short nMeasure, TemplateStruct* pTemplate, short nDirection);
	void FillInGrooveLevels();

	String					m_strName;
	String					m_strType;
	short					m_nMeasures;
	TList<TemplateCommand>	m_CommandList;
};

/////////////////////////////////////////////////////////////////////////////
// CDMTempl
class CDMTempl : 
	public IDMTempl,
	public IPersistStream
{
public:
	CDMTempl();
	~CDMTempl();
	void CleanUp();
	HRESULT SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT LoadTemplate( LPSTREAM pStream, DWORD dwSize );
	HRESULT Init(TemplateStruct* pTemplate);

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMTempl
public:
	HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment);
	HRESULT STDMETHODCALLTYPE Init(void* pTemplate);

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

public: // attributes
    long m_cRef;
	BOOL					m_fDirty;				// has this been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	TemplateStruct*			m_pTemplateInfo;
};

#endif //__DMTEMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmcompp.h ===
//
// DMCompP.H
//
// Private include for DMCompos.DLL
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
//

#ifndef _DMCOMPP_
#define _DMCOMPP_

#define ALL_TRACK_GROUPS 0xffffffff

extern long g_cComponent;

// Class factory
//
class CDirectMusicPersonalityFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicComposerFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicComposerFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicComposerFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicTemplateFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicTemplateFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicTemplateFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSignPostTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSignPostTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSignPostTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicPersonalityTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityTrackFactory() {} 

private:
    long m_cRef;
};

// private interfaces
interface IDMPers : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality)=0; 
};

interface IDMTempl : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE Init(void* pTemplate)=0;
};


// private CLSIDs and IIDs (some IIDs should no longer be needed...)
const CLSID CLSID_DMTempl = {0xD30BCC65,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

const IID IID_IDMPers = {0x93BE9414,0x5C4E,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_IDMCompos = {0x6724A8C0,0x60C3,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
const IID IID_IDMTempl = {0xD30BCC64,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_ISPstTrk = {0xB65019E0,0x61B6,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

/*
// stuff that will move to dmusici.h

DEFINE_GUID(CLSID_DirectMusicPersonalityTrack, 
	0xf1edefe1, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);

DEFINE_GUID(GUID_PersonalityTrack, 
	0xf1edefe2, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
	*/

/*
// stuff that will move to dmusicf.h

// personalities

// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

///*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

///

// Signpost tracks

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK	 mmioFOURCC( 's', 'g', 'n', 'p' )


struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

///*

	// <sgnp-list>
	'sgnp'
	(
		//sizeof ioDMSignPost, followed by a number of <ioDMSignPost>
	)

///

// Personality tracks

#define DMUS_FOURCC_PERF_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERF_REF_LIST mmioFOURCC('p', 'f', 'r', 'f')
#define DMUS_FOURCC_TIME_STAMP_CHUNK mmioFOURCC('s', 't', 'm', 'p')

///*

	// <pftr-list>
	LIST('pftr'
	(
		// some number of <pfrf-list>
	)

	// <pfrf-list>
	LIST('pfrf'
	(
		<stmp-ck>
		<DMRF>
	)

  // <stmp-ck>
  'stmp'
  (
	// time:DWORD
  )



///

*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmpers.h ===
// DMPers.h : Declaration of the CDMPers
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//

#ifndef __DMPERS_H_
#define __DMPERS_H_

#include "dmusici.h"
#include "DMCompos.h"

const short MAX_PALETTE = 24;

struct DMPersonalityStruct
{
	//void ResolveConnections( LPPERSONALITY personality, short nCount );
	bool					m_fLoaded;			// is the personality loaded in memory?
	GUID					m_guid;
	//DWORD					m_dwVersionMS;
	//DWORD					m_dwVersionLS;
	String					m_strName;			// Name of the personality
	//String					m_strCategory;			// Category of the personality
	DWORD					m_dwScalePattern;	// Scale for the personality
	DWORD					m_dwChordMapFlags;			// Flags (?)
	TList<DMChordData>		m_aChordPalette[MAX_PALETTE];	// chord palette
	TList<DMChordEntry>		m_ChordMap;			// Chord map DAG (adjacency list)
	TList<DMSignPost>		m_SignPostList;		// List of sign posts
};

/*
@interface IDirectMusicPersonality | 
The <i IDirectMusicPersonality> interface provides methods for manipulating personalities.
Personalities provide the Composer (<i IDirectMusicComposer>) with the information it 
needs to compose chord progressions, which it uses to build section segments and automatic 
transitions, as wells as to change the chords in an existing segment as it plays.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.

@base public | IUnknown

@meth HRESULT | GetScale | Returns the scale of the personality.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMPers
class CDMPers : 
	public IDMPers,
	public IDirectMusicChordMap,
	public IDirectMusicObject,
	public IPersistStream
{
public:
	CDMPers();
	~CDMPers();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMPers
public:
	void CleanUp();
	//HRESULT LoadPersonality( LPSTREAM pStream, DWORD dwSize );
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB );
	HRESULT DM_LoadChordEntry( 
		IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax );
	HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality);

// IDirectMusicPersonality
public:
HRESULT STDMETHODCALLTYPE GetScale(DWORD* pdwScale);

//HRESULT STDMETHODCALLTYPE GetName(BSTR* pdwName);

// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

protected: // attributes
    long m_cRef;
	BOOL					m_fDirty;				// has the style been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	DMPersonalityStruct		m_PersonalityInfo;		// The details of the personality
};

#endif //__DMPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmpers.cpp ===
// 
// DMPers.cpp : Implementation of CDMPers
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMPers.h"
#include "dmusici.h"

#include "..\shared\validate.h"
#include "..\shared\dmscriptautguids.h"

#include "debug.h"

V_INAME(DMCompose)

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, String& pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwBytesRead;
    
    pstrText = "";
    
    wstrText = new wchar_t[dwSize];
    if( wstrText == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERR;
    }

    hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
    if( FAILED( hr )
    ||  dwBytesRead != dwSize )
    {
        goto ON_ERR;
    }

    pstrText = wstrText;
    
ON_ERR:
    if( wstrText )
        delete [] wstrText;
}

/////////// Utility functions for chords //////////////////

static BYTE setchordbits( long lPattern )
{
LONG    i;
short   count = 0;
BYTE bBits = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( lPattern & (1L << i) )
            count++;
    }
    bBits |= CHORD_INVERT;
    if( count > 3 )
        bBits |= CHORD_FOUR;
    if( lPattern & (15L << 18L) )
        bBits |= CHORD_UPPER;
    bBits &= ~CHORD_COUNT;
    bBits |= count;
    return bBits;
}

// returns TRUE if the chord pattern represents a multichord, FALSE otherwise
inline BOOL MultiChord(DWORD dwPattern)
{
    BYTE bBits = setchordbits( dwPattern );
    short nChordCount = bBits & CHORD_COUNT;
    return !((bBits & CHORD_FOUR && nChordCount <= 4) || 
             (!(bBits & CHORD_FOUR) && nChordCount <= 3));
}

/*
TListItem<DMExtendedChord*>* ConvertChord(
    DWORD dwChordPattern, BYTE bChordRoot, DWORD dwScalePattern, BYTE bScaleRoot)
{ 
    BYTE bBits = setchordbits( dwChordPattern );
    short nChordCount = bBits & CHORD_COUNT;
    // The root of the lower chord is the input chord's root, 
    // relative to the scale root.
    bChordRoot -= bScaleRoot;
    if (bChordRoot < 0) bChordRoot += 12;
    if ((bBits & CHORD_FOUR && nChordCount <= 4) || 
        (!(bBits & CHORD_FOUR) && nChordCount <= 3))
    {
        // single subchord with all info from input chord
        TListItem<DMExtendedChord*>* pSubChord = new TListItem<DMExtendedChord*>;
        if ( pSubChord == NULL ) return NULL;
        DMExtendedChord* pNew = new DMExtendedChord;
        if (!pNew)
        {
            delete pSubChord;
            return NULL;
        }
        DMExtendedChord*& rSubChord = pSubChord->GetItemValue();
        rSubChord = pNew;
        rSubChord->m_dwChordPattern = dwChordPattern;
        rSubChord->m_dwScalePattern = dwScalePattern;
        rSubChord->m_dwInvertPattern = 0xffffff;    // default: inversions everywhere
        rSubChord->m_bRoot = bChordRoot;
        rSubChord->m_bScaleRoot = bScaleRoot;
        rSubChord->m_wCFlags = 0;
        // A single subchord can be used as either a bass or standard chord
        rSubChord->m_dwParts = (1 << SUBCHORD_BASS) | (1 << SUBCHORD_STANDARD_CHORD);
        rSubChord->AddRef();
        return pSubChord;
    }
    else
    {
        // two subchords both with scale and roots from input chord, and:
        // 1st chord: chord pattern from lower n notes of input chord
        // 2nd chord: chord pattern from upper n notes of input chord
        DWORD dwLowerSubChord = 0L;
        DWORD dwUpperSubChord = 0L;
        BYTE bUpperRoot = bChordRoot;
        DWORD dwPattern = dwChordPattern;
        short nIgnoreHigh = (bBits & CHORD_FOUR) ? 4 : 3;
        short nIgnoreLow = (bBits & CHORD_FOUR) ? nChordCount - 4 : nChordCount - 3;
        short nLowestUpper = 0;
        for (short nPos = 0, nCount = 0; nPos < 24; nPos++)
        {
            if (dwPattern & 1)
            {
                if (nCount < nIgnoreHigh)
                {
                    dwLowerSubChord |= 1L << nPos;
                }
                if (nCount >= nIgnoreLow)
                {
                    if (!nLowestUpper)
                    {
                        nLowestUpper = nPos;
                        bUpperRoot = (bUpperRoot + (BYTE) nLowestUpper);
                    }
                    dwUpperSubChord |= 1L << (nPos - nLowestUpper);
                }
                nCount++;
                if (nCount >= nChordCount)
                    break;
            }
            dwPattern >>= 1L;
        }
        // now, create the two subchords.
        TListItem<DMExtendedChord*>* pLowerSubChord = new TListItem<DMExtendedChord*>;
        if ( pLowerSubChord == NULL ) return NULL;
        DMExtendedChord* pLower = new DMExtendedChord;
        if (!pLower)
        {
            delete pLowerSubChord;
            return NULL;
        }
        DMExtendedChord*& rLowerSubChord = pLowerSubChord->GetItemValue();
        rLowerSubChord = pLower;
        rLowerSubChord->m_dwChordPattern = dwLowerSubChord;
        rLowerSubChord->m_dwScalePattern = dwScalePattern;
        rLowerSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rLowerSubChord->m_bRoot = bChordRoot;
        rLowerSubChord->m_bScaleRoot = bScaleRoot;
        rLowerSubChord->m_wCFlags = 0;
        rLowerSubChord->m_dwParts = (1 << SUBCHORD_BASS); // the lower chord is the bass chord
        TListItem<DMExtendedChord*>* pUpperSubChord = new TListItem<DMExtendedChord*>;
        if ( pUpperSubChord == NULL ) return NULL;
        DMExtendedChord* pUpper = new DMExtendedChord;
        if (!pUpper) 
        {
            delete pUpperSubChord;
            return NULL;
        }
        DMExtendedChord*& rUpperSubChord = pUpperSubChord->GetItemValue();
        rUpperSubChord = pUpper;
        rUpperSubChord->m_dwChordPattern = dwUpperSubChord;
        rUpperSubChord->m_dwScalePattern = dwScalePattern;
        rUpperSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rUpperSubChord->m_bRoot = bUpperRoot % 24;
        while (rUpperSubChord->m_bRoot < rLowerSubChord->m_bRoot)
            rUpperSubChord->m_bRoot += 12;
        rUpperSubChord->m_bScaleRoot = bScaleRoot;  
        rUpperSubChord->m_wCFlags = 0;
        rUpperSubChord->m_dwParts = (1 << SUBCHORD_STANDARD_CHORD); // the upper chord is the standard chord
        rLowerSubChord->AddRef();
        rUpperSubChord->AddRef();
        return pLowerSubChord->Cat(pUpperSubChord);
    }
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDMPers

CDMPers::CDMPers( ) : m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
}

CDMPers::~CDMPers()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CDMPers::CleanUp()
{
    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
    TListItem<DMChordEntry>* pEntry = m_PersonalityInfo.m_ChordMap.GetHead(); 
    for(; pEntry; pEntry=pEntry->GetNext())
    {
        pEntry->GetItemValue().m_ChordData.Release();
    }
    m_PersonalityInfo.m_ChordMap.CleanUp();
    for (short i = 0; i < 24; i++)
    {
        TListItem<DMChordData>* pData = m_PersonalityInfo.m_aChordPalette[i].GetHead(); 
        for(; pData; pData=pData->GetNext())
        {
            pData->GetItemValue().Release();
        }
        m_PersonalityInfo.m_aChordPalette[i].CleanUp();
    }
    TListItem<DMSignPost>* pSignPost = m_PersonalityInfo.m_SignPostList.GetHead();
    for (; pSignPost != NULL; pSignPost = pSignPost->GetNext())
    {
        DMSignPost& rSignPost = pSignPost->GetItemValue();
        rSignPost.m_ChordData.Release();
        rSignPost.m_aCadence[0].Release();
        rSignPost.m_aCadence[1].Release();
    }
    m_PersonalityInfo.m_SignPostList.CleanUp();
}

STDMETHODIMP CDMPers::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMPers::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicChordMap)
    {
        *ppv = static_cast<IDirectMusicChordMap*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDMPers)
    {
        *ppv = static_cast<IDMPers*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMPers::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMPers::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMPers::GetPersonalityStruct(void** ppPersonality)
{
    if (ppPersonality)
        *ppPersonality = &m_PersonalityInfo;
    return S_OK;
}

HRESULT CDMPers::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    EnterCriticalSection( &m_CriticalSection );
    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;
    if (m_PersonalityInfo.m_fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }
    if (m_PersonalityInfo.m_guid.Data1 || m_PersonalityInfo.m_guid.Data2)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_PersonalityInfo.m_guid;
    }
    if (m_PersonalityInfo.m_strName)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcscpy(pDesc->wszName, m_PersonalityInfo.m_strName);
        //MultiByteToWideChar( CP_ACP, 0, m_PersonalityInfo.m_strName, -1, pDesc->wszName, DMUS_MAX_NAME);
    }
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

HRESULT CDMPers::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::SetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    EnterCriticalSection( &m_CriticalSection );
    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_PersonalityInfo.m_guid = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            m_PersonalityInfo.m_strName = pDesc->wszName;
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2, "WARNING: SetDescriptor (chord map): Descriptor contains fields that were not set.\n");
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMPers::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
//    Prsonality  personality;
//    DWORD       dwSize;
//    FOURCC      id;
    DWORD dwPos;
    HRESULT hr = S_OK;

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    hr = AllocRIFFStream( pStream, &pIRiffStream );
    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_ParseDescriptor( pIRiffStream, &ckMain, pDesc );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }
    else
    {
        return hr;
    }

    if( !fFoundFormat )
    {
        /* Don't try to parse IMA 2.5 format
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
        */
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        /*
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        }

        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicChordMap;

        GetMLong( pStream, dwSize );
        if( SUCCEEDED( pStream->Read( &personality, min( sizeof(Prsonality), dwSize ), NULL ) ) )
        {
            MultiByteToWideChar( CP_ACP, 0, personality.name, -1, pDesc->wszName, DMUS_MAX_NAME);
            if (pDesc->wszName[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
            }
        }
        */
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPersonality

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicPersonality | GetScale | Retrieves the scale
associated with the personality.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | <p pdwScale> is not a valid pointer.

@comm The scale is defined by the bits in a DWORD, split into a scale pattern (lower 24 bits)
and a root (upper 8 bits) For the scale pattern, the low bit (0x0001) is the lowest note in the
scale, the next higher (0x0002) is a semitone higher, etc. for two octaves.  The root is
represented as a number between 0 and 23, where 0 represents a low C, 1 represents the
C# above that, etc. for two octaves.

*/
 
HRESULT CDMPers::GetScale(
                    DWORD *pdwScale // @parm The scale value to be returned.
                )
{
    V_PTR_WRITE(pdwScale, sizeof(DWORD) );
    *pdwScale = m_PersonalityInfo.m_dwScalePattern;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CDMPers::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DirectMusicChordMap;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IPersistStream

HRESULT CDMPers::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

HRESULT CDMPers::Save( LPSTREAM /*pStream*/, BOOL /*fClearDirty*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::Load( LPSTREAM pStream )
{
    //FOURCC id;
    //DWORD dwSize;
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    CleanUp();

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_LoadPersonality( pIRiffStream, &ckMain );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }

    if( !fFoundFormat )
    {
        /* Don't try to load IMA 2.5 format
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
        */
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        /*
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        }
        hr = LoadPersonality( pStream, dwSize );
        */
    }
end:
    if (SUCCEEDED(hr)) m_PersonalityInfo.m_fLoaded = true;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

/*
static LPSINEPOST loadasignpost( LPSTREAM pStream, DWORD dwSize )
{
    LPSINEPOST signpost;

    signpost = new SinePost;
    if( signpost == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if( dwSize > sizeof(SinePost) )
    {
        pStream->Read( signpost, sizeof(SinePost), NULL );
        FixBytes( FBT_SINEPOST, signpost );
        StreamSeek( pStream, dwSize - sizeof(SinePost), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( signpost, dwSize, NULL );
        FixBytes( FBT_SINEPOST, signpost );
    }
    signpost->pNext = 0;
    signpost->chord.pNext      = 0;
    signpost->cadence[0].pNext = 0;
    signpost->cadence[1].pNext = 0;

    return signpost;
}


static LPNEXTCHRD loadnextchords( LPSTREAM pStream, DWORD dwSiz )
{
    HRESULT hr = S_OK;
    LPNEXTCHRD nextchordlist = NULL;
    LPNEXTCHRD nextchord;
    DWORD      nodesize = 0;
    long lSize = dwSiz;

    if (!GetMLong( pStream, nodesize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    lSize -= 4;

    while( lSize > 0 )
    {
        nextchord = new NextChrd;
        if( nextchord == NULL )
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        if( nodesize > NEXTCHORD_SIZE )
        {
            hr = pStream->Read( &nextchord->dwflags, NEXTCHORD_SIZE, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
            StreamSeek( pStream, nodesize - NEXTCHORD_SIZE, STREAM_SEEK_CUR );
        }
        else
        {
            pStream->Read( &nextchord->dwflags, nodesize, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
        }
        lSize -= nodesize;

        if (SUCCEEDED(hr))
        {
            nextchord->pNext = 0;
            nextchordlist = List_Cat( nextchordlist, nextchord );
        }
        else 
        {
            delete nextchord;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
    }

    return nextchordlist;
}

static LPCHRDENTRY loadachordentry( LPSTREAM pStream, DWORD dwSiz )
{
    LPCHRDENTRY chordentry;
    DWORD       csize = 0;
    DWORD       segsize = 0;
    DWORD       id;
    long lSize = dwSiz;

    chordentry = new ChrdEntry;
    if( chordentry == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete chordentry;
        return NULL;
    }
    
    lSize -= 4;
    if( csize > CHORDENTRY_SIZE )
    {
        pStream->Read( &chordentry->chord.time, CHORDENTRY_SIZE, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
        StreamSeek( pStream, csize - CHORDENTRY_SIZE, STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &chordentry->chord.time, csize, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
    }
    lSize -= csize;
    chordentry->pNext = 0;
    chordentry->nextchordlist = 0;
    chordentry->chord.pNext    = 0;

    while( lSize > 0 )
    {
        pStream->Read( &id, sizeof(id), NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;

        switch( id )
        {
        case mmioFOURCC( 'L', 'X', 'N', 's' ):
            chordentry->nextchordlist = loadnextchords( pStream, segsize );
            break;
        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    return chordentry;
}

void DMPersonalityStruct::ResolveConnections( LPPERSONALITY personality, short nCount )
{
    LPCHRDENTRY entry;
    LPNEXTCHRD  nextchord;

    if (nCount == 0)
    {
        return;
    }
    // nCount is the largest index, so the array needs to be one more than that
    TListItem<DMChordEntry> **ChordMap = new TListItem<DMChordEntry> *[nCount + 1]; 
    if (!ChordMap) return;

    for( entry=personality->chordlist ;  entry ;  entry=entry->pNext )
    {
        TListItem<DMChordEntry>* pEntry = new TListItem<DMChordEntry>;
        if (!pEntry)
        {
            delete [] ChordMap;
            return;
        }
        DMChordEntry& rEntry = pEntry->GetItemValue();
        rEntry.m_dwFlags = entry->dwflags;
        rEntry.m_ChordData.m_strName = entry->chord.name;
        rEntry.m_ChordData.m_pSubChords = ConvertChord(
            entry->chord.pattern, entry->chord.root, entry->chord.scalepattern, 0);
        m_ChordMap.AddHead(pEntry);
        ChordMap[entry->nid] = pEntry;
        nextchord = entry->nextchordlist;
        for( ;  nextchord ;  nextchord=nextchord->pNext )
        {
            if( nextchord->nid )
            {
                TListItem<DMChordLink>* pLink = new TListItem<DMChordLink>;
                if (!pLink)
                {
                    delete [] ChordMap;
                    return;
                }
                DMChordLink& rLink = pLink->GetItemValue();
                rLink.m_wWeight = nextchord->nweight;       
                rLink.m_wMinBeats = nextchord->nminbeats;
                rLink.m_wMaxBeats = nextchord->nmaxbeats;
                rLink.m_dwFlags = nextchord->dwflags;
                rLink.m_nID = nextchord->nid;
                rEntry.m_Links.AddHead(pLink);
            }
        }
    }

    for(TListItem<DMChordEntry>* pEntry=m_ChordMap.GetHead(); pEntry; pEntry=pEntry->GetNext())
    {
        TListItem<DMChordLink>* pLink = pEntry->GetItemValue().m_Links.GetHead();
        for( ;  pLink ;  pLink = pLink->GetNext() )
        {
            DMChordLink& rLink = pLink->GetItemValue();
            if( rLink.m_nID )
            {
                rLink.m_pChord = ChordMap[rLink.m_nID];
            }
        }
    }
    delete [] ChordMap;
}

HRESULT CDMPers::LoadPersonality( LPSTREAM pStream, DWORD dwSiz )
{
    short         i;
    LPPERSONALITY personality;
    LPCHRDENTRY   chordentry;
    LPSINEPOST    signpost;
    DWORD         csize = 0;
    DWORD         segsize = 0;
    FOURCC        id;
    short         nCount = 0;
    long lSize = dwSiz;
    HRESULT hr = S_OK;

    if ( pStream == NULL ) return E_INVALIDARG;
    personality = new Prsonality;
    if( personality == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete personality;
        return E_FAIL;
    }

    lSize -= 4;
    if( csize > sizeof(Prsonality) )
    {
        pStream->Read( personality, sizeof(Prsonality), NULL );
        FixBytes( FBT_PRSONALITY, personality );
        StreamSeek( pStream, csize - sizeof(Prsonality), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( personality, csize, NULL );
        FixBytes( FBT_PRSONALITY, personality );
    }
    lSize -= csize;
    m_PersonalityInfo.m_strName = personality->name;
    m_PersonalityInfo.m_dwScalePattern = personality->scalepattern;
    personality->pNext         = NULL;
    personality->dwAA         = 0;
    personality->chordlist    = NULL;
    personality->signpostlist = NULL;
    personality->playlist     = 0;
    personality->firstchord   = NULL;
    for( i=0 ;  i<24 ;  i++ )
    {
        TListItem<DMChordData>* pPaletteEntry = new TListItem<DMChordData>;
        if (!pPaletteEntry)
        {
            hr = E_OUTOFMEMORY;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
        DMChordData& rChordData = pPaletteEntry->GetItemValue();
        rChordData.m_strName = personality->chord[i].achName;
        rChordData.m_pSubChords = ConvertChord(
            personality->chord[i].lPattern, personality->chord[i].chRoot, 
            personality->chord[i].lScalePattern, 0);
        m_PersonalityInfo.m_aChordPalette[i].AddTail(pPaletteEntry);
        personality->chord[i].pNext = 0;
    }

    if (SUCCEEDED(hr))
    {
        while( lSize > 0 )
        {
            pStream->Read( &id, sizeof(id), NULL );
            if (!GetMLong( pStream, segsize ))
            {
                StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= 8;

            switch( id )
            {
            case mmioFOURCC( 'N', 'E', 'C', 's' ):
                chordentry = loadachordentry( pStream, segsize );
                if( chordentry )
                {
                    personality->chordlist = List_Cat( personality->chordlist, chordentry );
                    if (chordentry->nid > nCount)
                        nCount = chordentry->nid;
                }
                break;

            case mmioFOURCC( 'P', 'N', 'S', 's' ):
                signpost = loadasignpost( pStream, segsize );
                if( signpost )
                {
                    personality->signpostlist = List_Cat( personality->signpostlist, signpost );
                    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
                    if (!pSignPost)
                    {
                        hr = E_OUTOFMEMORY;
                        StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                        break;
                    }
                    DMSignPost& rSignPost = pSignPost->GetItemValue();
                    rSignPost.m_dwChords = signpost->chords;
                    rSignPost.m_dwFlags = signpost->flags;
                    rSignPost.m_dwTempFlags = signpost->tempflags;
                    rSignPost.m_ChordData.m_strName = signpost->chord.name;
                    rSignPost.m_ChordData.m_pSubChords = ConvertChord(
                        signpost->chord.pattern, signpost->chord.root, 
                        signpost->chord.scalepattern, 0);
                    rSignPost.m_aCadence[0].m_strName = signpost->cadence[0].name;
                    rSignPost.m_aCadence[0].m_pSubChords = ConvertChord(
                        signpost->cadence[0].pattern, signpost->cadence[0].root, 
                        signpost->cadence[0].scalepattern, 0);
                    rSignPost.m_aCadence[1].m_strName = signpost->cadence[1].name;
                    rSignPost.m_aCadence[1].m_pSubChords = ConvertChord(
                        signpost->cadence[1].pattern, signpost->cadence[1].root, 
                        signpost->cadence[1].scalepattern, 0);
                    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
               }
                break;

            default:
                StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= segsize;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_PersonalityInfo.ResolveConnections( personality, nCount );
    }

    // free up all the old format data structures
    LPCHRDENTRY pChord;
    LPNEXTCHRD  pNextChord;
    LPNEXTCHRD  pNextNextChord;
    for( pChord = personality->chordlist ; pChord != NULL ; pChord = pChord->pNext )
    {
        for( pNextChord = pChord->nextchordlist ; pNextChord != NULL ;  pNextChord = pNextNextChord )
        {
            pNextNextChord = pNextChord->pNext;
            delete pNextChord;
        }
    }
    List_Free( personality->chordlist );
    List_Free( personality->signpostlist );
    delete personality;

    return hr;
}
*/

HRESULT CDMPers::DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    DWORD               dwByteCount;
    DWORD               dwSize;
    DWORD               dwPos;
    HRESULT             hr = S_OK;
    short nCount = 0;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;
                }
                wcscpy(pDesc->wszName, iPersonality.wszLoadName);
                if(pDesc->wszName[0])
                {
                    pDesc->dwValidData |= DMUS_OBJ_NAME;
                    pDesc->wszName[16] = 0;
                }
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &pDesc->guidObject, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;

                }
                pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_END:
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    MMCKINFO            ck1;
    MMCKINFO            ckList;
    DWORD               dwByteCount;
    DWORD               dwSize;
    DWORD               dwPos;
    HRESULT             hr = S_OK;
    DMExtendedChord**   apChordDB = NULL;
    short nCount = 0;
    short n;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                ZeroMemory(&iPersonality, sizeof(DMUS_IO_CHORDMAP));
                iPersonality.dwScalePattern = 0xffffffff;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                if( iPersonality.dwFlags & 0xffff0000 )
                {
                    // the scale was not properly initialized
                    Trace(2, "WARNING: Load (chord map): The chord map's flags are not properly initialized; clearing flags.\n");
                    iPersonality.dwFlags = 0;
                }
                if( !(iPersonality.dwFlags & DMUS_CHORDMAPF_VERSION8) && 
                    iPersonality.dwScalePattern >> 24 )
                {
                    // the scale was not properly initialized
                    Trace(1, "ERROR: Load (chord map): The chord map's scale is not properly initialized.\n");
                    hr = DMUS_E_NOT_INIT;
                    goto ON_END;
                }
                m_PersonalityInfo.m_strName = iPersonality.wszLoadName;
                m_PersonalityInfo.m_dwScalePattern = iPersonality.dwScalePattern;
                m_PersonalityInfo.m_dwChordMapFlags = iPersonality.dwFlags;
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &m_PersonalityInfo.m_guid, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                break;

            case DMUS_FOURCC_SUBCHORD_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid size DWORD.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                TList<DMExtendedChord*> ChordList;
                while (lFileSize > 0)
                {
                    DMUS_IO_PERS_SUBCHORD iSubChord;
                    hr = pIStream->Read( &iSubChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid DMUS_IO_PERS_SUBCHORD.\n");
                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    // stuff the data into a subchord struct and add it to the chord list
                    // (in reverse order)
                    TListItem<DMExtendedChord*>* pChordItem = new TListItem<DMExtendedChord*>;
                    if (pChordItem)
                    {
                        DMExtendedChord*& rpChord = pChordItem->GetItemValue();
                        rpChord = new DMExtendedChord;
                        if (rpChord)
                        {
                            rpChord->m_dwChordPattern = iSubChord.dwChordPattern;
                            rpChord->m_dwScalePattern = iSubChord.dwScalePattern;
                            rpChord->m_dwInvertPattern = iSubChord.dwInvertPattern;
                            rpChord->m_bRoot = iSubChord.bChordRoot;
                            rpChord->m_bScaleRoot = iSubChord.bScaleRoot;
                            rpChord->m_wCFlags = iSubChord.wCFlags;
                            rpChord->m_dwParts = iSubChord.dwLevels;
                            nCount++;
                            ChordList.AddHead(pChordItem);
                        }
                        else
                        {
                            delete pChordItem;
                            pChordItem = NULL;
                        }
                    }
                    if (!pChordItem)
                    {
                        hr = E_OUTOFMEMORY;
                        goto ON_END;
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                // now that the chord list is complete, transfer the pointers into the
                // chord db (back to front to reinstate original order)
                apChordDB = new DMExtendedChord*[nCount];
                if (apChordDB)
                {
                    TListItem<DMExtendedChord*>* pScan = ChordList.GetHead();
                    for (n = nCount - 1; n >= 0; n--)
                    {
                        apChordDB[n] = pScan->GetItemValue();
                        pScan = pScan->GetNext();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                break;
            }
            case FOURCC_LIST:
                ck1 = ck;
                ckList = ck;
                switch( ck1.fccType )
                {
                case DMUS_FOURCC_CHORDPALETTE_LIST:
                    for( n = 0; pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 && n < 24; n++ )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORD_LIST )
                        {
                            TListItem<DMChordData>* pChordData = new TListItem<DMChordData>;
                            if (pChordData)
                            {
                                m_PersonalityInfo.m_aChordPalette[n].AddHead(pChordData);
                                hr = pChordData->GetItemValue().Read(pIRiffStream, &ck1, apChordDB);
                            }
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    break;
                case DMUS_FOURCC_CHORDMAP_LIST:
                {
                    short nMapMax = 0;
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORDENTRY_LIST )
                        {
                            DM_LoadChordEntry(pIRiffStream, &ck1, apChordDB, nMapMax);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    TListItem<DMChordEntry>** aChordArray = new TListItem<DMChordEntry>*[nMapMax + 1];
                    if (!aChordArray)
                    {
                        hr = E_OUTOFMEMORY;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    TListItem<DMChordEntry>* pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for(; pScan; pScan = pScan->GetNext())
                    {
                        if (pScan->GetItemValue().m_nID < 0 || pScan->GetItemValue().m_nID > nMapMax)
                        {
                            // the connection id was not properly initialized
                            Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                            hr = DMUS_E_NOT_INIT;
                            pIRiffStream->Ascend( &ck, 0 );
                            delete [] aChordArray;
                            goto ON_END;
                        }
                        aChordArray[pScan->GetItemValue().m_nID] = pScan;
                    }
                    pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for (; pScan; pScan = pScan->GetNext())
                    {
                        TListItem<DMChordLink>* pLink = pScan->GetItemValue().m_Links.GetHead();
                        for (; pLink; pLink = pLink->GetNext())
                        {
                            DMChordLink& rLink = pLink->GetItemValue();
                            if (rLink.m_nID < 0 || rLink.m_nID > nMapMax)
                            {
                                // the connection id was not properly initialized
                                Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                                hr = DMUS_E_NOT_INIT;
                                pIRiffStream->Ascend( &ck, 0 );
                                delete [] aChordArray;
                                goto ON_END;
                            }
                            rLink.m_pChord = aChordArray[rLink.m_nID];
                        }
                    }
                    delete [] aChordArray;
                    break;
                }
                    
                case DMUS_FOURCC_SIGNPOST_LIST:
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_SIGNPOSTITEM_LIST )
                        {
                            DM_LoadSignPost(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    break;

                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_END:
    if (apChordDB) delete [] apChordDB;
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadChordEntry( 
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    WORD wConnectionID = 0;

    TListItem<DMChordEntry>* pChordEntry = new TListItem<DMChordEntry>;
    if (!pChordEntry) return E_OUTOFMEMORY;
    DMChordEntry& rChordEntry = pChordEntry->GetItemValue();
    rChordEntry.m_ChordData.m_strName = "";
    m_PersonalityInfo.m_ChordMap.AddHead(pChordEntry);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDENTRY_CHUNK:
            {
                DMUS_IO_CHORDENTRY iChordEntry;
                DWORD cb;
                hr = pIStream->Read( &iChordEntry, sizeof(iChordEntry), &cb );
                if (FAILED(hr) || cb !=  sizeof(iChordEntry) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rChordEntry.m_dwFlags = iChordEntry.dwFlags;
                rChordEntry.m_nID = iChordEntry.wConnectionID;
                if (rChordEntry.m_nID > nMax) nMax = rChordEntry.m_nID;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_CHORD_LIST)
            {
                hr = rChordEntry.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
            }
            break;
        case DMUS_FOURCC_NEXTCHORDSEQ_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                while (lFileSize > 0)
                {
                    DMUS_IO_NEXTCHORD iNextChord;
                    hr = pIStream->Read( &iNextChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        if (SUCCEEDED(hr)) hr = E_FAIL;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    if (iNextChord.wConnectionID)
                    {
                        TListItem<DMChordLink>* pItem = new TListItem<DMChordLink>;
                        if (!pItem ) 
                        {
                            hr = E_OUTOFMEMORY;
                            pIRiffStream->Ascend( &ck, 0 );
                            goto ON_END;
                        }
                        DMChordLink& rLink = pItem->GetItemValue();
                        rLink.m_dwFlags = iNextChord.dwFlags;
                        rLink.m_nID = iNextChord.wConnectionID;
                        rLink.m_wWeight = iNextChord.nWeight;
                        rLink.m_wMinBeats = iNextChord.wMinBeats;
                        rLink.m_wMaxBeats = iNextChord.wMaxBeats;
                        rChordEntry.m_Links.AddHead(pItem);
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
    if (!pSignPost) return E_OUTOFMEMORY;
    DMSignPost& rSignPost = pSignPost->GetItemValue();
    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_IOSIGNPOST_CHUNK:
            {
                DMUS_IO_PERS_SIGNPOST iSignPost;
                DWORD cb;
                hr = pIStream->Read( &iSignPost, sizeof(iSignPost), &cb );
                if (FAILED(hr) || cb !=  sizeof(iSignPost) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rSignPost.m_dwChords = iSignPost.dwChords;
                rSignPost.m_dwFlags = iSignPost.dwFlags;
            }
            break;
        case FOURCC_LIST:
            switch(ck.fccType)
            {
            case DMUS_FOURCC_CHORD_LIST:
                hr = rSignPost.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
                break;
            case DMUS_FOURCC_CADENCE_LIST:
                {
                    MMCKINFO ckCadence = ck;
                    MMCKINFO ck1 = ck;
                    for (short n = 0;
                         pIRiffStream->Descend(&ck1, &ckCadence, 0) == 0 && hr == S_OK && n < 2;
                        n++)
                    {
                        if (ck1.fccType == DMUS_FOURCC_CHORD_LIST)
                        {
                            short n2 = n;
                            if ( !(rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_1) &&
                                 (rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_2) )
                            {
                                // if all we have is cadence 2, put it in location 1
                                n2 = 1;
                            }
                            hr = rSignPost.m_aCadence[n2].Read(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend(&ck1, 0);
                    }
                }
                break;
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT DMChordData::Read(
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB)
{
    HRESULT hr1 = E_FAIL, hr2 = E_FAIL;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    if (!apChordDB) return E_POINTER;
    MMCKINFO ck;
    wchar_t wzName[12];
    WORD awSubIds[4];

    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
    {
        TListItem<DMExtendedChord*>* pChord = NULL;
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDNAME_CHUNK:
            hr1 = pIStream->Read(wzName, sizeof(wzName), 0);
            if (SUCCEEDED(hr1)) m_strName = wzName;
            break;
        case DMUS_FOURCC_SUBCHORDID_CHUNK:
            hr2 = pIStream->Read(awSubIds, sizeof(awSubIds), 0);
            // now use the ids to set up pointers to subchords
            if (m_pSubChords) Release();
            pChord = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[3]]);
            if (pChord)
            {
                pChord->GetItemValue()->AddRef();
                for (short n = 2; n >= 0; n--)
                {
                    TListItem<DMExtendedChord*>* pNew = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[n]]);
                    if (pNew)
                    {
                        pNew->GetItemValue()->AddRef();
                        pNew->SetNext(pChord);
                        pChord = pNew;
                    }
                }
            }
            m_pSubChords = pChord;
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
    pIStream->Release();
    return (hr1 == S_OK && hr2 == S_OK) ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\fileio.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       fileio.cpp
//
//--------------------------------------------------------------------------

// FileIO.cpp
//

#include "aariff.h"

STDAPI AllocFileStream(LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream)
{
    HANDLE          hfile;          // handle to open file
    CFileStream *   pstream;        // IStream implementation

    // in case of error...
    *ppstream = NULL;

    // open the file
    if( dwDesiredAccess == GENERIC_READ )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else
    {
        return E_INVALIDARG;
    }
    if( hfile == INVALID_HANDLE_VALUE )
    {
        //DisplayDebug( 5, "File open error: Can't open \"%s\", error code %d", szFileName, GetLastError() );
        return E_FAIL; // to do: real error code
    }

    // create the Windows object
    if ((pstream = new CFileStream(hfile)) == NULL)
        return E_OUTOFMEMORY;

    // return an IStream pointer
    *ppstream = (IStream *) pstream;
    return S_OK;
}

STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff )
{
    if( ( *ppRiff = (IAARIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


/* MyRead, MyWrite, MySeek
 *
 * These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
 * except for the absence of the HMMIO parameter.
 */

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    /* figure out what chunk id and form/list type to search for */
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        /* read the chunk header */
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;
        FixBytes( FBT_LONG, &lpck->cksize );

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by CreateChunk();
         * check that the chunk size that was written when
         * CreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        FixBytes( FBT_LONG, &lpck->cksize );
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))  {
        	FixBytes( FBT_LONG, &lpck->cksize );
            return MMIOERR_CANNOTWRITE;
        }
        FixBytes( FBT_LONG, &lpck->cksize );
    }

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    /* store the offset of the data part of the chunk */
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
	FixBytes( FBT_MMCKINFO, lpck );
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)  {
    	FixBytes( FBT_MMCKINFO, lpck );
        return MMIOERR_CANNOTWRITE;
    }
    FixBytes( FBT_MMCKINFO, lpck );

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\iodmcomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       iodmcomp.h
//
//--------------------------------------------------------------------------

#ifndef PERSONALITYRIFF_H
#define PERSONALITYRIFF_H


// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// simple riff read/writers
inline HRESULT ReadWord(IAARIFFStream* pIRiffStream, WORD& val)
{
	assert(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	assert(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IAARIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IAARIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid = FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};


// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

/*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

*/

struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\dmtempl.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       dmtempl.cpp
//
//--------------------------------------------------------------------------

// DMTempl.cpp : Implementation of CDMTempl

#include "DMTempl.h"
#include <comdef.h>
#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\iostru.h"
#include "debug.h"
#include "..\shared\Validate.h"

void TemplateStruct::AddIntro(TList<PlayChord>& PlayList, int nIntroLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<PlayChord> *pChord = PlayList.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            pChord->GetItemValue().m_nMeasure += (short)nIntroLength;
        }
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure >= nIntroLength || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nIntroLength;
            else if (rScan.m_Command.bGrooveLevel != 0 || rScan.m_Command.bCommand == DMUS_COMMANDT_END)
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nIntroLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        m_nMeasures += (short)nIntroLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddIntro(bool f1Bar, int nLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure > 0 || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nLength;
            else if ( !f1Bar &&
                        (rScan.m_Command.bGrooveLevel != 0 ||
                         rScan.m_Command.bCommand != DMUS_COMMANDT_GROOVE) )
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        if (!f1Bar) m_nMeasures += (short)nLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddEnd(int nLength)
{
    TListItem<TemplateCommand> *pCommand;
    TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (m_nMeasures - nLength == pScan->GetItemValue().m_nMeasure) break;
    }
    pCommand = (pScan) ? pScan : new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = m_nMeasures - nLength;
        if (!pScan || pScan->GetItemValue().m_nMeasure > 1) // otherwise keep the existing signpost
        {
            rCommand.m_dwChord = 0;
        }
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        if (!pScan) m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::FillInGrooveLevels()
{
    BYTE bLastGrooveLevel = 62;
    TListItem<TemplateCommand>* pCommands = m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGrooveLevel;
        }
        else
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
        }
    }
}


void TemplateStruct::IncorporateTemplate(
            short nMeasure, TemplateStruct* pTemplate, short nDirection)
{
    if (!pTemplate) return;
    TListItem<TemplateCommand>* pCommands = pTemplate->m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            m_CommandList.AddHead(pNew);
        }
    }
}

void TemplateStruct::InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand)
{
    TListItem<TemplateCommand> *pScan;

    if( !pCommand )
    {
        return;
    }
    pCommand->SetNext(NULL);
    TemplateCommand& rCommand = pCommand->GetItemValue();
    pScan = m_CommandList.GetHead();
    if (pScan)
    {
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure == rCommand.m_nMeasure)
            {
                if (fIsCommand)
                {
                    rScan.m_dwChord = 0;
                    rScan.m_Command.bCommand = rCommand.m_Command.bCommand;
                    rScan.m_Command.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                    rScan.m_Command.bGrooveRange = rCommand.m_Command.bGrooveRange;
                    rScan.m_Command.bRepeatMode = rCommand.m_Command.bRepeatMode;
                }
                else
                {
                    rScan.m_dwChord = rCommand.m_dwChord;
                    rScan.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                    rScan.m_Command.bGrooveLevel = 0;
                    rScan.m_Command.bGrooveRange = 0;
                    rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                }
                delete pCommand;
                return;
            }
            if (rScan.m_nMeasure > rCommand.m_nMeasure)
            {
                m_CommandList.InsertBefore(pScan, pCommand);
                break;
            }
        }
    }
    if (!pScan)
    {
        m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::AddCommand(int nMeasure, DWORD dwCommand)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = (short)nMeasure;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        switch (dwCommand)
        {
        case PF_FILL:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_INTRO:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_BREAK:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_END:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_A:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 12;
            break;
        case PF_B:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 37;
            break;
        case PF_C:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
            break;
        case PF_D:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 87;
            break;
        default:  // default to a Groove C
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
        }
        InsertCommand( pCommand, TRUE );
    }
}

void TemplateStruct::AddChord(int nMeasure, DWORD dwChord)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        pCommand->GetItemValue().m_nMeasure = (short)nMeasure;
        pCommand->GetItemValue().m_dwChord = dwChord;
        InsertCommand( pCommand, FALSE );
    }
}

int WeightedRand(int nRange)

/*  This randomly chooses a number within nrange.  However, it heavily
    weights in favor of the first index, which has twice the chance
    of the second index, which has twice the chance of the third...
*/

{
    int nTotal = 0;
    int index;
    unsigned int nGuess;
    if (nRange <= 0 || nRange > 15) return(0);     // out of range.
    for (index = 0;index < nRange; index++)
    {
        nTotal += (1 << index);
    }
    nGuess = rand() % nTotal;
    nGuess++;
    for (;nGuess;index--)
    {
        nGuess = nGuess >> 1;
    }
    return(index);
}

void TemplateStruct::CreateSignPosts()
{
    // First, figure out how many different sign posts we should use.
    // Should be the number of bits in measures minus two. Min is one.
    // For example, 8 measures gets us 2 sign posts.

    int nSPCount = -2;
    int nCopy = m_nMeasures;
    m_CommandList.RemoveAll();
    while (nCopy)
    {
        nSPCount++;
        nCopy = nCopy >> 1;
    }
    if (nSPCount < 1) nSPCount = 1;
    if (nSPCount > 7) nSPCount = 7;

    // Now, choose some signposts.  We choose from the following set:
    // 1, A, C, E, B, D, F. Randomly, but heavily weighted towards the start
    // of the set.

    static DWORD adwSource[7] = { DMUS_SIGNPOSTF_1, DMUS_SIGNPOSTF_A, DMUS_SIGNPOSTF_C, DMUS_SIGNPOSTF_E, DMUS_SIGNPOSTF_B, DMUS_SIGNPOSTF_D, DMUS_SIGNPOSTF_F };
    DWORD adwChoice[7];
    DWORD adwSign[7];
    int anLength[7];
    DWORD dwLastChord;

    int index;
    for (index = 0;index < 7;index++)
    {
        adwChoice[index] = adwSource[index];
        adwSign[index] = 0;
        if (rand() % 3) anLength[index] = 4;
        else anLength[index] = 2;
    }
    if (rand() % 2) anLength[0] = 4;
    for (index = 0;index < nSPCount;index++)
    {
        int nPosition;
        int nScan = 0;
        if (index) nPosition = WeightedRand(7 - index);
        else nPosition = WeightedRand(3);
        for (;nScan < 7;nScan++)
        {
            if (adwChoice[nScan])
            {
                if (!nPosition)
                {
                    adwSign[index] = adwChoice[nScan];
                    if (rand() % 2) adwSign[index] |= DMUS_SIGNPOSTF_CADENCE;
                    adwChoice[nScan] = 0;
                    break;
                }
                nPosition--;
            }
        }
    }
    AddChord(0,dwLastChord = adwSign[0]);
    int nLast = 0;
    for (index = 0;index < m_nMeasures;)
    {
        DWORD dwCadence = 0;
        DWORD dwChord;
        index += anLength[nLast];
        if (index >= (m_nMeasures - 1))
        {
            if (rand() % 3) AddChord(m_nMeasures - 1,DMUS_SIGNPOSTF_1 | dwCadence);
            else AddChord(m_nMeasures - 1,adwSign[0] | dwCadence);
            break;
        }
        dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        if (dwChord == dwLastChord)
        {
            dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        }
        AddChord(index,dwChord | dwCadence);
        dwLastChord = dwChord;
    }
}

static void GrooveRange(TemplateStruct *pTemplate,int nStartm,int nEndm,
            int nStartg,int nEndg,BOOL fRandom)

{
    static BYTE abGrooveLevels[4] = { 12, 37, 62, 87 };
    TListItem<TemplateCommand> *pCommand = pTemplate->m_CommandList.GetHead();
    TListItem<TemplateCommand> *pLast = NULL;
    int nRangem = nEndm - nStartm;
    int nRangeg = nEndg - nStartg;
    BYTE bLastGrooveLevel = 0;
    int nLastGroove = -1;
    int nLastMeasure = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE &&
            rCommand.m_Command.bGrooveLevel > 0)
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
            nLastMeasure = rCommand.m_nMeasure;
        }
        if (rCommand.m_nMeasure >= nStartm)
        {
            if (rCommand.m_nMeasure >= nEndm) break;
            int nGroove;
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            if (pNext)
            {
                nGroove = 
                    ((pNext->GetItemValue().m_nMeasure + rCommand.m_nMeasure ) >> 1) - nStartm;
            }
            else
            {
                nGroove = rCommand.m_nMeasure - nStartm;
            }
            if (fRandom)
            {
                nGroove = rand() % 3;
                nGroove += nLastGroove - 1;
                if (nGroove > 3) nGroove = 2;
                if (nGroove < 0) nGroove = 1;
            }
            else
            {
                nGroove *= nRangeg;
                nGroove += (nRangem >> 1);
                nGroove /= nRangem;
                nGroove += nStartg;
            }
            if ((nGroove >= 0) && (nGroove < 4))
            {
                if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                {
                    if (nLastGroove >= 0)
                    {
                        if (nLastGroove > nGroove) nGroove = nLastGroove - 1;
                        else if (nLastGroove < nGroove) nGroove = nLastGroove + 1;
                    }
                    rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                    rCommand.m_Command.bGrooveRange = 0;
                    bLastGrooveLevel = abGrooveLevels[nGroove];
                    nLastMeasure = rCommand.m_nMeasure;
                    nLastGroove = nGroove;
                }
                else if (rCommand.m_nMeasure > (nLastMeasure + 6))
                {
                    nGroove += ((rand() % 3) - 1);
                    if (nGroove < 0) nGroove += 2;
                    if (nGroove > 3) nGroove -= 2;
                    if (!nRangeg)
                    {
                        if ((nGroove < nLastGroove) && (nGroove <= nStartg))
                        {
                            if (rand() % 2) nGroove++;
                        }
                    }
                    if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                    {
                        rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                        rCommand.m_Command.bGrooveRange = 0;
                        bLastGrooveLevel = abGrooveLevels[nGroove];
                        nLastMeasure = rCommand.m_nMeasure;
                        nLastGroove = nGroove;
                    }
                }
            }
        }
    }
}

void TemplateStruct::CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength)
{
    // Put fills in. Scan forward through the list, placing fills
    // just prior to sign post changes.  Each time, move forward a
    // random count.
    TListItem<TemplateCommand> *pCommand;
    BYTE bLastGroove = 0;
    BOOL fAddMore = FALSE;
    int nStartg, nEndg;
    switch (shape)
    {
    case DMUS_SHAPET_FALLING:
        nStartg = 3;
        nEndg = 0;
        break;
    case DMUS_SHAPET_LEVEL:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOOPABLE:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOUD:
        nStartg = 3;
        nEndg = 3;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_QUIET:
        nStartg = 0;
        nEndg = 1;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_PEAKING:
        nStartg = 0;
        nEndg = 3;
        GrooveRange(this, 0, m_nMeasures >> 1, nStartg, nEndg, FALSE);
        nStartg = 3;
        nEndg = 0;
        GrooveRange(this, m_nMeasures >> 1, m_nMeasures - 1, nStartg, nEndg, FALSE);
        nStartg = 0;
        nEndg = 0;
        break;
    case DMUS_SHAPET_RANDOM:
        nStartg = 0;
        nEndg = 0;
        GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, TRUE);
        break;
    case DMUS_SHAPET_RISING:
        nStartg = 0;
        nEndg = 3;
        break;
    case DMUS_SHAPET_SONG:
    default:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    }
    if (nStartg || nEndg) GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, FALSE);
    pCommand = m_CommandList.GetHead();
    int nLastGrooveBar = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
        {
            BYTE bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            if (bGrooveLevel && (bGrooveLevel != bLastGroove))
            {
               if (rand() % 2)
                {
                    if ( (rCommand.m_nMeasure >= nFillLength) && 
                         (rCommand.m_nMeasure - nFillLength > nLastGrooveBar) && 
                         (bGrooveLevel > 50 || bLastGroove > 75) )
                    {
                        AddCommand(rCommand.m_nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if ((rCommand.m_nMeasure >= nBreakLength) && 
                            (rCommand.m_nMeasure - nBreakLength > nLastGrooveBar) &&
                            (rand() % 3) )
                        {
                            AddCommand(rCommand.m_nMeasure - nBreakLength, PF_BREAK);
                        }
                    }
                }
            }
            bLastGroove = bGrooveLevel;
            if (rCommand.m_Command.bGrooveLevel) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
    if (fAddMore)
    {
        int nLastMeasure = 0;
        nLastGrooveBar = 0;
        bLastGroove = 0;
        pCommand = m_CommandList.GetHead();
        for (; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            int nMeasure = rCommand.m_nMeasure;
            if (rCommand.m_Command.bCommand != DMUS_COMMANDT_GROOVE)
            {
                nLastMeasure = nMeasure;
                continue;
            }
            if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
            {
                bLastGroove = rCommand.m_Command.bGrooveLevel;
            }
            if ( (nLastMeasure + nFillLength + nBreakLength + 4) < nMeasure )
            {
                if ((rand() % 3) == 0)  // do something?
                {                // perhaps a fill?
                    nLastMeasure = nMeasure;
                    if ((bLastGroove > 50) && 
                        (nMeasure >= nFillLength) && 
                        (nMeasure - nFillLength > nLastGrooveBar) && 
                        (rand() % 2))
                    {
                        AddCommand(nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if (pNext)
                        {
                            while (nMeasure + nBreakLength <= pNext->GetItemValue().m_nMeasure )
                            {
                                AddCommand(nMeasure, PF_BREAK);
                                nMeasure += nBreakLength;
                                if (rand() % 2) break;
                            }
                        }
                    }
                }
            }
            if (bLastGroove) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDMTempl

CDMTempl::CDMTempl(  ) : m_cRef(1), m_pTemplateInfo(NULL), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CDMTempl::~CDMTempl()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CDMTempl::CleanUp()
{
    if( m_pTemplateInfo != NULL )
    {
        delete m_pTemplateInfo;
        m_pTemplateInfo = NULL;
    }
}

STDMETHODIMP CDMTempl::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMTempl::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDMTempl)
    {
        *ppv = static_cast<IDMTempl*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMTempl::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMTempl::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMTempl::SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rCommand.m_Command.bGrooveLevel || rCommand.m_Command.bCommand)
            {
                memset( &iCommand, 0, sizeof( iCommand ) );
                iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
                iCommand.wMeasure = rCommand.m_nMeasure;
                iCommand.bBeat = 0;
                iCommand.bCommand = rCommand.m_Command.bCommand;
                iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
                iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
                if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                    cb != sizeof( iCommand ) )
                {
                    break;
                }
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}

HRESULT CDMTempl::SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&   TimeSig )
{
    IStream*        pStream;
    MMCKINFO        ck;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_SIGNPOST    oSignPost;
    TListItem<TemplateCommand>* pCommand;
    ;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = ClocksPerMeasure(TimeSig) * rCommand.m_nMeasure;
            oSignPost.wMeasure = rCommand.m_nMeasure;
            oSignPost.dwChords = rCommand.m_dwChord;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pStream->Release();
    return hr;
}

HRESULT CDMTempl::Init(void* pTemplate)
{
    CleanUp();
    m_pTemplateInfo = (TemplateStruct*)pTemplate;
    // fix groove levels in the command list
//  m_pTemplateInfo->FillInGrooveLevels();
    return S_OK;
}

HRESULT CDMTempl::CreateSegment(IDirectMusicSegment* pISegment)
{
    if (!pISegment) return E_INVALIDARG;
    if (!m_pTemplateInfo) return E_FAIL;

    IDirectMusicTrack*  pICommandTrack          = NULL;
    IDirectMusicTrack*  pISignPostTrack         = NULL;
    IAARIFFStream*      pCommandRIFF            = NULL;
    IStream*            pICommandStream         = NULL;
    IPersistStream*     pICommandTrackStream    = NULL;
    IPersistStream*     pISignPostTrackStream   = NULL;
    IAARIFFStream*      pSignPostRIFF           = NULL;
    IStream*            pISignPostStream        = NULL;
    HRESULT             hr                      = S_OK;
    DMUS_TIMESIGNATURE  TimeSig;

    // Fill in the time sig event with default values (4/4, 16th note resolution)
    TimeSig.mtTime = 0;
    TimeSig.bBeatsPerMeasure = 4;
    TimeSig.bBeat = 4;
    TimeSig.wGridsPerBeat = 4;

    // 1. Create Command and Sign Post Tracks.
    hr = ::CoCreateInstance(
        CLSID_DirectMusicCommandTrack,
        NULL,
        CLSCTX_INPROC, 
        IID_IDirectMusicTrack,
        (void**)&pICommandTrack
        );
    if (FAILED(hr)) goto ON_END;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicSignPostTrack,
        NULL,
        CLSCTX_INPROC, 
        IID_IDirectMusicTrack,
        (void**)&pISignPostTrack
        );
    if (FAILED(hr)) goto ON_END;

    // 2. Write the template's command list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (!pCommandRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveCommandList(pCommandRIFF, TimeSig);

    // 3. Use the command list stream as input to the Command Track's Load method.
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if(FAILED(hr)) goto ON_END;

    // 4. Write the template's sign post list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pISignPostStream);
    if(S_OK != hr) goto ON_END;
    AllocRIFFStream( pISignPostStream, &pSignPostRIFF);
    if (!pSignPostRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveSignPostList(pSignPostRIFF, TimeSig);

    // 5. Use the chord list stream as input to the Sign Post Track's Load method.
    hr = pISignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pISignPostTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pISignPostStream, 0, STREAM_SEEK_SET);
    hr = pISignPostTrackStream->Load(pISignPostStream);
    if (FAILED(hr)) goto ON_END;

    // 6. Create a Segment has been removed it is now passed in

    // 7. Initialize the segment appropriately.
    //pISegment->SetUserData(m_pTemplateInfo->m_nMeasures);
    pISegment->SetLength(ClocksPerMeasure(TimeSig) * m_pTemplateInfo->m_nMeasures);

    // 8. Insert the two Tracks into the Segment's Track list.
    pISegment->InsertTrack(pICommandTrack, 1);
    pISegment->InsertTrack(pISignPostTrack, 1);
    // Note: the segment must release the track objects...

ON_END:
    if (pICommandTrack) pICommandTrack->Release();
    if (pISignPostTrack) pISignPostTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pISignPostTrackStream) pISignPostTrackStream->Release();
    if (pSignPostRIFF) pSignPostRIFF->Release();
    if (pISignPostStream) pISignPostStream->Release();

    return hr;
}

HRESULT CDMTempl::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DMTempl;
    return S_OK;
}

HRESULT CDMTempl::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

static TListItem<TemplateCommand>* loadacommand( LPSTREAM pStream, DWORD dwSize )
{
    CommandExt command;
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if( pCommand == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }
    TemplateCommand& rCommand = pCommand->GetItemValue();

    if( dwSize > sizeof(CommandExt) )
    {
        pStream->Read( &command, sizeof(CommandExt), NULL );
        FixBytes( FBT_COMMANDEXT, &command );
        StreamSeek( pStream, dwSize - sizeof(CommandExt), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &command, dwSize, NULL );
        FixBytes( FBT_COMMANDEXT, &command );
    }
    //rCommand.m_lTime = command->time;
    rCommand.m_nMeasure = command.measure;
    rCommand.m_Command.bGrooveRange = 0;
    rCommand.m_Command.bRepeatMode = 0;
    switch (command.command)
    {
    case PF_FILL:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_INTRO:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_BREAK:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_END:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_A:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 12;
        break;
    case PF_B:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 37;
        break;
    case PF_C:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 62;
        break;
    case PF_D:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 87;
        break;
    default:  // default to a Groove with level 0 (interpretation: use previous groove level)
        // This happens in the measure following an embellishment
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 0;
    }
    rCommand.m_dwChord = command.chord;

    return pCommand;
}

HRESULT CDMTempl::LoadTemplate( LPSTREAM pStream, DWORD dwSize )
{
    TListItem<TemplateCommand>*     pCommand;
    DWORD         id = 0;
    DWORD         tsize = 0;
    DWORD         segsize = 0;
    SCTtemplate* pTemplate;
    long lSize = dwSize;

    if ( pStream == NULL ) return E_INVALIDARG;
    pTemplate = new SCTtemplate;
    if( pTemplate == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }

    if (!GetMLong( pStream, tsize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete pTemplate;
        return E_FAIL;
    }

    lSize -= 4;
    if( tsize > sizeof(SCTtemplate) )
    {
        pStream->Read( pTemplate, sizeof(SCTtemplate), NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
        StreamSeek( pStream, tsize - sizeof(SCTtemplate), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( pTemplate, tsize, NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
    }
    lSize -= tsize;

    m_pTemplateInfo = new TemplateStruct;
    if (!m_pTemplateInfo)
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    m_pTemplateInfo->m_strName = pTemplate->achName;
    m_pTemplateInfo->m_strType = pTemplate->achType;
    m_pTemplateInfo->m_nMeasures = pTemplate->nMeasures;
    delete pTemplate;
    while( lSize > 0 )
    {
        pStream->Read( &id, 4, NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;
        switch( id )
        {
        case mmioFOURCC( 'D', 'M', 'C', 's' ):
            pCommand = loadacommand( pStream, segsize );
            if( pCommand )
            {
                m_pTemplateInfo->m_CommandList.AddTail(pCommand);
            }
            break;

        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    // fix groove levels in the command list
    BYTE bLastGroove = 62; 
    pCommand = m_pTemplateInfo->m_CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGroove;
        }
        else bLastGroove = rCommand.m_Command.bGrooveLevel;
    }
    return S_OK;
}

// This loads a *single* template.  I also need to handle files that contain
// *lists* of templates (but I can just load the first one in the list)
HRESULT CDMTempl::Load( LPSTREAM pStream )
{
    FOURCC id;
    DWORD dwSize;
    HRESULT hr;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    CleanUp();
    if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        hr = E_FAIL;
        goto end;
    }
    if( id != mmioFOURCC( 'L', 'P', 'T', 's' ) )
    {
        hr = E_FAIL;
        goto end;
    }
    hr = LoadTemplate( pStream, dwSize );
end:
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMTempl::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CDMTempl::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\oledll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.cpp
//
//--------------------------------------------------------------------------

// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\opnew.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       opnew.cpp
//
//--------------------------------------------------------------------------

// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\oledll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.h
//
//--------------------------------------------------------------------------

//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\perstrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// PersTrk.cpp : Implementation of CPersonalityTrack
#include "DMPers.h"
#include "PersTrk.h"
#include "dmusicc.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack


CPersonalityTrack::CPersonalityTrack() : 
    m_bRequiresSave(0), 
    m_cRef(1),
    m_fCSInitialized(FALSE)

{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CPersonalityTrack::CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0),
    m_cRef(1),
    m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    TListItem<StampedPersonality>* pScan = rTrack.m_PersonalityList.GetHead();
    TListItem<StampedPersonality>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        StampedPersonality& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
            if (pNew)
            {
                StampedPersonality& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_pPersonality = rScan.m_pPersonality;
                if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
                m_PersonalityList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (pNew)
        {
            StampedPersonality& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_pPersonality = pPrevious->GetItemValue().m_pPersonality;
            if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
            m_PersonalityList.AddHead(pNew);
        }
    }
}

CPersonalityTrack::~CPersonalityTrack()
{
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CPersonalityTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CPersonalityTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPersonalityTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPersonalityTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CPersonalityTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{ 
    return S_OK;
}

HRESULT CPersonalityTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CPersonalityTrack::GetParam(
                REFGUID                     rCommandGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    V_INAME(CPersonalityTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        Trace(1, "ERROR: GetParam (chord map track): pParam is NULL.\n");
        return E_POINTER;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (rCommandGuid == GUID_IDirectMusicChordMap)
    {
        TListItem<StampedPersonality>* pScan = m_PersonalityList.GetHead();
        if (pScan)
        {
            IDirectMusicChordMap* pPersonality = pScan->GetItemValue().m_pPersonality;
            for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                StampedPersonality& rScan = pScan->GetItemValue();
                if (mtTime < rScan.m_mtTime  && rScan.m_pPersonality) break;  // ignore if NULL
                if (rScan.m_pPersonality) pPersonality = rScan.m_pPersonality; // skip if NULL
            }
            if (pPersonality)
            {
                pPersonality->AddRef();
                *(IDirectMusicChordMap**)pData = pPersonality;
                if (pmtNext)
                {
                    *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime - mtTime : 0;
                }
                hr = S_OK;
            }
            else
            {
                Trace(1, "ERROR: GetParam (chord map track): Chord map list item is empty.\n");
                hr = E_POINTER;
            }

        }
        else
        {
            Trace(1, "ERROR: GetParam (chord map track): Chord map track is empty.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1, "ERROR: GetParam (chord map track): Attempt to get an unsupported parameter.\n");
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
} 

HRESULT CPersonalityTrack::SetParam( 
    REFGUID                     rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CPersonalityTrack::SetParam);
    V_REFGUID(rCommandGuid);

    HRESULT hr;
    if (!pData)
    {
        Trace(1, "ERROR: SetParam (chord map track): pParam is NULL.\n");
        return E_POINTER;
    }

    EnterCriticalSection( &m_CriticalSection );
    if (rCommandGuid == GUID_IDirectMusicChordMap)
    {
        IDirectMusicChordMap* pPers = (IDirectMusicChordMap*)pData;
        TListItem<StampedPersonality>* pPersItem = m_PersonalityList.GetHead();
        TListItem<StampedPersonality>* pPrevious = NULL;
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            pNew->GetItemValue().m_mtTime = mtTime;
            pNew->GetItemValue().m_pPersonality = pPers;
            if (pPers) pPers->AddRef();
            for(; pPersItem != NULL; pPersItem = pPersItem->GetNext())
            {
                if (pPersItem->GetItemValue().m_mtTime >= mtTime) break;
                pPrevious = pPersItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pPersItem);
            }
            else // pPersItem is current head of list
            {
                m_PersonalityList.AddHead(pNew);
            }
            if (pPersItem && pPersItem->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                if (pPersItem->GetItemValue().m_pPersonality)
                {
                    pPersItem->GetItemValue().m_pPersonality->Release();
                }
                pPersItem->GetItemValue().m_pPersonality = NULL;
                pNew->SetNext(pPersItem->GetNext());
                pPersItem->SetNext(NULL);
                delete pPersItem;
            }
            hr = S_OK;
        }
    }
    else
    {
        Trace(1, "ERROR: SetParam (chord map track): Attempt to set an unsupported parameter.\n");
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CPersonalityTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CPersonalityTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicChordMapTrack;
    return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CPersonalityTrack::GetName(
                /*[out]*/  BSTR*        pbstrName
            )
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    V_INAME(CPersonalityTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_IDirectMusicChordMap)
        return S_OK;
    else 
    {
        Trace(2, "WARNING: IsParamSupported (chord map track): The parameter is not supported.\n");
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

// IPersistStream methods
 HRESULT CPersonalityTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CPersonalityTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(StampedPersonality& SP1, StampedPersonality& SP2)
{ return SP1.m_mtTime < SP2.m_mtTime; }

HRESULT CPersonalityTrack::Load(LPSTREAM pStream )
{
    V_INAME(CPersonalityTrack::Load);
    V_INTERFACE(pStream);

    IAARIFFStream*  pIRiffStream;
    //MMCKINFO      ckMain;
    MMCKINFO        ck;
    HRESULT         hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    if (m_PersonalityList.GetHead())
    {
        delete m_PersonalityList.GetHead();
        m_PersonalityList.RemoveAll();
    }

    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        if (pIRiffStream->Descend( &ck, NULL, 0 ) == 0)
        {
            if (ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_TRACK_LIST)
            {
                hr = LoadPersRefList(pIRiffStream, &ck);
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Release();
    }
    m_PersonalityList.MergeSort(Less);

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CPersonalityTrack::LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;

    while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
    {
        if ( ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_REF_LIST )
        {
            hr = LoadPersRef(pIRiffStream, &ck);
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Ascend( &ck, 0 );
    }

    return hr;
}

HRESULT CPersonalityTrack::LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    IDirectMusicChordMap* pPersonality = NULL;
    TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
    if (!pNew) return E_OUTOFMEMORY;
    StampedPersonality& rNew = pNew->GetItemValue();
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case DMUS_FOURCC_TIME_STAMP_CHUNK:
            {
                DWORD dwTime;
                DWORD cb;
                hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
                if (FAILED(hr) || cb != sizeof( dwTime ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rNew.m_mtTime = dwTime;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                hr = LoadReference(pIStream, pIRiffStream, ck, &pPersonality);
                if (SUCCEEDED(hr))
                {
                    rNew.m_pPersonality = pPersonality;
                }
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    if (SUCCEEDED(hr))
    {
        m_PersonalityList.AddTail(pNew);
    }
    else
    {
        delete pNew;
    }
ON_END:
    pIStream->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPersonalityTrack::LoadReference

HRESULT CPersonalityTrack::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         IDirectMusicChordMap** ppPersonality)
{
    if (!pStream || !pIRiffStream || !ppPersonality) return E_INVALIDARG;

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;  
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;
    
    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;
        
    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    
        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDirectMusicChordMap, (void**)ppPersonality);
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CPersonalityTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1, "ERROR: Clone (chord map track): Invalid  start time.\n");
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1, "ERROR: Clone (chord map track): Invalid  end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );

    CPersonalityTrack *pDM;
    
    try
    {
        pDM = new CPersonalityTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CPersonalityTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersonalityTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CPersonalityTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CPersonalityTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup) 
{
    HRESULT hr = S_OK;
    CPersonalityTrack* pOtherTrack = (CPersonalityTrack*)pNewTrack;
    TListItem<StampedPersonality>* pScan = pOtherTrack->m_PersonalityList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        StampedPersonality& rScan = pScan->GetItemValue();
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (pNew)
        {
            StampedPersonality& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_pPersonality = rScan.m_pPersonality;
            if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
            m_PersonalityList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\sjpers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjpers.h
//
//--------------------------------------------------------------------------

// SJPers.h  #defines and structs from SuperJam!  Used for loading personalities.

#define CM_DEFAULT  2               // Prsonality.dwflags & CM_DEFAULT

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

#pragma pack(1)

typedef struct ChordExt    FAR *LPCHORDEXT;
struct ChordExt   // Based on ChordSelection
{
    LPCHORDEXT pNext;
    long       time;
    long       pattern;      // Pattern that defines chord
    char       name[12];     // Text for display
    char       keydown;      // Currently held down
    char       root;         // Root note of chord
    char       inscale;      // Member of scale
    char       flat;         // Display with flat
    short      varflags;     // Used to select appropriate variation
    short      measure;      // What measure
    char       beat;         // What beat this falls on
    unsigned   char bits;    // Invert and item count
    long       scalepattern; // Scale Pattern for the chord
    long       melodypattern;// Melody Pattern for the chord
};

typedef struct SinePost    FAR *LPSINEPOST ;
struct SinePost
{
    LPSINEPOST      pNext ;          // The next personality in the list.
    ChordExt        chord;          // Chord for sign post.
    ChordExt        cadence[2];     // Chords for cadence.
    DWORD           chords;         // Which kinds of signpost supported.
    DWORD           flags;
    DWORD           tempflags;
};

typedef struct ChrdEntry   FAR *LPCHRDENTRY ;

typedef struct NextChrd    FAR *LPNEXTCHRD ;
struct NextChrd
{
    LPNEXTCHRD      pNext;           // List of chords to go to next.
    LPCHRDENTRY     nextchord;
    unsigned long   dwflags;
    short           nweight;        // Importance of destination chord.
    short           nminbeats;      // Min beats to wait till chord.
    short           nmaxbeats;      // Max beats to wait till chord.
    short           nid;            // ID of destination chord.
};

#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

struct ChrdEntry
{
    LPCHRDENTRY     pNext ;          // The next personality in the list.
    LPNEXTCHRD      nextchordlist;  // List of chords to go to next.
    ChordExt        chord;          // Chord definition.
    unsigned long   dwflags;        // Various flags.
    short           nid;            // ID for pointer maintenance.
};

typedef struct SCTchord     FAR *LPSCTCHORD ;
struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
};

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
};

typedef struct Prsonality    FAR *LPPERSONALITY ;
struct Prsonality
{
    LPPERSONALITY   pNext ;          // The next personality in the list.
    LPCHRDENTRY     chordlist;      // All chords in the map.
    LPSINEPOST      signpostlist;   // All available sign posts.
    DWORD           dwAA;           // only valid for separately loaded personalities
    long            scalepattern;   // Scale for map.
    char            name[20];
    char            description[80];
    char            username[20];
    SCTchord        chord[24];
    unsigned long   dwflags;
    long            playlist;       // Collection of NextChords for playback.
    LPCHRDENTRY     firstchord;
    struct SCTpersonality* lpSCTpersonality;
};

typedef struct CommandExt    FAR *LPCOMMAND;
typedef struct CommandExt
{
    LPCOMMAND   pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    // The next command in the list.
    long          lDLL1 ;     //   Reserved for use by score.dll.
    short         nMeasure ;  // Measure this command occurs. 
    DWORD         dwCommand ; // Command type. 
    DWORD         dwChord ;   // Signpost chord.
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           // The next template in the list.
    char          achName[20] ;      // Template name.
    char          achType[20] ;      // Template type.
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; // Template commands. 
} SCTtemplate ;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmcompos

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=dmcompod
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmcompos.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /W3 /WX

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\user32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib

INCLUDES=$(INCLUDES);   \
    ..\..\shared

SOURCES=\
..\debug.cpp           \
..\dmcmpdll.cpp            \
..\dmcompos.cpp            \
..\dmpers.cpp          \
..\dmtempl.cpp         \
..\fileio.cpp          \
..\oledll.cpp          \
..\spsttrk.cpp         \
..\str.cpp             \
..\perstrk.cpp             \
..\dmcompos.rc         \
..\opnew.cpp           \
..\dmcomp2.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\perstrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.h
//
//--------------------------------------------------------------------------

// PersTrk.h : Declaration of the CPersonalityTrack

#ifndef __PERSONALITYTRACK_H_
#define __PERSONALITYTRACK_H_

#include "dmusici.h"
#include "DMCompos.h"

struct StampedPersonality
{
	StampedPersonality() { m_pPersonality = NULL; }
	~StampedPersonality() { if (m_pPersonality) m_pPersonality->Release(); }
	MUSIC_TIME				m_mtTime;
	IDirectMusicChordMap*	m_pPersonality;
};

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack
class CPersonalityTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CPersonalityTrack();
	CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CPersonalityTrack();
	HRESULT LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  IDirectMusicChordMap** ppPersonality);

public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
/*
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);
*/

    HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

// attributes
    long m_cRef;
	TList<StampedPersonality>	m_PersonalityList;
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;
//  BOOL                        m_fNotifyRecompose;

	BYTE						m_bRequiresSave;
};

#endif //__PERSONALITYTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\spsttrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.h
//
//--------------------------------------------------------------------------

// SPstTrk.h : Declaration of the CSPstTrk

#ifndef __SPSTTRK_H_
#define __SPSTTRK_H_

#include "dmusici.h"
#include "DMCompos.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk
class CSPstTrk : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSPstTrk();
	CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSPstTrk();

// ISPstTrk
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// ICommandTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);

	void Clear();

// attributes
    long m_cRef;
	TList<DMSignPostStruct>		m_SignPostList;
    CRITICAL_SECTION			m_CriticalSection; // for load and SetParam
    BOOL                        m_fCSInitialized;
	IDirectMusicPerformance*	m_pPerformance; // is this necessary?
	CDMCompos*					m_pComposer; // for Segment Recompose on loop
//	IDirectMusicSegment*		m_pSegment;
    BOOL                        m_fNotifyRecompose;

	BYTE						m_bRequiresSave;
};

#endif //__SPSTTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\spsttrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SPstTrk.cpp : Implementation of CSPstTrk
#include "SPstTrk.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk


CSPstTrk::CSPstTrk() : 
    m_bRequiresSave(0), m_pPerformance(NULL),
    m_pComposer(NULL),
    m_fNotifyRecompose(FALSE),
//  m_pSegment(NULL),
    m_cRef(1),
    m_fCSInitialized(FALSE)

{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// This assumes cloning on measure boundaries
CSPstTrk::CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_pPerformance(NULL),
    m_pComposer(NULL),
    m_fNotifyRecompose(FALSE),
    //m_pSegment(NULL),
    m_cRef(1),
    m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    BOOL fStarted = FALSE;
    WORD wMeasure = 0;
    TListItem<DMSignPostStruct>* pScan = rTrack.m_SignPostList.GetHead();
    TListItem<DMSignPostStruct>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMSignPostStruct& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
            if (pNew)
            {
                DMSignPostStruct& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_dwChords = rScan.m_dwChords;
                m_SignPostList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
        if (pNew)
        {
            DMSignPostStruct& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_dwChords = pPrevious->GetItemValue().m_dwChords;
            m_SignPostList.AddHead(pNew);
        }
    }
}

CSPstTrk::~CSPstTrk()
{
    if (m_pComposer)
    {
        delete m_pComposer;
    }
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CSPstTrk::Clear()
{
    m_SignPostList.CleanUp();
}


STDMETHODIMP CSPstTrk::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CSPstTrk::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSPstTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CSPstTrk::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CSPstTrk::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK; // if I return an error, dmime gives me an assertion failure
}

HRESULT CSPstTrk::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    EnterCriticalSection(&m_CriticalSection);
    // get rid of any existing composer object
    if (m_pComposer)
    {
        delete m_pComposer;
        m_pComposer = NULL;
    }

    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr = pSegmentState->GetSegment(&pSegment);
    if (SUCCEEDED(hr))
    {
        m_pComposer = new CDMCompos;
        if(!m_pComposer) 
        {
            hr = E_OUTOFMEMORY;
        }
        pSegment->Release();
    }
    else
    {
        Trace(2, "WARNING: InitPlay (Signpost Track): Segment State does not contain a segment.\n");
        hr = S_OK; // Let it succeed anyway.  Just means we can't compose on the fly.
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSPstTrk::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    EnterCriticalSection(&m_CriticalSection);
    // get rid of any existing composer object
    if (m_pComposer)
    {
        delete m_pComposer;
        m_pComposer = NULL;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSPstTrk::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? true : false;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? true : false;
    bool fCompose = (dwFlags & DMUS_TRACKF_RECOMPOSE) ? true : false;
    bool fPlayOff = (dwFlags & DMUS_TRACKF_PLAY_OFF) ? true : false;
    EnterCriticalSection(&m_CriticalSection);
    if ( fStart || fLoop ) 
    {
        if ( fCompose && !fPlayOff )
        {
            IDirectMusicSegment* pSegment = NULL;
            if (SUCCEEDED(pSegState->GetSegment(&pSegment)))
            {
                // call ComposeSegmentFromTemplateEx on this segment
                if (m_pComposer)
                {
                    // Should an activity level be allowed if desired?
                    // This could be handled via a SetParam.
                    m_pComposer->ComposeSegmentFromTemplateEx(
                        NULL,
                        pSegment,
                        0,      // ignore activity level, don't clone
                        0,      // for activity level
                        NULL,
                        NULL
                    );
                    // if we recomposed, send a recompose notification
                    SendNotification(mtStart + mtOffset, pPerf, pSegment, pSegState, dwFlags);
                }
                pSegment->Release();
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSPstTrk::SendNotification(MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegment* pSegment,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (!m_fNotifyRecompose || (dwFlags & DMUS_TRACKF_NOTIFY_OFF))
    {
        return S_OK;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_RECOMPOSE;
        pEvent->guidNotificationType = GUID_NOTIFICATION_RECOMPOSE;

        if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
        {
            pEvent->dwGroupID = 0xffffffff;
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CSPstTrk::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CSPstTrk::GetParam(
                REFGUID                     rCommandGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    return E_NOTIMPL;
} 

HRESULT CSPstTrk::SetParam( 
    REFGUID                     rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    return E_NOTIMPL;
}

// IPersist methods
 HRESULT CSPstTrk::GetClassID( LPCLSID pClassID )
{
    V_INAME(CSPstTrk::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicSignPostTrack;
    return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CSPstTrk::GetName(
                /*[out]*/  BSTR*        pbstrName
            )
{
    return E_NOTIMPL;
}

HRESULT CSPstTrk::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    return E_NOTIMPL;
}

// IPersistStream methods
 HRESULT CSPstTrk::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CSPstTrk::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CSPstTrk::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO        ck;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_SIGNPOST    oSignPost;
    TListItem<DMSignPostStruct>* pSignPost;

    EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if ( FAILED( hr ) )
    {
        goto ON_END;
    }
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pSignPost = m_SignPostList.GetHead(); pSignPost != NULL ; pSignPost = pSignPost->GetNext() )
        {
            DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = rSignPost.m_mtTime;
            oSignPost.wMeasure = rSignPost.m_wMeasure;
            oSignPost.dwChords = rSignPost.m_dwChords;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pSignPost == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CSPstTrk::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(DMSignPostStruct& SP1, DMSignPostStruct& SP2)
{ return SP1.m_wMeasure < SP2.m_wMeasure; }

HRESULT CSPstTrk::Load(LPSTREAM pStream )
{
    V_INAME(CSPstTrk::Load);
    V_INTERFACE(pStream);

    HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF;

    EnterCriticalSection( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    DMUS_IO_SIGNPOST        iSignPost;

    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
    {
        lFileSize = (long) ck.cksize;
        hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMSignPostStruct>* pSignPost;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    //TraceI(0, "File size: %d\n", lFileSize);
                    pSignPost = new TListItem<DMSignPostStruct>;
                    if( pSignPost )
                    {
                        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
                        if( dwNodeSize <= sizeof( iSignPost ) )
                        {
                            pStream->Read( &iSignPost, dwNodeSize, NULL );
                        }
                        else
                        {
                            pStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
                            DWORD dw = (lFileSize >= sizeof( iSignPost ) ) ? lFileSize - sizeof( iSignPost ) : 0;
                            StreamSeek( pStream, dw, STREAM_SEEK_CUR );
                        }
                        memset( &rSignPost, 0, sizeof( rSignPost ) );
                        rSignPost.m_mtTime = iSignPost.mtTime;
                        rSignPost.m_wMeasure = iSignPost.wMeasure;
                        rSignPost.m_dwChords = iSignPost.dwChords;
                        m_SignPostList.AddTail(pSignPost);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
            m_SignPostList.MergeSort(Less);
        }
        pRIFF->Release();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CSPstTrk::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = TRUE;
        return S_OK;
    }
    else
    {
        Trace(2, "WARNING: AddNotificationType (signpost track): Notification type not supported.\n");
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CSPstTrk::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = FALSE;
        return S_OK;
    }
    else
    {
        Trace(2, "WARNING: RemoveNotificationType (signpost track): Notification type not supported.\n");
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CSPstTrk::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CSPstTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1, "ERROR: Clone (signpost map): Invalid  start time.\n");
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1, "ERROR: Clone (signpost map): Invalid  end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    
    CSPstTrk *pDM;
    
    try
    {
        pDM = new CSPstTrk(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CSPstTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSPstTrk::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Compose)

    V_INTERFACE(pContext);
    V_PTRPTR_WRITE(ppResultTrack);

    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = S_OK;
    IDirectMusicTrack* pChordTrack = NULL;
    IDirectMusicTrack8* pCommandTrack = NULL;
    IDirectMusicStyle* pStyle = NULL;
    IDirectMusicTrack8* pChordMapTrack = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    CDMCompos* pComposer = NULL;

    MUSIC_TIME mtLength = 0;

    IDirectMusicSegment* pTempSeg = NULL;
    IDirectMusicSong* pSong = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pTempSeg)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            Trace(1, "ERROR: Compose (signpost track): Missing segment or song.\n");
            hr = E_INVALIDARG;
            goto ON_END;
        }
    }

    if (pTempSeg)
    {
        if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
        {
            if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
            {
                goto ON_END;
            }
        }
        hr = pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pChordMapTrack);
        if (FAILED(hr)) goto ON_END;
        if (FAILED(hr = pTempSeg->GetLength(&mtLength))) goto ON_END;
        hr = pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pCommandTrack);
        if (FAILED(hr)) goto ON_END;
    }
    else if (pSong)
    {
        MUSIC_TIME mtNow = 0;
        MUSIC_TIME mtNext = 0;
        while (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, mtNow, &mtNext, (void*)&pStyle)))
        {
            if (SUCCEEDED(hr = pSong->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, mtNow, NULL, (void*)&pStyle)))
            {
                break;
            }
            if (mtNext <= 0) goto ON_END;
            mtNow = mtNext;
        }
        IDirectMusicSegment* pSeg = NULL;
        DWORD dwSeg = 0;
        while (S_OK == hr)
        {
            if (FAILED(hr = pSong->EnumSegment(dwSeg, &pSeg))) goto ON_END;
            if (hr == S_OK)
            {
                HRESULT hrCommand = S_OK;
                HRESULT hrChordMap = S_OK;
                MUSIC_TIME mt = 0;
                hr = pSeg->GetLength(&mt);
                if (FAILED(hr))
                {
                    pSeg->Release();
                    goto ON_END;
                }

                IDirectMusicTrack8* pSegTrack = NULL;
                IDirectMusicTrack8* pSegTrack2 = NULL;
                hrCommand = pSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack);
                hrChordMap = pSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack2);
                pSeg->Release();
                pSeg = NULL;
                if (SUCCEEDED(hrCommand))
                {
                    if (!pCommandTrack)
                    {
                        hr = pSegTrack->Clone(0, 0, (IDirectMusicTrack**)&pCommandTrack);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = pCommandTrack->Join(pSegTrack, mtLength, pSong, dwTrackGroup, NULL);
                    }
                    pSegTrack->Release();
                }
                if (SUCCEEDED(hrChordMap))
                {
                    if (!pChordMapTrack)
                    {
                        hr = pSegTrack2->Clone(0, 0, (IDirectMusicTrack**)&pChordMapTrack);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = pChordMapTrack->Join(pSegTrack2, mtLength, pSong, dwTrackGroup, NULL);
                    }
                    pSegTrack2->Release();
                }
                if (FAILED(hr))  goto ON_END;
                mtLength += mt;
                dwSeg++;
            }
        }
    }

    pComposer = new CDMCompos;
    if(!pComposer) 
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        TList<PlayChord> PlayList;
        BYTE bRoot = 0; 
        DWORD dwScale;
        hr = pComposer->ComposePlayListFromTemplate(
            pStyle, NULL, pChordMapTrack, (IDirectMusicTrack*)this, pCommandTrack, dwTrackGroup,
            mtLength, false, 0, PlayList, bRoot, dwScale);
        // create a new chord track
        DMUS_TIMESIGNATURE      TimeSig;
        // Fill in the time sig event with default values (4/4, 16th note resolution)
        TimeSig.mtTime = 0;
        TimeSig.bBeatsPerMeasure = 4;
        TimeSig.bBeat = 4;
        TimeSig.wGridsPerBeat = 4;
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC, 
            IID_IDirectMusicTrack,
            (void**)&pChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        pComposer->SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        *ppResultTrack = pChordTrack;
    }

ON_END:
    if (pComposer) pComposer->CleanUp();
    if (pStyle) pStyle->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pCommandTrack) pCommandTrack->Release();
    if (pChordMapTrack) pChordMapTrack->Release();
    if (pComposer) delete pComposer;
    if (pSong) pSong->Release();
    if (pTempSeg) pTempSeg->Release();

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSPstTrk::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    TList<DMSignPostStruct> ResultList;
    CSPstTrk* pResultTrack = NULL;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CSPstTrk*)*ppResultTrack;
        while(!pResultTrack->m_SignPostList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_SignPostList.RemoveHead());
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_SignPostList.IsEmpty() && 
              m_SignPostList.GetHead()->GetItemValue().m_mtTime < mtJoin)
        {
            ResultList.AddHead(m_SignPostList.RemoveHead());
        }
        m_SignPostList.CleanUp();
    }
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            WORD wMeasureOffset = ClocksToMeasure(mtNext + mtOver, TimeSig);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CSPstTrk* pOtherTrack = (CSPstTrk*)pNewTrack;
    TListItem<DMSignPostStruct>* pScan = pOtherTrack->m_SignPostList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>(pScan->GetItemValue());
        if (pNew)
        {
            pNew->GetItemValue().m_mtTime += mtJoin;
            pNew->GetItemValue().m_wMeasure += wMeasure;
            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_SignPostList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_SignPostList.AddHead(ResultList.RemoveHead());
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\templats.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       templats.h
//
//--------------------------------------------------------------------------

// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       str.cpp
//
//--------------------------------------------------------------------------

//
// string.cpp

#include "str.h"

WORD String::sm_wBlockSize = 16;

String::String()
{
	m_wAllocated = 0;
    m_pBuf = NULL;
    m_wLength = 0;
}

String::String( const String& str )
{
    m_wLength = str.m_wLength;
	if (m_wLength == 0)
	{
		m_wAllocated = 0;
		m_pBuf = NULL;
	}
	else
	{
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];
		if( m_pBuf != NULL )
		{
			wcscpy( m_pBuf, str.m_pBuf );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
	}
}

String::String( LPCSTR pszStr )
{
    if( pszStr != NULL && pszStr[0] != '\0' )
    {
        m_wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::String( LPCWSTR pszWstr )
{
    if( pszWstr != NULL && pszWstr[0] != L'\0')
    {
        m_wLength = static_cast<WORD>( wcslen(pszWstr) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			wcscpy(m_pBuf, pszWstr);
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::~String()
{
    if (m_pBuf) delete[] m_pBuf;
}

String& String::operator=( const String& str )
{
    WORD wBlockSize;

    if( m_pBuf != str.m_pBuf )
    {
		if (!str.m_pBuf)
		{
            if (m_pBuf)
			{
				m_pBuf[0] = L'\0';
			}
            m_wLength = 0;
		}
		else
		{
			wBlockSize = figureblocksize( str.m_wLength );
			if( wBlockSize <= m_wAllocated )
			{
				m_wLength = str.m_wLength;
				wcscpy( m_pBuf, str.m_pBuf );
			}
			else
			{
				if (m_pBuf) delete [] m_pBuf;
				m_wLength = str.m_wLength;
				m_wAllocated = wBlockSize;
				m_pBuf = new WCHAR[m_wAllocated];
				if( m_pBuf != NULL )
				{
					wcscpy( m_pBuf, str.m_pBuf );
				}
				else
				{
					m_wLength = 0;
					m_wAllocated = 0;
				}
			}
		}
    }
    return *this;
}

String& String::operator=( LPCSTR pszStr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszStr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

String& String::operator=( LPCWSTR pszWstr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszWstr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( wcslen( pszWstr ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        wcscpy(m_pBuf, pszWstr);
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy(m_pBuf, pszWstr);
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

/*
#ifndef _MAC
BOOL String::LoadString( UINT nID, HINSTANCE hInstance )
{
    char szBuf[256];    // this is safe since resource strings
                        // are limited to 255 characters

    if( ::LoadString( hInstance, nID, szBuf, sizeof( szBuf ) ) == 0 )
    {
        return FALSE;
    }
    delete[] m_pBuf;
    m_wLength = static_cast<WORD>( ::lstrlen( szBuf ) );
    m_wAllocated = figureblocksize( m_wLength );
    m_pBuf = new WCHAR[m_wAllocated];
    if( m_pBuf == NULL )
    {
        m_wLength = 0;
        return FALSE;
    }
    ::lstrcpy( m_pBuf, szBuf );
    m_pBuf[m_wLength] = '\0';
    return TRUE;
}
#endif
*/

void String::TrimTrailingSpaces()
{
    while( m_wLength > 0 && m_pBuf[m_wLength - 1] == ' ' )
    {
        m_pBuf[m_wLength - 1] = '\0';
        --m_wLength;
    }
}

void String::Concat( const String& str )
{
    if( ( str.m_wLength + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        wcscat( m_pBuf, str.m_pBuf );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, str.m_pBuf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( LPCWSTR lpwzStr )
{
    int len;

    len = wcslen( lpwzStr );
    if( ( len + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + len );
        wcscat( m_pBuf, lpwzStr );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + len );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, lpwzStr );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( WCHAR wch )
{
    WCHAR buf[2];

    buf[0] = wch;
    buf[1] = '\0';
    if( ( 1 + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength += 1;
        wcscat( m_pBuf, buf );
    }
    else
    {
        WCHAR* p;

        m_wLength += 1;
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, buf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

HRESULT String::ReadWCS( LPSTREAM pStream, DWORD cSize )
{
	HRESULT		hr = S_OK;
	WCHAR*		wstrText = NULL;
	DWORD		cb;
    WORD        wBlockSize;

    wstrText = new WCHAR[cSize / sizeof( WCHAR )];
	if( NULL == wstrText )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}
    hr = pStream->Read( reinterpret_cast<LPWSTR>( wstrText ), cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
	{
        hr = E_FAIL;
        goto ON_ERR;
	}

	cSize = wcslen(wstrText);
	if (cSize == 0)
	{
        if (m_pBuf)
		{
			m_pBuf[0] = L'\0';
		}
        m_wLength = 0;
		goto ON_ERR;
	}
    wBlockSize = figureblocksize( static_cast<WORD>( cSize ) );
    m_wLength = static_cast<WORD>( cSize );
    if( wBlockSize <= m_wAllocated )
    {
        wcscpy( m_pBuf, wstrText );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy( m_pBuf, wstrText );
        }
        else
        {
            hr = E_OUTOFMEMORY;
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }

ON_ERR:
    if( wstrText != NULL )
    {
		delete [] wstrText;
    }
    return hr;
}

/*
HRESULT String::WriteWCS( LPSTREAM pStream )
{
    HRESULT     hr;
    wchar_t*    wstrText;
	DWORD		cb;
    DWORD       cSize;

    cSize = MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, NULL, 0 );  // get number of wide characters required

	wstrText = new wchar_t[cSize];
    if( wstrText == NULL )
	{
		hr = E_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, wstrText, cSize );
        hr = pStream->Write( reinterpret_cast<LPSTR>( wstrText ), cSize * sizeof( wchar_t ), &cb );
        if( FAILED( hr ) || cb != ( cSize * sizeof( wchar_t ) ) )
        {
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
        delete [] wstrText;
    }

    return hr;
}
*/

String operator+( const String& str1, const String& str2 )
{
    String str;

    str = str1;
    str.Concat( str2 );
    return str;
}

String operator+( const String& str1, LPCSTR lpszStr )
{
    String str;

    str = str1;
    str.Concat( lpszStr );
    return str;
}

String operator+( LPCSTR lpszStr, const String& str1 )
{
    String str;

    str = lpszStr;
    str.Concat( str1 );
    return str;
}

String operator+( const String& str1, char ch )
{
    String str;

    str = str1;
    str.Concat( ch );
    return str;
}

String operator+( char ch, const String& str1 )
{
    String str;

    str.Concat( ch );
    str.Concat( str1 );
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\audpath.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// audpath.cpp : Implementation of CAudioPath

#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmsegobj.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "audpath.h"
#include "debug.h"
#include "..\shared\dmusiccp.h"


#define ASSERT  assert

CBufferNode::CBufferNode()

{
    m_lActivateCount = 0;
    m_cRef = 1;
    m_pBuffer = NULL;
    m_pManager = NULL;
}

CBufferNode::~CBufferNode()

{
    FinalDeactivate();
    if (m_pManager)
    {
        m_pManager->Remove(this);
    }
}

ULONG CBufferNode::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CBufferNode::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CBufferNode::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    if (m_pBuffer)
    {
        if (fActivate)
        {
            if (!m_lActivateCount)
            {
                // Don't bother starting if the primary buffer.
                if (SUCCEEDED(hr) && !(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                {
                    TraceI(2,"Play buffer %lx\n",m_pBuffer);
                    hr = m_pBuffer->Play(0,0,DSBPLAY_LOOPING);
#ifdef DBG
                    if (FAILED(hr))
                    {
                        Trace(1,"Error: Activate on audiopath failed because buffer failed Play command.\n");
                    }
#endif
                }
            }
            if (hr == S_OK)
            {
                m_lActivateCount++;
            }
            TraceI(3,"Incrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
        }
        else
        {
            if (m_lActivateCount > 0)
            {
                m_lActivateCount--;
                if (!m_lActivateCount)
                {
                    // Don't bother stopping the primary buffer.
                    if (!(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                    {
                        TraceI(2,"Stop buffer %lx\n",m_pBuffer);
                        hr = m_pBuffer->Stop();
                    }
                }
                TraceI(3,"Decrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
                if (hr != S_OK)
                {
                    m_lActivateCount++;
                }
            }
        }
    }
    return hr;
}


void CBufferNode::FinalDeactivate()

{
    if (m_lActivateCount)
    {
        Activate(FALSE);
    }
    if (m_pBuffer)
    {
        m_pBuffer->Release();
        m_pBuffer = NULL;
    }
}

CBufferManager::CBufferManager()
{
    m_pFirstBuffer = NULL;
    m_pSinkConnect = NULL;
    m_pSynthSink = NULL;
    m_pPerf = NULL;
}

CBufferManager::~CBufferManager()
{
    Clear();
    if (m_pSinkConnect)
    {
        m_pSinkConnect->Release();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Release();
    }
}

HRESULT CBufferManager::Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams)

{
    HRESULT hr = S_OK;
    m_pPerf = pPerf;
    m_AudioParams = *pAudioParams;
    CBufferNode *pNode = new CBufferNode;
    if (pNode)
    {
        pNode->m_BufferHeader.guidBufferID = GUID_Buffer_Primary;
        pNode->m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_PRIMARY;
        pNode->m_pManager = this;
        AddHead(pNode);
        // Create the primary buffer. This will be used for requests to access the listener.
        DSBUFFERDESC dsbdesc;
        memset(&dsbdesc, 0, sizeof(dsbdesc));
        dsbdesc.dwSize = sizeof(dsbdesc);
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;

        // create primary buffer
        if (SUCCEEDED(hr = pPerf->m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pNode->m_pBuffer, NULL)))
        {
            WAVEFORMATEX wfPrimary;
            memset(&wfPrimary, 0, sizeof(wfPrimary));

            if (SUCCEEDED(hr = pNode->m_pBuffer->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
            {
                assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);

                BOOL fUpgrade = FALSE;
                if (wfPrimary.nSamplesPerSec < m_AudioParams.dwSampleRate)
                {
                    wfPrimary.nSamplesPerSec = m_AudioParams.dwSampleRate;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.wBitsPerSample < 16)
                {
                    wfPrimary.wBitsPerSample = 16;
                    fUpgrade = TRUE;
                }

                if (fUpgrade)
                {
                    wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
                    wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;

                    // the existing format is of lesser quality than we desire, so let's upgrade it
                    if (FAILED(hr = pNode->m_pBuffer->SetFormat( &wfPrimary )))
                    {
                        if (hr == DSERR_PRIOLEVELNEEDED)
                        {
                            // okay, so maybe the app doen't want us changing primary buffer
                            Trace(0, "SynthSink - SetFormat on primary buffer failed, lacking priority\n");
                        }
                        else
                        {
                            Trace(0, "SynthSink - Activation failed, couldn't set primary buffer format\n");
                        }
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CBufferManager::InitSink(/*WAVEFORMATEX *pSinkFormat*/)

{
    HRESULT hr = S_OK;
    // Only init the sink if it's needed. If the audiopaths will be using buffers,
    // we need the sink. If not, bypass setting it up.
    if (!m_pSinkConnect && (m_pPerf->m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
    {
        static WAVEFORMATEX sDefaultFormat = { WAVE_FORMAT_PCM,1,22050,22050*2,2,16,0 };
        sDefaultFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
        sDefaultFormat.nAvgBytesPerSec = m_AudioParams.dwSampleRate * 2;
        sDefaultFormat.cbSize = 0;
        sDefaultFormat.nBlockAlign = 2;
        sDefaultFormat.nChannels = 1;
        sDefaultFormat.wBitsPerSample = 16;
        sDefaultFormat.wFormatTag = WAVE_FORMAT_PCM;

        IDirectSoundPrivate* pDSPrivate;
        hr = m_pPerf->m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pDSPrivate->AllocSink(&sDefaultFormat, &m_pSinkConnect);
            pDSPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            IReferenceClock *pClock = NULL;
            hr = m_pPerf->m_pDirectMusic->GetMasterClock(NULL, &pClock);
            if (SUCCEEDED(hr))
            {
                hr = m_pSinkConnect->SetMasterClock(pClock);
                pClock->Release();
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink,(void **) &m_pSynthSink);
            if (SUCCEEDED(hr))
            {
                hr = m_pSynthSink->Activate(TRUE);
            }
        }
        if (SUCCEEDED(hr))
        {
            // Create a dummy buffer that gets activated at the start and stays active until
            // the sink closes down. This is an unfortunate patch to the "clock-hopping" bug.
            // Once we come up with a better solution for providing timing from the sink, this
            // can go away.
            CBufferConfig Config(BUFFER_MONO);
            hr = CreateBuffer(&Config,&m_pFirstBuffer);
            if (SUCCEEDED(hr))
            {
                hr = m_pFirstBuffer->Activate(TRUE);
            }
        }
    }
    return hr;
}

void CBufferManager::FinalDeactivate()
{
    // Kill dummy buffer.
    if (m_pFirstBuffer)
    {
        m_pFirstBuffer->Activate(FALSE);
        delete m_pFirstBuffer;
        m_pFirstBuffer = NULL;
    }
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        pNode->FinalDeactivate();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Activate(FALSE);
        m_pSynthSink->Release();
        m_pSynthSink = NULL;
    }
    if (m_pSinkConnect)
    {
        m_pSinkConnect->SetMasterClock(NULL);
        m_pSinkConnect->Release();
        m_pSinkConnect = NULL;
    }
}

void CBufferManager::Clear()
{
    CBufferNode *pNode;
    FinalDeactivate();
    while (pNode = GetHead())
    {
        delete pNode;
    }
}

CBufferNode *CBufferManager::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        if (pNode->m_BufferHeader.guidBufferID == guidBufferID)
        {
            pNode->AddRef();
            break;
        }
    }
    return pNode;
}

HRESULT CBufferManager::CreateBuffer(CBufferConfig *pConfig, CBufferConfig ** ppNew)

{
    HRESULT hr = S_OK;
    if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
    {
        ASSERT(m_pSinkConnect);

        CBufferConfig *pNew = new CBufferConfig(pConfig->m_dwStandardBufferID);
        if (pNew)
        {
            *ppNew = pNew;
            pNew->m_BufferHeader = pConfig->m_BufferHeader;
            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
            {
                // Check to see if there already is a buffer in the list with this GUID.
                CBufferNode *pNode = GetHead();
                for (;pNode;pNode = pNode->GetNext())
                {
                    if (pNode->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
                    {
                        if (pNode->m_BufferHeader.guidBufferID == pConfig->m_BufferHeader.guidBufferID)
                        {
                            pNew->m_pBufferNode = pNode;
                            pNode->AddRef();
                            TraceI(2,"Found shared Buffer %lx\n",pNode->m_pBuffer);
                            return S_OK;
                        }
                    }
                }
            }
            // Either the buffer does not already exist, or it is not to be shared, so
            // create a new buffer node and requested buffer.
            CBufferNode *pNode = new CBufferNode;
            if (pNode)
            {
                pNode->m_BufferHeader = pConfig->m_BufferHeader;
                // Predefined buffer type?
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
                {
                    // Must be a standard type. Create by hand.
                    CBufferNode *pSendNode = NULL;
                    DSBUFFERDESC BufferDesc;
                    WAVEFORMATEX WaveFormat;
                    DWORD dwFunctionIDs[2];
                    CLSID clsidDMO;
                    BOOL fDMO = FALSE;
                    DWORD dwNumFunctionIDs;
                    memset(&BufferDesc, 0, sizeof(BufferDesc));
                    BufferDesc.dwSize  = sizeof(BufferDesc);
                    BufferDesc.lpwfxFormat = &WaveFormat;
                    BufferDesc.dwBufferBytes = 0;
                    BufferDesc.dwFlags = 0;
                    memset(&WaveFormat,0,sizeof(WaveFormat));
                    WaveFormat.nChannels = 2;
                    switch (pConfig->m_dwStandardBufferID)
                    {
                    case BUFFER_REVERB :
                        dwFunctionIDs[0] = DSBUSID_REVERB_SEND;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        clsidDMO = GUID_DSFX_WAVES_REVERB;
                        fDMO = TRUE;
                        break;
                    case BUFFER_ENVREVERB :
                        dwNumFunctionIDs = 0;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_MIXIN | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME;
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
                        fDMO = TRUE;
                        if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
                        {
                            hr = DMUS_E_AUDIOPATH_NOBUFFER;
                            Trace(1,"Audiopath Creation error: Requested Environmental reverb buffer when DMUS_AUDIOF_ENVIRON not enabled via InitAudio.\n");
                        }
                        break;
                        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*                    case BUFFER_3D :
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
                        fDMO = TRUE;
                        pSendNode = GetBufferNode(GUID_Buffer_EnvReverb);
                        if (!pSendNode)
                        {
                            Trace(1,"Error: Failed creating 3D audiopath because the environmental reverb audiopath has not been created.\n");
                            hr = DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER;
                            break;
                        }*/
                    case BUFFER_3D_DRY :
                        dwFunctionIDs[0] = DSBUSID_DYNAMIC_0;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY |
                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_LOCDEFER;
                        BufferDesc.guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION;
                        break;
                    case BUFFER_MONO :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        break;
                    case BUFFER_STEREO :
                        BufferDesc.dwFlags = DSBCAPS_CTRLFREQUENCY;
                    case BUFFER_MUSIC :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwFunctionIDs[1] = DSBUSID_RIGHT;
                        dwNumFunctionIDs = 2;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCDEFER;
                        break;
                    default:
                        hr = E_INVALIDARG;
                    }
                    if (SUCCEEDED(hr))
                    {
                        WaveFormat.nBlockAlign = WaveFormat.nChannels * 2;
                        WaveFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
                        WaveFormat.nAvgBytesPerSec = WaveFormat.nChannels * WaveFormat.nSamplesPerSec * 2;
                        WaveFormat.wBitsPerSample = 16;
                        WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
                        // Ensure that the mixin flag and number of bus ids are in sync (you can't combine mixin with buses.)
                        if ((pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN) || (dwNumFunctionIDs == 0))
                        {
                            dwNumFunctionIDs = 0;
                            BufferDesc.dwFlags |= DSBCAPS_MIXIN;
                            pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            BufferDesc.dwFlags &= ~DSBCAPS_LOCDEFER;
                        }
                        // Always allow effects to be created on the buffer, regardless of whether we need them now.
                        BufferDesc.dwFlags |= DSBCAPS_CTRLFX;
                        hr = m_pSinkConnect->CreateSoundBuffer(&BufferDesc, &dwFunctionIDs[0], dwNumFunctionIDs,
                                                               pConfig->m_BufferHeader.guidBufferID, &pNode->m_pBuffer);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                            {
                                Trace(1,"Error: Failed creating global (MIXIN) buffer for standard path.\n");
                            }
                            else
                            {
                                Trace(1,"Error: Failed creating buffer for standard path.\n");
                            }
                        }
#endif
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (fDMO)
                        {
                            IDirectSoundBuffer8 *pBuff8;
                            if (SUCCEEDED(pNode->m_pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **)&pBuff8)))
                            {
                                DWORD dwResult;
                                DSEFFECTDESC FXDesc;
                                FXDesc.dwSize = sizeof(DSEFFECTDESC);
                                FXDesc.dwFlags = 0;
                                FXDesc.guidDSFXClass = clsidDMO;
                                FXDesc.dwReserved1 = 0;
                                FXDesc.dwReserved2 = 0;
                                if (pSendNode)
                                {
                                    FXDesc.dwReserved1 = DWORD_PTR(pSendNode->GetBuffer());
                                }
                                hr = pBuff8->SetFX(1, &FXDesc, &dwResult);
                                if (FXDesc.dwReserved1)
                                {
                                    ((IDirectSoundBuffer*)FXDesc.dwReserved1)->Release();
                                }
                                pBuff8->Release();
                            }
                        }
                    }
                    if (pSendNode)
                    {
                        pSendNode->Release();
                    }
                }
                else
                {
                    pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
                    if (SUCCEEDED(hr))
                    {
                        // We need to know if this is a mixin buffer so we can identify it later.
                        DWORD dwBusIDs[32];
                        DWORD dwFuncIDs[32];
                        DWORD dwCount = 32;
                        dwFuncIDs[0] = 0;
                        if (SUCCEEDED(m_pSinkConnect->GetSoundBufferBusIDs(pNode->m_pBuffer,dwBusIDs,dwFuncIDs,&dwCount)))
                        {
                            if (dwFuncIDs[0] == 0xFFFFFFFF)
                            {
                                pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            }
                        }
                    }
                    else
                    {
                        Trace(1,"Error: Failed creation of buffer defined in audio path configuration file.\n");
                    }
                }

                if (SUCCEEDED(hr))
                {
                    TraceI(2,"Created Buffer %lx\n",pNode->m_pBuffer);
                    pNew->m_pBufferNode = pNode;
                    pNode->m_pManager = this;
                    AddHead(pNode);
                }
                else
                {
                    delete pNode;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (FAILED(hr) && pNew)
        {
            delete pNew;
            *ppNew = NULL;
        }
    }
    else
    {
        hr = DMUS_E_AUDIOPATH_NOBUFFER;
        Trace(0,"Audiopath Creation error: Requested buffer when DMUS_AUDIOF_BUFFERS not enabled via InitAudio.\n");
    }
    return hr;
}

CBufferConnect::CBufferConnect()

{
    m_ppBufferNodes = NULL;
    m_pguidBufferIDs = NULL;
    m_ConnectHeader.dwBufferCount = 0;
}

HRESULT CBufferConnect::Load(CRiffParser *pParser)

{
    HRESULT hr = pParser->Read(&m_ConnectHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER));
    if (SUCCEEDED(hr))
    {
        DWORD dwBufferCount = m_ConnectHeader.dwBufferCount;
        m_pguidBufferIDs = new GUID[dwBufferCount];
        if (m_pguidBufferIDs )
        {
            hr = pParser->Read(m_pguidBufferIDs,sizeof(GUID)*dwBufferCount);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

CBufferConnect *CBufferConnect::CreateRunTimeVersion(CPortConfig *pParent)

{
    CBufferConnect *pCopy = new CBufferConnect;
    if (pCopy && m_pguidBufferIDs)
    {
        pCopy->m_ConnectHeader = m_ConnectHeader;
        pCopy->m_ppBufferNodes = new CBufferNode *[m_ConnectHeader.dwBufferCount];
        if (pCopy->m_ppBufferNodes)
        {
            for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
            {
                pCopy->m_ppBufferNodes[dwIndex] = pParent->GetBufferNode(m_pguidBufferIDs[dwIndex]);
            }
        }
        else
        {
            delete pCopy;
            pCopy = NULL;
        }
    }
    return pCopy;
}


CBufferConnect::~CBufferConnect()

{
    if (m_ppBufferNodes)
    {
        for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
        {
            if (m_ppBufferNodes[dwIndex]) m_ppBufferNodes[dwIndex]->Release();
        }
        delete [] m_ppBufferNodes;
    }
    if (m_pguidBufferIDs)
    {
        delete [] m_pguidBufferIDs;
    }
}

HRESULT CBufferConnectList::CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent)

{
    CBufferConnect *pScan = GetHead();
    CBufferConnect *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        pCopy = pScan->CreateRunTimeVersion(pParent);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CBufferConnectList::Clear()

{
    CBufferConnect *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

HRESULT CBufferConfig::Activate(BOOL fActivate)

{
    if (m_pBufferNode)
    {
        return m_pBufferNode->Activate(fActivate);
    }
    return S_OK;
}

CBufferConfig::CBufferConfig(DWORD dwType)

{
    m_pBufferNode = NULL;
    m_BufferHeader.guidBufferID = GUID_NULL;
    m_BufferHeader.dwFlags = DMUS_BUFFERF_DEFINED;
    m_dwStandardBufferID = dwType;
    switch (dwType)
    {
    case BUFFER_REVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_Reverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    case BUFFER_ENVREVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_EnvReverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_MIXIN;
        break;
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
//    case BUFFER_3D :
//        m_BufferHeader.guidBufferID = GUID_Buffer_3D;
//        break;
    case BUFFER_3D_DRY :
        m_BufferHeader.guidBufferID = GUID_Buffer_3D_Dry;
        break;
    case BUFFER_MONO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Mono;
        break;
    case BUFFER_STEREO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        break;
    case BUFFER_MUSIC :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    default:
        m_BufferHeader.dwFlags = 0;
        break;
    }
    m_pBufferConfig = NULL;
}

CBufferConfig::~CBufferConfig()

{
    if (m_pBufferNode)
        m_pBufferNode->Release();
    if (m_pBufferConfig)
        m_pBufferConfig->Release();
}

void CBufferConfig::DecideType()

{
    if (m_BufferHeader.guidBufferID == GUID_Buffer_Reverb)
    {
        m_dwStandardBufferID = BUFFER_REVERB;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_EnvReverb)
    {
        m_dwStandardBufferID = BUFFER_ENVREVERB;
    }
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D)
    {
        m_dwStandardBufferID = BUFFER_3D;
    }*/
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D_Dry)
    {
        m_dwStandardBufferID = BUFFER_3D_DRY;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Mono)
    {
        m_dwStandardBufferID = BUFFER_MONO;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Stereo)
    {
        m_dwStandardBufferID = BUFFER_STEREO;
    }
}



HRESULT CBufferConfig::Load(IStream *pStream)

{
    IPersistStream *pPersist;
    HRESULT hr = CoCreateInstance( CLSID_DirectSoundBufferConfig,
        NULL, CLSCTX_INPROC, IID_IPersistStream,
        (void**)&pPersist );
    if (SUCCEEDED(hr))
    {
        hr = pPersist->Load(pStream);
        if (SUCCEEDED(hr))
        {
            m_pBufferConfig = pPersist;
            IDirectMusicObject *pObject;
            hr = pPersist->QueryInterface(IID_IDirectMusicObject,(void **) &pObject);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(Desc);
                pObject->GetDescriptor(&Desc);
                if (Desc.dwValidData & DMUS_OBJ_OBJECT)
                {
                    m_BufferHeader.guidBufferID = Desc.guidObject;
                }
                else
                {
                    Trace(1,"Error: Unable to load Buffer Configuration in AudioPath Config - Missing buffer GUID in file.\n");
                    hr = E_FAIL;
                }
                pObject->Release();
            }
        }
        else
        {
            pPersist->Release();
        }
    }
    return hr;
}

void CBufferConfigList::Clear()

{
    CBufferConfig *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

CBufferNode * CBufferConfigList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_BufferHeader.guidBufferID == guidBufferID)
        {
            if (pBuffer->m_pBufferNode)
            {
                pBuffer->m_pBufferNode->AddRef();
                pBuff = pBuffer->m_pBufferNode;
            }
            break;
        }
    }
    return pBuff;
}

HRESULT CBufferConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        hr = pBuffer->Activate(fActivate);
        if (FAILED(hr))
        {
            CBufferConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pBuffer);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CBufferConfigList::CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager)

/*  To create a runtime version, we scan through all bufferconfigs and, for each one, we call the
    buffer manager to create a new one, managed by CBufferNode. In the case where the buffer already exists, it just
    addrefs the CBufferNode and returns that.
*/

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        CBufferConfig *pNew = NULL;
        hr = pManager->CreateBuffer(pBuffer,&pNew);
        if (SUCCEEDED(hr))
        {
            pCopy->AddTail(pNew);
        }
        else
        {
            break;
        }
    }
    return hr;
}


CPortConfig::CPortConfig()

{
    m_fAlreadyHere = FALSE;
    m_pPort = NULL;
    m_dwPortID = 0;
    m_pParent = NULL;
    m_PortHeader.guidPort = GUID_Synth_Default;     // Default synth, as specified by DMUS_AUDPARAMS.
    m_PortHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;
    m_PortHeader.dwPChannelBase = 0;
    m_PortHeader.dwPChannelCount = 32;
    m_PortParams.dwChannelGroups = 2;
    m_PortParams.dwSize = sizeof(DMUS_PORTPARAMS8);
    m_PortParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_FEATURES;
    m_PortParams.dwFeatures = DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING;
}

CPortConfig::~CPortConfig()

{
    if (m_pPort) m_pPort->Release();
    m_BufferConnectList.Clear();
    m_BufferConfigList.Clear();
}


HRESULT CPortConfig::Activate(BOOL fActivate)

{
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr) && fActivate && m_pPort)
    {
        HRESULT hrTemp = m_pPort->Activate(TRUE);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    return hr;
}

HRESULT CPortConfig::CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent, CBufferManager *pManager)

{
    HRESULT hr = E_OUTOFMEMORY;
    CPortConfig *pCopy = new CPortConfig();
    if (pCopy)
    {
        pCopy->m_pParent = pParent;
        pCopy->m_PortHeader = m_PortHeader;
        pCopy->m_PortParams = m_PortParams;
        hr = m_BufferConfigList.CreateRunTimeVersion(&pCopy->m_BufferConfigList,pManager);
        if (SUCCEEDED(hr))
        {
            hr = m_BufferConnectList.CreateRunTimeVersion(&pCopy->m_BufferConnectList,pCopy);
        }
    }
    *ppCopy = pCopy;
    return hr;
}

CBufferNode * CPortConfig::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff && !m_fAlreadyHere)
    {
        m_fAlreadyHere = TRUE;
        pBuff = m_pParent->GetBufferNode(guidBuffer);
        m_fAlreadyHere = FALSE;
    }
    return pBuff;
}


HRESULT CPortConfig::Load(CRiffParser *pParser)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    DWORD dwLoadedBoth = 0;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_PORTCONFIG_ITEM:
            hr = pParser->Read(&m_PortHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER));
            dwLoadedBoth |= 1;
            break;
        case DMUS_FOURCC_PORTPARAMS_ITEM:
            hr = pParser->Read(&m_PortParams, sizeof(DMUS_PORTPARAMS8));
            dwLoadedBoth |= 2;
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                RIFFIO ckChild;
                case DMUS_FOURCC_PCHANNELS_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        switch( ckChild.ckid )
                        {
                        case DMUS_FOURCC_PCHANNELS_ITEM:
                            {
                                CBufferConnect *pBufferConnect = new CBufferConnect;
                                if (pBufferConnect)
                                {
                                    hr = pBufferConnect->Load(pParser);
                                    if (SUCCEEDED(hr))
                                    {
                                        m_BufferConnectList.AddTail(pBufferConnect);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            break;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_DSBUFFER_LIST:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->EnterList(&ckChild);
                            while (pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                    hr = pParser->Read(&pSource->m_BufferHeader,
                                        sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                    pSource->DecideType();
                                    break;
                                case FOURCC_LIST:
                                case FOURCC_RIFF:
                                    if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                    {
                                        pParser->SeekBack();
                                        hr = pSource->Load(pParser->GetStream());
                                        pParser->SeekForward();
                                        if (FAILED(hr))
                                        {
                                            Trace(1,"AudioPath Configuration failed loading buffer\n");
                                        }
                                    }
                                }
                            }
                            pParser->LeaveList();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                case DMUS_FOURCC_DSBC_FORM:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->SeekBack();
                            hr = pSource->Load(pParser->GetStream());
                            pParser->SeekForward();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                Trace(1,"AudioPath Configuration failed loading buffer\n");
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
        }
    }
    if (dwLoadedBoth != 3)
    {
        hr = DMUS_E_CHUNKNOTFOUND;
        Trace(1,"Error: Failure loading port configuration chunk in Audio Path Configuration.\n");
    }

    // Make sure the channel groups in the portparams is large enough to handle the requested
    // channels in portheader.
    m_PortParams.dwChannelGroups = (m_PortHeader.dwPChannelCount + 15) / 16;
    m_PortParams.dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
    pParser->LeaveList();

    return hr;
}

HRESULT CPortConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CPortConfig *pPort;
    for (pPort = GetHead();pPort;pPort = pPort->GetNext())
    {
        hr = pPort->Activate(fActivate);
        if (FAILED(hr))
        {
            CPortConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pPort);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CPortConfigList::CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager)

{
    HRESULT hr = S_OK;
    CPortConfig *pScan = GetHead();
    CPortConfig *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        hr = pScan->CreateRunTimeVersion(&pCopy,pParent,pManager);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            break;
        }
    }
    return hr;
}

BOOL CPortConfigList::UsesPort(IDirectMusicPort *pPort)

{
    CPortConfig *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pScan->m_pPort == pPort) return TRUE;
    }
    return FALSE;
}


void CPortConfigList::Clear()

{
    CPortConfig *pPort;
    while (pPort = RemoveHead())
    {
        delete pPort;
    }
}

CAudioPath::CAudioPath()

{
    TraceI(2,"Creating AudioPath %lx\n",this);
    InitializeCriticalSection(&m_CriticalSection);
    m_fDeactivating = FALSE;
    m_bLastVol = 127;
    m_cRef = 0;
    m_fActive = FALSE;
    m_pdwVChannels = NULL;
    m_pdwPChannels = NULL;
    m_dwChannelCount = 0;
    m_pPerformance = NULL;
    m_pGraph = NULL;
    m_pConfig = NULL;
    m_pUnkDispatch = NULL;
}


CAudioPath::~CAudioPath()
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    LeaveCriticalSection(&m_CriticalSection);
    Deactivate();
    DeleteCriticalSection(&m_CriticalSection);
}

STDMETHODIMP_(ULONG) CAudioPath::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPath::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPath::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPath::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicAudioPath)
    {
        *ppv = static_cast<IDirectMusicAudioPath*>(this);
    } else
    if (iid == IID_CAudioPath)
    {
        *ppv = static_cast<CAudioPath*>(this);
    } else
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPath,
                static_cast<IDirectMusicAudioPath*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPath object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


static BYTE VolumeToMidi(long lVolume)

{
    static long lDBToMIDI[97] = {        // Array used to convert db to MIDI.
        127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
        71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
        40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
        22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
        12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
        7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
        4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
        2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0
    };
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = lDBToMIDI[lVolume];
    lResult += ((lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

STDMETHODIMP CAudioPath::SetVolume(long lVolume,DWORD dwDuration)

{
    if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance.
    BYTE bMIDIVol = VolumeToMidi(lVolume);

    DMUS_CURVE_PMSG *pCurve;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetLatencyTime(&rtTimeNow);
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = m_bLastVol;
            m_bLastVol = bMIDIVol;
            // nStartValue: will be ignored
            pCurve->nEndValue = bMIDIVol;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_CCCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            pCurve->bCCData = 7; // MIDI volume controller number
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            // wParamType: leave as zero since this isn't a NRPN/RPN curve
            pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CAudioPath::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,
                                          DWORD dwBuffer, REFGUID guidObject,
                                          DWORD dwIndex, REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicAudioPath::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    CPortConfig *pPortConfig;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_AUDIOPATH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            hr = QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_AUDIOPATH_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_AUDIOPATH_TOOL:
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                // Convert from audiopath channel to performance channel.
                ConvertPChannel( dwPChannel,&dwPChannel);
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PORT:
        pPortConfig = m_PortConfigList.GetHead();
        for (;pPortConfig;pPortConfig = pPortConfig->GetNext())
        {
            // First, see if this matches the port guid.
            if ((pPortConfig->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
            {
                // Then, see if we have a pchannel match.
                if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                    ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelBase + pPortConfig->m_PortHeader.dwPChannelCount) > dwPChannel)))
                {
                    // If everything matches, there is always the chance that we have multiple instances of
                    // this in the list and we are actually looking at a second or third pointer to the same port.
                    // So, scan through the list again, making the exact same matches. If this port is found in
                    // an earlier instance, fail the match.
                    BOOL fSuccess = true;
                    CPortConfig *pScan = m_PortConfigList.GetHead();
                    for (;pScan;pScan = pScan->GetNext())
                    {
                        // First, see if this matches the port guid.
                        if ((pScan->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
                        {
                            // Then, see if we have a pchannel match.
                            if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                                ((pScan->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                                ((pScan->m_PortHeader.dwPChannelBase + pScan->m_PortHeader.dwPChannelCount) > dwPChannel)))
                            {
                                // If this is the same as the outer loop, we have arrived.
                                if (pScan == pPortConfig)
                                {
                                    break;
                                }
                                else
                                {
                                    // Else, if this points to the same port, we have failed.
                                    if (pScan->m_pPort == pPortConfig->m_pPort)
                                    {
                                        fSuccess = false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (fSuccess)
                    {
                        if (dwIndex)
                        {
                            dwIndex--;
                        }
                        else
                        {
                            IDirectMusicPort *pPort;
                            if (SUCCEEDED(m_pPerformance->GetPort(pPortConfig->m_dwPortID,&pPort)))
                            {
                                hr = pPort->QueryInterface(iidInterface,ppObject);
                                pPort->Release();
                            }
                            break;
                        }
                    }
                }
            }
        }
        break;
    case DMUS_PATH_SINK:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0) &&
            m_pPerformance->m_BufferManager.m_pSinkConnect)
        {
            hr = m_pPerformance->m_BufferManager.m_pSinkConnect->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_BUFFER:
    case DMUS_PATH_BUFFER_DMO:
        {
            CBufferConnect *pConnect = NULL;
            BOOL fAllChannels = (dwPChannel == DMUS_PCHANNEL_ALL);
            pPortConfig = m_PortConfigList.GetHead();
            for (;pPortConfig && FAILED(hr);pPortConfig = pPortConfig->GetNext())
            {
                if (fAllChannels || ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelCount +
                    pPortConfig->m_PortHeader.dwPChannelBase) > dwPChannel)))
                {
                    pConnect = pPortConfig->m_BufferConnectList.GetHead();
                    for (;pConnect;)
                    {
                        if (fAllChannels || ((pConnect->m_ConnectHeader.dwPChannelBase <= dwPChannel) &&
                            ((pConnect->m_ConnectHeader.dwPChannelCount +
                            pConnect->m_ConnectHeader.dwPChannelBase) > dwPChannel)))
                        {
                            // Found the buffer connect. Which buffer will be determined
                            // by dwBuffer. If dwBuffer is greater than the count of buffer,
                            // decrement and move on to the next pConnect.
                            if (pConnect->m_ConnectHeader.dwBufferCount > dwBuffer)
                            {
                                if (pConnect->m_ppBufferNodes[dwBuffer])
                                {
                                    IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwBuffer]->GetBuffer();
                                    if (pBuffer)
                                    {
                                        if (dwStage == DMUS_PATH_BUFFER)
                                        {
                                            if (dwIndex == 0)
                                            {
                                                hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                            }
                                        }
                                        else
                                        {
                                            IDirectSoundBuffer8 *pBuffer8;
                                            hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                                pBuffer8->Release();
                                            }
                                        }
                                        pBuffer->Release();
                                    }
                                }
                                pConnect = NULL;
                            }
                            else
                            {
                                dwBuffer -= pConnect->m_ConnectHeader.dwBufferCount;
                            }
                        }
                        if (pConnect)
                        {
                            pConnect = pConnect->GetNext();
                        }
                    }
                }
            }

        }
        break;
    case DMUS_PATH_MIXIN_BUFFER :
    case DMUS_PATH_MIXIN_BUFFER_DMO :
        if (dwPChannel == 0)
        {
            CBufferConfig *pConfig = m_BufferConfigList.GetHead();
            for (;pConfig; pConfig = pConfig->GetNext())
            {
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                {
                    if (!dwBuffer)
                    {
                        IDirectSoundBuffer *pBuffer = pConfig->m_pBufferNode->GetBuffer();
                        if (pBuffer)
                        {
                            if (dwStage == DMUS_PATH_MIXIN_BUFFER)
                            {
                                if (dwIndex == 0)
                                {
                                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                }
                            }
                            else
                            {
                                IDirectSoundBuffer8 *pBuffer8;
                                hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                    pBuffer8->Release();
                                }
                            }
                            pBuffer->Release();
                        }
                        break;
                    }
                    dwBuffer--;
                }
            }
        }
        break;
    case DMUS_PATH_PRIMARY_BUFFER :
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            CBufferNode *pNode = m_pPerformance->m_BufferManager.GetBufferNode(GUID_Buffer_Primary);
            if (pNode)
            {
                IDirectSoundBuffer *pBuffer = pNode->GetBuffer();
                if (pBuffer)
                {
                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                    pBuffer->Release();
                }
                pNode->Release();
            }
        }
        break;
    default:
        hr = E_INVALIDARG;
#ifdef DBG
        Trace(1,"Error: Audiopath does not support stage 0x%lx\n",dwStage);
#endif
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(3,"Warning: Requested AudioPath object not found\n");
    }
#endif
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Activate(BOOL fActivate)

{
    TraceI(2,"Audiopath %lx Activate: %ld\n",this,fActivate);
    if (fActivate == m_fActive)
    {
#ifdef DBG
        if (fActivate) Trace(2,"Warning: Attempt to activate already active audiopath.\n");
        else Trace(2,"Warning: Attempt to deactivate already inactive audiopath.\n");
#endif
        return S_FALSE;
    }
    m_fActive = fActivate;
    if (!fActivate && !m_fDeactivating)
    {
        EnterCriticalSection(&m_CriticalSection);
        CPerformance *pPerf = m_pPerformance;
        LeaveCriticalSection(&m_CriticalSection);
        if (pPerf)
        {
            // Kill anything currently playing on the audiopath.
            pPerf->StopEx(static_cast<IDirectMusicAudioPath*>(this),0,0);
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr))
    {
        hr = m_PortConfigList.Activate(fActivate);
        if (FAILED(hr))
        {
            m_BufferConfigList.Activate(!fActivate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hr))
    {
        m_fActive = !fActivate;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut)

{
    V_INAME(IDirectMusicAudioPath::ConvertPChannel);
    V_PTR_WRITE(pdwPChannelOut,DWORD);

    // If any special PMsg address (for example, broadcast), leave as is.
    if (dwPChannelIn >= DMUS_PCHANNEL_KILL_ME)
    {
        *pdwPChannelOut = dwPChannelIn;
        return S_OK;
    }
    DWORD dwScan = 0;
    for (;dwScan < m_dwChannelCount;dwScan++)
    {
        if (m_pdwVChannels[dwScan] == dwPChannelIn)
        {
            *pdwPChannelOut = m_pdwPChannels[dwScan];
            return S_OK;
        }
    }
    Trace(1,"Error: Audiopath failed request to convert out of range PChannel %ld\n",dwPChannelIn);
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::StampPMsg(
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicAudioPath::StampPMsg);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = E_FAIL;

    if (!m_fActive)
    {
        // Only kill notes and wave messages, since they are the only PMsgs that make sound.
        if ((pPMsg->dwType == DMUS_PMSGT_NOTE) || (pPMsg->dwType == DMUS_PMSGT_WAVE))
        {
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            Trace(1,"Error: Attempting to play on an inactive AudioPath, PMsg being ignored.\n");
            return DMUS_E_AUDIOPATH_INACTIVE;
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    if (!m_pPerformance)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOT_INIT;
    }
    // First, check if the audio path has its own graph.
    if (m_pGraph)
    {
        // Could return DMUS_S_LAST_TOOL, indicating end of graph.
        // If so, we'll treat that as a failure and drop on through to the next graph...
        if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
        {
            if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
            {
                if( pPMsg->pGraph )
                {
                    pPMsg->pGraph->Release();
                    pPMsg->pGraph = NULL;
                }
                pPMsg->pGraph = this;
                AddRef();
            }
        }
    }

    // If done with the graph, send to the performance. Also, check for the special case of
    // DMUS_PCHANNEL_BROADCAST_AUDIOPATH. If so, duplicate the pMsg
    // and send all the copies with the appropriate pchannel values.
    // Otherwise, convert the vchannel to the matching pchannel (this is the
    // point where the pchannel mapping occurs.)
    if( FAILED(hr) || (hr == DMUS_S_LAST_TOOL))
    {
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
        {
            DWORD dwIndex;
            for (dwIndex = 1;dwIndex < m_dwChannelCount;dwIndex++)
            {
                DWORD dwNewChannel = m_pdwPChannels[dwIndex];
                // Don't broadcast any broadcast messages!
                // And, if this is a transpose on the drum channel, don't send it.
                if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                    ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                {
                    DMUS_PMSG *pNewMsg;
                    if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                    {
                        pNewMsg->dwPChannel = dwNewChannel;
                        m_pPerformance->StampPMsg(pNewMsg);
                        m_pPerformance->SendPMsg(pNewMsg);
                    }
                }
            }
            // Now, set the pchannel for this one. First check that there are any
            // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
            // Also, mark it this way if the PMsg is a broadcast PMsg.
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            if (m_dwChannelCount)
            {
                if (m_pdwPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[0];
                }
            }
        }
        else
        {
            DWORD dwScan = 0;
            for (;dwScan < m_dwChannelCount;dwScan++)
            {
                if (m_pdwVChannels[dwScan] == pPMsg->dwPChannel)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[dwScan];
                    break;
                }
            }
            // If a map was not found, kill the message.
            // But, ignore for notifications, since they really don't care about pchannel.
            // And, ignore for performance broadcast PMsgs.
            if ((dwScan == m_dwChannelCount) &&
                (pPMsg->dwType != DMUS_PMSGT_NOTIFICATION) &&
                (pPMsg->dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            }
        }
        hr = m_pPerformance->StampPMsg(pPMsg);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CGraph *CAudioPath::GetGraph()

{
    CGraph *pGraph;
    EnterCriticalSection(&m_CriticalSection);
    // Return the graph, and AddRef if it exists.
    if (pGraph = m_pGraph)
    {
        m_pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return pGraph;
}

void CAudioPath::Deactivate()
{
    m_fDeactivating = TRUE;
    Activate(FALSE);
    EnterCriticalSection(&m_CriticalSection);
    m_fActive = FALSE;
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    if (m_pGraph)
    {
        m_pGraph->Release();
        m_pGraph = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig->Release();
        m_pConfig = NULL;
    }
    if (m_pPerformance)
    {
        if (m_pdwVChannels && m_pdwPChannels)
        {
            DWORD dwIndex;
            for (dwIndex = 0;dwIndex <m_dwChannelCount;dwIndex++)
            {
                m_pPerformance->ReleasePChannel(m_pdwPChannels[dwIndex]);
            }
            delete [] m_pdwVChannels;
            delete [] m_pdwPChannels;
        }
        m_pPerformance->m_AudioPathList.Remove(this);
        m_pPerformance->RemoveUnusedPorts();
        m_pPerformance->Release();
        m_pPerformance = NULL;
    }
    m_fDeactivating = FALSE;
    LeaveCriticalSection(&m_CriticalSection);
}

void CAudioPath::SetGraph(CGraph *pGraph)

{
    EnterCriticalSection(&m_CriticalSection);
    // Is this a change?
    if (!m_pGraph)
    {
        pGraph->Clone((IDirectMusicGraph **) &m_pGraph);
    }
    LeaveCriticalSection(&m_CriticalSection);
}


CBufferNode * CAudioPath::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    EnterCriticalSection(&m_CriticalSection);
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff)
    {
        CPortConfig *pConfig = m_PortConfigList.GetHead();
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            pBuff = pConfig->GetBufferNode(guidBuffer);
            if (pBuff)
            {
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (!pBuff)
    {
        pBuff = m_pPerformance->m_BufferManager.GetBufferNode(guidBuffer);
    }
    return pBuff;
}


HRESULT CAudioPath::Init(IUnknown *pSourceConfig,CPerformance *pPerf)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    m_pPerformance = pPerf;
    pPerf->m_AudioPathList.AddHead(this);
    pPerf->AddRef();
    if (pPerf && pSourceConfig)
    {
        if (SUCCEEDED(hr = pSourceConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pConfig)))
        {
            if (m_pConfig->m_pGraph)
            {
                SetGraph(m_pConfig->m_pGraph);
            }
            // The very first audio path has to create the sink.
            hr = pPerf->m_BufferManager.InitSink();

            if (SUCCEEDED(hr))
            {
                // First, install any global buffers that are required.
                hr = m_pConfig->m_BufferConfigList.CreateRunTimeVersion(&m_BufferConfigList,&pPerf->m_BufferManager);
                if (SUCCEEDED(hr))
                {
                    // Then, install the ports and buffers.
                    hr = m_pConfig->m_PortConfigList.CreateRunTimeVersion(&m_PortConfigList,this,&pPerf->m_BufferManager);
                    if (SUCCEEDED(hr))
                    {
                        hr = ConnectToPorts(pPerf,pPerf->m_AudioParams.dwSampleRate);
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPath::ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate)

/*  This must be called from within a critical section.
*/

{
    HRESULT hr = S_OK;
    // Scan through the list of portconfigs and hook them up with active ports
    // in the performance. If a port is not available, create the port.
    CPortConfig *pConfig = m_PortConfigList.GetHead();
    DWORD dwChannelCount = 0;   // Used to add up total PChannels needed.
    for (;pConfig && SUCCEEDED(hr);pConfig = pConfig->GetNext())
    {
        // Given the configuration, either find a port with a matching id, or create one.
        hr = pPerf->GetPathPort(pConfig);
        dwChannelCount += pConfig->m_PortHeader.dwPChannelCount;
    }
    if (SUCCEEDED(hr))
    {
        // Now, allocate the VChannels needed for each portconfig.
        m_pdwVChannels = new DWORD[dwChannelCount];
        if (m_pdwVChannels)
        {
            m_pdwPChannels = new DWORD[dwChannelCount];
            if (!m_pdwPChannels)
            {
                delete [] m_pdwVChannels;
                m_pdwVChannels = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Scan through the port configs and allocate the pchannels, copying the assignments
        // into virtual channel assignment arrays.
        pConfig = m_PortConfigList.GetHead();
        DWORD dwIndex = 0;
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            // If this port uses buffers, then connect them up.
            if (((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
                (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)))
            {
                CBufferConnect *pConnect = pConfig->m_BufferConnectList.GetHead();
                for (;pConnect && SUCCEEDED(hr);pConnect = pConnect->GetNext())
                {
                    // For each connect block, there should be an array of buffers
                    // to connect the range of PChannels to.
                    // For each PChannel, get a virtual pchannel and then assign
                    // it to the bus ids that belong to the buffers.
                    if (pConnect->m_ppBufferNodes)
                    {
                        DWORD dwCount = 0;
                        DWORD dwBusIDs[32];
                        DWORD *pdwBusIDBase = &dwBusIDs[0];
                        DWORD dwTotalRead = 0;
                        DWORD dwAmountLeft = 32;
                        for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) && dwAmountLeft; dwCount++)
                        {
                            if (pConnect->m_ppBufferNodes[dwCount] && !(pConnect->m_ppBufferNodes[dwCount]->m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                            {
                                IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
                                if (pBuffer)
                                {
                                    dwTotalRead = dwAmountLeft;
                                    hr = m_pPerformance->m_BufferManager.m_pSinkConnect->GetSoundBufferBusIDs(pBuffer,pdwBusIDBase,NULL,&dwTotalRead);
                                    pBuffer->Release();
                                    if (FAILED(hr)) break;
                                    pdwBusIDBase += dwTotalRead; // Increment pointer by how many was read.
                                    dwAmountLeft -=  dwTotalRead;
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            dwTotalRead = 32 - dwAmountLeft;
                            // Now, allocate the pchannels and assign them to buses.
                            IDirectMusicPortP* pPortP = NULL;
                            if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
                            {
                                for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
                                {
                                    DWORD dwDrumFlags = 0;
                                    m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
                                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                                    {
                                        dwDrumFlags = 1;
                                        if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                                        {
                                            // This is a drum on channel 10.
                                            dwDrumFlags |= 2;
                                        }
                                    }
                                    // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
                                    DWORD dwGroup;
                                    DWORD dwMChannel;
                                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
                                    if (dwTotalRead && SUCCEEDED(hr))
                                    {
                                        hr = pPortP->AssignChannelToBuses(dwGroup,dwMChannel,dwBusIDs,dwTotalRead);
                                    }
                                    dwIndex++;
                                }
                                pPortP->Release();
                            }
                        }
                    }
                }
            }
            else
            {
                DWORD dwCount;
                for (dwCount = 0;SUCCEEDED(hr) && (dwCount < pConfig->m_PortHeader.dwPChannelCount); dwCount++)
                {
                    DWORD dwDrumFlags = 0;
                    m_pdwVChannels[dwIndex] = pConfig->m_PortHeader.dwPChannelBase + dwCount;
                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                    {
                        dwDrumFlags = 1;
                        if (((pConfig->m_PortHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                        {
                            // This is a drum on channel 10.
                            dwDrumFlags |= 2;
                        }
                    }
                    // Now, allocate a virtual pchannel for this.
                    DWORD dwGroup; // These won't be used since we won't be assigning pchannels on the port to buffers.
                    DWORD dwMChannel;
                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
/*                    Trace(0,"%ld: Mapping %ld to %ld (Port %ld, Group %ld, Channel %ld)\n",
                        dwIndex,m_pdwVChannels[dwIndex],m_pdwPChannels[dwIndex],
                        pConfig->m_dwPortID,dwGroup,dwMChannel);*/

                    dwIndex++;
                }
            }
        }
    }
    m_dwChannelCount = dwChannelCount;
    return hr;
}

void CAudioPathList::Clear()
{
    CAudioPath *pPath;
    while (pPath = GetHead())
    {
        pPath->Deactivate(); // This should also remove it from the list.
        assert(pPath != GetHead()); // Make sure this is always the case!
    }
}

CBufferNode * CAudioPathList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CAudioPath *pPath;
    for (pPath = GetHead();pPath;pPath = pPath->GetNext())
    {
        pBuff = pPath->GetBufferNode(guidBufferID);
        if (pBuff)
        {
            break;
        }
    }
    return pBuff;
}

BOOL CAudioPathList::UsesPort(IDirectMusicPort *pPort)

{
    CAudioPath *pPath = GetHead();
    for (;pPath;pPath = pPath->GetNext())
    {
        if (pPath->UsesPort(pPort))
        {
            return TRUE;
        }
    }
    return FALSE;
}

CAudioPathConfig::CAudioPathConfig()
{
    m_pGraph = NULL;
    m_fPartialLoad = 0;
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;

    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
}

CAudioPathConfig::~CAudioPathConfig()
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
}

CAudioPathConfig *CAudioPathConfig::CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate)

{
    CAudioPathConfig *pConfig = new CAudioPathConfig;
    if (pConfig)
    {
        DWORD dwGlobalType = 0;         // Global mixin buffer.
        DWORD dwTypes[3];               // What types of buffers to create.
        DWORD dwTotal = 0;              // How many buffers.
        GUID  guidBufferIDs[3];         // IDs of buffers that should be connected to.
        DWORD dwConnections = 0;        // How many buffer connections.
        BOOL fCreatePort = TRUE;
        switch (dwType)
        {
        case DMUS_APATH_SHARED_STEREOPLUSREVERB:
            dwTypes[0] = BUFFER_MUSIC;
            dwTypes[1] = BUFFER_REVERB;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            guidBufferIDs[1] = GUID_Buffer_Reverb;
            dwConnections = 2;
            dwTotal = 2;
            break;
        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*        case DMUS_APATH_DYNAMIC_ENV3D:
            dwGlobalType = BUFFER_ENVREVERB;
            dwTypes[0] = BUFFER_3D;
            guidBufferIDs[0] = GUID_Buffer_3D;
            dwConnections = 1;
            dwTotal = 1;
            break;*/
        case DMUS_APATH_DYNAMIC_3D:
            dwTypes[0] = BUFFER_3D_DRY;
            guidBufferIDs[0] = GUID_Buffer_3D_Dry;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_MONO:
            dwTypes[0] = BUFFER_MONO;
            guidBufferIDs[0] = GUID_Buffer_Mono;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_STEREO:
            dwTypes[0] = BUFFER_STEREO;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            dwConnections = 1;
            dwTotal = 1;
            break;
        }
        if (dwGlobalType)
        {
            CBufferConfig *pBuffer = new CBufferConfig(dwGlobalType);
            if (pBuffer)
            {
                // This buffer configuration just has an id to identify which standard
                // buffer, instead of a pointer to a DSoundBufferConfig object,
                // which is what you'd see in the file io case.
                pConfig->m_BufferConfigList.AddHead(pBuffer);
            }
            else
            {
                delete pConfig;
                return NULL;
            }
        }
        if (fCreatePort)
        {
            CPortConfig *pPort = new CPortConfig();
            if (pPort)
            {
                pConfig->m_PortConfigList.AddHead(pPort);
                for (DWORD dwIndex = 0; dwIndex < dwTotal; dwIndex++)
                {
                    CBufferConfig *pBuffer = new CBufferConfig(dwTypes[dwIndex]);
                    if (pBuffer)
                    {
                        // This buffer configuration just has an id to identify which standard
                        // buffer, instead of a pointer to a DSoundBufferConfig object,
                        // which is what you'd see in the file io case.
                        pPort->m_BufferConfigList.AddHead(pBuffer);
                    }
                    else
                    {
                        delete pConfig;
                        return NULL;
                    }
                }
                // If there are connections to buffers, create the connection structure.
                if (dwConnections)
                {
                    CBufferConnect *pConnect = new CBufferConnect;
                    if (pConnect)
                    {
                        pPort->m_BufferConnectList.AddHead(pConnect);
                        pConnect->m_ConnectHeader.dwBufferCount = dwConnections;
                        pConnect->m_ConnectHeader.dwFlags = 0;
                        pConnect->m_ConnectHeader.dwPChannelBase = 0;
                        pConnect->m_ConnectHeader.dwPChannelCount = dwPChannelCount;
                        pConnect->m_pguidBufferIDs = new GUID[dwConnections];
                        if (pConnect->m_pguidBufferIDs)
                        {
                            for (DWORD dwIndex = 0; dwIndex < dwConnections; dwIndex++)
                            {
                                pConnect->m_pguidBufferIDs[dwIndex] = guidBufferIDs[dwIndex];
                            }
                        }
                        else
                        {
                            delete pConfig;
                            return NULL;
                        }
                    }
                }
                pPort->m_PortHeader.dwPChannelCount = dwPChannelCount;
                pPort->m_PortParams.dwChannelGroups = (dwPChannelCount + 15) / 16;
            }
            else
            {
                delete pConfig;
                pConfig = NULL;
            }
        }
    }
    return pConfig;
}



STDMETHODIMP CAudioPathConfig::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPathConfig::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if ((iid == IID_IUnknown ) || (iid == IID_IDirectMusicObject))
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CAudioPathConfig)
    {
        *ppv = static_cast<CAudioPathConfig*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPathConfig,
                static_cast<IDirectMusicObject*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPathConfig object\n");
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAudioPathConfig::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPathConfig::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPathConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CAudioPathConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: AudioPathConfig::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Descriptor size is larger than AudioPathConfig::SetDescriptor can handle\n");
    }
    return hr;
}

STDMETHODIMP CAudioPathConfig::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)

{
    V_INAME(CAudioPathConfig::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CAudioPathConfig::GetClassID( CLSID* pClassID )
{
    V_INAME(CAudioPathConfig::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicAudioPathConfig;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CAudioPathConfig::IsDirty()
{
    return S_FALSE;
}

HRESULT CAudioPathConfig::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        EnterCriticalSection(&m_CriticalSection);
        // Clear out any data that was previously loaded.
        if (m_pGraph)
        {
            m_pGraph->Release();
        }
        m_PortConfigList.Clear();
        m_BufferConfigList.Clear();
        hr = Load(&Parser);
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CAudioPathConfig::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read( &m_guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    m_dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    RIFFIO ckChild;
                    case DMUS_FOURCC_UNFO_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                                    if(SUCCEEDED(hr) )
                                    {
                                        m_dwValidData |= DMUS_OBJ_NAME;
                                    }
                                    break;
                                }
                                default:
                                    break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_PORTCONFIGS_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                            case FOURCC_LIST:
                                if (ckChild.fccType == DMUS_FOURCC_PORTCONFIG_LIST)
                                {
                                    CPortConfig *pConfig = new CPortConfig();
                                    if (pConfig)
                                    {
                                        hr = pConfig->Load(pParser);
                                        if (SUCCEEDED(hr))
                                        {
                                            m_PortConfigList.AddTail(pConfig);
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                                break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_DSBUFFER_LIST:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->EnterList(&ckChild);
                                while (pParser->NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                    case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                        hr = pParser->Read(&pSource->m_BufferHeader,
                                            sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                        pSource->DecideType();
                                        break;
                                    case FOURCC_LIST:
                                    case FOURCC_RIFF:
                                        if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                        {
                                            pParser->SeekBack();
                                            hr = pSource->Load(pParser->GetStream());
                                            pParser->SeekForward();
                                        }
                                    }
                                }
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    delete pSource;
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                }
                                pParser->LeaveList();
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_DSBC_FORM:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->SeekBack();
                                hr = pSource->Load(pParser->GetStream());
                                pParser->SeekForward();
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                    delete pSource;
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_TOOLGRAPH_FORM:
                        {
                            CGraph *pGraph = new CGraph;
                            if (pGraph)
                            {
                                hr = pGraph->Load(pParser);
                                if(m_pGraph)
                                {
                                    m_pGraph->Release();
                                }
                                m_pGraph = pGraph;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                }
                break;
        }
    }
    pParser->LeaveList();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPathConfig::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CAudioPathConfig::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\audpath.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __AUDIOPATH_H_
#define __AUDIOPATH_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "TrkList.h"
#include "alist.h"
#include "..\shared\dmstrm.h"
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"

class CPerformance;
class CSegState;
class CGraph;
class CAudioPathConfig;
class CBufferConfig;
struct IDirectSoundConnect;

class CBufferNode : public AListItem
{
friend class CBufferManager;
friend class CAudioPath;
public:
    CBufferNode();
    ~CBufferNode();
    ULONG AddRef();
    ULONG Release();
    IDirectSoundBuffer *GetBuffer() { if (m_pBuffer) m_pBuffer->AddRef(); return m_pBuffer;}
    HRESULT Activate(BOOL fActivate);
private:
    void FinalDeactivate();
    CBufferNode* GetNext() { return (CBufferNode*)AListItem::GetNext();}
    IDirectSoundBuffer *   m_pBuffer;           // DSound buffer that this manages. 
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags (can it be shared?).
    CBufferManager * m_pManager; // Pointer to parent list. 
    long m_lActivateCount;  // How many times this has been activated.
    long m_cRef;            // How many objects point at this.
};

class CBufferManager : public AList
{    

public:
    CBufferManager(); 
    ~CBufferManager() ;
    HRESULT Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams) ;
    HRESULT InitSink();
    void AddHead(CBufferNode* pBufferNode) { AList::AddHead((AListItem*)pBufferNode);}
    CBufferNode* GetHead(){return (CBufferNode*)AList::GetHead();}
    CBufferNode* RemoveHead() {return (CBufferNode *) AList::RemoveHead();}
    void Remove(CBufferNode* pBufferNode){AList::Remove((AListItem*)pBufferNode);}
    void AddTail(CBufferNode* pBufferNode){AList::AddTail((AListItem*)pBufferNode);}
    void Clear();
    void FinalDeactivate();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateBuffer(CBufferConfig *pConfig, CBufferConfig **pNew); 
private:
    CPerformance *m_pPerf;                  // Pointer to parent performance. 
    CBufferConfig *m_pFirstBuffer;          // Actual buffer created by config.
public:
    IDirectSoundConnect* m_pSinkConnect;    // The sink object which manages creation of buffers in dsound.
    IDirectSoundSynthSink *m_pSynthSink;    // Used to activate sink.
    DMUS_AUDIOPARAMS m_AudioParams;
};

#define BUFFER_REVERB       1
#define BUFFER_ENVREVERB    2
#define BUFFER_3D           3
#define BUFFER_3D_DRY       4
#define BUFFER_MONO         6
#define BUFFER_STEREO       7
#define BUFFER_MUSIC        8

DEFINE_GUID(GUID_Buffer_Primary,0x186cc544, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

#define DMUS_BUFFERF_PRIMARY    4   // This buffer flag is a private definition.

#define DMUS_STANDARD_PATH_DX7  20 // This is for internal use only.

#define MAX_CONNECTIONS     32  // Maximum of 32 buffers connected to one PChannel.

class CBufferConfig : public AListItem
{
public:
    CBufferConfig(DWORD dwType) ;
    ~CBufferConfig();
    void DecideType();         // Looks at embedded GUID and infers default type, if one exists.
    HRESULT Load(IStream *pStream);
    CBufferConfig* GetNext() { return (CBufferConfig*)AListItem::GetNext();}
    IUnknown *              m_pBufferConfig;     // Buffer definition. 
    CBufferNode *           m_pBufferNode;      // Manages the DSound buffer.
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags.
    DWORD                   m_dwStandardBufferID;// Optionally, one of the standard buffer types.
    HRESULT Activate(BOOL fActivate);
};

class CBufferConfigList : public AList
{
public:
    void AddHead(CBufferConfig* pBufferConfig) { AList::AddHead((AListItem*)pBufferConfig);}
    CBufferConfig* GetHead(){return (CBufferConfig*)AList::GetHead();}
    CBufferConfig* RemoveHead() {return (CBufferConfig *) AList::RemoveHead();}
    void Remove(CBufferConfig* pBufferConfig){AList::Remove((AListItem*)pBufferConfig);}
    void AddTail(CBufferConfig* pBufferConfig){AList::AddTail((AListItem*)pBufferConfig);}
    void Clear();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager);
    HRESULT Activate(BOOL fActivate);
};

class CPortConfig;

class CBufferConnect : public AListItem
{
public:
    CBufferConnect() ;
    ~CBufferConnect();
    CBufferConnect *CreateRunTimeVersion(CPortConfig *pParent);
    HRESULT Load(CRiffParser *pParser);
    CBufferConnect* GetNext() { return (CBufferConnect*)AListItem::GetNext();}
    DMUS_IO_PCHANNELTOBUFFER_HEADER m_ConnectHeader;
    GUID *                          m_pguidBufferIDs;// Set of guids identifying buffers to connect to.
    CBufferNode **                  m_ppBufferNodes; // Array of equivalent Buffer nodes. 
};

class CBufferConnectList : public AList
{
public:
    void AddHead(CBufferConnect* pBufferConnect) { AList::AddHead((AListItem*)pBufferConnect);}
    CBufferConnect* GetHead(){return (CBufferConnect*)AList::GetHead();}
    CBufferConnect* RemoveHead() {return (CBufferConnect *) AList::RemoveHead();}
    void Remove(CBufferConnect* pBufferConnect){AList::Remove((AListItem*)pBufferConnect);}
    void AddTail(CBufferConnect* pBufferConnect){AList::AddTail((AListItem*)pBufferConnect);}
    HRESULT CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent);
    void Clear();
};

class CAudioPath;

class CPortConfig : public AListItem
{
public:
    CPortConfig() ;
    ~CPortConfig();
    HRESULT CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent,CBufferManager *pManager);
    CPortConfig* GetNext() { return (CPortConfig*)AListItem::GetNext();}
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    HRESULT Activate(BOOL fActivate);
    HRESULT CPortConfig::Load(CRiffParser *pParser);
    DMUS_IO_PORTCONFIG_HEADER   m_PortHeader; // Port configuration header, from file.
    DMUS_PORTPARAMS8            m_PortParams; // Port params for opening the port, also from file. 
    DWORD                       m_dwPortID;   // Used to track the index of a created port, once connecting.
    CBufferConnectList          m_BufferConnectList; // Pchannel to buffer mappings. 
    CBufferConfigList           m_BufferConfigList; // List of dsound buffer configurations.
    CAudioPath *                m_pParent;    // Parent audio path.
    IDirectMusicPort *         m_pPort;      // Pointer to port, if run time version.
	BOOL						m_fAlreadyHere; // Check for recursive case looking for buffer nodes.
};

class CPortConfigList : public AList
{
public:
    void AddHead(CPortConfig* pPortConfig) { AList::AddHead((AListItem*)pPortConfig);}
    CPortConfig* GetHead(){return (CPortConfig*)AList::GetHead();}
    CPortConfig* RemoveHead() {return (CPortConfig *) AList::RemoveHead();}
    void Remove(CPortConfig* pPortConfig){AList::Remove((AListItem*)pPortConfig);}
    void AddTail(CPortConfig* pPortConfig){AList::AddTail((AListItem*)pPortConfig);}
    HRESULT CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager);
    void Clear();
    HRESULT Activate(BOOL fActivate);
    BOOL UsesPort(IDirectMusicPort *pPort);
};

class CAudioPath;

DEFINE_GUID(IID_CAudioPath,0xb06c0c23, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/*  The AudioPath represents a configuration of pchannels, ports, and buffers to play
    segments. The performance creates CAudioPath objects from CAudioPathConfig file
    objects and stores them in a linked list, which it uses to keep track of them.
*/

class CAudioPath : 
    public IDirectMusicAudioPath, 
	public IDirectMusicGraph,
    public AListItem
{
public:
    CAudioPath();
    ~CAudioPath();
    CAudioPath* GetNext() { return (CAudioPath*)AListItem::GetNext();}
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicAudioPath 
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    STDMETHODIMP Activate(BOOL fActivate) ;
    STDMETHODIMP SetVolume(long lVolume,DWORD dwDuration) ;
    STDMETHODIMP ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut) ; 

// IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    HRESULT Init(IUnknown *pSourceConfig,CPerformance *pPerf);
    HRESULT ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate);
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    void SetGraph(CGraph *pGraph);
    CGraph *GetGraph();
    void Deactivate();
    BOOL IsActive() { return m_fActive; }
    BOOL NoPorts() { return m_PortConfigList.IsEmpty(); }
    BOOL UsesPort(IDirectMusicPort *pPort) { return m_PortConfigList.UsesPort(pPort); }
private:
    BOOL                m_fDeactivating;    // State variable.
    BYTE                m_bLastVol;         // Last volume change.
    CRITICAL_SECTION    m_CriticalSection;
	BOOL				m_fActive;			// Indicates that the audio path is active.
    long			    m_cRef;             // Reference counter. 
    DWORD *             m_pdwVChannels;     // Array of source VChannels.
    DWORD *             m_pdwPChannels;     // Array of destination PChannels.
    DWORD               m_dwChannelCount;   // Size of arrays.
    CGraph *            m_pGraph;           // Route tool graph.
    CPerformance *      m_pPerformance;     // Pointer to performance, needed to release PChannels.
    CAudioPathConfig *  m_pConfig;          // Source configuration.
    CPortConfigList     m_PortConfigList;   // List of port definitions (copied from source.)
    CBufferConfigList   m_BufferConfigList; // List of DSound buffers connected to the ports.
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch
};

class CAudioPathList : public AList
{
public:
    void Clear();
    void AddHead(CAudioPath* pAudioPath) { AList::AddHead((AListItem*)pAudioPath);}
    CAudioPath* GetHead(){return (CAudioPath*)AList::GetHead();}
    CAudioPath* RemoveHead() {return (CAudioPath *) AList::RemoveHead();}
    void Remove(CAudioPath* pAudioPath){AList::Remove((AListItem*)pAudioPath);}
    void AddTail(CAudioPath* pAudioPath){AList::AddTail((AListItem*)pAudioPath);}
    BOOL IsMember(CAudioPath* pAudioPath){return AList::IsMember((AListItem*)pAudioPath);}
    BOOL UsesPort(IDirectMusicPort *pPort); 
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
};

DEFINE_GUID(IID_CAudioPathConfig,0xe9874261, 0xab52, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

class CAudioPathConfig : 
    public IPersistStream, 
    public IDirectMusicObject
{
friend class CAudioPath;
public:
    CAudioPathConfig();
    ~CAudioPathConfig();
    static CAudioPathConfig *CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate);


// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT Load( CRiffParser *pParser);

protected:
    CGraph *            m_pGraph;                   // Audio path tool graph.
    CPortConfigList     m_PortConfigList;           // List of port definitions.
    CBufferConfigList   m_BufferConfigList;         // List of global dsound buffer configurations.
    CRITICAL_SECTION    m_CriticalSection;
	long		        m_cRef;
	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
};

#endif // __AUDIOPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\curve.h ===
// Copyright (c) 1998 Microsoft Corporation
// curve.h

#ifndef __CURVE_H_
#define __CURVE_H_

#define CT_MAX  192 // curve table maximum
#define CT_FACTOR	100	// curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // curve division factor

// linear curves
static short ganCT_Linear[CT_MAX + 1] = {
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200 };

// sine curves
static short ganCT_Sine[CT_MAX + 1] = {
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200 };

// log curve
static short ganCT_Log[CT_MAX + 1] = {
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200 };

// exponential curve
static short ganCT_Exp[CT_MAX + 1] = {
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200 };

#endif // __CURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMIME"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\curvetrk.h ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmcompos\str.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       str.h
//
//--------------------------------------------------------------------------

//
// string.h
//

#include <objbase.h>

#ifndef __BRSTRING_H__
#define __BRSTRING_H__

class Archive;

class String
{
    friend String operator+( const String& str1, const String& str2 );
    friend String operator+( const String& str1, LPCSTR lpszStr );
    friend String operator+( LPCSTR lpszStr, const String& str1 );
    friend String operator+( const String& str1, char ch );
    friend String operator+( char ch, const String& str1 );

public:
    String();
    String( LPCSTR lpszStr );
    String( const String& str );
    String( LPCWSTR pszWstr );
    ~String();

    //BOOL LoadString( UINT nID, HINSTANCE hInstance );

    BOOL IsEmpty() const
    {
        return ( m_wLength == 0 );
    };
    WORD GetLength() const
    {
        return m_wLength;
    };
    int Compare( const String& str ) const
    {
		if (m_pBuf && str.m_pBuf)
		{
			return _wcsicmp( m_pBuf, str.m_pBuf );
		}
		else if (!m_pBuf && !str.m_pBuf)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    int Compare( LPCWSTR lpwzStr ) const
    {
		if (m_pBuf && lpwzStr)
		{
			return _wcsicmp( m_pBuf, lpwzStr );
		}
		else if (!m_pBuf && !lpwzStr)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    void Concat( const String& str );
    void Concat( LPCWSTR lpwzStr );
    void Concat( WCHAR wch );
    void TrimTrailingSpaces();
    WCHAR GetAt( UINT nIndex ) const
    {
        if( nIndex >= m_wLength )
        {
            return L'\0';
        }
        return m_pBuf[nIndex];
    };
    void SetAt( UINT nIndex, char ch )
    {
        if( nIndex < m_wLength )
        {
            m_pBuf[nIndex] = ch;
        }
    };
    HRESULT ReadWCS( LPSTREAM pStream, DWORD cSize );
    //HRESULT WriteWCS( LPSTREAM pStream );

// operators
    const String& operator+=( const String& str )   // concatenation
    {
        Concat( str );
        return *this;
    };
    const String& operator+=( LPCSTR lpszStr )      // concatenation
    {
        Concat( lpszStr );
        return *this;
    };
    const String& operator+=( char ch )             // concatenation
    {
        Concat( ch );
        return *this;
    };
    String& operator=( const String& str );
	String& operator=( LPCSTR pszStr );
    String& operator=( LPCWSTR pszWstr );
    operator const WCHAR*() const
    {
        return m_pBuf;
    }

private:
    WORD figureblocksize( WORD slen )
    {
        ++slen;         // for '\0'
        slen = static_cast<WORD>( slen / sm_wBlockSize );
        return static_cast<WORD>( ( slen + 1 ) * sm_wBlockSize );
    };

private:
    WORD m_wLength;
    WORD m_wAllocated;
    WCHAR* m_pBuf;

    static WORD sm_wBlockSize;  // size blocks are allocated in for strings
};

inline BOOL operator==( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator==( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) == 0 );
}

inline BOOL operator==( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator!=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator!=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) != 0 );
}

inline BOOL operator!=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator<( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator<( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) > 0 );
}

inline BOOL operator<( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator>( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator>( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) < 0 );
}

inline BOOL operator>( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator<=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator<=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) >= 0 );
}

inline BOOL operator<=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}

inline BOOL operator>=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}
#endif // __BRSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\curvetrk.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmgraph.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// DMGraph.cpp : Implementation of CGraph

#include "dmime.h"
#include "DMGraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validp.h"
#include "dls1.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include <strsafe.h>
#define ASSERT  assert

CGraph::CGraph()
{
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    memset(m_wszName, 0, sizeof(WCHAR) * DMUS_MAX_NAME);
    memset(m_wszCategory, 0, sizeof(WCHAR) * DMUS_MAX_CATEGORY);
    memset(m_wszFileName, 0, sizeof(WCHAR) * DMUS_MAX_FILENAME);
    InitializeCriticalSection(&m_CrSec);
    InterlockedIncrement(&g_cComponent);
}

CGraph::~CGraph()
{
    Shutdown();  // shouldn't be needed, but doesn't hurt
    DeleteCriticalSection(&m_CrSec);
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CGraph::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CGraph::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicGraph || iid == IID_IDirectMusicGraph8)
    {
        *ppv = static_cast<IDirectMusicGraph8*>(this);
    }
    else if (iid == IID_CGraph)
    {
        *ppv = static_cast<CGraph*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IGraphClone)
    {
        *ppv = static_cast<IGraphClone*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on ToolGraph object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | AddRef | Standard AddRef implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | Release | Standard Release implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
Made internal 9/25/98
  method HRESULT | IDirectMusicGraph | Shutdown |
  Shuts down the graph. This must be called when the graph is no longer needed,
  in order to release the tools and other memory. A call to Release is not
  sufficient, because there is circular referencing between the graph and the tools.
  However, only the segment, performance, or whatever owns the graph
  should call this function.
  rvalue S_OK | Success.
  rvalue S_FALSE | Success, but didn't need to do anything.
*/
HRESULT STDMETHODCALLTYPE CGraph::Shutdown()
{
    // release all Tools
    CToolRef*   pObj;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    if( IsEmpty() )
    {
        hr = S_FALSE;
    }
    else
    {
        while( pObj = RemoveHead() )
        {
            delete pObj;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CGraph::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex,
    GUID *pguidClassID)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pToolRef;
    // make sure that this Tool instance isn't already in the Graph
    for( pToolRef = GetHead(); pToolRef; pToolRef = pToolRef->GetNext() )
    {
        if( pTool == pToolRef->m_pTool )
        {
            LeaveCriticalSection(&m_CrSec);
            Trace(1,"Error: Multiple install of the same tool in a graph\n");
            return DMUS_E_ALREADY_EXISTS;
        }
    }
    // insert this Tool instance into the Graph
    pToolRef = new CToolRef;
    if( pToolRef )
    {
        DWORD       dwTemp;
        DWORD*      pdwArray = NULL;

        pToolRef->m_pTool = pTool;
        pTool->AddRef();
        pTool->Init(this);
        dwTemp = 0;
        IDirectMusicTool8 *pTool8;
        if (SUCCEEDED(pTool->QueryInterface(IID_IDirectMusicTool8,(void **) &pTool8)))
        {
            pToolRef->m_fSupportsClone = TRUE;
            pTool8->Release();
        }
        if (pguidClassID)
        {
            pToolRef->m_guidClassID = *pguidClassID;
        }
        else
        {
            IPersistStream *pPersist;
            if (SUCCEEDED(pTool->QueryInterface(IID_IPersistStream,(void **) &pPersist)))
            {
                pPersist->GetClassID(&pToolRef->m_guidClassID);
                pPersist->Release();
            }
        }
        pTool->GetMsgDeliveryType(&dwTemp);
        if( (dwTemp != DMUS_PMSGF_TOOL_IMMEDIATE) && (dwTemp != DMUS_PMSGF_TOOL_QUEUE) && (dwTemp != DMUS_PMSGF_TOOL_ATTIME) )
        {
            dwTemp = DMUS_PMSGF_TOOL_IMMEDIATE;
        }
        pToolRef->m_dwQueue = dwTemp;
        if( FAILED( pTool->GetMediaTypeArraySize(&dwTemp)))
        {
            dwTemp = 0;
        }
        pToolRef->m_dwMTArraySize = dwTemp;
        if( dwTemp )
        {
            pdwArray = new DWORD[dwTemp];
            if( pdwArray )
            {
                HRESULT hrTemp = pTool->GetMediaTypes( &pdwArray, dwTemp );
                if( hrTemp == E_NOTIMPL )
                {
                    delete [] pdwArray;
                    pToolRef->m_dwMTArraySize = 0;
                }
                else
                {
                    pToolRef->m_pdwMediaTypes = pdwArray;
                }
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }
        if( pdwPChannels )
        {
            pToolRef->m_pdwPChannels = new DWORD[cPChannels];
            if( pToolRef->m_pdwPChannels )
            {
                memcpy( pToolRef->m_pdwPChannels, pdwPChannels, sizeof(DWORD) * cPChannels );
                pToolRef->m_dwPCArraySize = cPChannels;
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }

        if (lIndex < 0)
        {
            lIndex += AList::GetCount();       // Make index be offset from end.
        }
        CToolRef *pNext = GetItem(lIndex);
        if (pNext)
        {
            InsertBefore(pNext,pToolRef);
        }
        else
        {
            AList::AddTail(pToolRef);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
HRESULT STDMETHODCALLTYPE CGraph::InsertTool(
    IDirectMusicTool *pTool,    // @parm The Tool to insert.
    DWORD *pdwPChannels,    // @parm An array of which PChannels to place the tool in. These are
                            // id's which are converted to MIDI Channel + Port on output. If the
                            // tool accepts messages on all PChannels, this is NULL. <p cPChannels>
                            // is the count of how many this array points to.
    DWORD cPChannels,       // @parm Count of how many PChannels are pointed to by <p pdwPChannels>.
    LONG lIndex)            // @parm At what position to place the tool. This is an index from either the start
                            // of the current tool list or, working backwards from the end (in which case, it is
                            // a negative number.) If <p lIndex> is out of range, the Tool will be placed at
                            // the very beginning or end of the Tool list. 0 is the beginning. To place a Tool
                            // at the end of the list, use a number for <p lIndex> that is larger than the number
                            // of tools in the current tool list.
{
    V_INAME(IDirectMusicGraph::InsertTool);
    V_INTERFACE(pTool);
    V_BUFPTR_READ_OPT(pdwPChannels, sizeof(DWORD) * cPChannels);

    return InsertTool(pTool,pdwPChannels,cPChannels,lIndex,NULL);
}

HRESULT CGraph::GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)

{
    V_INAME(IDirectMusicGraph::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    HRESULT hr = DMUS_E_NOT_FOUND;
    CToolRef*   pPlace;
    if( !IsEmpty() )
    {
        pPlace = NULL;
        // search for the tool
        EnterCriticalSection(&m_CrSec);
        for( pPlace = GetHead(); pPlace;
            pPlace = pPlace->GetNext() )
        {
            if ((guidObject == pPlace->m_guidClassID) || (guidObject == GUID_All_Objects))
            {
                BOOL fFound = (!pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_ALL));
                if( !fFound )
                {
                    DWORD cCount;
                    // scan through the array of PChannels to see if this one
                    // supports dwPChannel
                    for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
                    {
                        if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                        {
                            fFound = TRUE;
                            // yep, it supports it
                            break;
                        }
                    }
                }
                if (fFound)
                {
                    if (!dwIndex)
                    {
                        break;
                    }
                    else
                    {
                        dwIndex--;
                    }
                }
            }
        }
        if( pPlace )
        {
            hr = pPlace->m_pTool->QueryInterface(iidInterface,ppObject);
        }
        LeaveCriticalSection(&m_CrSec);
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: Requested Tool not found in Graph\n");
    }
#endif
    return hr;

}

/*
  @method HRESULT | IDirectMusicGraph | GetTool |
  Returns the Tool at the specified index.

  @rvalue DMUS_E_NOT_FOUND | Unable to find a Tool at the position described.
  @rvalue E_POINTER | ppTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The retrieved tool is AddRef'd by this call, so be sure to Release it.
*/
HRESULT STDMETHODCALLTYPE CGraph::GetTool(
    DWORD dwIndex,              // @parm The index, from the beginning and starting at 0,
                                // at which to retrieve the Tool from the Graph.
    IDirectMusicTool **ppTool)  // @parm The <i IDirectMusicTool> pointer to use
                                // for returning the requested tool.
{
    V_INAME(IDirectMusicGraph::GetTool);
    V_PTRPTR_WRITE(ppTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;

    if( IsEmpty() )
    {
        Trace(1,"Error: GetTool failed because the Tool Graph is empty\n");
        return DMUS_E_NOT_FOUND;
    }
    pPlace = NULL;
    // search for the indexed tool
    EnterCriticalSection(&m_CrSec);
    for( pPlace = GetHead(); ( dwIndex > 0 ) && pPlace;
        pPlace = pPlace->GetNext() )
    {
        dwIndex--;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        *ppTool = pPlace->m_pTool;
        (*ppTool)->AddRef();
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicGraph | RemoveTool |
  Removes the Tool from the Graph.

  @rvalue DMUS_E_NOT_FOUND | The specified Tool is not in the Graph.
  @rvalue E_POINTER | pTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The Tool is removed from the Graph, and the Graph's reference on the Tool
  object is released.
*/
HRESULT STDMETHODCALLTYPE CGraph::RemoveTool(
    IDirectMusicTool *pTool)    // @parm The <i IDirectMusicTool> pointer of the Tool to remove.
{
    V_INAME(IDirectMusicGraph::RemoveTool);
    V_INTERFACE(pTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    // search for the tool
    for( pPlace = GetHead(); pPlace; pPlace = pPlace->GetNext() )
    {
        if( pPlace->m_pTool == pTool )
            break;
    }
    if( NULL == pPlace )
    {
        Trace(1,"Error: RemoveTool - Tool not in Graph.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        AList::Remove(pPlace);
        delete pPlace;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CGraph::Clone(IDirectMusicGraph **ppGraph)

{
    V_INAME(IDirectMusicGraph::Clone);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr = E_OUTOFMEMORY;
    EnterCriticalSection(&m_CrSec);
    CGraph *pNew = new CGraph;
    if (pNew)
    {
        pNew->m_dwValidData = m_dwValidData;
        pNew->m_ftDate = m_ftDate;
        pNew->m_guidObject = m_guidObject;
        pNew->m_vVersion = m_vVersion;
        StringCchCopyW(pNew->m_wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
        StringCchCopyW(pNew->m_wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
        StringCchCopyW(pNew->m_wszName, DMUS_MAX_NAME, m_wszName);
        CToolRef *pSource = GetHead();
        CToolRef *pDest;
        for (;pSource;pSource = pSource->GetNext())
        {
            pDest = new CToolRef;
            if (pDest)
            {
                pNew->AList::AddTail(pDest);
                pDest->m_dwMTArraySize = pSource->m_dwMTArraySize;
                pDest->m_dwPCArraySize = pSource->m_dwPCArraySize;
                pDest->m_dwQueue = pSource->m_dwQueue;
                pDest->m_fSupportsClone = pSource->m_fSupportsClone;
                pDest->m_guidClassID = pSource->m_guidClassID;
                if (pSource->m_dwMTArraySize)
                {
                    pDest->m_pdwMediaTypes = new DWORD[pSource->m_dwMTArraySize];
                    if (pDest->m_pdwMediaTypes)
                    {
                        memcpy(pDest->m_pdwMediaTypes,pSource->m_pdwMediaTypes,
                            sizeof(DWORD)*pDest->m_dwMTArraySize);
                    }
                    else
                    {
                        pDest->m_dwMTArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwMediaTypes = NULL;
                }
                if (pSource->m_dwPCArraySize)
                {
                    pDest->m_pdwPChannels = new DWORD[pSource->m_dwPCArraySize];
                    if (pDest->m_pdwPChannels)
                    {
                        memcpy(pDest->m_pdwPChannels,pSource->m_pdwPChannels,
                            sizeof(DWORD)*pDest->m_dwPCArraySize);
                    }
                    else
                    {
                        pDest->m_dwPCArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwPChannels = NULL;
                }
                if (pSource->m_pTool)
                {
                    if (pDest->m_fSupportsClone)
                    {
                        IDirectMusicTool8 *pTool8 = (IDirectMusicTool8 *) pSource->m_pTool;
                        pTool8->Clone(&pDest->m_pTool);
                    }
                    else
                    {
                        pDest->m_pTool = pSource->m_pTool;
                        pDest->m_pTool->AddRef();
                    }
                }
            }
            else
            {
                delete pNew;
                pNew = NULL;
                break;
            }
        }
    }
    *ppGraph = (IDirectMusicGraph *) pNew;
    if (pNew) hr = S_OK;
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

// returns TRUE if dwType is supported by pToolRef
inline BOOL CGraph::CheckType( DWORD dwType, CToolRef* pToolRef )
{
    BOOL fReturn = FALSE;
    if( pToolRef->m_dwMTArraySize == 0 )
    {
        fReturn = TRUE; // supports all types
    }
    else
    {
        DWORD dw;
        ASSERT( pToolRef->m_pdwMediaTypes );
        for( dw = 0; dw < pToolRef->m_dwMTArraySize; dw++ )
        {
            if( dwType == pToolRef->m_pdwMediaTypes[dw] )
            {
                fReturn = TRUE;
                break;
            }
        }
    }
    return fReturn;
}

HRESULT STDMETHODCALLTYPE CGraph::StampPMsg(
    DMUS_PMSG* pPMsg)   // @parm The message to stamp.
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    V_BUFPTR_WRITE(pPMsg, sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;
    if( NULL == pPMsg )
    {
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pPlace = GetHead();
    IDirectMusicTool*   pPriorTool;
    DWORD       dwType;
    DWORD       dwPChannel;


    pPriorTool = pPMsg->pTool;
    dwType = pPMsg->dwType;
    dwPChannel = pPMsg->dwPChannel;
    if( pPriorTool )
    {
        for( ; pPlace; pPlace = pPlace->GetNext() )
        {
            if( pPriorTool == pPlace->m_pTool )
            {
                pPlace = pPlace->GetNext();
                break;
            }
        }
    }
    BOOL fFound = FALSE;
    for( ; pPlace ; pPlace = pPlace->GetNext() )
    {
        if( CheckType(dwType, pPlace) )
        {
            if( !pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                // supports all tracks, or requested channel is broadcast.
                break;
            }
            DWORD cCount;
            // scan through the array of PChannels to see if this one
            // supports dwPChannel
            for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
            {
                if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                {
                    fFound = TRUE;
                    // yep, it supports it
                    break;
                }
            }
        }
        if (fFound) break;
    }
    // release the current tool
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_S_LAST_TOOL;
    }
    else
    {
        // if there is no graph pointer, set it to this
        if( NULL == pPMsg->pGraph )
        {
            pPMsg->pGraph = this;
            AddRef();
        }
        // set to the new tool and addref
        if (pPlace->m_pTool) // Just in case, the ptool sometimes goes away in debugging situations after a long break.
        {
            pPMsg->pTool = pPlace->m_pTool;
            pPMsg->pTool->AddRef();
        }
        // set the event's queue type
        pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
        pPMsg->dwFlags |= pPlace->m_dwQueue;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CGraph::GetClassID( CLSID* pClassID )
{
    V_INAME(CGraph::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicGraph;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CGraph::IsDirty()
{
    return S_FALSE;
}

HRESULT CGraph::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        Shutdown(); // Clear out the tools that are currently in the graph.
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Tool Graph\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CGraph::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &m_guidObject, sizeof(GUID) );
            m_dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
            m_dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            m_wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
            m_dwValidData |= DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
            m_dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                            m_wszName[DMUS_MAX_NAME-1] = '\0';
                            m_dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_TOOL_LIST:
                    pParser->EnterList(&ckChild);
                    while(pParser->NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) &&
                            (ckChild.fccType == DMUS_FOURCC_TOOL_FORM))
                        {
                            hr = LoadTool(pParser);
                        }
                    }
                    pParser->LeaveList();
                    break;
            }
            break;
        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CGraph::LoadTool(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD cbSize;

    DMUS_IO_TOOL_HEADER ioDMToolHdr;
    DWORD *pdwPChannels = NULL;

    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);

    if (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid != DMUS_FOURCC_TOOL_CHUNK)
        {
            pParser->LeaveList();
            Trace(1,"Error: Tool header chunk not first in tool list.\n");
            return DMUS_E_TOOL_HDR_NOT_FIRST_CK;
        }

        hr = pParser->Read(&ioDMToolHdr, sizeof(DMUS_IO_TOOL_HEADER));

        if(ioDMToolHdr.ckid == 0 && ioDMToolHdr.fccType == NULL)
        {
            pParser->LeaveList();
            Trace(1,"Error: Invalid Tool header.\n");
            return DMUS_E_INVALID_TOOL_HDR;
        }

        if(ioDMToolHdr.cPChannels)
        {
            pdwPChannels = new DWORD[ioDMToolHdr.cPChannels];
            // subtract 1 from cPChannels, because 1 element is actually stored
            // in the ioDMToolHdr array.
            cbSize = (ioDMToolHdr.cPChannels - 1) * sizeof(DWORD);
            if(pdwPChannels)
            {
                pdwPChannels[0] = ioDMToolHdr.dwPChannels[0];
                if( cbSize )
                {
                    hr = pParser->Read(&pdwPChannels[1], cbSize);
                    if(FAILED(hr))
                    {
                        delete [] pdwPChannels;
                        pdwPChannels = NULL;
                        pParser->LeaveList();
                        Trace(1,"Error: File read error loading Tool.\n");
                        return DMUS_E_CANNOTREAD;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        pParser->LeaveList();
        Trace(1,"Error reading Tool chunk - not RIFF format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    while (pParser->NextChunk(&hr))
    {
        if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioDMToolHdr.fccType) ||
            (ckNext.ckid == ioDMToolHdr.ckid))
        {
            pParser->SeekBack();
            hr = CreateTool(ioDMToolHdr, pParser->GetStream(), pdwPChannels);
            pParser->SeekForward();
        }
    }

    pParser->LeaveList();

    if( pdwPChannels )
    {
        delete [] pdwPChannels;
        pdwPChannels = NULL;
    }

    return hr;
}

HRESULT CGraph::CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels)
{
    assert(pStream);

    IDirectMusicTool* pDMTool = NULL;
    HRESULT hr = CoCreateInstance(ioDMToolHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTool,
                                  (void**)&pDMTool);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTool->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }
    else
    {
        Trace(1,"Error creating tool for loading\n");
    }

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pStream);
        if (FAILED(hr))
        {
            Trace(1,"Error loading data into tool\n");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTool(pDMTool, pdwPChannels, ioDMToolHdr.cPChannels, ioDMToolHdr.lIndex, &ioDMToolHdr.guidClassID);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTool)
    {
        pDMTool->Release();
    }

    return hr;
}

HRESULT CGraph::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CGraph::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CGraph::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicGraph;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    StringCchCopyW( pDesc->wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW( pDesc->wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW( pDesc->wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CGraph::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            StringCchCopyW(m_wszName, DMUS_MAX_NAME, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            StringCchCopyW(m_wszCategory, DMUS_MAX_CATEGORY, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            StringCchCopyW(m_wszFileName, DMUS_MAX_FILENAME, pDesc->wszFileName);
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: ToolGraph::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Size of descriptor too large for Tool Graph to parse.\n");
    }
    return hr;
}


STDMETHODIMP CGraph::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CGraph::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicGraph;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                pDesc->wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                dwValidData |= DMUS_OBJ_CATEGORY;
                break;
            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            pDesc->wszName[DMUS_MAX_NAME-1] = '\0';
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Parsing Tool Graph - invalid file format\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

void CGraphList::Clear()
{
    CGraph *pGraph;
    while (pGraph = RemoveHead())
    {
        pGraph->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmgraph.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMGraph.h : Declaration of the CGraph

#ifndef __DMGRAPH_H_
#define __DMGRAPH_H_

#include "alist.h"
#include "dmusici.h"
#include "dmusicf.h"

class CRiffParser;

class CToolRef : public AListItem
{
public:
	CToolRef()
	{
        m_fSupportsClone = FALSE;
		m_pTool = NULL;
		m_dwQueue = 0;
		m_dwMTArraySize = 0;
        m_dwPCArraySize = 0;
		m_pdwMediaTypes = NULL;
		m_pdwPChannels = NULL;
        m_guidClassID = GUID_NULL;
	};

	// the memory for pdwTracks and pidType better have been allocated with
	// something compatible with delete!!!
	~CToolRef()
	{
		if( m_pdwPChannels )
		{
			delete [] m_pdwPChannels;
		}
		if( m_pdwMediaTypes )
		{
			delete [] m_pdwMediaTypes;
		}
		if( m_pTool )
		{
			m_pTool->Release();
		}
	};
    CToolRef* GetNext()
	{
		return (CToolRef*)AListItem::GetNext();
	};

    GUID                m_guidClassID;      // Class ID of tool.
    BOOL                m_fSupportsClone;   // Indicates this is a DX8 tool with support for cloning.
	IDirectMusicTool*	m_pTool;
	DWORD	            m_dwQueue;	// type of queue the tool wants messages to be
	DWORD	            m_dwMTArraySize; // size of the pdwMediaTypes array
	DWORD*	            m_pdwMediaTypes; // types of media the tool supports
	DWORD               m_dwPCArraySize;  // size of the pdwPChannels array
	DWORD*	            m_pdwPChannels;	// array of PChannel id's - messages stamped with these id's are
						// sent to the tool

};

class CGraph;

//#undef  INTERFACE
//#define INTERFACE  IGraphClone
DECLARE_INTERFACE_(IGraphClone, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IGraphClone */
    STDMETHOD(Clone)                (THIS_ IDirectMusicGraph **ppGraph) PURE;
};

DEFINE_GUID(IID_CGraph,0xb06c0c24, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(IID_IGraphClone,0xb06c0c27, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CGraph
class CGraph :
	public IDirectMusicGraph8,
	public IPersistStream,
    public IDirectMusicObject,
    public IGraphClone,
    public AList,
    public AListItem
{
public:
	CGraph();
	~CGraph();
    CToolRef* GetHead(){return (CToolRef*)AList::GetHead();};
    CToolRef* RemoveHead(){return (CToolRef*)AList::RemoveHead();};
    CToolRef* GetItem(LONG lIndex){return (CToolRef*) AList::GetItem(lIndex);};
    CGraph* GetNext() { return (CGraph*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicGraph
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD dwPosition,IDirectMusicTool** ppTool);
    STDMETHODIMP RemoveTool(IDirectMusicTool* pTool);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pPMsg);
//  IGraphClone 
    STDMETHODIMP Clone(IDirectMusicGraph **ppGraph); 

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    HRESULT Load(CRiffParser *pParser);
protected:
	HRESULT BuildToolList(CRiffParser *pParser);
	HRESULT LoadTool(CRiffParser *pParser);
	HRESULT CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels);
	HRESULT STDMETHODCALLTYPE Shutdown();
    HRESULT InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,
                DWORD cPChannels,LONG lIndex, GUID *pguidClassID);
    inline BOOL CheckType( DWORD dwType, CToolRef* pToolRef );
protected:
	CRITICAL_SECTION    m_CrSec;
	long		        m_cRef;
//	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
public:
    DWORD               m_dwLoadID;         // Identifier, used when loaded as part of a song.
};

class CGraphList : public AList
{
public:
    void Clear();
    void AddHead(CGraph* pGraph) { AList::AddHead((AListItem*)pGraph);}
    void Insert(CGraph* pGraph);
    CGraph* GetHead(){return (CGraph*)AList::GetHead();}
    CGraph* GetItem(LONG lIndex){return (CGraph*)AList::GetItem(lIndex);}
    CGraph* RemoveHead() {return (CGraph *) AList::RemoveHead();}
    void Remove(CGraph* pGraph){AList::Remove((AListItem*)pGraph);}
    void AddTail(CGraph* pGraph){AList::AddTail((AListItem*)pGraph);}
    CGraph* GetTail(){ return (CGraph*)AList::GetTail();}
};

#endif //__DMGRAPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmime.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmime.h
//
#ifndef _DMIME_H_
#define _DMIME_H_

// Must be before dmusicc.h, which includes dsound.h
//
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusici.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#define RELEASE(x)	if( NULL != x ) { x->Release(); }

#ifdef __cplusplus
extern "C" {
#endif

extern long g_cComponent;
extern bool g_fInitCS;
extern CRITICAL_SECTION g_CritSec;


#define	PARTIALLOAD_S_OK	(1 << 1)
#define PARTIALLOAD_E_FAIL	(1 << 2)

#ifdef __cplusplus
}; /* extern "C" */
#endif
DEFINE_GUID(IID_IDirectMusicPerformanceStats, 0x9301e312, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(IID_IDirectMusicParamHook,0x58880561, 0x5481, 0x11d3, 0x9b, 0xd1, 0xc2, 0x9f, 0xc4, 0xd1, 0xe6, 0x35);
DEFINE_GUID(IID_IDirectMusicSetParamHook,0x679c4138, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);

#endif // _DMIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmime_i.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__ 

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDirectMusicSegmentObject = {0x04742AFE,0x141F,0x11D1,{0xBC,0x1C,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITempoTrack = {0x31A1066B,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITimeSigTrack = {0x31A1066D,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISeqTrack = {0x30E6B076,0x3B49,0x11D1,{0xBC,0x37,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IDMGraph = {0xA1198389,0x4EF1,0x11D1,{0xBC,0x4B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISysExTrack = {0x4ECFF912,0x56DD,0x11D1,{0xBC,0x50,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IPrivatePerformance = { 0xb982d7cb, 0x8177, 0x11d1, { 0xbc, 0x60, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb } };


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmhall.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dmhall.cpp
// No longer used.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmperf.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmperf.h
// @doc EXTERNAL

#ifndef _DMPERF_H_ 
#define _DMPERF_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "audpath.h"
#include "..\shared\dmusicp.h"

#define DMUS_PCHANNEL_KILL_ME   0xFFFFFFF0

typedef struct _DMUS_SEGSTATEDATA
{
    _DMUS_SEGSTATEDATA *    pNext;        // Linked list of these.
    DWORD                   dwQueue;      // Which queue it is in.
    WCHAR                   wszName[DMUS_MAX_NAME]; // Name of object. 
    MUSIC_TIME              mtLoopStart;  // Loop start point.
    MUSIC_TIME              mtLoopEnd;    // Loop end point.
    DWORD                   dwRepeats;    // The original repeat setting (before countdown)
    MUSIC_TIME              mtLength;     // Length of segment.
    REFERENCE_TIME          rtGivenStart; // Start time given in PlaySegment, unquantized
    MUSIC_TIME              mtResolvedStart;// Start time resolved to desired resolution
    MUSIC_TIME              mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME              mtLastPlayed; // The last played absolute time
    MUSIC_TIME              mtPlayTo;     // Used to stop play at a specific time. Ignored when 0.
    MUSIC_TIME              mtSeek;       // How far into the segment we are.
    MUSIC_TIME              mtStartPoint; // Point in the segment where playback started
    DWORD                   dwRepeatsLeft;// Current repeats left.
    DWORD                   dwPlayFlags;// Segment playback control flags
    BOOL                    fStartedPlay; // Indicates if the segstate has started to play yet
    IDirectMusicSegmentState *pSegState;  // Pointer to segstate.
} DMUS_SEGSTATEDATA;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicParamHook */
#undef  INTERFACE
#define INTERFACE  IDirectMusicParamHook
DECLARE_INTERFACE_(IDirectMusicParamHook, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicParamHook */
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pData,
                                           IDirectMusicSegmentState *pSegState,
                                           DWORD dwTrackFlags,
                                           HRESULT hr) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSetParamHook
DECLARE_INTERFACE_(IDirectMusicSetParamHook, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSetParamHook */
    STDMETHOD(SetParamHook)         (THIS_ IDirectMusicParamHook *pIHook) PURE; 
};


#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformanceStats
DECLARE_INTERFACE_(IDirectMusicPerformanceStats, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPerformanceStats */
    STDMETHOD(TraceAllSegments)     (THIS) PURE;
    STDMETHOD(CreateSegstateList)   (THIS_ DMUS_SEGSTATEDATA ** ppList) PURE;     
    STDMETHOD(FreeSegstateList)     (THIS_ DMUS_SEGSTATEDATA * pList) PURE; 
};



#define DEFAULT_BUFFER_SIZE 1024
// the following constants represent time in milliseconds
#define TRANSPORT_RES 100
#define REALTIME_RES 10

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL     10000       // For converting from reference time to mils 
#define MARGIN_MIN      (100 * REF_PER_MIL) // 
#define MARGIN_MAX      (400 * REF_PER_MIL) // 
#define PREPARE_TIME    (m_dwPrepareTime * REF_PER_MIL) // Time
#define NEARTIME        (100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)
/*
// here's a convenience inline function that helps using resolution bits
inline DWORD SIMPLIFY_RESOLUTION(DWORD x)
{   
    if( x & DMUS_SEGF_DEFAULT )     
    {                               
        return DMUS_SEGF_DEFAULT;
    }                               
    else if( x & DMUS_SEGF_SEGMENTEND )
    {
        return DMUS_SEGF_SEGMENTEND;
    }
    else if( x & DMUS_SEGF_MARKER )
    {
        return DMUS_SEGF_MARKER;
    }
    else if( x & DMUS_SEGF_MEASURE )        
    {                               
        return DMUS_SEGF_MEASURE;       
    }                               
    else if( x & DMUS_SEGF_BEAT )   
    {                               
        return DMUS_SEGF_BEAT;          
    }                               
    else if( x & DMUS_SEGF_GRID )   
    {                               
        return DMUS_SEGF_GRID;          
    }   
    else return 0;                      
}
*/

struct PRIV_PMSG;

// pNext contains the next pointer for the next PMsg
// dwPrivFlags contains private flags used by the performance
// rtLast contains the previous time when an event is requeued,
//      which is used by the flush routine
#define PRIV_PART                       \
    struct PRIV_PMSG*   pNext;          \
    DWORD               dwPrivFlags;    \
    DWORD               dwPrivPubSize;  \
    REFERENCE_TIME      rtLast; 

typedef struct PRIV_PART_STRUCT
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
} PRIV_PART_STRUCT;

#define PRIV_PART_SIZE  sizeof(PRIV_PART_STRUCT)
#define PRIV_TO_DMUS(x) ((DMUS_PMSG*)(LPBYTE(x) + PRIV_PART_SIZE))
#define DMUS_TO_PRIV(x) ((PRIV_PMSG*)(LPBYTE(x) - PRIV_PART_SIZE))

typedef struct PRIV_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
} PRIV_PMSG;

typedef struct PRIV_TEMPO_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
} PRIV_TEMPO_PMSG;

#define PRIV_FLAG_ALLOC_MASK    0x0000FFFF0 // using 4 bits for this for now
#define PRIV_FLAG_ALLOC         0x0000CAFE0 // arbitrary pattern for allocated
#define PRIV_FLAG_FREE			0x0000DEAD0 // pattern for in free list
#define PRIV_FLAG_QUEUED        0x000000001 // set if in a queue
#define PRIV_FLAG_REMOVE        0x000000002 // set if this needs to be removed from a queue
#define PRIV_FLAG_TRACK 		0x000000004 // indicates this message was generated by a track 
#define PRIV_FLAG_FLUSH 		0x000000008 // this is a curve that needs to be flushed after
                                            // its end value has played 
#define PRIV_FLAG_REQUEUE       0x000100000 // set if this needs to be requeued to a queue


class CPMsgQueue
{
public:
    CPMsgQueue();
    ~CPMsgQueue();
    void            Enqueue(PRIV_PMSG *pItem);
    PRIV_PMSG *     Dequeue();
    PRIV_PMSG *     Dequeue(PRIV_PMSG *pItem);
    PRIV_PMSG *     GetHead() { return (m_pTop);}
    PRIV_PMSG *     FlushOldest(REFERENCE_TIME rtTime);
    long            GetCount();
    void            Sort();
private:
    PRIV_PMSG *     m_pTop;             // Top of list.
    PRIV_PMSG *     m_pLastAccessed;    // Last item access in list.
};

// structure used to hold Ports and Buffers
typedef struct PortTable
{
    REFERENCE_TIME      rtLast; // last message time packed
    IDirectMusicPort*  pPort;
    IDirectMusicBuffer* pBuffer;
    IReferenceClock*    pLatencyClock;
    BOOL                fBufferFilled;   // TRUE if there are messages in the buffer that should be sent to the port
    DWORD               dwChannelGroups; // Number of channel groups active on the port.
    CLSID               guidPortID;      // The class id of the port, for matching with audio path requests.
    DMUS_PORTPARAMS8    PortParams;      // PortParams returned when this port was created.  
    DWORD               dwGMFlags;       // DM_PORTFLAGS_XG, DM_PORTFLAGS_GM, and DM_PORTFLAGS_GS.
} PortTable;

// structure to hold a channel of an accumulated parameter.
// The CChannelMap keeps a linked list of these, one list each
// for each parameter type.

class CMergeParam : public AListItem
{
public:
    CMergeParam* GetNext() { return (CMergeParam*)AListItem::GetNext();}
    long                m_lData;    // Current parameter data.
    DWORD               m_dwIndex;  // Which layer.
};

class CParamMerger : public AList
{
public:
    CParamMerger();
    void Clear(long lInitValue);
    BYTE MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume);
    BYTE GetVolumeStart(DWORD dwIndex);
    short MergeTranspose(DWORD dwIndex, short nTranspose);
    long MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange);
    long GetIndexedValue(DWORD dwIndex);
private:
    long MergeData(DWORD dwIndex, long lData);
    void AddHead(CMergeParam* pMergeParam) { AList::AddHead((AListItem*)pMergeParam);}
    CMergeParam* GetHead(){return (CMergeParam*)AList::GetHead();}
    CMergeParam* RemoveHead() {return (CMergeParam *) AList::RemoveHead();}
    void Remove(CMergeParam* pMergeParam){AList::Remove((AListItem*)pMergeParam);}
    void AddTail(CMergeParam* pMergeParam){AList::AddTail((AListItem*)pMergeParam);}
    BYTE VolumeToMidi(long lVolume);
    static long m_lMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_lDBToMIDI[97];    // For converting volume to MIDI.
    long                m_lMergeTotal;   // Total for all parameters in the list, but not including m_lData.
    long                m_lZeroIndexData;    // Default (no index) data.
};

// structure to hold a single ChannelMap
class CChannelMap
{
public:
    void                Clear();            // Completely clears and resets structure. 
    void                Reset(BOOL fVolumeAndPanToo); // Clears just the midi controllers.
    CParamMerger        m_VolumeMerger;     // Set of volumes to merge.
    CParamMerger        m_ExpressionMerger; // Set of expression controllers to merge.
    CParamMerger        m_TransposeMerger;  // Set of transpositions to merge.
    CParamMerger        m_PitchbendMerger;  // Set of pitchbends to merge.
    CParamMerger        m_PanMerger;        // Set of pans to merge.
    CParamMerger        m_FilterMerger;     // Set of filters to merge.
    CParamMerger        m_ModWheelMerger;   // Set of mod wheel controls to merge.
    CParamMerger        m_ReverbMerger;     // Set of reverb levels to merge.
    CParamMerger        m_ChorusMerger;     // Set of chorus levels to merge.
    DWORD               dwPortIndex;        // index into the PortTable
    DWORD               dwGroup;            // group number of the port
    DWORD               dwMChannel;         // channel number in the group
    short               nTranspose;         // amount to transpose
    WORD                wFlags;             // CMAP_X flags
} ;

#define CMAP_FREE       (WORD) 1        // This channel is currently not in use.
#define CMAP_STATIC     (WORD) 2        // This channel is in use as a regular, static pchannel.
#define CMAP_VIRTUAL    (WORD) 4        // This channel is in use for a dynamic, virtual pchannel.

// structure used to hold a PChannelMap block of 16.
#define PCHANNEL_BLOCKSIZE  16

class CChannelBlock : public AListItem
{
public:
    CChannelBlock* GetNext() { return (CChannelBlock*)AListItem::GetNext();}
    void Init(DWORD dwPChannelStart, DWORD dwPortIndex, DWORD dwGroup, WORD wFlags);
    DWORD               m_dwPChannelStart;  // first PChannel index
    CChannelMap         m_aChannelMap[PCHANNEL_BLOCKSIZE];
    DWORD               m_dwFreeChannels;   // Number of channels currently free.
    DWORD               m_dwPortIndex;      // Port id, if this is completely assigned to one port.
};

class CChannelBlockList : public AList
{
public:
    void Clear();
    void AddHead(CChannelBlock* pChannelBlock) { AList::AddHead((AListItem*)pChannelBlock);}
    CChannelBlock* GetHead(){return (CChannelBlock*)AList::GetHead();}
    CChannelBlock* RemoveHead() {return (CChannelBlock *) AList::RemoveHead();}
    void Remove(CChannelBlock* pChannelBlock){AList::Remove((AListItem*)pChannelBlock);}
    void AddTail(CChannelBlock* pChannelBlock){AList::AddTail((AListItem*)pChannelBlock);}
};

// structure to hold a global GUID and its data
typedef struct GlobalData
{
    ~GlobalData()
    {
        if( pData )
        {
            delete [] pData;
        }
    }
    struct GlobalData*  pNext;
    GUID    guidType;
    void*   pData;
    DWORD   dwSize;
} GlobalData;

// structure to hold internal tempo message with relative tempo
typedef struct DMInternalTempo
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
    float   fltRelTempo; // the current relative tempo, from .5 to 2
} DMInternalTempo;

/*  Integer constants for defining each segstate queue */

#define SQ_PRI_WAIT     0   
#define SQ_CON_WAIT     1
#define SQ_SEC_WAIT     2
#define SQ_PRI_PLAY     3   
#define SQ_CON_PLAY     4
#define SQ_SEC_PLAY     5
#define SQ_PRI_DONE     6
#define SQ_CON_DONE     7
#define SQ_SEC_DONE     8
#define SQ_COUNT        9

#define IsPriQueue( dwCount ) ((dwCount % 3) == 0)
#define IsConQueue( dwCount ) ((dwCount % 3) == 1)
#define IsSecQueue( dwCount ) ((dwCount % 3) == 2)
#define IsWaitQueue( dwCount ) (dwCount <= SQ_SEC_WAIT)
#define IsPlayQueue( dwCount ) ((dwCount >= SQ_PRI_PLAY) && (dwCount <= SQ_SEC_PLAY))
#define IsDoneQueue( dwCount ) (dwCount >= SQ_PRI_DONE)
 


DEFINE_GUID(IID_CPerformance, 0xade66ea2, 0xe1c5, 0x4552, 0x85, 0x27, 0x1e, 0xef, 0xa5, 0xa, 0xfd, 0x7b);

class CSong;

// class CPerformance
class CPerformance : 
    public IDirectMusicPerformance8,
    public IDirectMusicTool,
    public IDirectMusicGraph,
    public IDirectMusicPerformanceStats,
    public IDirectMusicPerformanceP,
    public IDirectMusicSetParamHook
{
    friend class CAudioPath;
    friend class CSegState;
    friend class CBufferManager;

public:
    CPerformance();
    ~CPerformance();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPerformance
    STDMETHODIMP Init(IDirectMusic** ppDirectMusic,LPDIRECTSOUND pDSound,HWND hWnd );
    STDMETHODIMP PlaySegment(IDirectMusicSegment *pSegment,DWORD dwFlags,
        __int64 i64StartTime,IDirectMusicSegmentState **ppSegmentState);
    STDMETHODIMP Stop(IDirectMusicSegment *pSegment,
        IDirectMusicSegmentState *pSegmentState,MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetSegmentState(IDirectMusicSegmentState **ppSegmentState,MUSIC_TIME mtTime);
    STDMETHODIMP SetPrepareTime(DWORD dwMilliSeconds);
    STDMETHODIMP GetPrepareTime(DWORD* pdwMilliSeconds);
    STDMETHODIMP SetBumperLength(DWORD dwMilliSeconds);
    STDMETHODIMP GetBumperLength(DWORD* pdwMilliSeconds);
    STDMETHODIMP SendPMsg(DMUS_PMSG *pPMsg);
    STDMETHODIMP MusicToReferenceTime(MUSIC_TIME mtTime,REFERENCE_TIME *prtTime);
    STDMETHODIMP ReferenceToMusicTime(REFERENCE_TIME rtTime,MUSIC_TIME *pmtTime);
    STDMETHODIMP IsPlaying(IDirectMusicSegment *pSegment,IDirectMusicSegmentState *pSegState);
    STDMETHODIMP GetTime(REFERENCE_TIME *prtNow,MUSIC_TIME  *pmtNow);
    STDMETHODIMP AllocPMsg(ULONG cb,DMUS_PMSG** ppPMsg);
    STDMETHODIMP FreePMsg(DMUS_PMSG* pPMsg);
    STDMETHODIMP SetNotificationHandle(HANDLE hNotificationEvent,REFERENCE_TIME rtMinimum);
    STDMETHODIMP GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddPort(IDirectMusicPort* pPort);
    STDMETHODIMP RemovePort(IDirectMusicPort* pPort);
    STDMETHODIMP AssignPChannelBlock(DWORD dwBlockNum,IDirectMusicPort* pPort,DWORD dwGroup);
    STDMETHODIMP AssignPChannel(DWORD dwPChannel,IDirectMusicPort* pPort,DWORD dwGroup,DWORD dwMChannel);
    STDMETHODIMP PChannelInfo(DWORD dwPChannel,IDirectMusicPort** ppPort,DWORD* pdwGroup,DWORD* pdwMChannel);
    STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInst,DWORD dwPChannel, 
                IDirectMusicDownloadedInstrument**,DMUS_NOTERANGE* pNoteRanges,
                DWORD dwNumNoteRanges,IDirectMusicPort**,DWORD*,DWORD*);
    STDMETHODIMP Invalidate(MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP GetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP SetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP GetLatencyTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP GetQueueTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP AdjustTime(REFERENCE_TIME rtAmount);
    STDMETHODIMP CloseDown(void);
    STDMETHODIMP GetResolvedTime(REFERENCE_TIME rtTime,REFERENCE_TIME* prtResolved,DWORD dwFlags);
    STDMETHODIMP MIDIToMusic(BYTE bMIDIValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,WORD *pwMusicValue);
    STDMETHODIMP MusicToMIDI(WORD wMusicValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,BYTE *pbMIDIValue);
    STDMETHODIMP TimeToRhythm(MUSIC_TIME mtTime,DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,BYTE *pbBeat,BYTE *pbGrid,short *pnOffset);
    STDMETHODIMP RhythmToTime(WORD wMeasure,BYTE bBeat,BYTE bGrid,
                short nOffset,DMUS_TIMESIGNATURE *pTimeSig,MUSIC_TIME *pmtTime);   
    //  IDirectMusicPerformance8 
    STDMETHODIMP InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,                          
                           DMUS_AUDIOPARAMS *pParams);
    STDMETHODIMP PlaySegmentEx(IUnknown* pSource, 
                    WCHAR *pwzSegmentName,
                    IUnknown* pTransition,
                    DWORD dwFlags, 
                    __int64 i64StartTime, 
                    IDirectMusicSegmentState** ppSegmentState,
                    IUnknown *pFrom,
                    IUnknown *pAudioPath); 
    STDMETHODIMP StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags) ;
    STDMETHODIMP ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG) ;
    STDMETHODIMP CreateAudioPath( IUnknown *pSourceConfig, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);
    STDMETHODIMP CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);    
    STDMETHODIMP SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath) ;
    STDMETHODIMP GetDefaultAudioPath(IDirectMusicAudioPath **pAudioPath) ;
    STDMETHODIMP GetParamEx(REFGUID rguidType,
                    DWORD dwTrackID,
                    DWORD dwGroupBits,
                    DWORD dwIndex,
                    MUSIC_TIME mtTime,
                    MUSIC_TIME* pmtNext,
                    void* pParam); 

// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph);
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg);
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg,REFERENCE_TIME mtTime);
    STDMETHODIMP GetMsgDeliveryType(DWORD*);
    STDMETHODIMP GetMediaTypeArraySize(DWORD*);
    STDMETHODIMP GetMediaTypes(DWORD**,DWORD);

// IDirectMusicGraph
    STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg( DMUS_PMSG* pPMsg );
// IDirectMusicPerformanceStats 
    STDMETHODIMP TraceAllSegments() ;
    STDMETHODIMP CreateSegstateList(DMUS_SEGSTATEDATA ** ppList) ;     
    STDMETHODIMP FreeSegstateList(DMUS_SEGSTATEDATA * pList) ;     
// IDirectMusicPerformanceP
    STDMETHODIMP GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags);
// IDirectMusicSetParamHook 
    STDMETHODIMP SetParamHook(IDirectMusicParamHook *pIHook); 

// Access from segstate, audiopath and segment...
    HRESULT GetGraphInternal(IDirectMusicGraph** ppGraph);
    HRESULT FlushVirtualTrack(DWORD dwId,MUSIC_TIME mtTime, BOOL fLeaveNotesOn);
    HRESULT GetControlSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPriSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPathPort(CPortConfig *pConfig);
    void RemoveUnusedPorts();
    DWORD GetPortID(IDirectMusicPort * pPort);
    HRESULT AddPort(IDirectMusicPort* pPort,GUID *pguidPortID,
        DMUS_PORTPARAMS8 *pParams,DWORD *pdwPortID);
private:
    // private member functions
    void Init();
    friend DWORD WINAPI _Transport(LPVOID);
    friend DWORD WINAPI _Realtime(LPVOID);   
    HRESULT CreateThreads();
    HRESULT AllocPMsg(ULONG cb,PRIV_PMSG** ppPMsg);
    HRESULT FreePMsg(PRIV_PMSG* pPMsg);
    inline bool SendShortMsg(IDirectMusicBuffer* pBuffer,
                               IDirectMusicPort* pPort,DWORD dwMsg,
                               REFERENCE_TIME rt, DWORD dwGroup);
    HRESULT PackNote(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackCurve(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackMidi(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackSysEx(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackPatch(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackWave(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    void SendBuffers();
    void Realtime();
    void Transport();
    void ProcessEarlyPMsgs();
    PRIV_PMSG *GetNextPMsg();
    REFERENCE_TIME GetTime();
    REFERENCE_TIME GetLatency();
    REFERENCE_TIME GetBestSegLatency( CSegState* pSeg );
    void PrepSegToPlay(CSegState *pSegState, bool fQueue = false);
    void ManageControllingTracks();
    void PerformSegStNode(DWORD dwList,CSegState* pSegStNode);
    void AddEventToTempoMap( PRIV_PMSG* pPMsg );
    void FlushMainEventQueues( DWORD, MUSIC_TIME mtFlush,  MUSIC_TIME mtFlushUnresolved, BOOL fLeaveNotesOn); // flush all events in all queues.
    void FlushEventQueue( DWORD dwId,CPMsgQueue *pQueue, REFERENCE_TIME rtFlush, REFERENCE_TIME rtFlushUnresolved, BOOL fLeaveNotesOn );
    void ClearMusicStoppedNotification();
    HRESULT PlayOneSegment(
        CSegment* pSegment, 
        DWORD dwFlags, 
        __int64 i64StartTime, 
        CSegState **ppSegState,
        CAudioPath *pAudioPath);
    HRESULT PlaySegmentInternal( CSegment* pSegment, 
        CSong * pSong,
        WCHAR *pwzSegmentName,
        CSegment* pTransition,
        DWORD dwFlags, 
        __int64 i64StartTime, 
        IDirectMusicSegmentState** ppSegmentState,
        IUnknown *pFrom,
        CAudioPath *pAudioPath);
    CSegState *GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom);
    void QueuePrimarySegment( CSegState* pSeg );
    void QueueSecondarySegment( CSegState* pSeg );
    void CalculateSegmentStartTime( CSegState* pSeg );
    MUSIC_TIME ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize );
    void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig );
    void SyncTimeSig( CSegState *pSegState );
    void DequeueAllSegments();
    void AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime );
    void UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas = true);
    void IncrementTempoMap();
    void RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtOffset, bool fAllDeltas = true);
    void RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime );
    void AddNotificationTypeToAllSegments( REFGUID rguidNotification );
    void RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification );
    CNotificationItem* FindNotification( REFGUID rguidNotification );
    HRESULT GetPort(DWORD dwPortID, IDirectMusicPort **ppPort);
    HRESULT AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup);
    HRESULT AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel);
    HRESULT ReleasePChannel(DWORD dwPChannel);
    CChannelMap * GetPChannelMap( DWORD dwPChannel );
    HRESULT AssignPChannelBlock(DWORD dwBlockNum,DWORD dwPortIndex,DWORD dwGroup,WORD wFlags);
    HRESULT AssignPChannel(DWORD dwPChannel,DWORD dwPortIndex,DWORD dwGroup,DWORD dwMChannel,WORD wFlags);
    HRESULT PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
                DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose = NULL );
    void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime, IDirectMusicSegmentState* pSegSt );
    CSegState* GetPrimarySegmentAtTime( MUSIC_TIME mtTime );
    void ResetAllControllers( REFERENCE_TIME rtTime);
    void ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset);
    void DoStop( CSegState* pSegState, MUSIC_TIME mtTime, BOOL fInvalidate );
    void DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate );
    HRESULT GetChordNotificationStatus(
		DMUS_NOTE_PMSG* pNote, 
		DWORD dwTrackGroup, 
		REFERENCE_TIME rtTime, 
		DMUS_PMSG** ppNew);
	void OnChordUpdateEventQueues( DMUS_NOTIFICATION_PMSG* pNotify);
	void OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush );
#ifdef DBG
    void TraceAllChannelMaps();
#endif

    // private member variables
    IDirectMusic8*      m_pDirectMusic;
    IDirectSound8*      m_pDirectSound;
    IReferenceClock*    m_pClock;
    IDirectMusicGraph*  m_pGraph;
    CAudioPath *        m_pDefaultAudioPath; // Default audio path.
    DWORD               m_dwNumPorts; // the number of ports
    PortTable*          m_pPortTable; // array of ports, number equals m_dwNumPorts
    CChannelBlockList   m_ChannelBlockList; // List of pchannel maps, in blocks of 16
    CChannelBlockList   m_FreeChannelBlockList; // List of pchannel maps that are no longer in use
    CSegStateList       m_SegStateQueues[SQ_COUNT]; // Lists of all active segment states.
    CSegStateList       m_ShutDownQueue;    // List of segments that are pending shutdown.

    CAudioPathList      m_AudioPathList; // List of all active audio paths in this performance.
    CBufferManager      m_BufferManager; // List of all buffers currently in use.
    DMUS_AUDIOPARAMS    m_AudioParams;  // Initial requirements, as set in InitAudio, by app. 

    HANDLE      m_hNotification; // notification handle set in SetNotificationHandle
    REFERENCE_TIME  m_rtNotificationDiscard; // minimum time to hold onto a notification message
    CNotificationList   m_NotificationList;
    GlobalData* m_pGlobalData; // list of global data structs

    DWORD       m_dwAudioPathMode;  // 0 for not yet set, 1 for old methods, 2 for using AudioPaths.
    BOOL        m_fInTransportThread; // This is used to signal that the transport thread
                                     // is active and the realtime thread should hold
                                     // off on processing the early queue.
	BOOL		m_fInTrackPlay;		// This is used to signal that a track is in the process of
									// generating events. These will have the PRIV_FLAG_TRACK flag set.
    CPMsgQueue m_EarlyQueue;        // List of PMsgs that play immediately.
    CPMsgQueue m_NearTimeQueue;     // List of PMsgs that play a little early.
    CPMsgQueue m_OnTimeQueue;       // List of PMsgs that play exactly when due.
    CPMsgQueue m_TempoMap;          // List of tempo changes.
    CPMsgQueue m_OldTempoMap;       // List of old tempo changes.
    CPMsgQueue m_NotificationQueue; // List of notification messages.
    CPMsgQueue m_TimeSigQueue;      // List of time signature changes.

    // cache of allocated pmsg's
#define PERF_PMSG_CB_MIN 48
#define PERF_PMSG_CB_MAX 101
    PRIV_PMSG* m_apPMsgCache[ PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN ];

    DWORD            m_dwInitCS;
    CRITICAL_SECTION m_PMsgCacheCrSec;
    CRITICAL_SECTION m_SegmentCrSec;
    CRITICAL_SECTION m_PipelineCrSec;   // For all the CPMsgQueues
    CRITICAL_SECTION m_PChannelInfoCrSec;
    CRITICAL_SECTION m_GlobalDataCrSec;
    CRITICAL_SECTION m_RealtimeCrSec;
    CRITICAL_SECTION m_MainCrSec;

    HANDLE          m_hTransport;       // to wake up the Transport thread when needed
    HANDLE          m_hRealtime;
    HANDLE          m_hTransportThread; // to kill the Transport thread if needed
    HANDLE          m_hRealtimeThread;

    REFERENCE_TIME  m_rtStart;          // time when this performance started
    REFERENCE_TIME  m_rtAdjust;         // adjustment time to compensate for e.g. smpte drift
    REFERENCE_TIME  m_rtHighestPackedNoteOn; // highest time of packed note on
    REFERENCE_TIME  m_rtEarliestStartTime; // Time of last Stop(0,0,0). New segment can not start before this.
    REFERENCE_TIME  m_rtQueuePosition;  // the highest time a message has been packed, or the latency + m_rtBumperLength, whichever is greater
    REFERENCE_TIME  m_rtNextWakeUp;     // Next time the pipeline thread needs to wake up to deliver a message.
    REFERENCE_TIME  m_rtBumperLength;   // Distance ahead of latency clock to send events down to synth.
    MUSIC_TIME      m_mtTransported;    // the highest time transported
    MUSIC_TIME      m_mtPlayTo;         // the time to play to on the next transport cycle
    MUSIC_TIME      m_mtTempoCursor;    // Tempo map has been generated up to this point.
    DWORD           m_dwPrepareTime;    // time ahead, in milliseconds, to transport
    DWORD           m_dwBumperLength;   // Millisecond version of m_rtBumperLength. 
    long            m_lMasterVolume;    // master volume.
    float           m_fltRelTempo;      // relative tempo, can be from 0 to 200
    long            m_cRef;
    WORD            m_wRollOverCount;   // tracks when timeGetTime rolls over
    DWORD           m_dwTransportThreadID;  // transport thread id
    DWORD           m_dwRealtimeThreadID;
    BOOL            m_fKillThread;      // signal to transport thread to die
    BOOL            m_fKillRealtimeThread;
    BOOL            m_fPlaying;
    BOOL            m_fMusicStopped;
    BOOL            m_fTempoChanged;    // When a tempo change occurs, refresh transport so clock time tracks don't get clobbered.

    IUnknown *      m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    DWORD           m_dwVersion;        // Version number, indicating DX6, DX7, or DX8. Determined by which interface requested.
    IDirectMusicSegmentState * m_pGetParamSegmentState; // Set prior to playing a segment, so GetParam() can know which segment called it.
    DWORD           m_dwGetParamFlags;  // Set prior to playing a segment track, so GetParam() can know how to search for the parameter.
    IDirectMusicParamHook * m_pParamHook;
    bool            m_fReleasedInTransport; // The performance had its final release in the transport thread
    bool            m_fReleasedInRealtime; // The performance had its final release in the realtime thread
};

#endif // _DMPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmperf.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmperf.cpp

#include <windows.h>
#include <mmsystem.h>
#include <time.h>       // To seed random number generator
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "dmperf.h"
#include "dmime.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "song.h"
#include "curve.h"
#include "math.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstylep.h"
#include <ks.h>
#include "dmksctrl.h"
#include <dsound.h>
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"
#include "wavtrack.h"
#include "tempotrk.h"
#include <strsafe.h>

#pragma warning(disable:4296)

#define PORT_CHANNEL 0

// @doc EXTERNAL
#define MIDI_NOTEOFF        0x80
#define MIDI_NOTEON         0x90
#define MIDI_PTOUCH         0xA0
#define MIDI_CCHANGE        0xB0
#define MIDI_PCHANGE        0xC0
#define MIDI_MTOUCH         0xD0
#define MIDI_PBEND          0xE0
#define MIDI_SYSX           0xF0
#define MIDI_MTC            0xF1
#define MIDI_SONGPP         0xF2
#define MIDI_SONGS          0xF3
#define MIDI_EOX            0xF7
#define MIDI_CLOCK          0xF8
#define MIDI_START          0xFA
#define MIDI_CONTINUE       0xFB
#define MIDI_STOP           0xFC
#define MIDI_SENSE          0xFE
#define MIDI_CC_BS_MSB      0x00
#define MIDI_CC_BS_LSB      0x20
#define MIDI_CC_DATAENTRYMSB 0x06
#define MIDI_CC_DATAENTRYLSB 0x26
#define MIDI_CC_NRPN_LSB    0x62
#define MIDI_CC_NRPN_MSB    0x63
#define MIDI_CC_RPN_LSB     0x64
#define MIDI_CC_RPN_MSB     0x65
#define MIDI_CC_MOD_WHEEL   0x01
#define MIDI_CC_VOLUME      0x07
#define MIDI_CC_PAN         0x0A
#define MIDI_CC_EXPRESSION  0x0B
#define MIDI_CC_FILTER      0x4A
#define MIDI_CC_REVERB      0x5B
#define MIDI_CC_CHORUS      0x5D
#define MIDI_CC_RESETALL    0x79
#define MIDI_CC_ALLSOUNDSOFF 0x78

#define CLEARTOOLGRAPH(x)   { \
    if( (x)->pTool ) \
    { \
        (x)->pTool->Release(); \
        (x)->pTool = NULL; \
    } \
    if( (x)->pGraph ) \
    { \
        (x)->pGraph->Release(); \
        (x)->pGraph = NULL; }}

#define GetLatencyWithPrePlay() ( GetLatency() + m_rtBumperLength )

void CChannelBlockList::Clear()
{
    CChannelBlock* pCB;
    while( pCB = RemoveHead() )
    {
        delete pCB;
    }
}

void CChannelMap::Clear()

{
    Reset(TRUE);                // Clear all MIDI controllers
    m_TransposeMerger.Clear(0); // No transpose.
    nTranspose = 0;
    wFlags = CMAP_FREE;
}

void CChannelMap::Reset(BOOL fVolumeAndPanToo)

{
    if (fVolumeAndPanToo)
    {
        m_PanMerger.Clear(0);       // Panned to center.
        m_VolumeMerger.Clear(-415); // Equivalent to MIDI value 100.
    }
    m_PitchbendMerger.Clear(0); // No pitch bend.
    m_ExpressionMerger.Clear(0);// Full volume for expression (MIDI 127.)
    m_FilterMerger.Clear(0);    // No filter change.
    m_ReverbMerger.Clear(-87); // Start at default level (MIDI 40).
    m_ChorusMerger.Clear(-127);    // Start with no chorus.
    m_ModWheelMerger.Clear(-127);  // Start with no mod wheel.
}

void CParamMerger::Clear(long lInitValue )

{
    CMergeParam *pParam;
    while (pParam = RemoveHead())
    {
        delete pParam;
    }
    m_lZeroIndexData = lInitValue;
    m_lMergeTotal = 0;
}


long CParamMerger::m_lMIDIToDB[128] = {       // Global array used to convert MIDI to dB.
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034,
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710,
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968,
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449,
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050,
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726,
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453,
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217,
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010,
    -985, -961, -938, -914, -891, -869, -846, -824,
    -802, -781, -759, -738, -718, -697, -677, -657,
    -637, -617, -598, -579, -560, -541, -522, -504,
    -486, -468, -450, -432, -415, -397, -380, -363,
    -347, -330, -313, -297, -281, -265, -249, -233,
    -218, -202, -187, -172, -157, -142, -127, -113,
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CParamMerger::m_lDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
};


CParamMerger::CParamMerger()
{
    m_lMergeTotal = 0;
    m_lZeroIndexData = 0;
}

BYTE CParamMerger::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_lDBToMIDI[lVolume];
    lResult += ((m_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

/*  MergeMidiVolume() takes an incoming volume and updates the matching
    MergeParam structure (determined by index.) If there is no such matching
    structure, it creates one. Also, the volumes are totaled to create a new
    total volume, which is converted back to MIDI volume and returned.
    This mechanism allows us to introduce additional volume controllers
    that are summed.
*/

BYTE CParamMerger::MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume)

{
    long lVolume = MergeData(dwIndex,m_lMIDIToDB[bMIDIVolume]);
    if (m_lMergeTotal || dwIndex) // Optimization for simplest and most frequent case - there are no additional indexes.
    {
        return (BYTE) VolumeToMidi(lVolume);
    }
    return bMIDIVolume;
}

BYTE CParamMerger::GetVolumeStart(DWORD dwIndex)

{
    if (dwIndex == 0)
    {
        return VolumeToMidi(m_lZeroIndexData);
    }
    return VolumeToMidi(GetIndexedValue(dwIndex));
}

/*  MergeValue is used for all data types that have a plus and minus range
    around a center bias. These include pitch bend, pan and filter.
    MergeValue takes an incoming data value, adds the bias (in lRange),
    calls MergeData to combine it with the other merged inputs,
    adds the bias back in and checks for over or underflow.
*/

long CParamMerger::MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange)

{
    lData = MergeData(dwIndex,lData - lCenter) + lCenter;
    if (lData < 0) lData = 0;
    if (lData > lRange) lData = lRange;
    return lData;
}


short CParamMerger::MergeTranspose(DWORD dwIndex, short nTranspose)

{
    return (short) MergeData(dwIndex,nTranspose);
}

long CParamMerger::MergeData(DWORD dwIndex, long lData)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, update it
        // with the new data. Meanwhile, add up all the data fields.
        // If it is not found, add an entry for it.
        m_lMergeTotal = 0;   // Recalculate
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                // Found the index. Store the new value.
                pParam->m_lData = lData;
                fNoEntry = FALSE;
            }
            // Sum all values to create the merged total.
            m_lMergeTotal += pParam->m_lData;
        }
        if (fNoEntry)
        {
            // Didn't find the index. Create one and store the value.
            pParam = new CMergeParam;
            if (pParam)
            {
                pParam->m_dwIndex = dwIndex;
                pParam->m_lData = lData;
                m_lMergeTotal += lData;
                AddHead(pParam);
            }
        }
        // Add the initial value for merge index 0.
        lData = m_lMergeTotal + m_lZeroIndexData;
    }
    else
    {
        m_lZeroIndexData = lData;
        lData += m_lMergeTotal;
    }
    return lData;
}


long CParamMerger::GetIndexedValue(DWORD dwIndex)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, return its data.
        // If not, return the default 0.
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                return pParam->m_lData;
            }
        }
        return 0;
    }
    return m_lZeroIndexData;
}

void CChannelBlock::Init(DWORD dwPChannelStart,
                         DWORD dwPortIndex, DWORD dwGroup,
                         WORD wFlags)

{
    DWORD dwIndex;
    m_dwPortIndex = dwPortIndex;
    m_dwPChannelStart = ( dwPChannelStart / PCHANNEL_BLOCKSIZE ) * PCHANNEL_BLOCKSIZE;
    for( dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++ )
    {
        m_aChannelMap[dwIndex].Clear();
        m_aChannelMap[dwIndex].dwPortIndex = dwPortIndex;
        m_aChannelMap[dwIndex].dwGroup = dwGroup;
        m_aChannelMap[dwIndex].dwMChannel = dwIndex;
        m_aChannelMap[dwIndex].nTranspose = 0;
        m_aChannelMap[dwIndex].wFlags = wFlags;
    }
    if (wFlags == CMAP_FREE) m_dwFreeChannels = 16;
    else m_dwFreeChannels = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPerformance

// Flags for which critical sections have been initialized
//

#define PERF_ICS_SEGMENT        0x0001
#define PERF_ICS_PIPELINE       0x0002
#define PERF_ICS_PCHANNEL       0x0004
#define PERF_ICS_GLOBAL         0x0010
#define PERF_ICS_REALTIME       0x0020
#define PERF_ICS_PORTTABLE      0x0040
#define PERF_ICS_MAIN           0x0100
#define PERF_ICS_PMSGCACHE      0x0200

CPerformance::CPerformance()
{
    m_pGraph = NULL;
    m_dwPrepareTime = 1000;
    m_dwBumperLength = 50;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    m_pGlobalData = NULL;
    m_fInTrackPlay = FALSE;
    m_fPlaying = FALSE;
    m_wRollOverCount = 0;
    m_mtTransported = 0;
    m_mtTempoCursor = 0;
    m_pParamHook = NULL;
    m_hNotification = 0;
    m_rtNotificationDiscard = 20000000;
    m_rtStart = 0;
    m_rtAdjust = 0;
    m_mtPlayTo = 0;
    m_cRef = 1;
    m_pUnkDispatch = NULL;
    m_dwVersion = 6;
    m_dwNumPorts = 0;
    m_pPortTable = NULL;
    m_fKillThread = 0;
    m_fKillRealtimeThread = 0;
    m_fInTransportThread = 0;
    m_dwTransportThreadID = 0;
    m_pDirectMusic = NULL;
    m_pDirectSound = NULL;
    m_pClock = NULL;
    m_fReleasedInTransport = false;
    m_fReleasedInRealtime = false;
    InterlockedIncrement(&g_cComponent);

    TraceI(3,"CPerformance %lx\n", this);
    m_dwInitCS = 0;

    InitializeCriticalSection(&m_SegmentCrSec);         m_dwInitCS |= PERF_ICS_SEGMENT;
    InitializeCriticalSection(&m_PipelineCrSec);        m_dwInitCS |= PERF_ICS_PIPELINE;
    InitializeCriticalSection(&m_PChannelInfoCrSec);    m_dwInitCS |= PERF_ICS_PCHANNEL;
    InitializeCriticalSection(&m_GlobalDataCrSec);      m_dwInitCS |= PERF_ICS_GLOBAL;
    InitializeCriticalSection(&m_RealtimeCrSec);        m_dwInitCS |= PERF_ICS_REALTIME;
    InitializeCriticalSection(&m_PMsgCacheCrSec);       m_dwInitCS |= PERF_ICS_PMSGCACHE;
    InitializeCriticalSection(&m_MainCrSec);            m_dwInitCS |= PERF_ICS_MAIN;
    memset( m_apPMsgCache, 0, sizeof(DMUS_PMSG*) * (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN) );
    DWORD dwCount;
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        m_SegStateQueues[dwCount].SetID(dwCount);
    }
    Init();
}

void CPerformance::Init()

{
    m_rtEarliestStartTime = 0;
    m_lMasterVolume = 0;
    if (m_dwVersion >= 8)
    {
        m_rtQueuePosition = 0;
        m_dwPrepareTime = 1000;
        m_dwBumperLength = 50;
        m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
        if (m_dwAudioPathMode)
        {
            CloseDown();
        }
    }
    m_pDefaultAudioPath = NULL;
    m_fltRelTempo = 1;
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    m_rtHighestPackedNoteOn = 0;
    m_dwAudioPathMode = 0;
    m_hTransport = 0;
    m_hTransportThread = 0;
    m_dwRealtimeThreadID = 0;
    m_hRealtime = 0;
    m_hRealtimeThread = 0;
    m_fMusicStopped = TRUE;
    BOOL fAuto = FALSE;
    SetGlobalParam(GUID_PerfAutoDownload,&fAuto,sizeof(BOOL));
    DMUS_TIMESIG_PMSG* pTimeSig;
    if (SUCCEEDED(AllocPMsg(sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG **) &pTimeSig)))
    {
        pTimeSig->wGridsPerBeat = 4;
        pTimeSig->bBeatsPerMeasure = 4;
        pTimeSig->bBeat = 4;
        pTimeSig->dwFlags = DMUS_PMSGF_REFTIME;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        EnterCriticalSection(&m_PipelineCrSec);
        m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pTimeSig) );
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

CPerformance::~CPerformance()
{
    TraceI(3,"~CPerformance %lx\n", this);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    CloseDown(); // this should have already been called, but just in case...
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

    if (m_dwInitCS & PERF_ICS_SEGMENT)  DeleteCriticalSection(&m_SegmentCrSec);
    if (m_dwInitCS & PERF_ICS_PIPELINE) DeleteCriticalSection(&m_PipelineCrSec);
    if (m_dwInitCS & PERF_ICS_PCHANNEL) DeleteCriticalSection(&m_PChannelInfoCrSec);
    if (m_dwInitCS & PERF_ICS_GLOBAL)   DeleteCriticalSection(&m_GlobalDataCrSec);
    if (m_dwInitCS & PERF_ICS_REALTIME) DeleteCriticalSection(&m_RealtimeCrSec);
    if (m_dwInitCS & PERF_ICS_PMSGCACHE)DeleteCriticalSection(&m_PMsgCacheCrSec);
    if (m_dwInitCS & PERF_ICS_MAIN)     DeleteCriticalSection(&m_MainCrSec);

    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CPerformance::CloseDown(void)
{
    V_INAME(CPerformance::CloseDown);
    DWORD dwThreadID = GetCurrentThreadId();
    if( m_dwAudioPathMode )
    {
        // kill the transport thread
        m_fKillThread = 1;
        m_fKillRealtimeThread = 1;
        if (dwThreadID != m_dwTransportThreadID)
        {
            // signal the transport thread so we don't have to wait for it to wake up on its own
            if( m_hTransport ) SetEvent( m_hTransport );
            // wait until the transport thread quits
            WaitForSingleObject(m_hTransportThread, INFINITE);
        }
        if (dwThreadID != m_dwRealtimeThreadID)
        {
            // signal the realtime thread so we don't have to wait for it to wake up on its own
            if( m_hRealtime ) SetEvent( m_hRealtime );
            // wait until the realtime thread quits
            WaitForSingleObject(m_hRealtimeThread, INFINITE);
        }
    }

    if (m_pGraph) SetGraph(NULL); // shut down the graph and release it (needs to happen before clearing audio path)

    EnterCriticalSection(&m_SegmentCrSec);
    EnterCriticalSection(&m_RealtimeCrSec);

    m_fPlaying = FALSE; // prevents transport thread from doing anything more
    IDirectMusicPerformance* pPerf = NULL;
    if (SUCCEEDED(QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)))
    {
        CWavTrack::UnloadAllWaves(pPerf);
        pPerf->Release();
    }
    DequeueAllSegments();
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_dwAudioPathMode = 0;
    m_AudioPathList.Clear();
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        CNotificationItem* pNext = pItem->GetNext();
        m_NotificationList.Remove( pItem );
        delete pItem;
        pItem = pNext;
    }
    LeaveCriticalSection(&m_RealtimeCrSec);
    LeaveCriticalSection(&m_SegmentCrSec);

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    while( pPMsg = m_EarlyQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NearTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OnTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OldTempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NotificationQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TimeSigQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }

    LeaveCriticalSection(&m_PipelineCrSec);

    EnterCriticalSection(&m_GlobalDataCrSec);
    GlobalData* pGD = m_pGlobalData;
    while( pGD )
    {
        m_pGlobalData = pGD->pNext;
        delete pGD;
        pGD = m_pGlobalData;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);

    EnterCriticalSection(&m_PChannelInfoCrSec);
    // clear out ports, buffers, and pchannel maps
    if( m_pPortTable )
    {
        DWORD dwIndex;
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pPort )
            {
                m_pPortTable[dwIndex].pPort->Release();
            }
            if( m_pPortTable[dwIndex].pBuffer )
            {
                m_pPortTable[dwIndex].pBuffer->Release();
            }
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
        }
        delete [] m_pPortTable;
        m_pPortTable = NULL;
        m_dwNumPorts = 0;
    }
    m_ChannelBlockList.Clear();
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock )
    {
        m_pClock->Release();
        m_pClock = NULL;
    }
    m_BufferManager.Clear();
    if( m_pDirectMusic )
    {
        m_pDirectMusic->Release();
        m_pDirectMusic = NULL;
    }
    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
    m_hNotification = NULL;
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection(&m_PMsgCacheCrSec);
    for( int i = 0; i < (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN); i++ )
    {
        while( m_apPMsgCache[i] )
        {
            PRIV_PMSG* pPriv = m_apPMsgCache[i];
            m_apPMsgCache[i] = pPriv->pNext;
            delete [] pPriv;
        }
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);

    DWORD dwExitCode = 0;
    if (m_hTransportThread)
    {
        CloseHandle( m_hTransportThread );
        m_hTransportThread = 0;
    }
    if( m_hTransport )
    {
        CloseHandle( m_hTransport );
        m_hTransport = 0;
    }
    if (m_hRealtimeThread)
    {
        CloseHandle( m_hRealtimeThread );
        m_hRealtimeThread = 0;
    }
    if( m_hRealtime )
    {
        CloseHandle( m_hRealtime );
        m_hRealtime = 0;
    }
    m_mtPlayTo = 0;
    return S_OK;
}

// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CPerformance::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CPerformance::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPerformance)
    {
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicPerformance8*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance2)
    {
        m_dwVersion = 7;
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if( iid == IID_IDirectMusicPerformanceStats )
    {
        *ppv = static_cast<IDirectMusicPerformanceStats*>(this);
    } else
    if( iid == IID_IDirectMusicSetParamHook )
    {
        *ppv = static_cast<IDirectMusicSetParamHook*>(this);
    } else
    if (iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } else
    if (iid == IID_CPerformance)
    {
        *ppv = static_cast<CPerformance*>(this);
    }
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    if (iid == IID_IDirectMusicPerformanceP)
    {
        *ppv = static_cast<IDirectMusicPerformanceP*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicPerformance,
                static_cast<IDirectMusicPerformance*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }
    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Performance object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | AddRef | Standard AddRef implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | Release | Standard Release implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DWORD dwThreadID = GetCurrentThreadId();
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        if (dwThreadID == m_dwTransportThreadID)
        {
            m_fReleasedInTransport = true;
            m_fKillThread = TRUE;
        }
        else if (dwThreadID == m_dwRealtimeThreadID)
        {
            m_fReleasedInRealtime = true;
            m_fKillRealtimeThread = TRUE;
        }
        else
        {
            delete this;
        }
        return 0;
    }

    return m_cRef;
}

// call this only from within a m_SegmentCrSec critical section
// if fSendNotify, then send segment end notifications for segments that were
// playing
void CPerformance::DequeueAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        while( pNode = m_SegStateQueues[dwCount].RemoveHead())
        {
            pNode->ShutDown();
        }
    }
    while( pNode = m_ShutDownQueue.RemoveHead())
    {
        pNode->ShutDown();
    }
}

// IDirectMusicPerformanceStats

STDMETHODIMP CPerformance::TraceAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            TraceI(0,"%x %ld: Playing: %ld, Start: %ld, Seek: %ld, LastPlayed: %ld\n",
                pNode,dwCount,pNode->m_fStartedPlay, pNode->m_mtResolvedStart,
                pNode->m_mtSeek, pNode->m_mtLastPlayed);
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::CreateSegstateList(DMUS_SEGSTATEDATA ** ppList)

{
    if (!ppList) return E_POINTER;
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            DMUS_SEGSTATEDATA *pData = new DMUS_SEGSTATEDATA;
            if (pData)
            {
                CSegment *pSegment = pNode->m_pSegment;
                if (pSegment && (pSegment->m_dwValidData & DMUS_OBJ_NAME))
                {
                    StringCchCopyW(pData->wszName, DMUS_MAX_NAME, pSegment->m_wszName);
                }
                else
                {
                    pData->wszName[0] = 0;
                }
                pData->dwQueue = dwCount;
                pData->pSegState = (IDirectMusicSegmentState *) pNode;
                pNode->AddRef();
                pData->pNext = *ppList;
                pData->mtLoopEnd = pNode->m_mtLoopEnd;
                pData->mtLoopStart = pNode->m_mtLoopStart;
                pData->dwRepeats = pNode->m_dwRepeats;
                pData->dwPlayFlags = pNode->m_dwPlaySegFlags;
                pData->mtLength = pNode->m_mtLength;
                pData->rtGivenStart = pNode->m_rtGivenStart;
                pData->mtResolvedStart = pNode->m_mtResolvedStart;
                pData->mtOffset = pNode->m_mtOffset;
                pData->mtLastPlayed = pNode->m_mtLastPlayed;
                pData->mtPlayTo = pNode->m_mtStopTime;
                pData->mtSeek = pNode->m_mtSeek;
                pData->mtStartPoint = pNode->m_mtStartPoint;
                pData->dwRepeatsLeft = pNode->m_dwRepeatsLeft;
                pData->fStartedPlay = pNode->m_fStartedPlay;
                *ppList = pData;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::FreeSegstateList(DMUS_SEGSTATEDATA * pList)

{
    DMUS_SEGSTATEDATA *pState;
    while (pList)
    {
        pState = pList;
        pList = pList->pNext;
        pState->pSegState->Release();
        delete pState;
    }
    return S_OK;
}

void CPerformance::SendBuffers()
{
    DWORD dwIndex;
    PortTable* pPortTable;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].fBufferFilled && m_pPortTable[dwIndex].pBuffer )
        {
            pPortTable = &m_pPortTable[dwIndex];
            pPortTable->fBufferFilled = FALSE;
            ASSERT( pPortTable->pBuffer );
            if( pPortTable->pPort )
            {
                pPortTable->pPort->PlayBuffer( pPortTable->pBuffer );
//  TraceI(5, "SENT BUFFERS time=%ld latency=%ld\n", (long)(GetTime() / 10000),(long)(GetLatency()/10000));
            }
            pPortTable->pBuffer->Flush();
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime SendBuffers %u\n", dwDebugTime);
    }
#endif
}

static DWORD WINAPI _Realtime(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Realtime();
        ::CoUninitialize();
    }
    return 0;
}

void CPerformance::Realtime()
{
    while (!m_fKillRealtimeThread)
    {
        EnterCriticalSection(&m_RealtimeCrSec);
        PRIV_PMSG *pEvent;
        HRESULT hr;
        REFERENCE_TIME  rtFirst = 0;
        REFERENCE_TIME  rtEnter = GetLatencyWithPrePlay();
        DWORD   dwTestTime;
        DWORD   dwBeginTime = timeGetTime();
        DWORD   dwLimitLoop = 0;

        if( rtEnter > m_rtQueuePosition )
        {
            m_rtQueuePosition = rtEnter;
        }

        while (1)
        {
            // rtFirst equals the time that the first event was packed into a buffer.
            // Once this time is greater than the latency clock (minus a delay) we need
            // to queue the buffers so the events get down in time to be rendered.
            // If rtFirst is 0 it means it hasn't been initialized yet.
            dwTestTime = timeGetTime();
            if( dwTestTime - dwBeginTime > REALTIME_RES )
            {
                if( ++dwLimitLoop > 10 )
                {
                    TraceI(1,"Error! We've been in the realtime thread too long!!! Breaking out without completing.\n");
                    break;
                }
                SendBuffers();
                dwBeginTime = dwTestTime;
            }
            pEvent = GetNextPMsg();
            if( NULL == pEvent )
            {
                break;
            }
            ASSERT( pEvent->pNext == NULL );
            if( !pEvent->pTool )
            {
                // this event doesn't have a Tool pointer, so stamp it with the
                // final output Tool.
                pEvent->pTool = (IDirectMusicTool*)this;
                AddRef();
            }

            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
        SendBuffers();
        LeaveCriticalSection(&m_RealtimeCrSec);
        if( m_hRealtime )
        {
            WaitForSingleObject( m_hRealtime, REALTIME_RES );
        }
        else
        {
            Sleep(REALTIME_RES);
        }
    }
    m_fKillRealtimeThread = FALSE;
    TraceI(2, "dmperf: LEAVE realtime\n");
    if (m_fReleasedInRealtime)
    {
        delete this;
    }
}

void CPerformance::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime,
                                          IDirectMusicSegmentState* pSegSt)
{
    GUID guid;
    guid = GUID_NOTIFICATION_PERFORMANCE;
    if( FindNotification( guid ))
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG),
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_PERFORMANCE;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            if( pSegSt )
            {
                pSegSt->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);
            }
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                FreePMsg((DMUS_PMSG*)pEvent);
            }
        }
    }
}

void CPerformance::PrepSegToPlay(CSegState *pSegState, bool fQueue)

/*  Called when a segment is first queued, once the start time of the segment is known.
    This calculates various fields that need to be initialized and also regenerates the
    tempo map if the new segment has an active tempo map in it.
*/

{
    if (!pSegState->m_fPrepped)
    {
        pSegState->m_fPrepped = TRUE;
        pSegState->m_mtLastPlayed = pSegState->m_mtResolvedStart;
        // if this is queued to play after the current segment ends, no need to recalc the tempo map;
        // it will be updated as necessary by the transport thread.
        if (!fQueue)
        {
            RecalcTempoMap(pSegState, pSegState->m_mtResolvedStart);
        }
        MusicToReferenceTime(pSegState->m_mtLastPlayed,&pSegState->m_rtLastPlayed);
        // Calculate the total duration of the segment and store in m_mtEndTime.
        pSegState->m_mtEndTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart);
    }
}

/*

  void | CPerformance | PerformSegStNode |
  Perform a Segment State contained in the CSegState.

  Note that this ppSegStNode may be dequeued, so don't depend on it
  staying around!

*/
void CPerformance::PerformSegStNode(
    DWORD dwList,   // The list the segmentstate comes from.
    CSegState* pSegStNode)  // The segmentstate node.
{
    MUSIC_TIME mtMargin; // tracks how much of a segment to play
    HRESULT hr;
    CSegStateList *pList = &m_SegStateQueues[dwList];
    CSegState *pNext;

    if( !m_fPlaying || m_fInTrackPlay )
    {
        return;
    }
    if( pSegStNode )
    {
        m_fInTransportThread = TRUE;    // Disable realtime processing of early queue messages.
        hr = S_OK;
//Trace(0,"%ld: Performing %lx, Active: %ld, Start Time: %ld, End Time: %ld\n",m_mtPlayTo,
//      pSegStNode->m_pSegment,pSegStNode->m_fStartedPlay,pSegStNode->m_mtResolvedStart,pSegStNode->m_mtEndTime);
        if( !pSegStNode->m_fStartedPlay )
        {
            // check to see if this SegState should start playing.
            ASSERT( !(pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ));
            if( pSegStNode->m_mtResolvedStart < m_mtPlayTo )
            {
                pSegStNode->m_fStartedPlay = TRUE;
                PrepSegToPlay(pSegStNode);
                // send a MUSICSTARTED notification if needed
                if(m_fMusicStopped)
                {
                    m_fMusicStopped = FALSE;
                    GenerateNotification( DMUS_NOTIFICATION_MUSICSTARTED, pSegStNode->m_mtResolvedStart, NULL );
                }
                // We don't want the music to start with a big BLURP in track
                // order, so we send a little dribble out on each track.
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                if( mtMargin >= 50 )
                {
                    hr = pSegStNode->Play( 50 );
                    ProcessEarlyPMsgs();
                    // Once done processing all the early messages, make sure that the realtime
                    // thread wakes up and does whatever it needs to do. This ensures that the starting
                    // notes in a sequence get to the output port immediately.
                    if( m_hRealtime ) SetEvent( m_hRealtime );
                    mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                    // Then, we send a larger chunk out on each track to catch up a little more...
                    if ((hr == S_OK) && ( mtMargin >= 200 ))
                    {
                        hr = pSegStNode->Play( 200 );
                        ProcessEarlyPMsgs();
                    }
                }
            }
            else
            {
                MusicToReferenceTime(pSegStNode->m_mtLastPlayed,&pSegStNode->m_rtLastPlayed);
            }
        }
        if( pSegStNode->m_fStartedPlay )
        {
            if( pSegStNode->m_mtStopTime && ( pSegStNode->m_mtStopTime < m_mtPlayTo ) )
            {
                mtMargin = pSegStNode->m_mtStopTime - pSegStNode->m_mtLastPlayed;
            }
            else
            {
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
            }
            while ((hr == S_OK) && (mtMargin > 0))
            {
                // Do not allow more than a quarter note's worth to be done at once.
                MUSIC_TIME mtRange = mtMargin;
                if (mtRange > DMUS_PPQ)
                {
                    mtRange = DMUS_PPQ;
                    mtMargin -= mtRange;
                }
                else
                {
                    mtMargin = 0;
                }
                hr = pSegStNode->Play( mtRange );
                ProcessEarlyPMsgs();
            }
        }
        if( (hr == DMUS_S_END) || ( pSegStNode->m_mtStopTime &&
                                  ( pSegStNode->m_mtStopTime <= pSegStNode->m_mtLastPlayed ) ) )
        {

            if( pSegStNode->m_mtStopTime && (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed) )
            {
                pSegStNode->AbortPlay(pSegStNode->m_mtStopTime - 1, FALSE);
            }
            MUSIC_TIME mtEnd = pSegStNode->m_mtLastPlayed;
            if( pList == &m_SegStateQueues[SQ_PRI_PLAY] )
            {
                // move primary segments to PriPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_PRI_DONE].Insert(pSegStNode);
                pNext = pList->GetHead();
                if( pNext )
                {
                    if (!( pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE ))
                    {
                        if (IsConQueue(dwList))
                        {
                            Invalidate( pNext->m_mtResolvedStart, 0 );
                        }
                    }
                }
                else    // No more primary segments, send DMUS_NOTIFICATION_MUSICALMOSTEND
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegStNode );
                    }
                }
                ManageControllingTracks();
            }
            else if ( pList == &m_SegStateQueues[SQ_CON_PLAY] )
            {
                pList->Remove(pSegStNode );
                if (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed)
                {
                    m_ShutDownQueue.Insert(pSegStNode);
                }
                else
                {
                    m_SegStateQueues[SQ_CON_DONE].Insert(pSegStNode);
                }
            }
            else
            {
                // move 2ndary segments to SecPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_SEC_DONE].Insert(pSegStNode);
            }
            // if there aren't any more segments to play, send a Music Stopped
            // notification
            if( (m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
                m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
                m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty()))
            {
                m_fMusicStopped = TRUE;
                GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtEnd, NULL );
            }
        }
        m_fInTransportThread = FALSE;
    }
}

static DWORD WINAPI _Transport(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Transport();
        ::CoUninitialize();
    }
    return 0;
}

// call Segment's play code on a periodic basis. This routine is in its
// own thread.
void CPerformance::Transport()
{
    srand((unsigned int)time(NULL));
    while (!m_fKillThread)
    {
        DWORD dwCount;
        CSegState*  pNode;
        CSegState*  pNext;
        CSegState*  pTempQueue = NULL;
        REFERENCE_TIME rtNow = GetTime();

        EnterCriticalSection(&m_SegmentCrSec);
        // Compute the time we should play all the segments to.
        REFERENCE_TIME rtPlayTo = rtNow + PREPARE_TIME;
        MUSIC_TIME mtAmount, mtResult, mtPlayTo;
        mtPlayTo = 0;
        ReferenceToMusicTime( rtPlayTo, &mtPlayTo );
        if (m_fTempoChanged)
        {
            // If there has been a tempo change to slower, any clock time tracks could
            // be delayed to long as the transport holds off sending out events. That's
            // okay for music time tracks, but bad news for clock time tracks. This
            // makes sure that the clock time tracks get a chance to spew.
            if (m_mtPlayTo >= mtPlayTo)
            {
                mtPlayTo = m_mtPlayTo + 10;
            }
            m_fTempoChanged = FALSE;
        }
        IncrementTempoMap();
        while (m_mtPlayTo < mtPlayTo)
        {
            BOOL fDirty = FALSE; // see below
            m_mtPlayTo = mtPlayTo; // Start out optimistic
            // We need to set play boundaries at the end of control segments.
            // The beginnings of control segments are handled inside the segment state code.
            pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
            if( pNode && pNode->m_fStartedPlay )
            {
                mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                pNode->CheckPlay( mtAmount, &mtResult );
                if( mtResult < mtAmount )
                {
                    m_mtPlayTo -= ( mtAmount - mtResult );
                    // don't need dirty flag when primary segment loops or ends normally (bug 30829)
                    // fDirty = TRUE; // see below
                }
            }
            // if a control segment ended prematurely, mtPlayTo will have a value besides 0
            // check for upcoming endings to control segments
            for( pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_fStartedPlay )
                {
                    if( pNode->m_mtStopTime && (m_mtPlayTo > pNode->m_mtStopTime) )
                    {
                        m_mtPlayTo = pNode->m_mtStopTime;
                        fDirty = TRUE; // see below
                    }
                    else
                    {
                        mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                        pNode->CheckPlay( mtAmount, &mtResult );
                        if( mtResult < mtAmount )
                        {
                            m_mtPlayTo -= ( mtAmount - mtResult );
                            fDirty = TRUE; // see below
                        }
                    }
                }
            }
            // play the primary segment
            PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
            // check to see if the next primary segment in the queue is ready to play
            while( (pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead()) &&
                (pNext = pNode->GetNext()) &&
                ( pNext->m_mtResolvedStart <= pNode->m_mtLastPlayed ) )
            {
                // the next primary segment is indeed ready to begin playing.
                // save the old one in the primary past list so Tools can reference
                // it if they're looking for chord progressions and such.
                pNode->AbortPlay(pNext->m_mtResolvedStart-1,TRUE && (pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                ManageControllingTracks();
                // we need to flush primary events after the new start time
                if(!( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                {
                    Invalidate( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart, 0 );
                }
                // and play the new segment
                PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead());
            }
            // play the controlling segments
            pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode(SQ_CON_PLAY,pNode );
            }
            // play the secondary segments
            pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode( SQ_SEC_PLAY,pNode );
            }

            // if we set fDirty above, it means that we truncated the playback of a control
            // segment because of a loop or end condition. Therefore, we want all segments
            // to set the DMUS_TRACKF_DIRTY flag on the next play cycle.
            if( fDirty )
            {
                for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if( pNode->m_fStartedPlay )
                        {
                            pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                        }
                    }
                }
                ManageControllingTracks();
            }
            m_mtTransported = m_mtPlayTo;

        }

        // check segments queued in ref-time to see if it's time for them to
        // play. Add some extra time just in case. We'll bet that a tempo pmsg won't come
        // in in the intervening 200 ms.
        REFERENCE_TIME rtLatency = GetLatencyWithPrePlay();
        for (dwCount = SQ_PRI_WAIT;dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                if( m_SegStateQueues[dwCount].GetHead()->m_rtGivenStart > rtLatency + PREPARE_TIME + (200 * REF_PER_MIL) )
                {
                    // it's not yet time to handle this one
                    break;
                }
                if (dwCount == SQ_PRI_WAIT)
                {
                    QueuePrimarySegment( m_SegStateQueues[SQ_PRI_WAIT].RemoveHead());
                }
                else
                {
                    QueueSecondarySegment( m_SegStateQueues[dwCount].RemoveHead());
                }
            }
        }

        // Check to see if Segments in the done queues
        // can be released. They can be released if their
        // final play times are older than the current time.
        for (dwCount = SQ_PRI_DONE;dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for (pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode = pNext)
            {
                pNext = pNode->GetNext();
                if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
                {
                    m_SegStateQueues[dwCount].Remove(pNode);
                    pNode->ShutDown();
                }
            }
        }
        for (pNode = m_ShutDownQueue.GetHead();pNode;pNode = pNext)
        {
            pNext = pNode->GetNext();
            if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
            {
                m_ShutDownQueue.Remove(pNode);
                pNode->ShutDown();
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);

        // check to see if there are old notifications that haven't been
        // retrieved by the application and need to be removed.
        EnterCriticalSection(&m_PipelineCrSec);
        while( m_NotificationQueue.GetHead() )
        {
            if( m_NotificationQueue.GetHead()->rtTime <
                (rtNow - m_rtNotificationDiscard) )
            {
                FreePMsg(m_NotificationQueue.Dequeue());
            }
            else
            {
                break;
            }
        }
        LeaveCriticalSection(&m_PipelineCrSec);
        if( m_hTransport )
        {
            WaitForSingleObject( m_hTransport, TRANSPORT_RES );
        }
        else
        {
            Sleep(TRANSPORT_RES);
        }
    }
    m_fKillThread = FALSE;
    if (m_fReleasedInTransport)
    {
        delete this;
    }
}

//////////////////////////////////////////////////////////////////////
// CPerformance::GetNextPMsg
/*
HRESULT | CPerformance | GetNextPMsg |
Returns messages from the queues in priority order.  Any message in the
OnTime queue that is scheduled to be played at the current time is
returned above any other.  Secondly, any message in the NearTime queue
that is scheduled to be played within the next NEARTIME ms is returned.
Lastly, any message in the Early queue is returned.

rvalue PRIV_PMSG* | The message, or NULL if there are no messages.
*/
inline PRIV_PMSG *CPerformance::GetNextPMsg()
{
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    PRIV_PMSG* pEvent = NULL;

    EnterCriticalSection(&m_PipelineCrSec);
    if (m_OnTimeQueue.GetHead())
    {
        ASSERT( m_OnTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
        if ( m_OnTimeQueue.GetHead()->rtTime - GetTime() <= 0 )
        {
            pEvent = m_OnTimeQueue.Dequeue();
        }
    }
    if( !pEvent )
    {
        if (m_NearTimeQueue.GetHead())
        {
            ASSERT( m_NearTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
            if ( m_NearTimeQueue.GetHead()->rtTime < (m_rtQueuePosition + (m_rtBumperLength >> 1)))
            {
                pEvent = m_NearTimeQueue.Dequeue();
            }
        }
        if( !pEvent && !m_fInTransportThread)
        {
            if (m_EarlyQueue.GetHead())
            {
                pEvent = m_EarlyQueue.Dequeue();
            }
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetNextPMsg %u\n", dwDebugTime);
    }
#endif

    return pEvent;
}

/*  This next function is used just by the transport thread
    which can process messages in the early queue, but not
    the other types. This allows all the tools that process
    events right after they are generated by tracks to process
    the events right after they were generated, and in sequential
    order. This allows them to take a little longer, since it's
    not as time critical, and it's much more likely to ensure
    that they are in sequential order. If the realtime thread were
    allowed to process these, it would preempt and process them
    as soon as generated, so they would be processed in the order
    of the tracks. The m_fInTransportThread is set by the
    transport thread when it is generating and processing events
    and this disallows the realtime thread from processing
    early events (but not others.) At other times, the realtime
    thread is welcome to process early events.
*/

void CPerformance::ProcessEarlyPMsgs()
{
    PRIV_PMSG* pEvent;

    //  Exit if the thread is exiting.  If we don't test here
    //  we can actually loop forever because tools and queue more
    //  early PMSGs (the Echo tool does this)
    while (!m_fKillThread)
    {
        EnterCriticalSection(&m_PipelineCrSec);
        pEvent = m_EarlyQueue.Dequeue();
        LeaveCriticalSection(&m_PipelineCrSec);
        if (!pEvent) break; // Done?
        ASSERT( pEvent->pNext == NULL );
        if( !pEvent->pTool )
        {
            // this event doesn't have a Tool pointer, so stamp it with the
            // final output Tool.
            pEvent->pTool = (IDirectMusicTool*)this;
            AddRef();
            // Don't process it. Instead, send to neartime queue so
            // realtime thread will deal with it.
            pEvent->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
            pEvent->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            SendPMsg( PRIV_TO_DMUS(pEvent) );
        }
        else
        {
            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            HRESULT hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
    }
}

REFERENCE_TIME CPerformance::GetTime()
{
    REFERENCE_TIME rtTime;
    REFERENCE_TIME rtCurrent = 0;
    WORD    w;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_MainCrSec);
    if (m_pClock) hr = m_pClock->GetTime( &rtCurrent );
    if( !m_pClock || FAILED( hr ) || rtCurrent == 0 )
    {
        // this only gets called with machines that don't support m_pClock
        rtTime = timeGetTime();
        rtCurrent = rtTime * REF_PER_MIL; // 100 ns increments
        // take care of timeGetTime rolling over every 49 days
        if( rtCurrent < 0 )
        {
            m_wRollOverCount++;
        }
        for( w = 0; w < m_wRollOverCount; w++ )
        {
            rtCurrent += 4294967296;
        }
        // if rtCurrent is negative, it means we've rolled over rtCurrent. Ignore
        // this case for now, as it will be quite uncommon.
    }
    LeaveCriticalSection(&m_MainCrSec);

    return rtCurrent;
}

REFERENCE_TIME CPerformance::GetLatency(void)
{
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( m_pPortTable )
    {
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetTime();
    }
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetLatency %u\n", dwDebugTime);
    }
#endif
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return rtLatency;
}

// return the most desireable Segment latency, based on which ports this
// segment plays on.
REFERENCE_TIME CPerformance::GetBestSegLatency( CSegState* pSeg )
{
    // If we're using audiopaths, the code below doesn't work because it doesn't
    // take converting pchannels into account. So, just use the worse case
    // latency. 99% of the time, there is only one port, so this results
    // in just a performance enhancement.
    if (m_dwAudioPathMode == 2)
    {
        return GetLatency();
    }
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;
    BOOL* pafIndexUsed = NULL;
    DWORD dwCount;

    if( m_dwNumPorts == 1 )
    {
        return GetLatency();
    }
    pafIndexUsed = new BOOL[m_dwNumPorts];
    if( NULL == pafIndexUsed )
    {
        return GetLatency();
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        pafIndexUsed[dwCount] = FALSE;
    }
    DWORD dwNumPChannels, dwGroup, dwMChannel;
    DWORD* paPChannels;
    pSeg->m_pSegment->GetPChannels( &dwNumPChannels, &paPChannels );
    for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
    {
        if( SUCCEEDED( PChannelIndex( paPChannels[dwCount],
            &dwIndex, &dwGroup, &dwMChannel )))
        {
            pafIndexUsed[dwIndex] = TRUE;
        }
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        if( pafIndexUsed[dwCount] )
            break;
    }
    if( dwCount >= m_dwNumPorts )
    {
        delete [] pafIndexUsed;
        return GetLatency();
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( pafIndexUsed[dwIndex] )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetLatency();
    }
    delete [] pafIndexUsed;
    return rtLatency;
}

/*  Called from either QueuePrimarySegment or QueueSecondarySegment,
    this calculates the appropriate boundary time to start the segment
    playback. Most of the logic takes care of the new DMUS_SEGF_ALIGN
    capabilities.
*/


void CPerformance::CalculateSegmentStartTime( CSegState* pSeg )
{
    BOOL fNoValidStart = TRUE;
    if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_ALIGN)
    {
        // If the ALIGN flag is set, see if we can align with the requested resolution,
        // but switch to the new segment at an earlier point, as defined by
        // a "valid start" point in the new segment.
        DMUS_VALID_START_PARAM ValidStart;    // Used to read start parameter from segment.
        MUSIC_TIME mtIntervalSize = 0;      // Quantization value.
        MUSIC_TIME mtTimeNow = (MUSIC_TIME)pSeg->m_rtGivenStart; // The earliest time this can start.
        // Call resolve time to get the last quantized interval that precedes mtTimeNow.
        MUSIC_TIME mtStartTime = ResolveTime( mtTimeNow, pSeg->m_dwPlaySegFlags, &mtIntervalSize );
        // StartTime actually shows the next time after now, so subtract the interval time to get the previous position.
        mtStartTime -= mtIntervalSize;
        // If the segment was supposed to start after the very beginning, quantize it.
        if (mtIntervalSize && pSeg->m_mtStartPoint)
        {
            pSeg->m_mtStartPoint = ((pSeg->m_mtStartPoint + (mtIntervalSize >> 1))
                / mtIntervalSize) * mtIntervalSize;
            // If this ends up being longer than the segment, do we need to drop back?
        }
        // Now, get the next start point after the point in the segment that
        // corresponds with mtTimeNow, adjusted for the startpoint.
        if (SUCCEEDED(pSeg->m_pSegment->GetParam( GUID_Valid_Start_Time,-1,0,
            pSeg->m_mtStartPoint + mtTimeNow - mtStartTime,NULL,(void *) &ValidStart)))
        {
            // If the valid start point is within the range, we can cut in at the start point.
            if ((mtTimeNow - mtStartTime + ValidStart.mtTime) < (mtIntervalSize + pSeg->m_mtStartPoint))
            {
                pSeg->m_mtResolvedStart = mtTimeNow + ValidStart.mtTime;
                pSeg->m_mtStartPoint += mtTimeNow - mtStartTime + ValidStart.mtTime;
                fNoValidStart = FALSE;
            }
        }
        if (fNoValidStart)
        {
            // Couldn't find a valid start point. Was DMUS_SEGF_VALID_START_XXX set so we can override?
            if (pSeg->m_dwPlaySegFlags &
                (DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK))
            {
                MUSIC_TIME mtOverrideTime;
                // Depending on the flag, we need to get the appropriate interval resolution.
                if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_MEASURE)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_MEASURE, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_BEAT)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_BEAT, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_GRID)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_GRID, 0 );
                }
                else
                {
                    mtOverrideTime = mtTimeNow;
                }
                // If the valid start point is within the range, we can cut in at the start point.
                if ((mtOverrideTime - mtTimeNow) < (mtIntervalSize + pSeg->m_mtStartPoint))
                {
                    pSeg->m_mtResolvedStart = mtOverrideTime;
                    if ((mtOverrideTime - mtStartTime) >= mtIntervalSize)
                    {
                        mtOverrideTime -= mtIntervalSize;
                    }
/*Trace(0,"Startpoint %ld plus OverrideTime %ld - StartTime %ld = %ld\n",
      pSeg->m_mtStartPoint, mtOverrideTime - mtSegmentTime, mtStartTime - mtSegmentTime,
        pSeg->m_mtStartPoint + mtOverrideTime - mtStartTime);*/
                    pSeg->m_mtStartPoint += mtOverrideTime - mtStartTime;
                    fNoValidStart = FALSE;
                }
            }
        }
    }
    if (fNoValidStart)
    {
        pSeg->m_mtResolvedStart = ResolveTime( (MUSIC_TIME)pSeg->m_rtGivenStart,
            pSeg->m_dwPlaySegFlags, NULL );
    }
    else
    {
        // If we succeeded in finding a place to switch over, make sure it isn't deep inside
        // a loop. This is specifically a problem when syncing to segment and switching inside
        // or after a loop.
        while (pSeg->m_dwRepeats && (pSeg->m_mtStartPoint >= pSeg->m_mtLoopEnd))
        {
            pSeg->m_dwRepeats--;
            pSeg->m_mtStartPoint -= (pSeg->m_mtLoopEnd - pSeg->m_mtLoopStart);
        }
        // Since we were decrementing the repeats, we need to also decrement the repeats left.
        pSeg->m_dwRepeatsLeft = pSeg->m_dwRepeats;
        // Finally, if the startpoint is after the end of the segment, cut it back to the end of the
        // segment. This will cause it to play for time 0 and, if this is a transition segment, whatever
        // should play after will play immediately.
        if (pSeg->m_mtStartPoint > pSeg->m_mtLength)
        {
            pSeg->m_mtStartPoint = pSeg->m_mtLength;
        }
    }
    pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
    pSeg->m_mtLastPlayed = pSeg->m_mtResolvedStart;
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueuePrimarySegment( CSegState* pSeg )
{
    CSegState* pTemp;
    BOOL fInCrSec = TRUE;
    BOOL fNotDone = TRUE;
    EnterCriticalSection(&m_PipelineCrSec);
    pSeg->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_QUEUE )
    {
        MUSIC_TIME mtStart = 0;

        pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetTail();
        if( pTemp )
        {
            mtStart = pTemp->GetEndTime( pTemp->m_mtResolvedStart );
        }
        else
        {
            pTemp = m_SegStateQueues[SQ_PRI_DONE].GetTail();
            if( pTemp )
            {
                mtStart = pTemp->m_mtLastPlayed;
            }
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE;
        if( NULL == pTemp )
        {
            // if there's nothing in the queue, this means play it now
            if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
            {
                // we want to queue this at the last transported time,
                // so we don't need to do an invalidate
                if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
                {
                    REFERENCE_TIME rtTrans;
                    MusicToReferenceTime( m_mtTransported, &rtTrans );
                    if( pSeg->m_rtGivenStart < rtTrans )
                    {
                        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
                else
                {
                    if( pSeg->m_rtGivenStart < m_mtTransported )
                    {
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
            }
            else
            {
                // This will be changed to Queue time below
                pSeg->m_rtGivenStart = 0;
            }
        }
        else
        {
            REFERENCE_TIME rtQueue;

            // otherwise, time stamp it with the time corresponding to
            // the end time of all segments currently in the queue.
            pSeg->m_mtResolvedStart = mtStart;
            // make sure the resolved start time isn't before the latency
            GetQueueTime(&rtQueue);
            ReferenceToMusicTime( rtQueue, &mtStart );
            if( pSeg->m_mtResolvedStart < mtStart )
            {
                pSeg->m_mtResolvedStart = 0; // below code will take care of this case
            }
            else
            {
                pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
                m_SegStateQueues[SQ_PRI_PLAY].Insert(pSeg);
                TraceI(2, "dmperf: queueing primary seg/DMUS_SEGF_QUEUE. Prev time=%ld, this=%ld\n",
                    pTemp->m_mtResolvedStart, pSeg->m_mtResolvedStart);
                fNotDone = FALSE;
                PrepSegToPlay(pSeg, true);
            }
        }
    }
    if( fNotDone && (pSeg->m_rtGivenStart == 0) )
    {
        // if the given start time is 0, it means play now.
        MUSIC_TIME mtStart;
        REFERENCE_TIME rtStart;

        GetQueueTime( &rtStart );
        ReferenceToMusicTime( rtStart, &mtStart );
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
        // we definitely want to get rid of all segments following
        // the currently playing segment
        if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            while( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead()->GetNext() )
            {
                m_SegStateQueues[SQ_PRI_PLAY].Remove(pTemp);
                pTemp->AbortPlay(mtStart,FALSE);
                m_ShutDownQueue.Insert(pTemp);
            }
        }
    }
    if( fNotDone && pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow = m_rtQueuePosition;
        MUSIC_TIME mtTime;
        if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() || ( pSeg->m_rtGivenStart <= rtNow ) )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_PRI_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }
    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded. Also, segments that are in
        // the wait queue as RefTime are discarded.

        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        while( (pTemp = m_SegStateQueues[SQ_PRI_WAIT].RemoveHead()) )
        {
            pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
            m_ShutDownQueue.Insert(pTemp);
        }
        if( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            if( pSeg->m_mtResolvedStart > pTemp->m_mtResolvedStart )
            {
                while( pTemp->GetNext() )
                {
                    if( pTemp->GetNext()->m_mtResolvedStart >= pSeg->m_mtResolvedStart )
                    {
                        break;
                    }
                    pTemp = pTemp->GetNext();
                }
                pSeg->SetNext(pTemp->GetNext());
                pTemp->SetNext(pSeg);
                while( pTemp = pSeg->GetNext() )
                {
                    // delete the remaining pSegs after this one
                    pSeg->SetNext(pTemp->GetNext());
                    pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                    m_ShutDownQueue.Insert(pTemp);
                }
            }
            else
            {
                if( !pTemp->m_fStartedPlay )
                {
                    // blow away the entire queue
                    while( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
                    {
                        pTemp = m_SegStateQueues[SQ_PRI_PLAY].RemoveHead();
                        pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                        m_ShutDownQueue.Insert(pTemp);
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    // give this a chance to start performing if it's near
                    // enough to time
                    if( fInCrSec )
                    {
                        LeaveCriticalSection(&m_PipelineCrSec);
                        fInCrSec = FALSE;
                    }
                    SyncTimeSig( pSeg );
                    ManageControllingTracks();
                    PerformSegStNode( SQ_PRI_PLAY,pSeg);
                }
                else
                {
                    // else, place this segment after the current one
                    // and count on the routine below to take care of dequeing
                    // the current one, because in this case m_mtLastPlayed
                    // must be greater than m_mtResolvedStart.
                    if ( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtLastPlayed <=
                        m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart )
                    {
                        TraceI(0,"Current Primary segment has not started playing.\n");
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    MUSIC_TIME mtTime = pSeg->m_mtResolvedStart;
                    while( pTemp = pSeg->GetNext() )
                    {
                        pTemp->AbortPlay( mtTime, TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) );
                        // delete the remaining pSegs after this one
                        pSeg->SetNext(pTemp->GetNext());
                        m_ShutDownQueue.Insert(pTemp);
                    }
                }
            }
            // m_pPriSegQueue could have become NULL from the PerformSegStNode call above.
            if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() && (pSeg != m_SegStateQueues[SQ_PRI_PLAY].GetHead()) )
            {
                CSegState *pCurrentSeg = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
                if( pCurrentSeg->m_fStartedPlay &&
                    ( pSeg->m_mtResolvedStart <= pCurrentSeg->m_mtLastPlayed ))
                {
                    // If Playsegment is recursively called by the end of a previous segment in a song, don't abort.
                    if (!pCurrentSeg->m_fInPlay || !pCurrentSeg->m_fSongMode)
                    {
                        // the new segment wants to play on top of stuff that's
                        // already been transported by the current primary segment.
                        pCurrentSeg->AbortPlay(pSeg->m_mtResolvedStart-1,TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                        m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                        // make sure none of the last played times in the past list
                        // are past the resolved start
                        for( CSegState* pSegTemp = m_SegStateQueues[SQ_PRI_DONE].GetHead();
                            pSegTemp; pSegTemp = pSegTemp->GetNext() )
                        {
                            if( pSegTemp->m_mtLastPlayed > pSeg->m_mtResolvedStart )
                            {
                                pSegTemp->m_mtLastPlayed = pSeg->m_mtResolvedStart;
                            }
                        }
                        if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ) )
                        {
                            // if we set the PREPARE flag it means we specifically
                            // don't want to invalidate
                            Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                        }
                        else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                                 !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                        {
                            pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                        }
                        ASSERT( m_SegStateQueues[SQ_PRI_PLAY].GetHead() == pSeg ); // this should be the case
                        if( fInCrSec )
                        {
                            LeaveCriticalSection(&m_PipelineCrSec);
                            fInCrSec = FALSE;
                        }
                        SyncTimeSig( pSeg );
                        ManageControllingTracks();
                        PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
                    }
                }
                else
                {
                    if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                    {
                        Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                    }
                    else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                             !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                    {
                        pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                    }
                }
            }
        }
        else
        {
            m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
            // give this a chance to start performing if it's near
            // enough to time
            if( fInCrSec )
            {
                LeaveCriticalSection(&m_PipelineCrSec);
                fInCrSec = FALSE;
            }
            //DWORD dwDebugTime = timeGetTime();
            SyncTimeSig( pSeg );
            //DWORD dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime SyncTimeSig %u\n", dwDebugTime2 - dwDebugTime);

            ManageControllingTracks();
            //dwDebugTime = timeGetTime();
            //Trace(0, "perf, debugtime ManageControllingTracks %u\n", dwDebugTime - dwDebugTime2);

            PerformSegStNode( SQ_PRI_PLAY,pSeg );
            //dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime PerformSegStNode %u\n", dwDebugTime2 - dwDebugTime);
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueueSecondarySegment( CSegState* pSeg)
{
    BOOL fInCrSec = FALSE;
    BOOL fNotDone = TRUE;

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
    {
        EnterCriticalSection(&m_PipelineCrSec);
        fInCrSec = TRUE;
    }
    pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE; // not legal for 2ndary segs.
    if( pSeg->m_rtGivenStart == 0 )
    {
        MUSIC_TIME mtStart;

        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            REFERENCE_TIME rtStart;
            GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
            ReferenceToMusicTime( rtStart, &mtStart );
        }
        else
        {
            ReferenceToMusicTime( GetBestSegLatency(pSeg), &mtStart );
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
    }

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow;
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            GetQueueTime( &rtNow ); // need queue time because control segments cause invalidations
        }
        else
        {
            rtNow = GetBestSegLatency(pSeg);
        }
        MUSIC_TIME mtTime;
        if( pSeg->m_rtGivenStart <= rtNow )
        {
            ReferenceToMusicTime( rtNow, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_SEC_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }

    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded.
        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        TraceI(2,"Queuing 2ndary seg time %ld\n",pSeg->m_mtResolvedStart);
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL)
        {
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSeg );
            // If this is a control segment, we need to do an invalidate.
            if(!(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
            {
                ManageControllingTracks();
                Invalidate( pSeg->m_mtResolvedStart, 0 );
            }
        }
        else
        {
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSeg );
        }
        // give this a chance to start performing if it's near
        // enough to time
        if( fInCrSec )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            fInCrSec = FALSE;
        }
        // play the secondary segments
        CSegState *pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
        CSegState *pNext;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_SEC_PLAY,pNode );
        }
        // play the controlling segments
        pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_CON_PLAY,pNode );
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

/*  If a segment is controlling, this establishes which tracks in the currently playing
    primary segment are disabled.
    We store temporary information in each playing track's m_dwInternalFlags, which is not used
    otherwise in segmentstates.

    Four scenarios, each for play and notify:
    1) An officially enabled track is currently enabled and gets disabled.
    2) An officially enabled track is currently disabled and continues to be disabled.
    3) An officially enabled track is currently disabled and gets enabled.
    4) An officially disabled track is left disabled. If none of the CONTROL_ flags are set and the track is disabled,
       set the _WAS_DISABLED flag, which also indicates that this should be left alone.

    This should get called every time a primary or secondary segment starts or stop, so it
    can recalculate the behavior of all tracks in the primary segment.
*/

void CPerformance::ManageControllingTracks()

{
    EnterCriticalSection(&m_SegmentCrSec);
    CSegState* pSegNode;
    // First, prepare all tracks in the primary segment, putting them back to normal.
    // so they are ready to be reset by the controlling tracks.
    // To do this, check for WAS_ENABLED or WAS_DISABLED and set the appropriate flags in m_dwFlags.
    // Else, if these weren't set, then it's time to set them, since this is the first pass through this segment.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwInternalFlags) // This has been touched before.
            {
                // First transfer and reset the is disabled flags.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_PLAY_WAS_DISABLED;
                }
                pTrack->m_dwInternalFlags &= ~(CONTROL_PLAY_IS_DISABLED | CONTROL_NTFY_IS_DISABLED);
                // Then, set the play flags based on the original state.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_PLAY_ENABLED;
                }
                if (pTrack->m_dwInternalFlags & CONTROL_NTFY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                }
            }
            else
            {
                // Since this has never been touched before, set the flags so we can know what to return to.
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED)
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_DISABLED;
                }
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_DISABLED;
                }
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    CSegState* pControlNode;
    // Now, go through all the controlling segments and, for each controlling track that matches
    // a primary segment track, clear the enable flags on the segment track.
    for( pControlNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pControlNode; pControlNode = pControlNode->GetNext() )
    {
        EnterCriticalSection(&pControlNode->m_CriticalSection);
        CTrack *pTrack = pControlNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            // If the track has never been overridden, the internal flags for IS_DISABLED should be clear.
            // If the track is currently overridden, the internal flags should be CONTROL_PLAY_IS_DISABLED and/or
            // CONTROL_NTFY_IS_DISABLED
            if (pTrack->m_dwFlags & (DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION)) // This overrides playback and/or notification.
            {
                for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
                {
                    EnterCriticalSection(&pSegNode->m_CriticalSection);
                    CTrack *pPrimaryTrack = pSegNode->m_TrackList.GetHead();
                    for (;pPrimaryTrack;pPrimaryTrack = pPrimaryTrack->GetNext())
                    {
                        // A track matches if it has the same class id and overlapping group bits.
                        if ((pPrimaryTrack->m_guidClassID == pTrack->m_guidClassID) &&
                            (pPrimaryTrack->m_dwGroupBits & pTrack->m_dwGroupBits))
                        {
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_PLAY) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_PLAY_IS_DISABLED; // Mark so we can turn on later.
                            }
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_NTFY_IS_DISABLED; // Mark so we can turn on later.
                            }
                        }
                    }
                    LeaveCriticalSection(&pSegNode->m_CriticalSection);
                }
            }
        }
        LeaveCriticalSection(&pControlNode->m_CriticalSection);
    }
    // Now, go back to the primary segment and find all tracks that have been reenabled
    // and tag them so they will generate refresh data on the next play (by seeking, as if they
    // were starting or looping playback.) We only do this for play, not notify, because no
    // notifications have state.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if ((pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED) &&
                (pTrack->m_dwInternalFlags & CONTROL_PLAY_WAS_DISABLED) &&
                !(pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED))
            {
                pTrack->m_dwInternalFlags |= CONTROL_PLAY_REFRESH; // Mark so we can turn on later.
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig )
{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
    for (;pEvent;pEvent = pEvent->pNext)
    {
        // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
        if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
        {
            DMUS_TIMESIG_PMSG* pNewTimeSig = (DMUS_TIMESIG_PMSG*)PRIV_TO_DMUS(pEvent);
            memcpy( pTimeSig, pNewTimeSig, sizeof(DMUS_TIMESIG_PMSG) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return;
        }
    }
    // This should only happen if there is no timesig at all. Should only happen before any segments play.
    memset( pTimeSig, 0, sizeof(DMUS_TIMESIG_PMSG ) );
    pTimeSig->wGridsPerBeat = 4;
    pTimeSig->bBeatsPerMeasure = 4;
    pTimeSig->bBeat = 4;
    LeaveCriticalSection(&m_PipelineCrSec);
}

void CPerformance::SyncTimeSig( CSegState *pSegState )

/*  If a primary segment is played that does not have a time signature track,
    this forces the current time signature to line up with the start of the
    primary segment.
*/

{
    // First, test to see if the segment has a time signature.
    // If it doesn't then we need to do this.
    DMUS_TIMESIGNATURE TimeSig;
    if (FAILED(pSegState->GetParam(this,GUID_TimeSignature,-1,0,0,NULL,(void *)&TimeSig)))
    {
        MUSIC_TIME mtTime = pSegState->m_mtResolvedStart;
        EnterCriticalSection(&m_PipelineCrSec);
        PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
        // Scan through the time signatures until the most recent one is found.
        for (;pEvent;pEvent = pEvent->pNext)
        {
            // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
            if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
            {
                pEvent->mtTime = mtTime;
                MusicToReferenceTime(mtTime,&pEvent->rtTime);
                break;
            }
        }
        // Should never fall through to here without finding a time signature because Init() creates a timesig.
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// Convert mtTime into the resolved time according to the resolution in
// dwResolution.
// This should only be called from within a segment critical section.
MUSIC_TIME CPerformance::ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize )
{
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = 0;
    }
    if (dwResolution & DMUS_SEGF_MARKER)
    {
        DMUS_PLAY_MARKER_PARAM Marker;
        MUSIC_TIME mtNext;
        // First, get the time of the marker preceding this one.
        if (SUCCEEDED (GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
        {
            BOOL fIsMarker = FALSE;
            MUSIC_TIME mtInitialTime = mtTime;
            MUSIC_TIME mtFirst = mtTime + Marker.mtTime; // This is the time of the preceding marker.
            MUSIC_TIME mtSecond = mtTime + mtNext;  // This might be the time of the next marker.
            // Then, scan forward until a marker is found after or equal to this time.
            // If a loop point or end of segment is encountered, the value in Marker.mtTime will
            // continue to be negative. Once we hit the actual marker, it will become 0, since
            // we are asking for the marker at that specific time.
            while (mtNext)
            {
                mtTime += mtNext;
                if (SUCCEEDED(GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
                {
                    // If the marker time is 0, this means we are sitting right on the marker,
                    // so we are done.
                    if (fIsMarker = (Marker.mtTime == 0))
                    {
                        mtSecond = mtTime;
                        break;
                    }
                    // Otherwise, this was a loop boundary or segment end, so we should continue scanning forward.
                }
                else
                {
                    // GetParam failed, must be nothing more to search.
                    break;
                }
            }
            // If the caller wants the interval size, then we know they are interested in
            // aligning to a previous marker as well as a future one. In that case,
            // if we didn't find a marker in the future, it's okay because it will
            // use the previous marker (mtFirst) anyway.
            // For all other cases, we only return if the upcoming marker is legal.
            // Otherwise, we drop through and try other resolutions.
            if (pmtIntervalSize || fIsMarker)
            {
                if (pmtIntervalSize)
                {
                    *pmtIntervalSize = mtSecond - mtFirst;
                }
                return mtSecond;
            }
            mtTime = mtInitialTime;
        }
        // If marker fails, we can drop down to the other types...
    }
    if( dwResolution & DMUS_SEGF_SEGMENTEND )
    {
        // In this mode, we don't actually get the time signature. Instead, we
        // find out the time of the next segment start after the requested time.
        CSegState *pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            // First, calculate the end time of the segment.
            // Include any starting offset so we see the full span of the segment.
            mtTime = pSegNode->GetEndTime( pSegNode->m_mtStartPoint );
            if (pmtIntervalSize)
            {
                // Interval would be the length of the primary segment!
                *pmtIntervalSize = mtTime;
            }
            // Return the end of the segment.
            LONGLONG llEnd = mtTime + (LONGLONG)(pSegNode->m_mtResolvedStart - pSegNode->m_mtStartPoint);
            if(llEnd > 0x7fffffff) llEnd = 0x7fffffff;
            mtTime = (MUSIC_TIME) llEnd;
            return mtTime;
        }
        // If there was no segment, we should fail and try the other flags.
    }
    long        lQuantize;
    MUSIC_TIME  mtNewTime;
    MUSIC_TIME  mtStartOfTimeSig = 0;
    DMUS_TIMESIGNATURE  timeSig;
    if (!(dwResolution & DMUS_SEGF_TIMESIG_ALWAYS))
    {
        if (!GetPrimarySegmentAtTime(mtTime))
        {
            return mtTime;
        }
    }
    GetParam(GUID_TimeSignature,-1,0,mtTime,NULL,(void *) &timeSig);
    mtStartOfTimeSig = timeSig.mtTime + mtTime;
    mtNewTime = mtTime - mtStartOfTimeSig;
    if (dwResolution & DMUS_SEGF_MEASURE)
    {
        lQuantize = ( DMUS_PPQ * 4 * timeSig.bBeatsPerMeasure ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_BEAT)
    {
        lQuantize = ( DMUS_PPQ * 4 ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_GRID)
    {
        lQuantize = ( ( DMUS_PPQ * 4 ) / timeSig.bBeat ) / timeSig.wGridsPerBeat;
    }
    else
    {
        lQuantize = 1;
    }
    if (lQuantize == 0) // Avoid divide by 0 error.
    {
        lQuantize = 1;
    }
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = lQuantize;
    }
    if( mtNewTime ) // if it's 0 it stays 0
    {
        // round up to next boundary
        mtNewTime = ((mtNewTime-1) / lQuantize ) * lQuantize;
        mtNewTime += lQuantize;
    }
    return (mtNewTime + mtStartOfTimeSig);
}

// returns:
// true if the note should be invalidated (any other return code will invalidate)
// false if the note should not be invalidated
inline bool GetInvalidationStatus(DMUS_PMSG* pPMsg)
{
    bool fResult = true; // default: invalidate the note

    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
        if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_WAVE )
    {
        DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
        if(pWave->bFlags & DMUS_WAVEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        // Don't invalidate segment abort messages
        DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
        if ((pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT) &&
            (pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT))
        {
            fResult = false;
        }
    }
    return fResult;
}

static inline long ComputeCurveTimeSlice(DMUS_CURVE_PMSG* pCurve)
{
    long lTimeIncrement;
    DWORD dwTotalDistance;
    DWORD dwResolution;
    if ((pCurve->bType == DMUS_CURVET_PBCURVE) ||
        (pCurve->bType == DMUS_CURVET_RPNCURVE) ||
        (pCurve->bType == DMUS_CURVET_NRPNCURVE))
    {
        dwResolution = 100;
    }
    else
    {
        dwResolution = 3;
    }
    if (pCurve->nEndValue > pCurve->nStartValue)
        dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;
    else
        dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;
    if (dwTotalDistance == 0) dwTotalDistance = 1;
    lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;
    // Force to no smaller than 192nd note (10ms at 120 bpm.)
    if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;
    return lTimeIncrement;
}

static DWORD ComputeCurve( DMUS_CURVE_PMSG* pCurve )
{
    DWORD dwRet;
    short *panTable;
    MUSIC_TIME mtCurrent;
    long lIndex;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            pCurve->rtTime = 0;
            return (DWORD)pCurve->nResetValue;
        }
        if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && ( pCurve->mtResetDuration > 0 ) )
        {
            pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart;
            pCurve->mtDuration = 0;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // setting this to 0 will free the event upon return
        }
        return (DWORD)pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    // compute index into table
    // there are CT_MAX + 1 elements in the table.
    mtCurrent = pCurve->mtTime - pCurve->mtOriginalStart;

    // if we're flushing this event, send the reset value
    if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
    {
        // it will only get here if pCurve->bFlags & 1, because that is checked in
        // the :Flush() routine.
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }

    // this should now never happen, as a result of fixing 33987: Transition on a beat boundary invalidates CC's right away (doesn't wait for the beat)
    if( (pCurve->bFlags & DMUS_CURVE_RESET) &&
        (pCurve->mtResetDuration < 0 ) && // this can happen from flushing
        (pCurve->mtTime >= pCurve->mtOriginalStart + pCurve->mtDuration + pCurve->mtResetDuration ))
    {
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }
    else if( (pCurve->mtDuration == 0) ||
        (pCurve->mtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))
    {
        // if we're supposed to send the return value (m_bFlags & 1) then
        // set it up to do so. Otherwise, free the event.
        if( pCurve->bFlags & DMUS_CURVE_RESET )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // time to free the event, we're done
        }
        dwRet = pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            dwRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }

        // this should now never happen, as a result of fixing 33987
        if( (pCurve->bFlags & DMUS_CURVE_RESET) && (pCurve->mtResetDuration < 0) )
        {
            // this can happen as a result of flushing. We want to make sure the next
            // time is the reset flush time.
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
        }
        else
        {
            // Within curve, so increment time.
            if (!pCurve->wMeasure) // oops --- better compute this.
            {
                TraceI(2, "Warning: Computing curve time slice...\n");
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);  // Use this to store the time slice interval.
            }
            pCurve->mtTime += pCurve->wMeasure; // We are storing the time increment here.
        }
        if( pCurve->mtTime > pCurve->mtDuration + pCurve->mtOriginalStart )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtOriginalStart;
        }
        pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

    }
    return dwRet;
}

static int RecomputeCurveEnd( DMUS_CURVE_PMSG* pCurve, MUSIC_TIME mtCurrent )
{
    int nRet = 0;
    short *panTable;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        return pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    if( (pCurve->mtDuration == 0) || (mtCurrent >= pCurve->mtDuration ))
    {
        return pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        long lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            nRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            nRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }
    }
    return nRet;
}

void CPerformance::FlushEventQueue( DWORD dwId,
    CPMsgQueue *pQueue,                 // Queue to flush events from.
    REFERENCE_TIME rtFlush,             // Time that flush occurs. This may be resolved to a timing resolution.
    REFERENCE_TIME rtFlushUnresolved,   // Queue time at time flush was requested. This is not resolved to the timing resolution.
                                        // Instead, it is the actual time at which that the flush was requested. This is used only by curves.
    BOOL fLeaveNotesOn)                 // If notes or waves are currently on, do not cut short their durations.
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        // Clear the remove bit. This will be set for each event that should be removed from the queue.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        // Also clear the requeue bit, which will be set for each event that needs to be requeued.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
        if( ( 0 == dwId ) || ( pEvent->dwVirtualTrackID == dwId ) )
        {
            // First, create the correct mtTime and rtTime for invalidation.
            REFERENCE_TIME rtTime = pEvent->rtTime;
            if( pEvent->dwType == DMUS_PMSGT_NOTE )
            {
                DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    // If this is a note on, we want to take the offset into consideration for
                    // determining whether or not to invalidate.
                    MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset;
                    MusicToReferenceTime( mtNote, &rtTime );
                }
                // If note off and we want to leave notes playing, turn on the noinvalidate flag.
                else if (fLeaveNotesOn)
                {
                    pNote->bFlags |= DMUS_NOTEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_WAVE )
            {
                DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                {
                    if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                    {
                        rtTime = pWave->rtTime;
                    }
                    else
                    {
                        MusicToReferenceTime(pWave->mtTime, &rtTime);
                    }
                }
                // If wave off and we want to leave waves playing, turn on the noinvalidate flag.
                else if (fLeaveNotesOn)
                {
                    pWave->bFlags |= DMUS_WAVEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_CURVE )
            {
                if (fLeaveNotesOn)
                {
                    rtTime = 0;
                }
                else
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtCurve;
                    MUSIC_TIME mtStart;
                    mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    // if rtFlush is before the beginning of the curve minus the offset of
                    // the curve, we want to prevent the curve from playing
                    mtCurve = mtStart - pCurve->nOffset;
                    MusicToReferenceTime( mtCurve, &rtTime );
                    if( rtFlush > rtTime ) // if it isn't...
                    {
                        // if the curve has a reset value and has already begun,
                        // we may want to flush right away.
                        if( ( pCurve->bFlags & DMUS_CURVE_RESET) &&
                              pCurve->mtOriginalStart &&
                              rtFlush <= rtFlushUnresolved )
                        {
                            mtCurve = mtStart + pCurve->mtDuration;
                            MusicToReferenceTime( mtCurve, &rtTime );
                            if( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                            {
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtDuration = (mt - mtStart) - 1;
                                pCurve->mtResetDuration = 1;
                            }
                            else
                            {
                                mtCurve = mtStart + pCurve->mtDuration + pCurve->mtResetDuration;
                                MusicToReferenceTime( mtCurve, &rtTime );
                                if ( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                                {
                                    MUSIC_TIME mt = 0;
                                    ReferenceToMusicTime(rtFlush, &mt);
                                    pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                }
                            }
                        }
                        else
                        {
                            // Otherwise, we may cut the curve short in the code below.
                            rtTime = 0;
                        }
                    }
                }
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                if (!(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH))
                {
                    if( pEvent->pTool)
                    {
                        bool fFlush = false;
                        if (pEvent->dwType == DMUS_PMSGT_WAVE)
                        {
                            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                            if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                            {
                                // this wave on is due to start after the flush time.
                                // we never want to hear it.
                                fFlush = true;
                            }
                            else
                            {
                                // cut the duration short, but don't actually flush here,
                                // since it's possible to invalidate the same wave more
                                // than once, and the second invalidation might have a
                                // time prior to the first one (e.g., first is from a loop,
                                // second is from a transition)
                                if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)) &&
                                    rtFlush < pWave->rtTime)
                                {
                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                    MUSIC_TIME mtFlush = 0;
                                    ReferenceToMusicTime(rtFlush, &mtFlush);
                                    pWave->rtTime = rtFlush;
                                    pWave->mtTime = mtFlush;
                                }
                            }
                        }
                        if (fFlush ||
                            (pEvent->dwType != DMUS_PMSGT_WAVE &&
                             GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                        {
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                            pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                            if( rtFlush <= pEvent->rtLast )
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), pEvent->rtLast + REF_PER_MIL );
                            }
                            else
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlush );
                            }
                        }
                    }
                    else
                    {
                        pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    }
                }
            }
            else // cut notes, waves, and curves short if needed
            {
                if( pEvent->dwType == DMUS_PMSGT_NOTE && !fLeaveNotesOn )
                {
                    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                    {
                        if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)))
                        {
                            // subtract 2 from the duration to guarantee the note cuts short
                            // 1 clock before the flush time.
                            MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                            REFERENCE_TIME rtNoteOff;
                            MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                            if( rtNoteOff >= rtFlush )
                            {
                                ReferenceToMusicTime( rtFlush, &mtNoteOff );
                                mtNoteOff -= pNote->mtTime;
                                // Make any duration < 1 be 0; this will cause the note not to
                                // sound.  Can happen if the note's logical time is well before
                                // its physical time.
                                if( mtNoteOff < 1 ) mtNoteOff = 0;
                                pNote->mtDuration = mtNoteOff;
                            }
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_WAVE && !fLeaveNotesOn )
                {
                    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( !(pWave->bFlags & DMUS_WAVEF_OFF) &&
                        (GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                    {
                        if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                        {
                            // This is a clock time message.
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((rtTime + pWave->rtDuration - 2) >= rtFlush)
                            {
                                pWave->rtDuration = rtFlush - rtTime;
                            }

                        }
                        else
                        {
                            MUSIC_TIME mtTime = 0;
                            MUSIC_TIME mtFlush = 0;
                            ReferenceToMusicTime(rtTime, &mtTime);
                            ReferenceToMusicTime(rtFlush, &mtFlush);
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((mtTime + (MUSIC_TIME)pWave->rtDuration - 2) >= mtFlush)
                            {
                                pWave->rtDuration = mtFlush - mtTime;
                            }
                        }
                        if (pWave->rtDuration < 1) // disallow durations less than 1. This should never happen anyway.
                        {
                            pWave->rtDuration = 1;
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_CURVE && !fLeaveNotesOn )
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtEnd;
                    MUSIC_TIME mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    if( pCurve->bFlags & DMUS_CURVE_RESET )
                    {
                        mtEnd = mtStart + pCurve->mtResetDuration + pCurve->mtDuration;
                    }
                    else
                    {
                        mtEnd = mtStart + pCurve->mtDuration;
                    }
                    REFERENCE_TIME rtEnd;
                    MusicToReferenceTime( mtEnd, &rtEnd );
                    // Note: as a result of fixing 33987, the curve is no longer given
                    // a negative reset duration.  Now, the curve's duration is recomputed
                    // and its time slice is recalculated.
                    if( rtEnd >= rtFlush )
                    {
                        // reset the curve's duration
                        ReferenceToMusicTime( rtFlush, &mtEnd );
                        mtEnd -= mtStart;
                        // get the curve value at the flush time, and make that the end value
                        pCurve->nEndValue = (short) RecomputeCurveEnd(pCurve, mtEnd);
                        // subtract 2 from the duration to guarantee the curve cuts short
                        // 1 clock before the flush time.
                        mtEnd -= 2;
                        if ( mtEnd < 1)
                        {
                            mtEnd = 1;
                        }
                        else if (pCurve->bFlags & DMUS_CURVE_RESET)
                        {
                            if (mtEnd > pCurve->mtDuration)
                            {
                                // curve ends in the reset duration; keep regular duration the
                                // same as it was and adjust reset duration
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                mtEnd = pCurve->mtDuration;
                                if (pCurve->mtTime > mtEnd + pCurve->mtResetDuration + mtStart)
                                {
                                    pCurve->mtTime = mtEnd + pCurve->mtResetDuration + mtStart;
                                    MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
                                }
                            }
                            else
                            {
                                // curve ends in the regular duration; reduce it by 1 and
                                // give the reset duration a value of 1
                                mtEnd--;
                                pCurve->mtResetDuration = 1;
                                if (mtEnd < 1)
                                {
                                    // this is unlikely, but the curve really should have
                                    // a duration...
                                    mtEnd = 1;
                                }
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                            }
                            // If this is an instant curve that's already started, we
                            // don't want it to play again, so reset its start time
                            if ( pCurve->bCurveShape == DMUS_CURVES_INSTANT &&
                                 pCurve->mtOriginalStart )
                            {
                                pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart + mtEnd;
                            }
                        }
                        pCurve->mtDuration = mtEnd;
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & (PRIV_FLAG_REMOVE | PRIV_FLAG_REQUEUE))
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                if (pEvent->dwPrivFlags & PRIV_FLAG_REQUEUE)
                {
                    pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
                    pQueue->Enqueue(pEvent);
                }
                else
                {
                    FreePMsg(pEvent);
                }
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    SendBuffers();
}

/*

  Flushes all events in all queues from time <p mtFlush> on.

  comm Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::FlushMainEventQueues(
    DWORD dwId,                      // Virtual Track ID to flush, or zero for all.
    MUSIC_TIME mtFlush,              // Time to flush (resolved to timing resolution).
    MUSIC_TIME mtFlushUnresolved,    // Time to flush (unresolved).
    BOOL fLeaveNotesOn)              // If true, notes currently on are left to play through their duration.
{
    REFERENCE_TIME rt;
    if( mtFlush )
    {
        MusicToReferenceTime( mtFlush, &rt );
    }
    else
    {
        rt = 0;
    }
    REFERENCE_TIME rtUnresolved;
    if( mtFlushUnresolved && mtFlushUnresolved != mtFlush)
    {
        MusicToReferenceTime( mtFlushUnresolved, &rtUnresolved );
    }
    else
    {
        rtUnresolved = rt;
    }
    FlushEventQueue( dwId, &m_OnTimeQueue, rt, rtUnresolved, fLeaveNotesOn );
    FlushEventQueue( dwId, &m_NearTimeQueue, rt, rtUnresolved, fLeaveNotesOn );
    FlushEventQueue( dwId, &m_EarlyQueue, rt, rtUnresolved, fLeaveNotesOn );
    if (dwId == 0)
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime(rt,&mtTime);
        FlushEventQueue( dwId, &m_TempoMap, rt, rtUnresolved, fLeaveNotesOn );
        RecalcTempoMap(NULL, mtTime );
    }
}

// the only kinds of events we care about are note events.
void CPerformance::OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush )
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;
    DWORD dwId = pNotify->dwVirtualTrackID;
    DWORD dwTrackGroup = pNotify->dwGroupID;
    CPMsgQueue UpdateQueue;        // List of PMsgs to be inserted into a queue during update.

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        DMUS_PMSG* pNew = NULL;
        if( ( 0 == dwId || pEvent->dwVirtualTrackID == dwId ) &&
            (pEvent->dwType == DMUS_PMSGT_NOTE) )
        {
            REFERENCE_TIME rtTime = pEvent->rtTime;
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset;
                MusicToReferenceTime( mtNote, &rtTime );
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                REFERENCE_TIME rtFlushTime = (rtFlush <= pEvent->rtLast) ? pEvent->rtLast + REF_PER_MIL : rtFlush;
                if( pEvent->pTool &&
                    !(pNote->bFlags & DMUS_NOTEF_NOTEON) &&
                    S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlushTime, &pNew)))
                {
                    pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                    pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlushTime );
                }
                if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                {
                    UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                }
            }
            else // cut notes short if needed
            {
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    if (S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlush, &pNew)))
                    {
                        // subtract 2 from the duration to guarantee the note cuts short
                        // 1 clock before the flush time.
                        MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                        REFERENCE_TIME rtNoteOff;
                        MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                        if( rtNoteOff >= rtFlush )
                        {
                            ReferenceToMusicTime( rtFlush, &mtNoteOff );
                            mtNoteOff -= pNote->mtTime;
                            if( mtNoteOff < 1 ) mtNoteOff = 1; // disallow durations less than 1. This should never happen anyway.
                            pNote->mtDuration = mtNoteOff;
                        }
                    }
                    if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                    {
                        UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & PRIV_FLAG_REMOVE)
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                FreePMsg(pEvent);
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    // empty the Update queue into the current queue
    while( pEvent = UpdateQueue.Dequeue() )
    {
        pQueue->Enqueue(pEvent);
    }
    SendBuffers();
}

/*

  Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::OnChordUpdateEventQueues(
    DMUS_NOTIFICATION_PMSG* pNotify)    // notification PMsg that caused this to be called
{
    IDirectMusicSegmentState* pSegState = NULL;
    if (!pNotify || !pNotify->punkUser) return;
    REFERENCE_TIME rt = 0;
    if( pNotify->mtTime )
    {
        MusicToReferenceTime( pNotify->mtTime, &rt );
    }
    OnChordUpdateEventQueue( pNotify, &m_OnTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_NearTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_EarlyQueue, rt );
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance

HRESULT CPerformance::CreateThreads()

{
    // initialize the realtime thread
    m_hRealtimeThread = CreateThread(NULL, 0, _Realtime, this, 0, &m_dwRealtimeThreadID);
    if( m_hRealtimeThread )
    {
        m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
        SetThreadPriority( m_hRealtimeThread, THREAD_PRIORITY_TIME_CRITICAL );
    }
    else
    {
        TraceI(0, "Major error! Realtime thread not created.\n");
        return E_OUTOFMEMORY;
    }
    // initialize the transport thread
    m_hTransportThread = CreateThread(NULL, 0, _Transport, this, 0, &m_dwTransportThreadID);
    if( m_hTransportThread )
    {
        m_hTransport = CreateEvent(NULL, FALSE, FALSE, NULL);
        SetThreadPriority( m_hTransportThread, THREAD_PRIORITY_ABOVE_NORMAL );
    }
    else
    {
        TraceI(0, "Major error! Transport thread not created.\n");
        m_fKillRealtimeThread = TRUE;
        if( m_hRealtime ) SetEvent( m_hRealtime );
        return E_OUTOFMEMORY;
    }
    m_pDirectMusic->GetMasterClock( NULL, &m_pClock );
    m_rtStart = GetTime();
    m_rtQueuePosition = m_rtStart;
    return S_OK;
}


STDMETHODIMP CPerformance::InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,
                           DMUS_AUDIOPARAMS *pParams)

{
    V_INAME(IDirectMusicPerformance::InitAudio);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_PTRPTR_WRITE_OPT(ppDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if (ppDirectSound)
    {
        V_INTERFACE_OPT(*ppDirectSound);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: InitAudio called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    if (dwFlags == 0)
    {
        dwFlags = DMUS_AUDIOF_ALL;
    }
    Init();
    m_AudioParams.dwFeatures = dwFlags;
    m_AudioParams.dwSampleRate = 22050;
    m_AudioParams.dwSize = sizeof (m_AudioParams);
    m_AudioParams.dwValidData = DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
    m_AudioParams.dwVoices = 64;
    m_AudioParams.fInitNow = TRUE;
    m_AudioParams.clsidDefaultSynth = CLSID_DirectMusicSynth;
    if (pParams)
    {
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
        {
            m_AudioParams.dwFeatures = pParams->dwFeatures;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
        {
            m_AudioParams.dwVoices = pParams->dwVoices;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
        {
            // If they requested the DX7 default synth and yet also asked for audiopath
            // features, force to DX8 default synth.
            if ((pParams->clsidDefaultSynth != GUID_NULL) ||
                !((m_AudioParams.dwValidData & DMUS_AUDIOPARAMS_FEATURES) &&
                (m_AudioParams.dwFeatures & DMUS_AUDIOF_ALL)))
            {
                m_AudioParams.clsidDefaultSynth = pParams->clsidDefaultSynth;
            }
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
        {
            if (pParams->dwSampleRate > 96000)
            {
                m_AudioParams.dwSampleRate = 96000;
            }
            else if (pParams->dwSampleRate < 11025)
            {
                m_AudioParams.dwSampleRate = 11025;
            }
            else
            {
                m_AudioParams.dwSampleRate = pParams->dwSampleRate;
            }
        }
    }
    m_dwAudioPathMode = 2;
    EnterCriticalSection(&m_MainCrSec);
    if (ppDirectMusic && *ppDirectMusic)
    {
        hr = (*ppDirectMusic)->QueryInterface(IID_IDirectMusic8,(void **) &m_pDirectMusic);
    }
    if (SUCCEEDED(hr))
    {
        if (ppDirectSound && *ppDirectSound)
        {
            hr = (*ppDirectSound)->QueryInterface(IID_IDirectSound8,(void **) &m_pDirectSound);
        }
        if (SUCCEEDED(hr))
        {
            if (!m_pDirectSound)
            {
                hr = DirectSoundCreate8(NULL,&m_pDirectSound,NULL);
                if (SUCCEEDED(hr))
                {
                    if (!hWnd)
                    {
                        hWnd = GetForegroundWindow();
                        if (!hWnd)
                        {
                            hWnd = GetDesktopWindow();
                        }
                    }
                    m_pDirectSound->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
                }
            }

            if (SUCCEEDED(hr))
            {
                if (!m_pDirectMusic)
                {
                    hr = CoCreateInstance(CLSID_DirectMusic,
                                          NULL,
                                          CLSCTX_INPROC,
                                          IID_IDirectMusic8,
                                          (LPVOID*)&m_pDirectMusic);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDirectMusic->SetDirectSound(m_pDirectSound,hWnd);
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = m_BufferManager.Init(this,&m_AudioParams);
        if (SUCCEEDED(hr))
        {
            // If we are going to be connecting the synth to Buffers,
            // force the use of the dsound clock.
            if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
            {
                DMUS_CLOCKINFO ClockInfo;
                ClockInfo.dwSize = sizeof(ClockInfo);
                DWORD dwIndex;
                GUID guidMasterClock = GUID_NULL;
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK == m_pDirectMusic->EnumMasterClock(dwIndex, &ClockInfo))
                    {
                        if (!wcscmp(ClockInfo.wszDescription, L"DirectSound Clock"))
                        {
                            guidMasterClock = ClockInfo.guidClock;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                m_pDirectMusic->SetMasterClock(guidMasterClock);
            }
            hr = CreateThreads();
            if (SUCCEEDED(hr))
            {
                if (dwDefaultPathType)
                {
                    IDirectMusicAudioPath *pPath;
                    hr = CreateStandardAudioPath(dwDefaultPathType,dwPChannelCount,m_AudioParams.fInitNow,&pPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetDefaultAudioPath(pPath);
                        pPath->Release();
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (m_pDirectMusic && ppDirectMusic && !*ppDirectMusic)
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
        if (m_pDirectSound && ppDirectSound && !*ppDirectSound)
        {
            *ppDirectSound = m_pDirectSound;
            m_pDirectSound->AddRef();
        }
        if (pParams && pParams->fInitNow)
        {
            if (pParams->clsidDefaultSynth != m_AudioParams.clsidDefaultSynth)
            {
                pParams->clsidDefaultSynth = m_AudioParams.clsidDefaultSynth;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
                {
                    Trace(2,"Warning: Default synth choice has been changed.\n");
                    hr = S_FALSE;
                }
            }
            if (pParams->dwFeatures != m_AudioParams.dwFeatures)
            {
                pParams->dwFeatures = m_AudioParams.dwFeatures;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
                {
                    Trace(2,"Warning: Features flags has been changed to %lx.\n",pParams->dwFeatures);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwSampleRate != m_AudioParams.dwSampleRate)
            {
                pParams->dwSampleRate = m_AudioParams.dwSampleRate;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
                {
                    Trace(2,"Warning: Sample rate has been changed to %ld.\n",pParams->dwSampleRate);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwVoices != m_AudioParams.dwVoices)
            {
                pParams->dwVoices = m_AudioParams.dwVoices;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
                {
                    Trace(2,"Warning: Number of requested voices has been changed to %ld.\n",pParams->dwVoices);
                    hr = S_FALSE;
                }
            }
            pParams->dwValidData = m_AudioParams.dwValidData;
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    else
    {
        LeaveCriticalSection(&m_MainCrSec);
        CloseDown();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Init(
    IDirectMusic** ppDirectMusic,   LPDIRECTSOUND pDirectSound,HWND hWnd)
{
    V_INAME(IDirectMusicPerformance::Init);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: Init called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    Init();
    m_dwAudioPathMode = 1;
    EnterCriticalSection(&m_MainCrSec);

    if(( NULL == ppDirectMusic ) || ( NULL == *ppDirectMusic ))
    {
        // intialize DirectMusic.

        if( FAILED( CoCreateInstance(CLSID_DirectMusic,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IDirectMusic,
                              (LPVOID*)&m_pDirectMusic)))
        {
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return E_OUTOFMEMORY;
        }

        // If version2 was requested by the app (in the process of requesting the
        // IDirectMusicPerformance2 interface), do the same for IDirectMusic.
        if (m_dwVersion > 6)
        {
            IDirectMusic *pTemp = NULL;
            if (SUCCEEDED(m_pDirectMusic->QueryInterface(
                IID_IDirectMusic2,
                (LPVOID*)&pTemp)))
            {
                // Succeeded in requesting DX7 and up behavior...
                pTemp->Release();
            }
        }

        hr = m_pDirectMusic->SetDirectSound(pDirectSound, hWnd);
        if( FAILED( hr ) )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return hr;
        }

        if( ppDirectMusic )
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
    }
    else
    {
        m_pDirectMusic = (IDirectMusic8 *) *ppDirectMusic;
        m_pDirectMusic->AddRef();
    }
    if (FAILED(hr = CreateThreads()))
    {
        if( m_pDirectMusic )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
        }
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}

CSegState *CPerformance::GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom)

{
    CSegState *pSegState = NULL;

    // If the source segment was provided, use it.
    if (pFrom)
    {
        if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegState)))
        {
            pSegState->Release();
        }
    }
    // Else, if this is a primary segment, get the current primary segment.
    if (!pSegState && !(dwFlags & DMUS_SEGF_SECONDARY))
    {
        pSegState = GetPrimarySegmentAtTime(mtTime);
    }
    return pSegState;
}

void CPerformance::ClearMusicStoppedNotification()

{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    PRIV_PMSG* pNext;
    DMUS_NOTIFICATION_PMSG* pNotification;

    pPMsg = m_OnTimeQueue.GetHead(); // where notifications live normally
    for (; pPMsg ; pPMsg = pNext)
    {
        pNext = pPMsg->pNext;
        pNotification = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPMsg);
        if( ( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION ) &&
            ( pNotification->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE ) &&
            ( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MUSICSTOPPED ) )
        {
            pPMsg = m_OnTimeQueue.Dequeue(pPMsg);
            if( pPMsg ) // Should always succeeed
            {
                FreePMsg(pPMsg);
            }
            m_fMusicStopped = FALSE;
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
}

HRESULT CPerformance::PlayOneSegment(
    CSegment* pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    CSegState **ppSegState,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif

    TraceI(0,"Play Segment %lx (%ls) at time %ld with flags %lx\n",pSegment,pSegment->m_wszName,(long)i64StartTime,dwFlags);
    if( dwFlags & DMUS_SEGF_CONTROL )
    {
        dwFlags |= DMUS_SEGF_SECONDARY;
    }
    if( i64StartTime )
    {
        if(dwFlags & DMUS_SEGF_REFTIME)
        {
            // Give a grace period of 100ms.
            if( i64StartTime < (GetLatency() - (100 * REF_PER_MIL)))
            {
                Trace(1,"Error: Unable to play segment, requested clock time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)(GetLatency() - (100 * REF_PER_MIL)));
                return DMUS_E_TIME_PAST;
            }
        }
        else
        {
            MUSIC_TIME mtPrePlay;
            // Give a grace period of 100ms.
            ReferenceToMusicTime( (GetLatency() - (100 * REF_PER_MIL)), &mtPrePlay );
            if( (MUSIC_TIME)i64StartTime < mtPrePlay )
            {
                Trace(1,"Error: Unable to play segment, requested music time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)mtPrePlay);
                return DMUS_E_TIME_PAST;
            }
        }
    }

    CSegState *pSegState = NULL;
    hr = pSegment->CreateSegmentState( &pSegState, this, pAudioPath, dwFlags);
    *ppSegState = pSegState;
    if (FAILED(hr))
    {
        Trace(1,"Error: Unable to play segment because of failure creating segment state.\n");
        return DMUS_E_SEGMENT_INIT_FAILED;
    }
    pSegState->m_rtGivenStart = i64StartTime;

    pSegState->m_dwPlaySegFlags = dwFlags;

    // add the pSegState to the appropriate queue
    EnterCriticalSection(&m_SegmentCrSec);
    m_fPlaying = 1; // turn on the transport
    // add all notifications to the segment. First, clear it, in case old notifications
    // are in effect.
    pSegment->RemoveNotificationType(GUID_NULL,TRUE);
    CNotificationItem* pItem;
    pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pSegment->AddNotificationType( pItem->guidNotificationType, TRUE );
        pItem = pItem->GetNext();
    }

    if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
    {
        // we want to queue this at the last transported time,
        // so we don't need to do an invalidate
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            REFERENCE_TIME rtTrans;
            MusicToReferenceTime( m_mtTransported, &rtTrans );
            if( pSegState->m_rtGivenStart < rtTrans )
            {
                pSegState->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
        else
        {
            if( pSegState->m_rtGivenStart < m_mtTransported )
            {
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
    }
    else if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERQUEUETIME )
    {
        // we want to queue this at the queue time, as opposed to latency time,
        // which is an option for secondary segments.
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            if( pSegState->m_rtGivenStart < rtStart )
            {
                pSegState->m_rtGivenStart = rtStart;
            }
        }
        else
        {
            MUSIC_TIME mtStart;
            ReferenceToMusicTime( rtStart, &mtStart );
            if( pSegState->m_rtGivenStart < mtStart )
            {
                pSegState->m_rtGivenStart = mtStart;
            }
        }
    }
    // need to get rid of any pending musicstopped notifications
    ClearMusicStoppedNotification();

    pSegState->AddRef();

    if( dwFlags & DMUS_SEGF_SECONDARY ) // queue a secondary segment
    {
        QueueSecondarySegment( pSegState );
    }
    else // queue a primary segment
    {
        QueuePrimarySegment( pSegState );
    }

    LeaveCriticalSection(&m_SegmentCrSec);

#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    TraceI(5, "perf, debugtime PlaySegment %u\n", dwDebugTime);
#endif

    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );

    return S_OK;
}


HRESULT CPerformance::PlaySegmentInternal(
    CSegment* pSegment,
    CSong * pSong,
    WCHAR *pwzSegmentName,
    CSegment* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
    CAudioPath *pInternalPath = NULL;
    if( m_pClock == NULL )
    {
        Trace(1,"Error: Can not play segment because master clock has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    if (pAudioPath && (pAudioPath->NoPorts()))
    {
        // This audiopath can't be used for playback since it doesn't have any ports.
        Trace(1,"Error: Audiopath can't be used for playback because it doesn't have any ports.\n");
        return DMUS_E_AUDIOPATH_NOPORT;
    }

    // Pointer to segment or song provided audio path config.
    IUnknown *pConfig = NULL;

    /*  If this is a song, use the segment name to get the segment.
        Then, it looks like a normal segment except the
        existence of the pSong will let the segstate know
        that it is a member of a song, so it should chain segments.
    */
    if (pSong)
    {
        IDirectMusicSegment *pISegment = NULL;
        hr = pSong->GetSegment(pwzSegmentName,&pISegment);
        if (hr != S_OK)
        {
            return DMUS_E_NOT_FOUND;
        }
        pSegment = (CSegment *) pISegment;
        // If the app wants an audiopath created dynamically from the song, find it and use it.
        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
        {
            pSong->GetAudioPathConfig(&pConfig);
        }
    }
    else if (pSegment)
    {
        // Addref so we can release later.
        pSegment->AddRef();
    }
    else
    {
        // No Segment!
        Trace(1,"Error: No segment - nothing to play!\n");
        return E_FAIL;
    }
    if (dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwResTemp;
        pSegment->GetDefaultResolution( &dwResTemp );
        dwFlags &= ~DMUS_SEGF_DEFAULT;
        dwFlags |= dwResTemp;
    }
    // If the app wants an audiopath created dynamically from the segment, find it and use it.
    // Note that this overrides an audiopath created from the song.
    if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
    {
        IUnknown *pSegConfig;
        if (SUCCEEDED(pSegment->GetAudioPathConfig(&pSegConfig)))
        {
            if (pConfig)
            {
                pConfig->Release();
            }
            pConfig = pSegConfig;
        }
    }

    // If we got an audiopath config from the segment or song, use it.
    if (pConfig)
    {
        IDirectMusicAudioPath *pNewPath;
        if (SUCCEEDED(CreateAudioPath(pConfig,TRUE,&pNewPath)))
        {
            // Now, get the CAudioPath structure.
            if (SUCCEEDED(pNewPath->QueryInterface(IID_CAudioPath,(void **) &pInternalPath)))
            {
                pAudioPath = pInternalPath;
            }
            pNewPath->Release();
        }
        else
        {
            pConfig->Release();
            Trace(1,"Error: Embedded audiopath failed to create, segment will not play.\n");
            return DMUS_E_NO_AUDIOPATH;
        }
        pConfig->Release();
    }

    if (pTransition)
    {
        pTransition->AddRef();
    }

    if ((dwFlags & DMUS_SEGF_SECONDARY) && (dwFlags & DMUS_SEGF_QUEUE))
    {
        // Can only queue if there's a segment to queue after.
        if (pFrom)
        {
            CSegState *pSegFrom = NULL;
            if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegFrom)))
            {
                // Calculate the time at which the preceding segment will stop.
                MUSIC_TIME mtStartTime = pSegFrom->GetEndTime( pSegFrom->m_mtResolvedStart );
                i64StartTime = mtStartTime;
                dwFlags &= ~DMUS_SEGF_REFTIME;
                pSegFrom->Release();
            }
        }
    }

    // If auto-transition is requested,
    // get the transition template, if it exists,
    // and compose a segment with it.
    CSegment *pPlayAfter = NULL;    // This will hold the second segment, if we end up with a transition.
    DWORD dwFlagsAfter = dwFlags & (DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL);
    if ( dwFlags & DMUS_SEGF_AUTOTRANSITION )
    {
        // First, calculate the time to start the transition.
        // Note: this will be done again later. We really need to fold this all together.
        REFERENCE_TIME rtTime;
        if (i64StartTime == 0)
        {
            GetQueueTime( &rtTime );
        }
        else if (dwFlags & DMUS_SEGF_REFTIME)
        {
            rtTime = i64StartTime;
        }
        else
        {
            MusicToReferenceTime((MUSIC_TIME) i64StartTime,&rtTime);
        }
        REFERENCE_TIME rtResolved;
        GetResolvedTime(rtTime, &rtResolved,dwFlags);
        MUSIC_TIME mtTime;  // Actual time to start transition.
        ReferenceToMusicTime(rtResolved,&mtTime);

        CSegment *pPriorSeg = NULL;
        // Find the segment that is active at transition time.
        CSegState *pPriorState = GetSegmentForTransition(dwFlags,mtTime,pFrom);
        if (pPriorState)
        {
            pPriorSeg = pPriorState->m_pSegment;
        }
        // If this is a song, use the id to get the transition.
        if (pSong && !pTransition)
        {
            DMUS_IO_TRANSITION_DEF Transition;
            // Now, find out what sort of transition is expected.
            if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,pSegment,&Transition)))
            {
                if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                {
                    if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                    {
                        dwFlags = Transition.dwPlayFlags;
                    }
                }
                else
                {
                    dwFlags = Transition.dwPlayFlags;
                }
            }
        }
        if (pTransition)
        {
            IDirectMusicSegment *pITransSegment = NULL;
            if (pPriorState)
            {
                pTransition->Compose(mtTime - pPriorState->m_mtOffset, pPriorSeg, pSegment, &pITransSegment);
            }
            else
            {
                pTransition->Compose(0,pPriorSeg,pSegment,&pITransSegment);
            }
            // Now, if we successfully composed a transition segment, set it up to be the one we
            // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
            // to play after the transition.
            if (pITransSegment)
            {
                pPlayAfter = pSegment;
                pSegment = (CSegment *) pITransSegment;
            }
        }
    }
    if (pSegment)
    {
        CSegState *pSegState;
        if (!pAudioPath)
        {
            pAudioPath = m_pDefaultAudioPath;
        }
        if (pAudioPath && !pAudioPath->IsActive())
        {
            Trace(1,"Error: Can not play segment on inactive audiopath\n");
            hr = DMUS_E_AUDIOPATH_INACTIVE;
        }
        else if ((m_dwAudioPathMode != 1) && !pAudioPath)
        {
            Trace(1,"Error: No audiopath to play segment on.\n");
            hr = DMUS_E_NO_AUDIOPATH;
        }
        else
        {
            if (ppSegmentState)
            {
                *ppSegmentState = NULL;
            }
            hr = PlayOneSegment(
                pSegment,
                dwFlags,
                i64StartTime,
                &pSegState,
                pAudioPath);
            if (SUCCEEDED(hr))
            {
                if (pFrom)
                {
                    pSegState->m_fCanStop = FALSE;
                    StopEx(pFrom, pSegState->m_mtResolvedStart, 0);
                    pSegState->m_fCanStop = TRUE;
                }
                // If this was actually a transition segment, now we need to play the original segment!
                if (pPlayAfter)
                {
                    MUSIC_TIME mtStartTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart );
                    pSegState->Release();
                    hr = PlayOneSegment(pPlayAfter,dwFlagsAfter,mtStartTime,&pSegState,pAudioPath);
                }
                if (SUCCEEDED(hr))
                {
                    if (pSong)
                    {
                        pSegState->m_fSongMode = TRUE;
                    }
                    if (ppSegmentState)
                    {
                        *ppSegmentState = pSegState;
                    }
                    else
                    {
                        pSegState->Release();
                    }
                }
            }
        }
    }
    else
    {
        // There never was a segment to play, not even a transition.
        Trace(1,"Error: No segment to play.\n");
        hr = E_INVALIDARG;
    }
    // Before leaving, reduce the reference counts on variables that have been addref'd.
    if (pSegment)
    {
        pSegment->Release();
    }
    if (pTransition)
    {
        pTransition->Release();
    }
    if (pPlayAfter)
    {
        pPlayAfter->Release();
    }
    if (pInternalPath)
    {
        pInternalPath->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegment(
    IDirectMusicSegment *pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState **ppSegmentState)
{
    V_INAME(IDirectMusicPerformance::PlaySegment);
    V_INTERFACE(pSegment);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    CSegment *pCSourceSegment = NULL;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
    {
        pCSourceSegment->Release();
    }
    else
    {
        Trace(1,"Error: Invalid segment object passed to PlaySegment(). Segment must be created using CLSID_DirectMusicSegment object.\n");
        return E_POINTER;
    }
    return PlaySegmentInternal(pCSourceSegment,NULL,0,NULL,dwFlags,i64StartTime,ppSegmentState,NULL,NULL);
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegmentEx(
    IUnknown* pSource,
    WCHAR *pwzSegmentName,
    IUnknown* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::PlaySegmentEx);
    V_INTERFACE_OPT(pSource);
    V_INTERFACE_OPT(pTransition);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    V_INTERFACE_OPT(pFrom);
    V_INTERFACE_OPT(pAudioPath);

    CSegment *pCSourceSegment = NULL;
    CSong *pCSourceSong = NULL;
    CSegment *pCTransition = NULL;
    CAudioPath *pCAudioPath = NULL;
//    TraceI(0,"Playing %lx at time %ld, flags %lx, Transition %lx\n",pSource,(long)i64StartTime,dwFlags,pTransition);

    // We may not have a source segment in the special case of transitioning from NULL.
    if (!pSource && !pTransition)
    {
        Trace(1,"Error: Must pass either a segment or transition segment to PlaySegmentEx()\n");
        return E_POINTER;
    }
    if (pSource)
    {
        // Figure out if we have a source song or segment and get the internal representations.
        if (SUCCEEDED(pSource->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
        {
            pCSourceSegment->Release();
        }
        else if (SUCCEEDED(pSource->QueryInterface(IID_CSong,(void **) &pCSourceSong)))
        {
            pCSourceSong->Release();
        }
        else
        {
            Trace(1,"Error: Invalid segment or song passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    // If we have a transition segment, get the CSegment representation.
    if (pTransition)
    {
        if (SUCCEEDED(pTransition->QueryInterface(IID_CSegment,(void **) &pCTransition)))
        {
            pCTransition->Release();
        }
        else
        {
            Trace(1,"Error: Invalid transition passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCAudioPath)))
        {
            pCAudioPath->Release();
        }
        else
        {
            Trace(1,"Error: Invalid audiopath passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    return PlaySegmentInternal(pCSourceSegment,pCSourceSong,pwzSegmentName,
        pCTransition,dwFlags,i64StartTime,
        ppSegmentState,pFrom,
        pCAudioPath);
}

STDMETHODIMP CPerformance::SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::SetDefaultAudioPath);
    V_INTERFACE_OPT(pAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance initialized not to support Audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    CAudioPath *pCPath = NULL;
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCPath)))
        {
            pCPath->Release();
            if (!m_AudioPathList.IsMember(pCPath))
            {
                // This is not a legal audiopath, since it wasn't created by this performance.
                Trace(1,"Error: Invalid audiopath - not created by this Performance.\n");
                return E_INVALIDARG;
            }
            if (pCPath->NoPorts())
            {
                // This is an audiopath that doesn't have any port configurations.
                // For example, it might be environmental reverb.
                Trace(1,"Error: Failure setting default audiopath - does not have any ports, so can not be played on.\n");
                return DMUS_E_AUDIOPATH_NOPORT;
            }
        }
        else
        {
            // This is not a legal audiopath object at all.
            Trace(1,"Error: Invalid audiopath - not created by call to Performance->CreateAudioPath().\n");
            return E_INVALIDARG;
        }
    }
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_pDefaultAudioPath = pCPath;
    if (pCPath)
    {
        pCPath->AddRef();
        pCPath->Activate(TRUE);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::GetDefaultAudioPath(IDirectMusicAudioPath **ppAudioPath)
{
    V_INAME(IDirectMusicPerformance::GetDefaultAudioPath);
    V_PTRPTR_WRITE(ppAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance was initialized not to support audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    if (m_pDefaultAudioPath)
    {
        *ppAudioPath = (IDirectMusicAudioPath *) m_pDefaultAudioPath;
        m_pDefaultAudioPath->AddRef();
        return S_OK;
    }
    Trace(3,"Warning: No default audiopath\n");
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CPerformance::CreateAudioPath( IUnknown *pSourceConfig,
                                                        BOOL fActivate,
                                                        IDirectMusicAudioPath **ppNewPath)

{
    V_INAME(IDirectMusicPerformance::CreateAudioPath);
    V_INTERFACE(pSourceConfig);
    V_PTRPTR_WRITE_OPT(ppNewPath);

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance not initialized to support audiopaths (must use InitAudio.)\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    HRESULT hr = E_OUTOFMEMORY;
    CAudioPath *pPath = new CAudioPath;
    if (pPath)
    {
        hr = pPath->Init(pSourceConfig,this);
        if (SUCCEEDED(hr) && fActivate)
        {
            hr = pPath->Activate(TRUE);
#ifdef DBG
            if (FAILED(hr))
            {
                Trace(1,"Error: Audiopath creation failed because one or more buffers could not be activated.\n");
            }
#endif
        }
        if (SUCCEEDED(hr))
        {
            hr = pPath->QueryInterface(IID_IDirectMusicAudioPath,(void **) ppNewPath);
        }
        else
        {
            delete pPath;
        }
    }
    return hr;
}

STDMETHODIMP CPerformance::CreateStandardAudioPath(DWORD dwType,
                                                   DWORD dwPChannelCount,
                                                   BOOL fActivate,
                                                   IDirectMusicAudioPath **ppNewPath)
{
    V_INAME(IDirectMusicPerformance::CreateStandardAudioPath);
    V_PTRPTR_WRITE_OPT(ppNewPath);
    HRESULT hr = S_OK;
    if (m_dwAudioPathMode == 2)
    {
        if ((dwType <= DMUS_APATH_DYNAMIC_STEREO) && (dwType >= DMUS_APATH_DYNAMIC_3D)
            || (dwType == DMUS_APATH_SHARED_STEREOPLUSREVERB))
        {
            if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
            {
                Trace(4,"Warning: Creating a standard audiopath without buffers - InitAudio specified no buffer support.\n");
                // If the default synth doesn't support buffers, then create a simple port with no buffers.
                dwType = 0;
            }
            CAudioPathConfig *pConfig = CAudioPathConfig::CreateStandardConfig(dwType,dwPChannelCount,m_AudioParams.dwSampleRate);
            if (pConfig)
            {
                hr = CreateAudioPath((IPersistStream *) pConfig,fActivate,ppNewPath);
                pConfig->Release();
            }
            else
            {
                // CreateStandardConfig only returns NULL if we've run out of memory.
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Trace(1,"Error: %ld is not a valid predefined audiopath.\n",dwType);
            hr  = E_INVALIDARG;
        }
    }
    else
    {
        Trace(1,"Error: Performance not initialized to support audiopaths.\n");
        hr = DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    return hr;
}

// Stop the segment state at mtTime. If NULL, stop all.
void CPerformance::DoStop( CSegState* pSegState, MUSIC_TIME mtTime,
                                     BOOL fInvalidate)
{
    HRESULT hrAbort = S_OK;
    DWORD dwCount;
    if( NULL == pSegState ) return;
    EnterCriticalSection(&m_SegmentCrSec);
    CSegStateList *pSourceList = NULL;
    CSegStateList *pDestList = NULL;
    CSegState *pNode = NULL;
    // Mark the length of the segstate to be only as far as it played
    // to keep GetParam() from accessing the unplayed portion.
    if (pSegState)
    {
        if (mtTime < pSegState->m_mtEndTime)
        {
            pSegState->m_mtLength = mtTime - pSegState->m_mtResolvedStart +
                pSegState->m_mtStartPoint;
            if (pSegState->m_mtLength < 0)
            {
                pSegState->m_mtLength = 0;
            }
            // Make endtime one greater than mtTime so Abort notification will still happen.
            pSegState->m_mtEndTime = mtTime + 1;
        }
    }
    RecalcTempoMap(pSegState,mtTime);
    // check each play queue
    for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
        {
            if( pNode == pSegState )
            {
                // we want to move this to the approprate done queue
                pDestList = &m_SegStateQueues[SQ_PRI_DONE - SQ_PRI_PLAY + dwCount];
                pSourceList = &m_SegStateQueues[dwCount];
                if ((dwCount == SQ_PRI_PLAY) && (m_SegStateQueues[SQ_PRI_PLAY].GetCount() == 1))
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegState );
                    }
                }
                dwCount = SQ_SEC_PLAY;  // Force out of outer loop.
                break;
            }
        }
    }
    if (!pNode)
    {
        // check each done queue
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
            {
                if( pNode == pSegState )
                {
                    pSourceList = &m_SegStateQueues[dwCount];
                    dwCount = SQ_SEC_DONE;  // Force out of outer loop.
                    break;
                }
            }
        }
    }
    if( pNode && pSourceList)
    {
        REFERENCE_TIME rtTime;
        MusicToReferenceTime(mtTime,&rtTime);
        if( pNode->m_mtLastPlayed >= mtTime )
        {
            pNode->Flush( mtTime );
            pNode->m_mtLastPlayed = mtTime; // must set this to indicate it only played until then
            pNode->m_rtLastPlayed = rtTime;
        }
        if( fInvalidate )
        {
            if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
            {
                Invalidate( mtTime, 0 ); // must call Invalidate before AbortPlay so we don't
                // invalidate the abort notification
            }
            else if ( !(pNode->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY ))
            {
                // If this is a primary segment, kill the tempo map.
                FlushEventQueue( 0, &m_TempoMap, rtTime, rtTime, FALSE );
            }
        }
        hrAbort = pNode->AbortPlay( mtTime, FALSE );
        if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            pSourceList->Remove(pNode);
            m_ShutDownQueue.Insert(pNode); // we're guaranteed to never need this again

            // set dirty flags on all other segments

            for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if( pNode->m_fStartedPlay )
                    {
                        pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                    }
                }
            }
        }
        else if( pDestList )
        {
            pSourceList->Remove(pNode);
            pDestList->Insert(pNode);
        }
    }
    else
    {
        // check the wait lists.
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode == pSegState )
                {
                    hrAbort = pNode->AbortPlay( mtTime, FALSE );
                    m_SegStateQueues[dwCount].Remove(pNode);
                    RecalcTempoMap(pNode, mtTime);
                    m_ShutDownQueue.Insert(pNode);
                    break;
                }
            }
        }
    }
    // if there aren't any more segments to play, send a Music Stopped
    // notification
    if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
        m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
        m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty())
    {
        m_fMusicStopped = TRUE;
        // S_FALSE means we tried to abort this segstate, but it's already been aborted
        if (hrAbort != S_FALSE)
        {
            GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtTime, NULL );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

// Stop all segment states based off of the segment.
void CPerformance::DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate )
{
    DWORD dwCount;
    CSegState* pNode;
    CSegState* pNext;
    EnterCriticalSection(&m_SegmentCrSec);
    // find all seg pSegStates based off this segment that have played through time mtTime
    // if pSeg is NULL, go through all of the segment lists. Flush any
    // segment that played through time mtTime. Move any active segments
    // into past lists.
    if( pSeg )
    {
        for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
        {
            pNode = m_SegStateQueues[dwCount].GetHead();
            while( pNode )
            {
                pNext = pNode->GetNext();
                if( pNode->m_pSegment == pSeg )
                {
                    if (IsDoneQueue(dwCount))
                    {
                        if (pNode->m_mtLastPlayed >= mtTime)
                        {
                             DoStop( pNode, mtTime, fInvalidate );
                        }
                    }
                    else
                    {
                        DoStop( pNode, mtTime, fInvalidate );
                    }
                }
                pNode = pNext;
            }
        }
    }
    else // pSeg is NULL, stop everything.
    {
        // go ahead and flush the event queues
        EnterCriticalSection(&m_PipelineCrSec);
        FlushMainEventQueues( 0, mtTime, mtTime, FALSE );
        LeaveCriticalSection(&m_PipelineCrSec);
        // clear out the wait lists
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while (pNode = m_SegStateQueues[dwCount].GetHead())
            {
                pNode->AbortPlay( mtTime, FALSE );
                m_SegStateQueues[dwCount].RemoveHead();
                m_ShutDownQueue.Insert(pNode);
            }
        }
        // stop any segment that is currently playing.
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_mtLastPlayed >= mtTime )
                {
                    DoStop( pNode, mtTime, fInvalidate );
                }
            }
        }
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                DoStop( m_SegStateQueues[dwCount].GetHead(), mtTime, fInvalidate );
            }
        }
        // reset controllers and force all notes off.
        ResetAllControllers( GetLatency() );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}


STDMETHODIMP CPerformance::StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags)
{
    V_INAME(IDirectMusicPerformance::StopEx);
    V_INTERFACE_OPT(pObjectToStop);
    HRESULT hr = E_INVALIDARG;
    IDirectMusicSegmentState *pState;
    IDirectMusicSegment *pSegment;
    CSong *pSong;
    CAudioPath *pAudioPath;
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
TraceI(0,"StopExing %lx at time %ld, flags %lx\n",pObjectToStop,(long)i64StopTime,dwFlags);
    if (pObjectToStop == NULL)
    {
        return Stop(NULL,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
    }
    if (dwFlags & DMUS_SEGF_AUTOTRANSITION)
    {
        // I this is an autotransition, it will only work if the currently playing segment in question
        // is a member of a song. So, check the segstate, segment, song, and audiopath
        // to find the segstate. And, if found, see if it is part of a song. If so,
        // then go ahead and do the transition.
        EnterCriticalSection(&m_SegmentCrSec);
        BOOL fTransition = FALSE;
        dwFlags &= ~DMUS_SEGF_AUTOTRANSITION;
        CSegState *pCState = NULL;
        // First, see if this is a segstate.
        HRESULT hrTemp = pObjectToStop->QueryInterface(IID_CSegState,(void **)&pCState);
        if (FAILED(hrTemp))
        {
            // Segstate failed. Is this a Song? If so, find the first correlating segstate.
            CSong *pCSong = NULL;
            CAudioPath *pCAudioPath = NULL;
            CSegment *pCSegment = NULL;
            hrTemp = pObjectToStop->QueryInterface(IID_CSong,(void **)&pCSong);
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CSegment,(void **)&pCSegment);
            }
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CAudioPath,(void **)&pCAudioPath);
            }
            if (SUCCEEDED(hrTemp))
            {
                CSegState *pNode;
                DWORD dwCount;
                for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if (pNode->m_fCanStop)
                        {
                            // Can only do this if the segstate ultimately points to a song.
                            if (pNode->m_pSegment && pNode->m_pSegment->m_pSong)
                            {
                                if ((pNode->m_pSegment == pCSegment) ||
                                    (pNode->m_pSegment->m_pSong == pCSong) ||
                                    (pCAudioPath && (pNode->m_pAudioPath == pCAudioPath)))
                                {
                                    pCState = pNode;
                                    pCState->AddRef();
                                    break;
                                }
                            }
                        }
                    }
                    if (pCState) break;
                }
            }
            if (pCSong) pCSong->Release();
            else if (pCAudioPath) pCAudioPath->Release();
            else if (pCSegment) pCSegment->Release();
        }
        if (pCState)
        {
            CSegment *pPriorSeg = pCState->m_pSegment;
            if (pPriorSeg)
            {
                pSong = pPriorSeg->m_pSong;
                if (pSong)
                {
                    // If this is an autotransition, compose a transition segment from the
                    // current position in the song and play it.
                    // This will, in turn, call stop on the song, so we don't need to do it here.
                    // First, calculate the time to start the transition.
                    REFERENCE_TIME rtTime;
                    if (i64StopTime == 0)
                    {
                        GetQueueTime( &rtTime );
                    }
                    else if (dwFlags & DMUS_SEGF_REFTIME)
                    {
                        rtTime = i64StopTime;
                    }
                    else
                    {
                        MusicToReferenceTime((MUSIC_TIME) i64StopTime,&rtTime);
                    }
                    REFERENCE_TIME rtResolved;
                    GetResolvedTime(rtTime, &rtResolved,dwFlags);
                    MUSIC_TIME mtTime;  // Actual time to start transition.
                    ReferenceToMusicTime(rtResolved,&mtTime);

                    CSegment *pTransition = NULL;
                    // Now, get the transition.
                    DMUS_IO_TRANSITION_DEF Transition;
                    if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,NULL,&Transition)))
                    {
                        if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                        {
                            if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                            {
                                dwFlags = Transition.dwPlayFlags;
                            }
                        }
                    }
                    if (pTransition)
                    {
                        IDirectMusicSegment *pITransSegment = NULL;
                        pTransition->Compose(mtTime - pCState->m_mtOffset, pPriorSeg, NULL, &pITransSegment);
                        // Now, if we successfully composed a transition segment, set it up to be the one we
                        // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
                        // to play after the transition.
                        if (pITransSegment)
                        {
                            hr = PlaySegmentEx(pITransSegment,NULL,NULL,dwFlags,i64StopTime,NULL,(IDirectMusicSegmentState *)pCState,NULL);
                            pITransSegment->Release();
                            fTransition = TRUE;
                        }
                        pTransition->Release();
                    }
                }
            }
            pCState->Release();
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if (fTransition)
        {
            return hr;
        }
    }
    if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegmentState,(void **) &pState)))
    {
        hr = Stop(NULL,pState,(MUSIC_TIME)i64StopTime,dwFlags);
        pState->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegment,(void **) &pSegment)))
    {
        hr = Stop(pSegment,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
        pSegment->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CAudioPath,(void **) &pAudioPath)))
    {
        pAudioPath->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            CSegState *pNext;
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNext )
            {
                pNext = pNode->GetNext();
                if (pNode->m_fCanStop && (pNode->m_pAudioPath == pAudioPath))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CSong,(void **) &pSong)))
    {
        pSong->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if (pNode->m_fCanStop && pNode->m_pSegment && (pNode->m_pSegment->m_pSong == pSong))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
     }

    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::Stop(
    IDirectMusicSegment *pISegment, // @parm The Segment to stop playing. All SegmentState's based upon this Segment are
                                    // stopped playing at time <p mtTime>.
    IDirectMusicSegmentState *pISegmentState, // @parm The SegmentState to stop playing.
    MUSIC_TIME mtTime,  // @parm The time at which to stop the Segments, Segment State, or everything. If
                                    // this time is in the past, stop everything right away. Therefore, a value of
                                    // 0 indicates stop everything NOW.
    DWORD dwFlags)      // @parm Flag that indicates whether we should stop immediately at time <p mtTime>,
                                    // or on the grid, measure, or beat following <p mtTime>. This is only valid in
                                    // relation to the currently playing primary segment. (For flag descriptions,
                                    // see <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicPerformance::Stop);
    V_INTERFACE_OPT(pISegment);
    V_INTERFACE_OPT(pISegmentState);

    EnterCriticalSection(&m_SegmentCrSec);

    CSegment *pSegment = NULL;
    CSegState *pSegmentState = NULL;
TraceI(0,"Stopping Segment %lx, SegState %lx at time %ld, flags %lx\n",pISegment,pISegmentState,mtTime,dwFlags);
    if (pISegmentState)
    {
        if (SUCCEEDED(pISegmentState->QueryInterface(IID_CSegState,(void **)&pSegmentState)))
        {
            pISegmentState->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in SegState parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pISegment)
    {
        if (SUCCEEDED(pISegment->QueryInterface(IID_CSegment,(void **)&pSegment)))
        {
            pISegment->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in Segment parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pSegmentState)
    {
        // If this is the starting segstate from a playing song, find the
        // current active segstate within that song.
        // The current active segstate keeps a pointer to
        // this segstate.
        if (pSegmentState->m_fSongMode)
        {
            CSegState* pNode;
            DWORD dwCount;
            for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if (pNode->m_pSongSegState == pSegmentState)
                    {
                        pSegmentState = pNode;
                        dwCount = SQ_COUNT;
                        break;
                    }
                }
            }
        }
    }
    if( dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwNewRes = 0;
        if( pSegment )
        {
            pSegment->GetDefaultResolution( &dwNewRes );
        }
        else if( pSegmentState )
        {
            IDirectMusicSegment*    pSegTemp;
            if( SUCCEEDED( pSegmentState->GetSegment( &pSegTemp ) ) )
            {
                pSegTemp->GetDefaultResolution( &dwNewRes );
                pSegTemp->Release();
            }
            else
            {
                dwNewRes = 0;
            }
        }
        else
        {
            dwNewRes = 0;
        }
        dwFlags |= dwNewRes;
        dwFlags &= ~DMUS_SEGF_DEFAULT;
    }
    // Make sure mtTime is greater or equal to QueueTime, which is the last time notes were
    // queued down (or latency time, whichever is later) so we can stop everything after it.
    MUSIC_TIME mtLatency;
    REFERENCE_TIME rtQueueTime;
    GetQueueTime( &rtQueueTime );
    ReferenceToMusicTime( rtQueueTime, &mtLatency );
    if( mtTime < mtLatency ) mtTime = mtLatency;
    // Resolve the time according to the resolution
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // if mtTime is less than the current transported time, we can take
    // care of the Stop now. Otherwise, we need to cue a Stop PMsg and
    // take care of it at QUEUE time.
    if( mtTime <= m_mtTransported )
    {
        if( pSegmentState )
        {
            DoStop( pSegmentState, mtTime, TRUE );
            if( pSegment )
            {
                DoStop( pSegment, mtTime, TRUE );
            }
        }
        else
        {
            DoStop( pSegment, mtTime, TRUE );
        }
    }
    else
    {
        // find and mark the segment and/or segment state to not play beyond
        // the stop point.
        CSegState* pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( (pNode->m_pSegment == pSegment) ||
                    (pNode == pSegmentState) )
                {
                    if (pNode->m_fCanStop)
                    {
                        pNode->m_mtStopTime = mtTime;
                        // Make sure GetParams ignore the rest of the segment from now on.
                        if (mtTime < pNode->m_mtEndTime)
                        {
                            pNode->m_mtLength = mtTime - pNode->m_mtResolvedStart +
                                pNode->m_mtStartPoint;
                            if (pNode->m_mtLength < 0)
                            {
                                pNode->m_mtLength = 0;
                            }
                            // Make endtime one greater than mtTime so Abort notification will still happen.
                            pNode->m_mtEndTime = mtTime + 1;
                        }
                        // Force the tempo map to be recalculated IF this has a tempo track.
                        RecalcTempoMap(pNode,mtTime);
                    }
                }
            }
        }

        // create a Stop PMsg and cue it for QUEUE time
        // I've removed this to fix bugs. A stop message at queue time, 
        // if in a controlling or primary segment, results in invalidation.
        // This is particularily bad for controlling segments.
        // Can't figure out why we even need the stop message...
/*      DMUS_PMSG* pPMsg;

        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg )))
        {
            pPMsg->dwType = DMUS_PMSGT_STOP;
            pPMsg->mtTime = mtTime;
            pPMsg->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
            if( pSegment )
            {
                pSegment->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
                if( pSegmentState )
                {
                    // if there is also a segment state pointer, we need to create two
                    // pmsg's
                    DMUS_PMSG* pPMsg2;

                    if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg2 )))
                    {
                        pPMsg2->dwType = DMUS_PMSGT_STOP;
                        pPMsg2->mtTime = mtTime;
                        pPMsg2->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
                        pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg2->punkUser );
                        pPMsg2->pTool = this;
                        AddRef();
                        if(FAILED(SendPMsg( pPMsg2 )))
                        {
                            FreePMsg(pPMsg2);
                        }
                    }
                }
            }
            else if( pSegmentState )
            {
                pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
            }
            pPMsg->pTool = this;
            AddRef();
            if(FAILED(SendPMsg( pPMsg )))
            {
                FreePMsg(pPMsg);
            }
        }*/
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_OK;
}

void CPerformance::ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset)

{
    DWORD dwIndex = pChannelMap->dwPortIndex;
    DWORD dwGroup = pChannelMap->dwGroup;
    DWORD dwMChannel = pChannelMap->dwMChannel;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    IDirectMusicPort* pPort = m_pPortTable[dwIndex].pPort;
    IDirectMusicBuffer* pBuffer = m_pPortTable[dwIndex].pBuffer;
    if( pPort && pBuffer )
    {
        m_pPortTable[dwIndex].fBufferFilled = TRUE;
        if (!rtTime)
        {
            rtTime = m_pPortTable[dwIndex].rtLast + 1;
        }
        else
        {
            m_pPortTable[dwIndex].rtLast = rtTime;
        }
        pChannelMap->Reset(true);
        DWORD dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8); // 0x78 is all sounds off.
        if( FAILED( pBuffer->PackStructured( rtTime, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime, dwGroup, dwMsg );
        }
        dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16) ; // 0x79 is reset all controllers. Data byte set to indicate volume and pan too.
        if( FAILED( pBuffer->PackStructured( rtTime + 30 * REF_PER_MIL, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime + (30 * REF_PER_MIL), dwGroup, dwMsg );
        }
        // Send one GM Reset per channel group, but only under DX8 (and only if we need to).
        if ((dwMChannel == 0) && (m_dwVersion >= 8) && fGMReset)
        {
            // create a buffer of the right size
            DMUS_BUFFERDESC dmbd;
            IDirectMusicBuffer *pLocalBuffer;
            static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX };
            memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
            dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
            dmbd.cbBuffer = 50;

            EnterCriticalSection(&m_MainCrSec);
            if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pLocalBuffer, NULL)))
            {
                if( SUCCEEDED( pLocalBuffer->PackUnstructured( rtTime + (30 * REF_PER_MIL), dwGroup,
                    6, abGMReset ) ) )
                {
                    pPort->PlayBuffer(pLocalBuffer);
                }
                pLocalBuffer->Release();
            }
            LeaveCriticalSection(&m_MainCrSec);
        }
        m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
                                                             // before next start.
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}


void CPerformance::ResetAllControllers( REFERENCE_TIME rtTime )
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock;
    SendBuffers();
    for( pChannelBlock = m_ChannelBlockList.GetHead(); pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        CChannelMap* pChannelMap;
        for( DWORD dwPChannel = pChannelBlock->m_dwPChannelStart;
            dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE;
            dwPChannel++ )
        {
            pChannelMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
            if( pChannelMap->dwGroup ) // Valid group?
            {
                // Reset controllers and send a GM reset.
                ResetAllControllers(pChannelMap, rtTime, true);
            }
        }
    }
    SendBuffers();

    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

// internal: return CSegState* at time mtTime
// only call this from within a segment critical section
CSegState* CPerformance::GetPrimarySegmentAtTime( MUSIC_TIME mtTime )
{
    CSegState* pSegNode;
    CSegState* pSegReturn = NULL;
    BOOL fCheckedPri = FALSE;
    for( pSegNode = m_SegStateQueues[SQ_PRI_DONE].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        // if we're checking the past list, only check up until the last time played.
        if( (mtTime >= pSegNode->m_mtResolvedStart) && (mtTime <= pSegNode->m_mtLastPlayed) )
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        MUSIC_TIME mtTest = mtTime;
        MUSIC_TIME mtOffset;
        DWORD dwRepeat;
        // if we're checking the current list, check the full segment time
        if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    if (!pSegReturn)
    {
        for( pSegNode = m_SegStateQueues[SQ_PRI_WAIT].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
        {
            MUSIC_TIME mtTest = mtTime;
            MUSIC_TIME mtOffset;
            DWORD dwRepeat;
            // if we're checking the current list, check the full segment time
            if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
            {
                pSegReturn = pSegNode;
                break;
            }
        }
    }
    return pSegReturn;
}

/*

  @method HRESULT | IDirectMusicPerformance | GetSegmentState |
  Returns the Primary SegmentState at time <p mtTime>.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | ppSegmentState is NULL or invalid.
  @rvalue DMUS_E_NOT_FOUND | There is no currently playing SegmentState or one at <p mtTime>.

  @comm This function is intended for routines that need to access the currently
  playing SegmentState, e.g. to obtain the chord or command track. "Currently
  Playing" in this context means that it is being called into to perform messages.
  I.e., this includes all latencies and doesn't imply that this
  SegmentState is currenty being "heard" through the speakers.

*/
HRESULT STDMETHODCALLTYPE CPerformance::GetSegmentState(
    IDirectMusicSegmentState **ppSegmentState,  // @parm Returns the SegmentState pointer to the one currently playing.
                                                // The caller is responsible for calling Release on this pointer.
    MUSIC_TIME mtTime ) // @parm Return the SegmentState which played, is playing, or will
                        // be playing at mtTime. To get the currently playing segment, pass the
                        // mtTime retrieved from <om .GetTime>.
{
    V_INAME(IDirectMusicPerformance::GetSegmentState);
    V_PTRPTR_WRITE(ppSegmentState);

    CSegState* pSegNode;
    HRESULT hr;
    EnterCriticalSection(&m_SegmentCrSec);
    if( pSegNode = GetPrimarySegmentAtTime( mtTime ))
    {
        *ppSegmentState = pSegNode;
        pSegNode->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(3,"Unable to find a segment state at time %ld\n",mtTime);
        hr  = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetPrepareTime |
  Sets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetPrepareTime(
    DWORD dwMilliSeconds) // @parm The amount of time.
{
    m_dwPrepareTime = dwMilliSeconds;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetPrepareTime |
  Gets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetPrepareTime(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetPrepareTime);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwPrepareTime;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetBumperLength |
  Sets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetBumperLength(
    DWORD dwMilliSeconds)   // @parm The amount of time.
{
    m_dwBumperLength = dwMilliSeconds;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetBumperLength |
  Gets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetBumperLength(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetBumperLength);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwBumperLength;
    return S_OK;
}

#define RESOLVE_FLAGS (DMUS_TIME_RESOLVE_AFTERPREPARETIME | \
                       DMUS_TIME_RESOLVE_AFTERLATENCYTIME | \
                       DMUS_TIME_RESOLVE_AFTERQUEUETIME | \
                       DMUS_TIME_RESOLVE_BEAT | \
                       DMUS_TIME_RESOLVE_MEASURE | \
                       DMUS_TIME_RESOLVE_GRID | \
                       DMUS_TIME_RESOLVE_MARKER | \
                       DMUS_TIME_RESOLVE_SEGMENTEND)


HRESULT STDMETHODCALLTYPE CPerformance::SendPMsg(
    DMUS_PMSG *pDMUS_PMSG)

{
    V_INAME(IDirectMusicPerformance::SendPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
#else
        if (!pDMUS_PMSG)
        {
            return E_POINTER;
        }
#endif
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to Send PMsg because performance not initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if (pDMUS_PMSG->dwSize < sizeof(DMUS_PMSG))
    {
        TraceI(1,"Warning: PMsg size field has been cleared.\n");
    }

    // If this is a PMsg that was marked by STampPMsg as one that should be removed,
    // do so now.
    if (pDMUS_PMSG->dwPChannel == DMUS_PCHANNEL_KILL_ME)
    {
        FreePMsg(pDMUS_PMSG);
        return S_OK;
    }

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pDMUS_PMSG);
    if( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED ) ||
        ( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK ) != PRIV_FLAG_ALLOC ) )
    {
        Trace(1, "Error: Attempt to send an improperly allocated PMsg, or trying to send it after it is already sent.\n" );
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_E_ALREADY_SENT;
    }

    if (m_dwVersion >= 8)
    {
        // If the music and ref times are both 0, set to latency time.
        if ((pDMUS_PMSG->mtTime == 0) && ( pDMUS_PMSG->rtTime == 0 ))
        {
            // If this needs to resolve, use the worse case latency
            // because this needs to sync with other pmsgs.
            if (pDMUS_PMSG->dwFlags & RESOLVE_FLAGS)
            {
                GetLatencyTime(&pDMUS_PMSG->rtTime);
            }
            else
            {
                // Otherwise, we want to play as soon as possible.
                pDMUS_PMSG->rtTime = GetTime();
            }
            pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
            pDMUS_PMSG->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
        }
    }

    // fill in missing time value
    if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_MUSICTIME))
    {
        if( !(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME ) )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            Trace(1,"Error: Unable to send PMsg because neither clock time (DMUS_PMSGF_REFTIME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.\n");
            return E_INVALIDARG; // one or the other MUST be set
        }
        // quantize to resolution boundaries
        GetResolvedTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->rtTime, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        // if time is zero, set it to time now plus latency
        if( pDMUS_PMSG->rtTime == 0 )
        {
            pDMUS_PMSG->rtTime = GetLatency();
        }
        ReferenceToMusicTime(pDMUS_PMSG->rtTime,
            &pDMUS_PMSG->mtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    else if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME))
    {
        MusicToReferenceTime(pDMUS_PMSG->mtTime,
            &pDMUS_PMSG->rtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
        // quantize to resolution boundaries
        REFERENCE_TIME rtNew;
        GetResolvedTime( pDMUS_PMSG->rtTime, &rtNew, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        if( rtNew != pDMUS_PMSG->rtTime )
        {
            pDMUS_PMSG->rtTime = rtNew;
            ReferenceToMusicTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->mtTime );
        }
    }

    // insert into the proper queue by music value
    if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_QUEUE)
    {
        m_NearTimeQueue.Enqueue(pPrivPMsg);
    }
    else if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_ATTIME)
    {
        m_OnTimeQueue.Enqueue(pPrivPMsg);
    }
    else // (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
        m_EarlyQueue.Enqueue(pPrivPMsg);
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*

  Call this only from within a PipelineCrSec.
*/
void CPerformance::RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime )
{
    PRIV_PMSG* pCheck;
    BOOL fError = FALSE;
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->mtTime > mtTime)
        {
            if (pCheck->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
            {
                ReferenceToMusicTime(pCheck->rtTime,&pCheck->mtTime);
            }
            else // if(pCheck->dwFlags & DMUS_PMSGF_MUSICTIME)
            {
                MusicToReferenceTime(pCheck->mtTime,&pCheck->rtTime);
            }
        }
    }
    // Make sure that we do not end up with out of order RTimes. This can happen with
    // DMUS_PMSGF_LOCKTOREFTIME messages or very abrupt changes in tempo.
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->pNext && ( pCheck->rtTime > pCheck->pNext->rtTime ))
        {
            fError = TRUE;  // Need to sort the list.
        }
    }
    if (fError)
    {
        TraceI(2,"Rearrangement of times in message list due to tempo change, resorting\n");
        pList->Sort();
    }
}

void CPerformance::AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime )
{
    DMInternalTempo* pITempo = NULL;

    if( FAILED( AllocPMsg( sizeof(DMInternalTempo), (PRIV_PMSG**)&pITempo )))
    {
        return; // out of memory!
    }
    if( dblTempo > DMUS_TEMPO_MAX ) dblTempo = DMUS_TEMPO_MAX;
    else if( dblTempo < DMUS_TEMPO_MIN ) dblTempo = DMUS_TEMPO_MIN;
    pITempo->tempoPMsg.dblTempo = dblTempo;
    pITempo->tempoPMsg.rtTime = rtTime;
    pITempo->tempoPMsg.mtTime = mtTime;
    pITempo->tempoPMsg.dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;
    pITempo->pNext = NULL;
    // set the relative tempo field
    EnterCriticalSection(&m_GlobalDataCrSec);
    pITempo->fltRelTempo = m_fltRelTempo;
    // add the tempo event to the tempo map and clear the tool and graph pointers
    pITempo->tempoPMsg.pTool = NULL;
    EnterCriticalSection(&m_PipelineCrSec);
    // remove stale tempo events from the tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
    PRIV_PMSG* pCheck;
    while (pCheck = m_TempoMap.FlushOldest(rtNow))
    {
        m_OldTempoMap.Enqueue(pCheck);
    }
    // add the new tempo event to the queue
    m_TempoMap.Enqueue( (PRIV_PMSG*) pITempo );
    // now that it's been added, scan forward from it and change the relative tempo
    // times of everyone after it
    DMInternalTempo* pChange;
    for( pChange = (DMInternalTempo*)pITempo->pNext; pChange;
        pChange = (DMInternalTempo*)pChange->pNext )
    {
        pChange->fltRelTempo = pITempo->fltRelTempo;
    }
    // remove stale tempo events from the old tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    rtNow = GetTime() - ((REFERENCE_TIME)10000 * 300000); // keep around for five minutes.
    while (pCheck = m_OldTempoMap.FlushOldest(rtNow))
    {
        FreePMsg(pCheck);
    }
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
}

void CPerformance::AddEventToTempoMap( PRIV_PMSG* pEvent )
{
    PRIV_TEMPO_PMSG* pTempo = (PRIV_TEMPO_PMSG*)pEvent;
    MUSIC_TIME mtTime = pTempo->tempoPMsg.mtTime;
    AddToTempoMap( pTempo->tempoPMsg.dblTempo, mtTime, pTempo->tempoPMsg.rtTime );
    pEvent->dwPrivFlags = PRIV_FLAG_ALLOC;
    EnterCriticalSection(&m_GlobalDataCrSec);
    EnterCriticalSection(&m_PipelineCrSec);
    // revalidate the ref times of the events in the queues
    RevalidateRefTimes( &m_TempoMap, mtTime );
    RevalidateRefTimes( &m_OnTimeQueue, mtTime );
    RevalidateRefTimes( &m_NearTimeQueue, mtTime );
    RevalidateRefTimes( &m_EarlyQueue, mtTime );
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
    RecalcTempoMap(NULL, mtTime+1, false);
}

#define TEMPO_AHEAD 768 * 4 * 10    // 10 measures ahead is plenty!

void CPerformance::IncrementTempoMap()

{
    if (m_mtTempoCursor <= (m_mtTransported + TEMPO_AHEAD))
    {
        UpdateTempoMap(m_mtTempoCursor, false, NULL);
    }
}

void CPerformance::RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtStart, bool fAllDeltas)

/*  Called whenever a primary or controlling segment that has a tempo
    track is played or stopped.
    1) Convert the music time at transport time to ref time using the old
    map.
    2) Build a replacement tempo map starting at mtStart, by
    calling GetParam() until there is no next time.
    3) Install the new map.
    4) Convert with the new map.
    5) If the two numbers are not identical, recalculate all message times.
*/

{
    if( mtStart > 0) // Don't do this for invalid values.
    {
        if (!pSegState || (pSegState->m_pSegment && pSegState->m_pSegment->IsTempoSource()))
        {
            REFERENCE_TIME rtCompareTime;
            REFERENCE_TIME rtAfterTime;
            MUSIC_TIME mtCompareTime = m_mtTransported;
            MusicToReferenceTime(mtCompareTime,&rtCompareTime);
            EnterCriticalSection(&m_PipelineCrSec);
            FlushEventQueue( 0, &m_TempoMap, rtCompareTime, rtCompareTime, FALSE );
            LeaveCriticalSection(&m_PipelineCrSec);
            UpdateTempoMap(mtStart, true, pSegState, fAllDeltas);
            MusicToReferenceTime(mtCompareTime,&rtAfterTime);
            if (rtAfterTime != rtCompareTime)
            {
                EnterCriticalSection(&m_GlobalDataCrSec);
                EnterCriticalSection(&m_PipelineCrSec);
                // revalidate the ref times of the events in the queues
                RevalidateRefTimes( &m_TempoMap, mtStart );
                RevalidateRefTimes( &m_OnTimeQueue, mtStart );
                RevalidateRefTimes( &m_NearTimeQueue, mtStart );
                RevalidateRefTimes( &m_EarlyQueue, mtStart );
                m_fTempoChanged = TRUE;
                LeaveCriticalSection(&m_PipelineCrSec);
                LeaveCriticalSection(&m_GlobalDataCrSec);
            }
        }
    }
}


void CPerformance::UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas)

{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;
    PrivateTempo Tempo;
    TList<PrivateTempo> TempoList;
    TListItem<PrivateTempo>* pScan = NULL;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtTime = mtStart;
    MUSIC_TIME mtCursor = mtStart;
    REFERENCE_TIME rtTime;
    do
    {
        hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
        Tempo.mtTime = mtTime;
        if (hr == S_OK && Tempo.mtDelta > 0)
        {
            mtTime += Tempo.mtDelta;
            hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
            Tempo.mtTime = mtTime;
        }
        if (hr == S_FALSE && fFirst && !pSegState)
        {
            // If this was the very first try, there might not be any tempo track, and
            // so global tempo is called. If so, S_FALSE is returned. This is okay
            // for the NULL segstate case where we are recomputing the tempo map in response
            // to a change in global tempo, or stop of all segments.
            if (fAllDeltas) // Never do this in response to adding a new event to the tempo map
            {
                MusicToReferenceTime(mtTime,&rtTime);
                // the rtTime in the tempo map needs to be the non-adjusted value (305694)
                AddToTempoMap( Tempo.dblTempo, mtTime, rtTime + m_rtAdjust );
            }
            break;
        }
        if (hr == S_OK)
        {
            TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>(Tempo);
            if (pNew)
            {
                // add to TempoList, replacing duplicate times with the most recent mtDelta
                TListItem<PrivateTempo>* pNext = TempoList.GetHead();
                if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                {
                    TempoList.AddHead(pNew);
                }
                else for (pScan = TempoList.GetHead(); pScan; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (Tempo.mtTime == pScan->GetItemValue().mtTime)
                    {
                        if (Tempo.mtDelta > pScan->GetItemValue().mtDelta)
                        {
                            pScan->GetItemValue() = Tempo;
                        }
                        delete pNew;
                        break;
                    }
                    else if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                    {
                        pScan->SetNext(pNew);
                        pNew->SetNext(pNext);
                        break;
                    }
                }
            }
            mtTime += mtNext;
            fFirst = false;
            // If this was the last tempo in the track (that we care about),
            // reset the time and bump the track index
            if (Tempo.fLast || mtTime > (m_mtTransported + TEMPO_AHEAD))
            {
                dwIndex++;
                mtCursor = mtTime;
                mtTime = mtStart;
            }
            else if (!mtNext) break; // should never happen but if it does, infinite loop
        }
        else if (Tempo.fLast) // There was an empty tempo track
        {
            dwIndex++;
            hr = S_OK;
        }
        Tempo.fLast = false;
    } while (hr == S_OK);
    if (TempoList.GetHead() && TempoList.GetHead()->GetItemValue().mtTime > mtStart)
    {
        // add a tempo of 120 at time mtStart
        TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>();
        if (pNew)
        {
            PrivateTempo& rNew = pNew->GetItemValue();
            rNew.dblTempo = 120.0;
            rNew.mtTime = mtStart;
            TempoList.AddHead(pNew);
        }
        else
        {
#ifdef DBG
            Trace(1, "Error: Out of memory; Tempo map is incomplete.\n");
#endif
            TempoList.GetHead()->GetItemValue().mtTime = mtStart;
        }
    }
    for (pScan = TempoList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        PrivateTempo& rTempo = pScan->GetItemValue();
        if (fAllDeltas || rTempo.mtTime + rTempo.mtDelta >= mtStart)
        {
            MusicToReferenceTime(rTempo.mtTime,&rtTime);
            // the rtTime in the tempo map needs to be the non-adjusted value (305694)
            AddToTempoMap( rTempo.dblTempo, rTempo.mtTime, rtTime + m_rtAdjust );
        }
    }
    m_mtTempoCursor = mtCursor;
}

HRESULT STDMETHODCALLTYPE CPerformance::MusicToReferenceTime(
    MUSIC_TIME mtTime,          // @parm The time in MUSIC_TIME format to convert.
    REFERENCE_TIME *prtTime)    // @parm Returns the converted time in REFERENCE_TIME format.
{
    V_INAME(IDirectMusicPerformance::MusicToReferenceTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert music to reference time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;
    REFERENCE_TIME rtTemp;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( mtTime >= pEvent->mtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->mtTime > mtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( mtTime >= pEvent->mtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->mtTime > mtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;

    rtTemp = ( mtTime - mtTempo );
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dbl);
    *prtTime = rtTempo + rtTemp;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::ReferenceToMusicTime(
    REFERENCE_TIME rtTime,  // @parm The time in REFERENCE_TIME format to convert.
    MUSIC_TIME *pmtTime)    // @parm Returns the converted time in MUSIC_TIME format.
{
    V_INAME(IDirectMusicPerformance::ReferenceToMusicTime);
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert reference to music time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( rtTime >= pEvent->rtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->rtTime > rtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( rtTime >= pEvent->rtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->rtTime > rtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;
    if( rtTime < rtTempo )
    {
        rtTime = rtTempo;
    }
    rtTime -= rtTempo;
    rtTime *= DMUS_PPQ;
    rtTime = (REFERENCE_TIME)(rtTime * dbl);
    rtTime += 300000000;
    rtTime /= 600000000;
#ifdef DBG
    if ( rtTime & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    *pmtTime = (long) (rtTime & 0xFFFFFFFF);
    *pmtTime += mtTempo;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | AdjustTime |
  Adjust the internal Performance time forward or backward. This is mostly used to
  compensate for drift when synchronizing to another source, such as SMPTE.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | rtAmount is too large or too small.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AdjustTime(
    REFERENCE_TIME rtAmount)    // @parm The amount of time to adjust. This may be a
                                // number from -10000000 to 10000000 (-1 second to +1 second.)
{
    if( ( rtAmount < -10000000 ) || ( rtAmount > 10000000 ) )
    {
        Trace(1,"Error: Time parameter passed to AdjustTime() is out of range.\n");
        return E_INVALIDARG;
    }
    m_rtAdjust += rtAmount;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetResolvedTime |
  Quantize a time to a resolution boundary. Given a time, in REFERENCE_TIME,
  return the next time on a given boundary after the time given.

  @rvalue S_OK | Success.
  @rvalue E_POINTER <prtResolved> is not valid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetResolvedTime(
    REFERENCE_TIME rtTime,
    REFERENCE_TIME* prtResolved,
    DWORD dwResolvedTimeFlags)
{
    V_INAME(IDirectMusicPerformance::GetResolvedTime);
    V_PTR_WRITE(prtResolved,REFERENCE_TIME);

    if (rtTime == 0)
    {
        dwResolvedTimeFlags |= DMUS_TIME_RESOLVE_AFTERQUEUETIME ;
    }
    if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERPREPARETIME )
    {
        REFERENCE_TIME rtTrans;
        MusicToReferenceTime( m_mtTransported, &rtTrans );
        if( rtTime < rtTrans ) rtTime = rtTrans;
    }
    else if (dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERLATENCYTIME )
    {
        REFERENCE_TIME rtStart;
        rtStart = GetLatency();
        if( rtTime < rtStart ) rtTime = rtStart;
    }
    else if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERQUEUETIME )
    {
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( rtTime < rtStart ) rtTime = rtStart;
    }


    if( dwResolvedTimeFlags & ( DMUS_TIME_RESOLVE_BEAT | DMUS_TIME_RESOLVE_MEASURE |
        DMUS_TIME_RESOLVE_GRID | DMUS_TIME_RESOLVE_MARKER | DMUS_TIME_RESOLVE_SEGMENTEND))
    {
        MUSIC_TIME mtTime; //, mtResolved;

        ReferenceToMusicTime( rtTime, &mtTime );
        EnterCriticalSection(&m_SegmentCrSec);
        mtTime = ResolveTime( mtTime, dwResolvedTimeFlags, NULL);
        LeaveCriticalSection(&m_SegmentCrSec);
        MusicToReferenceTime( mtTime, prtResolved );
    }
    else
    {
        *prtResolved = rtTime;
    }
    return S_OK;
}


/*
  @method HRESULT | IDirectMusicPerformance | IsPlaying |
  Find out if a particular Segment or SegmentState is currently playing.

  @rvalue E_POINTER | Both pSegment and pSegState are null, or one or both are invalid.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
  @rvalue S_OK | Yes, it is playing.
  @rvalue S_FALSE | No, it is not playing.
*/
HRESULT STDMETHODCALLTYPE CPerformance::IsPlaying(
    IDirectMusicSegment *pSegment,          // @parm The Segment to check. If NULL, check
                                            // <p pSegState>.
    IDirectMusicSegmentState *pSegState)    // @parm The SegmentState to check. If NULL,
                                            // check <p pSegment>.
{
    CSegState* pNode;
    DWORD dwCount;

    V_INAME(IDirectMusicPerformance::IsPlaying);
    V_INTERFACE_OPT(pSegment);
    V_INTERFACE_OPT(pSegState);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: IsPlaying() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( !pSegment && !pSegState )
    {
        Trace(1,"Error: IsPlaying() failed because segment and segment state are both NULL pointers.\n");
        return E_POINTER;
    }

    MUSIC_TIME mtNow;
    GetTime(NULL, &mtNow);
    EnterCriticalSection(&m_SegmentCrSec);

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
        {
            if( !pNode->m_fStartedPlay )
            {
                continue;
            }
            if( mtNow >= pNode->m_mtResolvedStart )
            {
                if( mtNow < pNode->m_mtLastPlayed )
                {
                    if(( pNode == (CSegState*) pSegState ) ||
                        ( pNode->m_pSegment == (CSegment *) pSegment ))
                    {
                        LeaveCriticalSection(&m_SegmentCrSec);
                        return S_OK;
                    }
                }
            }
            else
            {
                // if mtNow is before this pSegState's resolved start, it is before every
                // pSegState after this too, so break now.
                break;
            }
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_FALSE;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetTime(
        REFERENCE_TIME *prtNow, // @parm Returns the current time in REFERENCE_TIME
                                            // format. May be NULL.
        MUSIC_TIME  *pmtNow)    // @parm Returns the current time in MUSIC_TIME
                                            // format. May be NULL.
{
    V_INAME(IDirectMusicPerformance::GetTime);
    V_PTR_WRITE_OPT(prtNow,REFERENCE_TIME);
    V_PTR_WRITE_OPT(pmtNow,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    REFERENCE_TIME rtTime = GetTime();
    if( prtNow )
    {
        *prtNow = rtTime;
    }
    if( pmtNow )
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime( rtTime, &mtTime );
        *pmtNow = mtTime;
    }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetLatencyTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current latency time.
{
    V_INAME(IDirectMusicPerformance::GetLatencyTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetLatencyTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    *prtTime = GetLatency();
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetQueueTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current queue time.
{
    V_INAME(IDirectMusicPerformance::GetQueueTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetQueueTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    DWORD dw;
    REFERENCE_TIME rtLatency;

    *prtTime = 0;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dw = 0; dw < m_dwNumPorts; dw++ )
    {
        if( m_pPortTable[dw].rtLast > *prtTime )
            *prtTime = m_pPortTable[dw].rtLast;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    rtLatency = GetLatency();
    if( *prtTime < rtLatency )
    {
        *prtTime = rtLatency;
    }
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return S_OK;
}

// private version of AllocPMsg
HRESULT CPerformance::AllocPMsg(
    ULONG cb,
    PRIV_PMSG** ppPMSG)
{
    ASSERT( cb >= sizeof(PRIV_PMSG) );
    DMUS_PMSG* pDMUS_PMSG;
    HRESULT hr;

    hr = AllocPMsg( cb - PRIV_PART_SIZE, &pDMUS_PMSG );
    if( SUCCEEDED(hr) )
    {
        *ppPMSG = DMUS_TO_PRIV(pDMUS_PMSG);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG)
{
    V_INAME(IDirectMusicPerformance::ClonePMsg);
#ifdef DBG
    V_PTRPTR_WRITE(ppCopyPMSG);
    V_BUFPTR_READ(pSourcePMSG,sizeof(DMUS_PMSG));
#else
    if (!ppCopyPMSG || !pSourcePMSG)
    {
        return E_POINTER;
    }
#endif
    HRESULT hr = AllocPMsg(pSourcePMSG->dwSize,ppCopyPMSG);
    if (SUCCEEDED(hr))
    {
        memcpy(*ppCopyPMSG,pSourcePMSG,pSourcePMSG->dwSize);
        if (pSourcePMSG->punkUser)
        {
            pSourcePMSG->punkUser->AddRef();
        }
        if (pSourcePMSG->pTool)
        {
            pSourcePMSG->pTool->AddRef();
        }
        if (pSourcePMSG->pGraph)
        {
            pSourcePMSG->pGraph->AddRef();
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CPerformance::AllocPMsg
/*
  @method HRESULT | IDirectMusicPerformance | AllocPMsg |
  Allocate a DMUS_PMSG.

  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p cb> is smaller than sizeof(DMUS_PMSG)
  @rvalue E_POINTER | <p ppPMSG> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AllocPMsg(
    ULONG cb,               // @parm Size of the <p ppPMSG>. Must be equal to or greater
                            // than sizeof(DMUS_PMSG).
    DMUS_PMSG** ppPMSG  // @parm Returns the pointer to the allocated message, which will
                            // be of size <p cb>. All fields are initialized to zero,
                            // except dwSize which is initialized to <p cb>.
    )
{
    V_INAME(IDirectMusicPerformance::AllocPMsg);
    if( m_dwVersion < 8)
    {
        V_PTRPTR_WRITE(ppPMSG);
    }
    else
    {
#ifdef DBG
        V_PTRPTR_WRITE(ppPMSG);
#else
        if (!ppPMSG)
        {
            return E_POINTER;
        }
#endif
    }
    PRIV_PMSG* pPrivPMsg;

    if( cb < sizeof(DMUS_PMSG) )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PMsgCacheCrSec);
    // cached pmsg's are stored in an array based on their public size.
    // If a cached pmsg exists, return it. Otherwise, make a new one.
    if( (cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX) )
    {
        ULONG cbIndex = cb - PERF_PMSG_CB_MIN;
        if( m_apPMsgCache[ cbIndex ] )
        {
            pPrivPMsg = m_apPMsgCache[ cbIndex ];
            m_apPMsgCache[ cbIndex ] = pPrivPMsg->pNext;
            pPrivPMsg->pNext = NULL;
            if (pPrivPMsg->dwPrivFlags != PRIV_FLAG_FREE)
            {
                Trace(0,"Error - previously freed PMsg has been mangled.\n");
                LeaveCriticalSection(&m_PMsgCacheCrSec);
                return E_FAIL;
            }
            pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
            if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
            *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
            LeaveCriticalSection(&m_PMsgCacheCrSec);
            return S_OK;
        }
    }

    HRESULT hr = S_OK;
    // no cached pmsg exists. Return a new one.
    ULONG cbPriv = cb + PRIV_PART_SIZE;
    pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
    if( pPrivPMsg )
    {
        memset( pPrivPMsg, 0, cbPriv );
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cb; // size of public part only
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
        if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
        *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return hr;
}

// private version of FreePMsg
HRESULT CPerformance::FreePMsg(
    PRIV_PMSG* pPMSG)
{
    return FreePMsg( PRIV_TO_DMUS(pPMSG) );
}


HRESULT STDMETHODCALLTYPE CPerformance::FreePMsg(
    DMUS_PMSG*  pPMSG   // @parm The message to free. This message must have been allocated
                            // using <om .AllocPMsg>.
    )
{
    V_INAME(IDirectMusicPerformance::FreePMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
#else
        if (!pPMSG)
        {
            return E_POINTER;
        }
#endif
    }

    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMSG);

    if( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK) != PRIV_FLAG_ALLOC )
    {
        Trace(0, "Error --- Attempt to free a PMsg that is not allocated memory.\n");
        // this isn't a msg allocated by AllocPMsg.
        return DMUS_E_CANNOT_FREE;
    }
    if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED )
    {
        TraceI(1, "Attempt to free a PMsg that is currently in the Performance queue.\n");
        return DMUS_E_CANNOT_FREE;
    }

    EnterCriticalSection(&m_PMsgCacheCrSec);
    if( pPMSG->pTool )
    {
        pPMSG->pTool->Release();
    }
    if( pPMSG->pGraph )
    {
        pPMSG->pGraph->Release();
    }
    if( pPMSG->punkUser )
    {
        pPMSG->punkUser->Release();
    }

    ULONG cbSize = pPrivPMsg->dwPrivPubSize;
    if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) )
    {
        memset( pPrivPMsg, 0, cbSize + PRIV_PART_SIZE );
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_FREE; // Mark this as in the free queue.
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cbSize;
        pPrivPMsg->pNext = m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ];
        m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ] = pPrivPMsg;
    }
    else
    {
        delete [] pPrivPMsg;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return S_OK;
}

HRESULT CPerformance::FlushVirtualTrack(
    DWORD       dwId,
    MUSIC_TIME  mtTime,
    BOOL fLeaveNotesOn)
{
    EnterCriticalSection(&m_PipelineCrSec);
    FlushMainEventQueues( dwId, mtTime, mtTime, fLeaveNotesOn );
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*
  Given a time, mtTime, returns the time of the next control segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/

HRESULT CPerformance::GetControlSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    // search the secondary lists for a control segment
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_CON_DONE].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart >= mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    if( S_FALSE == hr ) // if this is still zero, check the current queue
    {
        for( pTemp = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
        {
            if( pTemp->m_mtResolvedStart >= mtTime )
            {
                *pmtNextSeg = pTemp->m_mtResolvedStart;
                hr = S_OK;
                break;
            }
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  Given a time, mtTime, returns the time of the next primary segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/
HRESULT CPerformance::GetPriSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart > mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGraph |
  Returns the performance's Tool Graph, AddRef'd.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NOT_FOUND | There is no graph in the performance, and therefore
  one couldn't be returned.
  @rvalue E_POINTER | <p ppGraph> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGraph(
         IDirectMusicGraph** ppGraph // @parm Returns the tool graph pointer.
        )
{
    V_INAME(IDirectMusicPerformance::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr;
    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        *ppGraph = m_pGraph;
        m_pGraph->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Performance does not currently have a tool graph installed.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}


HRESULT CPerformance::GetGraphInternal(
         IDirectMusicGraph** ppGraph )
{
    EnterCriticalSection(&m_MainCrSec);
    if( !m_pGraph )
    {
        m_pGraph = new CGraph;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return GetGraph(ppGraph);
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGraph |
  Replaces the performance's Tool Graph. <p pGraph> is AddRef'd inside this
  method. Any messages flowing through Tools in the current Tool Graph are deleted.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pGraph> is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGraph(
         IDirectMusicGraph* pGraph  // @parm The tool graph pointer. May be NULL to clear
                                    // the current graph out of the performance.
        )
{
    V_INAME(IDirectMusicPerformance::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::SetNotificationHandle(
     HANDLE hNotification,      // @parm The event handle created by CreateEvent, or
                                // 0 to clear out an existing handle.
     REFERENCE_TIME rtMinimum ) // @parm The minimum amount of time that the
                                // performance should hold notify messages before discarding them.
                                // 0 means to use the default minimum time of 20000000 reference time units,
                                // which is 2 seconds, or the previous value if this API has been called previously.
                                // If the application hasn't called <om .GetNotificationPMsg> by this time, the message is
                                // discarded to free the memory.
{
    EnterCriticalSection(&m_MainCrSec);
    m_hNotification = hNotification;
    if( rtMinimum )
    {
        m_rtNotificationDiscard = rtMinimum;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetNotificationPMsg(
     DMUS_NOTIFICATION_PMSG** ppNotificationPMsg )

{
    V_INAME(IDirectMusicPerformance::GetNotificationPMsg);
    V_PTRPTR_WRITE(ppNotificationPMsg);

    HRESULT hr;
    EnterCriticalSection(&m_PipelineCrSec);
    if( m_NotificationQueue.GetHead() )
    {
        PRIV_PMSG* pPriv = m_NotificationQueue.Dequeue();
        ASSERT(pPriv);
        *ppNotificationPMsg = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPriv);
        hr = S_OK;
    }
    else
    {
        *ppNotificationPMsg = NULL;
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return hr;
}

void CPerformance::AddNotificationTypeToAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->AddNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->RemoveNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CPerformance::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

/*
  @method HRESULT | IDirectMusicPerformance | AddNotificationType |
  Adds a notification type to the performance. Notifications are identified
  by a guid. When a notification is added to the performance, notify messages
  are sent to the application, which provides a message handle on which to
  block through <om IDirectMusicPerformance.SetNotificationHandle>. All segments
  and tracks are automatically updated with the new notification by calling
  their AddNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification is already on the performance.
  @rvalue E_OUTOFMEMORY | Out of memory.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .RemoveNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::AddNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to add.
{
    V_INAME(IDirectMusicPerformance::AddNotificationType);
    V_REFGUID(rguidNotification);

    CNotificationItem*  pItem;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_SegmentCrSec);
    if( NULL == FindNotification( rguidNotification ) )
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllSegments( rguidNotification );
        }
    }
    else
    {
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | RemoveNotificationType |
  Removes a previously added notification type from the performance. All
  segments and tracks are updated with the removed notification by calling
  their RemoveNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification isn't currently active.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .AddNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to remove.
                        // If GUID_NULL, remove all notifications.
{
    V_INAME(IDirectMusicPerformance::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    HRESULT hr = S_OK;
    CNotificationItem* pItem;

    if( GUID_NULL == rguidNotification )
    {
        while (pItem = m_NotificationList.RemoveHead())
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            delete pItem;
        }
    }
    else
    {
        if( pItem = FindNotification( rguidNotification ))
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            m_NotificationList.Remove( pItem );
            delete pItem;
        }
        else
        {
            Trace(2,"Warning: Unable to remove requested notification because it is not currently installed.\n");
            hr = S_FALSE;
        }
    }
    return hr;
}

void CPerformance::RemoveUnusedPorts()


{
    DWORD dwIndex;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort && !m_AudioPathList.UsesPort(m_pPortTable[dwIndex].pPort))
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            CChannelBlock *pBlock = m_ChannelBlockList.GetHead();
            CChannelBlock *pNext;
            for(;pBlock;pBlock = pNext)
            {
                pNext = pBlock->GetNext();
                if (pBlock->m_dwPortIndex == dwIndex)
                {
                    m_ChannelBlockList.Remove(pBlock);
                    delete pBlock;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

HRESULT CPerformance::GetPathPort(CPortConfig *pConfig)

{
    HRESULT hr = S_OK;
    DWORD dwPort;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    GUID &guidScan = pConfig->m_PortHeader.guidPort;
    // If we are looking for the default synth, get the class id for the default synth.
    BOOL fDefault = (pConfig->m_PortHeader.guidPort == GUID_Synth_Default);
    if (fDefault)
    {
        guidScan = m_AudioParams.clsidDefaultSynth;
    }
    for (dwPort = 0;dwPort < m_dwNumPorts;dwPort++)
    {
        if ((m_pPortTable[dwPort].guidPortID == guidScan) && m_pPortTable[dwPort].pPort)
        {
            pConfig->m_dwPortID = dwPort;
            pConfig->m_pPort = m_pPortTable[dwPort].pPort;
            pConfig->m_PortParams = m_pPortTable[dwPort].PortParams;
            ASSERT(pConfig->m_pPort);
            pConfig->m_pPort->AddRef();
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    // Failed finding the port, so create it.
    if (dwPort >= m_dwNumPorts)
    {
        BOOL fUseBuffers = FALSE;
        pConfig->m_PortParams.dwSampleRate = m_AudioParams.dwSampleRate;
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_STREAMING)
        {
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_STREAMING;
        }
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
        {
            fUseBuffers = TRUE;
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_AUDIOPATH;
        }
        pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_SAMPLERATE  | DMUS_PORTPARAMS_FEATURES;
        // If this wants a default synth, consult m_AudioParams and create that synth.
        if (fDefault)
        {
            pConfig->m_PortParams.dwAudioChannels = 1;
            pConfig->m_PortParams.dwVoices = m_AudioParams.dwVoices;
            pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS | DMUS_PORTPARAMS_VOICES;
        }
        hr = m_pDirectMusic->CreatePort(guidScan,&pConfig->m_PortParams,&pConfig->m_pPort, NULL);
        if (SUCCEEDED(hr))
        {
            if ((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH))
            {
                IDirectMusicPortP* pPortP = NULL;
                // QI for the private interface.
                if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP,(void **) &pPortP)))
                {
                    // Connect the port to the sink.
                    hr = pPortP->SetSink(m_BufferManager.m_pSinkConnect);
                    pPortP->Release();
                }
                else
                {
                    Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because synth does not support buffers.\n");
                    hr = E_INVALIDARG;
                }
            }
            else if (fUseBuffers && fDefault)
            {
                Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because default synth does not support buffers.\n");
                hr = E_INVALIDARG;
            }
        }
        if (SUCCEEDED(hr))
        {
            // Now add the port to the performance.
            hr = AddPort(pConfig->m_pPort,&pConfig->m_PortHeader.guidPort,
                &pConfig->m_PortParams,&pConfig->m_dwPortID);
        }
        if (SUCCEEDED(hr))
        {
            // Activate the port.
            hr = pConfig->m_pPort->Activate(TRUE);
            // It's okay if the synth is already active.
            if (hr == DMUS_E_SYNTHACTIVE)
            {
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwPortID = GetPortID(pConfig->m_pPort);
            // Then create matching channel blocks for all of the channel groups in the port.
            for (DWORD dwGroup = 0;dwGroup < pConfig->m_PortParams.dwChannelGroups; dwGroup++)
            {
                AllocVChannelBlock(dwPortID,dwGroup+1);
            }
        }
    }
    return (hr);
}

HRESULT STDMETHODCALLTYPE CPerformance::AddPort(
            IDirectMusicPort* pPort)
{
    V_INAME(IDirectMusicPerformance::AddPort);
    V_INTERFACE_OPT(pPort);
    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AddPort() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    return AddPort(pPort,NULL,NULL,NULL);
}

HRESULT CPerformance::AddPort(
            IDirectMusicPort* pPort,
            GUID *pguidPortID,
            DMUS_PORTPARAMS8 *pParams,
            DWORD *pdwPortID)
{
    PortTable* pPortTable;
    IDirectMusicBuffer* pBuffer;
    BOOL    fSetUpBlock = FALSE;
    BOOL    fBuiltNewTable = FALSE;
    HRESULT hr = S_OK;
    GUID guidPortID;             // Class ID of port.
    DWORD dwChannelGroups;       // Number of channel groups at initialization.
    DWORD dwNewPortIndex = 0;    // Index into port array for new port.

    EnterCriticalSection(&m_MainCrSec);
    EnterCriticalSection(&m_PChannelInfoCrSec);

    if( NULL == m_pDirectMusic )
    {
        Trace(1,"Error: Performance is not initialized, ports can not be added.\n");
        hr = DMUS_E_NOT_INIT;
        goto END;
    }

    for (;dwNewPortIndex < m_dwNumPorts; dwNewPortIndex++)
    {
        if (!m_pPortTable[dwNewPortIndex].pPort)
        {
            break;
        }
    }

    if (dwNewPortIndex == m_dwNumPorts)
    {
        pPortTable = new PortTable[m_dwNumPorts + 1];
        if( !pPortTable )
        {
            hr = E_OUTOFMEMORY;
            goto END;
        }
        fBuiltNewTable = TRUE;
    }

    // if pPort is NULL, create a software synth port
    DMUS_PORTPARAMS dmpp;
    if( NULL == pPort )
    {
        pParams = &dmpp;
        memset(&dmpp, 0, sizeof(DMUS_PORTPARAMS) );
        dmpp.dwSize = sizeof(DMUS_PORTPARAMS);
        dmpp.dwChannelGroups = dwChannelGroups = 1;
        dmpp.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS |
            DMUS_PORTPARAMS_AUDIOCHANNELS;
        dmpp.dwAudioChannels = 2;
        guidPortID = GUID_NULL;
        hr = m_pDirectMusic->CreatePort(GUID_NULL, &dmpp, &pPort, NULL);

        if ( SUCCEEDED( hr ) )
        {
            hr = pPort->Activate(TRUE);
        }


        fSetUpBlock = TRUE;
    }
    else
    {
        if (pguidPortID)
        {
            guidPortID = *pguidPortID;
        }
        else
        {
            DMUS_PORTCAPS PortCaps;
            PortCaps.dwSize = sizeof (PortCaps);
            pPort->GetCaps(&PortCaps);
            guidPortID = PortCaps.guidPort;
        }
        pPort->GetNumChannelGroups(&dwChannelGroups);
        pPort->AddRef();
    }
    if( FAILED(hr) || ( pPort == NULL ) )
    {
        if (fBuiltNewTable) delete [] pPortTable;
        Trace(1,"Error: Unable to open requested port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    // Create a buffer
    DMUS_BUFFERDESC dmbd;
    memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
    dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
    dmbd.cbBuffer = DEFAULT_BUFFER_SIZE;
    if( FAILED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
    {
        if (fBuiltNewTable) delete [] pPortTable;
        pPort->Release();
        Trace(1,"Error: Unable to create MIDI buffer for port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    if (fBuiltNewTable)
    {
        // if there is an existing port table, copy its contents to the new, bigger, port table
        if( m_pPortTable )
        {
            if( m_dwNumPorts > 0 )
            {
                memcpy( pPortTable, m_pPortTable, sizeof(PortTable) * ( m_dwNumPorts ) );
            }
            delete [] m_pPortTable;
        }
        m_pPortTable = pPortTable;
    }
    if (pdwPortID)
    {
        *pdwPortID = dwNewPortIndex;
    }
    pPortTable = &m_pPortTable[dwNewPortIndex];
    pPortTable->pPort = pPort;
    // If we have a passed params structure, copy it. This will be used for identifying the
    // params as initialized by the synth.
    if (pParams)
    {
        pPortTable->PortParams = *pParams;
    }
    pPortTable->dwGMFlags = 0;
    //set master volume
    IKsControl *pControl;
    if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
    {
        KSPROPERTY ksp;
        ULONG cb;

        memset(&ksp, 0, sizeof(ksp));
        ksp.Set   = GUID_DMUS_PROP_Volume;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&m_lMasterVolume,
                            sizeof(m_lMasterVolume),
                            &cb);
        // Now, find out if it has a gm, gs, or xg sets in rom...
        BOOL bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GM_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GM;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GS_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GS;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_XG_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_XG;
        }
        pControl->Release();
    }

    if( FAILED( pPort->GetLatencyClock( &pPortTable->pLatencyClock )))
    {
        pPortTable->pLatencyClock = NULL;
    }
    pPortTable->dwChannelGroups = dwChannelGroups;
    pPortTable->guidPortID = guidPortID;
    pPortTable->pBuffer = pBuffer;
    pPortTable->fBufferFilled = FALSE;
    pPortTable->rtLast = 0;
    if (fBuiltNewTable) m_dwNumPorts++; // must do this before calling AssignPChannelBlock
    if( fSetUpBlock && m_ChannelBlockList.IsEmpty() ) // set up default PChannel map if none already set
    {
        AssignPChannelBlock( 0, pPort, 1);
    }
    hr = S_OK;
END:
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    LeaveCriticalSection(&m_MainCrSec);

    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemovePort(
            IDirectMusicPort* pPort     // @parm The port to remove.
        )
{
    V_INAME(IDirectMusicPerformance::RemovePort);
    V_INTERFACE(pPort);

    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            hr = S_OK;
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Invalid port passed to RemovePort().\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,
            DWORD dwPortIndex,
            DWORD dwGroup,
            WORD wFlags)
{
    // see if we've already allocated this block before
    // blocknum is PChannel / 16, so search on that.
    DWORD dwPChannel = dwBlockNum * 16;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart == dwPChannel )
        {
            pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
            break;
        }
    }
    if( !pChannelBlock )
    {
        pChannelBlock = new CChannelBlock;
        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
        m_ChannelBlockList.AddHead(pChannelBlock);
        pChannelBlock->m_dwPChannelStart = dwPChannel;
    }
    return S_OK;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannel(
            DWORD dwPChannel,
            DWORD dwPortIndex,
            DWORD dwGroup,
            DWORD dwMChannel,
            WORD wFlags)
{
    DWORD dwIndex;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( !pChannelBlock )
    {
        // there is no currently existing block that encompases dwPChannel.
        // Create one.
        pChannelBlock = new CChannelBlock;

        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,0,0,CMAP_FREE);
        m_ChannelBlockList.AddHead(pChannelBlock);
    }

    dwIndex = dwPChannel - pChannelBlock->m_dwPChannelStart;

    ASSERT( dwIndex < PCHANNEL_BLOCKSIZE );
    CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
    pMap->dwPortIndex = dwPortIndex;
    pMap->dwGroup = dwGroup;
    pMap->dwMChannel = dwMChannel;
    pMap->nTranspose = 0;
    if ((pMap->wFlags & CMAP_FREE) && !(wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels--;
    else if (!(pMap->wFlags & CMAP_FREE) && (wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels++;
    pMap->wFlags = wFlags;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,           // @parm The block number. Should be 0 or greater.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup               // @parm The group on the port. Should be 1 or greater.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannelBlock);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannelBlock() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannelBlock( dwBlockNum, dwIndex, dwGroup, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: AssignPChannelBlock() called with invalid port.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannel(
            DWORD dwPChannel,           // @parm The PChannel.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup,              // @parm The group on the port.
            DWORD dwMChannel            // @parm The channel on the group.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannel);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannel() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    if( (dwMChannel < 0) || (dwMChannel > 15))
    {
        Trace(1,"Error: AssignPChannel() called with invalid MIDI Channel %ld.\n",dwMChannel);
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannel( dwPChannel, dwIndex, dwGroup, dwMChannel, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*  ReleasePChannel finds the requested PChannel and makes it available
    for reuse.
    It also calls ResetAllControllers(), which sends MIDI CC 121 and 123,
    reset all controllers and all notes off.
*/

HRESULT CPerformance::ReleasePChannel(DWORD dwPChannel)
{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( pChannelBlock )
    {
        // Only release if this is genuinely a virtual pchannel. Otherwise, leave alone.
        CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
        if (pMap->wFlags & CMAP_VIRTUAL)
        {
            pChannelBlock->m_dwFreeChannels++;
            // Clear out all the merge lists, etc.
            pMap->Clear();
            // Reset controllers, but don't send a GM reset.
            ResetAllControllers(pMap,0, false);
        }
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::GetPort(DWORD dwPortID, IDirectMusicPort **ppPort)

{
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if (dwPortID < m_dwNumPorts)
    {
        *ppPort = m_pPortTable[dwPortID].pPort;
        (*ppPort)->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Unable to find requested port.\n");
        hr = E_FAIL;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


HRESULT CPerformance::AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel)
{
    // dwDrumsFlags:
    // bit 0 determines whether this port separates out drums on channel 10.
    // bit 1 determines whether this request is for a drum.
    // First, figure out if we are scanning for drums on channel 10, melodic instruments
    // on the other channels, or any on all channels.
    static DWORD sdwSearchForDrums[1] = { 9 };
    static DWORD sdwSearchForAll[16] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
    static DWORD sdwSearchForMelodic[15] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 };
    DWORD *pSearchArray = sdwSearchForAll;
    DWORD dwSearchSize = 16;
    if (dwDrumFlags & 1) // Do we handle drums as a special case for channel 10?
    {
        if (dwDrumFlags & 2) // And are we looking for drums on channel 10?
        {
            pSearchArray = sdwSearchForDrums;
            dwSearchSize = 1;
        }
        else
        {
            pSearchArray = sdwSearchForMelodic;
            dwSearchSize = 15;
        }
    }
    HRESULT hr = E_INVALIDARG; // Return this if the vChannel is out of range.
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    BOOL fNotFound = TRUE;              // Use to indicate when we finally find a match.
    DWORD dwHighestPChannel = 0;        // Keep track of the highest PCHannel in use, this will be
                                        // used to create a new PChannel block, if needed.
    DWORD dwChannel;
    for (;fNotFound && pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (dwHighestPChannel < pChannelBlock->m_dwPChannelStart)
        {
            dwHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
        if ((pChannelBlock->m_dwPortIndex == dwPortID) && (pChannelBlock->m_dwFreeChannels))
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwSearchSize; dwIndex++)
            {
                dwChannel = pSearchArray[dwIndex];
                if (pChannelBlock->m_aChannelMap[dwChannel].wFlags & CMAP_FREE)
                {
                    *pdwPChannel = pChannelBlock->m_dwPChannelStart + dwChannel;
                    pChannelBlock->m_dwFreeChannels--;
                    pChannelBlock->m_aChannelMap[dwChannel].wFlags = CMAP_VIRTUAL;
                    *pdwGroup = pChannelBlock->m_aChannelMap[dwChannel].dwGroup;
                    *pdwMChannel = pChannelBlock->m_aChannelMap[dwChannel].dwMChannel;
                    fNotFound = FALSE;
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    if( fNotFound )
    {
        // there is no currently existing block that has a free channel.
        // Create one.
        IDirectMusicPort *pPort = m_pPortTable[dwPortID].pPort;
        DWORD dwChannelGroupCount;
        pPort->GetNumChannelGroups(&dwChannelGroupCount);
        dwChannelGroupCount++;
        hr = pPort->SetNumChannelGroups(dwChannelGroupCount);
        if (SUCCEEDED(hr))
        {
            m_pPortTable[dwPortID].dwChannelGroups = dwChannelGroupCount;
            hr = E_OUTOFMEMORY;
            dwHighestPChannel += PCHANNEL_BLOCKSIZE;
            pChannelBlock = new CChannelBlock;
            if (pChannelBlock)
            {
                pChannelBlock->Init(dwHighestPChannel,dwPortID,dwChannelGroupCount,CMAP_FREE);
                m_ChannelBlockList.AddTail(pChannelBlock);
                dwChannel = pSearchArray[0];  // Which channel should we use?
                CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwChannel];
                pMap->dwMChannel = dwChannel;
                pMap->wFlags = CMAP_VIRTUAL;
                pChannelBlock->m_dwFreeChannels--;
                *pdwPChannel = dwChannel + dwHighestPChannel;
                *pdwGroup = pMap->dwGroup;
                *pdwMChannel = dwChannel;
                hr = S_OK;
            }
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Unable to allocated dynamic PChannel.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup)
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    long lHighestPChannel = -PCHANNEL_BLOCKSIZE;
    for (;pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (lHighestPChannel < (long) pChannelBlock->m_dwPChannelStart)
        {
            lHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
    }
    HRESULT hr = E_OUTOFMEMORY;
    lHighestPChannel += PCHANNEL_BLOCKSIZE;
    pChannelBlock = new CChannelBlock;
    if (pChannelBlock)
    {
        pChannelBlock->Init((DWORD) lHighestPChannel,dwPortID,dwGroup,CMAP_FREE);
        m_ChannelBlockList.AddTail(pChannelBlock);
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


#ifdef DBG
void CPerformance::TraceAllChannelMaps()

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        TraceI(0,"ChannelBlock %lx, Free %ld\n",pChannelBlock->m_dwPChannelStart,pChannelBlock->m_dwFreeChannels);
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++)
        {
            CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
            TraceI(0,"\tPort %ld, Group: %ld, MIDI: %ld, Transpose: %ld, Flags: %ld\n",
                pMap->dwPortIndex, pMap->dwGroup, pMap->dwMChannel, (long) pMap->nTranspose, (long) pMap->wFlags);
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

#endif


/* Note that the following must be called from within a m_PChannelInfoCrSec
   critical section and stay within that critical section for the duration
   of using the returned CChannelMap.
*/


CChannelMap * CPerformance::GetPChannelMap( DWORD dwPChannel )
{
    CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( ( dwPChannel >= pChannelBlock->m_dwPChannelStart ) &&
            ( dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE ) )
        {
            CChannelMap* pChannelMap;

            pChannelMap = &pChannelBlock->m_aChannelMap[ dwPChannel - pChannelBlock->m_dwPChannelStart ];
            if( pChannelMap->dwGroup == 0 )
            {
                // this PChannel isn't on a valid group, therefore it hasn't
                // been set.
//              return NULL;
            }
            return pChannelMap;
        }
    }
    return NULL;
}

/*
  internal version
*/

HRESULT CPerformance::PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
            DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose )
{
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelMap *pChannelMap = GetPChannelMap(dwPChannel);
    if (pChannelMap)
    {
        ASSERT( pdwIndex && pdwGroup && pdwMChannel );

        *pdwIndex = pChannelMap->dwPortIndex;
        *pdwGroup = pChannelMap->dwGroup;
        *pdwMChannel = pChannelMap->dwMChannel;
        if( pnTranspose )
        {
            *pnTranspose = pChannelMap->nTranspose;
        }
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: PChannel %ld has not been assigned to a port.\n",dwPChannel);
        if (m_dwVersion < 8)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = DMUS_E_AUDIOPATH_NOPORT;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

DWORD CPerformance::GetPortID(IDirectMusicPort * pPort)

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwID = 0;
    for (;dwID < m_dwNumPorts; dwID++)
    {
        if (pPort == m_pPortTable[dwID].pPort)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if (dwID == m_dwNumPorts) dwID = 0;
    return dwID;
}

STDMETHODIMP CPerformance::GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags)

{

    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwIndex;
    DWORD dwGroup;
    DWORD dwMChannel;
    HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
    if (SUCCEEDED(hr))
    {
        *ppPort = m_pPortTable[dwIndex].pPort;
        if( *ppPort )
        {
            m_pPortTable[dwIndex].pPort->AddRef();
        }
        else
        {
            Trace(1,"Error: Performance does not have a port assigned to PChannel %ld.\n",dwPChannel);
            hr = DMUS_E_NOT_INIT;
        }
        *pdwFlags = m_pPortTable[dwIndex].dwGMFlags;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

STDMETHODIMP CPerformance::PChannelInfo(
            DWORD dwPChannel,           // @parm The PChannel to convert.
            IDirectMusicPort** ppPort,  // @parm Returns the port. May be NULL.
            DWORD* pdwGroup,            // @parm Returns the group on the port. May be NULL.
            DWORD* pdwMChannel          // @parm Returns the channel on the group. May be NULL.
        )
{
    V_INAME(IDirectMusicPerformance::PChannelInfo);
    V_PTRPTR_WRITE_OPT(ppPort);
    V_PTR_WRITE_OPT(pdwGroup,DWORD);
    V_PTR_WRITE_OPT(pdwMChannel,DWORD);

    DWORD dwIndex, dwGroup, dwMChannel;
    HRESULT hr;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        if( ppPort )
        {
            *ppPort = m_pPortTable[dwIndex].pPort;
            if( *ppPort )
            {
                m_pPortTable[dwIndex].pPort->AddRef();
            }
        }
        if( pdwGroup )
        {
            *pdwGroup = dwGroup;
        }
        if( pdwMChannel )
        {
            *pdwMChannel = dwMChannel;
        }
        hr = S_OK;
    }
    else
    {
        // No need to print an error message because PChannelIndex() does it.
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | DownloadInstrument |
  Downloads an IDirectMusicInstrument to the IDirectMusicPort specified by
  the selected PChannel.

  @rvalue E_INVALIDARG | The PChannel isn't assigned to a Port, or the Port failed
  to download the instrument. No return parameter is valid.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | One of the pointers is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::DownloadInstrument(
    IDirectMusicInstrument* pInst,  // @parm The instrument to download.
    DWORD dwPChannel,               // @parm The PChannel to assign the instrument.
    IDirectMusicDownloadedInstrument** ppDownInst,  // @parm Returns the downloaded instrument.
    DMUS_NOTERANGE* pNoteRanges,    // @parm A pointer to an array of DMUS_NOTERANGE structures
    DWORD dwNumNoteRanges,          // @parm Number of DMUS_NOTERANGE structures in array pointed to by pNoteRanges
    IDirectMusicPort** ppPort,      // @parm Returns the port to which the instrument was downloaded.
    DWORD* pdwGroup,                // @parm Returns the group to which the instrument was assigned.
    DWORD* pdwMChannel              // @parm Returns the MChannel to which the instrument was assigned.
        )
{
    V_INAME(IDirectMusicPerformance::DownloadInstrument);
    V_INTERFACE(pInst);
    V_PTRPTR_WRITE(ppDownInst);
    V_BUFPTR_READ_OPT(pNoteRanges, (sizeof(DMUS_NOTERANGE) * dwNumNoteRanges));
    V_PTRPTR_WRITE(ppPort);
    V_PTR_WRITE(pdwGroup,DWORD);
    V_PTR_WRITE(pdwMChannel,DWORD);


    DWORD dwIndex, dwGroup, dwMChannel;
    IDirectMusicPort* pPort = NULL;
    HRESULT hr = E_INVALIDARG;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        pPort = m_pPortTable[dwIndex].pPort;
        if( pPort )
        {
            hr = pPort->DownloadInstrument( pInst, ppDownInst, pNoteRanges, dwNumNoteRanges );
            pPort->AddRef();
        }
    }
    else
    {
        Trace(1,"Error: Download attempted on unassigned PChannel %ld\n",dwPChannel);
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED(hr) )
    {
        *ppPort = pPort;
        pPort->AddRef();
        *pdwGroup = dwGroup;
        *pdwMChannel = dwMChannel;
    }
    if( pPort )
    {
        pPort->Release();
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | Invalidate |
  Flushes all methods from <p mtTime> forward, and seeks all Segments back
  to <p mtTime>, thereby calling all Tracks to resend their data.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.

  @comm If <p mtTime> is so long ago that it is impossible to invalidate that time,
  the earliest possible time will be used.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Invalidate(
    MUSIC_TIME mtTime,  // @parm The time to invalidate, adjusted by <p dwFlags>. 0 means now.
    DWORD dwFlags)      // @parm Adjusts <p mtTime> to align to measures, beats, etc. See
                        // <t DMPLAYSEGFLAGS>.
{
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
         Trace(1,"Error: Invalidate() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection( &m_SegmentCrSec );
    EnterCriticalSection( &m_PipelineCrSec );

    SendBuffers();

    // make sure mtTime is greater than the current queue time
    REFERENCE_TIME rtQueue;
    MUSIC_TIME mtQueue;
    MUSIC_TIME mtBumperLength;

    GetQueueTime( &rtQueue );
    ReferenceToMusicTime( rtQueue, &mtQueue );
    ReferenceToMusicTime( m_rtBumperLength, &mtBumperLength );
    if( mtTime < mtQueue + mtBumperLength )
    {
        mtTime = mtQueue + mtBumperLength;
    }
    // resolve mtTime to the boundary of dwFlags
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // flush messages
    FlushMainEventQueues( 0, mtTime, mtQueue, FALSE );
    // move any segments in the past list that are affected into the current list
    CSegState *pSegSt;
    CSegState *pNext;
    for (pSegSt = m_SegStateQueues[SQ_SEC_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_SEC_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSegSt );
        }
    }
    for (pSegSt = m_SegStateQueues[SQ_CON_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_CON_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSegSt );
        }
    }
    pSegSt = m_SegStateQueues[SQ_PRI_DONE].GetTail();
    if(pSegSt)
    {
        // only check the last one in this list
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_PRI_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_PRI_PLAY].Insert( pSegSt );
        }
    }
    // seek back any affected segmentstates that were playing
    DWORD dwCount;
    for( dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++ )
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            if( pSegSt->m_fStartedPlay )
            {
                if (SQ_PRI_PLAY == dwCount && pSegSt->m_mtResolvedStart >= mtTime)
                {
                    // resend the segment start notification
                    pSegSt->GenerateNotification( DMUS_NOTIFICATION_SEGSTART, pSegSt->m_mtResolvedStart );
                    // if this is a primary or controlling segment, resend a DMUS_PMSGT_DIRTY message
                    if( !(pSegSt->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (pSegSt->m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
                    {
                        TraceI(4, "ReSend Dirty PMsg [3] %d (%d)\n", pSegSt->m_mtSeek, pSegSt->m_mtOffset + pSegSt->m_mtSeek);
                        pSegSt->SendDirtyPMsg( pSegSt->m_mtOffset + pSegSt->m_mtSeek );
                    }
                }
                if( pSegSt->m_mtLastPlayed > mtTime )
                {
                    // if mtTime is after the actual start time of the segment,
                    // set it so the segment has never been played before and
                    // seek the segment to the beginning
                    if( pSegSt->m_mtResolvedStart > mtTime )
                    {
                        pSegSt->m_mtLastPlayed = pSegSt->m_mtResolvedStart;
                        pSegSt->m_fStartedPlay = FALSE;
                    }
                    else
                    {
                        pSegSt->m_mtLastPlayed = mtTime;
                    }
                    pSegSt->SetInvalidate( pSegSt->m_mtLastPlayed );
                }
            }
        }
    }

    LeaveCriticalSection( &m_PipelineCrSec );
    LeaveCriticalSection( &m_SegmentCrSec );
    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );
    return S_OK;
}

STDMETHODIMP CPerformance::SetParamHook(IDirectMusicParamHook *pIHook)

{   V_INAME(IDirectMusicPerformance::SetParamHook);
    V_INTERFACE_OPT(pIHook);

    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    m_pParamHook = pIHook;
    if (pIHook)
    {
        pIHook->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParamEx(
    REFGUID rguidType,
    DWORD dwTrackID,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParamEx);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    static DWORD dwSearchOrder[SQ_COUNT] = { SQ_PRI_PLAY, SQ_SEC_PLAY,
                                      SQ_PRI_DONE, SQ_SEC_DONE,
                                      SQ_PRI_WAIT, SQ_SEC_WAIT,
                                      SQ_CON_PLAY, SQ_CON_DONE,
                                      SQ_CON_WAIT };

    DWORD dwIX;
    HRESULT hr;
    CSegState *pSegNode;
    if (dwTrackID)
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for (dwIX = 0; dwIX < SQ_COUNT; dwIX++)
        {
            pSegNode = m_SegStateQueues[dwSearchOrder[dwIX]].GetHead();
            for (;pSegNode;pSegNode = pSegNode->GetNext())
            {
                if ((pSegNode->m_dwFirstTrackID <= dwTrackID) &&
                    (pSegNode->m_dwLastTrackID >= dwTrackID))
                {
                    CTrack* pCTrack;
                    for (pCTrack = pSegNode->m_TrackList.GetHead();pCTrack;pCTrack = pCTrack->GetNext())
                    {
                        if (pCTrack->m_dwVirtualID == dwTrackID)
                        {
                            m_dwGetParamFlags = pCTrack->m_dwFlags;
                            m_pGetParamSegmentState = pSegNode;
                            break;
                        }
                    }
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else
    {
        m_pGetParamSegmentState = NULL;
        m_dwGetParamFlags = 0;
    }
    hr = GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData);
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParam(
    REFGUID rguidType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( pmtNext )
    {
        *pmtNext = 0; // this will be replaced by calls to IDMSegment::GetParam
    }
    CSegState* pSegNode;
    CSegState* pSegSource = (CSegState *) m_pGetParamSegmentState;
    DWORD dwOverrideFlags;
    HRESULT hr = DMUS_E_NOT_FOUND;
    BOOL fCheckedPast = FALSE;
    MUSIC_TIME mtOffset;
    DWORD dwRepeat = 0;
    MUSIC_TIME mtSegTime = 0;
    MUSIC_TIME mtSegEnd = 0;
    MUSIC_TIME mtLoopEnd = 0;
    DWORD dwRepeatsLeft = 0;
    if (pSegSource)
    {
        dwOverrideFlags = m_dwGetParamFlags & (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK);
    }
    else
    {
        dwOverrideFlags = 0;
    }

    if (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL)
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }
    if (FAILED(hr))
    {
        EnterCriticalSection(&m_SegmentCrSec);
        // we only care about control segments
        if( m_SegStateQueues[SQ_CON_DONE].GetHead() )
        {
            pSegNode = m_SegStateQueues[SQ_CON_DONE].GetHead();
        }
        else
        {
            pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            fCheckedPast = TRUE;
        }
        while( pSegNode )
        {
            mtSegTime = mtTime;
            if( S_OK == pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
            {
                hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                        mtSegTime, pmtNext, pData );
                if( SUCCEEDED(hr) )
                {
                    dwRepeatsLeft = pSegNode->m_dwRepeats;
                    mtLoopEnd = pSegNode->m_mtLoopEnd;
                    mtSegEnd = pSegNode->m_mtLength;
                    dwRepeatsLeft -= dwRepeat;

                    break; // got the param we want. We're outta this loop with a success.
                }
            }
            // we didn't find the param, so try the next segment.
            pSegNode = pSegNode->GetNext();

            // if we're the last segnode in the done queue, we need to
            // check against the time of the first segnode in the control play queue
            if (!pSegNode && !fCheckedPast )
            {
                pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
                fCheckedPast = TRUE;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY))
    {
        // The calling track wants the controlling param to come from the segment
        // itself if there was no controlling segment.
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) ) // didn't find one in the previous, so check for a primary segment
    {
        IDirectMusicSegment* pSegment = NULL;
        mtSegTime = mtTime;
        EnterCriticalSection(&m_SegmentCrSec);
        pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            pSegment = pSegNode->m_pSegment;
            pSegment->AddRef();
            pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat );
            dwRepeatsLeft = pSegNode->m_dwRepeats;
            mtLoopEnd = pSegNode->m_mtLoopEnd;
            mtSegEnd = pSegNode->m_mtLength;
            dwRepeatsLeft -= dwRepeat;
        }
        else
        {
            Trace(4, "Couldn't find SegState in GetParam call.\n");
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if( pSegment )
        {
            hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            pSegment->Release();
        }
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_FALLBACK))
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) )
    {   // If we failed, fill in the end time of loop or segment anyway.
        if (pmtNext)
        {   // Check to see if the loop end is earlier than end of segment.
            if (dwRepeatsLeft && (mtLoopEnd > mtSegTime))
            {
                *pmtNext = mtLoopEnd - mtSegTime;
            }
            else // Or, mark end of segment.
            {
                *pmtNext = mtSegEnd - mtSegTime;
            }
        }
        // if we're looking for timesig, and didn't find it anywhere,
        // return the Performance timesig
        if( rguidType == GUID_TimeSignature )
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for time signature passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
                DMUS_TIMESIG_PMSG timeSig;

                GetTimeSig( mtTime, &timeSig );
                pTSigData->bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
                pTSigData->bBeat = timeSig.bBeat;
                pTSigData->wGridsPerBeat = timeSig.wGridsPerBeat;
                pTSigData->mtTime = timeSig.mtTime - mtTime;
                hr = S_OK;
            }
        }
        // Likewise, if there was no tempo in a segment, we need to read directly from the tempo list.
        else if  ( rguidType == GUID_TempoParam || rguidType == GUID_PrivateTempoParam)
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for tempo passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMInternalTempo* pInternalTempo;
                EnterCriticalSection( &m_PipelineCrSec );
                pInternalTempo = (DMInternalTempo*)m_TempoMap.GetHead();
                DMInternalTempo* pNextTempo = NULL;
                for ( ;pInternalTempo;pInternalTempo = pNextTempo )
                {
                    pNextTempo = (DMInternalTempo *) pInternalTempo->pNext;
                    if (pNextTempo && (pNextTempo->tempoPMsg.mtTime <= mtTime))
                    {
                        continue;
                    }
                    if (rguidType == GUID_TempoParam)
                    {
                        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    else // rguidType == GUID_PrivateTempoParam
                    {
                        PrivateTempo* pTempoData = (PrivateTempo*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    if( pmtNext )
                    {
                        *pmtNext = 0;
                    }
                    break;
                }
                LeaveCriticalSection( &m_PipelineCrSec );
                if (pInternalTempo)
                {
                    hr = S_FALSE;
                }
            }
        }
    }
    else // GetParam from a segment succeeded, so we need to clean up the next time parameter to account
         // for loops and end of segment.
    {
        if (pmtNext) // Check to see if the loop end is earlier than *pmtNext.
        {
            if (dwRepeatsLeft && (*pmtNext > (mtLoopEnd - mtSegTime)))
            {
                if (mtLoopEnd >= mtSegTime) // This should always be true, but test anyway.
                {
                    *pmtNext = mtLoopEnd - mtSegTime;
                }
            }
        }
    }
    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook && SUCCEEDED(hr))
    {
        hr = m_pParamHook->GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData,
            pSegSource,m_dwGetParamFlags,hr);

    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}



/*
  @method HRESULT | IDirectMusicPerformance | SetParam |
  Sets data on a Track inside a Primary Segment in this Performance.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetParam(
    REFGUID rguidType,      // @parm The type of data to set.
    DWORD dwGroupBits,      // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,          // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,      // @parm The time at which to set the data. Unlike
                            // <om IDirectMusicSegment.SetParam>, this time is in
                            // performance time. The start time of the segment is
                            // subtracted from this time, and <om IDirectMusicSegment.SetParam>
                            // is called.
    void* pData)            // @parm The struture containing the data to set. Each
                            // <p pGuidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicPerformance::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: SetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    CSegState* pSegNode;
    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr;

    EnterCriticalSection(&m_SegmentCrSec);
    pSegNode = GetPrimarySegmentAtTime( mtTime );

    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    if( pSegNode )
    {
        pSegment = pSegNode->m_pSegment;
        pSegment->AddRef();
        pSegNode->ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    if( pSegment )
    {
        hr = pSegment->SetParam( rguidType, dwGroupBits, dwIndex,
                mtTime, pData );
        pSegment->Release();
    }
    else
    {
        Trace(1,"Error: SetParam failed because there is no segment at requested time.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGlobalParam |
  Gets global values from the Performance.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p pGuidType> isn't in the list of global data being handled by this
  Performance. Make sure to call <om IDirectMusicPerformance.SetGlobalParam> first.  Or,
  the value of <p pData> doesn't point to valid memory. Or, <p dwSize> isn't the size
  originally given in <om .SetGlobalParam>
  @rvalue E_POINTER | <p pData> is NULL or invalid.

  @xref <om .SetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm Allocated memory to receive a copy of the data. This must be
                        // the correct size, which is constant for each <p pGuidType> type of
                        // data, and was also passed in to <om .SetGlobalParam>.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::GetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_WRITE( pData, dwSize );
    }

    GlobalData* pGD;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    if( pGD && ( dwSize == pGD->dwSize ) )
    {
        memcpy( pData, pGD->pData, pGD->dwSize );
    }
    else
    {
#ifdef DBG
        if (pGD && ( dwSize != pGD->dwSize ))
        {
            Trace(1,"Error: GetGlobalParam() failed because the passed data size %ld was inconsistent with %ld, set previously.\n",
                dwSize, pGD->dwSize);
        }
        else
        {
            Trace(4,"Warning: GetGlobalParam() failed because the parameter had never been set.\n");
        }
#endif
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGlobalParam |
  Set global values on the Performance.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pData> is NULL or invalid.
  @rvalue E_OUTOFMEMORY | Ran out of memory.
  @rvalue E_INVALIDARG | Other failure. pData or dwSize not correct?

  @xref <om .GetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm The data itself, which will be copied and stored by the Performance.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::SetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_READ( pData, dwSize );
    }

    GlobalData* pGD;
    // see if this is one of our special Performance globals
    if( rguidType == GUID_PerfMasterTempo )
    {
        if( dwSize == sizeof(float) )
        {
            float flt;
            memcpy( &flt, pData, sizeof(float) );
            if( (flt >= DMUS_MASTERTEMPO_MIN) && (flt <= DMUS_MASTERTEMPO_MAX) )
            {
                if( m_fltRelTempo != flt )
                {
                    m_fltRelTempo = flt;
                    // It's only necessary to recalc the tempo map if something is playing
                    EnterCriticalSection(&m_SegmentCrSec);
                    if (GetPrimarySegmentAtTime(m_mtTransported))
                    {
                        RecalcTempoMap(NULL,m_mtTransported);
                    }
                    LeaveCriticalSection(&m_SegmentCrSec);
                }
            }
        }
        else
        {
            Trace(1,"Error: Attempt to set global tempo failed because dwSize is not size of float.\n");
            return E_INVALIDARG;
        }
    }
    else if( rguidType == GUID_PerfMasterVolume )
    {
        // master volume
        if( dwSize == sizeof(long) )
        {
            memcpy( &m_lMasterVolume, pData, sizeof(long) );
        }
        else
        {
            Trace(1,"Error: Attempt to set global volume failed because dwSize is not size of long.\n");
            return E_INVALIDARG;
        }
        // Go through all Ports and set the master volume.
        // This is also done upon adding a Port.
        IDirectMusicPort* pPort;
        DWORD dw;

        EnterCriticalSection(&m_PChannelInfoCrSec);
        for( dw = 0; dw < m_dwNumPorts; dw++ )
        {
            pPort = m_pPortTable[dw].pPort;
            if( pPort )
            {
                IKsControl *pControl;
                if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
                {
                    KSPROPERTY ksp;
                    ULONG cb;

                    memset(&ksp, 0, sizeof(ksp));
                    ksp.Set   = GUID_DMUS_PROP_Volume;
                    ksp.Id    = 0;
                    ksp.Flags = KSPROPERTY_TYPE_SET;

                    pControl->KsProperty(&ksp,
                                         sizeof(ksp),
                                         (LPVOID)&m_lMasterVolume,
                                         sizeof(m_lMasterVolume),
                                         &cb);
                    pControl->Release();
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
    }

    // see if this type is already there. If so, use it.
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    // if it already exists, just copy the new data into the
    // existing memory block and return
    if( pGD )
    {
        if( pGD->dwSize != dwSize )
        {
            Trace(1,"Error: Attempt to set global parameter failed because dwSize is not consistent with previous SetGlobalParam() call.\n");
            return E_INVALIDARG;
        }
        if( dwSize )
        {
            memcpy( pGD->pData, pData, dwSize );
        }
        return S_OK;
    }

    // otherwise, create new memory
    pGD = new GlobalData;
    if( NULL == pGD )
    {
        return E_OUTOFMEMORY;
    }
    pGD->dwSize = dwSize;
    if( dwSize )
    {
        pGD->pData = (void*)(new char[dwSize]);
        if( NULL == pGD->pData )
        {
            delete pGD;
            return E_OUTOFMEMORY;
        }
        memcpy( pGD->pData, pData, dwSize );
    }
    else
    {
        pGD->pData = NULL;
    }
    pGD->guidType = rguidType;
    EnterCriticalSection(&m_GlobalDataCrSec); // just using this one since it's available and not used much
    pGD->pNext = m_pGlobalData;
    m_pGlobalData = pGD;
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return S_OK;
}

// IDirectMusicTool
/*
  @method HRESULT | IDirectMusicTool | Init |
  Called when the Tool is inserted into the Graph, providing the Tool the opportunity
  to initialize itself.

  @rvalue S_OK | Success.
  @rvalue E_NOTIMPL | Not implemented is a valid return for the method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Init(
         IDirectMusicGraph* pGraph  // @parm The calling graph.
    )
{
    return E_NOTIMPL;
}

inline bool CPerformance::SendShortMsg( IDirectMusicBuffer* pBuffer,
                                   IDirectMusicPort* pPort,DWORD dwMsg,
                                   REFERENCE_TIME rt, DWORD dwGroup)

{
    if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
    {
        // ran out of room in the buffer
        TraceI(2, "RAN OUT OF ROOM IN THE BUFFER!\n");
        pPort->PlayBuffer( pBuffer );
        pBuffer->Flush();
        // try one more time
        if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
        {
            TraceI(1, "MAJOR BUFFER PACKING FAILURE!\n");
            // if it didn't work this time, free the event because something
            // bad has happened.
            return false;
        }
    }
    return true;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackNote
/*
  HRESULT | CPerformance | PackNote |
  Converts the message into a midiShortMsg, midiLongMsg, or user message
  and packs it into the appropriate IDirectMusicBuffer in the PortTable,
  setting the m_fBufferFilled flag.

  DMUS_PMSG* | pPMsg |
  [in] The message to pack into the buffer.

  REFERENCE_TIME | mt |
  [in] The time (in the Buffer's clock coordinates) at which to queue the message.

  E_INVALIDARG | Either pPMsg or pBuffer is NULL.
  E_OUTOFMEMORY | Failed to pack the buffer.
  DMUS_S_REQUEUE | Tells the Pipeline to requeue this message.
  DMUS_S_FREE | Tells the Pipeline to free this message.
*/
HRESULT CPerformance::PackNote(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pEvent;
    PRIV_PMSG* pPriv = DMUS_TO_PRIV(pEvent);
    REFERENCE_TIME rtLogical; // the time the note occurs in logical music time (subtract offset)
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    short nTranspose = 0;
    short nValue;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pNote->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel,
        &nTranspose )))
    {
        Trace(1,"Play note failed on unassigned PChannel %ld\n",pNote->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if(pPort && pBuffer )
    {
        dwMsg = 0;
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            // transpose the note's bMidiValue, and store it in the note so the note off
            // plays the correct pitch.
            nValue = pNote->bMidiValue + nTranspose;
            if( ( nValue > 127 ) || ( nValue < 0 )
                || pNote->mtDuration <= 0 )
            {
                // don't play this out-of-range or 0-duration note
                pPort->Release();
                pBuffer->Release();
                return DMUS_S_FREE;
            }
            pNote->bMidiValue = (BYTE)nValue;
            dwMsg |= pNote->bVelocity << 16;
        }
        else if( rt < pPriv->rtLast )
        {
            // the note off will play before the note on. Bad.
            rt = pPriv->rtLast + REF_PER_MIL;
        }
        dwMsg |= pNote->bMidiValue << 8; // set note value
        dwMsg |= dwMChannel; // MIDI Channel
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            dwMsg |= MIDI_NOTEON;
        }
        else
        {
            dwMsg |= MIDI_NOTEOFF;
        }

        if (SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup))
        {
            EnterCriticalSection(&m_PipelineCrSec); // to prevent deadlock in MusicToReferenceTime
            EnterCriticalSection(&m_PChannelInfoCrSec);
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            rtLogical = rt;
            // subtract the offset if needed, but only for a note on.
            if( pNote->nOffset && (pNote->bFlags & DMUS_NOTEF_NOTEON))
            {
                MUSIC_TIME mtTemp = pNote->mtTime - pNote->nOffset + 1;
                REFERENCE_TIME rtTemp;
                MusicToReferenceTime( mtTemp, &rtTemp );
                if( rtTemp > rtLogical )
                {
                    rtLogical = rtTemp;
                }
            }
            if( m_pPortTable[dwPortTableIndex].rtLast < rtLogical )
            {
                m_pPortTable[dwPortTableIndex].rtLast = rtLogical;
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            LeaveCriticalSection(&m_PipelineCrSec);

            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                pPriv->rtLast = rt;
                m_rtHighestPackedNoteOn = rt;
                if (pNote->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    rt = pNote->rtTime;
                    pNote->rtTime += (pNote->mtDuration * REF_PER_MIL);
                    if (pNote->mtDuration > 1)
                    {
                        pNote->rtTime -= REF_PER_MIL;
                    }
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( pNote->rtTime < rt + 1 )
                    {
                        pNote->rtTime = rt + 1;
                    }
                    pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                    pNote->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    hr = DMUS_S_REQUEUE;
                }
                else
                {
                    pNote->mtTime += pNote->mtDuration;
                    if (pNote->mtDuration > 1)
                    {
                        pNote->mtTime--;
                    }
                    MusicToReferenceTime( pNote->mtTime, &rt );
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( rt < pNote->rtTime + 2 )
                    {
                        rt = pNote->rtTime + 2;
                    }
                    pNote->rtTime = rt - 1;
                }
                pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackCurve
HRESULT CPerformance::PackCurve(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;
    BOOL fCalcStartValue = FALSE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pEvent )
        return E_INVALIDARG;

    // store the original start time so we know how far into the curve we are
    if( pCurve->mtOriginalStart == 0 )
    {
        // if we're flushing and have never played this curve at all, just free
        // it.
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            return DMUS_S_FREE;
        }
        if (pCurve->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
        {
            // This is a clock time message. Convert the duration into music time. It will act as
            // a music time message from now on. This does have the downside that if a dramatic tempo
            // change occurs in the middle of a lengthy curve, the end time can be distorted.
            // But, given the purpose of curves, this is really an unlikely issue.
            MUSIC_TIME mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtDuration = mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtResetDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtResetDuration = mtTemp;
            pCurve->dwFlags &= ~DMUS_PMSGF_LOCKTOREFTIME;
        }
        pCurve->mtOriginalStart = pCurve->mtTime;
        // check the latency clock. Adjust pCurve->mtTime if needed. This can happen
        // if the curve is time-stamped for the past. We only need do this for non-instant
        // curve types.
        if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )
        {
            REFERENCE_TIME rtLatency = GetLatency();
            MUSIC_TIME mtLatency;
            ReferenceToMusicTime( rtLatency, &mtLatency );
            if( pCurve->mtTime < mtLatency )
            {
                if( pCurve->mtTime + pCurve->mtDuration < mtLatency )
                {
                    // If it is far enough in the past,
                    // we only need to send out the final value.
                    pCurve->mtTime += pCurve->mtDuration;
                }
                else
                {
                    pCurve->mtTime = mtLatency;
                }
            }
            // If this is the start of a curve and we are supposed to start with the current playing value...
            if (pCurve->bFlags & DMUS_CURVE_START_FROM_CURRENT)
            {
                fCalcStartValue = TRUE;
            }
            else
            {
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
            }
        }
    }
    // it is necessary to check reset duration >= 0 because it could have been set
    // to be negative by the flushing, and we don't want to toss it in that case.
    // (should no longer be necessary to check, as a result of fixing 33987)
    if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && (pCurve->mtResetDuration >= 0) && ( pCurve->mtTime ==
        pCurve->mtDuration + pCurve->mtResetDuration + pCurve->mtOriginalStart ))
    {
        if( !( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH ) )
        {
            PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pEvent);
            if ( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_FLUSH) )
            {
                pPrivPMsg->dwPrivFlags &= ~PRIV_FLAG_FLUSH;
                pCurve->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                MUSIC_TIME mt = 0;
                if( rt <= pPrivPMsg->rtLast )
                {
                    return PackCurve( pEvent, pPrivPMsg->rtLast + REF_PER_MIL );
                }
                else
                {
                    return PackCurve( pEvent, rt );
                }
            }
            else
            {
                // the reset duration has expired, and we're not flushing, so expire the event.
                return DMUS_S_FREE;
            }
        }
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pCurve->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play curve failed on unassigned PChannel %ld\n",pCurve->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        DWORD dwCurve;
        DWORD dwMergeIndex = 0;
        dwMsg = 0;
        if (pCurve->dwFlags & DMUS_PMSGF_DX8)
        {
            dwMergeIndex = pCurve->wMergeIndex;
        }
        switch( pCurve->bType )
        {
        case DMUS_CURVET_PBCURVE:
            if (fCalcStartValue)
            {
                pCurve->nStartValue =
                    (short) pChannelMap->m_PitchbendMerger.GetIndexedValue(dwMergeIndex) + 0x2000;
            }
            dwCurve = ComputeCurve( pCurve );
            dwCurve = pChannelMap->m_PitchbendMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x2000,0x3FFF);
            dwMsg = MIDI_PBEND;
            dwMsg |= ( (dwCurve & 0x7F) << 8);
            dwCurve = dwCurve >> 7;
            dwMsg |= ( (dwCurve & 0x7F) << 16);
            break;
        case DMUS_CURVET_CCCURVE:
            switch (pCurve->bCCData)
            {
            case MIDI_CC_MOD_WHEEL:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ModWheelMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ModWheelMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_VolumeMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_VolumeMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_PAN:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_PanMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_PanMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ExpressionMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ExpressionMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_FILTER:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_FilterMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_FilterMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ReverbMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ReverbMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ChorusMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ChorusMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                dwCurve = ComputeCurve( pCurve );
                pChannelMap->Reset(pCurve->nEndValue);
                break;
            default:
                dwCurve = ComputeCurve( pCurve );
                break;
            }
            dwMsg = MIDI_CCHANGE;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_MATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_MTOUCH;
            dwMsg |= (dwCurve << 8);
            break;
        case DMUS_CURVET_PATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_PTOUCH;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_RPNCURVE:
        case DMUS_CURVET_NRPNCURVE:
            if (pCurve->dwFlags & DMUS_PMSGF_DX8)
            {
                dwCurve = ComputeCurve( pCurve );
                DWORD dwMsg2 = MIDI_CCHANGE;
                dwMsg = MIDI_CCHANGE;
                // First, send the two CC commands to select which RPN or NRPN event.
                if (pCurve->bType == DMUS_CURVET_RPNCURVE)
                {
                    dwMsg |= (MIDI_CC_RPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_RPN_LSB << 8);
                }
                else
                {
                    dwMsg |= (MIDI_CC_NRPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_NRPN_LSB << 8);
                }
                dwMsg |= (pCurve->wParamType  & 0x3F80) << 9;  // Upper 8 bits of command #
                dwMsg2 |= (pCurve->wParamType & 0x7F) << 16;   // Lower 8 bits.
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                dwMsg2 |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-3,pChannelMap->dwGroup); // Too bad if it fails!
                SendShortMsg(pBuffer,pPort,dwMsg2,rt-2,pChannelMap->dwGroup);
                // Then, send the two data CC commands.
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYMSB << 8);
                dwMsg |= (dwCurve & 0x3F80) << 9;  // Upper 8 bits of data
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-1,pChannelMap->dwGroup);
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYLSB << 8);
                dwMsg |= (dwCurve & 0x7F) << 16;  // Lower 8 bits of data
            }
        }
        if (dwMsg) // Make sure we successfully created a message.
        {
            dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
            if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
            {
                m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
                m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;

                // ComputeCurve() will set this to 0 if it's time to free the event. Otherwise, it
                // will set it to the next time this event should be performed.
                if( pCurve->rtTime )
                {
                    // If we didn't calculate the time slice because we didn't know
                    // what the start value was, do it now.
                    if (fCalcStartValue)
                    {
                        pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
                    }
                    hr = DMUS_S_REQUEUE;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackMidi
HRESULT CPerformance::PackMidi(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
//  DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pMidi )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pMidi->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play MIDI failed on unassigned PChannel %ld\n",pMidi->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }

    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if(pPort && pBuffer )
    {
        pMidi->bStatus &= 0xF0;
        if (pMidi->bStatus == MIDI_CCHANGE)
        {
            switch (pMidi->bByte1)
            {
            case MIDI_CC_MOD_WHEEL:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ModWheelMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                pMidi->bByte2 = pChannelMap->m_VolumeMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_PAN:
                pMidi->bByte2 = (BYTE) pChannelMap->m_PanMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                pMidi->bByte2 = pChannelMap->m_ExpressionMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_FILTER:
                pMidi->bByte2 = (BYTE) pChannelMap->m_FilterMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ReverbMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ChorusMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                pChannelMap->Reset(pMidi->bByte2);
                break;
            }

        }
        else if (pMidi->bStatus == MIDI_PBEND)
        {
            WORD wBend = pMidi->bByte1 | (pMidi->bByte2 << 7);
            wBend = (WORD) pChannelMap->m_PitchbendMerger.MergeValue(0,wBend,0x2000,0x3FFF);
            pMidi->bByte1 = wBend & 0x7F;
            pMidi->bByte2 = (wBend >> 7) & 0x7F;
        }
        dwMsg = pMidi->bByte1 << 8;
        dwMsg |= pMidi->bByte2 << 16;
        dwMsg |= pMidi->bStatus;
        dwMsg |= pChannelMap->dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
        {
            m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackSysEx
HRESULT CPerformance::PackSysEx(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_SYSEX_PMSG* pSysEx = (DMUS_SYSEX_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( NULL == m_pDirectMusic )
        return DMUS_E_NOT_INIT;

    if( FAILED( PChannelIndex( pSysEx->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play SysEx failed on unassigned PChannel %ld\n",pSysEx->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort )
    {
        // create a buffer of the right size
        DMUS_BUFFERDESC dmbd;
        memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
        dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
        dmbd.cbBuffer = pSysEx->dwLen + 48;

        EnterCriticalSection(&m_MainCrSec);
        if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
        {
            if( SUCCEEDED( pBuffer->PackUnstructured( rt - 4, dwGroup, pSysEx->dwLen, pSysEx->abData ) ) )
            {
                pPort->PlayBuffer(pBuffer);
            }
            pBuffer->Release();
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    if( pPort ) pPort->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackPatch
HRESULT CPerformance::PackPatch(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_PATCH_PMSG* pPatch = (DMUS_PATCH_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pPatch->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play Patch failed on unassigned PChannel %ld\n",pPatch->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        // subtract 10 from rt to guarantee that patch events always go out earlier than
        // notes with the same time stamp.
        rt -= 10;
        // send the bank select lsb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_LSB << 8 );
        dwMsg |= (pPatch->byLSB << 16);
        ASSERT( dwMChannel < 16 );
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup);
        // send the bank select msb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_MSB << 8 );
        dwMsg |= (pPatch->byMSB << 16);
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-1,dwGroup);
        // send the program change
        dwMsg = MIDI_PCHANGE;
        dwMsg |= (pPatch->byInstrument << 8);
        dwMsg |= dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,dwGroup))
        {
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[dwPortTableIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

HRESULT CPerformance::PackWave(DMUS_PMSG* pPMsg, REFERENCE_TIME rtTime)
{
    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
    HRESULT hr = DMUS_S_FREE;

    IDirectMusicVoiceP *pVoice = (IDirectMusicVoiceP *) pWave->punkUser;
    if (pVoice)
    {
        if (pWave->bFlags & DMUS_WAVEF_OFF)
        {
            pVoice->Stop(rtTime);
            EnterCriticalSection(&m_SegmentCrSec);
            for (DWORD dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( CSegState* pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
                {
                    CTrack* pTrack = pSegSt->m_TrackList.GetHead();
                    while( pTrack )
                    {
                        if (pTrack->m_guidClassID == CLSID_DirectMusicWaveTrack)
                        {
                            IPrivateWaveTrack* pWaveTrack = NULL;
                            if (pTrack->m_pTrack &&
                                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pWaveTrack)))
                            {
                                pWaveTrack->OnVoiceEnd(pVoice, pTrack->m_pTrackState);
                                pWaveTrack->Release();
                            }
                        }
                        pTrack = pTrack->GetNext();
                    }
                }
            }
            LeaveCriticalSection(&m_SegmentCrSec);
        }
        else
        {
            if (SUCCEEDED(pVoice->Play(rtTime, pWave->lPitch, pWave->lVolume)))
            {
                if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    pWave->rtTime += pWave->rtDuration ;
                    pWave->dwFlags &= ~DMUS_PMSGF_MUSICTIME;

                }
                else
                {
                    pWave->mtTime += (MUSIC_TIME) pWave->rtDuration;
                    pWave->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                pWave->bFlags |= DMUS_WAVEF_OFF;   // Queue this back up as a wave off.
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ProcessPMsg(
    IDirectMusicPerformance* pPerf, // @parm The performance pointer.
    DMUS_PMSG* pPMsg            // @parm The message to process.
    )
{
    V_INAME(IDirectMusicTool::ProcessPMsg);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    if (m_rtQueuePosition > pPMsg->rtTime + 50000000)
    {
        // pMSg is more than 5 seconds in the past; get rid of it unless it's signalling the
        // end of something that's already been started.
        if (pPMsg->dwType == DMUS_PMSGT_NOTIFICATION)
        {
            DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
            if ( (pNotify->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_MUSICSTOPPED) ||
                 (pNotify->guidNotificationType == GUID_NOTIFICATION_SEGMENT &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_SEGEND) )
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_NOTE)
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if (pNote->bFlags & DMUS_NOTEF_NOTEON)
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_WAVE)
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (!(pWave->bFlags & DMUS_WAVEF_OFF))
            {
                return DMUS_S_FREE;
            }
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    HRESULT hr = DMUS_S_FREE;

    ASSERT( pPerf == this );
    if( pPMsg->dwType == DMUS_PMSGT_TEMPO )
    {
        PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMsg);
        // If the pmsg was generated by a track, discard it
        // because it was already placed in the tempo map.
        if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_TRACK )
        {
            return DMUS_S_FREE;
        }
        // Otherwise, this was generated by the application, so it's not already
        // in the tempo map and we need to add it.
        AddEventToTempoMap( DMUS_TO_PRIV(pPMsg));
        return DMUS_S_FREE; // OK to free this event; not requeued
    }

    if ((pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) ||
        (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE))
    {
        // Scan through all the pchannels and make copies of the message for each pchannel.
        // Then, release this one.
        DWORD dwMax = PCHANNEL_BLOCKSIZE;
        // If one per channel group (for sysex, for example,) do only one per block.
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) dwMax = 1;
        EnterCriticalSection(&m_PipelineCrSec); // Make sure we are in this so we don't deadlock in SendPMsg().
        EnterCriticalSection(&m_PChannelInfoCrSec);
        CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();
        for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwMax; dwIndex++)
            {
                CChannelMap* pChannelMap = &pChannelBlock->m_aChannelMap[ dwIndex ];
                if( pChannelMap->dwGroup &&
                    (pChannelMap->wFlags & (CMAP_STATIC | CMAP_VIRTUAL)))
                {
                    DWORD dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                    // If this is a transpose on the drum channel, don't send it.
                    if ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwPChannel & 0xF) != 9))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            pNewMsg->dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                            SendPMsg(pNewMsg);
                        }
                    }
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_S_FREE;
    }

    if(pPMsg->dwType == DMUS_PMSGT_TRANSPOSE)
    {
        if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_QUEUE ))
        {
            // requeue any tranpose event to be queue time
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            DMUS_TRANSPOSE_PMSG* pTrans = (DMUS_TRANSPOSE_PMSG*)pPMsg;
            // set the PChannel for this transpose message
            EnterCriticalSection(&m_PChannelInfoCrSec);
            CChannelMap * pChannelMap = GetPChannelMap(pPMsg->dwPChannel);
            if (pChannelMap)
            {
                WORD wMergeIndex = 0;
                if (pPMsg->dwFlags & DMUS_PMSGF_DX8)
                {
                    wMergeIndex = pTrans->wMergeIndex;
                }
                pChannelMap->nTranspose = pChannelMap->m_TransposeMerger.MergeTranspose(
                    wMergeIndex,pTrans->nTranspose);
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            return DMUS_S_FREE;
        }
    }

    if(pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
        if (pNotify->guidNotificationType == GUID_NOTIFICATION_PRIVATE_CHORD)
        {
            // if we've got a GUID_NOTIFICATION_PRIVATE_CHORD,
            // invalidate/regenerate queued note events as necessary
            EnterCriticalSection(&m_PipelineCrSec);
            OnChordUpdateEventQueues(pNotify);
            LeaveCriticalSection(&m_PipelineCrSec);
            return DMUS_S_FREE;
        }
        else if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_ATTIME ))
        {
            // requeue any notification event to be ontime
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            // otherwise, fire the notification
            // first, move the event into the notification queue.
            // The app then calls GetNotificationPMsg to get the event.
            CLEARTOOLGRAPH(pPMsg);
            EnterCriticalSection(&m_PipelineCrSec);
            m_NotificationQueue.Enqueue( DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            EnterCriticalSection(&m_MainCrSec);
            if( m_hNotification )
            {
                SetEvent(m_hNotification);
            }
            LeaveCriticalSection(&m_MainCrSec);
            return S_OK; // don't free since we've placed the event into the
            // notification queue
        }
    }

    // add time signature changes to the time sig queue
    if(pPMsg->dwType == DMUS_PMSGT_TIMESIG )
    {
        CLEARTOOLGRAPH(pPMsg);
        DMUS_TIMESIG_PMSG* pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;

        // check for a legal time signature, which may not have any
        // members equal to 0, and bBeat must be evenly divisible by 2.
        if( pTimeSig->wGridsPerBeat &&
            pTimeSig->bBeatsPerMeasure &&
            pTimeSig->bBeat &&
            ( 0 == ( pTimeSig->bBeat % 2 )))
        {
            EnterCriticalSection(&m_PipelineCrSec);
            REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
            PRIV_PMSG* pCheck;
            while (pCheck = m_TimeSigQueue.FlushOldest(rtNow))
            {
                FreePMsg(pCheck);
            }
            m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return S_OK;
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    // requeue anything else that's early to be neartime
    if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        // if this is a stop command, make sure the segment state doesn't keep going
        if( pPMsg->dwType == DMUS_PMSGT_STOP )
        {
            IDirectMusicSegment* pSeg = NULL;
            IDirectMusicSegmentState* pSegState = NULL;
            if( pPMsg->punkUser )
            {
                if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegment,
                    (void**)&pSeg )))
                {
                    pSeg = NULL;
                }
                else if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState,
                    (void**)&pSegState )))
                {
                    pSegState = NULL;
                }
            }
            if( pSeg || pSegState )
            {
                EnterCriticalSection(&m_SegmentCrSec);
                if( pPMsg->mtTime > m_mtTransported )
                {
                    // find and mark the segment and/or segment state to not play beyond
                    // the stop point.
                    CSegState* pNode;
                    DWORD dwCount;
                    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
                    {
                        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                        {
                            if( (pNode->m_pSegment == pSeg) ||
                                (pNode == pSegState) )
                            {
                                pNode->m_mtStopTime = pPMsg->mtTime;
                            }
                        }
                    }
                }
                LeaveCriticalSection(&m_SegmentCrSec);
                if( pSeg )
                {
                    pSeg->Release();
                }
                if( pSegState )
                {
                    pSegState->Release();
                }
            }
        }
        pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
        pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
        return DMUS_S_REQUEUE;
    }

    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            hr = PackNote(  pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            hr = PackCurve( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_SYSEX:
        {
            hr = PackSysEx( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_MIDI:
        {
            hr = PackMidi( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_PATCH:
        {
            hr = PackPatch( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CHANNEL_PRIORITY:
        {
            DMUS_CHANNEL_PRIORITY_PMSG* pPriPMsg = (DMUS_CHANNEL_PRIORITY_PMSG*)pPMsg;
            DWORD dwPortTableIndex, dwGroup, dwMChannel;
            IDirectMusicPort* pPort;

            hr = DMUS_S_FREE;
            if( SUCCEEDED( PChannelIndex( pPriPMsg->dwPChannel, &dwPortTableIndex, &dwGroup,
                &dwMChannel )))
            {
                EnterCriticalSection(&m_PChannelInfoCrSec);
                if( dwPortTableIndex <= m_dwNumPorts )
                {
                    pPort = m_pPortTable[dwPortTableIndex].pPort;
                    if( pPort )
                    {
                        pPort->SetChannelPriority( dwGroup, dwMChannel,
                            pPriPMsg->dwChannelPriority );
                    }
                }
                LeaveCriticalSection(&m_PChannelInfoCrSec);
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            hr = PackWave( pPMsg, pPMsg->rtTime );
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Flush(
    IDirectMusicPerformance* pPerf, // @parm The Performance pointer.
     DMUS_PMSG* pPMsg,          // @parm The event to flush.
     REFERENCE_TIME rtTime          // @parm The time at which to flush.
    )
{
    V_INAME(IDirectMusicTool::Flush);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;

    ASSERT( pPerf == this );
    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if( !(pNote->bFlags & DMUS_NOTEF_NOTEON) )
            {
                PackNote( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pPMsg;
            if( pCurve->bFlags & DMUS_CURVE_RESET )
            {
                PackCurve( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (pWave->bFlags & DMUS_WAVEF_OFF)
            {
                PackWave( pPMsg, rtTime );
            }
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMsgDeliveryType(
    DWORD* pdwDeliveryType) // @parm Should return either DMUS_PMSGF_TOOL_IMMEDIATE, DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
                    // An illegal return value will be treated as DMUS_PMSGF_TOOL_IMMEDIATE by the <i IDirectMusicGraph>.
{
    V_INAME(IDirectMusicTool::GetMsgDeliveryType);
    V_PTR_WRITE(pdwDeliveryType,DWORD);

    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypeArraySize(
    DWORD* pdwNumElements) // @parm Returns the number of media types, with 0 meaning all.
{
    V_INAME(IDirectMusicTool::GetMediaTypeArraySize);
    V_PTR_WRITE(pdwNumElements,DWORD);

    *pdwNumElements = 0;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypes(
    DWORD** padwMediaTypes, // @parm This should be a DWORD array of size <p dwNumElements>.
                            // Upon return, the elements will be filled with the media types
                            // this Tool supports.
    DWORD dwNumElements)    // @parm Contains the number of elements, i.e. the size, of the
                            // array <p padwMediaTypes>. <p dwNumElements> should be equal
                            // to the number returned in
                            // <om IDirectMusicTool.GetMediaTypeArraySize>. If dwNumElements
                            // is less than this number, this method can't return all of the
                            // message types that are supported. If it is greater than this
                            // number, the element fields in the array will be set to zero.
{
    return E_NOTIMPL;
}

// IDirectMusicGraph
HRESULT STDMETHODCALLTYPE CPerformance::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::StampPMsg( DMUS_PMSG* pPMsg )
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph && ( S_OK == m_pGraph->StampPMsg( pPMsg )))
    {
        if (pPMsg->pGraph != this)
        {
            if( pPMsg->pGraph )
            {
                pPMsg->pGraph->Release();
                pPMsg->pGraph = NULL;
            }
            pPMsg->pGraph = this;
            pPMsg->pGraph->AddRef();
        }
        LeaveCriticalSection(&m_MainCrSec);
        return S_OK;
    }
    LeaveCriticalSection(&m_MainCrSec);
    if( pPMsg->pGraph )
    {
        pPMsg->pGraph->Release();
        pPMsg->pGraph = NULL;
    }
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }

    //otherwise there is no graph: set it to the internal Performance Tool
    pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
    pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
    pPMsg->pTool = this;
    pPMsg->pTool->AddRef();
    return S_OK;
}

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;

inline DWORD BitCount(DWORD dwPattern)

{
    DWORD dwCount = 0;

    while (dwPattern)
    {
        dwPattern &= (dwPattern - 1);
        dwCount++;
    }

    return dwCount;
}

inline bool InScale(BYTE bMIDI, BYTE bRoot, DWORD dwScale)
{
    TraceI(3, "note: %d root: %d scale: %x\n", bMIDI, bRoot, dwScale);
    // shift the note by the scale root, and put it in a one-octave range
    bMIDI = ((bMIDI + 12) - (bRoot % 12)) % 12;
     // merge two octaves of scale into one
    dwScale = (dwScale & 0x0fff) | ((dwScale >> 12) & 0x0fff);
    // note n is in scale if there's a bit in position n
    TraceI(3, "shifted note: %d shifted scale: %x\n", bMIDI, dwScale);
    return ((1 << bMIDI) & dwScale) ? true : false;
}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline DWORD PatternMatch(DWORD dwA, DWORD dwB)

{
    DWORD dwHit = 0;
    DWORD dwIndex = 0;
    for (;dwIndex < 24; dwIndex++)
    {
        if ((dwA & (1 << dwIndex)) == (dwB & (1 << dwIndex)))
        {
            dwHit++;
        }
    }
    return dwHit;
}

static DWORD dwFallbackScales[12] =
{
    0xab5ab5,0x6ad6ad,
    0x5ab5ab,0xad5ad5,
    0x6b56b5,0x5ad5ad,
    0x56b56b,0xd5ad5a,
    0xb56b56,0xd6ad6a,
    0xb5ab5a,0xad6ad6,
};

inline DWORD FixScale(DWORD dwScale)

{
    if (BitCount(dwScale & 0xFFF) > 4)
    {
        return dwScale;
    }
    DWORD dwBest = 0;
    DWORD dwBestPattern = DEFAULT_SCALE_PATTERN;
    DWORD dwX;
    for (dwX = 0;dwX < 12; dwX++)
    {
        DWORD dwTest = PatternMatch(dwScale,dwFallbackScales[dwX]);
        if (dwTest > dwBest)
        {
            dwBestPattern = dwFallbackScales[dwX];
            dwBest = dwTest;
        }
    }
    return dwBestPattern;
}

inline DWORD ThreeOctave(DWORD dwScale)
{
    DWORD dwResult = dwScale;
     // don't change third octave if there's something there
    if ( !(0xFFF000000 & dwScale) )
    {
        // copy second octave to third octave
        dwResult |= (dwScale & 0xFFF000) << 12;
    }
    return dwResult;
}

inline DWORD AddRootToScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (12 - (bScaleRoot % 12));
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

inline DWORD SubtractRootFromScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (bScaleRoot % 12);
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

static DWORD ChordFromScale(BYTE bRoot, DWORD dwScalePattern)

{
    DWORD dwChordPattern = CleanupScale(dwScalePattern >> (bRoot % 12));
    DWORD dwX;
    DWORD dwBitCount = 0;
    for (dwX = 0; dwX < 24; dwX++)
    {
        DWORD dwBit = 1 << dwX;
        if (dwChordPattern & dwBit)
        {
            if ((dwBitCount & 1) || (dwBitCount > 7))
            {
                dwChordPattern &= ~dwBit;
            }
            dwBitCount++;
        }
    }
    return dwChordPattern;
}

static DWORD InvertChord(BYTE bKey, BYTE bChordRoot, DWORD dwChordPattern, bool& rfBelowRoot)

{
    // rotate the chord by the difference between the key and chord root
    rfBelowRoot = false;
    bKey %= 12;
    bChordRoot %= 12;
    if (bKey < bChordRoot) bKey += 12;
    BYTE bRotate = bKey - bChordRoot;
    // first check if the whole chord fits into one octave
    if ( !(dwChordPattern & 0xFFF000) )
    {
        dwChordPattern = ThreeOctave(CleanupScale(dwChordPattern));
        dwChordPattern >>= bRotate;
        dwChordPattern &= 0xFFF;
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)))
        {
            dwChordPattern |= (dwChordPattern << 12);
            dwChordPattern &= 0x3FFC00;
            rfBelowRoot = true;
        }
    }
    else
    {
        dwChordPattern &= 0xFFFFFF; // make sure there are only notes in the two-octave range
        // do a circular shift in the closest direction
        BYTE bRotate2 = (bChordRoot + 12) - bKey;
        if (bRotate <= bRotate2)
        {
            dwChordPattern = (dwChordPattern << (24 - bRotate)) | (dwChordPattern >> bRotate);
        }
        else
        {
            dwChordPattern = (dwChordPattern >> (24 - bRotate2)) | (dwChordPattern << bRotate2);
        }
        dwChordPattern &= 0xFFFFFF;
        if (!(dwChordPattern & 0x7) &&
            (!(dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000)) ||
             !(dwChordPattern & 0x3000) && ((dwChordPattern & 0x800000)) ||
             !(dwChordPattern & 0x1000) && ((dwChordPattern & 0x1000000)) ||
             !(dwChordPattern & 0x7) && (dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000))) )
        {
            dwChordPattern = (dwChordPattern << 12) | (dwChordPattern >> 12);
            dwChordPattern &= 0xFFFFFF;
        }
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)) ||
            !(dwChordPattern & 0x1) && ((dwChordPattern & 0x1000)) )
        {
            // put everything up to the G in the first octave two octaves up;
            // put G# and A one octave up
            dwChordPattern |= (((dwChordPattern & 0xFF) << 24) | ((dwChordPattern & 0x300) << 12));
            // get rid of everything below A# in the first octave
            dwChordPattern &= 0xFFFFFC00;
            // If there are no notes lower than C2, shift everything back down an octave
            if (!(dwChordPattern & 0xFFF))
            {
                dwChordPattern >>= 12;
            }
            else
            {
                rfBelowRoot = true;
            }
        }
    }
    return dwChordPattern;

}

/*  This is SuperJAM! code */

static unsigned char OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   result ;
    char            octpart   = (char)(value >> 12) ;
    char            chordpart = (char)((value >> 8) & 0xF) ;
    char            keypart   = (char)((value >> 4) & 0xF) ;
    char            accpart   = (char)(value & 0xF) ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    for( ;  chordpattern ;  result++ ) {
        if( chordpattern & 1L ) {
            if( !chordpart )
                break ;
            chordpart-- ;
        }
        chordpattern = chordpattern >> 1L ;
        if( !chordpattern ) {
            if( !scalevalue )
                return( 0 ) ;
            result  = unsigned char(12 * octpart) ;
            result += chordroot ;
            keypart = char(scalevalue >> 4) ;
            accpart = char(scalevalue & 0x0F) ;
            break ;
        }
    }

    if( keypart ) {
        keypattern = CleanupScale(keypattern) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}


/*  This is SuperJAM! code */

static unsigned short OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   octpart = 0 ;
    unsigned char   chordpart = 0;
    unsigned char   keypart = (BYTE)-1 ;
    unsigned char   accpart = 0 ;
    unsigned char   scan, test, base, last ;    // was char
    long            pattern ;
    short           testa, testb ;


    scan = chordroot ;

    // If we're trying to play a note below the bottom of our chord, forget it
    if( note < scan)
    {
        return 0;
    }

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = last = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
        {
            accpart = 0;
            while (!(pattern & 1) && pattern)
            {
                accpart--;
                pattern >>= 1;
            }
            return( (unsigned short) (octpart << 12) + (accpart & 0xF)) ;           // if octave, return.
        }
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {
                if( scan == note )              // note in chord?
                {
                    chordpart++ ;
                    return((unsigned short) ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
    pattern     = CleanupScale(keypattern);
    pattern     = pattern >> ((scan - keyroot) % 12) ;

    for( ;  pattern ;  pattern=pattern >> 1 )
    {
        if( 1 & pattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = -1 ;
        }
    }

    // If the conversion didn't find an exact match, fudge accpart to make it work
    testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));
    testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                 chordpattern, chordroot );

    if( testa != note )
    {
        accpart += note - testa;
    }

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

}

inline short MusicValueOctave(WORD wMusicValue)
{ return short((wMusicValue >> 12) & 0xf) * 12; }

inline short MusicValueAccidentals(WORD wMusicValue)
{
    short acc = short(wMusicValue & 0xf);
    return (acc > 8) ? acc - 16 : acc;
}

inline short BitsInChord(DWORD dwChordPattern)
{

    for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)
        if (dwChordPattern & 1) nResult++;
    return nResult;
}

#define S_OVER_CHORD    0x1000      // Success code to indicate the musicval could not be
                                    // converted because the note is above the top of the chord.

short MusicValueIntervals(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bRoot)
{
    if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))
    {
        DWORD dwDefaultScale =
            (pSubChord->dwScalePattern) ? (pSubChord->dwScalePattern) : DEFAULT_SCALE_PATTERN;
        dwDefaultScale = AddRootToScale(pSubChord->bScaleRoot, dwDefaultScale);
        dwDefaultScale = ThreeOctave(FixScale(dwDefaultScale));
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        if (!dwChordPattern) dwChordPattern = 1;
        bool fBelowRoot = false;
        if ((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && bPlayModes != DMUS_PLAYMODE_PEDALPOINT)
        {
            dwChordPattern = InvertChord(bRoot, pSubChord->bChordRoot, dwChordPattern, fBelowRoot);
        }
        const short nChordPosition = (wMusicValue >> 8) & 0xf;
//      const short nScalePosition = (wMusicValue >> 4) & 0xf;
        // ensure that scale position is < 8
        const short nScalePosition = (wMusicValue >> 4) & 0x7;
        const short nChordBits = BitsInChord(dwChordPattern);
        short nSemitones = 0;
        // If the chord doesn't have a root or second, but does have a seventh, it's been inverted and
        // we need to start below the root
        short nTransposetones;
        DWORD dwPattern;
        short nPosition;
        BYTE bOctRoot = bRoot % 12; // root in one octave
        // if using chord intervals and the note is in the chord
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
            !nScalePosition &&
            (nChordPosition < nChordBits) )
        {
            nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
        }
        // if using chord intervals and note is inside the chord (including 6ths)
        else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
                 (nChordPosition < nChordBits) )
        {
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
            if (dwPattern)
            {
                // skip to the first note in the chord
                while (!(dwPattern & 1))
                {
                    dwPattern >>= 1;
                    nSemitones++;
                }
            }
            if (nPosition > 0)
            {
                do
                {
                    dwPattern >>= 1; // this will ignore the first note in the chord
                    nSemitones++;
                    if (dwPattern & 1)
                    {
                        nPosition--;
                    }
                    if (!dwPattern)
                    {
                        nSemitones += nPosition;
//                      assert (0); // This shouldn't happen...
                        break;
                    }
                } while (nPosition > 0);
            }

            nSemitones += bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> (nSemitones % 12);  // start comparing partway through the pattern
            nPosition = nScalePosition;
        }
        // if using scale intervals
        else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)
        {
            fBelowRoot = false; // forget about chord inversions
            nSemitones = bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern
            nPosition = nChordPosition * 2 + nScalePosition;
        }
        else
        {
            return S_OVER_CHORD;  //
        }
        nPosition++; // Now nPosition corresponds to actual scale positions
        for (; nPosition > 0; dwPattern >>= 1)
        {
            nSemitones++;
            if (dwPattern & 1)
            {
                nPosition--;
            }
            if (!dwPattern)
            {
                nSemitones += nPosition;
//              assert (0); // This shouldn't happen...
                break;
            }
        }
        nSemitones--; // the loop counts one too many semitones...
        if (fBelowRoot)
        {
            nSemitones -=12;
        }
        return nSemitones + nTransposetones;
    }
    else
    {
        // should be impossible for 2.5 format
        return bRoot + wMusicValue;
    }
}

inline short MusicValueChord(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    // first, get the root for transposition.
    BYTE bRoot = 0;
    if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)
    {
        bRoot = pSubChord->bChordRoot;
    }
    else if (bPlayModes & DMUS_PLAYMODE_KEY_ROOT)
        bRoot = bKey;
    // Next, get an interval and combine it with the root.
    return MusicValueIntervals(wMusicValue, bPlayModes, pSubChord, bRoot);
}

inline short MusicValueConvert(WORD wMV, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    short nResult = 0;
    // First, make sure the octave is not negative.
    short nOffset = 0;
    while (wMV >= 0xE000)
    {
        wMV += 0x1000;
        nOffset -= 12;
    }

    // If the music value has a negative scale offset, convert to an equivalent
    // music value with a positive offset (up an octave) and shift the whole thing
    // down an octave
    WORD wTemp = (wMV & 0x00f0) + 0x0070;
    if (wTemp & 0x0f00)
    {
        wMV = (wMV & 0xff0f) | (wTemp & 0x00f0);
        nOffset = -12;
    }

    short nChordValue = MusicValueChord(wMV, bPlayModes, pSubChord, bKey);
    if (nChordValue != S_OVER_CHORD)
    {
        nChordValue += nOffset;
        // If the chord root is < 12, take the result down an octave.
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))
            nResult = MusicValueOctave(wMV) + nChordValue - 12;
        else
            nResult = MusicValueOctave(wMV) + nChordValue;
    }
    else
        nResult = S_OVER_CHORD;
    return nResult;
}

HRESULT STDMETHODCALLTYPE CPerformance::MIDIToMusic(
                BYTE bMIDIValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                WORD *pwMusicValue
            )

{
    V_INAME(IDirectMusicPerformance::MIDIToMusic);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pwMusicValue,WORD);

    long lMusicValue;
    HRESULT hr = S_OK;
#ifdef DBG
    long lMIDIInTraceValue = bMIDIValue;
#endif

    if ((bPlayMode & DMUS_PLAYMODE_NONE ) || (bMIDIValue & 0x80))
    {
        Trace(1,"Error: MIDIToMusic conversion failed either because there is no playmode or MIDI value %ld is out of range.\n",(long)bMIDIValue);
        return E_INVALIDARG;
    }
    else if( bPlayMode == DMUS_PLAYMODE_FIXED )
    {
        *pwMusicValue = bMIDIValue & 0x7F;
        return S_OK;
    }
    else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to key
    {
        lMusicValue = bMIDIValue - pChord->bKey;
        while (lMusicValue < 0)
        {
            lMusicValue += 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_UP_OCTAVE;
        }
        while (lMusicValue > 127)
        {
            lMusicValue -= 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_DOWN_OCTAVE;
        }
        *pwMusicValue = (WORD) lMusicValue;
        return hr;
    }
    else
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lMusicValue = bMIDIValue - (pSubChord->bChordRoot % 24);
            while (lMusicValue < 0)
            {
                lMusicValue += 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_UP_OCTAVE;
            }
            while (lMusicValue > 127)
            {
                lMusicValue -= 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value down an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_DOWN_OCTAVE;
            }
            *pwMusicValue = (WORD) lMusicValue;
            return hr;
        }
        bool fBelowRoot = false;
        DWORD dwScalePattern = AddRootToScale(pSubChord->bScaleRoot, pSubChord->dwScalePattern);
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        BYTE bKeyRoot = pChord->bKey;
        BYTE bChordRoot = pSubChord->bChordRoot;
        dwScalePattern = FixScale(dwScalePattern);
        bPlayMode &= 0xF;   // We only know about the bottom four flags, at this point.
//        if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT)
        // Do this for any non-fixed key root mode (Pedalpoint, PedalpointChord, PedalpointAlways)
        if (bPlayMode & DMUS_PLAYMODE_KEY_ROOT)
        {
            while (bKeyRoot > bMIDIValue)
            {
                hr = DMUS_S_UP_OCTAVE;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_KEY_ROOT note.\n");
                bMIDIValue += 12;
            }
            dwScalePattern = SubtractRootFromScale(bKeyRoot,dwScalePattern);
            if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT || !dwChordPattern)
            {
                bChordRoot = bKeyRoot;
                dwChordPattern = ChordFromScale(0,dwScalePattern);
            }
            else
            {
                dwChordPattern = InvertChord(bKeyRoot, bChordRoot, dwChordPattern, fBelowRoot);
                BYTE bNewChordRoot = 0;
                if (dwChordPattern)
                {
                    for (; !(dwChordPattern & (1 << bNewChordRoot)); bNewChordRoot++);
                }
                bChordRoot = bNewChordRoot + bKeyRoot;
                dwChordPattern >>= bNewChordRoot;
            }
        }
        else if (bPlayMode == DMUS_PLAYMODE_MELODIC)
        {
            bKeyRoot = 0;
            dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
        }
        else
        {
            bKeyRoot = 0;
            if (!dwChordPattern)
            {
                dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
            }
        }
        BOOL fDropOctave = FALSE;
        if (bMIDIValue < 24)
        {
            fDropOctave = TRUE;
            bMIDIValue += 24;
        }
        WORD wNewMusicValue = OldNoteToMusicValue( bMIDIValue,
            dwScalePattern,
            bKeyRoot,
            dwChordPattern,
            bChordRoot );
        if (fDropOctave)
        {
            wNewMusicValue -= 0x2000;
            bMIDIValue -= 24;
        }

        // If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
        // // also take the result up for the new pedalpoint chord modes.
        if( (bPlayMode & DMUS_PLAYMODE_CHORD_ROOT)  ||
            fBelowRoot)
            //((bPlayMode & DMUS_PLAYMODE_KEY_ROOT) && bPlayMode != DMUS_PLAYMODE_PEDALPOINT) )
        {
            wNewMusicValue += 0x1000;
        }
        short nTest =
            MusicValueConvert(wNewMusicValue, bPlayMode,
                pSubChord, pChord->bKey);

        if (nTest == (short) bMIDIValue)
        {
            *pwMusicValue = wNewMusicValue;
        }
        else
        {
            if (nTest == S_OVER_CHORD)
            {
                if (BitCount(pSubChord->dwChordPattern) < 4)
                {
                    DWORD dwOldChordPattern = pSubChord->dwChordPattern;
                    pSubChord->dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
                    nTest =
                        MusicValueConvert(wNewMusicValue, bPlayMode,
                            pSubChord, pChord->bKey);
                    pSubChord->dwChordPattern = dwOldChordPattern;
                    if (nTest == (short) bMIDIValue)
                    {
                        *pwMusicValue = wNewMusicValue;
                        return hr;
                    }
                }
            }
            *pwMusicValue = wNewMusicValue;
#ifdef DBG // Put in brackets just in case the compiler is using something different than DBG for turning on Trace.
            Trace(1,"Error: Unable to convert MIDI value %ld to Music value. This usually means the DMUS_CHORD_KEY structure has an invalid chord or scale pattern.\n",
                lMIDIInTraceValue);
#endif
            return DMUS_E_CANNOT_CONVERT;
        }
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::MusicToMIDI(
                WORD wMusicValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                BYTE *pbMIDIValue
            )

{
    V_INAME(IDirectMusicPerformance::MusicToMIDI);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pbMIDIValue,BYTE);

    long lReturnVal = wMusicValue;
    HRESULT hr = S_OK;

    if (bPlayMode != DMUS_PLAYMODE_FIXED)
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode & DMUS_PLAYMODE_NONE )
        {
            *pbMIDIValue = 0;
            Trace(1,"Error: Unable to convert Music value to MIDI because the playmode is DMUS_PLAYMODE_NONE.\n");
            return E_INVALIDARG;
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lReturnVal += (pSubChord->bChordRoot % 24);
        }
        else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to scale
        {
            lReturnVal += pChord->bKey;
        }
        else
        {
            lReturnVal =
                MusicValueConvert((WORD)lReturnVal, bPlayMode, pSubChord, pChord->bKey);
        }
    }
    if (lReturnVal == S_OVER_CHORD)
    {
        Trace(5,"Warning: MIDIToMusic unable to convert because note out of chord range.\n");
        return DMUS_S_OVER_CHORD;
    }
    while (lReturnVal < 0)
    {
        lReturnVal += 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value up an octave to stay in MIDI range.\n");
        hr = DMUS_S_UP_OCTAVE;
    }
    while (lReturnVal > 127)
    {
        lReturnVal -= 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value down an octave to stay in MIDI range.\n");
        hr = DMUS_S_DOWN_OCTAVE;
    }
    *pbMIDIValue = (BYTE) lReturnVal;
    return hr;
}

// returns:
// S_OK if the note should be invalidated (any other return code will not invalidate)
// S_FALSE if processing otherwise succeeded, but the note should not be invalidated
// E_OUTOFMEMORY if allocation of a new note failed
HRESULT CPerformance::GetChordNotificationStatus(DMUS_NOTE_PMSG* pNote,
                                                 //IDirectMusicSegment* pSegment,
                                                 DWORD dwTrackGroup,
                                                 REFERENCE_TIME rtTime,
                                                 DMUS_PMSG** ppNew)
{
    HRESULT hr = S_FALSE; // default: succeed, but don't invalidate the note

    DMUS_CHORD_PARAM CurrentChord;
    MUSIC_TIME mtTime;
    ReferenceToMusicTime(rtTime, &mtTime);

    if (pNote->bFlags & (DMUS_NOTEF_NOINVALIDATE_INSCALE | DMUS_NOTEF_NOINVALIDATE_INCHORD))
    {
        // If the note is inconsistent with the current scale/chord, invalidate it
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            if (CurrentChord.bSubChordCount > 0)
            {
                BYTE bRoot = CurrentChord.SubChordList[0].bChordRoot;
                DWORD dwScale = CurrentChord.SubChordList[0].dwScalePattern;
                if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD)
                {
                    dwScale = CurrentChord.SubChordList[0].dwChordPattern;
                }
                else
                {
                    dwScale = FixScale(SubtractRootFromScale(bRoot, dwScale));
                }
                if (!InScale(pNote->bMidiValue, bRoot, dwScale))
                {
                    hr = S_OK;
                }
            }
        }
    }
    else if (pNote->bFlags & DMUS_NOTEF_REGENERATE)
    {
        // this always causes an invalidation, and in addition generates a new note event,
        // based on the Music Value of the current one, that starts at rtTime
        // and continues until pNote->mtTime + pNote->Duration
        // EXCEPTION: the newly generated note is the same as the currently playing one
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            BYTE bNewMidiValue = 0;
            if (SUCCEEDED(MusicToMIDI(pNote->wMusicValue, &CurrentChord, pNote->bPlayModeFlags,
                                        pNote->bSubChordLevel, &bNewMidiValue)) &&
                bNewMidiValue != pNote->bMidiValue)
            {
                MUSIC_TIME mtDuration = (pNote->bFlags & DMUS_NOTEF_NOTEON) ? pNote->mtDuration - (mtTime - pNote->mtTime) : pNote->mtTime - mtTime;
                // Make any duration < 1 be 0; this will cause the note not to
                // sound.  Can happen if the note's logical time is well before
                // its physical time.
                if( mtDuration < 1 ) mtDuration = 0;
                DMUS_PMSG* pNewPMsg = NULL;
                if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTE_PMSG), &pNewPMsg )))
                {
                    DMUS_NOTE_PMSG* pNewNote = (DMUS_NOTE_PMSG*)pNewPMsg;
                    // start by copying the current note into the new one
                    pNewNote->dwFlags = pNote->dwFlags;
                    pNewNote->dwPChannel = pNote->dwPChannel;
                    pNewNote->dwVirtualTrackID = pNote->dwVirtualTrackID;
                    pNewNote->pTool = pNote->pTool;
                    if (pNewNote->pTool) pNewNote->pTool->AddRef();
                    pNewNote->pGraph = pNote->pGraph;
                    if (pNewNote->pGraph) pNewNote->pGraph->AddRef();
                    pNewNote->dwType = pNote->dwType;
                    pNewNote->dwVoiceID = pNote->dwVoiceID;
                    pNewNote->dwGroupID = pNote->dwGroupID;
                    pNewNote->punkUser = pNote->punkUser;
                    if (pNewNote->punkUser) pNewNote->punkUser->AddRef();
                    pNewNote->wMusicValue = pNote->wMusicValue;
                    pNewNote->wMeasure = pNote->wMeasure;
                    pNewNote->nOffset = pNote->nOffset;
                    pNewNote->bBeat = pNote->bBeat;
                    pNewNote->bGrid = pNote->bGrid;
                    pNewNote->bVelocity = pNote->bVelocity;
                    pNewNote->bTimeRange = pNote->bTimeRange;
                    pNewNote->bDurRange = pNote->bDurRange;
                    pNewNote->bVelRange = pNote->bVelRange;
                    pNewNote->bPlayModeFlags = pNote->bPlayModeFlags;
                    pNewNote->bSubChordLevel = pNote->bSubChordLevel;
                    pNewNote->cTranspose = pNote->cTranspose;
                    // only things that need to change are flags, MIDI value, start time, and duration
                    pNewNote->mtTime = mtTime;
                    MusicToReferenceTime(pNewNote->mtTime, &pNewNote->rtTime);
                    pNewNote->mtDuration = mtDuration;
                    pNewNote->bMidiValue = bNewMidiValue;
                    pNewNote->bFlags = DMUS_NOTEF_NOTEON | DMUS_NOTEF_REGENERATE;
                    PackNote(pNewPMsg, rtTime + 1); // play the note on
                    *ppNew = pNewPMsg;  // PackNote modifies event to be note-off; queue this
                    // invalidate the current note
                    hr = S_OK;
                }
                else hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::TimeToRhythm(
                MUSIC_TIME mtTime,
                DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,
                BYTE *pbBeat,
                BYTE *pbGrid,
                short *pnOffset
            )

{
    V_INAME(IDirectMusicPerformance::TimeToRhythm);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pwMeasure,WORD);
    V_PTR_WRITE(pbBeat,BYTE);
    V_PTR_WRITE(pbGrid,BYTE);
    V_PTR_WRITE(pnOffset,short);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = mtTime - pTimeSig->mtTime;
    *pwMeasure = (WORD)((lTemp / lMeasureLength));
    lTemp = lTemp % lMeasureLength;
    *pbBeat = (BYTE)(lTemp / lBeatLength);
    lTemp = lTemp % lBeatLength;
    *pbGrid = (BYTE)(lTemp / lGridLength);
    *pnOffset = (short)(lTemp % lGridLength);
    if (*pnOffset > (lGridLength >> 1))
    {
        *pnOffset -= (short) lGridLength;
        (*pbGrid)++;
        if (*pbGrid == pTimeSig->wGridsPerBeat)
        {
            *pbGrid = 0;
            (*pbBeat)++;
            if (*pbBeat == pTimeSig->bBeatsPerMeasure)
            {
                *pbBeat = 0;
                (*pwMeasure)++;
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::RhythmToTime(
                WORD wMeasure,
                BYTE bBeat,
                BYTE bGrid,
                short nOffset,
                DMUS_TIMESIGNATURE *pTimeSig,
                MUSIC_TIME *pmtTime
            )

{
    V_INAME(IDirectMusicPerformance::RhythmToTime);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = nOffset + pTimeSig->mtTime;
    lTemp += wMeasure * lMeasureLength;
    lTemp += bBeat * lBeatLength;
    lTemp += bGrid * lGridLength;
    *pmtTime = lTemp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmprfdll.cpp ===
//
// dmprfdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "debug.h"
#define ASSERT  assert 
#include "debug.h"
#include "dmprfdll.h"
#include "dmperf.h"
#include "dmsegobj.h"
#include "song.h"
#include "seqtrack.h"
#include "sysextrk.h"
#include "tempotrk.h"
#include "tsigtrk.h"
#include "marktrk.h"
#include "wavtrack.h"
#include "segtrtrk.h"
#include "lyrictrk.h"
#include "ParamTrk.h"
#include "dmgraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\oledll.h"
#include "..\dmstyle\dmstylep.h"
#include "..\dmband\dmbndtrk.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "dmksctrl.h"
#include "dmscriptautguids.h"
#include "audpath.h"
#include "..\dswave\dswave.h"
#include "dsoundp.h"            // For IDirectSoundPrivate

bool g_fInitCS = false;
CRITICAL_SECTION g_CritSec;


//////////////////////////////////////////////////////////////////////
// Globals

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
    m_cRef = 1;
    m_dwClassType = dwClassType;
    InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
    InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    switch (m_dwClassType)
    {
    case CLASS_PERFORMANCE:
        {
            CPerformance *pInst;

            try
            {
                pInst = new CPerformance;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_GRAPH:
        {
            CGraph *pInst = new CGraph;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEGMENT:
        {
            CSegment *pInst = new CSegment;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            // The segment is initialized with a ref count of 0, so QI will set it to 1.
            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_SONG:
        {
            CSong *pInst = new CSong;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_AUDIOPATH:
        {
            CAudioPathConfig *pInst;

            try
            {
                pInst = new CAudioPathConfig;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEQTRACK:
        {
            CSeqTrack *pInst;

            try
            {
                pInst = new CSeqTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SYSEXTRACK:
        {
            CSysExTrack *pInst;

            try
            {
                pInst = new CSysExTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TEMPOTRACK:
        {
            CTempoTrack *pInst;

            try
            {
                pInst = new CTempoTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TIMESIGTRACK:
        {
            CTimeSigTrack *pInst;
    
            try
            {
                pInst = new CTimeSigTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_MARKERTRACK:
        {
            CMarkerTrack *pInst;
    
            try
            {
                pInst = new CMarkerTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_WAVETRACK:
        {
            CWavTrack *pInst;
    
            try
            {
                pInst = new CWavTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TRIGGERTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CSegTriggerTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_LYRICSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CLyricsTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_PARAMSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CParamControlTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_SEGSTATE:
        {
            CSegState *pInst = new CSegState;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}


// Version information for our class
//
TCHAR g_szDMPerformanceFriendlyName[]    = TEXT("DirectMusicPerformance");
TCHAR g_szDMPerformanceVerIndProgID[]    = TEXT("Microsoft.DirectMusicPerformance");
TCHAR g_szDMPerformanceProgID[]          = TEXT("Microsoft.DirectMusicPerformance.1");

TCHAR g_szDMSegmentFriendlyName[]    = TEXT("DirectMusicSegment");
TCHAR g_szDMSegmentVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegment");
TCHAR g_szDMSegmentProgID[]          = TEXT("Microsoft.DirectMusicSegment.1");

TCHAR g_szDMSegmentStateFriendlyName[]    = TEXT("DirectMusicSegmentState");
TCHAR g_szDMSegmentStateVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegmentState");
TCHAR g_szDMSegmentStateProgID[]          = TEXT("Microsoft.DirectMusicSegmentState.1");

TCHAR g_szSongFriendlyName[]    = TEXT("DirectMusicSong");
TCHAR g_szSongVerIndProgID[]    = TEXT("Microsoft.DirectMusicSong");
TCHAR g_szSongProgID[]          = TEXT("Microsoft.DirectMusicSong.1");

TCHAR g_szAudioPathFriendlyName[]    = TEXT("DirectMusicAudioPath");
TCHAR g_szAudioPathVerIndProgID[]    = TEXT("Microsoft.DirectMusicAudioPath");
TCHAR g_szAudioPathProgID[]          = TEXT("Microsoft.DirectMusicAudioPath.1");

TCHAR g_szDMGraphFriendlyName[]    = TEXT("DirectMusicGraph");
TCHAR g_szDMGraphVerIndProgID[]    = TEXT("Microsoft.DirectMusicGraph");
TCHAR g_szDMGraphProgID[]          = TEXT("Microsoft.DirectMusicGraph.1");

TCHAR g_szDMSeqTrackFriendlyName[]    = TEXT("DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackProgID[]          = TEXT("Microsoft.DirectMusicSeqTrack.1");

TCHAR g_szDMSysExTrackFriendlyName[]    = TEXT("DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackProgID[]          = TEXT("Microsoft.DirectMusicSysExTrack.1");

TCHAR g_szDMTempoTrackFriendlyName[]    = TEXT("DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackProgID[]          = TEXT("Microsoft.DirectMusicTempoTrack.1");

TCHAR g_szDMTimeSigTrackFriendlyName[]    = TEXT("DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackProgID[]          = TEXT("Microsoft.DirectMusicTimeSigTrack.1");

TCHAR g_szMarkerTrackFriendlyName[]    = TEXT("DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackProgID[]          = TEXT("Microsoft.DirectMusicMarkerTrack.1");

TCHAR g_szWaveTrackFriendlyName[]    = TEXT("DirectMusicWaveTrack");
TCHAR g_szWaveTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicWaveTrack");
TCHAR g_szWaveTrackProgID[]          = TEXT("Microsoft.DirectMusicWaveTrack.1");

TCHAR g_szSegTriggerTrackFriendlyName[]    = TEXT("DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackProgID[]          = TEXT("Microsoft.DirectMusicSegTriggerTrack.1");

TCHAR g_szLyricsTrackFriendlyName[]    = TEXT("DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackProgID[]          = TEXT("Microsoft.DirectMusicLyricsTrack.1");

TCHAR g_szParamControlTrackFriendlyName[]    = TEXT("DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackProgID[]          = TEXT("Microsoft.DirectMusicParamControlTrack.1");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicPerformance)
    {
        dwTypeID = CLASS_PERFORMANCE;
    }
    else if(clsid == CLSID_DirectMusicSegment) 
    {
        dwTypeID = CLASS_SEGMENT;
    }
    else if(clsid == CLSID_DirectMusicSong) 
    {
        dwTypeID = CLASS_SONG;
    }
    else if(clsid == CLSID_DirectMusicAudioPathConfig) 
    {
        dwTypeID = CLASS_AUDIOPATH;
    }
    else if(clsid == CLSID_DirectMusicSeqTrack) 
    {
        dwTypeID = CLASS_SEQTRACK;
    }
    else if(clsid == CLSID_DirectMusicGraph) 
    {
        dwTypeID = CLASS_GRAPH;
    }
    else if(clsid == CLSID_DirectMusicSysExTrack) 
    {
        dwTypeID = CLASS_SYSEXTRACK;
    }
    else if(clsid == CLSID_DirectMusicTempoTrack) 
    {
        dwTypeID = CLASS_TEMPOTRACK;
    }
    else if(clsid == CLSID_DirectMusicTimeSigTrack) 
    {
        dwTypeID = CLASS_TIMESIGTRACK;
    }
    else if(clsid == CLSID_DirectMusicMarkerTrack) 
    {
        dwTypeID = CLASS_MARKERTRACK;
    }
    else if(clsid == CLSID_DirectMusicWaveTrack) 
    {
        dwTypeID = CLASS_WAVETRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        dwTypeID = CLASS_TRIGGERTRACK;
    }
    else if(clsid == CLSID_DirectMusicLyricsTrack)
    {
        dwTypeID = CLASS_LYRICSTRACK;
    }
    else if(clsid == CLSID_DirectMusicParamControlTrack)
    {
        dwTypeID = CLASS_PARAMSTRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentState)
    {
        dwTypeID = CLASS_SEGSTATE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    UnregisterServer(CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    UnregisterServer(CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    UnregisterServer(CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    UnregisterServer(CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);
    
    UnregisterServer(CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    UnregisterServer(CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    UnregisterServer(CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    UnregisterServer(CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    UnregisterServer(CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);

    UnregisterServer(CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);

    UnregisterServer(CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);

    UnregisterServer(CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);

    UnregisterServer(CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);

    UnregisterServer(CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                g_fInitCS = false;
                try
                {
                    InitializeCriticalSection(&g_CritSec);
                    InitializeCriticalSection(&WaveItem::st_WaveListCritSect);
                }
                catch( ... )
                {
                    TraceI(0, "InitializeCriticalSection failed.\n");
                    return FALSE;
                }
                g_fInitCS = true;

                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(1, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                if (g_fInitCS)
                {
                    DeleteCriticalSection(&g_CritSec);
                    DeleteCriticalSection(&WaveItem::st_WaveListCritSect);
                }

                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmsegobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSEGMENTOBJECT_H_
#define __DIRECTMUSICSEGMENTOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"

#include "TrkList.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "..\shared\dmusicp.h"

#define COMPOSE_TRANSITION1 (DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CSegment;

DEFINE_GUID(IID_CSegment,0xb06c0c21, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegment
class CSegment : 
	public IDirectMusicSegment8,
	public IDirectMusicSegment8P,
	public IPersistStream,
	public IDirectMusicObject,
    public AListItem,
    public IDirectMusicObjectP
{
friend class CPerformance;
friend class CSegState;
friend class CSong;
public:
	CSegment();
    CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource);
	~CSegment();
    CSegment* GetNext() { return (CSegment*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSegment
    STDMETHODIMP GetLength(MUSIC_TIME *pmtLength);
    STDMETHODIMP SetLength(MUSIC_TIME pmtLength);
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
    STDMETHODIMP SetRepeats(DWORD dwRepeats);
    STDMETHODIMP GetDefaultResolution(DWORD *pdwResolution);
    STDMETHODIMP SetDefaultResolution(DWORD dwResolution);
    STDMETHODIMP GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex,IDirectMusicTrack **ppTrack);
    STDMETHODIMP GetTrackGroup(IDirectMusicTrack* pTrack,DWORD* pdwGroupBits);
    STDMETHODIMP InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits);
    STDMETHODIMP RemoveTrack(IDirectMusicTrack *pTrack);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState **ppSegState,IDirectMusicPerformance *pPerformance,DWORD dwFlags);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
	STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,
                    DWORD dwIndex,MUSIC_TIME mtTime, 
				    MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits, 
				    DWORD dwIndex,MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicSegment** ppSegment);
	STDMETHODIMP GetStartPoint(MUSIC_TIME* pmtStart);
    STDMETHODIMP SetStartPoint(MUSIC_TIME mtStart);
    STDMETHODIMP GetLoopPoints(MUSIC_TIME* pmtStart,MUSIC_TIME* pmtEnd);
    STDMETHODIMP SetLoopPoints(MUSIC_TIME mtStart,MUSIC_TIME mtEnd);
    STDMETHODIMP SetPChannelsUsed(DWORD dwNumPChannels,DWORD* paPChannels);
//  IDirectMusicSegment8 
    STDMETHODIMP SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppIAudioPathConfig);
    STDMETHODIMP Compose(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment,
		IDirectMusicSegment** ppComposedSegment);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);
// IDirectMusicSegment8P
    STDMETHODIMP GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                    DWORD dwStage,       /* Which stage in the path. */
                                    DWORD dwBuffer,
                                    REFGUID guidObject,  /* ClassID of object. */
                                    DWORD dwIndex,       /* Which object of that class. */
                                    REFGUID iidInterface,/* Requested COM interface. */
                                    void ** ppObject) ; /* Pointer to interface. */
    STDMETHODIMP GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority);       /* Priority to set. */
    STDMETHODIMP SetAudioPathConfig(
        IUnknown *pAudioPathConfig);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	HRESULT GetPChannels( DWORD* pdwNumPChannels, DWORD** ppaPChannels );
	HRESULT CheckNotification( REFGUID );

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags) ;
    HRESULT AddNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    HRESULT RemoveNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    BOOL IsTempoSource();	
    HRESULT CreateSegmentState(CSegState **ppSegState,CPerformance *pPerformance, 
        IDirectMusicAudioPath *pAudioPath, DWORD dwFlags); 
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack * GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck);
    HRESULT GetTrackByParam(REFGUID rgCommandGuid,DWORD dwGroupBits,
        DWORD dwIndex,IDirectMusicTrack **ppTrack);
	HRESULT LoadDirectMusicSegment(IStream* pIStream);	
	void AddNotificationTypeToAllTracks( REFGUID rguidNotification );
	void RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification );
	CNotificationItem* FindNotification( REFGUID rguidNotification );
	HRESULT LoadTrack(CRiffParser *pParser);
	HRESULT CreateTrack(DMUS_IO_TRACK_HEADER& ioDMHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream);
    HRESULT InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits, DWORD dwFlags, DWORD dwPriority, DWORD dwPosition);
	HRESULT LoadGraph(CRiffParser *pParser,CGraph **ppGraph);
    HRESULT LoadAudioPath(IStream *pStream);
	HRESULT ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc);
    void Init();
    HRESULT ComposeTransition(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment);
    HRESULT ComposeInternal();
	HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
	HRESULT SetFlags(DWORD dwFlags);
    void Clear(bool fZombie);
    HRESULT MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime);
    HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime);

// Attributes
protected:
    CRITICAL_SECTION    m_CriticalSection;
	DWORD	            m_dwRepeats;	// # of times to repeat the segment. 0xffffffff is infinite
	DWORD	            m_dwResolution; // the default resolution to start motifs and such.
    DWORD               m_dwSegFlags;   // Flags loaded in with segment. 
	CTrackList	        m_TrackList;	// list of Tracks held in this Segment
    CAudioPathConfig*   m_pAudioPathConfig; // Optional audio path loaded from file. 
    CGraph*	            m_pGraph;       // Optional tool graph for segment.
	CNotificationList	m_NotificationList;
    REFERENCE_TIME      m_rtLength;     // Optional length in reference time units. 
	MUSIC_TIME	        m_mtLength;
	MUSIC_TIME	        m_mtStart;
	MUSIC_TIME	        m_mtLoopStart;
	MUSIC_TIME	        m_mtLoopEnd;
	DWORD	            m_dwNumPChannels;
	DWORD*	            m_paPChannels;
	long                m_cRef;
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?

    bool                m_fZombie;

public:
    DWORD               m_dwLoadID;     // Identifier, used when loaded as part of a song.
    CSong*              m_pSong;        // Optional parent song that segment belongs to. This is not AddRef'd.
    DWORD               m_dwPlayID;     // ID of segment, if within a song.
    DWORD               m_dwNextPlayID; // ID of next segment, if within a song.
    DWORD               m_dwNextPlayFlags; // DMUS_SEGF flags for playing next segment, if within a song.
    BOOL                m_fPlayNext;    // Whether the next segment should be played.
};

class CSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CSegment* pSegment) { AList::AddHead((AListItem*)pSegment);}
    void Insert(CSegment* pSegment);
    BOOL IsMember(CSegment *pSegment) { return AList::IsMember((AListItem*)pSegment);}
    CSegment* GetHead(){return (CSegment*)AList::GetHead();}
    CSegment* GetItem(LONG lIndex){return (CSegment*)AList::GetItem(lIndex);}
    CSegment* RemoveHead() {return (CSegment *) AList::RemoveHead();}
    void Remove(CSegment* pSegment){AList::Remove((AListItem*)pSegment);}
    void AddTail(CSegment* pSegment){AList::AddTail((AListItem*)pSegment);}
    CSegment* GetTail(){ return (CSegment*)AList::GetTail();}
};


#endif //__DIRECTMUSICSEGMENTOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmsstobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __DIRECTMUSICSEGMENTSTATEOBJECT_H_
#define __DIRECTMUSICSEGMENTSTATEOBJECT_H_

#include "dmusici.h"
#include "TrkList.h"
#include "alist.h"
#include "audpath.h"

class CPerformance;
class CSegState;
class CGraph;

// Control flags, placed in track->m_dwInternalFlags by ManageControllingTracks().

#define CONTROL_PLAY_IS_DISABLED       0x1   // Indicates the track is already disabled.
#define CONTROL_PLAY_WAS_DISABLED      0x2   // Indicates the track was previously disabled.
#define CONTROL_PLAY_REFRESH           0x4   // Indicates it has been reenabled and needs to be refreshed.
#define CONTROL_PLAY_DEFAULT_DISABLED  0x8   // Indicates it was disabled for playback anyway.
#define CONTROL_PLAY_DEFAULT_ENABLED   0x10  // Indicates it was enabled for playback.

#define CONTROL_NTFY_IS_DISABLED       0x20  // Indicates the track is already disabled for notifications.
#define CONTROL_NTFY_DEFAULT_DISABLED  0x40  // Indicates it was disabled for notifications anyway.
#define CONTROL_NTFY_DEFAULT_ENABLED   0x80  // Indicates it was enabled for notifications.

DEFINE_GUID(IID_CSegState,0xb06c0c26, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegState
class CSegState : 
	public IDirectMusicSegmentState8,
	public IDirectMusicGraph,
    public AListItem
{
friend class CSegment;
friend class CAudioPath;
friend class CPerformance;
public:
	CSegState();
	~CSegState();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicSegmentState
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
	STDMETHODIMP GetSegment(IDirectMusicSegment **ppSegment);
    STDMETHODIMP GetStartTime(MUSIC_TIME __RPC_FAR *);
	STDMETHODIMP Play(MUSIC_TIME mtAmount,MUSIC_TIME *pmtPlayed); // No longer supported.
    STDMETHODIMP GetSeek(MUSIC_TIME *pmtSeek);
	STDMETHODIMP GetStartPoint(MUSIC_TIME *pmtStart);
	STDMETHODIMP Flush(MUSIC_TIME mtTime);
    // IDirectMusicSegmentState8 
    STDMETHODIMP SetTrackConfig( REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);

    // IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    // Methods used by performance to access SegmentState.
	HRESULT PrivateInit(CSegment *pParentSegment,CPerformance *pPerformance);
    HRESULT InitRoute(IDirectMusicAudioPath *pAudioPath);
    HRESULT ShutDown(void); // called from ~SEGSTNODE in dmperf.h
	HRESULT GetTrackList(void** ppTrackList);
    HRESULT SetSeek(MUSIC_TIME mtSeek,DWORD dwPlayFlags);
    HRESULT SetInvalidate(MUSIC_TIME mtTime);
	MUSIC_TIME GetEndTime(MUSIC_TIME mtStartTime);
	HRESULT ConvertToSegTime(MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat);
	HRESULT AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn ); // called when the segstate is stopped prematurely
	HRESULT CheckPlay( MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult );
    HRESULT Play(MUSIC_TIME mtAmount);  
    HRESULT GetParam( CPerformance *pPerf,REFGUID rguidType,DWORD dwGroupBits,
        DWORD dwIndex,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pParam);	

    CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}
private:
    CTrack *GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
	void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime );
	void SendDirtyPMsg( MUSIC_TIME mtTime );
public:
// Attributes
    CRITICAL_SECTION            m_CriticalSection;
	IUnknown*					m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
	CPerformance*	            m_pPerformance;
	CSegment*		            m_pSegment;     // Holds the parent segment pointer, weak reference, for convenience
    CAudioPath*                 m_pAudioPath;   // Maps vchannels to pchannels, if requested.
    CGraph*                     m_pGraph;       // Temp graph is a copy of the segment's graph.
    CTrackList	                m_TrackList;	// list of Tracks held in this SegmentState
    MUSIC_TIME					m_mtLoopStart;  // Loop start point.
	MUSIC_TIME					m_mtLoopEnd;    // Loop end point.
	DWORD						m_dwRepeats;    // The original repeat setting (before countdown)
	MUSIC_TIME					m_mtLength;     // Length of segment.
	DWORD						m_dwPlayTrackFlags;// Track playback controlflags.
    DWORD						m_dwPlaySegFlags;// Segment playback control flags.
    DWORD                       m_dwSegFlags;   // New Segment Flags from file.
    MUSIC_TIME					m_mtResolvedStart;// Start time resolved to desired resolution
	MUSIC_TIME					m_mtEndTime;    // End time that the segment should play to if not stopped. 
	MUSIC_TIME					m_mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME					m_mtLastPlayed; // the last played absolute time
	MUSIC_TIME					m_mtStopTime;     // Used to stop play at a specific time. Ignored when 0.
	MUSIC_TIME					m_mtSeek;       // How far into the segment we are.
	MUSIC_TIME					m_mtStartPoint; // Point in the segment where playback started
    MUSIC_TIME                  m_mtAbortTime;  // Time a sudden stop occured.
	REFERENCE_TIME				m_rtGivenStart; // Start time given in PlaySegment, unquantized
    REFERENCE_TIME              m_rtLastPlayed; // Clock time version of the last played absolute time
	REFERENCE_TIME				m_rtStartPoint; // Clock time version of point in the segment where playback started
	REFERENCE_TIME				m_rtOffset;     // Clock time version of start time of the segment in absolute time, as if it were started from the beginning. 
    REFERENCE_TIME              m_rtEndTime;    // Clock time version of full length.
    REFERENCE_TIME				m_rtSeek;       // Clock time version of how far into the segment we are.
    REFERENCE_TIME              m_rtLength;     // Clock time length, read from file. If 0, ignore.
    REFERENCE_TIME              m_rtFirstLoopStart; // The clock time for the loop start when it starts looping the VERY FIRST time 
    REFERENCE_TIME              m_rtCurLoopStart;// The clock time for the loop start for the current loop repetition
    REFERENCE_TIME              m_rtCurLoopEnd; // The clock time for the loop end in the current loop repetition
    DWORD						m_dwRepeatsLeft;// Current repeats left.
	BOOL						m_fStartedPlay; // indicates if the segstate has started to play yet
    DWORD                       m_dwVersion;    // Which release does the app think it is using - 6, 7, or 8..
    DWORD                       m_dwFirstTrackID;// Virtual ID of first track in segstate.
    DWORD                       m_dwLastTrackID;// Last track's virtual id.
    BOOL                        m_fPrepped;     // Used to track whether PrepSegToPlay has been called.
    BOOL                        m_fSongMode;    // True if part of a playing song. If so, this should queue the next segment when done.
	BOOL						m_fCanStop;		// If false, Stop() should ignore this segment (it was just queued to play by PlaySegmentEx().)
    BOOL                        m_fInPlay;      // Segmentstate is currently playing.   
    BOOL                        m_fDelayShutDown;
    CSegState *                 m_pSongSegState;// Used to track the starting segstate in a song.
    long						m_cRef;         // COM reference counter.
};

class CSegStateList : public AList
{
public:
    void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}
    void Insert(CSegState* pSegState);
    CSegState* GetHead(){return (CSegState*)AList::GetHead();}
    CSegState* GetItem(LONG lIndex){return (CSegState*)AList::GetItem(lIndex);}
    CSegState* RemoveHead() {return (CSegState *) AList::RemoveHead();}
    void Remove(CSegState* pSegState){AList::Remove((AListItem*)pSegState);}
    void AddTail(CSegState* pSegState){AList::AddTail((AListItem*)pSegState);}
    CSegState* GetTail(){ return (CSegState*)AList::GetTail();}
    void SetID(DWORD dwID) { m_dwID = dwID; }
    DWORD GetID() { return m_dwID; }
private:
    DWORD       m_dwID;         // Identifies which segstate list this is.
};

#endif //__DIRECTMUSICSEGMENTSTATEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmsstobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsstobj.cpp : Implementation of CSegState

#include "dmime.h"
#include "DMSStObj.h"
#include "dmsegobj.h"
#include "song.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "paramtrk.h"
#define ASSERT assert

CSegState::CSegState()
{
    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
    m_fDelayShutDown = false;
    m_fInPlay = false;
    m_cRef = 1;
    m_dwPlayTrackFlags = DMUS_TRACKF_START | DMUS_TRACKF_SEEK;
    m_dwFirstTrackID = 0;
    m_dwLastTrackID = 0;
    m_mtEndTime = 0;
    m_mtAbortTime = 0;
    m_mtOffset = 0;
    m_rtOffset = 0;
    m_rtEndTime = 0;
    m_mtStartPoint = 0;
    m_rtStartPoint = 0;
    m_mtSeek = 0;
    m_rtSeek = 0;
    m_rtFirstLoopStart = 0;
    m_rtCurLoopStart = 0;
    m_rtCurLoopEnd = 0;
    m_mtLength = 0;
    m_rtLength = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_dwRepeatsLeft = 0;
    m_dwRepeats = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_fPrepped = FALSE;
    m_fCanStop = TRUE;
    m_rtGivenStart = -1;
    m_mtResolvedStart = -1;
    m_mtLastPlayed = 0;
    m_rtLastPlayed = 0;
    m_mtStopTime = 0;
    m_dwPlaySegFlags = 0;
    m_dwSegFlags = 0;
    m_fStartedPlay = FALSE;
    m_pUnkDispatch = NULL;
    m_pSegment = NULL;
    m_pPerformance = NULL;
    m_pAudioPath = NULL;
    m_pGraph = NULL;
    m_fSongMode = FALSE;
    m_pSongSegState = NULL;
    TraceI(2, "SegmentState %lx created\n", this );
}

CSegState::~CSegState()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    if (m_pAudioPath) m_pAudioPath->Release();
    if (m_pGraph) m_pGraph->Release();
    if (m_pSongSegState) m_pSongSegState->Release();
    InterlockedDecrement(&g_cComponent);
    DeleteCriticalSection(&m_CriticalSection);
    TraceI(2, "SegmentState %lx destroyed with %ld releases outstanding\n", this, m_cRef );
}


STDMETHODIMP CSegState::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegState::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegmentState || 
        iid == IID_IDirectMusicSegmentState8)
    {
        *ppv = static_cast<IDirectMusicSegmentState*>(this);
    } else
    if (iid == IID_CSegState)
    {
        *ppv = static_cast<CSegState*>(this);
    } else 
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegmentState,
                static_cast<IDirectMusicSegmentState*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on SegmentState object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CSegState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegState::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
  Private initialization function called by IDirectMusicSegment to set this
  state object's parent segment and performance. Addref's the parent segment
  but only retains a weak reference to the performance.
*/
HRESULT CSegState::PrivateInit(
    CSegment *pParentSegment,
    CPerformance *pPerformance)
{
    HRESULT hr = S_OK;
    ASSERT(pParentSegment);
    ASSERT(pPerformance);

    m_pSegment = pParentSegment;
    pParentSegment->AddRef();
    m_pPerformance = pPerformance; // retain only a weak reference
    m_rtLength = pParentSegment->m_rtLength;
    if (m_rtLength) // It's a ref time segment, so convert the length to music time
    {
        pParentSegment->ReferenceToMusicTime(m_rtLength, &m_mtLength);
    }
    else
    {
        m_mtLength = pParentSegment->m_mtLength;
    }
    m_mtStartPoint = pParentSegment->m_mtStart;
    pParentSegment->MusicToReferenceTime(m_mtStartPoint, &m_rtStartPoint);
    m_mtLoopStart = pParentSegment->m_mtLoopStart;
    m_mtLoopEnd = pParentSegment->m_mtLoopEnd;
    m_dwSegFlags = pParentSegment->m_dwSegFlags;
    m_dwRepeats = pParentSegment->m_dwRepeats;
    // Don't allow repeat count to overflow and cause mathematical errors. 
    // Make it so it can't create a segment length larger than 0x3FFFFFFF, 
    // which would last for 8 days at 120 bpm!
    if (m_dwRepeats)
    {
        if ((m_mtLoopEnd == 0) && (m_mtLoopStart == 0))
        {
            // This happens when loading waves and MIDI files. 
            m_mtLoopEnd = m_mtLength;
        }
        // Make sure the loop is real.
        if (m_mtLoopEnd > m_mtLoopStart)
        {
            // Take the maximum length, subtract out the full length, then divide by the loop size.
            DWORD dwMax = (0x3FFFFFFF - m_mtLength) / (m_mtLoopEnd - m_mtLoopStart);
            // dwMax is the maximum number of loops that can be done without overflowing the time.
            if (m_dwRepeats > dwMax)
            {
                m_dwRepeats = dwMax;
            }
        }
        else
        {
            m_dwRepeats = 0;
        }
    }
    m_dwRepeatsLeft = m_dwRepeats;
    if( m_mtLoopEnd == 0 )
    {
        m_mtLoopEnd = m_mtLength;
    }
    if( m_mtStartPoint >= m_mtLoopEnd )
    {
        // in this case, we're not doing any looping.
        m_mtLoopEnd = m_mtLoopStart = 0;
        m_dwRepeats = m_dwRepeatsLeft = 0;
    }
    return hr;
}

HRESULT CSegState::InitRoute(IDirectMusicAudioPath *pAudioPath)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    if (pAudioPath)
    {
        if (m_dwVersion < 8) m_dwVersion = 8;
        m_pAudioPath = (CAudioPath *) pAudioPath;
        pAudioPath->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/*
  This is called from the performance when it wants to release a
  segmentstate. This ensures that the segstate is
  no longer valid once outside the Performance.
*/
HRESULT CSegState::ShutDown(void)
{
    if (this)
    {
        if (m_fInPlay)
        {
            m_fDelayShutDown = true;
            return S_OK;
        }
        EnterCriticalSection(&m_CriticalSection);
        m_TrackList.Clear();
        if( m_pSegment )
        {
            m_pSegment->Release();
            m_pSegment = NULL;
        }
        if( m_pAudioPath)
        {
            m_pAudioPath->Release();
            m_pAudioPath = NULL;
        }
        if (m_pSongSegState)
        {
            m_pSongSegState->Release();
            m_pSongSegState = NULL;
        }
        m_pPerformance = NULL;
        LeaveCriticalSection(&m_CriticalSection);
        if( int nCount = Release() )
        {
            TraceI( 2, "Warning! SegmentState %lx still referenced %d times after Performance has released it.\n", this, nCount );
        }

        return S_OK;
    }
    TraceI(0,"Attempting to delete a NULL SegmentState!\n");
    return E_FAIL;
}

/*
  Retrieve the internal track list. Used by IDirectMusicSegment.
*/
HRESULT CSegState::GetTrackList(
    void** ppTrackList)
{
    ASSERT(ppTrackList);
    *ppTrackList = (void*)&m_TrackList;
    return S_OK;
}

/*
  Computes the length of the segmentstate using the internal length, loop points,
  and repeat count. This is the length of the segstate that will actually play,
  not necessarily the length if it played from the beginning.
*/
MUSIC_TIME CSegState::GetEndTime(MUSIC_TIME mtStartTime)
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_rtLength && m_pPerformance)
    {
        // If there is a reference time length, convert it into Music Time.
        // ALSO: convert m_mtLength and re-adjust loop points.
        MUSIC_TIME mtOffset = m_mtResolvedStart;
        REFERENCE_TIME rtOffset = 0;
        m_pPerformance->MusicToReferenceTime(mtOffset, &rtOffset);
        REFERENCE_TIME rtEndTime = (m_rtLength - m_rtStartPoint) + rtOffset; // Convert from length to actual end time.
        m_pPerformance->ReferenceToMusicTime(rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - mtOffset + m_mtStartPoint;
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength ) // shrink loop end to equal length
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    LONGLONG length;
    length = m_mtLength + ((m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats);
    length -= m_mtStartPoint;
    length += mtStartTime;
    if(length > 0x7fffffff) length = 0x7fffffff;
    return (MUSIC_TIME)length;
}

/*
  Converts an absolute Performance time to the index into the SegmentState, using
  the SegmentState's offset, internal length, loop points, and repeat count.
  Also returns the offset and repeat count for that time.
*/
HRESULT CSegState::ConvertToSegTime(
    MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat )
{
    ASSERT( pmtTime );
    ASSERT( pmtOffset );
    ASSERT( pdwRepeat );

    MUSIC_TIME mtPos = *pmtTime - m_mtResolvedStart + m_mtStartPoint;
    MUSIC_TIME mtLoopLength = m_mtLoopEnd - m_mtLoopStart;
    DWORD dwRepeat = 0;
    DWORD mtOffset = m_mtResolvedStart - m_mtStartPoint;

    while( mtPos >= m_mtLoopEnd )
    {
        if( dwRepeat >= m_dwRepeats ) break;
        mtPos -= mtLoopLength;
        mtOffset += mtLoopLength;
        dwRepeat++;
    }
    *pmtTime = mtPos;
    *pmtOffset = mtOffset;
    *pdwRepeat = dwRepeat;
    if( (mtPos >= 0) && (mtPos < m_mtLength) )
    {
        return S_OK;    // time is in range of the Segment
    }
    else
    {
        return S_FALSE; // time is out of range of the Segment
    }
}

void CSegState::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime )
{
    GUID guid;
    HRESULT hr;
    guid = GUID_NOTIFICATION_SEGMENT;

    hr = m_pSegment->CheckNotification( guid );

    if( S_FALSE != hr )
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_SEGMENT;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->punkUser = (IUnknown*)(IDirectMusicSegmentState*)this;
            AddRef();
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(m_pPerformance->SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                m_pPerformance->FreePMsg((DMUS_PMSG*) pEvent );
            }
        }
    }
}

/* 
  Called to send the tools in the tool graph a dirty pmsg so they update any
  cached GetParam() info.
*/
void CSegState::SendDirtyPMsg( MUSIC_TIME mtTime )
{
    DMUS_PMSG* pEvent = NULL;
    if (m_pPerformance)
    {
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwType = DMUS_PMSGT_DIRTY;
            StampPMsg((DMUS_PMSG*)pEvent);
            if( FAILED( m_pPerformance->SendPMsg( pEvent )))
            {
                m_pPerformance->FreePMsg( pEvent );
            }
        }
    }
}

/*
  Called when the SegState is stopped prematurely, so we can send a SEGABORT
  Notification.
  Also, flushes all events that were sent after the stop time. 
*/
HRESULT CSegState::AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn )
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        if( m_mtLastPlayed > mtTime )
        {
            // If we've played past the abort time, we need to flush messages. 
            // Note that if we were aborted by playing another segment that had
            // the DMUS_SEGF_NOINVALIDATE flag set, don't truncate notes
            // that are currently on.
            CTrack* pTrack;
            pTrack = m_TrackList.GetHead();
            while( pTrack )
            {
                m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, fLeaveNotesOn );
                pTrack = pTrack->GetNext();
            }
            m_mtLastPlayed = mtTime;
        }
        // Always fill in the updated value for lastplayed so the ShutDown or Done queue will flush this
        // at the right time.
        m_pPerformance->MusicToReferenceTime(mtTime,&m_rtLastPlayed);
    }
    LeaveCriticalSection(&m_CriticalSection);
    // Always generate an abort for a segment that has not started playing yet. 
    if (m_fStartedPlay && (m_mtEndTime <= mtTime))
    {
        return S_FALSE; // Abort was too late to matter.
    }
    if (m_mtAbortTime)  // Previous abort.
    {
        if (m_mtAbortTime <= mtTime) // Is this earlier?
        {
            return S_FALSE;     // No, don't send abort message.
        }
    }
    m_mtAbortTime = mtTime;
    // Find all the parameter control tracks and invalidate any parameter envelopes
    // that need invalidation.
    CTrack* pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        if (pTrack->m_guidClassID == CLSID_DirectMusicParamControlTrack)
        {
            CParamControlTrack* pParamTrack = NULL;
            if (pTrack->m_pTrack &&
                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_CParamControlTrack, (void**)&pParamTrack)))
            {
                pParamTrack->OnSegmentEnd(m_rtLastPlayed, pTrack->m_pTrackState);
                pParamTrack->Release();
            }
        }
        pTrack = pTrack->GetNext();
    }
    GenerateNotification( DMUS_NOTIFICATION_SEGABORT, mtTime );
    // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
    if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
    {
        TraceI(4, "Send Dirty PMsg [4] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
        SendDirtyPMsg( m_mtOffset + m_mtSeek );
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState

//////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetRepeats
/*
@method HRESULT | IDirectMusicSegmentState | GetRepeats |
Returns the number of times the SegmentState is set to repeat. A value of zero indicates
to play through only once (no repeats.) This value remains constant throughout the life
of the SegmentState.

@rvalue E_POINTER | if <p pdwRepeats> is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetRepeats( 
    DWORD *pdwRepeats)  // @parm Returns the repeat count.
{
    V_INAME(IDirectMusicSegmentState::GetRepeats);
    V_PTR_WRITE(pdwRepeats,DWORD);

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSegment
/*
@method HRESULT | IDirectMusicSegmentState | GetSegment |
Returns a pointer to the Segment that owns this SegmentState.

@rvalue E_POINTER | if ppSegment is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetSegment( 
    IDirectMusicSegment **ppSegment)    // @parm The Segment interface pointer to this
                                        // SegmentState. Call Release() on this pointer when
                                        // through.
{
    V_INAME(IDirectMusicSegmentState::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    *ppSegment = (IDirectMusicSegment *) m_pSegment;
    if( m_pSegment )
    {
        m_pSegment->AddRef();
    }
    else
    {
        Trace(1,"Error: Segmentstate doesn't have an associated segment.\n");
        return DMUS_E_NOT_FOUND;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::Play
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | Play |
<om IDirectMusicSegmentState.Play> is called regularly by the Performance object, 
usually every 200 ms or so, at a time ahead of playback that is set by 
<om IDirectMusicPerformance.SetPerformTime>
.
parm MUSIC_TIME | mtAmount |
    [in] The length of time to play, starting at the current Seek time.
    The SegmentState updates its Seek time to be the current Seek time
    plus mtAmount. Therefore, the SegmentState should play from the current
    Seek time to Seek time plus mtAmount, not including the last clock.

comm 
Play calls each Track's Play method in priority order, instructing the Track to 
create events from the current Seek time up to, but not including the current Seek
time plus <p mtAmount.>
Since the Segment started at the point designated by m_mtOffset (set by
<im IDirectMusicSegmentState.SetOffset>
m_mtOffset sets the starting offset to add to the times of all events.

rvalue E_INVALIDARG | mtAmount <= 0
rvalue S_OK | Success.
*/

HRESULT STDMETHODCALLTYPE CSegState::Play( 
    /* [in] */ MUSIC_TIME mtAmount, MUSIC_TIME* pmtPlayed )
{
    return E_FAIL;      // We don't want to support this publicly!
}

HRESULT CSegState::Play( MUSIC_TIME mtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount = mtAmount;
    REFERENCE_TIME rtMyAmount;
    HRESULT hr = DMUS_S_END;
    BOOL fUseClockTime = FALSE;

    if( mtAmount <= 0 )
        return E_INVALIDARG;

    EnterCriticalSection(&m_CriticalSection);
    if (m_fInPlay)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

        m_rtFirstLoopStart = 0;
    }
    if (m_rtLength)
    {
        // If there is a reference time length, convert it into mtTime.
        // Because there's always the danger of a tempo change, we do this every
        // time. It doesn't require the tight precision that song time
        // requires, so that's okay.
        // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
        m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - m_mtOffset; 
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength )
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
        
        //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;

        fUseClockTime = TRUE;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - m_mtSeek;
        }
    }
    else 
    {
        if (fUseClockTime)
        {
            if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
            {
                mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
            }
        }
        else if( mtMyAmount > m_mtLength - m_mtSeek )
        {
            mtMyAmount = m_mtLength - m_mtSeek;
        }
    }
    if (mtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // check the primary segment queue for a segment that might begin 
        // before mtMyAmount is up
        MUSIC_TIME mtNextPri;
        if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))
        {
            if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )
            {
                mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;
            }
        }
        TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
        
        // find out if there's a control segment interrupting this period of time.
        MUSIC_TIME mtControlSeg;
        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
        {
            if( m_mtOffset + m_mtSeek == mtControlSeg )
            {
                // we're at the beginning of a new control seg, so tell the tracks
                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
            }
            else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )
            {
                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
            }
        }
        // Now that mtMyAmount is calculated for how far to play in music time,
        // create the equivalent value in reference time.
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( mtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) {
                            EnterCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, set time variables appropriately.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        else
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }

                        if (m_pSegment) {
                            LeaveCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                    }
                    else
                    {
                        if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
                            m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                            m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                        {
                            hr = S_OK; // if even one track isn't done playing,
                            // keep going
                        }
                        else
                        {
                            pCTrack->m_bDone = TRUE;
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // And if this is the first repeat
                if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)
                {
                    // If we're playing the loop start remember it's reftime value
                    if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)
                    {
                        m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);
                        m_rtFirstLoopStart -= m_rtStartPoint;
                        m_rtCurLoopStart = m_rtFirstLoopStart;
                    }
                }

                // take into account repeats if necessary
                if( m_mtSeek >= m_mtLoopEnd )
                {
                    // Remember the current loop end
                    m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);
                    m_rtCurLoopEnd -= m_rtStartPoint;

                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        m_mtSeek = m_mtLoopStart;
                        m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);
                        
                        
                        m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

                        m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);
                   
                        m_rtCurLoopStart = m_rtCurLoopEnd;

                        if( mtMyAmount < mtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            mtMyAmount = mtAmount - mtMyAmount;
                            mtAmount = mtMyAmount;
                            // if we need to do a loop or the end is near, restrict mtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLoopEnd - m_mtSeek;
                                }
                            }
                            else 
                            {
                                if (fUseClockTime)
                                {
                                    if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
                                    {
                                        mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
                                    }
                                }
                                else if( mtMyAmount > m_mtLength - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLength - m_mtSeek;
                                }
                            }
                        }
                        // send a segment looped notification
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );
                        // find out if there's a control segment interrupting this period of time
                        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
                        {
                            if( m_mtOffset + m_mtSeek == mtControlSeg ) 
                            {
                                // we're at the beginning of a new control seg, so tell the tracks
                                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 
                            }
                            else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )
                            {
                                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
                            }
                        }
                        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
                        rtMyAmount -= m_rtLastPlayed;
                    }
                    else if( m_mtSeek == m_mtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // If this is part of a song, we need to queue the next segment.
        if (m_fSongMode)
        {
            if (m_pSegment)
            {
                CSong *pSong = m_pSegment->m_pSong;
                if (pSong)
                {
                    // Get the next segment from the song.
                    CSegment *pSegment;
                    if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))
                    {
                        // Now, play it.
                        // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
                        // And, make sure that it plays at the same level (control, secondary, or primary.)
                        CSegState *pCSegState = NULL;
                        CAudioPath *pPath = m_pAudioPath;
                        CAudioPath *pInternalPath = NULL;
                        DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);
                        dwFlags &= ~DMUS_SEGF_REFTIME;
                        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
                        {
                            IUnknown *pConfig;
                            if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))
                            {
                                IDirectMusicAudioPath *pNewPath;
                                if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))
                                {
                                    // Now, get the CAudioPath structure.
                                    pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);
                                    pPath = pInternalPath;
                                }
                                pConfig->Release();
                            }
                        }
                        if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))
                        {
                            if (m_pSongSegState)
                            {
                                // This is not the first, so transfer the segstate pointer.
                                pCSegState->m_pSongSegState = m_pSongSegState;
                                m_pSongSegState = NULL;
                            }
                            else
                            {
                                // This is the first, so have the next segstate point to this.
                                pCSegState->m_pSongSegState = this;
                                AddRef();
                            }
                            pCSegState->m_fSongMode = TRUE;
                            pCSegState->Release();
                        }
                        if (pInternalPath)
                        {
                            pInternalPath->Release();
                        }
                        pSegment->Release();
                    }
                }
            }
        }
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegState::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

/* GetParam() is called by the performance in response to a GetParam() call
   on the performance. This needs the performance pointer so it can handle
   clock time to music time conversion and back, in case the source track is a
   clock time track.
*/

HRESULT CSegState::GetParam(
    CPerformance *pPerf,
    REFGUID rguidType,
    DWORD dwGroupBits,      
    DWORD dwIndex,          
    MUSIC_TIME mtTime,      
    MUSIC_TIME* pmtNext,    
    void* pParam)           
{
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // Even though DX7 didn't support this, this is always safe because an index this high could never happen.
        fMultipleTry = TRUE; 
    }
    CTrack * pTrack = GetTrackByParam( NULL, rguidType, dwGroupBits, dwIndex);
    while (pTrack)
    {
        if (pTrack->m_pTrack8)
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
            {
                REFERENCE_TIME rtTime, rtNext;
                // Convert mtTime into reference time units:
                pPerf->MusicToReferenceTime(m_mtOffset + mtTime,&rtTime);
                rtTime -= m_rtOffset;
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, rtTime, &rtNext, 
                    pParam, pTrack->m_pTrackState, DMUS_TRACK_PARAMF_CLOCK );
                if (pmtNext)
                {
                    if (rtNext == 0) *pmtNext = 0;
                    else
                    {
                        rtNext += m_rtOffset;
                        pPerf->ReferenceToMusicTime(rtNext,pmtNext);
                        *pmtNext -= m_mtOffset;
                    }
                }
            }
            else
            {
                REFERENCE_TIME rtNext, *prtNext;
                // We need to store the next time in a 64 bit pointer. But, don't
                // make 'em fill it in unless the caller requested it. 
                if (pmtNext)
                {
                    prtNext = &rtNext;
                }
                else
                {
                    prtNext = NULL;
                }
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
                    pTrack->m_pTrackState, 0 );
                if (pmtNext)
                {
                    *pmtNext = (MUSIC_TIME) rtNext;
                }
            }
        }
        else
        {
            // This is a pre DX8 track...
            hr = pTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
        }
        if (SUCCEEDED(hr))
        {
            if( pmtNext )
            { 
                if(( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime)))
                {
                    // If no next was found OR it's greater than the end of the segment, set 
                    // it to the end of the segment. 
                    *pmtNext = m_mtLength - mtTime;
                }
            }
            pTrack = NULL;
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        else if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pTrack = GetTrackByParam( pTrack, rguidType, dwGroupBits, 0);
        }
        else
        {
            pTrack = NULL;
        }
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(4,"Warning: Segmentstate::GetParam failed, unable to find a track that supports the requested param.\n");
    }
#endif
    return hr;
}


CTrack *CSegState::GetTrack( 
    REFCLSID rType,     
    DWORD dwGroupBits,  
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_All_Objects == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

STDMETHODIMP CSegState::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, 
                                      DWORD dwFlagsOn, DWORD dwFlagsOff) 
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segmentstate::SetTrackConfig failed, unable to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegState::CheckPlay( 
    MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult )
{
    MUSIC_TIME mtMyAmount = mtAmount;
    MUSIC_TIME mtSeek = m_mtSeek;
    MUSIC_TIME mtOffset = m_mtOffset;

    ASSERT(pmtResult);
    // if this is the first call to play,
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // set the current seek to the start point
        mtSeek = m_mtStartPoint;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
    ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - mtSeek;
        }
    }
    else if( mtMyAmount > m_mtLength - mtSeek )
    {
        mtMyAmount = m_mtLength - mtSeek;
    }
    
    // take into account repeats if necessary
    *pmtResult = mtMyAmount;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartTime
/*
@method HRESULT | IDirectMusicSegmentState | GetStartTime |
Gets the music time this SegmentState started playing.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartTime( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time of the start of this SegmentState.
                            // This is the music time, in Performance time, that the SegmentState
                            // started or will start playing.
{
    V_INAME(IDirectMusicSegmentState::GetStartTime);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtResolvedStart;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartPoint
/*
@method HRESULT | IDirectMusicSegmentState | GetStartPoint |
Calling <om IDirectMusicSegment.SetStartPoint> causes the SegmentState to begin
playing from the middle instead of from the beginning. <om .GetStartPoint>
returns the amount of time from the beginning of the SegmentState that it
plays.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicSegment.SetStartPoint>,
<om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartPoint( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time offset from the start of the
                            // SegmentState at which the SegmentState initially plays.
{
    V_INAME(IDirectMusicSegmentState::GetStartPoint);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtStartPoint;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::SetSeek
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | SetSeek |
Sets the music time Seek maintained by this SegmentState.

parm MUSIC_TIME | mtSeek |
    [in] The music time Seek to store in this SegmentState.

comm The SegmentState passes this Seek value to <im IDirectMusicTrack.Play>
Note that newly created SegmentState's start with a Seek time of 0.
rvalue S_OK | Success.
*/
HRESULT CSegState::SetSeek( 
    MUSIC_TIME mtSeek, DWORD dwPlayFlags)
{
    m_mtSeek = mtSeek;
    m_dwPlayTrackFlags |= dwPlayFlags | DMUS_TRACKF_SEEK;
    return S_OK;
}

/*
Called from IDirectMusicPerformance::Invalidate, this routine helps set
the current seek pointer. Done here instead of directly inside Performance
because it's easier to compute the repeats, etc. here.
*/
HRESULT CSegState::SetInvalidate(
    MUSIC_TIME mtTime) // mtTime is in Performance time
{
    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    DWORD dwFlags = DMUS_TRACKF_FLUSH | DMUS_TRACKF_SEEK;

    HRESULT hr = ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    if( hr != S_OK )
    {
        mtTime = 0;
        m_dwRepeatsLeft = m_dwRepeats;
        m_mtOffset = m_mtResolvedStart;
        dwFlags |= DMUS_TRACKF_START;
    }
    else
    {
        m_dwRepeatsLeft = m_dwRepeats - dwRepeat;
        m_mtOffset = mtOffset;
    }
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        pCTrack->m_bDone = FALSE;
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return SetSeek( mtTime, dwFlags );
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSeek

HRESULT STDMETHODCALLTYPE CSegState::GetSeek( 
    MUSIC_TIME *pmtSeek) // @parm Returns the current seek pointer, which indicates
                        // the next time that will be called inside <om IDirectMusicTrack.Play>.
{
    V_INAME(IDirectMusicSegmentState::GetSeek);
    V_PTR_WRITE(pmtSeek, MUSIC_TIME);

    *pmtSeek = m_mtSeek;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Flush(MUSIC_TIME mtTime) // The time on and after which to flush.
{
    CTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, FALSE );
        pTrack = pTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::StampPMsg( 
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicSegmentState::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }
    HRESULT hr = E_FAIL;
    EnterCriticalSection(&m_CriticalSection);

    if (m_pPerformance) 

    {
        // First, check if the segmentstate has its own graph.
        if (m_pGraph)
        {
            // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
            // If so, we'll treat that as a failure and drop on through to the next graph...
            if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
            {
                if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
                {
                    if( pPMsg->pGraph )
                    {
                        pPMsg->pGraph->Release();
                        pPMsg->pGraph = NULL;
                    }
                    pPMsg->pGraph = this;
                    AddRef();
                }
            }
        }
        // If done with the graph, send to the audio path, if it exists,
        // else the performance. Also, check for the special case of 
        // DMUS_PCHANNEL_BROADCAST_SEGMENT. If so, duplicate the pMsg
        // and send all the copies with the appropriate pchannel values.
        if( FAILED(hr) || (m_dwVersion && (hr == DMUS_S_LAST_TOOL)))
        {
            if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)
            {
                CSegment *pSegment = m_pSegment;
                EnterCriticalSection(&pSegment->m_CriticalSection);
                DWORD dwIndex;
                // Create new messages with new pchannels for all but one, which will
                // be assigned to this message.
                for (dwIndex = 1;dwIndex < pSegment->m_dwNumPChannels;dwIndex++)
                {
                    DWORD dwNewChannel = pSegment->m_paPChannels[dwIndex];
                    // Don't broadcast any broadcast messages!
                    // And, if this is a transpose on the drum channel, don't send it.
                    if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                        ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            HRESULT hrTemp;
                            pNewMsg->dwPChannel = dwNewChannel;
                            if (m_pAudioPath)
                            {
                                hrTemp = m_pAudioPath->StampPMsg(pNewMsg);
                            }
                            else
                            {
                                hrTemp = m_pPerformance->StampPMsg(pNewMsg);
                            }
                            if (SUCCEEDED(hrTemp))
                            {
                                m_pPerformance->SendPMsg(pNewMsg);
                            }
                            else
                            {
                                m_pPerformance->FreePMsg(pNewMsg);
                            }
                        }
                    }
                }
                // Now, set the pchannel for this one. First check that there are any
                // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
                // Also, mark it this way if the PMsg is a broadcast PMsg.
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
                if (pSegment->m_dwNumPChannels)
                {
                    if (pSegment->m_paPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                    {
                        pPMsg->dwPChannel = pSegment->m_paPChannels[0];
                    }
                }
                LeaveCriticalSection(&pSegment->m_CriticalSection);
            }
            if (m_pAudioPath)
            {
                hr = m_pAudioPath->StampPMsg(pPMsg);
            }
            else
            {
                hr = m_pPerformance->StampPMsg(pPMsg);
            }
        }

    }
    else
    {
        hr = DMUS_E_NOT_INIT;
        Trace(1,"Error: Segmentstate::StampPMsg failed because the segmentstate is not properly initialized.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegState::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicSegmentState::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_SEGMENT:
        if (m_pSegment && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pSegment->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_SEGMENT_TRACK:
        if (dwPChannel == 0)
        {
            CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
            if (pCTrack)
            {
                if (pCTrack->m_pTrack)
                {
                    hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
                }
            }
        }
        break;
    case DMUS_PATH_SEGMENT_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_SEGMENT_TOOL:
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    default:
        if (m_pAudioPath)
        {
            hr = m_pAudioPath->GetObjectInPath(dwPChannel,dwStage,dwBuffer,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            Trace(1,"Error: Unable to access audiopath components of segmentstate.\n");
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmprfdll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmprfdll.h
//
// Class factory
//

#ifndef __DMPRFDLL_H_
#define __DMPRFDLL_H_
 
class CClassFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_PERFORMANCE   1
#define CLASS_GRAPH         2
#define CLASS_SEGMENT       3
#define CLASS_SONG          4
#define CLASS_AUDIOPATH     5
#define CLASS_SEQTRACK      6
#define CLASS_SYSEXTRACK    7
#define CLASS_TEMPOTRACK    8
#define CLASS_TIMESIGTRACK  9
#define CLASS_LYRICSTRACK   10
#define CLASS_MARKERTRACK   11
#define CLASS_PARAMSTRACK   12
#define CLASS_TRIGGERTRACK  13
#define CLASS_WAVETRACK     14
#define CLASS_SEGSTATE      15



#endif // __DMPRFDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmsegobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsegobj.cpp : Implementation of CSegment

#include "dmime.h"
#include "DMSegObj.h"
#include "DMSStObj.h"
#include "DMGraph.h"
#include "dmusici.h"
#include "tlist.h"
#include "midifile.h"
#include "dmusicc.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "wavtrack.h"
#include "..\shared\validp.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstyle.h"
#include "..\dmcompos\dmcompp.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "tempotrk.h"
#include <strsafe.h>
#define ASSERT assert

// @doc EXTERNAL

long g_lNewTrackID = 0; // shared by all instances of Segments, this keeps track of the
    // next available TrackID when creating new Track states.

/////////////////////////////////////////////////////////////////////////////
// CSegment

void CSegment::Init()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_pSong = NULL;
    m_dwNextPlayFlags = 0;
    m_dwNextPlayID = 0xFFFFFFFF;
    m_dwPlayID = 0;
//    m_fPartialLoad = FALSE;
    m_mtLength = 1;
    m_mtStart = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_rtLength = 0;
    m_dwRepeats = 0;
    m_dwResolution = 0;
    m_dwNumPChannels = 0;
    m_paPChannels = NULL;
    m_pGraph = NULL;
    m_pAudioPathConfig = NULL;
    m_pUnkDispatch = NULL;
    m_dwSegFlags = 0;
    m_cRef = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_fZombie = false;
    InterlockedIncrement(&g_cComponent);
    TraceI(2, "Segment %lx created\n", this );
}

CSegment::CSegment()
{
    Init();
}

CSegment::CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource)
{
    Init();
    AddRef(); // so that this doesn't get deleted in Track::Init...
    // Force the version to at least 8 so audiopath functionality will be turned on.
    m_dwVersion = 8;
    m_dwResolution = pHeader->dwResolution;
    m_mtLength = pHeader->mtLength;
    m_mtStart = pHeader->mtPlayStart;
    m_mtLoopStart = pHeader->mtLoopStart;
    m_mtLoopEnd = pHeader->mtLoopEnd;
    m_dwRepeats = pHeader->dwRepeats;
    m_dwSegFlags = pHeader->dwFlags;
    if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
    {
        m_rtLength = pHeader->rtLength;
    }
    else
    {
        m_rtLength = 0;
    }
    if (pSource)
    {
        pSource->m_TrackList.CreateCopyWithBlankState(&m_TrackList);
        CTrack *pTrack = m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            pTrack->m_pTrack->Init( this );
        }
    }
}

CSegment::~CSegment()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    Clear(false);
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Segment %lx destroyed\n", this );
}

void CSegment::Clear(bool fZombie)
{
    m_TrackList.Clear();
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    SetGraph(NULL); // shut down the graph and release it
    // We need the following stuff to hang around if the segment is being zombied.
    if (!fZombie)
    {
        // remove all notifies
        CNotificationItem* pItem = m_NotificationList.GetHead();
        while( pItem )
        {
            CNotificationItem* pNext = pItem->GetNext();
            m_NotificationList.Remove( pItem );
            delete pItem;
            pItem = pNext;
        }
        if( m_paPChannels )
        {
            delete [] m_paPChannels;
            m_paPChannels = NULL;
        }
        m_dwNumPChannels = 0;
    }
}

STDMETHODIMP_(void) CSegment::Zombie()
{
    Clear(true);
    m_fZombie = true;
}

STDMETHODIMP CSegment::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegment::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegment)
    {
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_CSegment)
    {
        *ppv = static_cast<CSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8P)
    {
        *ppv = static_cast<IDirectMusicSegment8P*>(this);
    }
    else if (iid == IID_IDirectMusicSegment2)
    {
        m_dwVersion = 2;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegment,
                static_cast<IDirectMusicSegment*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Segment queried for unknown interface.\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSegment::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegment::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSegment::GetLength(
    MUSIC_TIME *pmtLength) // @parm Returns the Segment's length.
{
    V_INAME(IDirectMusicSegment::GetLength);
    V_PTR_WRITE(pmtLength, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtLength = m_mtLength;
    return S_OK;
}


STDMETHODIMP CSegment::SetLength(
    MUSIC_TIME mtLength) // @parm The desired length.
{
    if( mtLength <=0 )
    {
        Trace(1,"Error: Can not set segment length to a negative number (%ld.)\n",mtLength);
        return E_INVALIDARG;
    }
    if(( mtLength <= m_mtStart ) || ( mtLength < m_mtLoopEnd ))
    {
        Trace(1,"Error: Can not set segment length to %ld, which is either less that the start time %ld or the loop end %ld\n",
            mtLength,m_mtStart,m_mtLoopEnd);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLength = mtLength;
    return S_OK;
}

STDMETHODIMP CSegment::GetRepeats(
    DWORD *pdwRepeats) // @parm Returns the number of repeats.
{
    V_INAME(IDirectMusicSegment::GetRepeats);
    V_PTR_WRITE(pdwRepeats, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::SetRepeats(
    DWORD dwRepeats)    // @parm The desired number of repeats.
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_dwRepeats = dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::GetDefaultResolution(
    DWORD *pdwResolution)    // @parm Returns the default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicSegment::GetDefaultResolution);
    V_PTR_WRITE(pdwResolution, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDefaultResolution after the segment has been garbage collected.\n");

        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwResolution = m_dwResolution;
    return S_OK;
}

#define LEGAL_RES_FLAGS (DMUS_SEGF_SECONDARY | \
                        DMUS_SEGF_QUEUE | \
                        DMUS_SEGF_CONTROL | \
                        DMUS_SEGF_AFTERPREPARETIME  | \
                        DMUS_SEGF_GRID | \
                        DMUS_SEGF_BEAT | \
                        DMUS_SEGF_MEASURE | \
                        DMUS_SEGF_NOINVALIDATE | \
                        DMUS_SEGF_ALIGN | \
                        DMUS_SEGF_VALID_START_BEAT | \
                        DMUS_SEGF_VALID_START_GRID | \
                        DMUS_SEGF_VALID_START_TICK | \
                        DMUS_SEGF_AFTERQUEUETIME | \
                        DMUS_SEGF_AFTERLATENCYTIME | \
                        DMUS_SEGF_SEGMENTEND | \
                        DMUS_SEGF_MARKER | \
                        DMUS_SEGF_TIMESIG_ALWAYS | \
                        DMUS_SEGF_USE_AUDIOPATH | \
                        DMUS_SEGF_VALID_START_MEASURE)

STDMETHODIMP CSegment::SetDefaultResolution(
    DWORD dwResolution)    // @parm The desired default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDefaultResolution after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }
#ifdef DBG
    if ((dwResolution & LEGAL_RES_FLAGS) != dwResolution)
    {
        Trace(1,"Warning: Attempt to set resolution includes inappropriate or non-existant flag: %lx\n",
            dwResolution & ~LEGAL_RES_FLAGS);
    }
#endif
    m_dwResolution = dwResolution;
    return S_OK;
}

STDMETHODIMP CSegment::GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DMUS_IO_SEGMENT_HEADER Header;
    Header.dwFlags = m_dwSegFlags;
    Header.dwRepeats = m_dwRepeats;
    Header.dwResolution = m_dwResolution;
    Header.mtLength = m_mtLength;
    Header.mtLoopEnd = m_mtLoopEnd;
    Header.mtLoopStart = m_mtLoopStart;
    Header.mtPlayStart = m_mtStart;
    Header.dwReserved = 0;
    Header.rtLength = m_rtLength;
    if (pdwSize && pHeader)
    {
        *pdwSize = min(sizeof(Header),*pdwSize);
        memcpy(pHeader,&Header,*pdwSize);
        return S_OK;
    }
    Trace(1,"Error: GetHeaderChunk() was passed a NULL for either pdwSize or pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pHeader)
    {
        DMUS_IO_SEGMENT_HEADER Header;
        dwSize = min(sizeof(Header),dwSize);
        // Initialize all fields so we don't have to worry about the passed size.
        Header.dwFlags = m_dwSegFlags;
        Header.dwRepeats = m_dwRepeats;
        Header.dwResolution = m_dwResolution;
        Header.mtLength = m_mtLength;
        Header.mtLoopEnd = m_mtLoopEnd;
        Header.mtLoopStart = m_mtLoopStart;
        Header.mtPlayStart = m_mtStart;
        Header.dwReserved = 0;
        Header.rtLength = m_rtLength;
        memcpy(&Header,pHeader,dwSize);
        m_dwSegFlags = Header.dwFlags;
        m_dwRepeats = Header.dwRepeats;
        m_dwResolution = Header.dwResolution;
        m_mtLength = Header.mtLength;
        m_mtLoopEnd = Header.mtLoopEnd;
        m_mtLoopStart = Header.mtLoopStart;
        m_mtStart = Header.mtPlayStart;
        m_rtLength = Header.rtLength;
        return S_OK;
    }
    Trace(1,"Error: SetHeaderChunk() was passed a NULL for pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority)       /* Priority to set. */
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackPriority after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroupBits,dwCounter))
    {
        pCTrack->m_dwPriority = dwPriority;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::SetAudioPathConfig(
        IUnknown *pAudioPathConfig)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (m_dwVersion < 8) m_dwVersion = 8;
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    if (pAudioPathConfig)
    {
        return pAudioPathConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pAudioPathConfig);
    }
    return S_OK;
}

STDMETHODIMP CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    IDirectMusicTrack **ppTrack)
{
    V_INAME(IDirectMusicSegment::GetTrack);
    V_PTRPTR_WRITE(ppTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rType,dwGroupBits,dwIndex);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: GetTrack could not find the requested track at index %ld.\n",dwIndex);
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack *CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_NULL == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

BOOL CSegment::IsTempoSource()

{
    EnterCriticalSection(&m_CriticalSection);
    BOOL fHasTempo = (NULL != GetTrackByParam(NULL, GUID_TempoParam,-1,0, FALSE));
    LeaveCriticalSection(&m_CriticalSection);
    return fHasTempo;
}

STDMETHODIMP CSegment::GetTrackGroup(
    IDirectMusicTrack* pTrack,    // @parm The Track to find the group bits.
    DWORD* pdwGroupBits)// @parm Returns the group(s) to which a Track belongs.
                        // Each bit in <p pdwGroupBits> corresponds to a Track
                        // group.
{
    V_INAME(IDirectMusicSegment::GetTrackGroup);
    V_INTERFACE(pTrack);
    V_PTR_WRITE(pdwGroupBits,DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrackGroup after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_pTrack == pTrack )
        {
            *pdwGroupBits = pCTrack->m_dwGroupBits;
            hr = S_OK;
            break;
        }
        pCTrack = pCTrack->GetNext();
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: GetTrackGroup could not find the requested track.\n");
    }
#endif
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && (fDontCheck ||
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED)))
        {
            if( (GUID_NULL == rguidType) ||
                (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

HRESULT CSegment::GetTrackByParam(
    REFGUID rguidType,    // The command type of the Track to find. A value of GUID_NULL
                        // will get any track.
    DWORD dwGroupBits,    // Which track groups to scan for the track in. A value of 0
                        // is invalid. Each bit in <p dwGroupBits> corresponds to a Track
                        // group. To scan all tracks regardless of groups, set all bits in
                        // this parameter (0xffffffff).
    DWORD dwIndex,        // The index into the list of tracks of type <p rguidType>
                        // and in group <p dwGroupBits> to return. 0 means the first
                        // one found, 1 would be the second, etc. If multiple groups are
                        // selected in <p dwGroupBits>, this index will indicate the nth
                        // track of type <p pCommandGuid> encountered in the union
                        // of the groups selected.
    IDirectMusicTrack **ppTrack)    // Returns the Track (AddRef'd), or NULL if the
                                    // Track isn't found.
{
    HRESULT hr;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,TRUE);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
        // Don't think we need an error message here since SetParam also does one...
        // Trace(1,"Error: Could not find the requested track for SetParam.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,    // @parm The Track to add to the Segment.
    DWORD dwGroupBits )            // @parm Identifies the group(s) this should be inserted into.
                                // May not be 0.
{
    V_INAME(IDirectMusicSegment::InsertTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::InsertTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return InsertTrack(pTrack,dwGroupBits,DMUS_TRACKCONFIG_DEFAULT,0, 0);
}

HRESULT CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,
    DWORD dwGroupBits,
    DWORD dwFlags,
    DWORD dwPriority,
    DWORD dwPosition)
{
    CTrack* pCTrack;

    if( 0 == dwGroupBits )
    {
        Trace(1,"Error: InsertTrack called with dwGroupBits set to 0.\n");
        return E_INVALIDARG;
    }
    if( FAILED( pTrack->Init( this ) ))
    {
        TraceI(1,"Error: Track failed to initialize\n");
        return DMUS_E_NOT_INIT;
    }
    pCTrack = new CTrack;
    if( NULL == pCTrack )
    {
        return E_OUTOFMEMORY;
    }
    pCTrack->m_pTrack = pTrack;
    pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pCTrack->m_pTrack8);
    IPersist *pPersist;
    if (S_OK == pTrack->QueryInterface(IID_IPersistStream,(void **) &pPersist))
    {
        pPersist->GetClassID( &pCTrack->m_guidClassID );
        pPersist->Release();
    }
    pCTrack->m_dwGroupBits = dwGroupBits;
    pCTrack->m_dwFlags = dwFlags;
    pCTrack->m_dwPriority = dwPriority;
    pCTrack->m_dwPosition = dwPosition;
    pTrack->AddRef();
    EnterCriticalSection(&m_CriticalSection);
    // Add the track based on position.
    CTrack* pScan = m_TrackList.GetHead();
    CTrack* pPrevTrack = NULL;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pCTrack->Less(pScan))
        {
            break;
        }
        pPrevTrack = pScan;
    }
    if (pPrevTrack)
    {
        pPrevTrack->SetNext(pCTrack);
        pCTrack->SetNext(pScan);
    }
    else
    {
        m_TrackList.AddHead( pCTrack );
    }

    // send notifications to track
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pTrack->AddNotificationType( pItem->guidNotificationType );
        pItem = pItem->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::RemoveTrack(
    IDirectMusicTrack *pTrack)    // @parm The Track to remove from the Segment's Track list.
{
    V_INAME(IDirectMusicSegment::RemoveTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrackTemp;
    pCTrackTemp = m_TrackList.GetHead();
    while( pCTrackTemp )
    {
        if( pTrack == pCTrackTemp->m_pTrack )
        {
            hr = S_OK;
            m_TrackList.Remove( pCTrackTemp );
            delete pCTrackTemp;
            break;
        }
        pCTrackTemp = pCTrackTemp->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == S_FALSE)
    {
        Trace(1,"Warning: RemoveTrack failed because the requested track is not in the segment.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::CreateSegmentState(
    CSegState **ppSegState,
    CPerformance *pPerformance,
    IDirectMusicAudioPath *pAudioPath,
    DWORD dwFlags)

{
    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    EnterCriticalSection(&m_CriticalSection);
    if( FAILED( m_TrackList.CreateCopyWithBlankState(&pState->m_TrackList)))
    {
        LeaveCriticalSection(&m_CriticalSection);
        pState->Release();
        return E_OUTOFMEMORY;
    }
    // set the segstate's parent and performance
    pState->PrivateInit( this, pPerformance );

    if (m_pGraph)
    {
        m_pGraph->Clone((IDirectMusicGraph **) &pState->m_pGraph);
    }
    pState->InitRoute(pAudioPath);
    CTrack* pCTrack = pState->m_TrackList.GetHead();
    while( pCTrack )
    {
        DWORD dwTempID;
        InterlockedIncrement(&g_lNewTrackID);
        dwTempID = g_lNewTrackID;
        if (!pState->m_dwFirstTrackID)
            pState->m_dwFirstTrackID = dwTempID;
        pState->m_dwLastTrackID = dwTempID;
        ASSERT(pCTrack->m_pTrack);
        if( FAILED(pCTrack->m_pTrack->InitPlay(
            pSegmentState, (IDirectMusicPerformance *) pPerformance,
            &pCTrack->m_pTrackState, dwTempID, dwFlags )))
        {
            pCTrack->m_pTrackState = NULL;
        }
        pCTrack->m_dwVirtualID = dwTempID;
        pCTrack = pCTrack->GetNext();
    }
    *ppSegState = pState;
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

/*  The following function is kept around only for DX6.1 compatibility just
    in case some mindless bureaucrat actually uses this somehow.
    For internal use, we've switched to the function above.
*/

STDMETHODIMP CSegment::InitPlay(
    IDirectMusicSegmentState **ppSegState,    // @parm Returns the SegmentState created
            // by this method call. It is returned with a reference count of 1, thus a
            // call to its Release will fully release it.
    IDirectMusicPerformance *pPerformance,    // @parm The IDirectMusicPerformance pointer.
            // This is needed by the Segment and SegmentState in order to call methods on
            // the Performance object. This pointer is not AddRef'd. It is a weak reference
            // because it is assumed that the Performance will outlive the Segment.
    DWORD dwFlags)                          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicSegment::InitPlay);
    V_INTERFACE(pPerformance);
    V_PTRPTR_WRITE(ppSegState);

    if (m_dwVersion)
    {
        return E_NOTIMPL;
    }

    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
        if (pPerformance)
        {
            // QI addref's the performance but we want only a weak refrenece with the segment state
            HRESULT hr = pPerformance->QueryInterface(IID_CPerformance,(void **) &pState->m_pPerformance);
            if(FAILED(hr))
            {
                return E_FAIL;
            }

            pPerformance->Release();
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    *ppSegState = pSegmentState;
    return S_OK;
}

STDMETHODIMP CSegment::GetGraph(
    IDirectMusicGraph**    ppGraph    // @parm Returns the Tool Graph pointer.
        )
{
    V_INAME(IDirectMusicSegment::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( NULL == m_pGraph )
    {
        Trace(1,"Error: GetGraph failed because segment does not have a tool graph.\n");
        return DMUS_E_NOT_FOUND;
    }
    EnterCriticalSection(&m_CriticalSection);
    *ppGraph = m_pGraph;
    m_pGraph->AddRef();
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::SetGraph(
    IDirectMusicGraph*    pGraph    // @parm The Tool Graph pointer. May be NULL to
                                // clear out the Segment graph.
        )
{
    V_INAME(IDirectMusicSegment::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    EnterCriticalSection(&m_CriticalSection);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = (CGraph *) pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSegment::SetClockTimeDuration(REFERENCE_TIME rtDuration)

{
    m_rtLength = rtDuration;
    return S_OK;
}

HRESULT CSegment::SetFlags(DWORD dwFlags)

{
    m_dwSegFlags = dwFlags;
    return S_OK;
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CSegment::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

void CSegment::AddNotificationTypeToAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->AddNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

void CSegment::RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->RemoveNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

HRESULT CSegment::AddNotificationType(
     REFGUID rguidNotification, BOOL fFromPerformance)
{
    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    pItem = FindNotification( rguidNotification );
    if (pItem)
    {
        // If the item was installed previously, but by
        // a difference source (performance vs. app)
        // then treat this as a normal addition.
        // Otherwise, indicate that the same operation
        // was done twice.
        if (pItem->fFromPerformance == fFromPerformance)
        {
            hr = S_FALSE;
        }
        else
        {
            // Clear the fFromPerformance flag since this has
            // now been added by the app and the performance.
            pItem->fFromPerformance = FALSE;
        }
    }
    else
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->fFromPerformance = fFromPerformance;
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllTracks( rguidNotification );
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::AddNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to add.
{
    V_INAME(IDirectMusicSegment::AddNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::AddNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return AddNotificationType(rguidNotification,FALSE);
}

HRESULT CSegment::RemoveNotificationType(
     REFGUID rguidNotification,BOOL fFromPerformance)
{

    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    if( GUID_NULL == rguidNotification )
    {
        CNotificationList TempList;
        while( pItem = m_NotificationList.RemoveHead() )
        {
            // If this is being called on an item that was installed by the
            // performance OR we are calling this directly from the app,
            // go ahead and remove. However, do not remove in the specific
            // case where the app installed the notification and the performance
            // is clearing notifications.
            if (pItem->fFromPerformance || !fFromPerformance)
            {
                RemoveNotificationTypeFromAllTracks( pItem->guidNotificationType );
                delete pItem;
            }
            else
            {
                TempList.AddHead(pItem);
            }
        }
        // Now, put the saved notifications back.
        while (pItem = TempList.RemoveHead())
        {
            m_NotificationList.AddHead(pItem);
        }
    }
    else if( pItem = FindNotification( rguidNotification ))
    {
        m_NotificationList.Remove( pItem );
        delete pItem;
        RemoveNotificationTypeFromAllTracks( rguidNotification );
    }
    else
    {
        Trace(2,"Warning: Unable to remove requested notification from segment, it was not currently installed.\n");
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::RemoveNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to remove. GUID_NULL to remove all notifies.
{
    V_INAME(IDirectMusicSegment::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return RemoveNotificationType(rguidNotification,FALSE);
}

STDMETHODIMP CSegment::GetParam(
    REFGUID rguidType,        // @parm The type of data to obtain.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to obtain the data from.
    MUSIC_TIME mtTime,        // @parm The segment time from which to obtain the data.
    MUSIC_TIME* pmtNext,    // @parm Returns the segment time until which the data is valid. <p pmtNext>
                            // may be NULL. If this returns a value of 0, it means that this
                            // data will either be always valid, or it is unknown when it will
                            // become invalid.
    void* pParam)            // @parm The struture in which to return the data. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::GetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // App must be using IDirectMusicSegment8 interface for this to be enabled...
        // Nah, nobody would ever have a use for an index that high, so this is safe.
        fMultipleTry = TRUE; // (m_dwVersion > 2);
    }
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,FALSE);
    while (pCTrack)
    {
        if (pCTrack->m_pTrack8)
        {
            REFERENCE_TIME rtNext, *prtNext;
            // We need to store the next time in a 64 bit pointer. But, don't
            // make 'em fill it in unless the caller requested it.
            if (pmtNext)
            {
                prtNext = &rtNext;
            }
            else
            {
                prtNext = NULL;
            }
            hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam, NULL, 0 );
            if (pmtNext)
            {
                *pmtNext = (MUSIC_TIME) rtNext;
            }
        }
        else
        {
            hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
            if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
            {
                *pmtNext = m_mtLength - mtTime;
            }
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pCTrack = GetTrackByParam( pCTrack, rguidType, dwGroupBits, 0, FALSE);
        }
        else
        {
            pCTrack = NULL;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment GetParam failed to find a track.\n");
    }
#endif
    return hr;
}


STDMETHODIMP CSegment::SetParam(
    REFGUID rguidType,        // @parm The type of data to set.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,        // @parm The time at which to set the data.
    void* pParam)            // @parm The struture containing the data to set. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::SetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    IDirectMusicTrack* pTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    while (SUCCEEDED( GetTrackByParam( rguidType, dwGroupBits, dwCounter, &pTrack )))
    {
        hr = pTrack->SetParam( rguidType, mtTime, pParam );
        pTrack->Release();
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment SetParam failed to find the requested track.\n");
    }
#endif
    return hr;
}

STDMETHODIMP CSegment::Download(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Download);
    V_INTERFACE(pAudioPath);
    HRESULT hr = S_OK;

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Download after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Validate that pAudioPath is either a performance or an audio path
    IDirectMusicPerformance* pPerf = NULL;
    if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)) )
    {
        IDirectMusicAudioPath* pAP = NULL;
        if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath, (void**)&pAP)) )
        {
            return hr; // nothing to release, since all the QI's failed.
        }
        else
        {
            pAP->Release();
        }
    }
    else
    {
        pPerf->Release();
    }

    hr = SetParam(GUID_DownloadToAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted download to a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::Unload(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Unload after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = SetParam(GUID_UnloadFromAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted unload from a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex,
                                      DWORD dwFlagsOn, DWORD dwFlagsOff)
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwCounter))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segment SetTrackConfig failed to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::GetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags)
{

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex);
    if (pCTrack)
    {
        *pdwFlags = pCTrack->m_dwFlags;
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::Clone(
            MUSIC_TIME mtStart,    // @parm The start of the part to clone. If less than 0,
                                // or greater than the length of the Segment, 0 will be used.
            MUSIC_TIME mtEnd,    // @parm The end of the part to clone. If past the end of the
                                // Segment, it will clone to the end. Also, a value of 0 or
                                // anything less than <p mtStart> will also clone to the end.
            IDirectMusicSegment** ppSegment    // @parm Returns the created Segment, if successful.
                                // It is caller's responsibility to call Release() when finished
                                // with it.
        )
{
    V_INAME(IDirectMusicSegment::Clone);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Clone after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CSegment* pCSegment;
    HRESULT hr = S_OK;

    if( (mtEnd < mtStart) || (mtEnd > m_mtLength) )
    {
        mtEnd = m_mtLength;
    }
    if( ( mtEnd == 0 ) && ( mtStart == 0 ))
    {
        mtEnd = m_mtLength;
    }
    if( (mtStart < 0) || (mtStart > m_mtLength) )
    {
        mtStart = 0;
    }
    pCSegment = new CSegment;
    if (pCSegment == NULL) {
        return E_OUTOFMEMORY;
    }
    // Addref to 1 and assign to ppSegment.
    pCSegment->AddRef();
    (*ppSegment) = (IDirectMusicSegment *) pCSegment;
    if( m_pGraph )
    {
        pCSegment->m_pGraph = m_pGraph;
        m_pGraph->AddRef();
    }
    if (m_pAudioPathConfig)
    {
        pCSegment->m_pAudioPathConfig = m_pAudioPathConfig;
        m_pAudioPathConfig->AddRef();
    }
    pCSegment->m_dwRepeats = m_dwRepeats;
    pCSegment->m_dwResolution = m_dwResolution;
    pCSegment->m_dwSegFlags = m_dwSegFlags;
    pCSegment->m_mtLength = mtEnd - mtStart;
    pCSegment->m_rtLength = m_rtLength;
    pCSegment->m_mtStart = m_mtStart;
    pCSegment->m_mtLoopStart = m_mtLoopStart;
    pCSegment->m_mtLoopEnd = m_mtLoopEnd;
    pCSegment->m_dwValidData = m_dwValidData;
    pCSegment->m_guidObject = m_guidObject;
    pCSegment->m_ftDate = m_ftDate;
    pCSegment->m_vVersion = m_vVersion;
    StringCchCopyW(pCSegment->m_wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW(pCSegment->m_wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW(pCSegment->m_wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pCSegment->m_dwVersion = m_dwVersion;
    pCSegment->m_dwLoadID = m_dwLoadID;
    pCSegment->m_dwPlayID = m_dwPlayID;
    pCSegment->m_dwNextPlayID = m_dwNextPlayID;
    pCSegment->m_dwNextPlayFlags = m_dwNextPlayFlags;

    CTrack* pCTrack;
    IDirectMusicTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        if( SUCCEEDED( pCTrack->m_pTrack->Clone( mtStart, mtEnd, &pTrack )))
        {
            if( FAILED( pCSegment->InsertTrack( pTrack, pCTrack->m_dwGroupBits, pCTrack->m_dwFlags, pCTrack->m_dwPriority, pCTrack->m_dwPosition )))
            {
                Trace(1,"Warning: Insertion of cloned track failed, cloned segment is incomplete.\n");
                hr = S_FALSE;
            }
            pTrack->Release();
        }
        else
        {
            Trace(1,"Warning: Track clone failed, cloned segment is incomplete.\n");
            hr = S_FALSE;
        }
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)

{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the segment.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                DWORD dwStage,       /* Which stage in the path. */
                                DWORD dwBuffer,
                                REFGUID guidObject,  /* ClassID of object. */
                                DWORD dwIndex,       /* Which object of that class. */
                                REFGUID iidInterface,/* Requested COM interface. */
                                void ** ppObject)

{
    V_INAME(IDirectMusicSegment::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetObjectInPath after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    if (dwStage == DMUS_PATH_SEGMENT_TRACK)
    {
        CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
        if (pCTrack)
        {
            if (pCTrack->m_pTrack)
            {
                hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_GRAPH)
    {
        if (dwIndex == 0)
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_TOOL)
    {
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (dwStage >= DMUS_PATH_BUFFER)
    {
        // Nothing here now. But, in DX9, we may add support for addressing the buffer configuration
        // and DMOS in it.
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::Compose(MUSIC_TIME mtTime,
                                IDirectMusicSegment* pFromSegment,
                                IDirectMusicSegment* pToSegment,
                                IDirectMusicSegment** ppComposedSegment)

{
    V_INAME(IDirectMusicSegment::Compose);
    V_INTERFACE_OPT(pFromSegment);
    V_INTERFACE_OPT(pToSegment);
    V_PTRPTR_WRITE_OPT(ppComposedSegment);
#ifdef DBG
    if (pFromSegment)
    {
        MUSIC_TIME mtLength, mtLoopEnd, mtLoopStart;
        DWORD dwRepeats;
        // To calculate the full length, we need to access the loop parameters.
        pFromSegment->GetLoopPoints(&mtLoopStart,&mtLoopEnd);
        pFromSegment->GetRepeats(&dwRepeats);
        pFromSegment->GetLength(&mtLength);
        // If repeats is set to infinite, the total length will be greater than 32 bits.
        LONGLONG llTotalLength = dwRepeats * (mtLoopEnd - mtLoopStart) + mtLength;
        if (mtTime >= (llTotalLength & 0x7FFFFFFF))
        {
            Trace(2,"Warning: A time value of %ld was passed to Compose for a segment of length %ld.\n",
                mtTime, (long) llTotalLength);
        }
    }
#endif
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Compose after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppComposedSegment)
    {
        hr = Clone(0, m_mtLength, ppComposedSegment);
        if (SUCCEEDED(hr))
        {
            hr = ((CSegment*)*ppComposedSegment)->ComposeTransition(mtTime, pFromSegment, pToSegment);
        }
    }
    else
    {
        hr = ComposeTransition(mtTime, pFromSegment, pToSegment);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSegment::ComposeTransition(MUSIC_TIME mtTime,
                                    IDirectMusicSegment* pFromSegment,
                                    IDirectMusicSegment* pToSegment)
{
    HRESULT hr = S_OK;
    bool fTrackPadded = false;

    // Compute amount of time to pad any tracks that need padding.
    DMUS_TIMESIGNATURE TimeSig;
    if (!pFromSegment ||
        FAILED(pFromSegment->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, NULL, (void*) &TimeSig)))
    {
        TimeSig.mtTime = 0;
        TimeSig.bBeatsPerMeasure = 4;
        TimeSig.bBeat = 4;
        TimeSig.wGridsPerBeat = 4;
    }
    else // avoid divide-by-zero
    {
        if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    }
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    MUSIC_TIME mtStartPad = min(mtBar, mtTime);
    if (!pFromSegment) mtStartPad = 0;
    MUSIC_TIME mtToLength = 0;
    if (pToSegment) pToSegment->GetLength(&mtToLength);
    MUSIC_TIME mtEndPad = min(mtBar, mtToLength);

    // Instantiate tracks
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        IDirectMusicTrack* pTransTrack1 = NULL;
        IDirectMusicTrack* pTransTrack2 = NULL;
        GUID guidClassID;
        memset(&guidClassID, 0, sizeof(guidClassID));
        IPersist* pPersist = NULL;
        if (SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)))
        {
            pPersist->GetClassID(&guidClassID);
            pPersist->Release();
        }
        DWORD dwTrackGroup = 0;
        GetTrackGroup(pTrack->m_pTrack, &dwTrackGroup);

        // Get track info
        if (pTrack->m_dwFlags & COMPOSE_TRANSITION1)
        {
            // Clone the appropriate track, with length m_mtLength
            MUSIC_TIME mtStart = 0;
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)
            {
                mtStart = mtTime;
            }
            MUSIC_TIME mtEnd = mtStart + m_mtLength;
            IDirectMusicTrack* pSourceTrack = NULL;
            if ( (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ||
                 (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) )
            {
                if (pFromSegment)
                {
                    hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            else if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)
            {
                if (pToSegment)
                {
                    hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            if (pSourceTrack)
            {
                hr = pSourceTrack->Clone(mtStart, mtEnd, &pTransTrack1);
                pSourceTrack->Release();
                pSourceTrack = NULL;
            }
        }
        if (!pTransTrack1)
        {
            pTransTrack1 = pTrack->m_pTrack;
            pTransTrack1->AddRef();

        }
        if (pTransTrack1)
        {
            // Pad the track with an extra bar of header and trailer, by cloning header and trailer
            // tracks (from From and To segments, respectively --- *not* using transition flags) and
            // joining them onto the transition segment track.
            IDirectMusicTrack* pStartPadTrack = NULL;
            IDirectMusicTrack* pEndPadTrack = NULL;
            IDirectMusicTrack* pSourceTrack = NULL;
            if (pFromSegment && mtStartPad)
            {
                hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(mtTime - mtStartPad, mtTime, &pStartPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            if (pToSegment && mtEndPad)
            {
                hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(0, mtEndPad, &pEndPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            IDirectMusicTrack8* pTrack8 = NULL;
            if (pEndPadTrack)
            {
                if (SUCCEEDED(pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pEndPadTrack, m_mtLength, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_END_PADDED;
                    }
                    pTrack8->Release();
                }
                pEndPadTrack->Release();
            }
            if (SUCCEEDED(hr) && pStartPadTrack)
            {
                if (SUCCEEDED(hr = pStartPadTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pTransTrack1, mtStartPad, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_START_PADDED;
                        pTransTrack1->Release();
                        pTransTrack1 = pStartPadTrack;
                    }
                    else
                    {
                        pStartPadTrack->Release();
                    }
                    pTrack8->Release();
                }
                else
                {
                    pStartPadTrack->Release();
                }
            }
            else if(pStartPadTrack)
            {
                pStartPadTrack->Release();
            }

            // Replace the current track with the instantiated one
            IDirectMusicTrack8* pTempTrack8 = NULL;
            pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
            if (pTrack->m_pTrack) pTrack->m_pTrack->Release();
            pTrack->m_pTrack = pTransTrack1;
            pTrack->m_pTrack->Init( this );
            if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
            pTrack->m_pTrack8 = pTempTrack8;
        }

        if (FAILED(hr)) break;
    }
    MUSIC_TIME mtOldLength = m_mtLength;
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // pad the length of the segment, to account for the header/trailer
        m_mtLength += mtStartPad + mtEndPad;
    }

    // Compose
    if (SUCCEEDED(hr))
    {
        hr = ComposeInternal();
    }

    // Back end
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // Trim header and trailer from each track that was joined, using Clone.
        pTrack = m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_START_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(mtStartPad, mtOldLength + mtStartPad, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            else if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_END_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(0, mtOldLength, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        }
        // Return the length of the segment to its original value.
         m_mtLength = mtOldLength;
    }

    return hr;
}

HRESULT CSegment::ComposeInternal()
{
    HRESULT hr = S_OK;
    TList<CTrack*> TrackList;
    // Find the composing tracks and put them in priority order
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
        {
            TListItem<CTrack*>* pTrackItem = new TListItem<CTrack*>(pTrack);
            if (!pTrackItem)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                TListItem<CTrack*>* pMaster = TrackList.GetHead();
                TListItem<CTrack*>* pPrevious = NULL;
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    CTrack*& rpMaster = pMaster->GetItemValue();
                    if (pTrack->m_dwPriority > rpMaster->m_dwPriority) break;
                    pPrevious = pMaster;
                }
                if (!pPrevious) // this has higher priority than anything in the list
                {
                    TrackList.AddHead(pTrackItem);
                }
                else // lower priority than pPrevious, higher than pMaster
                {
                    pTrackItem->SetNext(pMaster);
                    pPrevious->SetNext(pTrackItem);
                }
            }
        }
        if (FAILED(hr)) break;
    }
    // Compose a new track from each from each composing track; put the results
    // in the segment (remove any existing composed tracks)
    if (SUCCEEDED(hr))
    {
        TListItem<CTrack*>* pTrackItem = TrackList.GetHead();
        for (; pTrackItem; pTrackItem = pTrackItem->GetNext())
        {
            CTrack*& rpTrack = pTrackItem->GetItemValue();
            IDirectMusicTrack8* pComposedTrack = NULL;
            hr = rpTrack->m_pTrack8->Compose((IDirectMusicSegment*)this, rpTrack->m_dwGroupBits, (IDirectMusicTrack**)&pComposedTrack);
            if (SUCCEEDED(hr))
            {
                // Remove any tracks of this type (in the same group) from the segment.
                IDirectMusicTrack* pOldTrack = NULL;
                GUID guidClassId;
                memset(&guidClassId, 0, sizeof(guidClassId));
                IPersistStream* pPersist = NULL;
                if (SUCCEEDED(pComposedTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                {
                    if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                        SUCCEEDED( GetTrack( guidClassId, rpTrack->m_dwGroupBits, 0, &pOldTrack ) ) )
                    {
                        RemoveTrack( pOldTrack );
                        pOldTrack->Release();
                    }
                    pPersist->Release();
                }
                hr = InsertTrack(pComposedTrack, rpTrack->m_dwGroupBits);
                pComposedTrack->Release();
            }
            if (FAILED(hr)) break;
        }
    }
    return hr;
}


STDMETHODIMP CSegment::GetStartPoint(
            MUSIC_TIME* pmtStart    // @parm Returns the Segment's start point.
        )
{
    V_INAME(IDirectMusicSegment::GetStartPoint);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::SetStartPoint(
            MUSIC_TIME mtStart    // @parm The start point at which to begin playing the
                                // Segment. If it is less than zero or greater than the
                                // length of the Segment, the start point will be set
                                // to zero.
        )
{
    if( (mtStart < 0) || (mtStart >= m_mtLength) )
    {
        Trace(1,"Error: Unable to set start point %ld because not within the range of the segment, which is %ld.\n",
            mtStart,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtStart = mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::GetLoopPoints(
            MUSIC_TIME* pmtStart,    // @parm Returns the start point of the loop.
            MUSIC_TIME* pmtEnd        // @parm Returns the end point of the loop. A value of
                                    // 0 indicates that the entire Segment will loop.
        )
{
    V_INAME(IDirectMusicSegment::GetLoopPoints);
    V_PTR_WRITE(pmtStart, MUSIC_TIME);
    V_PTR_WRITE(pmtEnd, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtLoopStart;
    *pmtEnd = m_mtLoopEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetLoopPoints(
            MUSIC_TIME mtStart,    // @parm The start point at which to begin the loop.
            MUSIC_TIME mtEnd    // @parm The end point at which to begin the loop. Set
                                // <p mtStart> and <p mtEnd> to 0
                                // to loop the entire Segment.
        )
{
    if( (mtStart < 0) || (mtEnd > m_mtLength) || (mtStart > mtEnd) )
    {
        Trace(1,"Error: Unable to set loop points %ld, %ld because they are not within the range of the segment, which is %ld.\n",
            mtStart,mtStart,mtEnd,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLoopStart = mtStart;
    m_mtLoopEnd = mtEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetPChannelsUsed(
    DWORD dwNumPChannels,    // @parm The number of PChannels to set. This must be equal
                            // to the number of members in the array pointed to by
                            // <p paPChannels>.
    DWORD* paPChannels        // @parm Points to an array of PChannels. The array should
                            // have the same number of elements as specified by <p dwNumPChannels>.
    )
{
    V_INAME(IDirectMusicSegment::SetPChannelsUsed);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetPChannelsUsed after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( dwNumPChannels )
    {
        if( NULL == paPChannels )
        {
            Trace(1,"Error: Bad call to SetPChannelsUsed, pointer to PChannel array is NULL.\n");
            return E_INVALIDARG;
        }
        V_BUFPTR_READ(paPChannels, sizeof(DWORD)*dwNumPChannels);

        DWORD* padwTemp = new DWORD[dwNumPChannels]; // temp array
        DWORD dwTotalNum = 0;
        if( NULL == padwTemp )
        {
            return E_OUTOFMEMORY;
        }
        // count the number of unique PChannels are in the array. That is, the ones
        // that we don't already have stored.
        DWORD dwCount;
        for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
        {
            DWORD dwCurrent;
            for( dwCurrent = 0; dwCurrent < m_dwNumPChannels; dwCurrent++ )
            {
                if( m_paPChannels[dwCurrent] == paPChannels[dwCount] )
                {
                    // we already track this one
                    break;
                }
            }
            if( dwCurrent >= m_dwNumPChannels )
            {
                // we're not already tracking this one
                padwTemp[dwTotalNum] = paPChannels[dwCount];
                dwTotalNum++;
            }
        }
        // dwTotalNum equals the total number of new PChannels, and they are indexed
        // inside adwTemp.
        DWORD* paNewPChannels = new DWORD[m_dwNumPChannels + dwTotalNum];
        if( NULL == paNewPChannels )
        {
            delete [] padwTemp;
            return E_OUTOFMEMORY;
        }
        if( m_paPChannels )
        {
            memcpy( paNewPChannels, m_paPChannels, sizeof(DWORD) * m_dwNumPChannels );
            delete [] m_paPChannels;
        }
        memcpy( &paNewPChannels[m_dwNumPChannels], padwTemp, sizeof(DWORD) * dwTotalNum );
        delete [] padwTemp;
        m_dwNumPChannels += dwTotalNum;
        m_paPChannels = paNewPChannels;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentObject (private)
HRESULT CSegment::GetPChannels(
    DWORD* pdwNumPChannels,    // returns the number of pchannels
    DWORD** ppaPChannels)    // returns a pointer to the array of pchannels. Don't free this
                            // memory or keep it, as it is owned by the Segment.
{
    ASSERT(pdwNumPChannels && ppaPChannels);
    *pdwNumPChannels = m_dwNumPChannels;
    *ppaPChannels = m_paPChannels;
    return S_OK;
}

// return S_OK if the notification is active, S_FALSE if not.
HRESULT CSegment::CheckNotification( REFGUID rguid )
{
    if( NULL == FindNotification( rguid ) )
    {
        return S_FALSE;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSegment::GetClassID( CLSID* pClassID )
{
    V_INAME(CSegment::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetClassID after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSegment;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSegment::IsDirty()
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::IsDirty after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return S_FALSE;
}

#define DMUS_FOURCC_RMID_FORM    mmioFOURCC('R','M','I','D')
#define DMUS_FOURCC_data_FORM    mmioFOURCC('d','a','t','a')
#define DMUS_FOURCC_DLS_FORM    mmioFOURCC('D','L','S',' ')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')

HRESULT CSegment::Load( IStream* pIStream )
{
    V_INAME(CSegment::Load);
    V_INTERFACE(pIStream);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Load after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }

    EnterCriticalSection(&m_CriticalSection);
    Clear(false);

    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            long lFileLength = 0;
            pIStream->Read(&lFileLength, sizeof(long), &dwRead);
            // Check to see if what type of RIFF file we have
            hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    hr = LoadDirectMusicSegment(pIStream);
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    // Since we now know what type of stream we need to seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Create Section
                    IDMSection* pSection;
                    if(SUCCEEDED(hr))
                    {
                        hr = ::CoCreateInstance(CLSID_DMSection,
                                                NULL,
                                                CLSCTX_INPROC,
                                                IID_IDMSection,
                                                (void**)&pSection);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load Section
                        IPersistStream* pIPersistStream;
                        hr = pSection->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pIStream);
                            pIPersistStream->Release();
                        }

                        if(SUCCEEDED(hr))
                        {
                            HRESULT hrTemp = pSection->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                            if (hrTemp != S_OK)
                            {
                                hr = hrTemp;
                            }
                        }

                        pSection->Release();
                    }
                }
                else if(type == DMUS_FOURCC_RMID_FORM)    // We have an RMID MIDI file
                {
                    IDirectMusicCollection *pCollection = NULL;
                    BOOL fLoadedMIDI = FALSE;
                    // Since it's a RIFF file, it could have more than one top level chunk.
                    while (SUCCEEDED(hr) && (lFileLength > 8))
                    {
                        FOURCC dwType = 0;
                        DWORD dwLength;
                        pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                        hr = pIStream->Read(&dwLength, sizeof(DWORD), &dwRead);
                        lFileLength -= 8;
                        if (FAILED(hr))
                        {
                            break;
                        }
                        ULARGE_INTEGER ulPosition;  // Memorize start of chunk.
                        LARGE_INTEGER liStart;
                        liStart.QuadPart = 0;
                        hr = pIStream->Seek(liStart, STREAM_SEEK_CUR, &ulPosition);
                        liStart.QuadPart = ulPosition.QuadPart;
                        if (dwType == DMUS_FOURCC_data_FORM)
                        {   // Get MIDI file header.
                            hr = pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if(SUCCEEDED(hr) && (dwType == mmioFOURCC( 'M', 'T', 'h', 'd' )))
                            {
                                // Since we now know what type of stream we need to seek back to saved position
                                hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                if(SUCCEEDED(hr))
                                {
                                    hr = CreateSegmentFromMIDIStream(pIStream,
                                                                      static_cast<IDirectMusicSegment*>(this));
                                }
                                if (SUCCEEDED(hr)) fLoadedMIDI = TRUE;
                            }
                        }
                        else if ((dwType == mmioFOURCC( 'R', 'I', 'F', 'F' ) ||
                            (dwType == mmioFOURCC( 'L', 'I', 'S', 'T' ))))
                        {
                            pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if (dwType == DMUS_FOURCC_DLS_FORM)
                            {
                                hr = CoCreateInstance(CLSID_DirectMusicCollection,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDirectMusicCollection,
                                        (void**)&pCollection);
                                if (SUCCEEDED(hr))
                                {
                                    IPersistStream* pIPS;
                                    hr = pCollection->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                                    if (SUCCEEDED(hr))
                                    {
                                        // We need to seek back to start of chunk
                                        liStart.QuadPart -= 8;
                                        pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                        hr = pIPS->Load( pIStream );
                                        pIPS->Release();
                                    }
                                    if (FAILED(hr))
                                    {
                                        pCollection->Release();
                                        pCollection = NULL;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (dwLength & 1) ++dwLength;
                            ulPosition.QuadPart += dwLength; // Point to start of next chunk.
                            liStart.QuadPart = ulPosition.QuadPart;
                            hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
                            lFileLength -= dwLength; // Decrement amount left in file.
                        }
                    }
                    if (pCollection)
                    {
                        if (fLoadedMIDI)
                        {
                            SetParam(GUID_ConnectToDLSCollection,-1,0,0,(void *) pCollection);
                        }
                        pCollection->Release();
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    IDirectSoundWave* pWave = NULL;
                    // Seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Check to see if this wave is embedded
                    if (dwSavedPos == 0)
                    {
                        // CoCreate the wave and load it from the stream
                        if (SUCCEEDED(hr))
                        {
                            hr = CoCreateInstance(CLSID_DirectSoundWave,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDirectSoundWave,
                                    (void**)&pWave);

                            if (SUCCEEDED(hr))
                            {
                                IPersistStream* pIPS = NULL;

                                hr = pWave->QueryInterface(IID_IPersistStream, (void**)&pIPS);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pIPS->Load( pIStream );
                                    pIPS->Release();
                                }

                                if (FAILED(hr))
                                {
                                    pWave->Release();
                                    pWave = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Have the loader load the wave object from the stream
                        DMUS_OBJECTDESC descWave;
                        ZeroMemory(&descWave, sizeof(descWave));
                        descWave.dwSize = sizeof(descWave);
                        descWave.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        descWave.guidClass = CLSID_DirectSoundWave;
                        descWave.pStream = pIStream;
                        IDirectMusicLoader *pLoader = NULL;
                        IDirectMusicGetLoader *pGetLoader = NULL;
                        hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pGetLoader);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                            {
                                hr = pLoader->GetObject(&descWave, IID_IDirectSoundWave, (void **)&pWave);
                                descWave.pStream = NULL;
                                descWave.dwValidData &= ~DMUS_OBJ_STREAM;
                                if (SUCCEEDED(hr))
                                {
                                    IDirectMusicObject* pObject = NULL;
                                    hr = pWave->QueryInterface(IID_IDirectMusicObject, (void **)&pObject);
                                    if (SUCCEEDED(hr))
                                    {
                                        // set this object to be a segment with the same GUID
                                        pObject->GetDescriptor(&descWave);
                                        descWave.guidClass = CLSID_DirectMusicSegment;
                                        SetDescriptor(&descWave);
                                        pObject->Release();
                                    }
                                }
                                pLoader->Release();
                            }
                            pGetLoader->Release();
                        }
                    }

                    if(pWave)
                    {

                        // CoCreate a wave track
                        IDirectMusicTrack* pWaveTrack = NULL;
                        if (SUCCEEDED(hr))
                        {
                            hr = ::CoCreateInstance(CLSID_DirectMusicWaveTrack,
                                                    NULL,
                                                    CLSCTX_INPROC,
                                                    IID_IDirectMusicTrack,
                                                    (void**)&pWaveTrack);
                        }

                        // Add the wave object to the wave track, and insert the track in the segment.
                        if (SUCCEEDED(hr))
                        {
                            IPrivateWaveTrack* pPrivateWave = NULL;
                            hr = pWaveTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pPrivateWave);
                            if (SUCCEEDED(hr))
                            {
                                REFERENCE_TIME rt = 0;
                                hr = pPrivateWave->AddWave(pWave, 0, 0, 0, &rt);
                                if (SUCCEEDED(hr))
                                {
                                    SetClockTimeDuration(rt * REF_PER_MIL);
                                    SetFlags(DMUS_SEGIOF_REFLENGTH);
                                }
                                InsertTrack(pWaveTrack, 1);
                                SetTrackConfig(CLSID_DirectMusicWaveTrack, 1, 0, DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME,0);
                                pPrivateWave->Release();
                            }
                        }

                        // Clean up anything that's still hanging around
                        if (pWaveTrack) pWaveTrack->Release();
                        if (pWave) pWave->Release();
                    }
                }
            }
            else
            {
                hr = DMUS_E_CANNOTREAD;
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            // Create Template
            IDMTempl* pTemplate;
            if(SUCCEEDED(hr))
            {
                hr = ::CoCreateInstance(CLSID_DMTempl,
                                        NULL,
                                        CLSCTX_INPROC,
                                        IID_IDMTempl,
                                        (void**)&pTemplate);
            }

            if(SUCCEEDED(hr))
            {
                // Load Template
                IPersistStream* pIPersistStream;
                hr = pTemplate->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                if(SUCCEEDED(hr))
                {
                    hr = pIPersistStream->Load(pIStream);
                    pIPersistStream->Release();
                }

                if(SUCCEEDED(hr))
                {
                    hr = pTemplate->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                }

                pTemplate->Release();
            }
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            if(SUCCEEDED(hr))
            {
                hr = CreateSegmentFromMIDIStream(pIStream,
                                                  static_cast<IDirectMusicSegment*>(this));
            }
        }
        else
        {
            // Not a DirectMusic Segment file, MIDI file or section or
            // template; unsupported
            Trace(1,"Error: Segment unable to parse file. Must be segment, midi, wave, or rmi file format.\n");
            hr = DMUS_E_UNSUPPORTED_STREAM;
        }
    }
    else
    {
        hr = DMUS_E_CANNOTREAD;
    }
    if( SUCCEEDED(hr) )
    {
        m_dwValidData |= DMUS_OBJ_LOADED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


HRESULT CSegment::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSegment::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

HRESULT CSegment::LoadDirectMusicSegment(IStream* pIStream)
{
    // Argument validation
    assert(pIStream);
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;
    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM)
        {
            RIFFIO ckNext;    // Descends into the next chunk.
            RIFFIO ckChild;   // For scanning through children lists.
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                case DMUS_FOURCC_SEGMENT_CHUNK:
                    DMUS_IO_SEGMENT_HEADER ioSegHdr;
                    ioSegHdr.rtLength = 0;
                    ioSegHdr.dwFlags = 0;
                    hr = Parser.Read(&ioSegHdr, sizeof(DMUS_IO_SEGMENT_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_dwResolution = ioSegHdr.dwResolution;
                        m_mtLength = ioSegHdr.mtLength;
                        m_mtStart = ioSegHdr.mtPlayStart;
                        m_mtLoopStart = ioSegHdr.mtLoopStart;
                        m_mtLoopEnd = ioSegHdr.mtLoopEnd;
                        m_dwRepeats = ioSegHdr.dwRepeats;
                        m_dwSegFlags = ioSegHdr.dwFlags;
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
                        {
                            m_rtLength = ioSegHdr.rtLength;
                        }
                        else
                        {
                            m_rtLength = 0;
                        }
                    }
                    break;

                case DMUS_FOURCC_GUID_CHUNK:
                    if( ckNext.cksize == sizeof(GUID) )
                    {
                        hr = Parser.Read(&m_guidObject, sizeof(GUID));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_OBJECT;
                        }
                    }
                    break;

                case DMUS_FOURCC_VERSION_CHUNK:
                    hr = Parser.Read(&m_vVersion, sizeof(DMUS_VERSION) );
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_VERSION;
                    }
                    break;

                case DMUS_FOURCC_CATEGORY_CHUNK:
                    hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                    m_wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_CATEGORY;
                    }
                    break;

                case DMUS_FOURCC_DATE_CHUNK:
                    if( sizeof(FILETIME) == ckNext.cksize )
                    {
                        hr = Parser.Read( &m_ftDate, sizeof(FILETIME));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_DATE;
                        }
                    }
                    break;

                case FOURCC_LIST:
                case FOURCC_RIFF:
                    switch(ckNext.fccType)
                    {
                        case DMUS_FOURCC_UNFO_LIST:
                            Parser.EnterList(&ckChild);
                            while (Parser.NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_UNAM_CHUNK:
                                    {
                                        hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                        m_wszName[DMUS_MAX_NAME-1] = '\0';
                                        if(SUCCEEDED(hr) )
                                        {
                                            m_dwValidData |= DMUS_OBJ_NAME;
                                        }
                                        break;
                                    }
                                    default:
                                        break;
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_CONTAINER_FORM:
                            // An embedded container RIFF chunk which includes a bunch
                            // of objects referenced by the segment. This should precede the
                            // tracks and gets loaded prior to the tracks. Loading this
                            // causes all of its objects to get SetObject'd in the loader,
                            // so they later get pulled in as requested by the tracks.
                            // After the tracks are loaded, the loader references are
                            // released by a call to release the IDirectMusicContainer.
                            {
                                DMUS_OBJECTDESC Desc;
                                IDirectMusicLoader *pLoader;
                                IDirectMusicGetLoader *pGetLoader;
                                HRESULT hrTemp = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                if (SUCCEEDED(hrTemp))
                                {
                                    if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                    {
                                        // Move back stream's current position
                                        Parser.SeekBack();
                                        Desc.dwSize = sizeof(Desc);
                                        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                        Desc.guidClass = CLSID_DirectMusicContainer;
                                        Desc.pStream = pIStream;
                                        pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                        if (pContainer)
                                        {
                                            // Don't cache the container object! We want it and the
                                            // objects it references to go away when the segment is done loading.
                                            IDirectMusicObject *pObject = NULL;
                                            pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                            if (pObject)
                                            {
                                                pLoader->ReleaseObject(pObject);
                                                pObject->Release();
                                            }
                                        }
                                        // Now, seek to the end of this chunk.
                                        Parser.SeekForward();
                                        pLoader->Release();
                                    }
                                    pGetLoader->Release();
                                }
                            }
                            break;
                        case DMUS_FOURCC_TRACK_LIST:
                            Parser.EnterList(&ckChild);
                            while(Parser.NextChunk(&hr))
                            {
                                if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_TRACK_FORM))
                                {
                                    hr = LoadTrack(&Parser);
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_TOOLGRAPH_FORM:
                            hr = LoadGraph(&Parser,&m_pGraph);
                            break;
                        case DMUS_FOURCC_AUDIOPATH_FORM:
                            // Move back to start of this chunk.
                            Parser.SeekBack();
                            hr = LoadAudioPath(pIStream);
                            // Now, seek to the end of this chunk.
                            Parser.SeekForward();
                            break;
                    }
                    break;
                }
            }
            Parser.LeaveList();
            if (pContainer)
            {
                pContainer->Release();
            }
        }
        else
        {
            Trace(1,"Error: Unknown file format.\n");
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
    }
    Parser.LeaveList();
    if (SUCCEEDED(hr) && Parser.ComponentFailed())
    {
        Trace(1,"Warning: Segment successfully loaded but one or more tracks within it did not.\n");
        hr = DMUS_S_PARTIALLOAD;
    }

    return hr;
}

HRESULT CSegment::LoadTrack(CRiffParser *pParser)
{
    BOOL fHeaderRead = FALSE;

    DMUS_IO_TRACK_HEADER ioTrackHdr;
    DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
    ioTrackExtrasHdr.dwPriority = 0;
    ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    ioTrackHdr.ckid = 0;
    ioTrackHdr.fccType = 0;
    ioTrackHdr.dwPosition = 0;

    RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == DMUS_FOURCC_TRACK_CHUNK)
        {
            fHeaderRead = TRUE;
            hr = pParser->Read(&ioTrackHdr, sizeof(DMUS_IO_TRACK_HEADER));
            if(ioTrackHdr.ckid == 0 && ioTrackHdr.fccType == NULL)
            {
                Trace(1,"Error: Invalid track header in Segment.\n");
                hr = DMUS_E_INVALID_TRACK_HDR;
            }
        }
        else if (ckNext.ckid == DMUS_FOURCC_TRACK_EXTRAS_CHUNK)
        {
            hr = pParser->Read(&ioTrackExtrasHdr, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER));
        }
        else if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioTrackHdr.fccType) ||
            (ckNext.ckid == ioTrackHdr.ckid))
        {
            if (fHeaderRead)
            {
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                pParser->SeekBack();
                // Let the parser know it's okay to fail this.
                pParser->EnteringComponent();
                hr = CreateTrack(ioTrackHdr, ioTrackExtrasHdr.dwFlags, ioTrackExtrasHdr.dwPriority, pParser->GetStream());
                // Now, make sure we are at the end of the chunk.
                pParser->SeekForward();
            }
            else
            {
                Trace(1,"Error: Invalid track in Segment - track header is not before track data.\n");
                hr = DMUS_E_TRACK_HDR_NOT_FIRST_CK;
            }

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSegment::CreateTrack(DMUS_IO_TRACK_HEADER& ioTrackHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream)
{
    assert(pStream);

    IDirectMusicTrack* pDMTrack = NULL;
    HRESULT hrTrack = S_OK;
    HRESULT hr = CoCreateInstance(ioTrackHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTrack,
                                  (void**)&pDMTrack);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTrack->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = hrTrack = pIPersistStream->Load(pStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTrack(pDMTrack, ioTrackHdr.dwGroup, dwFlags, dwPriority, ioTrackHdr.dwPosition);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTrack)
    {
        pDMTrack->Release();
    }

    if (hr == S_OK && hrTrack != S_OK)
    {
        hr = hrTrack;
    }
    return hr;
}

HRESULT CSegment::LoadGraph(CRiffParser *pParser,CGraph **ppGraph)
{
    CGraph *pGraph = new CGraph;
    if (pGraph == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pGraph->Load(pParser);

    EnterCriticalSection(&m_CriticalSection);
    if(*ppGraph)
    {
        (*ppGraph)->Release();
    }
    *ppGraph = pGraph;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSegment::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    if (FAILED(hr))
    {
        Trace(1,"Segment failed loading embedded AudioPath Configuration\n");
    }

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    if (m_dwVersion < 8) m_dwVersion = 8;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSegment::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    pDesc->guidClass = CLSID_DirectMusicSegment;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    StringCchCopyW( pDesc->wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW( pDesc->wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW( pDesc->wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSegment::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw |= DMUS_OBJ_CLASS;
        }

        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw |= DMUS_OBJ_LOADED;
        }

        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            StringCchCopyW( m_wszName, DMUS_MAX_NAME, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            StringCchCopyW( m_wszCategory, DMUS_MAX_CATEGORY, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            StringCchCopyW( m_wszFileName, DMUS_MAX_FILENAME, pDesc->wszFileName);
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Segment::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Unable to set segment descriptor, size field is too small.\n");
    }
    return hr;
}

STDMETHODIMP CSegment::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSegment::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::ParseDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hret = E_FAIL;
    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }
    pDesc->dwValidData = 0;
    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            // Check to see if what type of RIFF file we have
            li.HighPart = 0;
            li.LowPart = dwSavedPos + 8; // Length needed to seek to form type of RIFF chunk

            hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
            if(SUCCEEDED(hr))
            {
                hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
            }

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                    if( SUCCEEDED(hr) ) // should always succeed.
                    {
                        hret = ParseSegment(pStream, pDesc);
                    }
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    long lTemp;
                    hr = pStream->Read(&lTemp, sizeof(long), &dwRead);
                    if( lTemp == mmioFOURCC('s','e','c','n') )
                    {
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // length
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // time
                        if( SUCCEEDED(hr) && (dwRead == sizeof(long) ))
                        {
                            hr = pStream->Read(&pDesc->wszName, sizeof(WCHAR)*16, &dwRead);
                            pDesc->wszName[16-1] = '\0';
                            if(SUCCEEDED(hr) && (dwRead == sizeof(WCHAR)*16))
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                        }
                        hret = S_OK;
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    // Create a wave object and have it parse the file.
                    IDirectMusicObject *pObject;
                    hret = CoCreateInstance(CLSID_DirectSoundWave,NULL,CLSCTX_INPROC_SERVER,
                        IID_IDirectMusicObject,(void **) &pObject);
                    if(SUCCEEDED(hret))
                    {
                        // seek back to saved position
                        li.HighPart = 0;
                        li.LowPart = dwSavedPos;
                        hret = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hret))
                        {
                            hret = pObject->ParseDescriptor(pStream,pDesc);
                        }
                        pObject->Release();
                    }
                }
                // Check to see if we have a MIDI file
                else
                {
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos + 20; // Length needed to seek to start of normal MIDI file
                                                  // contained within the Riff chunk

                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

                    if(SUCCEEDED(hr))
                    {
                        hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
                    }

                    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
                    {
                        if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
                        {
                            hret = S_OK;
                        }
                    }
                }
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            hret = S_OK;
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            hret = S_OK;
        }
    }
    if (SUCCEEDED(hret))
    {
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSegment;
    }
#ifdef DBG
    if (hret == E_FAIL)
    {
        Trace(1,"Error: Segment unable to parse file - unknown format.\n");
    }
#endif
    return hret;
}

HRESULT CSegment::ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc)
{
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                pDesc->wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            pDesc->wszName[DMUS_MAX_NAME-1] = '\0';
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    return hr;
}

void CSegmentList::Clear()
{
    CSegment *pSeg;
    while (pSeg = RemoveHead())
    {
        pSeg->SetNext(NULL);
        pSeg->m_pSong = NULL;
        pSeg->Release();
    }
}

inline REFERENCE_TIME ConvertToReference(MUSIC_TIME mtSpan, double dblTempo)
{
    REFERENCE_TIME rtTemp = mtSpan;
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dblTempo);
    return rtTemp;
}

inline MUSIC_TIME ConvertToMusic(REFERENCE_TIME rtSpan, double dblTempo)
{
    rtSpan *= DMUS_PPQ;
    rtSpan = (REFERENCE_TIME)(rtSpan * dblTempo);
    rtSpan += 300000000;
    rtSpan /= 600000000;
#ifdef DBG
    if ( rtSpan & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    return (MUSIC_TIME) (rtSpan & 0xFFFFFFFF);
}

HRESULT CSegment::MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || mtTempo + mtNext >= mtTime) break;
            rtTempo += ConvertToReference(mtNext, dbl);
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *prtTime = rtTempo + ConvertToReference(mtTime - mtTempo, dbl);
    return S_OK;
}

HRESULT CSegment::ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNext = rtTempo + ConvertToReference(mtNext, dbl);
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || rtNext >= rtTime) break;
            rtTempo = rtNext;
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *pmtTime = mtTempo + ConvertToMusic(rtTime - rtTempo, dbl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\dmstrm.cpp ===
//
// dmstrm.cpp
//
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream

CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init

STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;

    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(3,"Warning: Reached end of file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            // This is not really a failure, just indicating we've reached the end of the list.
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }

        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten);

            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }

        }

        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten);

        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }

    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten);

    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream;
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent)
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD)));
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart +
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\lyrictrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricTrack.
//

// This track type holds events that send DMUS_LYRIC_PMSG notifications at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct LyricInfo
{
	LyricInfo() : dwFlags(0), dwTimingFlags(0), lTriggerTime(0), lTimePhysical(0) {}

	HRESULT Clone(const LyricInfo &o, MUSIC_TIME mtStart)
	{
		*this = o;
		lTriggerTime -= mtStart;
		lTimePhysical -= mtStart;
		return S_OK;
	}

	DWORD dwFlags;
	DWORD dwTimingFlags;
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	SmartRef::WString wstrText;
};

//////////////////////////////////////////////////////////////////////
// CLyricsTrack

class CLyricsTrack;
typedef CPlayingTrack<CLyricsTrack, LyricInfo> CLyricsTrackBase;

class CLyricsTrack
  : public CLyricsTrackBase
{
public:
	// When the lyric track plays one of its items, it sends a Lyric PMsg through its segment state.  If an invalidation occurs,
	// the PMsg is retracted by the performance.  Then the track is played again (with the FLUSH bit set).  The last pameter to
	// the CSegTriggerTrackBase is true, which instructs it to play the item a second time--to replace the retracted lyric.
	CLyricsTrack(HRESULT *pHr) : CLyricsTrackBase(&g_cComponent, CLSID_DirectMusicLyricsTrack, false, true) {}

protected:
	HRESULT PlayItem(
		const LyricInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadLyric(SmartRef::RiffIter ri);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\marktrk.h ===
//MarkTrk.h : Declaration of the marker track

#ifndef __MARKTRK_H_
#define __MARKTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CValidStartItem : public AListItem
{
public:
    CValidStartItem* GetNext(){ return (CValidStartItem*)AListItem::GetNext(); };
    DMUS_IO_VALID_START  m_ValidStart;
};
   
class CValidStartList : public AList
{
public:
    CValidStartItem* GetHead() {return (CValidStartItem*)AList::GetHead();};
    CValidStartItem* RemoveHead() {return (CValidStartItem*)AList::RemoveHead();};
    CValidStartItem* GetItem(LONG lIndex) { return (CValidStartItem*) AList::GetItem(lIndex);};
};

class CPlayMarkerItem : public AListItem
{
public:
    CPlayMarkerItem* GetNext(){ return (CPlayMarkerItem*)AListItem::GetNext(); };
    DMUS_IO_PLAY_MARKER  m_PlayMarker;
};
   
class CPlayMarkerList : public AList
{
public:
    CPlayMarkerItem* GetHead() {return (CPlayMarkerItem*)AList::GetHead();};
    CPlayMarkerItem* RemoveHead() {return (CPlayMarkerItem*)AList::RemoveHead();};
    CPlayMarkerItem* GetItem(LONG lIndex) { return (CPlayMarkerItem*) AList::GetItem(lIndex);};
};

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack
class CMarkerTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CMarkerTrack();
	CMarkerTrack(CMarkerTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMarkerTrack();

// member variables
protected:
    CValidStartList     m_ValidStartList;
    CPlayMarkerList     m_PlayMarkerList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	void Construct(void);
    void Clear();
    HRESULT LoadValidStartList( CRiffParser *pParser, long lChunkSize );
    HRESULT LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize );
protected:
};

#endif //__MARKTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\lyrictrk.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricsTrack.
//

#include "dmime.h"
#include "lyrictrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CLyricsTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
    struct LocalFunction
    {
        // Helper used by the LoadRiff function when we expected to find something
        // but a RiffIter becomes false.  In this case, if it has a success HR
        // indicating there were no more items then we return DMUS_E_INVALID_LYRICSTRACK
        // because the stream didn't contain the data we expected.  If it has a
        // failure hr, it was unable to read from the stream and we return its HR.
        static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
        {
            HRESULT hr = ri.hr();
            return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;
        }
    };

    // find <lyrt>
    if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACK_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(ri.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrt' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(ri);
    }

    // find <lyrl>
    SmartRef::RiffIter riTrackForm = ri.Descend();
    if (!riTrackForm)
        return riTrackForm.hr();
    if (!riTrackForm.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACKEVENTS_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(riTrackForm.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrl' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(riTrackForm);
    }

    // process each event <lyre>
    SmartRef::RiffIter riEvent = riTrackForm.Descend();
    if (!riEvent)
        return riEvent.hr();

    for ( ; riEvent; ++riEvent)
    {
        if (riEvent.type() == SmartRef::RiffIter::List && riEvent.id() == DMUS_FOURCC_LYRICSTRACKEVENT_LIST)
        {
            HRESULT hr = this->LoadLyric(riEvent.Descend());
            if (FAILED(hr))
                return hr;
        }
    }
    return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CLyricsTrack::PlayItem(
        const LyricInfo &item,
        statedata &state,
        IDirectMusicPerformance *pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        bool fClockTime)
{
    // get the graph from the segment state
    IDirectMusicGraph *pGraph = NULL;
    HRESULT hrG = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&pGraph));
    if (FAILED(hrG))
        return hrG;

    SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(pPerf, 2 * wcslen(item.wstrText));
    if (FAILED(pmsg.hr())) {
        pGraph->Release();
        return pmsg.hr();
    }

    assert(((char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((char*)(pmsg.p)) + pmsg.p->dwSize)); // just to make sure we haven't miscalculated.  the last byte of the null of the string should fall before the byte just beyond the extent of the struct (and it could be several bytes before if the DMUS_LYRIC_PMSG struct ended up being padded to come out to an even multiple of bytes.
    wcscpy(pmsg.p->wszString, item.wstrText);
    if (fClockTime)
    {
        pmsg.p->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | item.dwTimingFlags;
    }
    else
    {
        pmsg.p->mtTime = item.lTimePhysical + mtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_MUSICTIME | item.dwTimingFlags;
    }
    pmsg.p->dwVirtualTrackID = dwVirtualID;
    pmsg.p->dwType = DMUS_PMSGT_LYRIC;
    pmsg.p->dwGroupID = 0xffffffff;

    pmsg.StampAndSend(pGraph);
    pGraph->Release();

    return pmsg.hr();
}

HRESULT
CLyricsTrack::LoadLyric(SmartRef::RiffIter ri)
{
    HRESULT hr = S_OK;

    if (!ri)
        return ri.hr();

    // Create an event
    TListItem<LyricInfo> *pItem = new TListItem<LyricInfo>;
    if (!pItem)
        return E_OUTOFMEMORY;
    LyricInfo &rinfo = pItem->GetItemValue();

    bool fFoundEventHeader = false;

    for ( ; ri; ++ri)
    {
        if (ri.type() != SmartRef::RiffIter::Chunk)
            continue;

        switch(ri.id())
        {
            case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
                // Read an event chunk
                DMUS_IO_LYRICSTRACK_EVENTHEADER ioItem;
                hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
                if (FAILED(hr))
                {
                    delete pItem;
                    return hr;
                }

                // Don't allow ref/music timing flags because these are controlled by whether
                // the overall track is playing music or clock time and can't be set in individual
                // events.  Similarly, the tool flush flag isn't appropriate for an event to be played.
                if (ioItem.dwTimingFlags & (DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_FLUSH | DMUS_PMSGF_LOCKTOREFTIME))
                {
                    Trace(1, "Error: Unable to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are not allowed as dwTimingFlags in chunk 'lyrh'.\n");
                    delete pItem;
                    return DMUS_E_INVALID_LYRICSTRACK;
                }

                fFoundEventHeader = true;
                rinfo.dwFlags = ioItem.dwFlags;
                rinfo.dwTimingFlags = ioItem.dwTimingFlags;
                rinfo.lTriggerTime = ioItem.lTimeLogical;
                rinfo.lTimePhysical = ioItem.lTimePhysical;
                break;

            case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
                {
                    hr = ri.ReadText(&rinfo.wstrText);
                    if (FAILED(hr))
                    {
#ifdef DBG
                        if (hr == E_FAIL)
                        {
                            Trace(1, "Error: Unable to load lyric track: Problem reading 'lyrn' chunk.\n");
                        }
#endif
                        delete pItem;
                        return hr == E_FAIL ? DMUS_E_INVALID_LYRICSTRACK : hr;
                    }
                }
                break;

            default:
                break;
        }
    }
    hr = ri.hr();

    if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.wstrText))
    {
#ifdef DBG
        if (!fFoundEventHeader)
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrh' not found.\n");
        }
        else
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrn' not found.\n");
        }
#endif
        hr = DMUS_E_INVALID_LYRICSTRACK;
    }

    if (SUCCEEDED(hr))
    {
        m_EventList.AddHead(pItem);
    }
    else
    {
        delete pItem;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\midifile.h ===
//
// midifile.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Note: 
//

#ifndef MIDIFILE_H
#define MIDIFILE_H

HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream, 
									IDirectMusicSegment* pSegment);
#endif // #ifndef MIDIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\mutx.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\marktrk.cpp ===
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MarkTrk.cpp : Implementation of CMarkerTrack

#include "dmime.h"
#include "..\shared\dmstrm.h"
#include "MarkTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack

void CMarkerTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
}

CMarkerTrack::CMarkerTrack()
{
	Construct();
}

CMarkerTrack::CMarkerTrack(
		CMarkerTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
    // Clone the valid start point list.
	CValidStartItem* pVScan = pSourceTrack->m_ValidStartList.GetHead();
	CValidStartItem* pVPrevious = NULL;
	for(; pVScan; pVScan = pVScan->GetNext())
	{
		if (pVScan->m_ValidStart.mtTime < mtStart)
		{
			pVPrevious = pVScan;
		}
		else if (pVScan->m_ValidStart.mtTime < mtEnd)
		{
			if (pVScan->m_ValidStart.mtTime == mtStart)
			{
				pVPrevious = NULL;
			}
			CValidStartItem* pNew = new CValidStartItem;
			if (pNew)
			{
				pNew->m_ValidStart.mtTime = pVScan->m_ValidStart.mtTime - mtStart;
				m_ValidStartList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_ValidStartList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pVPrevious)
	{
		CValidStartItem* pNew = new CValidStartItem;
		if (pNew)
		{
			pNew->m_ValidStart.mtTime = 0;
			m_ValidStartList.AddHead(pNew);
		}
	}
    // Clone the play marker list. Gee, this is identical code...
	CPlayMarkerItem* pPScan = pSourceTrack->m_PlayMarkerList.GetHead();
	CPlayMarkerItem* pPPrevious = NULL;
	for(; pPScan; pPScan = pPScan->GetNext())
	{
		if (pPScan->m_PlayMarker.mtTime < mtStart)
		{
			pPPrevious = pPScan;
		}
		else if (pPScan->m_PlayMarker.mtTime < mtEnd)
		{
			if (pPScan->m_PlayMarker.mtTime == mtStart)
			{
				pPPrevious = NULL;
			}
			CPlayMarkerItem* pNew = new CPlayMarkerItem;
			if (pNew)
			{
				pNew->m_PlayMarker.mtTime = pPScan->m_PlayMarker.mtTime - mtStart;
				m_PlayMarkerList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_PlayMarkerList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPPrevious)
	{
		CPlayMarkerItem* pNew = new CPlayMarkerItem;
		if (pNew)
		{
			pNew->m_PlayMarker.mtTime = 0;
			m_PlayMarkerList.AddHead(pNew);
		}
	}
}

void CMarkerTrack::Clear()

{
	CValidStartItem* pStart;
	while( pStart = m_ValidStartList.RemoveHead() )
	{
		delete pStart;
	}
	CPlayMarkerItem* pPlay;
	while( pPlay = m_PlayMarkerList.RemoveHead() )
	{
		delete pPlay;
	}
}

CMarkerTrack::~CMarkerTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CMarkerTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CMarkerTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Marker Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMarkerTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMarkerTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CMarkerTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CMarkerTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMarkerTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CMarkerTrack::IsDirty()
{
	return S_FALSE;
}

HRESULT CMarkerTrack::Load( IStream* pIStream )
{
	V_INAME(CMarkerTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_MARKERTRACK_LIST))
    {
        Clear();
	    RIFFIO ckNext;    // Descends into the children chunks.
        Parser.EnterList(&ckNext);
        while (Parser.NextChunk(&hr))
        {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_VALIDSTART_CHUNK :
                hr = LoadValidStartList(&Parser,ckNext.cksize);
                break;
            case DMUS_FOURCC_PLAYMARKER_CHUNK :
                hr = LoadPlayMarkerList(&Parser,ckNext.cksize);
                break;
            }    
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Invalid Marker Track.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    Parser.LeaveList();
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_PLAY_MARKER) )
	    {
		    dwRead = sizeof(DMUS_IO_PLAY_MARKER);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Invalid Marker Track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CPlayMarkerItem *pNew = new CPlayMarkerItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_PlayMarker, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_PlayMarkerList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_PlayMarkerList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::LoadValidStartList( CRiffParser *pParser, long lChunkSize )
{
    HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {	
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_VALID_START) )
	    {
		    dwRead = sizeof(DMUS_IO_VALID_START);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CValidStartItem *pNew = new CValidStartItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_ValidStart, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_ValidStartList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_ValidStartList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CMarkerTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CMarkerTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CMarkerTrack::IsParamSupported);
	V_REFGUID(rguid);

    if ((rguid == GUID_Valid_Start_Time) || 
        (rguid == GUID_Play_Marker))
        return S_OK;
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CMarkerTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CMarkerTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	return S_OK;
}

HRESULT CMarkerTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	return S_OK;
}

HRESULT CMarkerTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	return S_OK;
}

HRESULT CMarkerTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMarkerTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_Valid_Start_Time == rguid )
	{
        DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
		CValidStartItem* pScan = m_ValidStartList.GetHead();
		for (; pScan; pScan = pScan->GetNext())
		{
			if (pScan->m_ValidStart.mtTime >= mtTime)
			{
        		pValidStartData->mtTime = pScan->m_ValidStart.mtTime - mtTime;
				break;
			}
		}
        if (pScan)
        {
 		    if (pmtNext)
		    {
		        if (pScan && (pScan = pScan->GetNext()))
		        {
                    *pmtNext = pScan->m_ValidStart.mtTime - mtTime;
			    }
                else
                {
        		    *pmtNext = 0;
                }
            }
		    hr = S_OK;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
    }
	else if( GUID_Play_Marker == rguid )
	{
        // This is a little different. The marker should be the one in existence
        // BEFORE, not after the requested time. 
        DMUS_PLAY_MARKER_PARAM* pPlayMarkerData = (DMUS_PLAY_MARKER_PARAM*)pData;
		CPlayMarkerItem* pScan = m_PlayMarkerList.GetHead();
        CPlayMarkerItem* pNext;
        // For fallback, treat it as if there were a marker at the start of the segment, but return S_FALSE.
        hr = S_FALSE;
        pPlayMarkerData->mtTime = -mtTime;
		for (; pScan; pScan = pNext)
		{
            pNext = pScan->GetNext();
            if (pScan->m_PlayMarker.mtTime <= mtTime) 
            {
                if (!pNext || (pNext->m_PlayMarker.mtTime > mtTime))
                {
        		    pPlayMarkerData->mtTime = pScan->m_PlayMarker.mtTime - mtTime;
                    if (pmtNext && pNext)
                    {
                        *pmtNext = pNext->m_PlayMarker.mtTime - mtTime;
                    }
                    hr = S_OK;
				    break;
                }
			}
            else
            {
                // Didn't find a marker before the requested time.
                if (pmtNext)
                {
                    *pmtNext = pScan->m_PlayMarker.mtTime - mtTime;
                }
                break;
            }
		}
    }
#ifdef DBG
    if (hr == DMUS_E_GET_UNSUPPORTED)
    {
        Trace(1,"Error: MarkerTrack does not support requested GetParam call.\n");
    }
#endif
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return DMUS_E_SET_UNSUPPORTED;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1,"Error: Unable to clone marker track because the start point is less than 0.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1,"Error: Unable to clone marker track because the start point is greater than the length.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CMarkerTrack *pDM;
    
    try
    {
        pDM = new CMarkerTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\midifile.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
//
// midifile.cpp
//
// original author: Dave Miller
// original project: AudioActive
// modified by: Mark Burton
// project: DirectMusic
//

#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "Template.h"
#include "dmusici.h"
#include "dmperf.h"
#include "dmusicf.h"
#include "..\dmusic\dmcollec.h"
#include "alist.h"
#include "tlist.h"
#include "dmime.h"
#include "..\dmband\dmbndtrk.h"
#include "..\dmband\bandinst.h"

typedef struct _DMUS_IO_BANKSELECT_ITEM
{
    BYTE    byLSB;
    BYTE    byMSB;
    BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK  