cted != -1)
    {
        WCHAR buf[IP_LIMIT];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hIpListView, &lvItem);

        m_strRemovedIpAddress = buf;

        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hIpListView, &lvItem);

        m_strRemovedSubnetMask = buf;

        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_DELETEITEM,
                           (WPARAM)itemSelected, 0);

        ListView_SetItemState(m_hIpListView, 0, LVIS_SELECTED,
                             LVIS_SELECTED);

        SetIpButtons();
        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

INT CALLBACK GatewayCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lSort)
{
    return (INT)lParam1 - (INT)lParam2;
}

LRESULT CIpSettingsPage::OnAddGate(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CGatewayDialog * pDlgGate = new CGatewayDialog(this, g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE);

    if (pDlgGate == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pDlgGate->m_strNewGate = m_strRemovedGateway;
    pDlgGate->m_uiNewMetric = m_uiRemovedMetric;

    if (pDlgGate->DoModal() == IDOK)
    {
        WCHAR buf[256] = {0};
        LV_ITEM lvItem;

        int cItem = ListView_GetItemCount(m_hGatewayListView);

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam = (LPARAM)pDlgGate->m_uiNewMetric;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        lvItem.iItem = cItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = (PWSTR)(pDlgGate->m_strNewGate.c_str());
        lvItem.iItem = SendDlgItemMessage(IDC_IPADDR_GATE, LVM_INSERTITEM,
                                          0, (LPARAM)&lvItem);

        lvItem.iSubItem=1;
        lvItem.pszText = buf;
        
        if (0 == lvItem.lParam)
        {
            lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
        }
        else
        {
            _ltot((INT)lvItem.lParam, buf, 10);
        }
        
        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT,
                           lvItem.iItem, (LPARAM)&lvItem);
        ListView_SetItemState(m_hGatewayListView, lvItem.iItem, LVIS_SELECTED,
                              LVIS_SELECTED);

        SetGatewayButtons();

        pDlgGate->m_strNewGate = L"";
        pDlgGate->m_uiNewMetric = c_dwDefaultMetricOfGateway;

        ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
    }
    m_strRemovedGateway = pDlgGate->m_strNewGate;
    m_uiRemovedMetric = pDlgGate->m_uiNewMetric;

    delete pDlgGate;
    return TRUE;
}

LRESULT CIpSettingsPage::OnEditGate(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    int itemSelected = ListView_GetNextItem(m_hGatewayListView, -1, LVNI_SELECTED);

    CGatewayDialog * pDlgGate = new CGatewayDialog(this, 
                                        g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE,
                                        itemSelected
                                        );

    pDlgGate->m_strNewGate = m_strRemovedGateway;
    pDlgGate->m_uiNewMetric = m_uiRemovedMetric;

    // get the user selection and allow the user to edit the ip/subnet pair
    if (itemSelected != -1)
    {
        WCHAR buf[256] = {0};
        LV_ITEM lvItem;

        // Get gateway
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hGatewayListView, &lvItem);

        pDlgGate->m_strNewGate = buf;
        pDlgGate->m_uiNewMetric = lvItem.lParam;

        if (pDlgGate->DoModal() == IDOK)
        {
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.iItem = itemSelected;
            lvItem.lParam = pDlgGate->m_uiNewMetric;

            lvItem.iSubItem = 0;
            lvItem.pszText = (PWSTR) pDlgGate->m_strNewGate.c_str();
            SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEM, 0,
                               (LPARAM)&lvItem);

            lvItem.iSubItem = 1;
            lvItem.pszText = buf;
            if (0 == lvItem.lParam)
            {
                lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
            }
            else
            {
                _ltot((INT)lvItem.lParam, buf, 10);
            }

            SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT, itemSelected,
                               (LPARAM)&lvItem);
            ListView_SetItemState(m_hGatewayListView, itemSelected,
                                  LVIS_SELECTED, LVIS_SELECTED);
            ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
        }
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this ip/sub pair
    m_strRemovedGateway = L"";;
    m_uiRemovedMetric = c_dwDefaultMetricOfGateway;

    delete pDlgGate;
    return 0;
}

LRESULT CIpSettingsPage::OnRemoveGate(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(m_hGatewayListView, -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR buf[IP_LIMIT];

        LV_ITEM lvItem;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hGatewayListView, &lvItem);

        m_strRemovedGateway = buf;

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hGatewayListView, &lvItem);

        m_uiRemovedMetric = lvItem.lParam;

        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_DELETEITEM,
                           (WPARAM)itemSelected, 0);
        ListView_SetItemState(m_hGatewayListView, 0, LVIS_SELECTED,
                              LVIS_SELECTED);

        SetGatewayButtons();
        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

LRESULT CIpSettingsPage::OnAutoMetric(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    BOOL fEnable = FALSE;
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        fEnable = !IsDlgButtonChecked(IDC_AUTO_METRIC);
        ::EnableWindow(GetDlgItem(IDC_STATIC_IF_METRIC), fEnable);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_METRIC), fEnable);

        if (!fEnable)
        {
            ::SetWindowText(GetDlgItem(IDC_IPADDR_METRIC), _T(""));
        }

        PageModified();
        break;
    }

    return 0;
}

void CIpSettingsPage::SetIpInfo()
{
    Assert(m_hIpListView);

    BOOL ret = ListView_DeleteAllItems(m_hIpListView);
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    // if DHCP is enabled, show it in the listview
    if (m_pAdapterInfo->m_fEnableDhcp)
    {
        EnableIpButtons(FALSE);

        lvItem.iItem=0;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)SzLoadIds(IDS_DHCPENABLED_TEXT);

        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    }
    else
    {
        EnableIpButtons(TRUE);

        VSTR_ITER iterIpAddress = m_pAdapterInfo->m_vstrIpAddresses.begin();
        VSTR_ITER iterSubnetMask = m_pAdapterInfo->m_vstrSubnetMask.begin();

        int item=0;

        for(; iterIpAddress != m_pAdapterInfo->m_vstrIpAddresses.end() ;
            ++iterIpAddress, ++iterSubnetMask)
        {
            if(**iterIpAddress == L"")
                continue;

            // Add the IP address to the list box
            lvItem.iItem=item;
            lvItem.iSubItem=0;
            lvItem.pszText=(PWSTR)(*iterIpAddress)->c_str();

            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM,
                               item, (LPARAM)&lvItem);

            // Add the subnet and increment the item
            tstring strSubnetMask;

            if (iterSubnetMask == m_pAdapterInfo->m_vstrSubnetMask.end())
                strSubnetMask = L"0.0.0.0";
            else
                strSubnetMask = **iterSubnetMask;

            lvItem.iItem=item;
            lvItem.iSubItem=1;
            lvItem.pszText=(PWSTR)strSubnetMask.c_str();

            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEMTEXT,
                               item, (LPARAM)&lvItem);
            ++item;
        }
    }
}

void CIpSettingsPage::SetIpButtons()
{
    if (!m_pAdapterInfo->m_fEnableDhcp)
    {
        Assert(m_hRemoveIp);
        Assert(m_hEditIp);
        Assert(m_hAddIp);
        Assert(m_hIpListView);

        int nCount = ListView_GetItemCount(m_hIpListView);

        ::EnableWindow(m_hRemoveIp, nCount);
        ::EnableWindow(m_hEditIp, nCount);

        if (nCount == 0)
        {
            // remove the default on the remove button
            ::SendMessage(m_hRemoveIp, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            ::SetFocus(m_hIpListView);
        }
    }
}

void CIpSettingsPage::SetGatewayButtons()
{
    int nCount = ListView_GetItemCount(m_hGatewayListView);

    ::EnableWindow(m_hAddGateway, nCount < MAX_GATEWAY);
    ::EnableWindow(m_hRemoveGateway, nCount);
    ::EnableWindow(m_hEditGateway, nCount);

    if (nCount == 0)
    {
        // remove the default on the remove button
        ::SendMessage(m_hRemoveGateway, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        ::SetFocus(m_hGatewayListView);
    }
    else if (nCount == MAX_GATEWAY)
    {
        ::SetFocus(m_hEditGateway);
    }
}

void CIpSettingsPage::UpdateGatewayList()
{
    // update the gateway address list for the specified adapter
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGateway);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric);

    int nCount = ListView_GetItemCount(m_hGatewayListView);

    for (int j=0; j< nCount; j++)
    {
        WCHAR buf[IP_LIMIT];
        LV_ITEM lvItem;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        lvItem.iItem = j;

        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hGatewayListView, &lvItem);
        m_pAdapterInfo->m_vstrDefaultGateway.push_back(new tstring(buf));

        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hGatewayListView, &lvItem);
        _ltot((INT)lvItem.lParam, buf, 10);
        m_pAdapterInfo->m_vstrDefaultGatewayMetric.push_back(new tstring(buf));
    }
}

void CIpSettingsPage::SetGatewayInfo()
{
    Assert(m_hGatewayListView);

    BOOL ret = ListView_DeleteAllItems(m_hGatewayListView);
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    VSTR_ITER iterGateway = m_pAdapterInfo->m_vstrDefaultGateway.begin();
    VSTR_ITER iterMetric = m_pAdapterInfo->m_vstrDefaultGatewayMetric.begin();

    WCHAR buf[256] = {0};

    int cItem = 0;
    for(; iterGateway != m_pAdapterInfo->m_vstrDefaultGateway.end() ;
        ++iterGateway )
    {
        if(**iterGateway == L"")
            continue;

        lvItem.iItem=cItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)(*iterGateway)->c_str();
        if (iterMetric == m_pAdapterInfo->m_vstrDefaultGatewayMetric.end())
        {
            lvItem.lParam = (LPARAM)c_dwDefaultMetricOfGateway;
        }
        else
        {
            PWSTR pszEnd;
            lvItem.lParam = wcstoul((*iterMetric)->c_str(), &pszEnd, 0);
            if (!lvItem.lParam)
                lvItem.lParam = (LPARAM)c_dwDefaultMetricOfGateway;
            ++iterMetric;
        }

        cItem = SendDlgItemMessage(IDC_IPADDR_GATE, LVM_INSERTITEM,
                                          0, (LPARAM)&lvItem);
        lvItem.iItem = cItem;
        lvItem.iSubItem=1;
        lvItem.pszText = buf;

        if (0 == lvItem.lParam)
        {
            lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
        }
        else
        {
            _ltot((INT)lvItem.lParam, buf, 10);
        }

        
        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT,
                           lvItem.iItem, (LPARAM)&lvItem);
        cItem++;
    }

    ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
    ListView_SetItemState(m_hGatewayListView, 0, LVIS_SELECTED, LVIS_SELECTED);
}

void CIpSettingsPage::EnableIpButtons(BOOL fState)
{
    Assert(m_hAddIp);
    Assert(m_hEditIp);
    Assert(m_hRemoveIp);

    if (m_hAddIp && m_hEditIp && m_hRemoveIp)
    {
        ::EnableWindow(m_hAddIp, fState);
        ::EnableWindow(m_hEditIp, fState);
        ::EnableWindow(m_hRemoveIp, fState);
    }
}

////////////////////////////////////////////////////////////////////
/// Add, Edit, and Remove dialog for IP address
/// Dialog creation overides
//
//  iIndex - the index of the IP address in the list view of the parent dlg
//              -1 if this is a new address
CAddressDialog::CAddressDialog(CIpSettingsPage * pDlgAdv,
                               const DWORD* adwHelpIDs,
                               int iIndex)
{
    m_pParentDlg = pDlgAdv;
    m_hButton = 0;

    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CAddressDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    // replace the "Text" button with the add or edit
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAdd.c_str());

    m_ipAddress.Create(m_hWnd,IDC_IPADDR_ADV_CHANGEIP_IP);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipSubnetMask.Create(m_hWnd, IDC_IPADDR_ADV_CHANGEIP_SUB);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_ADVIP);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                 SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_strNewIpAddress.c_str());
        m_ipSubnetMask.SetAddress(m_strNewSubnetMask.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_strNewIpAddress = L"";
        m_strNewSubnetMask = L"";
        // the ip and subnet are blank, so there's nothing to add
        ::EnableWindow(m_hButton, FALSE);
    }

    return 0;
}

LRESULT CAddressDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAddressDialog::OnHelp(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAddressDialog::OnChangeIp(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        OnIpChange();
        break;

    case EN_SETFOCUS:
        OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_IP);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddressDialog::OnChangeSub(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        OnSubnetChange();
        break;

    case EN_SETFOCUS:
        OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_SUB);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddressDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_IPADDR_ADV_CHANGEIP_IP:
        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh, TRUE);

        break;

    case IDC_IPADDR_ADV_CHANGEIP_SUB:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}


void CAddressDialog::OnIpChange()
{
    Assert(m_hButton);

    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);
}

void CAddressDialog::OnSubnetChange()
{
    OnIpChange();
}

void CAddressDialog::OnEditSetFocus(WORD nId)
{
    if (nId != IDC_IPADDR_ADV_CHANGEIP_SUB)
        return;

    tstring strSubnetMask;
    tstring strIpAddress;

    // if the subnet mask is blank, create a mask and insert it into the control
    if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
    {
        m_ipAddress.GetAddress(&strIpAddress);

        // generate the mask and update the control, and internal structure
        GenerateSubnetMask(m_ipAddress, &strSubnetMask);
        m_ipSubnetMask.SetAddress(strSubnetMask.c_str());
    }
}

LRESULT CAddressDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    // set the subnet Mask
    OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_SUB);
    tstring strIp;
    tstring strSubnetMask;

    // Get the current address from the control and add them to the adapter if valid
    m_ipAddress.GetAddress(&strIp);
    m_ipSubnetMask.GetAddress(&strSubnetMask);

    if (!IsContiguousSubnet(strSubnetMask.c_str()))
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 IDS_ERROR_UNCONTIGUOUS_SUBNET,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipSubnetMask);
        return 0;
    }

    IP_VALIDATION_ERR err = IsValidIpandSubnet(strIp.c_str(), strSubnetMask.c_str());

    if (ERR_NONE != err)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 GetIPValidationErrorMessageID(err),
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipAddress);
        return 0;
    }
    

    int     iIndex = SearchListViewItem(m_pParentDlg->m_hIpListView, 0, strIp.c_str());
    if (-1 != iIndex && iIndex != m_iIndex)
    {
        NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_DUP_IPADDRESS,
                MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                strIp.c_str());
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and add them to the adapter if valid
        m_strNewIpAddress = strIp;
        m_strNewSubnetMask = strSubnetMask;
        m_pParentDlg->m_fModified = TRUE;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_strNewIpAddress || strSubnetMask != m_strNewSubnetMask)
        {
            m_strNewIpAddress = strIp; // update save addresses
            m_strNewSubnetMask = strSubnetMask;
            m_pParentDlg->m_fModified = TRUE;

            EndDialog(IDOK);
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    return 0;
}

LRESULT CAddressDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CAddressDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
///////////////////////////////////////////////////////////////////////////////
/// Add, Edit, and Remove dialog for Gateway address
/// Dialog creation overides

CGatewayDialog::CGatewayDialog(CIpSettingsPage * pDlgAdv,
                               const DWORD* adwHelpIDs,
                               int  iIndex) :
    m_fValidMetric(TRUE),
    m_iIndex (iIndex)
{
    m_pParentDlg = pDlgAdv;
    m_hButton = 0;

    m_adwHelpIDs = adwHelpIDs;
}

LRESULT CGatewayDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // replace the "Text" button with the add or edit

    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAdd.c_str());

    m_ipGateAddress.Create(m_hWnd,IDC_IPADDR_ADV_CHANGE_GATEWAY);
    m_ipGateAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);
    SendDlgItemMessage(IDC_IPADDR_ADV_CHANGE_METRIC, EM_LIMITTEXT, MAX_METRIC_DIGITS, 0);

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_GATE);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_strNewGate.size())
    {
        m_ipGateAddress.SetAddress(m_strNewGate.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_strNewGate = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    //initialize the metric controls
    BOOL fAutoMetric = (0 == m_uiNewMetric);
    CheckDlgButton(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC, fAutoMetric);
    if (fAutoMetric)
    {
        SetDlgItemText(IDC_IPADDR_ADV_CHANGE_METRIC, L"");
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC_STATIC), FALSE);
    }
    else
    {
        SetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, m_uiNewMetric);
    }
    m_fValidMetric = TRUE;

    return TRUE;
}

LRESULT CGatewayDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CGatewayDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CGatewayDialog::OnGatewayChange(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        Assert(m_hButton);

        if (m_ipGateAddress.IsBlank() || !m_fValidMetric)
            ::EnableWindow(m_hButton, FALSE);
        else
            ::EnableWindow(m_hButton, TRUE);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CGatewayDialog::OnMetricChange(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        if (!IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC))
        {
            BOOL bTranslated;
            UINT nValue;

            nValue = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, &bTranslated,
                               FALSE);
            m_fValidMetric = bTranslated;
            if (!m_fValidMetric || m_ipGateAddress.IsBlank())
                ::EnableWindow(m_hButton, FALSE);
            else
                ::EnableWindow(m_hButton, TRUE);
        }
       
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CGatewayDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };


    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh, TRUE);

    return 0;
}

LRESULT CGatewayDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    tstring strGateway;
    m_ipGateAddress.GetAddress(&strGateway);

    // Validate
    if (!FIsIpInRange(strGateway.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    int iIndex = -1;
    iIndex = SearchListViewItem(m_pParentDlg->m_hGatewayListView, 0, strGateway.c_str());
    if (-1 != iIndex && iIndex != m_iIndex)
    {
        NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_DUP_GATEWAY,
                MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                strGateway.c_str());

        return 0;
    }

    BOOL bTranslated;

    UINT uiMetric = 0;
    //Get the metric. If auto-metric is selected, the metric valud is 0.
    //Otherwise get the metric value from the edit control
    if (!IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC))
    {
        uiMetric = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, 
                                    &bTranslated,
                                    FALSE);
        if (uiMetric < 1 || uiMetric > MAX_METRIC)
        {
            HWND hFocus = NULL;
            TCHAR szBuf[32] = {0};
            wsprintf(szBuf, L"%u", MAX_METRIC);
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_METRIC,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK, szBuf);
            hFocus = GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC);
            if (hFocus)
            {
                ::SetFocus(hFocus);
            }
            return 0;
        }
    }
    
    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and add them to the adapter if valid
        m_strNewGate = strGateway;
        m_uiNewMetric = uiMetric;
        m_pParentDlg->m_fModified = TRUE;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strGateway != m_strNewGate || uiMetric != m_uiNewMetric)
        {
            m_pParentDlg->m_fModified = TRUE;
            m_strNewGate = strGateway;
            m_uiNewMetric = uiMetric;

            EndDialog(IDOK);
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    return 0;
}

LRESULT CGatewayDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CGatewayDialog::OnAutoMetric(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    BOOL fEnable = FALSE;
    BOOL bTranslated;
    UINT nValue;
    
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        fEnable = !IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC_STATIC), fEnable);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), fEnable);

        if (!fEnable)
        {
            ::SetWindowText(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), _T(""));
            m_fValidMetric = TRUE;
        }
        else
        {
            nValue = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, &bTranslated,
                               FALSE);

            m_fValidMetric = bTranslated;
        }


        if (m_ipGateAddress.IsBlank())
        {
            ::EnableWindow(m_hButton, FALSE);
        }
        else if (!fEnable)
        {
            //if the ip address has been filled in and we are using auto-metric,
            //enable the "OK" button
            ::EnableWindow(m_hButton, TRUE);
        }
        else
        {
            //if the address has been fileed in and we are using manual metric,
            //disable the "OK" button when the metric edit box doesn't contain
            //valid number
            
            ::EnableWindow(m_hButton, m_fValidMetric);
        }

        
        break;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CGatewayDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgaddr.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R . H
//
//  Contents:   CTcpAddrPage declaration
//
//  Notes:  CTcpAddrPage is the IP Address page
//
//  Author: tongl   5 Nov 1997
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"
#include "dlgbkup.h"

class CTcpAddrPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpAddrPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control message handlers

        // Mesg handler for the DHCP Radio button
        COMMAND_ID_HANDLER(IDC_IP_DHCP, OnDhcpButton)

        // Mesg handler for the "specify IP address" Radio button
        COMMAND_ID_HANDLER(IDC_IP_FIXED, OnFixedButton)

        // Mesg handler for the DHCP Radio button
        COMMAND_ID_HANDLER(IDC_DNS_DHCP, OnDnsDhcp)

        // Mesg handler for the "specify IP address" Radio button
        COMMAND_ID_HANDLER(IDC_DNS_FIXED, OnDnsFixed)

        // Mesg handler for the "Advanced" push button
        COMMAND_ID_HANDLER(IDC_IPADDR_ADVANCED, OnAdvancedButton)

        // Notification handlers for the IP address edit boxes
        COMMAND_ID_HANDLER(IDC_IPADDR_IP,    OnIpAddrIp)
        COMMAND_ID_HANDLER(IDC_IPADDR_SUB,   OnIpAddrSub)
        COMMAND_ID_HANDLER(IDC_IPADDR_GATE,  OnIpAddrGateway)

        COMMAND_ID_HANDLER(IDC_DNS_PRIMARY,    OnDnsPrimary)
        COMMAND_ID_HANDLER(IDC_DNS_SECONDARY,  OnDnsSecondary)

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()

    // Constructors/Destructors
    CTcpAddrPage(CTcpipcfg * ptcpip, const DWORD * phelpIDs = NULL);
    ~CTcpAddrPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command ID handlers
    LRESULT OnDhcpButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnFixedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnDnsDhcp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDnsFixed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAdvancedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // notify code hanlders for the IP edit controls
    LRESULT OnIpAddrIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrGateway(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnDnsPrimary(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDnsSecondary(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    friend class CIpSettingsPage;
    friend class CTcpDnsPage;
    friend class CTcpWinsPage;
    friend class CAtmArpcPage;
    friend class CTcpOptionsPage;
    friend class CTcpRasPage;

// Implementation
private:

    // initializes control state and values
    void SetInfo();

    // update values in m_pAdapterInfo with what's in the controls
    void UpdateInfo();
    void UpdateAddressList(VSTR * pvstrList,IpControl& ipPrimary,IpControl& ipSecondary);

    int  DoPropertySheet(ADAPTER_INFO * pAdapterDlg, GLOBAL_INFO * pGlbDlg);
    HRESULT HrSetupPropPages(ADAPTER_INFO * pAdapterDlg,
                             GLOBAL_INFO * pGlbDlg,
                             HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    void EnableGroup(BOOL fEnableDhcp);
    void EnableStaticDns(BOOL fUseStaticDns);

    void SetSubnetMask();

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { 
                            if (!m_fSetInitialValue)
                            {
                                m_fModified = TRUE; 
                                PropSheet_Changed(GetParent(), m_hWnd);
                            }
                        }

    BOOL FAlreadyWarned(tstring strIp)
    {
        BOOL fRet = FALSE;

        VSTR_ITER iterIpBegin = m_vstrWarnedDupIpList.begin();
        VSTR_ITER iterIpEnd = m_vstrWarnedDupIpList.end();
        VSTR_ITER iterIp = iterIpBegin;

        for( ; iterIp != iterIpEnd; iterIp++)
        {
            if (strIp == **iterIp)
            {
                fRet = TRUE;
                break;
            }
        }
        return fRet;
    }

    void ShowOrHideBackupPage();

    // data members
    CTcpipcfg *     m_ptcpip;
    ConnectionType  m_ConnType;
    ADAPTER_INFO *  m_pAdapterInfo;
    const DWORD*    m_adwHelpIDs;

    BOOL    m_fModified;

    BOOL    m_fPropShtOk;
    BOOL    m_fPropShtModified;
    BOOL    m_fLmhostsFileReset;
//IPSec is removed from connection UI		
//    BOOL    m_fIpsecPolicySet;

    BOOL            m_fSetInitialValue;

    BOOL    m_fRasNotAdmin;

    IpControl       m_ipAddress;
    IpControl       m_ipSubnetMask;
    IpControl       m_ipDefGateway;
    IpControl       m_ipDnsPrimary;
    IpControl       m_ipDnsSecondary;

    VSTR    m_vstrWarnedDupIpList;

    class CIpSettingsPage  * m_pIpSettingsPage;
    class CTcpDnsPage     * m_pTcpDnsPage;
    class CTcpWinsPage    * m_pTcpWinsPage;
    class CAtmArpcPage    * m_pAtmArpcPage;
    class CTcpOptionsPage * m_pTcpOptionsPage;
    class CTcpRasPage     * m_pTcpRasPage;

    CIpBackUpDlg         m_pageBackup;
    HPROPSHEETPAGE       m_hBackupPage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgaddrm.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R M . H
//
//  Contents:   Declaration of CAdvIPAddrPage, CAddressDialog and
//              CGatewayDialog
//
//  Notes:  CAdvIPAddrPage is the IP setting page
//
//  Author: tongl   5 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ipctrl.h"
#include "tcperror.h"

#include <ncxbase.h>
#include <ncatlps.h>

// Number of columns in the IDS_IPADDRESS_TEXT listview
const int c_nColumns = 2;

class CIpSettingsPage : public CPropSheetPage
{
public:

    BEGIN_MSG_MAP(CIpSettingsPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        COMMAND_ID_HANDLER(IDC_IPADDR_ADDIP,            OnAddIp);
        COMMAND_ID_HANDLER(IDC_IPADDR_EDITIP,           OnEditIp);
        COMMAND_ID_HANDLER(IDC_IPADDR_REMOVEIP,         OnRemoveIp);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADDGATE,          OnAddGate);
        COMMAND_ID_HANDLER(IDC_IPADDR_EDITGATE,         OnEditGate);
        COMMAND_ID_HANDLER(IDC_IPADDR_REMOVEGATE,       OnRemoveGate);

        COMMAND_ID_HANDLER(IDC_AUTO_METRIC,           OnAutoMetric)

    END_MSG_MAP()

public:

    CIpSettingsPage(CTcpAddrPage * pTcpAddrPage, 
                    ADAPTER_INFO * pAdapterInfo, 
                    const DWORD* pamhidsHelp = NULL);
    ~CIpSettingsPage();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnAddIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAddGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAutoMetric(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnGatewaySelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAddressDialog;
    friend class CGatewayDialog;

private:

    // functions
    void    SetIpInfo();
    void    SetIpButtons();
    void    UpdateIpList();

    void    SetGatewayInfo();
    void    SetGatewayButtons();
    void    UpdateGatewayList();

    void    EnableIpButtons(BOOL fState);

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    // data members
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    const  DWORD *  m_adwHelpIDs;

    BOOL m_fModified;

    // are we adding or editting
    BOOL        m_fEditState;  
    tstring     m_strAdd;

    HWND        m_hIpListView;      // IP/Subnet list view
    HWND        m_hAddIp;           // IP buttons
    HWND        m_hEditIp;
    HWND        m_hRemoveIp;

    HWND        m_hGatewayListView;
    HWND        m_hAddGateway;
    HWND        m_hEditGateway;
    HWND        m_hRemoveGateway;

    tstring     m_strRemovedIpAddress;
    tstring     m_strRemovedSubnetMask;
    tstring     m_strRemovedGateway;
    UINT        m_uiRemovedMetric;
};

class CAddressDialog : public CDialogImpl<CAddressDialog>
{
public:

    enum { IDD = IDD_IPADDR_ADV_CHANGEIP };

    BEGIN_MSG_MAP(CAddressDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGEIP_IP, OnChangeIp)
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGEIP_SUB, OnChangeSub)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()
//
public:
    CAddressDialog( CIpSettingsPage * pDlgAdvanced, 
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CAddressDialog(){};

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChangeIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnChangeSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Command Handlers
public:
    
    void    OnIpChange();
    void    OnSubnetChange();
    void    OnEditSetFocus(WORD nId);

public:
    IpControl   m_ipAddress;
    IpControl   m_ipSubnetMask;
    tstring     m_strNewIpAddress;     // either the one added, or edited
    tstring     m_strNewSubnetMask;    // either the one added, or edited

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hButton;     

    CIpSettingsPage * m_pParentDlg;

    const   DWORD * m_adwHelpIDs;

    int     m_iIndex;
};

class CGatewayDialog : public CDialogImpl<CGatewayDialog>
{
public:

    enum { IDD = IDD_IPADDR_ADV_CHANGEGATE };

    BEGIN_MSG_MAP(CAddressDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_GATEWAY, OnGatewayChange);
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_METRIC, OnMetricChange);
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC, OnAutoMetric)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)
    END_MSG_MAP()

public:
    CGatewayDialog( CIpSettingsPage * pDlgAdvanced,
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CGatewayDialog(){};

public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnGatewayChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMetricChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAutoMetric(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);  

// Dialog creation overides
public:
   
    IpControl   m_ipGateAddress;
    tstring     m_strNewGate;          // either the one added, or edited
    UINT        m_uiNewMetric;

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hButton;     

    CIpSettingsPage * m_pParentDlg;

    const   DWORD * m_adwHelpIDs;

    BOOL    m_fValidMetric;

    int     m_iIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\srvrobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R O B J . H
//
//  Contents:   Declaration of CSrvrcfg and helper functions.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include "ncmisc.h"
#include "resource.h"

struct SERVER_DLG_DATA
{
    DWORD       dwSize;         // corresponds to Size value in registry
    BOOL        fAnnounce;      // corresponds to Lmannounce value
    BOOL        fLargeCache;    // LargeSystemCache in Control\SessionManager
                                // \MemoryManagement
};

/////////////////////////////////////////////////////////////////////////////
// Srvrcfg

class ATL_NO_VTABLE CSrvrcfg :
    public CComObjectRoot,
    public CComCoClass<CSrvrcfg, &CLSID_CSrvrcfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi
{
public:
    CSrvrcfg();
    ~CSrvrcfg();

    BEGIN_COM_MAP(CSrvrcfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSrvrcfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SRVRCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFomBuildNo);
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // Accessors for Server dialog data
    const SERVER_DLG_DATA *DlgData() const
        {return (const SERVER_DLG_DATA *)&m_sdd;};
    SERVER_DLG_DATA *DlgDataRW() {return &m_sdd;};
    VOID SetDirty() {m_fDirty = TRUE;};

    SERVER_DLG_DATA     m_sdd;

private:
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrOpenRegKeys(INetCfg *);
    HRESULT HrGetRegistryInfo(BOOL fInstalling);
    HRESULT HrSetRegistryInfo(VOID);
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages);
    VOID CleanupPropPages(VOID);
    HRESULT HrRestoreRegistry(VOID);

    INetCfgComponent    *m_pncc;            // Place to keep my component

    // number of property sheet pages
    enum PAGES
    {
        c_cPages = 1
    };

    // Generic dialog data
    CPropSheetPage *    m_apspObj[c_cPages];// pointer to each of the prop
                                            // sheet page objects
    BOOL                m_fDirty;

    HKEY                m_hkeyMM;           // Memory Management key
    BOOL                m_fOneTimeInstall;  // TRUE if we're in install mode
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file
    BOOL                m_fUpgradeFromWks;  // TRUE if we are upgrading from
                                            // workstation product
    BOOL                m_fRestoredRegistry;// TRUE if registry has been
                                            // restored on upgrade

    PRODUCT_FLAVOR      m_pf;

    tstring             m_strAutoTunedRestoreFile;
    tstring             m_strSharesRestoreFile;
    tstring             m_strParamsRestoreFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgatm.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A T M . C P P
//
//  Contents:   CTcpArpcPage and CATMAddressDialog implementation
//
//  Notes:  The "ARP Client" page and dialog
//
//  Author: tongl  1 July 1997  Created
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "tcphelp.h"

#include "atmcommon.h"

#include "dlgatm.h"
#include "dlgaddr.h"

/////////////////////////////////////////////////////////////////
//
// CAtmArpcPage
//
/////////////////////////////////////////////////////////////////

// Message map functions
LRESULT CAtmArpcPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    m_hMTUEditBox = GetDlgItem(IDC_EDT_ATM_MaxTU);
    Assert(m_hMTUEditBox);

    // ARP Server
    m_hArps.m_hList      = GetDlgItem(IDC_LBX_ATM_ArpsAddrs);
    m_hArps.m_hAdd       = GetDlgItem(IDC_PSB_ATM_ArpsAdd);
    m_hArps.m_hEdit      = GetDlgItem(IDC_PSB_ATM_ArpsEdt);
    m_hArps.m_hRemove    = GetDlgItem(IDC_PSB_ATM_ArpsRmv);
    m_hArps.m_hUp        = GetDlgItem(IDC_PSB_ATM_ArpsUp);
    m_hArps.m_hDown      = GetDlgItem(IDC_PSB_ATM_ArpsDown);

    // MAR Server
    m_hMars.m_hList       = GetDlgItem(IDC_LBX_ATM_MarsAddrs);
    m_hMars.m_hAdd        = GetDlgItem(IDC_PSB_ATM_MarsAdd);
    m_hMars.m_hEdit       = GetDlgItem(IDC_PSB_ATM_MarsEdt);
    m_hMars.m_hRemove     = GetDlgItem(IDC_PSB_ATM_MarsRmv);
    m_hMars.m_hUp         = GetDlgItem(IDC_PSB_ATM_MarsUp);
    m_hMars.m_hDown       = GetDlgItem(IDC_PSB_ATM_MarsDown);

    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_PSB_ATM_ArpsUp, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_PSB_ATM_ArpsDown, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    SendDlgItemMessage(IDC_PSB_ATM_MarsUp, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_PSB_ATM_MarsDown, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Set MTU edit box length
    ::SendMessage(m_hMTUEditBox, EM_SETLIMITTEXT, MAX_MTU_LENGTH, 0);

    return 0;
}

LRESULT CAtmArpcPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmArpcPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// Notify handlers for the property page
LRESULT CAtmArpcPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    SetInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CAtmArpcPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // All error values are loaded and then checked here
    // while all non-error values are checked in OnApply
    BOOL err = FALSE; // Allow page to lose active status

    // In non-PVC only mode, if either of the list boxes (ARPS or MARS)
    // is empty for any bound atm card, we can't leave the page.
    if (BST_UNCHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY))
    {
        int nArps = Tcp_ListBox_GetCount(m_hArps.m_hList);
        int nMars = Tcp_ListBox_GetCount(m_hMars.m_hList);

        if ((nArps==0) || (nMars ==0))
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_ATMSERVERLIST,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            err = TRUE;
        }
    }

    // MTU value
    WCHAR szData[MAX_MTU_LENGTH+1];
    szData[0]= 0;
    ::GetWindowText(GetDlgItem(IDC_EDT_ATM_MaxTU), szData, MAX_MTU_LENGTH+1);

    // check the range of the number
    PWSTR pStr;
    unsigned long num = wcstoul(szData, &pStr, 10);

    int nId = IDS_MTU_RANGE_WORD;

    if (num < MIN_MTU || num > MAX_MTU)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 nId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        ::SetFocus(m_hMTUEditBox);

        err = TRUE;
    }

    if (!err)
    {
        UpdateInfo();
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CAtmArpcPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    UpdateInfo();

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CAtmArpcPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CAtmArpcPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

// Control message handlers

// PVC Only
LRESULT CAtmArpcPage::OnPVCOnly(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    BOOL fChecked = (BST_CHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY));
    if (fChecked != m_pAdapterInfo->m_fPVCOnly)
    {
        PageModified();
    }

    EnableGroup(!fChecked);

    return 0;
}

// ARP server controls
LRESULT CAtmArpcPage::OnArpServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAtmArpcPage::OnAddArps(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hArps.m_hList;
    OnServerAdd(m_hArps, c_szArpServer);
    return 0;
}

LRESULT CAtmArpcPage::OnEditArps(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hArps.m_hList;
    OnServerEdit(m_hArps, c_szArpServer);
    return 0;
}

LRESULT CAtmArpcPage::OnRemoveArps(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    BOOL fRemoveArps = TRUE;
    OnServerRemove(m_hArps, fRemoveArps);
    return 0;
}

LRESULT CAtmArpcPage::OnArpsUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    OnServerUp(m_hArps);
    return 0;
}

LRESULT CAtmArpcPage::OnArpsDown(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    OnServerDown(m_hArps);
    return 0;
}

// MAR server controls
LRESULT CAtmArpcPage::OnMarServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAtmArpcPage::OnAddMars(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hMars.m_hList;
    OnServerAdd(m_hMars, c_szMarServer);
    return 0;
}

LRESULT CAtmArpcPage::OnEditMars(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hMars.m_hList;
    OnServerEdit(m_hMars, c_szMarServer);
    return 0;
}

LRESULT CAtmArpcPage::OnRemoveMars(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    BOOL fRemoveArps = FALSE;
    OnServerRemove(m_hMars, fRemoveArps);
    return 0;
}

LRESULT CAtmArpcPage::OnMarsUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    OnServerUp(m_hMars);
    return 0;
}

LRESULT CAtmArpcPage::OnMarsDown(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    OnServerDown(m_hMars);
    return 0;
}

LRESULT CAtmArpcPage::OnMaxTU(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case EN_CHANGE:
            PageModified();
            break;
    }
    return 0;
}
//
// Helper functions
//

// Update the server addresses and MTU of the deselected card
void CAtmArpcPage::UpdateInfo()
{
    // PVC Only
    m_pAdapterInfo->m_fPVCOnly =
        (BST_CHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY));

    // Update ARP server address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrARPServerList);
    int nCount = Tcp_ListBox_GetCount(m_hArps.m_hList);

    WCHAR szARPS[MAX_ATM_ADDRESS_LENGTH+1];
    for (int i=0; i< nCount; i++)
    {
        Tcp_ListBox_GetText(m_hArps.m_hList, i, szARPS);
        m_pAdapterInfo->m_vstrARPServerList.push_back(new tstring(szARPS));
    }

    // Update MAR server address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrMARServerList);
    nCount = Tcp_ListBox_GetCount(m_hMars.m_hList);

    WCHAR szMARS[MAX_ATM_ADDRESS_LENGTH+1];
    for (i=0; i< nCount; i++)
    {
        Tcp_ListBox_GetText(m_hMars.m_hList, i, szMARS);
        m_pAdapterInfo->m_vstrMARServerList.push_back(new tstring(szMARS));
    }

    // MTU
    WCHAR szMTU[MAX_MTU_LENGTH+1];
    GetDlgItemText(IDC_EDT_ATM_MaxTU, szMTU, MAX_MTU_LENGTH+1);
    m_pAdapterInfo->m_dwMTU = _wtoi(szMTU);
}

// Set the other controls according to the current adapter
void CAtmArpcPage::SetInfo()
{
    Assert(m_pAdapterInfo);

    if (m_pAdapterInfo != NULL)
    {
        Assert (m_pAdapterInfo->m_fIsAtmAdapter);

        if (m_pAdapterInfo->m_fIsAtmAdapter)
        {
            // ARP server IDC_LBX_ATM_ArpsAddrs
            int nResult;

            Tcp_ListBox_ResetContent(m_hArps.m_hList);

            for(VSTR_ITER iterARPServer = m_pAdapterInfo->m_vstrARPServerList.begin();
                iterARPServer != m_pAdapterInfo->m_vstrARPServerList.end() ;
                ++iterARPServer)
            {
                nResult = Tcp_ListBox_InsertString(m_hArps.m_hList, -1,
                                                   (*iterARPServer)->c_str());
            }

            // set slection to first item
            if (nResult >= 0)
                Tcp_ListBox_SetCurSel(m_hArps.m_hList, 0);

            // MAR server IDC_LBX_ATM_MarsAddrs
            Tcp_ListBox_ResetContent(m_hMars.m_hList);

            for(VSTR_ITER iterMARServer = m_pAdapterInfo->m_vstrMARServerList.begin();
                iterMARServer != m_pAdapterInfo->m_vstrMARServerList.end() ;
                ++iterMARServer)
            {
                nResult = Tcp_ListBox_InsertString(m_hMars.m_hList, -1,
                                                   (*iterMARServer)->c_str());
            }

            // set slection to first item
            if (nResult >= 0)
                Tcp_ListBox_SetCurSel(m_hMars.m_hList, 0);

            // MTU
            WCHAR szBuf[MAX_MTU_LENGTH];
            wsprintfW(szBuf, c_szItoa, m_pAdapterInfo->m_dwMTU);
            SetDlgItemText(IDC_EDT_ATM_MaxTU, szBuf);

            // Set push buttons state
            SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
            SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);

            // Set PVC Only check box
            CheckDlgButton(IDC_CHK_ATM_PVCONLY, m_pAdapterInfo->m_fPVCOnly);
            if(m_pAdapterInfo->m_fPVCOnly)
            {
                EnableGroup(FALSE);
            }
        }
    }
    return;
}

void CAtmArpcPage::EnableGroup(BOOL fEnable)
{
    ::EnableWindow(GetDlgItem(IDC_LBX_ATM_ArpsAddrs), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsAdd), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsEdt), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsRmv), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsUp), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsDown), fEnable);

    ::EnableWindow(GetDlgItem(IDC_LBX_ATM_MarsAddrs), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsAdd), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsEdt), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsRmv), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsUp), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsDown), fEnable);

    if (fEnable)
    {
        // Set push buttons state
        SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
        SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);
    }
}

void CAtmArpcPage::OnServerAdd(HANDLES hGroup, PCTSTR pszTitle)
{
    m_fEditState = FALSE;
    CAtmAddressDialog * pDlgSrv = new CAtmAddressDialog(this, g_aHelpIDs_IDD_ATM_ADDR);

    pDlgSrv->SetTitle(pszTitle);

    if (pDlgSrv->DoModal() == IDOK)
    {
        tstring strNewAddress;
        if (!lstrcmpW(pszTitle, c_szArpServer))
        {
            strNewAddress = m_strNewArpsAddress;

            // empty strings, this removes the saved address
            m_strNewArpsAddress = c_szEmpty;
        }
        else
        {
            Assert(!lstrcmpW(pszTitle, c_szMarServer));
            strNewAddress = m_strNewMarsAddress;

            // empty strings, this removes the saved address
            m_strNewMarsAddress = c_szEmpty;
        }
        int idx = Tcp_ListBox_InsertString(hGroup.m_hList,
                                           -1,
                                           strNewAddress.c_str());

        PageModified();

        Assert(idx >= 0);
        if (idx >= 0)
        {
            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
            SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
        }
    }

    // release dialog object
    delete pDlgSrv;
}

void CAtmArpcPage::OnServerEdit(HANDLES hGroup, PCWSTR pszTitle)
{
    m_fEditState = TRUE;
    Assert(Tcp_ListBox_GetCount(hGroup.m_hList));

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx >= 0);

    // save off the removed address and delete it from the listview
    if (idx >= 0)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        Assert(Tcp_ListBox_GetTextLen(hGroup.m_hList, idx) <= celems(buf));
        Tcp_ListBox_GetText(hGroup.m_hList, idx, buf);

        BOOL fEditArps = !lstrcmpW(pszTitle, c_szArpServer);

        // used by dialog to display what to edit
        if (fEditArps)
        {
            m_strNewArpsAddress = buf;
        }
        else
        {
           m_strNewMarsAddress = buf;
        }

        CAtmAddressDialog * pDlgSrv = new CAtmAddressDialog(this, g_aHelpIDs_IDD_ATM_ADDR);

        pDlgSrv->SetTitle(pszTitle);

        if (pDlgSrv->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(hGroup.m_hList, idx);

            PageModified();

            if (fEditArps)
            {
                m_strMovingEntry = m_strNewArpsAddress;

                // restore the original removed address
                m_strNewArpsAddress = buf;
            }
            else
            {
                m_strMovingEntry = m_strNewMarsAddress;

                // restore the original removed address
                m_strNewMarsAddress = buf;
            }

            ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());
            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
        }
        else
        {
            // empty strings, this removes the saved address
            if (fEditArps)
            {
                m_strNewArpsAddress = c_szEmpty;
            }
            else
            {
                m_strNewMarsAddress = c_szEmpty;
            }
        }

        delete pDlgSrv;
    }
}

void CAtmArpcPage::OnServerRemove(HANDLES hGroup, BOOL fRemoveArps)
{
    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];
        Assert(Tcp_ListBox_GetTextLen(hGroup.m_hList, idx) <= celems(buf));

        Tcp_ListBox_GetText(hGroup.m_hList, idx, buf);

        if (fRemoveArps)
        {
            m_strNewArpsAddress = buf;
        }
        else
        {
            m_strNewMarsAddress = buf;
        }
        Tcp_ListBox_DeleteString(hGroup.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;
        if ((nCount = Tcp_ListBox_GetCount(hGroup.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
        }
        SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
    }
}

void CAtmArpcPage::OnServerUp(HANDLES hGroup)
{
    Assert(m_hArps.m_hList);

    int  nCount = Tcp_ListBox_GetCount(hGroup.m_hList);
    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx != 0);

    if (ListBoxRemoveAt(hGroup.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
    SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
}

void CAtmArpcPage::OnServerDown(HANDLES hGroup)
{
    Assert(hGroup.m_hList);

    int nCount = Tcp_ListBox_GetCount(hGroup.m_hList);
    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(hGroup.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
    SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
}

/////////////////////////////////////////////////////////////////
//
// CAtmAddressDialog
//
/////////////////////////////////////////////////////////////////

CAtmAddressDialog::CAtmAddressDialog(CAtmArpcPage * pAtmArpcPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg   = pAtmArpcPage;
    m_adwHelpIDs   = adwHelpIDs;
    m_hOkButton    = 0;
};

CAtmAddressDialog::~CAtmAddressDialog(){};

LRESULT CAtmAddressDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    // set title
    SetDlgItemText(IDCST_ATM_AddrName, m_szTitle);

    BOOL fEditArps = !lstrcmpW(m_szTitle, c_szArpServer);

    // change the "Ok" button to "Add" if we are not editing

    if (FALSE == m_pParentDlg->m_fEditState)
        SetDlgItemText(IDOK, L"Add");

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog

    RECT rect;

    Assert(m_pParentDlg->m_hAddressList);
    ::GetWindowRect(m_pParentDlg->m_hAddressList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);
    m_hEditBox  =  GetDlgItem(IDC_EDT_ATM_Address);

    // ATM addresses have a 40 character limit + separaters
    ::SendMessage(m_hEditBox, EM_SETLIMITTEXT, MAX_ATM_ADDRESS_LENGTH*1.5, 0);

    // add the address that was just removed
    tstring strNewAddress = fEditArps ? m_pParentDlg->m_strNewArpsAddress : m_pParentDlg->m_strNewMarsAddress;
    if (strNewAddress.size())
    {
        ::SetWindowText(m_hEditBox, strNewAddress.c_str());
        ::SendMessage(m_hEditBox, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        if (fEditArps)
        {
            m_pParentDlg->m_strNewArpsAddress = c_szEmpty;
        }
        else
        {
            m_pParentDlg->m_strNewMarsAddress = c_szEmpty;
        }
        ::EnableWindow(m_hOkButton, FALSE);
    }

    ::SetFocus(m_hEditBox);
    return 0;
}

LRESULT CAtmAddressDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmAddressDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// If the "Ok button is pushed
LRESULT CAtmAddressDialog::OnOk(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szAtmAddress[MAX_ATM_ADDRESS_LENGTH+1];
    int i =0;
    int nId =0;

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEditBox, szAtmAddress, MAX_ATM_ADDRESS_LENGTH+1);

    if (! FIsValidAtmAddress(szAtmAddress, &i, &nId))
    {   // If invalid ATM address, we pop up a message box and set focus
        // back to the edit box

        // REVIEW(tongl): report first invalid character in mesg box
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INCORRECT_ATM_ADDRESS,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_ATM_Address));

        return 0;
    }

    // We check if the newly added or modified string is already in the list,
    // if so, we do not add a duplicate address

    // m_hCurrentAddressList is the handle to either ARPS list or MARS list
    int nCount = Tcp_ListBox_GetCount(m_pParentDlg->m_hAddressList);
    if (nCount) // if the list is not empty
    {
        int i;
        WCHAR szBuff[MAX_ATM_ADDRESS_LENGTH+1];
        for (i=0; i<nCount; i++)
        {
            Tcp_ListBox_GetText(m_pParentDlg->m_hAddressList, i, szBuff);

            if (lstrcmpW(szAtmAddress, szBuff) ==0) // If string is already on the list
            {
                EndDialog(IDCANCEL);
            }
        }
    }

    BOOL fArpsDialog = !lstrcmpW(m_szTitle, c_szArpServer);
    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        if (fArpsDialog)
        {
            m_pParentDlg->m_strNewArpsAddress = szAtmAddress;
        }
        else
        {
            m_pParentDlg->m_strNewMarsAddress = szAtmAddress;
        }
    }
    else // if edit, see if string is having a diferent value now
    {
        if (fArpsDialog)
        {
            if(m_pParentDlg->m_strNewArpsAddress != szAtmAddress)
                m_pParentDlg->m_strNewArpsAddress = szAtmAddress; // update save addresses
            else
                EndDialog(IDCANCEL);
        }
        else
        {
            if(m_pParentDlg->m_strNewMarsAddress != szAtmAddress)
                m_pParentDlg->m_strNewMarsAddress = szAtmAddress; // update save addresses
            else
                EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);

    return 0;
}

// If the "Cancel" button is pushed
LRESULT CAtmAddressDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

// If the edit box contents is changed
LRESULT CAtmAddressDialog::OnChange(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty

    if (::GetWindowText(m_hEditBox, buf, celems(buf)) == 0)
        ::EnableWindow(m_hOkButton, FALSE);
    else
        ::EnableWindow(m_hOkButton, TRUE);

    return 0;
}

void CAtmAddressDialog::SetTitle(PCWSTR pszTitle)
{
    Assert(pszTitle);
    lstrcpyW(m_szTitle, pszTitle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgatm.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A T M . H
//
//  Contents:   CTcpArpcPage and CATMAddressDialog declaration
//
//  Notes:  The "ATM ARP Client" page and dialog
//
//  Author: tongl   1 July 1997  Created
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>

// maximum number of characters in the ARPS and MARS edit control
const int MAX_MTU_LENGTH = 5;
const int MAX_TITLE_LENGTH = 12;

const int NUM_ATMSERVER_LIMIT = 12;

const int MAX_MTU = 65527;
const int MIN_MTU = 9180;

const WCHAR c_szArpServer[] =   L"ARP Server:";
const WCHAR c_szMarServer[] =   L"MAR Server:";

class CAtmArpcPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CAtmArpcPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_CHK_ATM_PVCONLY,     OnPVCOnly)

        COMMAND_ID_HANDLER(IDC_LBX_ATM_ArpsAddrs,   OnArpServer)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsAdd,     OnAddArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsEdt,     OnEditArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsRmv,     OnRemoveArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsUp,      OnArpsUp)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsDown,    OnArpsDown)

        COMMAND_ID_HANDLER(IDC_LBX_ATM_MarsAddrs,   OnMarServer)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsAdd,     OnAddMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsEdt,     OnEditMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsRmv,     OnRemoveMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsUp,      OnMarsUp)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsDown,    OnMarsDown)

        COMMAND_ID_HANDLER(IDC_EDT_ATM_MaxTU,       OnMaxTU)

    END_MSG_MAP()

// Constructors/Destructors
public:

    CAtmArpcPage(CTcpAddrPage * pTcpAddrPage,
                 ADAPTER_INFO * pAdapterDlg,
                 const DWORD * adwHelpIDs = NULL)
    {
        AssertH(pTcpAddrPage);
        AssertH(pAdapterDlg);

        m_pParentDlg = pTcpAddrPage;
        m_pAdapterInfo = pAdapterDlg;
        m_adwHelpIDs = adwHelpIDs;

        m_fModified = FALSE;
    }

    ~CAtmArpcPage(){};

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Control message handlers
    LRESULT OnPVCOnly(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnArpServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAddArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnArpsUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnArpsDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnMarServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAddMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMarsUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMarsDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnMaxTU(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAtmAddressDialog;

private:

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() {   m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    // Update the server addresses and MTU of the deselected card
    void UpdateInfo();
    void SetInfo();
    void EnableGroup(BOOL fEnable);

    void OnServerAdd(HANDLES hwndGroup, PCWSTR szTitle);
    void OnServerEdit(HANDLES hwndGroup, PCWSTR szTitle);
    void OnServerRemove(HANDLES hwndGroup, BOOL fRemoveArps);
    void OnServerUp(HANDLES hwndGroup);
    void OnServerDown(HANDLES hwndGroup);

    // data members

    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    const DWORD *   m_adwHelpIDs;

    BOOL    m_fModified;

    BOOL    m_fEditState;
    HWND    m_hAddressList;

    tstring m_strNewArpsAddress; // either the one added, or edited
    tstring m_strNewMarsAddress;

    tstring m_strMovingEntry;

    HWND        m_hMTUEditBox;
    HANDLES     m_hArps;
    HANDLES     m_hMars;
};

class CAtmAddressDialog : public CDialogImpl<CAtmAddressDialog>
{
public:

    enum { IDD = IDD_ATM_ADDR };

    BEGIN_MSG_MAP(CServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_EDT_ATM_Address,     OnChange);
    END_MSG_MAP()

public:
    CAtmAddressDialog(CAtmArpcPage * pAtmArpcPage, const DWORD* pamhidsHelp = NULL);
    ~CAtmAddressDialog();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    void SetTitle(PCWSTR szTitle);

private:
    HWND m_hOkButton;     // this is the IDOK button, the text of the button changes
                          // with the context.
    HWND m_hEditBox;      // this is the edit box for the ATM address

    CAtmArpcPage * m_pParentDlg;

    WCHAR m_szTitle[MAX_TITLE_LENGTH];

    const   DWORD * m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgbkup.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       DLGBKUP.H
//
//  Contents:   Declaration for CIpBackUpDlg
//
//  Notes:  CIpBackUpDlg is the modal dialog to handle the fallback static
//			TCP/IP settings
//
//  Author: nsun	02/15/2000
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

// The IP Back up setting dialog
class CIpBackUpDlg : public CPropSheetPage
{
public:

    BEGIN_MSG_MAP(CIpBackUpDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog);

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
		NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)

        // command handlers
        COMMAND_ID_HANDLER(IDC_BKUP_RD_AUTO, OnAutoNet)
        COMMAND_ID_HANDLER(IDC_BKUP_RD_USER, OnUseConfig)

        COMMAND_ID_HANDLER(IDC_BKUP_IPADDR,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_SUBNET,   OnIpAddrSub)
        COMMAND_ID_HANDLER(IDC_BKUP_GATEWAY,  OnIpctrl)

        COMMAND_ID_HANDLER(IDC_BKUP_PREF_DNS,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_ALT_DNS,  OnIpctrl)

		COMMAND_ID_HANDLER(IDC_BKUP_WINS1,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_WINS2,  OnIpctrl)

		NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)


    END_MSG_MAP()
//
public:
    CIpBackUpDlg(CTcpipcfg * ptcpip, 
				 const DWORD* pamhidsHelp = NULL
				);

    ~CIpBackUpDlg();

// Dialog creation overides
public:
    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
	LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

	// message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // command ID handlers
	LRESULT OnAutoNet(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseConfig(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpctrl(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

	LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
	void EnableControls();
	void GetIpCtrlAddress(IpControl & IpCtrl, tstring * pstr);		
	void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd); }
	void UpdateInfo();

private:

    BOOL m_fModified;
    const DWORD *	m_adwHelpIDs;
	CTcpipcfg *     m_ptcpip;
	ADAPTER_INFO *	m_pAdapterInfo;

	IpControl       m_ipAddr;
    IpControl       m_ipMask;
    IpControl       m_ipDefGw;
    IpControl       m_ipPrefferredDns;
    IpControl       m_ipAlternateDns;
	IpControl       m_ipPrefferredWins;
    IpControl       m_ipAlternateWins;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgbkup.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       DLBBKUP.CPP
//
//  Contents:   Implementation for CIpBackUpDlg
//
//  Notes:  CIpBackUpDlg is the modal dialog to handle the fallback static
//			TCP/IP settings
//
//  Author: nsun	02/15/2000
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncreg.h"
#include "resource.h"
#include "tcpconst.h"
//#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"

#include "ncbase.h"

#include "dlgbkup.h"
#include "tcperror.h"


//
// CIpBackUpDlg
//
CIpBackUpDlg::CIpBackUpDlg (CTcpipcfg * ptcpip,
							const DWORD* adwHelpIDs) :
m_ptcpip(ptcpip),
m_fModified(FALSE)
{
	m_pAdapterInfo = ptcpip->GetConnectionAdapterInfo();
    m_adwHelpIDs  = adwHelpIDs;
}

CIpBackUpDlg::~CIpBackUpDlg()
{
}

LRESULT CIpBackUpDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{

    // limit the field ranges for the address fields
    m_ipAddr.Create(m_hWnd, IDC_BKUP_IPADDR);
    m_ipAddr.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipMask.Create(m_hWnd, IDC_BKUP_SUBNET);
    
	m_ipDefGw.Create(m_hWnd, IDC_BKUP_GATEWAY);
    m_ipDefGw.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipPrefferredDns.Create(m_hWnd, IDC_BKUP_PREF_DNS);
    m_ipPrefferredDns.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipAlternateDns.Create(m_hWnd, IDC_BKUP_ALT_DNS);
    m_ipAlternateDns.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipPrefferredWins.Create(m_hWnd, IDC_BKUP_WINS1);
    m_ipPrefferredWins.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipAlternateWins.Create(m_hWnd, IDC_BKUP_WINS2);
    m_ipAlternateWins.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	int nIdRdbutton;
	if (m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		nIdRdbutton = IDC_BKUP_RD_AUTO;
	}
	else
	{
		nIdRdbutton = IDC_BKUP_RD_USER;
	}

	CheckDlgButton(IDC_BKUP_RD_AUTO, 
		m_pAdapterInfo->m_BackupInfo.m_fAutoNet ? BST_CHECKED : BST_UNCHECKED);

	CheckDlgButton(IDC_BKUP_RD_USER, 
		m_pAdapterInfo->m_BackupInfo.m_fAutoNet ? BST_UNCHECKED : BST_CHECKED);

	if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		m_ipAddr.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str());
		m_ipMask.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());
		m_ipDefGw.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strDefGw.c_str());
		m_ipPrefferredDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredDns.c_str());
		m_ipAlternateDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateDns.c_str());
		m_ipPrefferredWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredWins.c_str());
		m_ipAlternateWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateWins.c_str());
	}

	EnableControls();

	m_fModified = FALSE;
    return 0;
}

LRESULT CIpBackUpDlg::OnDestroyDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{

    return 0;
}

LRESULT CIpBackUpDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);

    return 0;
}

LRESULT CIpBackUpDlg::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}


LRESULT CIpBackUpDlg::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpBackUpDlg::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

	BOOL fError = FALSE; // Allow page to lose active status
    HWND hWndFocus = 0;


    // If the ip address and subnet mask on this page mismatch,
    // just raise error and do not update the UI

    if (m_ipAddr.IsBlank() && !m_ipMask.IsBlank())
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                   MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        hWndFocus = (HWND) m_ipAddr;
        fError = TRUE;
    }
    else if (!m_ipAddr.IsBlank() && m_ipMask.IsBlank())
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        hWndFocus = (HWND) m_ipMask;
        fError = TRUE;
    }

    // Now, update in memory structure
    if (!fError && m_fModified)
    {
        UpdateInfo();

		if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
		{
			IP_VALIDATION_ERR err = IsValidIpandSubnet(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str(),
									m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());

	        // validate IP address and subnet mask
			if (ERR_NONE != err)
			{
				
	            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, GetIPValidationErrorMessageID(err),
	                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

				fError = TRUE;
	            hWndFocus = (HWND) m_ipMask;
			}

			if (!fError && !IsContiguousSubnet(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str()))
			{
				NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_ERROR_UNCONTIGUOUS_SUBNET,
	                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

				fError = TRUE;
	            hWndFocus = (HWND) m_ipMask;			
			}
		}
    }

    //we need to change focus to the control that contains invalidate data
    if (fError && hWndFocus)
        ::SetFocus(hWndFocus);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CIpBackUpDlg::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
	BOOL nResult = PSNRET_NOERROR;
	if (m_fModified)
    {
		m_pAdapterInfo->m_fBackUpSettingChanged = TRUE;
		m_ptcpip->SetSecondMemoryModified();
		m_fModified = FALSE;   // this page is no longer modified
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}


LRESULT CIpBackUpDlg::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_BKUP_IPADDR:
    case IDC_BKUP_GATEWAY:
    case IDC_BKUP_PREF_DNS:
    case IDC_BKUP_ALT_DNS:
	case IDC_BKUP_WINS1:
	case IDC_BKUP_WINS2:

        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, 
					m_hWnd, 
					iLow, 
					iHigh, 
					(IDC_BKUP_IPADDR == idCtrl || IDC_BKUP_GATEWAY == idCtrl)
					);
        break;

    case IDC_BKUP_SUBNET:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}

void CIpBackUpDlg::UpdateInfo()
{
	m_pAdapterInfo->m_BackupInfo.m_fAutoNet = IsDlgButtonChecked(IDC_BKUP_RD_AUTO);
	if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		GetIpCtrlAddress(m_ipAddr, &m_pAdapterInfo->m_BackupInfo.m_strIpAddr);
		GetIpCtrlAddress(m_ipMask, &m_pAdapterInfo->m_BackupInfo.m_strSubnetMask);
		GetIpCtrlAddress(m_ipDefGw, &m_pAdapterInfo->m_BackupInfo.m_strDefGw);
		GetIpCtrlAddress(m_ipPrefferredDns, &m_pAdapterInfo->m_BackupInfo.m_strPreferredDns);
		GetIpCtrlAddress(m_ipAlternateDns, &m_pAdapterInfo->m_BackupInfo.m_strAlternateDns);
		GetIpCtrlAddress(m_ipPrefferredWins, &m_pAdapterInfo->m_BackupInfo.m_strPreferredWins);
		GetIpCtrlAddress(m_ipAlternateWins, &m_pAdapterInfo->m_BackupInfo.m_strAlternateWins);
	}
}

LRESULT CIpBackUpDlg::OnAutoNet(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case BN_CLICKED:
        case BN_DOUBLECLICKED:
			EnableControls();
            break;
    }

    return 0;
}

LRESULT CIpBackUpDlg::OnUseConfig(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {

        case BN_CLICKED:
        case BN_DOUBLECLICKED:
			EnableControls();
            break;
    }
    return 0;
}

LRESULT CIpBackUpDlg::OnIpctrl(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CIpBackUpDlg::OnIpAddrSub(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;

    case EN_SETFOCUS:

        // if the subnet mask is blank, create a mask and insert it into
        // the control
        if (!m_ipAddr.IsBlank() && m_ipMask.IsBlank())
        {
            tstring strSubnetMask;
            tstring strIpAddress;

            m_ipAddr.GetAddress(&strIpAddress);

            // generate the mask and update the control, and internal structure
            GenerateSubnetMask(m_ipAddr, &strSubnetMask);
            m_ipMask.SetAddress(strSubnetMask.c_str());

            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                strSubnetMask.c_str());
        }
        break;
    }

    return 0;
}


void CIpBackUpDlg::EnableControls()
{
	BOOL fEnableUserConfig = !IsDlgButtonChecked(IDC_BKUP_RD_AUTO);

	::EnableWindow(GetDlgItem(IDC_BKUP_IPADDR_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_IPADDR), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_SUBNET_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_SUBNET), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_GATEWAY_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_GATEWAY), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_PREF_DNS_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_PREF_DNS), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_ALT_DNS_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_ALT_DNS), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS1_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS1), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_WINS2_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS2), fEnableUserConfig);

	if (fEnableUserConfig)
	{
		m_ipAddr.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str());
		m_ipMask.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());
		m_ipDefGw.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strDefGw.c_str());
		m_ipPrefferredDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredDns.c_str());
		m_ipAlternateDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateDns.c_str());
		m_ipPrefferredWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredWins.c_str());
		m_ipAlternateWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateWins.c_str());
	}
	else
	{
		m_ipAddr.ClearAddress();
		m_ipMask.ClearAddress();
		m_ipDefGw.ClearAddress();
		m_ipPrefferredDns.ClearAddress();
		m_ipAlternateDns.ClearAddress();
		m_ipPrefferredWins.ClearAddress();
		m_ipAlternateWins.ClearAddress();
	}
}

void CIpBackUpDlg::GetIpCtrlAddress(IpControl & IpCtrl, tstring * pstr)
{
	Assert(pstr);

	if (IpCtrl.IsBlank())
	{
		*pstr = c_szEmpty;
	}
	else
	{
		IpCtrl.GetAddress(pstr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgfilt.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G F I L T. C P P
//
//  Contents:   Implementation of CFilteringDialog and CAddFilterDialog
//
//  Notes:  CFilterDialog is the TCP/IP filtering dialog
//
//  Author: tongl   6 Sept 1998
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "resource.h"
#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "dlgopt.h"

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    unsigned long a = (unsigned long)lParam1;
    unsigned long b = (unsigned long)lParam2;

    if (a < b)
        return -1;

    return a != b;
}

//
// CFilterDialog
//

CFilterDialog::CFilterDialog(CTcpOptionsPage * pOptionsPage,
                             GLOBAL_INFO * pGlbDlg,
                             ADAPTER_INFO * pAdapterDlg,
                             const DWORD* adwHelpIDs)
{
    Assert(pOptionsPage != NULL);
    Assert(pGlbDlg != NULL);
    Assert(pAdapterDlg != NULL);

    m_pParentDlg   = pOptionsPage;
    m_pGlobalInfo  = pGlbDlg;
    m_pAdapterInfo = pAdapterDlg;
    m_adwHelpIDs   = adwHelpIDs;

    m_fModified = FALSE;
}

CFilterDialog::~CFilterDialog()
{
}

LRESULT CFilterDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    m_hlistTcp = GetDlgItem(IDC_FILTERING_TCP);
    m_hlistUdp = GetDlgItem(IDC_FILTERING_UDP);
    m_hlistIp  = GetDlgItem(IDC_FILTERING_IP);

    // Label columns in the listviews
    LV_COLUMN lvCol;
    RECT rect;
    int iNewCol;

    lvCol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvCol.fmt = LVCFMT_LEFT;

    // TCP ports
    ::GetClientRect(m_hlistTcp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_TCP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistTcp, 0, &lvCol);
    Assert(iNewCol == 0);

    // UDP ports
    ::GetClientRect(m_hlistUdp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_UDP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistUdp, 0, &lvCol);
    Assert(iNewCol == 0);

    // IP protocols
    ::GetClientRect(m_hlistIp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_IP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistIp, 0, &lvCol);
    Assert(iNewCol == 0);

    SetInfo();
    SetButtons();

    m_fModified = FALSE;
    return 0;
}

LRESULT CFilterDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CFilterDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CFilterDialog::OnEnableFiltering( WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        m_fModified = TRUE;

        if (m_pGlobalInfo->m_fEnableFiltering) // if Filtering was enabled
        {
            // disable filtering
            NcMsgBox(::GetActiveWindow(),
                    IDS_MSFT_TCP_TEXT,
                    IDS_FILTERING_DISABLE,
                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            m_pGlobalInfo->m_fEnableFiltering = FALSE;
        }
        else
        {
            m_pGlobalInfo->m_fEnableFiltering = TRUE;
        }
    }

    return 0;
}

LRESULT CFilterDialog::OnTcpPermit( WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_TCP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnUdpPermit(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_UDP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnIpPermit(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_IP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnOk(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    if (m_fModified)
    {
        m_pParentDlg->m_fPropDlgModified = TRUE;
        UpdateInfo();
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CFilterDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = FALSE;
    EndDialog(IDCANCEL);

    return 0;
}

LRESULT CFilterDialog::OnAdd(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    CAddFilterDialog * pDlgAddFilter = new CAddFilterDialog(this, 
                                                        wID, 
                                                        g_aHelpIDs_IDD_FILTER_ADD);
    if (pDlgAddFilter == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (pDlgAddFilter->DoModal() == IDOK)
        m_fModified = TRUE;

    SetButtons();

    delete pDlgAddFilter;

    return 0;
}

LRESULT CFilterDialog::OnRemove(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    HWND hList = NULL;
    HWND hAdd = NULL;

    switch (wID)
    {
    case IDC_FILTERING_TCP_REMOVE:
        hList = m_hlistTcp;
        hAdd = GetDlgItem(IDC_FILTERING_TCP_ADD);
        break;

    case IDC_FILTERING_UDP_REMOVE:
        hList = m_hlistUdp;
        hAdd = GetDlgItem(IDC_FILTERING_UDP_ADD);
        break;

    case IDC_FILTERING_IP_REMOVE:
        hList = m_hlistIp;
        hAdd = GetDlgItem(IDC_FILTERING_IP_ADD);
        break;

    default:
        Assert(FALSE);
        break;
    }

    Assert(hList);
    if (NULL == hList || NULL == hAdd)
    {
        return TRUE;
    }

    // see if an item is selected
    int i = ::SendMessage(hList, LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_SELECTED, 0));

    if (i == -1)
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_FILTERING_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        return TRUE;
    }

    // remove the item and make item 0 selected
    ListView_DeleteItem(hList, i);
    ListView_GetItemCount(hList);

    m_fModified = TRUE;
    if (i)
    {
        LV_ITEM lvItem;
        lvItem.stateMask = LVIS_SELECTED;
        lvItem.state = LVIS_SELECTED;
        ::SendMessage(hList, LVM_SETITEMSTATE, 0, (LPARAM)&lvItem);
    }
    else // Force focus to the Add button
    {
        IsWindow(::SetFocus(hAdd));
    }

    SetButtons();
    return TRUE;
}

void CFilterDialog::UpdateInfo()
{
    m_pGlobalInfo->m_fEnableFiltering = IsDlgButtonChecked(IDC_FILTERING_ENABLE);

    FreeCollectionAndItem(m_pAdapterInfo->m_vstrTcpFilterList);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrUdpFilterList);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpFilterList);

    HWND list[3];
    VSTR * pvstr[3];
    int nId[3] = {IDC_FILTERING_FILTER_TCP, IDC_FILTERING_FILTER_UDP, IDC_FILTERING_FILTER_IP};

    // Initialize values
    list[0] = m_hlistTcp;
    list[1] = m_hlistUdp;
    list[2] = m_hlistIp;
    pvstr[0] = &m_pAdapterInfo->m_vstrTcpFilterList;
    pvstr[1] = &m_pAdapterInfo->m_vstrUdpFilterList;
    pvstr[2] = &m_pAdapterInfo->m_vstrIpFilterList;

    for(int iLists = 0; iLists < 3; ++iLists)
    {
        int nlvCount = ListView_GetItemCount(list[iLists]);

        // "" (Empty String) == All ports
        // "0" == No ports
        // "x y z" == ports x, y, x

        // if the All Filter button is checked, use Empty String
        if (IsDlgButtonChecked(nId[iLists]))
        {
            pvstr[iLists]->push_back(new tstring(L"0"));
            continue;
        }

        if (nlvCount == 0)
        {
            pvstr[iLists]->push_back(new tstring(L""));
            continue;
        }

        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 0;

        for (int iItem = 0; iItem < nlvCount; iItem++)
        {
            WCHAR szBuf[16];

            lvItem.iItem = iItem;
            ListView_GetItem(list[iLists], &lvItem);

            Assert(lvItem.lParam != 0);
            _itow((int)lvItem.lParam, szBuf, 10);

            Assert(szBuf);
            pvstr[iLists]->push_back(new tstring(szBuf));
        }
    }
}

void CFilterDialog::SetInfo()
{
    CheckDlgButton(IDC_FILTERING_ENABLE, m_pGlobalInfo->m_fEnableFiltering);

    int anId[3] = {IDC_FILTERING_FILTER_TCP, IDC_FILTERING_FILTER_UDP, IDC_FILTERING_FILTER_IP};
    int anIdSel[3] = {IDC_FILTERING_FILTER_TCP_SEL, IDC_FILTERING_FILTER_UDP_SEL, IDC_FILTERING_FILTER_IP_SEL};
    HWND aplist[3];
    VSTR * apvect[3];

    aplist[0] = m_hlistTcp;
    aplist[1] = m_hlistUdp;
    aplist[2] = m_hlistIp;

    ListView_DeleteAllItems(m_hlistTcp);
    ListView_DeleteAllItems(m_hlistUdp);
    ListView_DeleteAllItems(m_hlistIp);

    apvect[0] = &m_pAdapterInfo->m_vstrTcpFilterList;
    apvect[1] = &m_pAdapterInfo->m_vstrUdpFilterList;
    apvect[2] = &m_pAdapterInfo->m_vstrIpFilterList;

    int iItem;
    for (int iLists = 0; iLists < 3; ++iLists)
    {
        iItem = 0;

        //if the list is empty, that means no value is accepted
        if (apvect[iLists]->empty())
        {
            EnableGroup(anId[iLists], TRUE);
            CheckRadioButton(anId[iLists], anIdSel[iLists], anIdSel[iLists]);
            continue;
        }

        for(VSTR_ITER iter = apvect[iLists]->begin() ; iter != apvect[iLists]->end() ; ++iter)
        {
            if (**iter == L"0")
            {
                EnableGroup(anId[iLists], FALSE);
                CheckRadioButton(anId[iLists], anIdSel[iLists], anId[iLists]);
                break;
            }

            EnableGroup(anId[iLists], TRUE);
            CheckRadioButton(anId[iLists], anIdSel[iLists], anIdSel[iLists]);

            if (**iter == L"")
                break;

            unsigned long nNum = wcstoul((*iter)->c_str(), NULL, 10);

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = nNum;
            lvItem.iItem = iItem;
            lvItem.iSubItem = 0;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.state =0;
            lvItem.pszText = (PWSTR)(*iter)->c_str();

            ::SendMessage(aplist[iLists], LVM_INSERTITEM, 0, (LPARAM)&lvItem);

            lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
            lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
            :: SendMessage(aplist[iLists], LVM_SETITEMSTATE, iItem, (LPARAM)&lvItem);

            ++iItem;
        }
        ListView_SortItems(aplist[iLists], CompareFunc, 0);
    }

    // Update the RemoveButtons
    SetButtons();
}

void CFilterDialog::EnableGroup(int nId, BOOL fEnable)
{
    int nIdAdd = 0;
    int nIdRemove = 0;
    int nIdList = 0;

    switch (nId)
    {
    case IDC_FILTERING_FILTER_TCP:
    case IDC_FILTERING_FILTER_TCP_SEL:
        nIdAdd = IDC_FILTERING_TCP_ADD;
        nIdRemove = IDC_FILTERING_TCP_REMOVE;
        nIdList = IDC_FILTERING_TCP;
        break;

    case IDC_FILTERING_FILTER_UDP:
    case IDC_FILTERING_FILTER_UDP_SEL:
        nIdAdd = IDC_FILTERING_UDP_ADD;
        nIdRemove = IDC_FILTERING_UDP_REMOVE;
        nIdList = IDC_FILTERING_UDP;
        break;

    case IDC_FILTERING_FILTER_IP:
    case IDC_FILTERING_FILTER_IP_SEL:
        nIdAdd = IDC_FILTERING_IP_ADD;
        nIdRemove = IDC_FILTERING_IP_REMOVE;
        nIdList = IDC_FILTERING_IP;
        break;

    default:
        Assert(FALSE);
        break;
    }

    if (0 != nIdAdd && 0 != nIdRemove && 0 != nIdList)
    {
        ::EnableWindow(GetDlgItem(nIdAdd), fEnable);
        ::EnableWindow(GetDlgItem(nIdRemove), fEnable);
        ::EnableWindow(GetDlgItem(nIdList), fEnable);
    }
}

void CFilterDialog::SetButtons()
{
    if (ListView_GetItemCount(m_hlistTcp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_TCP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_TCP));
    }

    if (ListView_GetItemCount(m_hlistUdp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_UDP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_UDP));
    }

    if (ListView_GetItemCount(m_hlistIp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_IP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_IP));
    }

}

//
// CAddFilterDialog
//

CAddFilterDialog::CAddFilterDialog(CFilterDialog* pParentDlg, int ID, const DWORD* adwHelpIDs)
{
    Assert(pParentDlg != NULL);
    Assert(ID != 0);

    m_pParentDlg = pParentDlg;
    m_nId = ID;
    m_hList = NULL;

    m_adwHelpIDs = adwHelpIDs;
}

CAddFilterDialog::~CAddFilterDialog()
{
}

LRESULT CAddFilterDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    int nTextId = 0;

    Assert(m_pParentDlg != NULL);

    // Position the dialog
    RECT rect;
    switch (m_nId)
    {
    case IDC_FILTERING_TCP_ADD:
        m_hList = m_pParentDlg->m_hlistTcp;
        nTextId = IDS_FILTERING_TCP_TEXT;
        break;

    case IDC_FILTERING_UDP_ADD:
        m_hList =  m_pParentDlg->m_hlistUdp;
        nTextId = IDS_FILTERING_UDP_TEXT;
        break;

    case IDC_FILTERING_IP_ADD:
        m_hList =  m_pParentDlg->m_hlistIp;
        nTextId = IDS_FILTERING_IP_TEXT;
        break;

    default:
        Assert(FALSE);
        break;
    }

    Assert(IsWindow(m_hList));

    if (IsWindow(m_hList))
    {
        ::GetWindowRect(m_hList, &rect);
        SetWindowPos(NULL,  rect.left, rect.top-8, 0,0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
    }

    // Set the static text and limit the edit control to 5 characters
    SetDlgItemText(IDC_FILTERING_TEXT, SzLoadIds(nTextId));
    SendDlgItemMessage(IDC_FILTERING_ADD_EDIT, EM_SETLIMITTEXT, FILTER_ADD_LIMIT, 0);
    ::EnableWindow(GetDlgItem(IDOK), FALSE);

    return TRUE;
}

LRESULT CAddFilterDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAddFilterDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAddFilterDialog::OnFilterAddEdit(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        ::EnableWindow(GetDlgItem(IDOK),
                       Tcp_Edit_LineLength(GetDlgItem(wID), -1));
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddFilterDialog::OnOk(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    WCHAR   szData[FILTER_ADD_LIMIT+1];

    szData[0] = 0;
    ::GetWindowText(GetDlgItem(IDC_FILTERING_ADD_EDIT), szData, FILTER_ADD_LIMIT+1);

    Assert(IsWindow(m_hList));

    // check the range of the number
    PWSTR pStr;
    unsigned long num = wcstoul(szData, &pStr, 10);
    unsigned long maxNum = 65535;
    int nId = IDS_FILTERING_RANGE_WORD;

    if (m_hList == m_pParentDlg->m_hlistIp)
    {
        maxNum = 255;
        nId = IDS_FILTERING_RANGE_BYTE;
    }

    if (num < 1 || num > maxNum)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 nId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        return 0;
    }

    // See if the item is in the list
    LV_FINDINFO info;
    info.flags = LVFI_PARAM;
    info.lParam = num;
    int i = ListView_FindItem(m_hList, -1, &info);

    if (i != -1)
    {
       NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_FILTERING_ITEM_IN_LIST,
                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

       return 0;
    }

    int index = ListView_GetItemCount(m_hList);

    LV_ITEM lvItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = num;
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state =0;
    lvItem.pszText = (PWSTR)szData;

    ::SendMessage(m_hList, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    ListView_SortItems(m_hList, CompareFunc, 0);

    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ::SendMessage(m_hList, LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)&lvItem);

    EndDialog(IDOK);

    return 0;
}

LRESULT CAddFilterDialog::OnCancel(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDOK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgdns.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D N S . C P P
//
//  Contents:   CTcpDnsPage, CServerDialog and CSuffixDialog implementation
//
//  Notes:  The DNS page and related dialogs
//
//  Author: tongl   11 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "dlgaddr.h"
#include "dlgdns.h"

#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "dnslib.h"

#define MAX_RAS_DNS_SERVER          2
#define MAX_HOSTNAME_LENGTH         64
#define MAX_DOMAINNAME_LENGTH       255

CTcpDnsPage::CTcpDnsPage(CTcpAddrPage * pTcpAddrPage,
                         ADAPTER_INFO * pAdapterDlg,
                         GLOBAL_INFO * pGlbDlg,
                         const DWORD*  adwHelpIDs)
{
    // Save everything passed to us
    Assert(pTcpAddrPage != NULL);
    m_pParentDlg = pTcpAddrPage;

    Assert(pAdapterDlg != NULL);
    m_pAdapterInfo = pAdapterDlg;

    Assert(pGlbDlg != NULL);
    m_pglb = pGlbDlg;

    m_adwHelpIDs = adwHelpIDs;

    // Initialize internal states
    m_fModified = FALSE;
}

CTcpDnsPage::~CTcpDnsPage()
{
}

LRESULT CTcpDnsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    m_fEditState = FALSE;

    // Cache hwnds
    // Server
    m_hServers.m_hList      = GetDlgItem(IDC_DNS_SERVER_LIST);
    m_hServers.m_hAdd       = GetDlgItem(IDC_DNS_SERVER_ADD);
    m_hServers.m_hEdit      = GetDlgItem(IDC_DNS_SERVER_EDIT);
    m_hServers.m_hRemove    = GetDlgItem(IDC_DNS_SERVER_REMOVE);
    m_hServers.m_hUp        = GetDlgItem(IDC_DNS_SERVER_UP);
    m_hServers.m_hDown      = GetDlgItem(IDC_DNS_SERVER_DOWN);

    // Suffix
    m_hSuffix.m_hList       = GetDlgItem(IDC_DNS_SUFFIX_LIST);
    m_hSuffix.m_hAdd        = GetDlgItem(IDC_DNS_SUFFIX_ADD);
    m_hSuffix.m_hEdit       = GetDlgItem(IDC_DNS_SUFFIX_EDIT);
    m_hSuffix.m_hRemove     = GetDlgItem(IDC_DNS_SUFFIX_REMOVE);
    m_hSuffix.m_hUp         = GetDlgItem(IDC_DNS_SUFFIX_UP);
    m_hSuffix.m_hDown       = GetDlgItem(IDC_DNS_SUFFIX_DOWN);


    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_DNS_SERVER_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_DNS_SERVER_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    SendDlgItemMessage(IDC_DNS_SUFFIX_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_DNS_SUFFIX_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Get the Service address Add and Edit button Text and remove ellipse
    WCHAR   szAddServer[16];
    WCHAR   szAddSuffix[16];

    GetDlgItemText(IDC_DNS_SERVER_ADD, szAddServer, celems(szAddServer));
    GetDlgItemText(IDC_DNS_SERVER_ADD, szAddSuffix, celems(szAddSuffix));

    szAddServer[lstrlenW(szAddServer) - c_cchRemoveCharatersFromEditOrAddButton]= 0;
    szAddSuffix[lstrlenW(szAddSuffix) - c_cchRemoveCharatersFromEditOrAddButton]= 0;

    m_strAddServer = szAddServer;
    m_strAddSuffix = szAddSuffix;

    // Initialize controls on this page
    // DNS server list box
    int nResult= LB_ERR;
    for(VSTR_ITER iterNameServer = m_pAdapterInfo->m_vstrDnsServerList.begin() ;
        iterNameServer != m_pAdapterInfo->m_vstrDnsServerList.end() ;
        ++iterNameServer)
    {
        nResult = Tcp_ListBox_InsertString(m_hServers.m_hList, -1,
                                           (*iterNameServer)->c_str());
    }

    // set slection to first item
    if (nResult >= 0)
    {
        Tcp_ListBox_SetCurSel(m_hServers.m_hList, 0);
    }

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);


    // DNS domain edit box
    ::SendMessage(GetDlgItem(IDC_DNS_DOMAIN), EM_SETLIMITTEXT, DOMAIN_LIMIT, 0);
    ::SetWindowText(GetDlgItem(IDC_DNS_DOMAIN),
                    m_pAdapterInfo->m_strDnsDomain.c_str());

    // DNS dynamic registration
    CheckDlgButton(IDC_DNS_ADDR_REG, !m_pAdapterInfo->m_fDisableDynamicUpdate);
    CheckDlgButton(IDC_DNS_NAME_REG, m_pAdapterInfo->m_fEnableNameRegistration);

    // Bug #266461 need disable IDC_DNS_NAME_REG if IDC_DNS_ADDR_REG is unchecked
    if(m_pAdapterInfo->m_fDisableDynamicUpdate)
        ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), FALSE);


    // DNS domain serach methods
    if (m_pglb->m_vstrDnsSuffixList.size() >0) //If suffix list not empty
    {
        CheckDlgButton(IDC_DNS_USE_SUFFIX_LIST, TRUE);
        CheckDlgButton(IDC_DNS_SEARCH_DOMAIN, FALSE);
        CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, FALSE);

        EnableSuffixGroup(TRUE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);

        // DNS suffix list box
        nResult= LB_ERR;
        for(VSTR_CONST_ITER iterSearchList = (m_pglb->m_vstrDnsSuffixList).begin() ;
                            iterSearchList != (m_pglb->m_vstrDnsSuffixList).end() ;
                            ++iterSearchList)
        {
            nResult = Tcp_ListBox_InsertString(m_hSuffix.m_hList, -1,
                                              (*iterSearchList)->c_str());
        }

        // set slection to first item
        if (nResult >= 0)
        {
            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, 0);
        }

        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }
    else
    {
        CheckDlgButton(IDC_DNS_USE_SUFFIX_LIST, FALSE);
        CheckDlgButton(IDC_DNS_SEARCH_DOMAIN, TRUE);
        CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, m_pglb->m_fUseDomainNameDevolution);

        EnableSuffixGroup(FALSE);
    }

    //this is a ras connection and a non-admin user, disable all the controls 
    //for globl settings
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
    {
        ::EnableWindow(GetDlgItem(IDC_DNS_STATIC_GLOBAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_DOMAIN), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_USE_SUFFIX_LIST), FALSE);
        EnableSuffixGroup(FALSE);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpDnsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpDnsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // server list
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDnsServerList);

    WCHAR szServer[IP_LIMIT];

    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    for (int i = 0; i < nCount; i++)
    {
        #ifdef DBG
            int len = Tcp_ListBox_GetTextLen(m_hServers.m_hList, i);
            Assert(len != LB_ERR && len < IP_LIMIT);
        #endif

        Tcp_ListBox_GetText(m_hServers.m_hList, i, szServer);
        m_pAdapterInfo->m_vstrDnsServerList.push_back(new tstring(szServer));
    }

    
    // DNS domain
    // update second memory with what's in the controls
    WCHAR szDomain[DOMAIN_LIMIT + 1];
    ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szDomain, celems(szDomain));
    m_pAdapterInfo->m_strDnsDomain = szDomain;

    m_pAdapterInfo->m_fDisableDynamicUpdate = !IsDlgButtonChecked(IDC_DNS_ADDR_REG);
    m_pAdapterInfo->m_fEnableNameRegistration = IsDlgButtonChecked(IDC_DNS_NAME_REG);
    

    // suffix list and radio button options
    FreeCollectionAndItem(m_pglb->m_vstrDnsSuffixList);

    WCHAR szSuffix[SUFFIX_LIMIT];
    if (IsDlgButtonChecked(IDC_DNS_USE_SUFFIX_LIST))
    {
        int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
        AssertSz(nCount > 0, "Why isn't the error caught by OnKillActive?");

        for (int i = 0; i < nCount; i++)
        {
            #ifdef DBG
                int len = Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, i);
                Assert(len != LB_ERR && len < SUFFIX_LIMIT);
            #endif

            Tcp_ListBox_GetText(m_hSuffix.m_hList, i, szSuffix);
            m_pglb->m_vstrDnsSuffixList.push_back(new tstring(szSuffix));
        }
    }
    else
    {
        m_pglb->m_fUseDomainNameDevolution =
            IsDlgButtonChecked(IDC_DNS_SEARCH_PARENT_DOMAIN);
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    SetModifiedTo(FALSE);  // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpDnsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}


LRESULT CTcpDnsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL fErr = FALSE;

    if (IsDlgButtonChecked(IDC_DNS_USE_SUFFIX_LIST))
    {
        int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

        if (0 == nCount)
        {
            // If the list is empty
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_SUFFIX,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            fErr = TRUE;
        }
    }

    WCHAR szDomain[DOMAIN_LIMIT + 1];
    ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szDomain, celems(szDomain));
    if (lstrlenW(szDomain) > 0 && lstrcmpiW(m_pAdapterInfo->m_strDnsDomain.c_str(), szDomain) != 0)
    {

        DNS_STATUS status;

        status = DnsValidateName(szDomain, DnsNameDomain);
        if (ERROR_INVALID_NAME == status ||
            DNS_ERROR_INVALID_NAME_CHAR == status)
        {
            NcMsgBox(m_hWnd,
                     IDS_MSFT_TCP_TEXT,
                     IDS_INVALID_DOMAIN_NAME,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                     szDomain);
            ::SetFocus(GetDlgItem(IDC_DNS_DOMAIN));
            fErr = TRUE;
        }
        else if (DNS_ERROR_NON_RFC_NAME == status)
        {
            //the dns domain name is not RFC compaliant, should we give a warning here?
        }
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fErr);
    return fErr;
}

// DNS server related controls
LRESULT CTcpDnsPage::OnAddServer(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CServerDialog * pDlgSrv = new CServerDialog(this, g_aHelpIDs_IDD_DNS_SERVER);

    if (pDlgSrv->DoModal() == IDOK)
    {
        int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hServers.m_hList,
                                           -1,
                                           m_strNewIpAddress.c_str());
        Assert(idx>=0);
        if (idx >= 0)
        {
            PageModified();

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
            SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    // release dialog object
    delete pDlgSrv;

    return 0;
}

LRESULT CTcpDnsPage::OnEditServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    Assert(Tcp_ListBox_GetCount(m_hServers.m_hList));
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    Assert(idx >= 0);

    CServerDialog * pDlgSrv = new CServerDialog(this, 
                                        g_aHelpIDs_IDD_DNS_SERVER,
                                        idx);
  

    // save off the removed address and delete if from the listbox
    if (idx >= 0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;  // used by dialog to display what to edit

        if (pDlgSrv->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

            PageModified();

            m_strMovingEntry = m_strNewIpAddress;
            ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

            m_strNewIpAddress = buf;  // restore the original removed address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    delete pDlgSrv;

    return 0;
}

LRESULT CTcpDnsPage::OnRemoveServer(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;
        Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;

        if ((nCount = Tcp_ListBox_GetCount(m_hServers.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
        }
        SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);
    }
    return 0;
}

LRESULT CTcpDnsPage::OnServerUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

    return 0;
}

LRESULT CTcpDnsPage::OnDnsDomain(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        // update second memory with what's in the controls
        WCHAR szBuf[DOMAIN_LIMIT + 1];
        ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szBuf, celems(szBuf));
        if (m_pAdapterInfo->m_strDnsDomain != szBuf)
            PageModified();

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnServerDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

    return 0;
}

// DNS domain search related controls
LRESULT CTcpDnsPage::OnSearchDomain(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (::IsWindowEnabled(m_hSuffix.m_hList))
        {
            PageModified();

            // Update in memory structure
            FreeCollectionAndItem(m_pglb->m_vstrDnsSuffixList);

            // delete all items from the list
            int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
            while (nCount>0)
            {
                Tcp_ListBox_DeleteString(m_hSuffix.m_hList, 0);
                nCount --;
            }
            EnableSuffixGroup(FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), TRUE);
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpDnsPage::OnSearchParentDomain(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        break;
    } // switch

    return 0;
}

LRESULT CTcpDnsPage::OnAddressRegister(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        // Bug #266461 need disable and uncheck IDC_DNS_NAME_REG
        //             if IDC_DNS_ADDR_REG is unchecked
        if(!IsDlgButtonChecked(IDC_DNS_ADDR_REG))
        {
            CheckDlgButton(IDC_DNS_NAME_REG, FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), FALSE);
        }
        else
            ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), TRUE);

        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnDomainNameRegister(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnUseSuffix(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (!::IsWindowEnabled(m_hSuffix.m_hList))
        {
            PageModified();
            EnableSuffixGroup(TRUE);
            CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);
        }

        break;
    } // switch
    return 0;
}

LRESULT CTcpDnsPage::OnAddSuffix(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CSuffixDialog * pDlgSuffix = new CSuffixDialog(this, g_aHelpIDs_IDD_DNS_SUFFIX);

    int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    if (pDlgSuffix->DoModal() == IDOK)
    {
        nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hSuffix.m_hList,
                                           -1,
                                           m_strNewSuffix.c_str());

        PageModified();

        Assert(idx >= 0);

        if (idx >= 0)
        {
            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

            SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
            m_strNewSuffix =L"";
        }
    }

    delete pDlgSuffix;
    return 0;
}

LRESULT CTcpDnsPage::OnEditSuffix(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    Assert(Tcp_ListBox_GetCount(m_hSuffix.m_hList));

    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);
    Assert(idx >= 0);

    CSuffixDialog * pDlgSuffix = new CSuffixDialog(this, 
                                        g_aHelpIDs_IDD_DNS_SUFFIX,
                                        idx);

    // save off the removed address and delete if from the listview
    if (idx >= 0)
    {
        WCHAR buf[SUFFIX_LIMIT];

        if (Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, idx) >= celems(buf))
        {
            Assert(FALSE);
            return 0;
        }

        Tcp_ListBox_GetText(m_hSuffix.m_hList, idx, buf);

        m_strNewSuffix = buf;

        if (pDlgSuffix->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information

            Tcp_ListBox_DeleteString(m_hSuffix.m_hList, idx);
            PageModified();

            m_strMovingEntry = m_strNewSuffix;
            ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

            m_strNewSuffix = buf; // save off old address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewSuffix = L"";
        }
    }

    delete pDlgSuffix;
    return 0;
}

LRESULT CTcpDnsPage::OnRemoveSuffix(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[SUFFIX_LIMIT];

        if(Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, idx) >= celems(buf))
        {
            Assert(FALSE);
            return 0;
        }

        Tcp_ListBox_GetText(m_hSuffix.m_hList, idx, buf);

        m_strNewSuffix = buf;
        Tcp_ListBox_DeleteString(m_hSuffix.m_hList, idx);
        PageModified();

        // select a new item
        int nCount;
        if ((nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList)) != LB_ERR)

        if(nCount != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);
        }
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hSuffix.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hSuffix.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

    SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hSuffix.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hSuffix.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

    SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);

    return 0;
}

LRESULT CTcpDnsPage::OnServerList(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixList(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
        break;

    default:
        break;
    }

    return 0;
}

void CTcpDnsPage::EnableSuffixGroup(BOOL fEnable)
{
    ::EnableWindow(m_hSuffix.m_hList, fEnable);

    if (fEnable)
    {
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }
    else
    {
        ::EnableWindow(m_hSuffix.m_hAdd, fEnable);
        ::EnableWindow(m_hSuffix.m_hEdit, fEnable);
        ::EnableWindow(m_hSuffix.m_hRemove, fEnable);
        ::EnableWindow(m_hSuffix.m_hUp, fEnable);
        ::EnableWindow(m_hSuffix.m_hDown, fEnable);
    }
}


//
// CServerDialog
//

CServerDialog::CServerDialog(CTcpDnsPage * pTcpDnsPage,
                             const DWORD * adwHelpIDs,
                             int iIndex)
{
    m_pParentDlg = pTcpDnsPage;
    m_hButton    = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CServerDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddServer.c_str());

    m_ipAddress.Create(m_hWnd, IDC_DNS_CHANGE_SERVER);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_DNS_SERVER_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_pParentDlg->m_strNewIpAddress.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewIpAddress = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_ipAddress);
    return 0;
}

LRESULT CServerDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CServerDialog::OnHelp(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CServerDialog::OnChange(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CServerDialog::OnOk(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& fHandled)
{
    tstring strIp;
    m_ipAddress.GetAddress(&strIp);

    // Validate
    if (!FIsIpInRange(strIp.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    //check whether this is a duplicate
    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hServers.m_hList, strIp.c_str());
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_DNS_SERVER,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 strIp.c_str());

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and
        // add them to the adapter if valid
        m_pParentDlg->m_strNewIpAddress = strIp;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_pParentDlg->m_strNewIpAddress)
            m_pParentDlg->m_strNewIpAddress = strIp; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CServerDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CServerDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
	
    return 0;
}

LRESULT CServerDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };

    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);

    return 0;
}

//
// CSuffixDialog
//

// iIndex - the index of the current suffix in the suffix list, default value
//          is -1, which means new suffix
CSuffixDialog::CSuffixDialog(CTcpDnsPage * pTcpDnsPage,
                             const DWORD * adwHelpIDs,
                             int iIndex)
{
    m_pParentDlg = pTcpDnsPage;
    m_hButton    = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CSuffixDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddSuffix.c_str());

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_DNS_SUFFIX_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                 SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hButton = GetDlgItem(IDOK);
    m_hEdit   = GetDlgItem(IDC_DNS_CHANGE_SUFFIX);

    // suffixes have a 255 character limit
    ::SendMessage(m_hEdit, EM_SETLIMITTEXT, SUFFIX_LIMIT, 0);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewSuffix.size())
    {
        ::SetWindowText(m_hEdit, m_pParentDlg->m_strNewSuffix.c_str());
        ::SendMessage(m_hEdit, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewSuffix = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_hEdit);
    return TRUE;
}

LRESULT CSuffixDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CSuffixDialog::OnHelp(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CSuffixDialog::OnChange(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty
    if (::GetWindowText(m_hEdit, buf, celems(buf)) == 0)
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CSuffixDialog::OnOk(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szSuffix[SUFFIX_LIMIT];

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEdit, szSuffix, SUFFIX_LIMIT);

    DNS_STATUS status;

    status = DnsValidateName(szSuffix, DnsNameDomain);

    if (ERROR_INVALID_NAME == status || 
        DNS_ERROR_INVALID_NAME_CHAR == status)
    {
        TraceTag(ttidTcpip,"Invalid Domain Suffix");

        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 IDS_INVALID_SUFFIX,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(m_hEdit);

        return 0;
    }

    //check whether this is a duplicate
    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hSuffix.m_hList, szSuffix);
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_DNS_SUFFIX,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 szSuffix);

        ::SetFocus(m_hEdit);

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        m_pParentDlg->m_strNewSuffix = szSuffix;
    }
    else // see if either changed
    {
        if(m_pParentDlg->m_strNewSuffix != szSuffix)
            m_pParentDlg->m_strNewSuffix = szSuffix; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CSuffixDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CSuffixDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
	
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgipsec.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G I P S E C . C P P
//
//  Contents:   Implementation for CIpSecDialog
//
//  Notes:  CIpSecDialog is the pop-up dislogs for IPSEC from
//          options page
//
//  Author: tongl   18 Jan, 1998
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncstl.h"
#include "ncui.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "dlgopt.h"

#include "lmcons.h"
#include "lmerr.h"

#include "cpolstor.h"
#include "ncbase.h"

struct IPSEC_POLICY_INFO
{
    WCHAR szPolicyName[MAX_PATH];
    WCHAR szPolicyDescription[MAX_PATH];
    GUID  guidPolicyId;
};

//const WCHAR c_szDomainPolicyKey[] =
//        L"System\\CurrentControlSet\\Services\\PolicyAgent\\Policy\\GPTIPSECPolicy";
//const WCHAR c_szDomainPolicyName[] = L"DSIPSECPolicyName";

//
// CIpSecDialog
//
CIpSecDialog::CIpSecDialog (CTcpOptionsPage * pOptionsPage,
                            GLOBAL_INFO * pGlbDlg,
                            const DWORD* adwHelpIDs)
{
    m_pParentDlg  = pOptionsPage;
    m_pGlobalInfo = pGlbDlg;
    m_adwHelpIDs  = adwHelpIDs;
}

CIpSecDialog::~CIpSecDialog()
{
}

LRESULT CIpSecDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    m_fInInitDialog = TRUE;

    // Does domain policy exist ?
    BOOL fHasDomainIpsecPolicy = FALSE;
    tstring strDomainIpsecPolicyName;

    hr = HrGetDomainIpsecPolicy( &fHasDomainIpsecPolicy, &strDomainIpsecPolicyName);

    if (SUCCEEDED(hr) && fHasDomainIpsecPolicy)
        hr = HrShowDomainIpsecPolicy(strDomainIpsecPolicyName.c_str());
    else
        hr = HrShowLocalIpsecPolicy();

    m_fInInitDialog = FALSE;

    if (FAILED(hr))
    {
         //$ TODO: Display a message box saying that an interal error occured. (Yuck.)
        EndDialog(IDCANCEL);
    }

    return 0;
}

LRESULT CIpSecDialog::OnDestroyDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    // Release the policy structures
    int nCount = Tcp_ComboBox_GetCount(GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST));

    for (int idx=0; idx < nCount; idx++)
    {
        DWORD_PTR dw = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                                      CB_GETITEMDATA, idx, (LPARAM)0);

        if (0 != dw)
        {
            IPSEC_POLICY_INFO * pIpsecInfo = (IPSEC_POLICY_INFO *)dw;
            delete pIpsecInfo;
        }
    }

    return 0;
}

LRESULT CIpSecDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CIpSecDialog::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CIpSecDialog::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    // save the current selection
    if (IsDlgButtonChecked(IDC_RAD_IPSEC_NOIPSEC))
    {
        m_pGlobalInfo->m_strIpsecPol = c_szIpsecNoPol;
    }
    else if (IsDlgButtonChecked(IDC_RAD_IPSEC_CUSTOM))
    {
        int idx = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST, CB_GETCURSEL, 0, 0);
        if (CB_ERR != idx)
        {
            DWORD_PTR dw = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                                          CB_GETITEMDATA, idx, (LPARAM)0);

            if (0 != dw)
            {
                IPSEC_POLICY_INFO * pIpsecInfo = (IPSEC_POLICY_INFO *)dw;

                m_pGlobalInfo->m_strIpsecPol = pIpsecInfo->szPolicyName;
                m_pGlobalInfo->m_guidIpsecPol = pIpsecInfo->guidPolicyId;
            }
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CIpSecDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CIpSecDialog::OnNoIpsec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case BN_CLICKED:
        case BN_DOUBLECLICKED:
            ::EnableWindow(GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST), FALSE);
            ::EnableWindow(GetDlgItem(IDC_EDT_POLICY_DESC), FALSE);

            if (!m_fInInitDialog)
                m_pParentDlg->m_fPropDlgModified = TRUE;
            break;
    }

    return 0;
}

LRESULT CIpSecDialog::OnUseCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case BN_CLICKED:
        case BN_DOUBLECLICKED:
            ::EnableWindow(GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST), TRUE);
            ::EnableWindow(GetDlgItem(IDC_EDT_POLICY_DESC), TRUE);

            if (!m_fInInitDialog)
                m_pParentDlg->m_fPropDlgModified = TRUE;
            break;
    }
    return 0;
}

LRESULT CIpSecDialog::OnSelectCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_SELCHANGE:

            // set description text
            int idx = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST, CB_GETCURSEL, 0, 0);
            if (CB_ERR != idx)
            {
                DWORD_PTR dw = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                                              CB_GETITEMDATA, idx, (LPARAM)0);

                if (0 != dw)
                {
                    IPSEC_POLICY_INFO * pIpsecInfo = (IPSEC_POLICY_INFO *)dw;

                    SetDlgItemText(IDC_EDT_POLICY_DESC,pIpsecInfo->szPolicyDescription);
                }
            }

            if (!m_fInInitDialog)
                m_pParentDlg->m_fPropDlgModified = TRUE;

            break;
    }
    return 0;
}

// help functions

HRESULT CIpSecDialog::HrGetDomainIpsecPolicy(BOOL * pfHasDomainIpsecPolicy,
                                             tstring * pstrDomainIpsecPolicyName)
{
    HRESULT hr = S_OK;
    WCHAR szPolicyName[MAX_PATH];
    DWORD dwBufferSize = sizeof(szPolicyName);

    typedef HRESULT (WINAPI* PFNHrIsDomainPolicyAssigned)();
    typedef HRESULT (WINAPI* PFNHrGetAssignedDomainPolicyName)(PWSTR strPolicyName, DWORD *pdwBufferSize);

    // load the polstore dll and get the two export functions we need
    static const CHAR c_szHrIsDomainPolicyAssigned [] = "HrIsDomainPolicyAssigned";
    static const CHAR c_szHrGetAssignedDomainPolicyName  [] = "HrGetAssignedDomainPolicyName";

    const PCSTR c_apszFunctionNames [2] =
    {
        c_szHrIsDomainPolicyAssigned,
        c_szHrGetAssignedDomainPolicyName
    };

    FARPROC apfn [2];
    HMODULE hPolStore;

    hr = HrLoadLibAndGetProcs ( L"polstore.dll", 2, c_apszFunctionNames,
                                &hPolStore, apfn);

    if (S_OK == hr) // if both functions load successfully
    {
        PFNHrIsDomainPolicyAssigned pfnHrIsDomainPolicyAssigned =
                            reinterpret_cast<PFNHrIsDomainPolicyAssigned>(apfn[0]);

        PFNHrGetAssignedDomainPolicyName pfnHrGetAssignedDomainPolicyName =
                            reinterpret_cast<PFNHrGetAssignedDomainPolicyName>(apfn[1]);

        Assert(pfnHrIsDomainPolicyAssigned);
        Assert(pfnHrGetAssignedDomainPolicyName);

        szPolicyName[0] = L'\0';
        *pfHasDomainIpsecPolicy = FALSE;

        // One more IPSEC change: LSA is out, instead, read this key from
        // local registry. Should get updated every 8 hours.

        hr = (*pfnHrIsDomainPolicyAssigned)();

        if (hr == S_OK) {

            hr = (*pfnHrGetAssignedDomainPolicyName)(
                        szPolicyName,
                        &dwBufferSize
                        );

            *pfHasDomainIpsecPolicy = TRUE;
            *pstrDomainIpsecPolicyName = SzLoadIds(IDS_DS_POLICY_PREFIX);
            *pstrDomainIpsecPolicyName += szPolicyName;

        }else {

            *pfHasDomainIpsecPolicy = FALSE;
            hr = S_OK;
        }

        // release the library
        FreeLibrary (hPolStore);

    }else {

        *pfHasDomainIpsecPolicy = FALSE;
        hr = S_OK;

    }

    TraceError("CIpSecDialog::HrGetDomainPolicy", hr);
    return hr;
}

HRESULT CIpSecDialog::HrShowDomainIpsecPolicy(PCWSTR pszDomainIpsecPolicyName)
{
    Assert(pszDomainIpsecPolicyName);

    HRESULT hr = S_OK;

    // check the "custom" policy button and set const text to the combo box
    CheckDlgButton(IDC_RAD_IPSEC_CUSTOM, TRUE);

    SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                       CB_ADDSTRING, 0, (LPARAM)(pszDomainIpsecPolicyName));

    HWND hPolicyCombo = GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST);
    Tcp_ComboBox_SetCurSel(hPolicyCombo, 0);

    // disable all controls on this doalog
    static const int nrgIdc[] = {IDC_RAD_IPSEC_NOIPSEC,
                                 IDC_RAD_IPSEC_CUSTOM,
                                 IDC_CMB_IPSEC_POLICY_LIST,
                                 IDC_STATIC,
                                 IDC_EDT_POLICY_DESC};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    TraceError("CIpSecDialog::HrShowDomainIpsecPolicy", hr);
    return hr;
}

HRESULT CIpSecDialog::HrShowLocalIpsecPolicy()
{
    HRESULT hr = S_OK;

    typedef HRESULT (WINAPI* PFNHrGetLocalIpSecPolicyList)(C_IPSEC_POLICY_INFO ** ppPolicyInfoList,
                                                           C_IPSEC_POLICY_INFO ** ppActivePolicyInfo);
    typedef HRESULT (WINAPI* PFNHrFreeLocalIpSecPolicyList)(C_IPSEC_POLICY_INFO * pPolicyInfoList);

    // load the polstore dll and get the two export functions we need
    static const CHAR c_szHrGetLocalIpSecPolicyList   [] = "HrGetLocalIpSecPolicyList";
    static const CHAR c_szHrFreeLocalIpSecPolicyList  [] = "HrFreeLocalIpSecPolicyList";

    const PCSTR c_apszFunctionNames [2] =
    {
        c_szHrGetLocalIpSecPolicyList,
        c_szHrFreeLocalIpSecPolicyList
    };

    FARPROC apfn [2];
    HMODULE hPolStore;

    hr = HrLoadLibAndGetProcs ( L"polstore.dll", 2, c_apszFunctionNames,
                                &hPolStore, apfn);

    if (S_OK == hr) // if both functions load successfully
    {
        PFNHrGetLocalIpSecPolicyList pfnHrGetLocalIpSecPolicyList =
                            reinterpret_cast<PFNHrGetLocalIpSecPolicyList>(apfn[0]);

        PFNHrFreeLocalIpSecPolicyList pfnHrFreeLocalIpSecPolicyList =
                            reinterpret_cast<PFNHrFreeLocalIpSecPolicyList>(apfn[1]);

        Assert(pfnHrGetLocalIpSecPolicyList);
        Assert(pfnHrFreeLocalIpSecPolicyList);

        // variables for the policies
        C_IPSEC_POLICY_INFO* pPolicyInfoList = NULL;
        C_IPSEC_POLICY_INFO* pActivePolicyInfo = NULL;

        // get the list of policies
        HRESULT hr = (*pfnHrGetLocalIpSecPolicyList)(&pPolicyInfoList,
                                                     &pActivePolicyInfo);
        if (SUCCEEDED(hr))
        {
            // loop through all the policies, insert custom policies to the combo-box
            C_IPSEC_POLICY_INFO * pCurPolicyInfoList = pPolicyInfoList;

            while (pCurPolicyInfoList)
            {
                IPSEC_POLICY_INFO * pPolInfo = new IPSEC_POLICY_INFO;
				if (NULL == pPolInfo)
				{
					hr = E_OUTOFMEMORY;
					continue;
				}

                pPolInfo->guidPolicyId = pCurPolicyInfoList->guidPolicyId;
                lstrcpyW(pPolInfo->szPolicyName, pCurPolicyInfoList->szPolicyName);
                lstrcpyW(pPolInfo->szPolicyDescription, pCurPolicyInfoList->szPolicyDescription);

                int idx;
                idx = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST, CB_ADDSTRING, 0,
                                    (LPARAM)(pCurPolicyInfoList->szPolicyName));
                if (idx != CB_ERR)
                    SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                                  CB_SETITEMDATA, idx, (LPARAM)pPolInfo);

                pCurPolicyInfoList = pCurPolicyInfoList->pNextPolicyInfo;
            }

            // now set active policy
            if (m_pGlobalInfo->m_strIpsecPol != c_szIpsecUnset)
            {
                if (m_pGlobalInfo->m_strIpsecPol == c_szIpsecNoPol)
                {
                    // no ipsec
                    hr = HrSelectActivePolicy(NULL);
                    Assert(S_OK == hr); // this should always succeed
                }
                else
                {
                    hr = HrSelectActivePolicy(&(m_pGlobalInfo->m_guidIpsecPol));

                    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        // policy does not exist
                        // NYI:pop-up message that the previous (custom) policy is no longer available

                        if (pActivePolicyInfo)
                            hr = HrSelectActivePolicy(&(pActivePolicyInfo->guidPolicyId));
                        else
                            hr = HrSelectActivePolicy(NULL);

                        Assert(S_OK == hr); // this should always succeed
                    }
                }
            }
            else
            {
                if (pActivePolicyInfo)
                    hr = HrSelectActivePolicy(&(pActivePolicyInfo->guidPolicyId));
                else
                    hr = HrSelectActivePolicy(NULL);

                Assert(S_OK == hr); // this should always succeed
            }

            // disabled the combo-box and radio button if no custom policy
            if (0 == Tcp_ComboBox_GetCount(GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST)))
            {
                ::EnableWindow(GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST), FALSE);
                ::EnableWindow(GetDlgItem(IDC_EDT_POLICY_DESC), FALSE);
                ::EnableWindow(GetDlgItem(IDC_RAD_IPSEC_CUSTOM), FALSE);
            }

            if (pPolicyInfoList)
            {
                HRESULT hrT = (*pfnHrFreeLocalIpSecPolicyList)(pPolicyInfoList);
                if (FAILED(hrT))
                {
                    TraceTag(ttidError, "HrFreeLocalIpSecPolicyList returned failure, hr = %x", hrT);
                }
            }
        }
        // release the library
        FreeLibrary (hPolStore);
    }
    else
    {
        // if failed to get the two export functions from polstore.dll
        TraceTag(ttidError, "Failed to load polstore.dll or get export function handle.");
        hr = E_FAIL;
    }

    TraceError("CIpSecDialog::HrShowLocalIpsecPolicy", hr);
    return hr;
}

HRESULT CIpSecDialog::HrSelectActivePolicy(GUID * pguidPolicyId)
{
    HRESULT hr = S_OK;

    HWND hPolicyCombo = GetDlgItem(IDC_CMB_IPSEC_POLICY_LIST);

    if (!pguidPolicyId)
    {
        CheckDlgButton(IDC_RAD_IPSEC_NOIPSEC, TRUE);
        Tcp_ComboBox_SetCurSel(hPolicyCombo, 0);
    }
    else
    {
        BOOL fFound = FALSE;

        // check if any available custom policy match this policy
        IPSEC_POLICY_INFO * pPolInfo;
        int nCount = Tcp_ComboBox_GetCount(hPolicyCombo);

        for (int i=0; i<nCount; i++)
        {
            pPolInfo = NULL;

            DWORD_PTR dw = ::SendMessage(hPolicyCombo, CB_GETITEMDATA, i, (LPARAM)0);

            if ((CB_ERR != dw) && (0 != dw))
                pPolInfo = (IPSEC_POLICY_INFO *)dw;

            if (pPolInfo->guidPolicyId == *pguidPolicyId)
            {
                fFound = TRUE;
                CheckDlgButton(IDC_RAD_IPSEC_CUSTOM, TRUE);

                Tcp_ComboBox_SetCurSel(hPolicyCombo, i);
                break;
            }
        }

        if (!fFound)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (SUCCEEDED(hr))
    {
        // set description text
        int idx = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST, CB_GETCURSEL, 0, 0);
        if (CB_ERR != idx)
        {
            DWORD_PTR dw = SendDlgItemMessage(IDC_CMB_IPSEC_POLICY_LIST,
                                          CB_GETITEMDATA, idx, (LPARAM)0);

            if (0 != dw)
            {
                IPSEC_POLICY_INFO * pIpsecInfo = (IPSEC_POLICY_INFO *)dw;

                SetDlgItemText(IDC_EDT_POLICY_DESC,pIpsecInfo->szPolicyDescription);
            }
        }
    }

    if (!pguidPolicyId)
    {
        ::EnableWindow(hPolicyCombo, FALSE);
        ::EnableWindow(GetDlgItem(IDC_EDT_POLICY_DESC), FALSE);
    }

    TraceError("CIpSecDialog::HrSelectActivePolicy", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgopt.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G O P T. C P P
//
//  Contents:   Implementation for CTcpOptionsPage
//
//  Notes:  CTcpOptionsPage is the Tcpip options page,
//          The other classes are pop-up dislogs for each option
//          on this page.
//
//  Author: tongl   29 Nov 1997
//-----------------------------------------------------------------------
//
// CTcpOptionsPage
//

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "dlgopt.h"
#include "dlgaddr.h"
#include "tcphelp.h"

//Whistler bug 123164, we remove the ipsec from the connection UI
const int c_rgsLanOptions[] = { c_iIpFilter };

//
// CTcpOptionsPage
//

CTcpOptionsPage::CTcpOptionsPage(CTcpAddrPage * pTcpAddrPage,
                                 ADAPTER_INFO * pAdapterDlg,
                                 GLOBAL_INFO  * pGlbDlg,
                                 const DWORD  * adwHelpIDs)
{
    Assert(pTcpAddrPage);
    Assert(pAdapterDlg);
    Assert(pGlbDlg);

    m_pParentDlg = pTcpAddrPage;
    m_pAdapterInfo = pAdapterDlg;
    m_pGlbInfo = pGlbDlg;
    m_adwHelpIDs = adwHelpIDs;

    m_fModified = FALSE;
    m_fPropDlgModified = FALSE;

    //IPSec is removed from connection UI   
    //m_fIpsecPolicySet = FALSE;
}

CTcpOptionsPage::~CTcpOptionsPage()
{
}

// message map functions
LRESULT CTcpOptionsPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // Initialize the list view
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    RECT      rc;
    LV_COLUMN lvc = {0};

    ::GetClientRect(hwndList, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(GetDlgItem(IDC_LVW_OPTIONS), 0, &lvc);

    // Insert options and description text
    LV_ITEM lvi = {0};
    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    int iMaxOptions = 0;
    const int * pOptions = NULL;

    // RAS connections don't have option tab at all
    ASSERT(!m_pAdapterInfo->m_fIsRasFakeAdapter);
    if (!m_pAdapterInfo->m_fIsRasFakeAdapter)
    {
        iMaxOptions = celems(c_rgsLanOptions);
        pOptions = c_rgsLanOptions;
    }

    for (int i = 0; i < iMaxOptions; i++)
    {
        lvi.iItem = i;

        OPTION_ITEM_DATA * pItemData = new OPTION_ITEM_DATA;

        if (NULL == pItemData)
            continue;

        ASSERT(pOptions);
        
        switch (pOptions[i])
        {
        case c_iIpFilter:
            pItemData->iOptionId = c_iIpFilter;
            pItemData->szName = (PWSTR) SzLoadIds(IDS_IP_FILTERING);
            pItemData->szDesc = (PWSTR) SzLoadIds(IDS_IP_FILTERING_DESC);
            break;

        default:
            AssertSz(FALSE, "Invalid option");
        }

        lvi.lParam = reinterpret_cast<LPARAM>(pItemData);
        lvi.pszText = pItemData->szName;

        INT ret;
        ret = ListView_InsertItem(hwndList, &lvi);
    }

    // set the top item as the current selection
    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    //this is a ras connection and a non-admin user, disable all the controls 
    //for globl settings
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
    {
        ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), FALSE);
    }
    
    return 0;
}

LRESULT CTcpOptionsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpOptionsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CTcpOptionsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    //IPSec is removed from connection UI   
    //if (!m_pParentDlg->m_fIpsecPolicySet)
    //    m_pParentDlg->m_fIpsecPolicySet = m_fIpsecPolicySet;

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpOptionsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnProperties(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);
    Assert(hwndList);

    LvProperties(hwndList);

    return 0;
}

LRESULT CTcpOptionsPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    Assert(pnmlv);

    // Check if selection changed
    if ((pnmlv->uNewState & LVIS_SELECTED) &&
        (!(pnmlv->uOldState & LVIS_SELECTED)))
    {
        // enable Property button if valid and update description text
        INT iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

        if (iSelected == -1) // Nothing selected or list empty
        {
            // if list is empty
            ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), FALSE);
            ::SetWindowText(GetDlgItem(IDC_OPT_DESC), c_szEmpty);
        }
        else
        {
            LV_ITEM lvItem;
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = iSelected;
            lvItem.iSubItem = 0;

            if (ListView_GetItem(hwndList, &lvItem))
            {
                OPTION_ITEM_DATA * pItemData = NULL;
                pItemData = reinterpret_cast<OPTION_ITEM_DATA *>(lvItem.lParam);
                if (pItemData)
                {
                    //this is a ras connection and a non-admin user, Dont enable the 
                    // "properties" button
                    if (!(m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin))
                    {
                        ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), TRUE);
                    }

                    ::SetWindowText(GetDlgItem(IDC_OPT_DESC), (PCWSTR)pItemData->szDesc);
                }
            }
        }
    }

    return 0;
}

LRESULT CTcpOptionsPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    INT iItem;
    DWORD dwpts;
    RECT rc;
    LV_HITTESTINFO lvhti;

    //don't bring up the propeties of the selected option if the user is not admin
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
        return 0;

    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    // we have the location
    dwpts = GetMessagePos();

    // translate it relative to the listview
    ::GetWindowRect( hwndList, &rc );

    lvhti.pt.x = LOWORD( dwpts ) - rc.left;
    lvhti.pt.y = HIWORD( dwpts ) - rc.top;

    // get currently selected item
    iItem = ListView_HitTest( hwndList, &lvhti );

    // if valid selection
    if (-1 != iItem)
    {
        LvProperties(hwndList);
    }

    return 0;
}

void CTcpOptionsPage::LvProperties(HWND hwndList)
{
    INT iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM     lvItem = {0};

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            OPTION_ITEM_DATA * pItemData = NULL;

            pItemData = reinterpret_cast<OPTION_ITEM_DATA *>(lvItem.lParam);

            if (pItemData)
            {
                // bring up the proper dialog
                switch(pItemData->iOptionId)
                {
                    case c_iIpFilter:
                    {
                        // make a copy of the global and adapter info & pass to the filter dialog
                        GLOBAL_INFO  glbInfo;
                        
                        glbInfo = *m_pGlbInfo;

                        ADAPTER_INFO adapterInfo;
                        adapterInfo = *m_pAdapterInfo;

                        CFilterDialog * pDlgFilter = new CFilterDialog(this, 
                                                            &glbInfo, 
                                                            &adapterInfo, 
                                                            g_aHelpIDs_IDD_FILTER);
                        if (NULL == pDlgFilter)
                            return;

                        if (pDlgFilter->DoModal() == IDOK)
                        {
                            if (m_fPropDlgModified)
                            {
                                // Something changed,
                                // so copy the changes and mark the page as modified
                                *m_pGlbInfo = glbInfo;
                                *m_pAdapterInfo = adapterInfo;

                                PageModified();
                                m_fPropDlgModified = FALSE;
                            }
                        }
                        delete pDlgFilter;
                    }
                    break;

                    default:
                        AssertSz(FALSE, "Invalid option");
                        break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgdns.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D N S . H
//
//  Contents:   CTcpDnsPage, CServerDialog and CSuffixDialog declaration
//
//  Notes:  The DNS page and related dialogs
//
//  Author: tongl   11 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

// maximum number of characters in the suffix edit control
const int SUFFIX_LIMIT = 255; 

//maximum length of domain name 
const int DOMAIN_LIMIT = 255; 

class CTcpDnsPage : public CPropSheetPage
{

public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpDnsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control message handlers
        // Push button message handlers
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_ADD,     OnAddServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_EDIT,    OnEditServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_REMOVE,  OnRemoveServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_UP,      OnServerUp)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_DOWN,    OnServerDown)

        COMMAND_ID_HANDLER(IDC_DNS_DOMAIN, OnDnsDomain)

        COMMAND_ID_HANDLER(IDC_DNS_SEARCH_DOMAIN,           OnSearchDomain)
        COMMAND_ID_HANDLER(IDC_DNS_SEARCH_PARENT_DOMAIN,    OnSearchParentDomain)
        COMMAND_ID_HANDLER(IDC_DNS_USE_SUFFIX_LIST,         OnUseSuffix)

        COMMAND_ID_HANDLER(IDC_DNS_ADDR_REG,     OnAddressRegister)
        COMMAND_ID_HANDLER(IDC_DNS_NAME_REG,     OnDomainNameRegister)

        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_ADD,      OnAddSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_EDIT,     OnEditSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_REMOVE,   OnRemoveSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_UP,       OnSuffixUp)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_DOWN,     OnSuffixDown)

        // Notification handlers
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_LIST,     OnServerList)

        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_LIST,     OnSuffixList)

    END_MSG_MAP()

// Constructors/Destructors
    CTcpDnsPage(CTcpAddrPage * pTcpAddrPage,
                ADAPTER_INFO * pAdapterDlg,
                GLOBAL_INFO * pGlbDlg,
                const DWORD * adwHelpIDs = NULL);

    ~CTcpDnsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // DNS server list
    LRESULT OnAddServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // DNS domain
    LRESULT OnDnsDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // Search order radio buttons
    LRESULT OnSearchDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSearchParentDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // DNS suffix list
    LRESULT OnAddSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnServerList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // ip address and name dynamic registration
    LRESULT OnAddressRegister(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDomainNameRegister(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

// Handlers
public:

    void OnServerChange();
    void OnSuffixChange();


// Attributes
public:
    tstring         m_strNewIpAddress; // server: either the one added, or edited
    tstring         m_strNewSuffix;

    // server: used as work space for moving entries in the listboxes
    tstring         m_strMovingEntry;  

    tstring         m_strAddServer; // OK or Add button server dialog
    tstring         m_strAddSuffix; // OK or Add button suffix dialog
    BOOL            m_fEditState;

    HANDLES         m_hServers;
    HANDLES         m_hSuffix;

private:
    CTcpAddrPage *   m_pParentDlg;
    ADAPTER_INFO *          m_pAdapterInfo;
    GLOBAL_INFO *           m_pglb;

    BOOL            m_fModified;

    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    // help functions
    void EnableSuffixGroup(BOOL fEnable);
};

class CServerDialog : public CDialogImpl<CServerDialog>
{
public:

    enum { IDD = IDD_DNS_SERVER };

    BEGIN_MSG_MAP(CServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,                    OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,                OnCancel);

        COMMAND_ID_HANDLER(IDC_DNS_CHANGE_SERVER,   OnChange);

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()

public:
    CServerDialog(CTcpDnsPage * pTcpDnsPage, const DWORD* pamhidsHelp = NULL, int iIndex = -1);
    ~CServerDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Dialog creation overides
public:

    IpControl m_ipAddress;

private:
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpDnsPage * m_pParentDlg;
    const DWORD * m_adwHelpIDs;
    int m_iIndex;
};

class CSuffixDialog : public CDialogImpl<CSuffixDialog>
{
public:

    enum { IDD = IDD_DNS_SUFFIX };

    BEGIN_MSG_MAP(CSuffixDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_DNS_CHANGE_SUFFIX,   OnChange);
    END_MSG_MAP()

//
public:
    CSuffixDialog(CTcpDnsPage * pTcpDnsPage, const DWORD* pamhidsHelp = NULL, int iIndex = -1);
    ~CSuffixDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    HWND m_hEdit;       //
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpDnsPage *   m_pParentDlg;
    const DWORD *   m_adwHelpIDs;
    int             m_iIndex;       
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgopt.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G O P T. H
//
//  Contents:   Declaration for CTcpOptionsPage, CIpSecDialog
//
//  Notes:  CTcpOptionsPage is the Tcpip options page,
//          The other classes are pop-up dislogs for each option
//          on this page.
//
//  Author: tongl   29 Nov 1997
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

#define FILTER_ADD_LIMIT  5

struct OPTION_ITEM_DATA
{
    INT         iOptionId;
    PWSTR      szName;
    PWSTR      szDesc;
};

// The options page
class CTcpOptionsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpOptionsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_OPT_PROPERTIES, OnProperties)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)

    END_MSG_MAP()

    // Constructors/Destructors
    CTcpOptionsPage(CTcpAddrPage * pTcpAddrPage,
                    ADAPTER_INFO * pAdapterDlg,
                    GLOBAL_INFO  * pGlbDlg,
                    const DWORD  * adwHelpIDs = NULL);

    ~CTcpOptionsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command and notification handlers
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Declare friend class
    friend class CIpSecDialog;
    friend class CFilterDialog;

// Implementation
private:

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    void LvProperties(HWND hwndList);

    // data members
    CTcpipcfg *     m_ptcpip;
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    GLOBAL_INFO  *  m_pGlbInfo;
    const DWORD*    m_adwHelpIDs;

    BOOL            m_fModified;

    // Has any of the property dialogs been modified ?
    BOOL    m_fPropDlgModified;

    BOOL    m_fIpsecPolicySet;
};

/* IP Security dialog is removed
// The IP Security dialog
class CIpSecDialog : public CDialogImpl<CIpSecDialog>
{
public:

    enum { IDD = IDD_IPSEC };

    BEGIN_MSG_MAP(CIpSecDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog);

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        // command handlers
        COMMAND_ID_HANDLER(IDC_RAD_IPSEC_NOIPSEC, OnNoIpsec);
        COMMAND_ID_HANDLER(IDC_RAD_IPSEC_CUSTOM, OnUseCustomPolicy);
        COMMAND_ID_HANDLER(IDC_CMB_IPSEC_POLICY_LIST, OnSelectCustomPolicy);

    END_MSG_MAP()
//
public:
    CIpSecDialog( CTcpOptionsPage * pOptionsPage,
                  GLOBAL_INFO * pGlbDlg,
                  const DWORD* pamhidsHelp = NULL);

    ~CIpSecDialog();

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnNoIpsec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSelectCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    HRESULT HrGetDomainIpsecPolicy(BOOL * pfHasDomainIpsecPolicy,
                                   tstring * pszDomainIpsecPolicyName);

    HRESULT HrShowDomainIpsecPolicy(PCWSTR szDomainIpsecPolicyName);
    HRESULT HrShowLocalIpsecPolicy();
    HRESULT HrSelectActivePolicy(GUID * guidIpsecPol);

    BOOL m_fInInitDialog;

    CTcpOptionsPage * m_pParentDlg;
    GLOBAL_INFO *  m_pGlobalInfo;
    const DWORD *  m_adwHelpIDs;
};
*/

// Tcpip security (Trajon) dialogs
class CFilterDialog;

class CAddFilterDialog : public CDialogImpl<CAddFilterDialog>
{
public:

    enum { IDD = IDD_FILTER_ADD };

    BEGIN_MSG_MAP(CAddFilterDialog)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_FILTERING_ADD_EDIT,  OnFilterAddEdit);

    END_MSG_MAP()
//
public:
    CAddFilterDialog(CFilterDialog* pParentDlg, int ID, const DWORD* adwHelpIDs = NULL);
    ~CAddFilterDialog();

// Dialog creation overides
public:

// Command Handlers
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnFilterAddEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    CFilterDialog*    m_pParentDlg;
    int               m_nId;
    HWND              m_hList;
    const DWORD*      m_adwHelpIDs;
};

class CFilterDialog : public CDialogImpl<CFilterDialog>
{
public:

    enum { IDD = IDD_FILTER };

    BEGIN_MSG_MAP(CFilterDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        // Enable Filtering checkbox
        COMMAND_ID_HANDLER(IDC_FILTERING_ENABLE,     OnEnableFiltering);

        // The TCP ports radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_TCP,     OnTcpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_TCP_SEL, OnTcpPermit);

        // The UDP ports radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_UDP,     OnUdpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_UDP_SEL, OnUdpPermit);

        // The IP Protocols radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_IP,      OnIpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_IP_SEL,  OnIpPermit);

        // Add buttons for TCP, UDP and IP

        COMMAND_ID_HANDLER(IDC_FILTERING_TCP_ADD,  OnAdd);
        COMMAND_ID_HANDLER(IDC_FILTERING_UDP_ADD,  OnAdd);
        COMMAND_ID_HANDLER(IDC_FILTERING_IP_ADD,   OnAdd);

        // Remove buttons for TCP, UDP and IP

        COMMAND_ID_HANDLER(IDC_FILTERING_TCP_REMOVE,  OnRemove);
        COMMAND_ID_HANDLER(IDC_FILTERING_UDP_REMOVE,  OnRemove);
        COMMAND_ID_HANDLER(IDC_FILTERING_IP_REMOVE,   OnRemove);

    END_MSG_MAP()

    friend class CAddFilterDialog;

public:
    CFilterDialog(  CTcpOptionsPage * pOptionsPage,
                    GLOBAL_INFO * pGlbDlg,
                    ADAPTER_INFO * pAdapterDlg,
                    const DWORD* pamhidsHelp = NULL);

    ~CFilterDialog();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnEnableFiltering(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnTcpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUdpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    // help functions
    void    SetInfo();
    void    UpdateInfo();
    void    EnableGroup(int nId, BOOL state);
    void    SetButtons();

    // data members
    GLOBAL_INFO *       m_pGlobalInfo;
    ADAPTER_INFO *      m_pAdapterInfo;

    CTcpOptionsPage *   m_pParentDlg;
    BOOL                m_fModified;

    const   DWORD * m_adwHelpIDs;

    HWND    m_hlistTcp;
    HWND    m_hlistUdp;
    HWND    m_hlistIp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgras.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G R A S. C P P
//
//  Contents:   Implementation for CTcpRasPage
//
//  Notes:  CTcpRasPage is for setting PPP/SLIP specific parameters
//
//  Author: tongl   10 Apr 1998
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "dlgras.h"
#include "dlgaddr.h"

//
// CTcpRasPage
//

CTcpRasPage::CTcpRasPage( CTcpAddrPage * pTcpAddrPage,
                          ADAPTER_INFO * pAdapterDlg,
                          const DWORD  * adwHelpIDs )
{
    Assert(pTcpAddrPage);
    Assert(pAdapterDlg);

    m_pParentDlg = pTcpAddrPage;
    m_pAdapterInfo = pAdapterDlg;
    m_adwHelpIDs = adwHelpIDs;

    m_fModified = FALSE;
}

CTcpRasPage::~CTcpRasPage()
{
}

LRESULT CTcpRasPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    AssertSz(((CONNECTION_RAS_PPP == m_pParentDlg->m_ConnType)||
              (CONNECTION_RAS_SLIP == m_pParentDlg->m_ConnType)||
              (CONNECTION_RAS_VPN == m_pParentDlg->m_ConnType)),
              "Why bring up the RAS property on a non-RAS connection?");

	// Fix bug 381870, If the interface is demand dial, then disable 
	// the "Use default gateway on the remote network" checkbox
	if (m_pAdapterInfo->m_fIsDemandDialInterface)
	{
		::EnableWindow(GetDlgItem(IDC_STATIC_REMOTE_GATEWAY), FALSE);
		::EnableWindow(GetDlgItem(IDC_REMOTE_GATEWAY), FALSE);
	}
	

	// Set the "Use default gateway on the remote network" checkbox
	CheckDlgButton(IDC_REMOTE_GATEWAY, m_pAdapterInfo->m_fUseRemoteGateway);
	
    if (CONNECTION_RAS_PPP == m_pParentDlg->m_ConnType)
    {
        ::ShowWindow(GetDlgItem(IDC_GRP_SLIP), SW_HIDE);

        // if PPP connection, hide "Frame Size" control
        ::ShowWindow(GetDlgItem(IDC_CMB_FRAME_SIZE), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_STATIC_FRAME_SIZE), SW_HIDE);
    }
    else if (CONNECTION_RAS_VPN == m_pParentDlg->m_ConnType)
    {
        //if VPN connection, hide the group box and the "Frame Size" control
        ::ShowWindow(GetDlgItem(IDC_GRP_PPP), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_GRP_SLIP), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CHK_USE_COMPRESSION), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CMB_FRAME_SIZE), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_STATIC_FRAME_SIZE), SW_HIDE);
    }
    else
    {
        ::ShowWindow(GetDlgItem(IDC_GRP_PPP), SW_HIDE);

        // initialize the combo box & show current selection
        int idx;

        idx = SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_ADDSTRING, 0,
                                  (LPARAM)(c_szFrameSize1006));
        if (idx != CB_ERR)
        {
            SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETITEMDATA,
                               idx, (LPARAM)c_dwFrameSize1006);

            if (1006 == m_pParentDlg->m_pAdapterInfo->m_dwFrameSize)
                SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETCURSEL, idx, 0);
        }

        idx = SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_ADDSTRING, 0,
                                  (LPARAM)(c_szFrameSize1500));
        if (idx != CB_ERR)
        {
           SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETITEMDATA,
                               idx, (LPARAM)c_dwFrameSize1500);

           if (1500 == m_pParentDlg->m_pAdapterInfo->m_dwFrameSize)
            {
                SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETCURSEL, idx, 0);
            }
        }
    }

    // initialize the checkbox
    CheckDlgButton(IDC_CHK_USE_COMPRESSION,
                   m_pParentDlg->m_pAdapterInfo->m_fUseIPHeaderCompression);

    return 0;
}

LRESULT CTcpRasPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpRasPage::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CTcpRasPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    // update value in second memory

    // Add remote gateway stuff
    BOOL fUseRemoteGateway = IsDlgButtonChecked(IDC_REMOTE_GATEWAY);
    if (fUseRemoteGateway != m_pAdapterInfo->m_fUseRemoteGateway)
    {
        m_pAdapterInfo->m_fUseRemoteGateway = fUseRemoteGateway;
        PageModified();
    }

    // header compression
    BOOL fUseHeaderCompression = IsDlgButtonChecked(IDC_CHK_USE_COMPRESSION);
    if (fUseHeaderCompression != m_pAdapterInfo->m_fUseIPHeaderCompression)
    {
        m_pAdapterInfo->m_fUseIPHeaderCompression = fUseHeaderCompression;
        PageModified();
    }

    // frame size
    if (CONNECTION_RAS_SLIP == m_pParentDlg->m_ConnType)
    {
        int idx = SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_GETCURSEL, 0L, 0L);
        if (idx != CB_ERR)
        {
            DWORD dwFrameSize = SendDlgItemMessage(IDC_CMB_FRAME_SIZE, 
                                                   CB_GETITEMDATA, idx, 0L);

            if ((dwFrameSize != CB_ERR) && (dwFrameSize != m_pAdapterInfo->m_dwFrameSize))
            {
                PageModified();
                m_pAdapterInfo->m_dwFrameSize = dwFrameSize;
            }
        }
    }

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgras.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G R A S. H
//
//  Contents:   Declaration for CTcpRasPage
//
//  Notes:  CTcpRasPage is for setting PPP/SLIP specific parameters
//
//  Author: tongl   10 Apr 1998
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>

class CTcpRasPage : public CPropSheetPage
{

public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpRasPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

    END_MSG_MAP()

// Constructors/Destructors
    CTcpRasPage(CTcpAddrPage * pTcpAddrPage,
                ADAPTER_INFO * pAdapterDlg,
                const DWORD * adwHelpIDs = NULL);

    ~CTcpRasPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
    CTcpAddrPage *   m_pParentDlg;
    ADAPTER_INFO *   m_pAdapterInfo;

    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\ipctrl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P C T R L . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ipctrl.h"
#include "tcpip.h"

///////////////////////////////////////////////////////////////////////
//
// IP Address control helpers

IpControl::IpControl()
{
    m_hIpAddress = 0;
}

IpControl::~IpControl()
{
}

BOOL IpControl::Create(HWND hParent, UINT nId)
{
    Assert(IsWindow(hParent));

    if (hParent)
        m_hIpAddress = GetDlgItem(hParent, nId);

    return m_hIpAddress != NULL;
}

LRESULT IpControl::SendMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Assert(IsWindow(m_hIpAddress));

    return ::SendMessage(m_hIpAddress, uMsg, wParam, lParam);
}

BOOL IpControl::IsBlank()
{
    return SendMessage(IPM_ISBLANK, 0, 0);
}

void IpControl::SetAddress(DWORD ardwAddress[4])
{
    SendMessage(IPM_SETADDRESS, 0,
                MAKEIPADDRESS(ardwAddress[0], ardwAddress[1],
                              ardwAddress[2], ardwAddress[3]));
}

void IpControl::SetAddress(DWORD a1, DWORD a2, DWORD a3, DWORD a4)
{
    SendMessage(IPM_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}

void IpControl::SetAddress(PCWSTR pszString)
{
    Assert(pszString != NULL);
    SendMessage(WM_SETTEXT, 0, (LPARAM)pszString);
}

void IpControl::GetAddress(DWORD *a1, DWORD *a2, DWORD *a3, DWORD *a4)
{
    DWORD dwAddress;

    Assert(a1 && a2 && a3 && a4);

    if (SendMessage(IPM_GETADDRESS,0,(LPARAM)&dwAddress)== 0)
    {
        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else
    {
        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }
}

void IpControl::GetAddress(DWORD ardwAddress[4])
{
    DWORD dwAddress;

    if (SendMessage(IPM_GETADDRESS, 0, (LPARAM)&dwAddress ) == 0)
    {
        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else
    {
        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }
}

void IpControl::GetAddress(tstring * pstrAddress)
{
    WCHAR szIpAddress[1000];

    if (SendMessage(WM_GETTEXT, celems(szIpAddress), (LPARAM)&szIpAddress) == 0)
    {
        *pstrAddress = ZERO_ADDRESS;
    }
    else
    {
        *pstrAddress = szIpAddress;
    }
}

void IpControl::SetFocusField(DWORD dwField)
{
    SendMessage(IPM_SETFOCUS, dwField, 0);
}

void IpControl::ClearAddress()
{
    SendMessage(IPM_CLEARADDRESS, 0, 0);
}

void IpControl::SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax)
{
    SendMessage(IPM_SETRANGE, dwField, MAKEIPRANGE(dwMin,dwMax));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgwins.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P W I N S . H
//
//  Contents:   CTcpWinsPage declaration
//
//  Notes:  The "WINS Address" page
//
//  Author: tongl   12 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"
#include "tcpconst.h"

class CTcpWinsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpWinsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_WINS_ADD,            OnAddServer)
        COMMAND_ID_HANDLER(IDC_WINS_EDIT,           OnEditServer)
        COMMAND_ID_HANDLER(IDC_WINS_REMOVE,         OnRemoveServer)
        COMMAND_ID_HANDLER(IDC_WINS_UP,             OnServerUp)
        COMMAND_ID_HANDLER(IDC_WINS_DOWN,           OnServerDown)
        COMMAND_ID_HANDLER(IDC_WINS_SERVER_LIST,    OnServerList)

        COMMAND_ID_HANDLER(IDC_WINS_LOOKUP,     OnLookUp)
        COMMAND_ID_HANDLER(IDC_WINS_LMHOST,     OnLMHost)

        COMMAND_ID_HANDLER(IDC_RAD_ENABLE_NETBT,    OnEnableNetbios)
        COMMAND_ID_HANDLER(IDC_RAD_DISABLE_NETBT,   OnDisableNetbios)
        COMMAND_ID_HANDLER(IDC_RAD_UNSET_NETBT,     OnUnsetNetBios)

    END_MSG_MAP()

// Constructors/Destructors
public:

    CTcpWinsPage(CTcpipcfg * ptcpip,
                 CTcpAddrPage * pTcpAddrPage,
                 ADAPTER_INFO * pAdapterDlg,
                 GLOBAL_INFO * pGlbDlg,
                 const DWORD * phelpIDs = NULL);

public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam,
                          LPARAM lParam, BOOL& fHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam,
                   LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // control message handlers
    LRESULT OnAddServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnLookUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLMHost(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnEnableNetbios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDisableNetbios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUnsetNetBios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:

    // This function adds card descriptions to the combo box
    BOOL InitPage();
    void UpdateIpInfo();
    static UINT_PTR CALLBACK HookProcOldStyle(
        HWND hdlg,      // handle to dialog box
        UINT uiMsg,      // message identifier
        WPARAM wParam,  // message parameter
        LPARAM lParam   // message parameter
        )
    {
        return 0;
    }
	

private:

    CTcpipcfg *     m_ptcpip;
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    GLOBAL_INFO *   m_pglb;

    BOOL            m_fModified;
    BOOL            m_fLmhostsFileReset;
    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    OPENFILENAME        m_ofn;
    WCHAR               m_szFilter[IP_LIMIT];

public:
    // server: either the one added, or edited
    tstring         m_strNewIpAddress;

    // server: used as work space for moving entries in the listboxes
    tstring         m_strMovingEntry;

    tstring         m_strAddServer; // OK or Add button server dialog
    BOOL            m_fEditState;

    HANDLES             m_hServers;

};

class CWinsServerDialog : public CDialogImpl<CWinsServerDialog>
{
public:

    enum { IDD = IDD_WINS_SERVER };

    BEGIN_MSG_MAP(CWinsServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,                    OnOk)
        COMMAND_ID_HANDLER(IDCANCEL,                OnCancel)

        COMMAND_ID_HANDLER(IDC_WINS_CHANGE_SERVER,   OnChange)

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)
    END_MSG_MAP()

public:
    CWinsServerDialog(CTcpWinsPage * pTcpWinsPage, 
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CWinsServerDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Dialog creation overides
public:

    IpControl m_ipAddress;

private:
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpWinsPage * m_pParentDlg;
    const  DWORD * m_adwHelpIDs;
    int            m_iIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgwins.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P W I N S . C P P
//
//  Contents:   CTcpWinsPage implementation
//
//  Notes:  The "WINS Address" page
//
//  Author: tongl   12 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncmisc.h"
#include "tcpconst.h"
#include "tcpipobj.h"
#include "resource.h"
#include "tcpmacro.h"
#include "dlgaddr.h"
#include "dlgwins.h"

#include "tcpconst.h"
#include "tcputil.h"
#include "tcphelp.h"

#define MAX_WINS_SERVER     12
#define MAX_RAS_WINS_SERVER 2

CTcpWinsPage::CTcpWinsPage( CTcpipcfg * ptcpip,
                            CTcpAddrPage * pTcpAddrPage,
                            ADAPTER_INFO * pAdapterDlg,
                            GLOBAL_INFO  * pGlbDlg,
                            const DWORD  * adwHelpIDs)
{
    // Save everything passed to us
    Assert(ptcpip != NULL);
    m_ptcpip = ptcpip;

    Assert(pTcpAddrPage != NULL);
    m_pParentDlg = pTcpAddrPage;

    Assert(pAdapterDlg != NULL);
    m_pAdapterInfo = pAdapterDlg;

    Assert(pGlbDlg != NULL);
    m_pglb = pGlbDlg;

    m_adwHelpIDs = adwHelpIDs;

    // Initialize internal states
    m_fModified = FALSE;
    m_fLmhostsFileReset = FALSE;

    WCHAR* pch;

    // gives double NULL by default
    ZeroMemory(m_szFilter, sizeof(m_szFilter));
    ZeroMemory(&m_ofn, sizeof(m_ofn));
    wsprintfW(m_szFilter, L"%s|%s", (PCWSTR)SzLoadIds(IDS_COMMONDLG_TEXT),  L"*.*");

    // replace '|' with NULL, required by common dialog
    pch = m_szFilter;
    while ((pch = wcschr(pch, '|')) != NULL)
            *pch++ = L'\0';

    m_ofn.lStructSize = sizeof(OPENFILENAME);
    m_ofn.hInstance = _Module.GetModuleInstance();
    m_ofn.lpstrFilter = m_szFilter;
    m_ofn.nFilterIndex = 1L;
}

LRESULT CTcpWinsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    // Initialize the Wins address listbox
    m_fEditState = FALSE;

    // Cache hwnds
    m_hServers.m_hList      = GetDlgItem(IDC_WINS_SERVER_LIST);
    m_hServers.m_hAdd       = GetDlgItem(IDC_WINS_ADD);
    m_hServers.m_hEdit      = GetDlgItem(IDC_WINS_EDIT);
    m_hServers.m_hRemove    = GetDlgItem(IDC_WINS_REMOVE);
    m_hServers.m_hUp        = GetDlgItem(IDC_WINS_UP);
    m_hServers.m_hDown      = GetDlgItem(IDC_WINS_DOWN);

    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_WINS_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_WINS_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Get the Service address Add and Edit button Text and remove ellipse
    WCHAR   szAddServer[16];

    GetDlgItemText(IDC_WINS_ADD, szAddServer, celems(szAddServer));

    szAddServer[lstrlenW(szAddServer) - c_cchRemoveCharatersFromEditOrAddButton] = 0;
    m_strAddServer = szAddServer;

    // Initialize controls on this page
    // WINS server list box
    int nResult= LB_ERR;
    for(VSTR_ITER iterWinsServer = m_pAdapterInfo->m_vstrWinsServerList.begin() ;
        iterWinsServer != m_pAdapterInfo->m_vstrWinsServerList.end() ;
        ++iterWinsServer)
    {
        nResult = Tcp_ListBox_InsertString(m_hServers.m_hList, -1,
                                           (*iterWinsServer)->c_str());
    }

    // set slection to first item
    if (nResult >= 0)
    {
        Tcp_ListBox_SetCurSel(m_hServers.m_hList, 0);
    }

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    // Enable LMHosts lookup ?
    CheckDlgButton(IDC_WINS_LOOKUP, m_pglb->m_fEnableLmHosts);
    ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST), m_pglb->m_fEnableLmHosts);

    // Enable NetBt ?
    CheckDlgButton( IDC_RAD_ENABLE_NETBT,
                    (c_dwEnableNetbios == m_pAdapterInfo->m_dwNetbiosOptions));

    CheckDlgButton( IDC_RAD_DISABLE_NETBT,
                    (c_dwDisableNetbios == m_pAdapterInfo->m_dwNetbiosOptions));

    CheckDlgButton( IDC_RAD_UNSET_NETBT,
                    (c_dwUnsetNetbios == m_pAdapterInfo->m_dwNetbiosOptions));
    
    if (m_pAdapterInfo->m_fIsRasFakeAdapter)
    {
        //if this is a ras connection, disable the default Netbt option since it
        //doesn't apply to RAS connections
        ::EnableWindow(GetDlgItem(IDC_RAD_UNSET_NETBT), FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_DEFALUT_NBT), FALSE);

        //this is a ras connection and a non-admin user, disable all the controls 
        //for globl settings
        if (m_pParentDlg->m_fRasNotAdmin)
        {
            ::EnableWindow(GetDlgItem(IDC_WINS_STATIC_GLOBAL), FALSE);
            ::EnableWindow(GetDlgItem(IDC_WINS_LOOKUP), FALSE);
            ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST), FALSE);
        }

    }
    

    return 0;
}

LRESULT CTcpWinsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpWinsPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpWinsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpWinsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CTcpWinsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    // server list
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrWinsServerList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    WCHAR szBuf[IP_LIMIT];

    for (int i = 0; i < nCount; i++)
    {
        #ifdef DBG
            int len = Tcp_ListBox_GetTextLen(m_hServers.m_hList, i);
            Assert(len != LB_ERR && len < IP_LIMIT);
        #endif

        Tcp_ListBox_GetText(m_hServers.m_hList, i, szBuf);
        m_pAdapterInfo->m_vstrWinsServerList.push_back(new tstring(szBuf));
    }

    // save checkbox states
    m_pglb->m_fEnableLmHosts = IsDlgButtonChecked(IDC_WINS_LOOKUP);

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    m_pParentDlg->m_fLmhostsFileReset = m_fLmhostsFileReset;

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpWinsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpWinsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, FALSE);
    return 0;
}

// WINS server related controls
LRESULT CTcpWinsPage::OnAddServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CWinsServerDialog DlgSrv(this, g_aHelpIDs_IDD_WINS_SERVER);

    if (DlgSrv.DoModal() == IDOK)
    {
        int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hServers.m_hList,
                                           -1,
                                           m_strNewIpAddress.c_str());
        Assert(idx>=0);
        if (idx >= 0)
        {
            PageModified();

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
            SetButtons(m_hServers,
                (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnEditServer(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;


    Assert(Tcp_ListBox_GetCount(m_hServers.m_hList));

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    Assert(idx >= 0);

    CWinsServerDialog DlgSrv(this, g_aHelpIDs_IDD_WINS_SERVER, idx);

    // save off the removed address and delete if from the listbox
    if (idx >= 0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;  // used by dialog to display what to edit

        if (DlgSrv.DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

            PageModified();

            m_strMovingEntry = m_strNewIpAddress;
            ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

            m_strNewIpAddress = buf;  // restore the original removed address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnRemoveServer(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;
        Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;

        if ((nCount = Tcp_ListBox_GetCount(m_hServers.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
        }
        SetButtons(m_hServers,
            (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);
    }
    return 0;
}

LRESULT CTcpWinsPage::OnServerUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    return 0;
}


LRESULT CTcpWinsPage::OnServerDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    return 0;
}

LRESULT CTcpWinsPage::OnServerList(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hServers,
            (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpWinsPage::OnLookUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{

    ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST),
                   IsDlgButtonChecked(IDC_WINS_LOOKUP) == BST_CHECKED);


    PageModified();
    return 0;
}

LRESULT CTcpWinsPage::OnLMHost(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szFileName[MAX_PATH] = {NULL}; // initialize first character
    WCHAR szFileTitle[MAX_PATH] = {NULL}; // initialize first character

    // see if the Lookup check-box is checked
    Assert(IsDlgButtonChecked(IDC_WINS_LOOKUP) == BST_CHECKED);

    // add runtime info
    m_ofn.hwndOwner         = m_hWnd;
    m_ofn.lpstrFile         = szFileName;
    m_ofn.nMaxFile          = celems(szFileName);
    m_ofn.lpstrFileTitle    = szFileTitle;
    m_ofn.nMaxFileTitle     = celems(szFileTitle);

    //if we are in GUI setup mode, explorer is not registered yet.
    //we need to use the old style of File Open dialog
    m_ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    if (!FInSystemSetup())
    {
        m_ofn.Flags |= OFN_EXPLORER;
    }
    else
    {
        m_ofn.Flags |= OFN_ENABLEHOOK;
        m_ofn.lpfnHook = HookProcOldStyle;
    }

    WCHAR szSysPath[MAX_PATH];
    WCHAR szSysPathBackup[MAX_PATH];

    BOOL fSysPathFound = (GetSystemDirectory(szSysPath, MAX_PATH) != 0);

    if (fSysPathFound  && GetOpenFileName(&m_ofn)) // bring up common dialog
    {
        lstrcpyW(szSysPathBackup, szSysPath);
        wcscat(szSysPath, RGAS_LMHOSTS_PATH);

        // Backup the original lmhosts file if it hasn't been set dirty
        if (!m_ptcpip->FIsSecondMemoryLmhostsFileReset())
        {
            wcscat(szSysPathBackup, RGAS_LMHOSTS_PATH_BACKUP);

            WIN32_FIND_DATA FileData;
            if (FindFirstFile(szSysPath, &FileData) != INVALID_HANDLE_VALUE)
            {
                BOOL ret;

                // Copy lmhosts file to lmhosts.bak if it already exists
                ret = CopyFile(szSysPath, szSysPathBackup, FALSE);
                AssertSz(ret, "Failed to backup existing lmhosts file!");
            }
        }

        if (CopyFile(szFileName, szSysPath, FALSE) == 0) // overwrie lmhosts file
        {
            TraceError("CTcpWinsPage::OnLMHost", HrFromLastWin32Error());

            // cannot copy the file to the %system32%\drivers\etc dir
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_CANNOT_CREATE_LMHOST_ERROR,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                     szSysPath);
            return 0;
        }
        else
        {
            // Set the flag so we can notify netbt of the change
            m_fLmhostsFileReset = TRUE;
        }

        TraceTag(ttidTcpip,"File Selected: %S", szSysPath);
    }
    else
    {
        // syspath failed
        if (fSysPathFound == FALSE)
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_WINS_SYSTEM_PATH,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        else if (szFileName[0] != NULL) // get open failed
        {
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_WINS_LMHOSTS_FAILED,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                     szSysPath);
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnEnableNetbios(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwEnableNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwEnableNetbios;
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpWinsPage::OnDisableNetbios(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwDisableNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwDisableNetbios;
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpWinsPage::OnUnsetNetBios(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwUnsetNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwUnsetNetbios;
        }
        break;
    } // switch

    return 0;
}

//
// CWinsServerDialog
//

CWinsServerDialog::CWinsServerDialog(CTcpWinsPage * pTcpWinsPage,
                                     const DWORD* adwHelpIDs,
                                     int iIndex)
{
    Assert(pTcpWinsPage);
    m_pParentDlg = pTcpWinsPage;
    m_hButton = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CWinsServerDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddServer.c_str());

    m_ipAddress.Create(m_hWnd, IDC_WINS_CHANGE_SERVER);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_WINS_SERVER_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_pParentDlg->m_strNewIpAddress.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewIpAddress = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_ipAddress);
    return 0;
}

LRESULT CWinsServerDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CWinsServerDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CWinsServerDialog::OnChange(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CWinsServerDialog::OnOk(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    tstring strIp;
    m_ipAddress.GetAddress(&strIp);

    // Validate
    if (!FIsIpInRange(strIp.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hServers.m_hList, strIp.c_str());
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_WINS_SERVER,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 strIp.c_str());

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and
        // add them to the adapter if valid
        m_pParentDlg->m_strNewIpAddress = strIp;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_pParentDlg->m_strNewIpAddress)
            m_pParentDlg->m_strNewIpAddress = strIp; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CWinsServerDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CWinsServerDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                           BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };

    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CWinsServerDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>
#include <wchar.h>
#include <winsock2.h>
#include <dnsapi.h>

#include "stlalgor.h"
#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\resource.h ===
#include "ncres.h"

#define IDD_ATM_ADDR                    2300
#define IDD_ATM_ARPC                    2301
#define IDD_DNS_SERVER                  2304
#define IDD_DNS_SUFFIX                  2305
#define IDD_IPADDR_ADV                  2308
#define IDD_IPADDR_ADV_CHANGEGATE       2309
#define IDD_IPADDR_ADV_CHANGEIP         2310
#define IDD_TCP_DNS                     2322
#define IDD_TCP_IPADDR                  2323
#define IDD_TCP_WINS                    2324
#define IDD_TCP_NAMESVC                 2325
#define IDD_WINS_SERVER                 2326
#define IDD_TCP_OPTIONS                 2327
#define IDD_DHCP_CLSID                  2328
//#define IDD_IPSEC                       2329
#define IDD_OPT_RAS                     2330
#define IDD_TCP_IPADDR_RAS              2331
#define IDD_FILTER                      2332
#define IDD_FILTER_ADD                  2333
#define IDD_BACK_UP                     2334

#define IDI_UP_ARROW                    101
#define IDI_DOWN_ARROW                  102
#define IDI_IPADDR                      103
#define IDI_IPADV                       104
#define IDI_IPNAME                      105

// IP address page
#define IDC_IP_DHCP             1000
#define IDC_IP_FIXED            1001
#define IDC_IPADDR_IP           1002
#define IDC_IPADDR_SUB          1003
#define IDC_IPADDR_GATE         1004
#define IDC_IPADDR_IPTEXT       1005
#define IDC_IPADDR_SUBTEXT      1006
#define IDC_IPADDR_GATETEXT     1007

#define IDC_IPADDR_TEXT         1008

#define IDC_DNS_DHCP            1009
#define IDC_DNS_FIXED           1010
#define IDC_DNS_PRIMARY         1011
#define IDC_DNS_SECONDARY       1012
#define IDC_DNS_PRIMARY_TEXT    1013
#define IDC_DNS_SECONDARY_TEXT  1014

#define IDC_IPADDR_ADVANCED     1015

// Advanced IP address dialog
#define IDC_IPADDR_ADVIP            1016
#define IDC_IPADDR_ADDIP            1017
#define IDC_IPADDR_EDITIP           1018
#define IDC_IPADDR_REMOVEIP         1019

#define IDC_IPADDR_ADDGATE      1020
#define IDC_IPADDR_EDITGATE     1021
#define IDC_IPADDR_REMOVEGATE   1022
#define IDC_IPADDR_UP           1023
#define IDC_IPADDR_DOWN         1024
#define IDC_IPADDR_ADV_CHANGEIP_IP      1025
#define IDC_IPADDR_ADV_CHANGEIP_SUB     1026
#define IDC_IPADDR_ADV_CHANGE_GATEWAY   1027
#define IDC_IPADDR_ADV_CHANGE_METRIC    1028
#define IDC_IPADDR_METRIC       1029
#define IDC_AUTO_METRIC         1030

// DNS page
#define IDC_DNS_DOMAIN          1031
#define IDC_DNS_DOMAIN_STATIC   1032
#define IDC_DNS_SERVER_LIST     1040
#define IDC_DNS_SERVER_ADD      1041
#define IDC_DNS_SERVER_EDIT     1042
#define IDC_DNS_SERVER_REMOVE   1043
#define IDC_DNS_SERVER_UP       1044
#define IDC_DNS_SERVER_DOWN     1045


#define IDC_DNS_SEARCH_DOMAIN           1046
#define IDC_DNS_SEARCH_PARENT_DOMAIN    1047
#define IDC_DNS_USE_SUFFIX_LIST         1048
#define IDC_DNS_SUFFIX_LIST             1049
#define IDC_DNS_SUFFIX_ADD              1050
#define IDC_DNS_SUFFIX_EDIT             1051
#define IDC_DNS_SUFFIX_REMOVE           1052
#define IDC_DNS_SUFFIX_UP               1053
#define IDC_DNS_SUFFIX_DOWN             1054

#define IDC_DNS_CHANGE_SERVER           1055
#define IDC_DNS_CHANGE_SUFFIX           1056

#define IDC_DNS_ADDR_REG                1057
#define IDC_DNS_NAME_REG                1058
#define IDC_DNS_STATIC_GLOBAL           1059

// WINS page
#define IDC_WINS_SERVER_LIST    1060
#define IDC_WINS_ADD            1061
#define IDC_WINS_EDIT           1062
#define IDC_WINS_REMOVE         1063
#define IDC_WINS_UP             1064
#define IDC_WINS_DOWN           1065

#define IDC_WINS_LOOKUP         1066
#define IDC_WINS_LMHOST         1067

#define IDC_RAD_ENABLE_NETBT    1068
#define IDC_RAD_DISABLE_NETBT   1069
#define IDC_RAD_UNSET_NETBT     1070

#define IDC_WINS_CHANGE_SERVER  1071
#define IDC_WINS_STATIC_GLOBAL  1072

#define IDC_STATIC_IF_METRIC    1073
#define IDC_STATIC_DEFALUT_NBT  1074

// Atm arp client page
#define IDC_CHK_ATM_PVCONLY     1080
#define IDC_LBX_ATM_ArpsAddrs   1081
#define IDC_PSB_ATM_ArpsAdd     1082
#define IDC_PSB_ATM_ArpsEdt     1083
#define IDC_PSB_ATM_ArpsRmv     1084
#define IDC_PSB_ATM_ArpsUp      1085
#define IDC_PSB_ATM_ArpsDown    1086
#define IDC_LBX_ATM_MarsAddrs   1087
#define IDC_PSB_ATM_MarsAdd     1088
#define IDC_PSB_ATM_MarsEdt     1089
#define IDC_PSB_ATM_MarsRmv     1090
#define IDC_PSB_ATM_MarsUp      1091
#define IDC_PSB_ATM_MarsDown    1092
#define IDC_EDT_ATM_MaxTU       1093
#define IDC_EDT_ATM_Address     1094
#define IDCST_ATM_AddrName      1095

// Options page
#define IDC_LVW_OPTIONS         1100
#define IDC_OPT_PROPERTIES      1001
#define IDC_OPT_DESC            1002

// IPsec dialog
/* IP Security dialog is removed
#define IDC_RAD_IPSEC_NOIPSEC       1020
#define IDC_RAD_IPSEC_CUSTOM        1021
#define IDC_CMB_IPSEC_POLICY_LIST   1022
#define IDC_EDT_POLICY_DESC         1023
*/

// PPP/SLIP dialog
#define IDC_REMOTE_GATEWAY          1030
#define IDC_CHK_USE_COMPRESSION     1031
#define IDC_CMB_FRAME_SIZE          1032
#define IDC_STATIC_FRAME_SIZE       1033
#define IDC_GRP_PPP                 1034
#define IDC_GRP_SLIP                1035
#define IDC_STATIC_REMOTE_GATEWAY   1036

// IP Filtering Dialog
#define IDC_FILTERING_ENABLE         1040
#define IDC_FILTERING_FILTER_TCP     1041
#define IDC_FILTERING_FILTER_TCP_SEL 1042
#define IDC_FILTERING_TCP            1043
#define IDC_FILTERING_TCP_ADD        1044
#define IDC_FILTERING_TCP_REMOVE     1045
#define IDC_FILTERING_FILTER_UDP     1046
#define IDC_FILTERING_FILTER_UDP_SEL 1047
#define IDC_FILTERING_UDP            1048
#define IDC_FILTERING_UDP_ADD        1049
#define IDC_FILTERING_UDP_REMOVE     1050
#define IDC_FILTERING_FILTER_IP      1051
#define IDC_FILTERING_FILTER_IP_SEL  1052
#define IDC_FILTERING_IP             1053
#define IDC_FILTERING_IP_ADD         1054
#define IDC_FILTERING_IP_REMOVE      1055

// IP Filtering Add Dialog
#define IDC_FILTERING_TEXT           1060
#define IDC_FILTERING_ADD_EDIT       1061

// IP Back up Dialog
#define IDC_BKUP_RD_AUTO             1070
#define IDC_BKUP_RD_USER             1071
#define IDC_BKUP_IPADDR_TEXT         1072
#define IDC_BKUP_IPADDR              1073
#define IDC_BKUP_SUBNET_TEXT         1074
#define IDC_BKUP_SUBNET              1075
#define IDC_BKUP_GATEWAY_TEXT        1076
#define IDC_BKUP_GATEWAY             1077
#define IDC_BKUP_PREF_DNS_TEXT       1078
#define IDC_BKUP_PREF_DNS            1079
#define IDC_BKUP_ALT_DNS_TEXT        1080
#define IDC_BKUP_ALT_DNS             1081
#define IDC_BKUP_WINS1_TEXT          1082
#define IDC_BKUP_WINS1               1083
#define IDC_WINS2_TEXT               1084
#define IDC_BKUP_WINS2               1085

#define IDC_IPADDR_ADV_CHANGE_AUTOMETRIC 1090
#define IDC_IPADDR_ADV_CHANGE_METRIC_STATIC 1091


// Strings

#define IDS_MSFT_TCP_TEXT           23001

#define IDS_INVALID_SUBNET          23002
#define IDS_INVALID_NO_IP           23003
#define IDS_INVALID_NOSUBNET        23004
#define IDS_INCORRECT_IPADDRESS     23005
#define IDS_INCORRECT_IP_LOOPBACK   23006
#define IDS_INCORRECT_IP_FIELD_1    23007
#define IDS_TCPIP_DHCP_ENABLE       23008
#define IDS_IPADDRESS_TEXT          23009
#define IDS_SUBNET_TXT              23010

#define IDS_ITEM_NOT_SELECTED       23011
#define IDS_DHCPENABLED_TEXT        23012

#define IDS_INVALID_ATMSERVERLIST   23013
#define IDS_MTU_RANGE_WORD          23014
#define IDS_INCORRECT_ATM_ADDRESS   23015
#define IDS_ATM_INVALID_CHAR        23016
#define IDS_ATM_EMPTY_ADDRESS       23017

#define IDS_ATM_INVALID_LENGTH      23019

#define IDS_INVALID_DOMAIN          23020
#define IDS_INVALID_NO_SUFFIX       23021
#define IDS_INVALID_SUFFIX          23022

//IPSec is removed from connection UI   
//#define IDS_IPSEC_DOMAIN_POLICY     23023

#define IDS_TCP_ADV_HEADER          23024
#define IDS_IP_SECURITY             23027
#define IDS_IP_SECURITY_DESC        23028
#define IDS_PPP                     23029
#define IDS_PPP_DESC                23030
#define IDS_SLIP                    23031
#define IDS_SLIP_DESC               23032

#define IDS_CANNOT_CREATE_LMHOST_ERROR  23036
#define IDS_WINS_SYSTEM_PATH        23037
#define IDS_WINS_LMHOSTS_FAILED     23038

#define IDS_DUP_NETIP               23039
#define IDS_NO_BOUND_CARDS          23040

#define IDS_IPBAD_FIELD_VALUE       23041

#define IDS_IPNOMEM                 23042
#define IDS_IPMBCAPTION             23043

//IPSec is removed from connection UI   
//#define IDS_UNKNOWN_POLICY          23044
//#define IDS_DS_POLICY_PREFIX        23045

#define IDS_DUPLICATE_IP_ERROR      23046
#define IDS_DUPLICATE_IP_WARNING    23047

#define IDS_FILTERING_IP_LABEL           23048
#define IDS_FILTERING_IP_TEXT            23049
#define IDS_FILTERING_ITEM_IN_LIST       23050
#define IDS_FILTERING_ITEM_NOT_SELECTED  23051
#define IDS_FILTERING_RANGE_BYTE         23052
#define IDS_FILTERING_RANGE_WORD         23053
#define IDS_FILTERING_TCP_LABEL          23054
#define IDS_FILTERING_TCP_TEXT           23055
#define IDS_FILTERING_UDP_LABEL          23056
#define IDS_FILTERING_UDP_TEXT           23057

#define IDS_IP_FILTERING                 23058
#define IDS_IP_FILTERING_DESC            23059
#define IDS_FILTERING_DISABLE            23060
#define IDS_TCPIP_DNS_EMPTY              23061
#define IDS_METRIC_TEXT                  23062
#define IDS_INVALID_METRIC               23063
#define IDS_GATEWAY_TEXT                 23064

#define IDS_DUP_MALFUNCTION_IP_WARNING   23065
#define IDS_ERROR_UNCONTIGUOUS_SUBNET    23066

#define IDS_INVALID_DOMAIN_NAME     23067

#define IDS_TCP_AF_INVALID_DNS_SUFFIX   23068
#define IDS_TCP_AF_INVALID_SUBNET       23069
#define IDS_TCP_AF_NO_IP                23070
#define IDS_TCP_AF_NO_SUBNET            23071
#define IDS_TCP_AF_INVALID_DNS_DOMAIN   23072
#define IDS_TCP_AF_INVALID_IP_FIELDS    23073
#define IDS_TCP_AF_INVALID_GLOBAL_DNS_DOMAIN    23074
#define IDS_WIN32_ERROR_FORMAT          23075
//IPSec is removed from connection UI   
//#define IDS_SET_IPSEC_FAILED            23076
#define IDS_TCP_AF_INVALID_FIELDS       23077
#define IDS_DUP_DNS_SERVER              23078
#define IDS_DUP_DNS_SUFFIX              23079
#define IDS_DUP_WINS_SERVER             23080
#define IDS_DUP_IPADDRESS               23081
#define IDS_DUP_GATEWAY                 23082
#define IDS_DUP_SECOND_DNS              23083

#define IDS_INVALID_HOST_ALL_1          23084
#define IDS_INVALID_HOST_ALL_0          23085
#define IDS_INVALID_SUBNET_ALL_0        23086
#define IDS_AUTO_GW_METRIC              23087
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\ipsysprp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I P S Y S P R P . C P P
//
//  Contents:   Handle the TCP/IP parameters in the sysprep 
//
//  Notes:
//
//  Author:     nsun
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncsetup.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "ncreg.h"
#include "afilestr.h"

typedef struct {
    LPCWSTR pszRegValName;
    LPCWSTR pszFileValName;
    DWORD dwType;
} SysprepValueNameTypeMapping;

SysprepValueNameTypeMapping c_TcpipValueTypeMapping [] =
{
    {c_szDefaultGateway, c_szAfDefaultGateway, REG_MULTI_SZ},
    {RGAS_DEFAULTGATEWAYMETRIC, RGAS_DEFAULTGATEWAYMETRIC, REG_MULTI_SZ},
    {c_szDomain, c_szAfDnsDomain, REG_SZ},
    {RGAS_ENABLE_DHCP, c_szAfDhcp, REG_BOOL},
    {c_szInterfaceMetric, c_szInterfaceMetric, REG_DWORD},
    {RGAS_IPADDRESS, c_szAfIpaddress, REG_MULTI_SZ},
    {RGAS_NAMESERVER, c_szAfDnsServerSearchOrder, REG_SZ},
    {RGAS_FILTERING_IP, c_szAfIpAllowedProtocols, REG_MULTI_SZ},
    {RGAS_SUBNETMASK, c_szAfSubnetmask, REG_MULTI_SZ},
    {RGAS_FILTERING_TCP, c_szAfTcpAllowedPorts, REG_MULTI_SZ},
    {RGAS_FILTERING_UDP, c_szAfUdpAllowedPorts, REG_MULTI_SZ}
};

SysprepValueNameTypeMapping c_NetBTValueTypeMapping [] =
{
    {RGAS_NETBT_NAMESERVERLIST, c_szAfWinsServerList, REG_MULTI_SZ},
    {RGAS_NETBT_NETBIOSOPTIONS, c_szAfNetBIOSOptions, REG_DWORD}
};

HRESULT HrSysPrepSaveInterfaceParams(
                    INetCfgSysPrep* pncsp,
                    LPCWSTR pszSection,
                    HKEY hkey,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT  cParams
                    );

HRESULT HrSysPrepLoadInterfaceParams(
                    HINF hinf,
                    PCWSTR pszSection,
                    HKEY    hkeyParam,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT    cParams
                    );

HRESULT CTcpipcfg::HrOpenTcpipInterfaceKey(
                                const GUID & guidInterface,
                                HKEY * phKey,
                                REGSAM sam
                    )
{
    if (NULL == phKey)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    *phKey = NULL;

    if (NULL == m_pnccTcpip)
        return E_FAIL;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyInterface = NULL;
    tstring strInterfaceRegPath;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(
                guidInterface,
                szGuid,
                c_cchGuidWithTerm
                );

    CORg(m_pnccTcpip->OpenParamKey(&hkeyTcpipParam));

    Assert(hkeyTcpipParam);
    strInterfaceRegPath = c_szInterfacesRegKey;
    strInterfaceRegPath += L"\\";

        
    strInterfaceRegPath += szGuid;
        
    CORg(HrRegOpenKeyEx(
                    hkeyTcpipParam,
                    strInterfaceRegPath.c_str(),
                    sam,
                    &hkeyInterface
                    ));

Error:
    if (SUCCEEDED(hr))
    {
        *phKey = hkeyInterface;
    }

    RegSafeCloseKey(hkeyTcpipParam);

    return hr;
}

HRESULT CTcpipcfg::HrOpenNetBtInterfaceKey(
                                const GUID & guidInterface,
                                HKEY * phKey,
                                REGSAM sam
                    )
{
    if (NULL == phKey)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    *phKey = NULL;

    if (NULL == m_pnccWins)
        return E_FAIL;

    HKEY hkeyNetBtParam = NULL;
    HKEY hkeyInterface = NULL;
    tstring strInterfaceRegPath;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(
                guidInterface,
                szGuid,
                c_cchGuidWithTerm
                );

    CORg(m_pnccWins->OpenParamKey(&hkeyNetBtParam));

    Assert(hkeyNetBtParam);
    strInterfaceRegPath = c_szInterfacesRegKey;
    strInterfaceRegPath += L"\\";
    strInterfaceRegPath += c_szTcpip_;
    strInterfaceRegPath += szGuid;
        
    CORg(HrRegOpenKeyEx(
                    hkeyNetBtParam,
                    strInterfaceRegPath.c_str(),
                    sam,
                    &hkeyInterface
                    ));

Error:
    if (SUCCEEDED(hr))
    {
        *phKey = hkeyInterface;
    }

    RegSafeCloseKey(hkeyNetBtParam);

    return hr;
}


STDMETHODIMP CTcpipcfg::SaveAdapterParameters(
                            INetCfgSysPrep* pncsp,
                            LPCWSTR pszwAnswerSections,
                            GUID* pAdapterInstanceGuid
                            )
{
    if (NULL == pncsp || NULL == pAdapterInstanceGuid)
        return E_INVALIDARG;

    Assert(m_pnccTcpip);
    Assert(m_pnccWins);

    if (NULL == m_pnccTcpip || NULL == m_pnccWins)
        return E_FAIL;

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyNetBtParam = NULL;

    //Write the TCP/IP settings
    hr = HrOpenTcpipInterfaceKey(*pAdapterInstanceGuid, &hkeyTcpipParam, KEY_READ);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyTcpipParam);
        hr = HrSysPrepSaveInterfaceParams(
                            pncsp, 
                            pszwAnswerSections,
                            hkeyTcpipParam,
                            c_TcpipValueTypeMapping,
                            celems(c_TcpipValueTypeMapping)
                            );

        RegSafeCloseKey(hkeyTcpipParam);
    }

    //Write the DNS update settings
    WCHAR szGuid [c_cchGuidWithTerm] = {0};
    BOOL fTemp = FALSE;
    
    StringFromGUID2(
                *pAdapterInstanceGuid,
                szGuid,
                c_cchGuidWithTerm
                );

    fTemp = !DnsIsDynamicRegistrationEnabled(szGuid);
    hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszwAnswerSections,
                                        c_szAfDisableDynamicUpdate,
                                        fTemp
                                        );
    if (SUCCEEDED(hr))
        hr = hrTmp;

    fTemp = DnsIsAdapterDomainNameRegistrationEnabled(szGuid);
    hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszwAnswerSections,
                                        c_szAfEnableAdapterDomainNameRegistration,
                                        fTemp
                                        );
    if (SUCCEEDED(hr))
        hr = hrTmp;


    //Write the NetBT settings
    hrTmp = HrOpenNetBtInterfaceKey(*pAdapterInstanceGuid, &hkeyNetBtParam, KEY_READ);
    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrSysPrepSaveInterfaceParams(
                        pncsp, 
                        pszwAnswerSections,
                        hkeyNetBtParam,
                        c_NetBTValueTypeMapping,
                        celems(c_NetBTValueTypeMapping)
                        );

        RegSafeCloseKey(hkeyNetBtParam);
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;

    return hr;
}


STDMETHODIMP CTcpipcfg::RestoreAdapterParameters(
                            LPCWSTR pszwAnswerFile, 
                            LPCWSTR pszwAnswerSection,
                            GUID*   pAdapterInstanceGuid
                            )
{
    AssertSz(pszwAnswerFile, "Answer file string is NULL!");
    AssertSz(pszwAnswerSection, "Answer file sections string is NULL!");

    if (NULL == pszwAnswerFile || 
        NULL == pszwAnswerSection ||
        NULL == pAdapterInstanceGuid)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CSetupInfFile   caf;    // Class to process answer file

    // Open the answer file.
    hr = caf.HrOpen(pszwAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
        return hr;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyNetBtParam = NULL;
    
    hr = HrOpenTcpipInterfaceKey(*pAdapterInstanceGuid, &hkeyTcpipParam, KEY_READ_WRITE);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyTcpipParam);
        hr = HrSysPrepLoadInterfaceParams(
                        caf.Hinf(),
                        pszwAnswerSection,
                        hkeyTcpipParam,
                        c_TcpipValueTypeMapping,
                        celems(c_TcpipValueTypeMapping)
                        );
    }

    HRESULT hrTmp = S_OK;
    
    hrTmp = HrOpenNetBtInterfaceKey(*pAdapterInstanceGuid, &hkeyNetBtParam, KEY_READ_WRITE);
    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyNetBtParam);
        hrTmp = HrSysPrepLoadInterfaceParams(
                        caf.Hinf(),
                        pszwAnswerSection,
                        hkeyNetBtParam,
                        c_NetBTValueTypeMapping,
                        celems(c_NetBTValueTypeMapping)
                        );
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;
        
    caf.Close();
    
    return hr;
}


HRESULT HrSysPrepSaveInterfaceParams(
                    INetCfgSysPrep* pncsp,
                    LPCWSTR pszSection,
                    HKEY hkey,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT  cParams
                    )
{
    Assert(pncsp);
    Assert(pszSection);
    Assert(hkey);

    if (NULL == pncsp || NULL == pszSection || NULL == hkey || NULL == prgVtpParams)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;
    UINT i = 0;
    for (i = 0; i < cParams; i++)
    {
        hrTmp = S_OK;
        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            if (SUCCEEDED(HrRegQueryDword(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &dwTmp
                                )))
            {
                fTmp = !!dwTmp;
                hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszSection,
                                        prgVtpParams[i].pszFileValName,
                                        fTmp
                                        );
            }
            break;

        case REG_DWORD:
            if (SUCCEEDED(HrRegQueryDword(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &dwTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstDword(
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    dwTmp
                                    );
            }

            break;

        case REG_SZ:
            if (SUCCEEDED(HrRegQueryString(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &strTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstString(
                                        pszSection,
                                        prgVtpParams[i].pszFileValName,
                                        strTmp.c_str()
                                        );
            }
            break;

        case REG_MULTI_SZ:
            if (SUCCEEDED(HrRegQueryMultiSzWithAlloc(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &mszTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstMultiSzField(
                                       pszSection,
                                       prgVtpParams[i].pszFileValName,
                                       mszTmp
                                       );
                delete [] mszTmp;
            }
            break;
        }

        //we dont pass the error of hrTmp out of this function because
        //there is not much we can do with this error
#ifdef ENABLETRACE
        if (FAILED(hrTmp))
        {
            TraceTag(ttidError, "Tcpip: HrSysPrepSaveInterfaceParams: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszFileValName, hrTmp);
        }
#endif

    }

    return hr;
}


HRESULT HrSysPrepLoadInterfaceParams(
                    HINF    hinf,
                    PCWSTR  pszSection,
                    HKEY    hkeyParam,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT    cParams
                    )
{
    Assert(prgVtpParams);

    if (NULL == hinf || NULL == pszSection || NULL == hkeyParam || NULL == prgVtpParams)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;

    for(UINT i = 0; i < cParams; i++)
    {
        hrReg = S_OK;
        hrTmp = S_OK;

        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            hrTmp = HrSetupGetFirstStringAsBool(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &fTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszRegValName,
                                      fTmp);
            break;

        case REG_DWORD:
            hrTmp = HrSetupGetFirstDword(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &dwTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszRegValName,
                                      dwTmp);

            break;

        case REG_SZ:
            hrTmp = HrSetupGetFirstString(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &strTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetString(hkeyParam,
                                       prgVtpParams[i].pszRegValName,
                                       strTmp);
            break;

        case REG_MULTI_SZ:
            hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( 
                                    hinf,
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &mszTmp
                                    );

            if (SUCCEEDED(hrTmp))
            {
                hrReg = HrRegSetMultiSz(hkeyParam,
                                        prgVtpParams[i].pszRegValName,
                                        mszTmp);
                delete [] mszTmp;
            }
            break;
        }

        if(FAILED(hrTmp))
        {
            if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                hrTmp = S_OK;
            else
            {
                TraceTag(ttidError,
                    "Tcpip: HrSysPrepLoadInterfaceParams: failed to load %S from the answer file. hr = %x.",
                    prgVtpParams[i].pszFileValName, 
                    hrTmp
                    );
            }
        }

#ifdef ENABLETRACE
        if(FAILED(hrReg))
        {
            TraceTag(ttidError,
                "HrSysPrepLoadInterfaceParams: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszRegValName, 
                hrReg);
        }
#endif

        //we dont pass the error of hrTmp out of this function because
        //there is not much we can do with this error
    }

    TraceError("CTcpipcfg::HrSysPrepLoadInterfaceParams", hr);
    return hr;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpaf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P A F . C P P
//
//  Contents:   TCP/IP answer file processing
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncsetup.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "tcputil.h"
#include "ncreg.h"
#include "ncperms.h"
#include "afilestr.h"
#include "ipafval.h"


extern const WCHAR c_szAdapterSections[];

BOOL FValidateIpFieldsFromAnswerFile(VSTR & vstrIpAddr, PCWSTR pszValueName,
                                    PCWSTR szAdapterName, BOOL fIsIpAddr = TRUE);

BOOL FValidateAdapterParametersFromAnswerFile(ADAPTER_INFO* pAdapter,
                                              PCWSTR pszAdapterName);
BOOL FValidateGlobalParametersFromAnswerFile(GLOBAL_INFO* pGlobalInfo);

HRESULT HrLoadUnConfigurableParamFromAnswerFile(HINF hinf,
                                                PCWSTR pszSection,
                                                const ValueTypePair * prgVtpParams,
                                                UINT    cParams,
                                                HKEY    hkeyParam);


HRESULT CTcpipcfg::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;
    HRESULT     hrTmp = S_OK;

    CSetupInfFile   caf;    // Class to process answer file

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = caf.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (SUCCEEDED(hr))
    {
        hrTmp = HrLoadGlobalParamFromAnswerFile(caf.Hinf(), pszAnswerSection);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Get the adapter specific Tcpip and NetBT parameters
        WCHAR * mszAdapterList;
        hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(),
                                                     pszAnswerSection,
                                                     c_szAdapterSections,
                                                     &mszAdapterList);
        if (SUCCEEDED(hrTmp))
        {
            hrTmp = HrLoadAdapterParameterFromAnswerFile(caf.Hinf(),
                                                      mszAdapterList);
            delete [] mszAdapterList;
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;

        caf.Close();
    }

    TraceErrorOptional("CTcpipcfg::HrProcessAnswerFile", hr,
                       SPAPI_E_LINE_NOT_FOUND == hr);

    // Mask the errors since we will be using the defaults
    if FAILED(hr)
        hr = S_OK;

    return hr;
}

// Load Global parameters from answerfile to memory structure
HRESULT  CTcpipcfg::HrLoadGlobalParamFromAnswerFile(HINF hinf,
                                                    PCWSTR pszTcpipMainSection)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;

    BOOL    fTmp;
    DWORD   dwTmp;

    hr = m_glbGlobalInfo.HrSetDefaults();

    if SUCCEEDED(hr)
    {
        // $REVIEW(tongl 3/22/98): per Stuart Kwan, I'm reading global
        // DNS server list just for the upgrade case
        // DNSDomain -> m_strDnsDomain
        tstring strDnsDomain;
        hrTmp = HrSetupGetFirstString(  hinf,
                                        pszTcpipMainSection,
                                        c_szAfDnsDomain,
                                        &strDnsDomain);

        if SUCCEEDED(hrTmp)
        {
            m_fUpgradeGlobalDnsDomain = TRUE;
            if (!strDnsDomain.empty())
            {
                DNS_STATUS status;
                status = DnsValidateName(strDnsDomain.c_str(), DnsNameDomain);

                //validate the global dns domain name
                if (ERROR_INVALID_NAME == status || 
                    DNS_ERROR_INVALID_NAME_CHAR == status)
                {
                    WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_GLOBAL_DNS_DOMAIN, strDnsDomain.c_str());
                    m_fUpgradeGlobalDnsDomain = FALSE;
                }
            }

            if (m_fUpgradeGlobalDnsDomain)
                m_strUpgradeGlobalDnsDomain = strDnsDomain;
        }
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParameterFromAnswerFile: DNSDomain", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DNSHostName -> m_strHostNameFromAnswerFile
        hrTmp = HrSetupGetFirstString(hinf,
                                      pszTcpipMainSection,
                                      c_szAfDnsHostname,
                                      &m_glbGlobalInfo.m_strHostNameFromAnswerFile);
        if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DNSHostName", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DNSSuffixSearchOrder -> m_strSearchList
        WCHAR * mszSearchList;
        hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( hinf,
                                                      pszTcpipMainSection,
                                                      c_szAfDnsSuffixSearchOrder,
                                                      &mszSearchList);

        if SUCCEEDED(hrTmp)
        {
            MultiSzToColString( mszSearchList,
                                &m_glbGlobalInfo.m_vstrDnsSuffixList);
            delete [] mszSearchList;
        }
        if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DNSSuffixSearchOrder", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // EnableLMHosts -> m_fEnableLmHosts
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableLmhosts,
                                            &fTmp);

        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableLmHosts = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableLMHosts", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Per AmritanR, drop the upgrade support of IpEnableRouter to fix bug 345700
        // EnableIPForwarding -> m_fEnableRouter (BOOL)
        

        //(nsun 11/03/98) parameters for RRAS during unattended install
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableICMPRedirect,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableIcmpRedirect = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableICMPRedirect", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        //(nsun 09/20/99) PerformRouterDiscoveryDefault was removed to fix bug 405636

        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfDeadGWDetectDefault,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fDeadGWDetectDefault = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DeadGWDetectDefault", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfDontAddDefaultGatewayDefault,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DontAddDefaultGatewayDefault", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;


        // EnableSecurity -> m_fEnableFiltering
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableSecurity,
                                            &fTmp);

        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableFiltering = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableSecurity", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;


        // 8/10/98 nsun: added to support UseDomainNameDevolution value in unattended install
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfUseDomainNameDevolution,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fUseDomainNameDevolution = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: UseDomainNameDevolution", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        //$REVIEW (nsun 12/11/98) directly save the unconfigurable parameters
        // right after reading it from the answer file.
        HKEY hkeyTcpipParam = NULL;
        Assert(m_pnccTcpip);

        if(m_pnccTcpip)
        {
            hrTmp = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);
            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyTcpipParam);
                hrTmp = HrLoadUnConfigurableParamFromAnswerFile(hinf,
                                                    pszTcpipMainSection,
                                                    rgVtpIp,
                                                    sizeof(rgVtpIp)/sizeof(rgVtpIp[0]),
                                                    hkeyTcpipParam);
                RegSafeCloseKey(hkeyTcpipParam);
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        HKEY hkeyWinsParam = NULL;
        Assert(m_pnccWins);
        if(m_pnccWins)
        {
            hrTmp = m_pnccWins->OpenParamKey(&hkeyWinsParam);
            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyWinsParam);
                hrTmp = HrLoadUnConfigurableParamFromAnswerFile(hinf,
                                                    pszTcpipMainSection,
                                                    rgVtpNetBt,
                                                    sizeof(rgVtpNetBt)/sizeof(rgVtpNetBt[0]),
                                                    hkeyWinsParam);
                RegSafeCloseKey(hkeyWinsParam);
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        if (!FValidateGlobalParametersFromAnswerFile(&m_glbGlobalInfo))
        {
            TraceError("FValidateGlobalParametersFromAnswerFile() got invalid tcp settings", E_FAIL);
        }
    }

    TraceError("CTcpipcfg::HrLoadGlobalParamFromAnswerFile", hr);
    return hr;
}

// Load adapter specific parameters from answerfile to memory structure
HRESULT CTcpipcfg::HrLoadAdapterParameterFromAnswerFile(HINF hinf,
                                                        PCWSTR mszTcpipAdapterSections)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;

    PCWSTR  pszAdapterSection = mszTcpipAdapterSections;
    tstring  strAdapterName;
    tstring  strInterfaceRegPath;

    //$REVIEW (nsun 12/11/98) bug #204145
    //directly save the unconfigurable parameters right after reading
    //it from the answer file.
    HKEY hkeyTcpipParam = NULL;
    hrReg = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);
    hr = hrReg;

    while (*pszAdapterSection)
    {
        // Get the card name "SpecificTo = ..."
        hrTmp = HrSetupGetFirstString(hinf, pszAdapterSection,
                                 c_szAfSpecificTo, &strAdapterName);
        if (SUCCEEDED(hrTmp))
        {
            GUID     guidNetCard;
            if (!FGetInstanceGuidOfComponentInAnswerFile(
                                                strAdapterName.c_str(),
                                                m_pnc,
                                                &guidNetCard))
            {
                TraceTag(ttidError, "FGetInstanceGuidOfComponentInAnswerFile failed to match GUID for adapter %S", strAdapterName.c_str());

                // Move to the next card
                pszAdapterSection += lstrlenW(pszAdapterSection) + 1;
                continue;
            }

            // Do we already have this adapter in our list ?
            ADAPTER_INFO * pAdapterInfo = PAdapterFromInstanceGuid(&guidNetCard);
            if (!pAdapterInfo)
            {
                pAdapterInfo = new ADAPTER_INFO;

                if (NULL == pAdapterInfo)
                {
                    hr = E_OUTOFMEMORY;
                    continue;
                }

                hrTmp = pAdapterInfo->HrSetDefaults(&guidNetCard, c_szEmpty,
                                            c_szEmpty, c_szEmpty);
                if (SUCCEEDED(hrTmp))
                {
                    m_vcardAdapterInfo.push_back(pAdapterInfo);

                    // Set the flag that we only got this card from answer file,
                    // not from binding path, i.e. it's not on the binding path yet.
                    pAdapterInfo->m_fIsFromAnswerFile = TRUE;
                }
                else
                {
                    delete pAdapterInfo;
                    pAdapterInfo = NULL;
                }
            }

            if (SUCCEEDED(hrTmp))
            {
                BOOL fWins;

                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                     c_szAfWins,
                                                     &fWins);

                if (FAILED(hrTmp))
                {
                    if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                    else
                        TraceError("HrLoadAdapterParamFormAnswerFile: fWins", hrTmp);
                }
                else if (fWins)
                {
                    // WinsServerList -> m_vstrWinsServerList
                    WCHAR * mszWinsServerList;
                    hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                                  pszAdapterSection,
                                                                  c_szAfWinsServerList,
                                                                  &mszWinsServerList);

                    if SUCCEEDED(hrTmp)
                    {
                        MultiSzToColString(mszWinsServerList,
                                           &pAdapterInfo->m_vstrWinsServerList);
                        delete [] mszWinsServerList;
                    }
                    else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                    else
                        TraceError("HrLoadAdapterParamFromAnswerFile: WinsServerList", hrTmp);

                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DHCP -> m_fEnableDhcp
                BOOL fEnableDhcp;
                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfDhcp,
                                                &fEnableDhcp);

                if SUCCEEDED(hrTmp)
                    pAdapterInfo->m_fEnableDhcp = fEnableDhcp;
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: DHCP", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // IPAddress -> m_vstrIpAddresses
                WCHAR * mszIPAddresses;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfIpaddress,
                                                              &mszIPAddresses);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszIPAddresses,
                                       &pAdapterInfo->m_vstrIpAddresses);
                    delete [] mszIPAddresses;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: IPAddress", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // SubnetMask -> m_vstrSubnetMask
                WCHAR * mszSubnetMasks;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfSubnetmask,
                                                              &mszSubnetMasks);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszSubnetMasks,
                                       &pAdapterInfo->m_vstrSubnetMask);
                    delete [] mszSubnetMasks;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: SubnetMask", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // Gateway -> m_vstrDefaultGateway
                WCHAR * mszDefaultGateways;

                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfDefaultGateway,
                                                              &mszDefaultGateways);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszDefaultGateways,
                                       &pAdapterInfo->m_vstrDefaultGateway);
                    delete [] mszDefaultGateways;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: Gateway", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DNSDomain -> m_strDnsDomain
                tstring strDnsDomain;
                hrTmp = HrSetupGetFirstString(  hinf,
                                                pszAdapterSection,
                                                c_szAfDnsDomain,
                                                &strDnsDomain);

                if SUCCEEDED(hrTmp)
                    pAdapterInfo->m_strDnsDomain = strDnsDomain;
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: DNSDomain", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DNSServerSearchOrder -> m_vstrDnsServerList
                WCHAR * mszDnsServerList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                             pszAdapterSection,
                                                             c_szAfDnsServerSearchOrder,
                                                             &mszDnsServerList);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszDnsServerList,
                                       &pAdapterInfo->m_vstrDnsServerList);
                    delete [] mszDnsServerList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: DNSServerSearchOrder", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                BOOL fTmp = FALSE;
                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfDisableDynamicUpdate,
                                                &fTmp);
                if (SUCCEEDED(hrTmp))
                {
                    pAdapterInfo->m_fDisableDynamicUpdate = fTmp;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError(
                        "HrLoadAdapterParameterFromAnswerFile: DisableDynamicUpdate", 
                        hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfEnableAdapterDomainNameRegistration,
                                                &fTmp);
                if (SUCCEEDED(hrTmp))
                {
                    pAdapterInfo->m_fEnableNameRegistration = fTmp;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError(
                        "HrLoadAdapterParameterFromAnswerFile: EnableAdapterDomainNameRegistration", 
                        hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // NetBIOSOptions ->m_dwNetbiosOptions
                DWORD dwNetbiosOptions;
                hrTmp = HrSetupGetFirstDword(hinf,
                                             pszAdapterSection,
                                             c_szAfNetBIOSOptions,
                                             &dwNetbiosOptions);
                if SUCCEEDED(hrTmp)
                {
                    if ((dwNetbiosOptions == c_dwUnsetNetbios) ||
                        (dwNetbiosOptions == c_dwEnableNetbios) ||
                        (dwNetbiosOptions == c_dwDisableNetbios))
                    {
                        pAdapterInfo->m_dwNetbiosOptions = dwNetbiosOptions;
                    }
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: NetBIOSOptions", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // TcpAllowedPorts -> m_vstrTcpFilterList
                WCHAR * mszTcpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfTcpAllowedPorts,
                                                              &mszTcpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszTcpFilterList,
                                       &pAdapterInfo->m_vstrTcpFilterList);
                    delete [] mszTcpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: TcpAllowedPorts", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // UdpAllowedPorts -> m_vstrUdpFilterList
                WCHAR * mszUdpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfUdpAllowedPorts,
                                                              &mszUdpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszUdpFilterList,
                                       &pAdapterInfo->m_vstrUdpFilterList);
                    delete [] mszUdpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: UdpAllowedPorts", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // IpAllowedProtocols -> m_vstrIpFilterList
                WCHAR * mszIpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfIpAllowedProtocols,
                                                              &mszIpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszIpFilterList,
                                       &pAdapterInfo->m_vstrIpFilterList);
                    delete [] mszIpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: IpAllowedProtocols", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                //$REVIEW (nsun 12/11/98) bug #204145
                //directly save the unconfigurable parameters right after reading
                //it from the answer file.
                if (SUCCEEDED(hrReg))
                {
                    Assert(hkeyTcpipParam);
                    HKEY hkeyInterfaceParam = NULL;
                    strInterfaceRegPath = c_szInterfacesRegKey;
                    strInterfaceRegPath += L"\\";

                    WCHAR szGuid [c_cchGuidWithTerm];
                    StringFromGUID2(guidNetCard, szGuid, c_cchGuidWithTerm);
                    strInterfaceRegPath += szGuid;

                    DWORD   dwDisposition;
                    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, strInterfaceRegPath.c_str(),
                                         REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                         &hkeyInterfaceParam, &dwDisposition);
                    if( SUCCEEDED(hrTmp))
                    {
                        Assert(hkeyInterfaceParam);
                        hrTmp = HrLoadUnConfigurableParamFromAnswerFile(
                                        hinf,
                                        pszAdapterSection,
                                        rgVtpIpAdapter,
                                        sizeof(rgVtpIpAdapter)/sizeof(rgVtpIpAdapter[0]),
                                        hkeyInterfaceParam
                                        );
                        RegSafeCloseKey(hkeyInterfaceParam);
                    }
                    else
                        TraceError("HrLoadAdapterParamFromAnswerFile: CreateTcpipParm Reg key", hrTmp);
                }

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (!FValidateAdapterParametersFromAnswerFile(pAdapterInfo, strAdapterName.c_str()))
                {
                    TraceError("FValidateAdapterParameterFromAnswerFile() got invalid tcp settings", E_FAIL);
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Move to the next card
        pszAdapterSection += lstrlenW(pszAdapterSection)+1;

    } // end of while loop

    if (SUCCEEDED(hrReg))
        RegSafeCloseKey(hkeyTcpipParam);

    TraceError("CTcpipcfg::HrLoadAdapterParamFromAnswerFile", hr);
    return hr;
}


HRESULT HrLoadUnConfigurableParamFromAnswerFile(HINF hinf,
                                                PCWSTR pszSection,
                                                const ValueTypePair * prgVtpParams,
                                                UINT    cParams,
                                                HKEY    hkeyParam)
{
    Assert(prgVtpParams);

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;

    for(UINT i = 0; i < cParams; i++)
    {
        TraceTag(ttidTcpip, "HrLoadUnConfigurableParamFromAnswerFile: configuring '%S'...", prgVtpParams[i].pszValueName);

        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            hrTmp = HrSetupGetFirstStringAsBool(hinf, pszSection,
                                                prgVtpParams[i].pszValueName,
                                                &fTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszValueName,
                                      fTmp);
            break;

        case REG_DWORD:
            hrTmp = HrSetupGetFirstDword(hinf, pszSection,
                                         prgVtpParams[i].pszValueName,
                                         &dwTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszValueName,
                                      dwTmp);

            break;

        case REG_SZ:
            hrTmp = HrSetupGetFirstString(hinf, pszSection,
                                        prgVtpParams[i].pszValueName,
                                        &strTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetString(hkeyParam,
                                       prgVtpParams[i].pszValueName,
                                       strTmp);
            break;

        case REG_MULTI_SZ:
            hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( hinf,
                                                      pszSection,
                                                      prgVtpParams[i].pszValueName,
                                                      &mszTmp);

            if (SUCCEEDED(hrTmp))
            {
                hrReg = HrRegSetMultiSz(hkeyParam,
                                        prgVtpParams[i].pszValueName,
                                        mszTmp);
                delete [] mszTmp;
            }
            break;

        case REG_FILE:
            hrTmp = HrSetupGetFirstString(hinf, pszSection,
                                          prgVtpParams[i].pszValueName,
                                          &strTmp);
            if (SUCCEEDED(hrTmp) && (strTmp.length() > 0))
            {
                DWORD   dwDisposition=0;
                TOKEN_PRIVILEGES *  ptpRestore = NULL;
                HKEY hkeyRestore=NULL;

                hrReg = HrRegCreateKeyEx(hkeyParam,
                                         prgVtpParams[i].pszValueName,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL,
                                         &hkeyRestore, &dwDisposition);
                if (S_OK == hr)
                {
                    hrReg = HrEnableAllPrivileges(&ptpRestore);
                    if (SUCCEEDED(hrReg))
                    {
                        TraceTag(ttidTcpip, "HrLoadUnConfigurableParamFromAnswerFile: trying to restore regkey from file '%S'..", strTmp.c_str());
                        hrReg = HrRegRestoreKey(hkeyRestore, strTmp.c_str(), 0);
                        (void) HrRestorePrivileges(ptpRestore);
                        delete [] reinterpret_cast<BYTE *>(ptpRestore);
                    }
                    RegCloseKey(hkeyRestore);
                }
            }
            break;
        }

        if(FAILED(hrTmp))
        {
            if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                hrTmp = S_OK;
            else
            {
                TraceTag(ttidError,
                    "HrLoadUnConfigurableParamFromAnswerFile: failed to load %S. hr = %x.",
                    prgVtpParams[i].pszValueName, hrTmp);
            }
        }

#ifdef ENABLETRACE
        if(FAILED(hrReg))
        {
            TraceTag(ttidError,
                "HrLoadUnConfigurableParamFromAnswerFile: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszValueName, hrReg);
        }
#endif

        if (SUCCEEDED(hr))
            hr = hrTmp;

        if (SUCCEEDED(hr))
            hr = hrReg;
    }

    TraceError("CTcpipcfg::HrLoadUnConfigurableParamFromAnswerFile", hr);
    return hr;
}


BOOL FValidateIpFieldsFromAnswerFile(VSTR & vstrIpAddr, PCTSTR pszValueName,
                                    PCWSTR pszAdapterName, BOOL fIsIpAddr)

{
    BOOL fRet = TRUE;

    for (VSTR::iterator iter = vstrIpAddr.begin(); iter != vstrIpAddr.end(); iter++)
    {
        tstring* pstrIpAddr = *iter;
        if (!FIsValidIpFields(pstrIpAddr->c_str(), fIsIpAddr))
        {
            WriteTcpSetupErrorLog(fIsIpAddr ? IDS_TCP_AF_INVALID_IP_FIELDS : IDS_TCP_AF_INVALID_FIELDS, 
                                  pszValueName,
                                  pszAdapterName, 
                                  pstrIpAddr->c_str());
            fRet = FALSE;
        }
    }

    return fRet;
}

BOOL FValidateGlobalParametersFromAnswerFile(GLOBAL_INFO* pGlobalInfo)
{
    BOOL fRet = TRUE;

    DNS_STATUS status;

    if (!pGlobalInfo->m_vstrDnsSuffixList.empty())
    {
        for (VSTR::iterator iter = pGlobalInfo->m_vstrDnsSuffixList.begin();
            iter != pGlobalInfo->m_vstrDnsSuffixList.end(); iter++)
        {
            status = DnsValidateName((*iter)->c_str(), DnsNameDomain);
            if (ERROR_INVALID_NAME == status ||
                DNS_ERROR_INVALID_NAME_CHAR == status)
            {
                WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_DNS_SUFFIX,
                                    c_szAfDnsSuffixSearchOrder,
                                    (*iter)->c_str());
                fRet = FALSE;
            }
        }
    }

    if (!fRet)
    {
        FreeCollectionAndItem(pGlobalInfo->m_vstrDnsSuffixList);
    }

    return fRet;
}

BOOL FValidateAdapterParametersFromAnswerFile(ADAPTER_INFO* pAdapter, PCWSTR pszAdapterName)
{
    BOOL fRet = TRUE;

    if (!pAdapter->m_fEnableDhcp)
    {
        if (!pAdapter->m_vstrIpAddresses.empty())
        {
            if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrIpAddresses,
                                                c_szAfIpaddress,
                                                pszAdapterName))
            {
                fRet = FALSE;
            }
        }

        if (!pAdapter->m_vstrSubnetMask.empty())
        {
            if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrSubnetMask,
                                                c_szAfSubnetmask,
                                                pszAdapterName,
                                                FALSE))
            {
                fRet = FALSE;
            }
        }

        if (fRet)
        {
            IP_VALIDATION_ERR err = ValidateIp(pAdapter);

            if (err != ERR_NONE)
            {
                fRet = FALSE;

                switch (err)
                {
                case ERR_INCORRECT_IP:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_SUBNET, pszAdapterName);
                    break;
                case ERR_NO_IP:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_NO_IP, pszAdapterName);
                    break;
                case ERR_NO_SUBNET:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_NO_SUBNET, pszAdapterName);
                    break;
                default:
                    //$REVIEW: we don't want to check other invalid settings at this time
                    // because the setting maybe is valid in NT4, for example: uncontiguous
                    // subnet mask
                    fRet = TRUE;
                    break;
                }
            }
        }

        if (!fRet)
        {
            //Invalid IP settings in the answer file. Set IP settings back to default
            pAdapter->m_fEnableDhcp = TRUE;
            FreeCollectionAndItem(pAdapter->m_vstrIpAddresses);
            FreeCollectionAndItem(pAdapter->m_vstrSubnetMask);
        }
    }

    if (!pAdapter->m_strDnsDomain.empty())
    {
        DNS_STATUS status;

        status = DnsValidateName(pAdapter->m_strDnsDomain.c_str(), DnsNameDomain);

        if (ERROR_INVALID_NAME == status ||
            DNS_ERROR_INVALID_NAME_CHAR == status)
        {
            WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_DNS_DOMAIN, pszAdapterName);
            pAdapter->m_strDnsDomain = c_szEmpty;

            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrDnsServerList.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrDnsServerList,
                                            c_szAfDnsServerSearchOrder,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrDnsServerList);
            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrDefaultGateway.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrDefaultGateway,
                                            c_szAfDefaultGateway,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrDefaultGateway);
            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrWinsServerList.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrWinsServerList,
                                            c_szAfWinsServerList,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrWinsServerList);
            fRet = FALSE;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpdhcp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D H C P . C P P
//
//  Contents:   Functions related to Calling Dhcpcsvc.dll entry point
//              called from HrSetMisc
//
//              HrNotifyDhcp, HrCallDhcpConfig
//
//  Notes:      These functions are based on what was in ncpa1.1
//
//              HrNotifyDHCP is from CTcpGenPage::NotifyDHCP
//              HrCallDhcpConfig is from CallDHCPConfig
//
//  Author:     tongl   11 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "atmcommon.h"

#define ConvertIpDword(dwIpOrSubnet) ((dwIpOrSubnet[3]<<24) | (dwIpOrSubnet[2]<<16) | (dwIpOrSubnet[1]<<8) | (dwIpOrSubnet[0]))

//
//  CTcpipcfg::HrNotifyDhcp
//
//  Makes on the fly IP Address changes for all cards in the system
//
//  hkeyTcpipParam      Handle to \CCS\Services\Tcpip\Parameters reg key

HRESULT CTcpipcfg::HrNotifyDhcp()
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    ADAPTER_INFO* pAdapter;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter ++)
    {
        pAdapter = *iterAdapter;

        if((pAdapter->m_BindingState == BINDING_ENABLE) &&
           (pAdapter->m_InitialBindingState != BINDING_DISABLE) &&
           (!pAdapter->m_fIsWanAdapter))
        {
            // 1) Static IP-> Dhcp
            // The new value is enable DHCP,
            // but the old value was disable DHCP
            if(pAdapter->m_fEnableDhcp &&
               !pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: Static IP->DHCP",
                         pAdapter->m_strBindName.c_str());

                HKEY hkeyTcpipParam = NULL;
                hrTmp = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);

                if SUCCEEDED(hrTmp)
                {
                    // Enable Dhcp
                    HKEY    hkeyInterfaces = NULL;
                    DWORD   dwGarbage;

                    // Open the interfaces key
                    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam,
                                             c_szInterfacesRegKey,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_READ,
                                             NULL,
                                             &hkeyInterfaces,
                                             &dwGarbage);

                    if(SUCCEEDED(hrTmp))
                    {
                        Assert(hkeyInterfaces);
                        HKEY    hkeyInterfaceParam = NULL;

                        // Open the interface key for the specified interface
                        hrTmp = HrRegCreateKeyEx(
                                hkeyInterfaces,
                                pAdapter->m_strTcpipBindPath.c_str(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ_WRITE,
                                NULL,
                                &hkeyInterfaceParam,
                                &dwGarbage);

                        if (SUCCEEDED(hrTmp))
                        {
                            // Clear up the IP address and subnet registry entries
                            Assert(hkeyInterfaceParam);

                            hrTmp = HrRegSetString(hkeyInterfaceParam,
                                                   RGAS_DHCP_IPADDRESS,
                                                   tstring(ZERO_ADDRESS));

                            if(SUCCEEDED(hrTmp))
                            {
                                hrTmp = HrRegSetString(hkeyInterfaceParam,
                                                       RGAS_DHCP_SUBNETMASK,
                                                       tstring(FF_ADDRESS));

                                if(SUCCEEDED(hrTmp))
                                {
                                    // Enable Dhcp & remove first static IP address
                                    hrTmp = HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    FALSE, // static->dhcp
                                    0,  // index
                                    0,  // IP address
                                    0,  // Subnet mask
                                    DhcpEnable); //Flag: enable Dhcp
                                }
                            }
                        }
                        RegSafeCloseKey(hkeyInterfaceParam);
                    }
                    RegSafeCloseKey(hkeyInterfaces);
                }
                RegSafeCloseKey(hkeyTcpipParam);
            }

            // 2) Static IP change
            // DHCP is disabled now, and also used to be disabled before
            if(!pAdapter->m_fEnableDhcp &&
               !pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: Static IP change.",
                         pAdapter->m_strBindName.c_str());

                HRESULT hrTmp2 = S_OK;
                BOOL  fStaticIpChanged = FALSE;

                // We should have equal number of IP addresses & subnet masks
                Assert(pAdapter->m_vstrIpAddresses.size() ==
                           pAdapter->m_vstrSubnetMask.size());

                Assert(pAdapter->m_vstrOldIpAddresses.size() ==
                       pAdapter->m_vstrOldSubnetMask.size());

                // We need to check if individual IP addresses are different
                // and call HrCallDhcpConfig once for each difference

                int iCountNew = pAdapter->m_vstrIpAddresses.size();
                int iCountOld = pAdapter->m_vstrOldIpAddresses.size();

                int iCount = iCountNew>iCountOld ? iCountOld :iCountNew;
                Assert(iCount>0);

                int iIp;

                // For each static IP address index in both old and new
                // Update IP
                for (iIp=0; iIp<iCount; iIp++)
                {
                    // Change address if mismatch
                    if((*pAdapter->m_vstrIpAddresses[iIp] !=
                        *pAdapter->m_vstrOldIpAddresses[iIp]) ||
                       (*pAdapter->m_vstrSubnetMask[iIp] !=
                        *pAdapter->m_vstrOldSubnetMask[iIp]))
                    {
                        // if a mismatch found, change it
                        fStaticIpChanged = TRUE;
                        break;
                    }
                }

                if (fStaticIpChanged)
                {
                    int i;

                    // blow away the rest of the old addresses in reverse order
                    for (i= iCountOld-1; i>=iIp; i--)
                    {
                        // Remove IP address on the fly
                        hrTmp2= HrCallDhcpConfig(
                                NULL,
                                (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                pAdapter->m_guidInstanceId,
                                TRUE,   // IsNewIpAddress: TRUE in static->static
                                i,      // Index of old IP address
                                0,      // Ip Address: remove
                                0,      // Subnetmask: remove
                                IgnoreFlag); // Flag: static->static

                        TraceError("Ctcpipcfg::HrNotifyDhcp - remove static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }

                    // add the rest of the new addresses in order
                    for (i= iIp; i< iCountNew; i++)
                    {
                        // Ip Address
                        DWORD dwIp[4];
                        GetNodeNum(pAdapter->m_vstrIpAddresses[i]->c_str(),dwIp);
                        DWORD dwNewIp = ConvertIpDword(dwIp);

                        // Subnet mask
                        DWORD dwSubnet[4];
                        GetNodeNum(pAdapter->m_vstrSubnetMask[i]->c_str(),dwSubnet);
                        DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                        if (0 == i)
                        {
                            // $REVIEW(tongl 6/3/98): the first address has to be added differently,
                            // yet another requirement by the api to change static ip list (bug #180015).
                            // Bug #180617 had my request to change the API to allow reconfigure whole
                            // static ip list instead of requiring caller to figure out everything needed
                            // for the internal data structure change for ip.

                            // must call "replace" instead of "add"
                            hrTmp2= HrCallDhcpConfig(
                                        NULL,
                                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                        pAdapter->m_guidInstanceId,
                                        TRUE,   // IsNewIpAddress: TRUE in static->static
                                        0,      // Replace first address
                                        dwNewIp,
                                        dwNewSubnet,
                                        IgnoreFlag); // Flag: static->static
                        }
                        else
                        {
                            // Add IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                        NULL,
                                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                        pAdapter->m_guidInstanceId,
                                        TRUE,   // IsNewIpAddress: TRUE in static->static
                                        0xFFFF, // New IP address
                                        dwNewIp,
                                        dwNewSubnet,
                                        IgnoreFlag); // Flag: static->static
                        }

                        TraceError("Ctcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }
                }
                else
                {
                    // existing addresses all match
                    if (iIp<iCountNew) // We ust get more new addresses to add
                    {
                        fStaticIpChanged = TRUE;

                        while (iIp<iCountNew)
                        {
                            DWORD dwIp[4];
                            Assert(!pAdapter->m_vstrIpAddresses.empty());

                            GetNodeNum(pAdapter->m_vstrIpAddresses[iIp]->c_str(),
                                       dwIp);
                            DWORD dwNewIp = ConvertIpDword(dwIp);

                            // Subnet mask
                            DWORD dwSubnet[4];
                            Assert(!pAdapter->m_vstrSubnetMask.empty());
                            GetNodeNum(pAdapter->m_vstrSubnetMask[iIp]->c_str(),
                                       dwSubnet);
                            DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                            // Add IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    TRUE,   // IsNewIpAddress: TRUE in static->static
                                    0xFFFF, // New IP address
                                    dwNewIp,
                                    dwNewSubnet,
                                    IgnoreFlag); // Flag: static->static

                            TraceError("Ctcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                            if SUCCEEDED(hrTmp)
                                hrTmp = hrTmp2;

                            iIp++;
                        }
                    }
                    else if (iIp<iCountOld) // We just get more old addresses to remove
                    {
                        fStaticIpChanged = TRUE;

                        int iIp2 = iCountOld-1;

                        while (iIp2 >= iIp)
                        {
                            // Remove IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    TRUE,   // IsNewIpAddress: TRUE in static->static
                                    iIp2,    // Index of old IP address
                                    0,      // Ip Address: remove
                                    0,      // Subnetmask: remove
                                    IgnoreFlag); // Flag: static->static

                            TraceError("Ctcpipcfg::HrNotifyDhcp - remove static IP address", hrTmp2);

                            if SUCCEEDED(hrTmp)
                                hrTmp = hrTmp2;

                            iIp2--;
                        }
                    }
                }
            }

            // 3) Dhcp->Static
            // DHCP is disabled now, but used to be enabled
            if(!pAdapter->m_fEnableDhcp &&
               pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: DHCP->Static IP",
                         pAdapter->m_strBindName.c_str());

                // Disable Dhcp & add first static Ip address
                Assert(!pAdapter->m_vstrIpAddresses.empty());

                // Ip Address
                DWORD dwIp[4];
                GetNodeNum(pAdapter->m_vstrIpAddresses[0]->c_str(),
                           dwIp);
                DWORD dwNewIp = ConvertIpDword(dwIp);

                // Subnet Mask
                DWORD dwSubnet[4];
                Assert(!pAdapter->m_vstrSubnetMask.empty());
                GetNodeNum(pAdapter->m_vstrSubnetMask[0]->c_str(),
                           dwSubnet);
                DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                // change IP address on the fly
                hrTmp = HrCallDhcpConfig(
                        NULL,
                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                        pAdapter->m_guidInstanceId,
                        TRUE,
                        0, // index: update dhcp address to first static address
                        dwNewIp,
                        dwNewSubnet,
                        DhcpDisable); // Flag: disable Dhcp

                if SUCCEEDED(hrTmp)
                {
                    HRESULT hrTmp2 = S_OK;

                    // Add the rest of new static IP addresses
                    for (size_t iIp = 1;
                         iIp < pAdapter->m_vstrIpAddresses.size();
                         iIp++)
                    {
                        // Ip Address
                        DWORD dwIp[4];
                        Assert(!pAdapter->m_vstrIpAddresses.empty());
                        GetNodeNum(pAdapter->m_vstrIpAddresses[iIp]->c_str(),
                                   dwIp);
                        DWORD dwNewIp = ConvertIpDword(dwIp);

                        // Subnet Mask
                        DWORD dwSubnet[4];
                        Assert(!pAdapter->m_vstrSubnetMask.empty());
                        GetNodeNum(pAdapter->m_vstrSubnetMask[iIp]->c_str(),
                                   dwSubnet);
                        DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                        // change IP address on the fly
                        hrTmp2= HrCallDhcpConfig(
                                NULL,
                                (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                pAdapter->m_guidInstanceId,
                                TRUE,
                                0xFFFF, // index: new address
                                dwNewIp,
                                dwNewSubnet,
                                IgnoreFlag ); // Flag: static->static

                         TraceError("CTcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }
                }
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;

            // 4) Dhcp Class ID, DNS server list and domain change
            // $REVIEW(tongl 6/12): Notify DNS server list and domain changes
            // here (Raid #175766)

            DHCP_PNP_CHANGE DhcpPnpChange;
            ZeroMemory(&DhcpPnpChange, sizeof(DHCP_PNP_CHANGE));

            DhcpPnpChange.Version = DHCP_PNP_CHANGE_VERSION_0;
            DhcpPnpChange.HostNameChanged = FALSE;
            DhcpPnpChange.MaskChanged = FALSE;

            //Bug 257868 If there is user specified default gateway, notify dhcp client
            DhcpPnpChange.GateWayChanged = !fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                                            pAdapter->m_vstrOldDefaultGateway) ||
                                           !fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                                            pAdapter->m_vstrOldDefaultGatewayMetric);
            DhcpPnpChange.RouteChanged = FALSE;
            DhcpPnpChange.OptsChanged = FALSE;
            DhcpPnpChange.OptDefsChanged = FALSE;

            DhcpPnpChange.DnsListChanged = !fIsSameVstr(pAdapter->m_vstrDnsServerList,
                                                        pAdapter->m_vstrOldDnsServerList);
            DhcpPnpChange.DomainChanged = pAdapter->m_strDnsDomain != pAdapter->m_strOldDnsDomain;
            DhcpPnpChange.ClassIdChanged = FALSE;
            DhcpPnpChange.DnsOptionsChanged = 
                        ((!!pAdapter->m_fDisableDynamicUpdate) != 
                            (!!pAdapter->m_fOldDisableDynamicUpdate))
                        ||
                        ((!!pAdapter->m_fEnableNameRegistration) !=
                            (!!pAdapter->m_fOldEnableNameRegistration));
  

            if(DhcpPnpChange.DnsListChanged || 
               DhcpPnpChange.DnsOptionsChanged ||
               DhcpPnpChange.DomainChanged  ||
               (DhcpPnpChange.GateWayChanged && pAdapter->m_fEnableDhcp))
            {
                hrTmp = HrCallDhcpHandlePnPEvent(pAdapter, &DhcpPnpChange);
                if (FAILED(hrTmp))
                {
                    TraceError("HrCallDhcpHandlePnPEvent returns failure, requesting reboot...", hrTmp);
                    hr = NETCFG_S_REBOOT;
                }
            }

            if (pAdapter->m_fBackUpSettingChanged)
            {
                hrTmp = HrDhcpRefreshFallbackParams(pAdapter);
                if (FAILED(hrTmp))
                {
                    TraceError("HrDhcpRefreshFallbackParams returns failure, requesting reboot...", hrTmp);
                    hr = NETCFG_S_REBOOT;
                }
            }
        }
    }

    if (NETCFG_S_REBOOT != hr)
        hr = hrTmp;

    TraceError("CTcpipcfg::HrNotifyDhcp", hr);
    return hr;
}

// Define the export function prototype from dhcpcsvc.dll

typedef DWORD (APIENTRY *T_DhcpNotifyConfigChange)(PWSTR ServerName,
                                                   PWSTR AdapterName,
                                                   BOOL IsNewIpAddress,
                                                   DWORD IpIndex,
                                                   DWORD IpAddress,
                                                   DWORD SubnetMask,
                                                   SERVICE_ENABLE DhcpServiceEnabled);

//
//  CTcpipcfg::HrCallDhcpConfig
//
//  Sets the IP address on the fly (without re-booting)
//
//  ServerName             always set to NULL
//  AdapterName            the adapter BindPathName to tcpip
//  IsNewIpAddress         set to TRUE if Dhcp->Static or Statis->Static changes
//                         set to FALSE if Static->Dhcp changes
//
//
//  IpIndex                the index of the IP Address for the card
//                         adapters can have more than 1 IP Address
//                         (as seen in the Advanced dialog)
//                         (this is causing problem for Munil
//                         because the use of this index is buggy in his code
//                         index is always set to 0 if there is only one IP Address
//                         for the card
//
//  IpAddress               the new IP Address
//  SubnetMask              the new SubnetMask
//
//  DhcpServiceEnabled      enum type, can be set to :
//                          DhcpEnable      -> if DHCP was disabled,
//                                             but now being changed to enabled
//                          IgnoreFlag      -> DHCP was disabled and is still disabled
//                          DhcpDisable     -> DHCP was enabled, but now being changed
//                                             to disabled
//
// For extra reference talk to Munil -> these parameters correspond to the
// DhcpNotifyConfigChange API of the dhcpcsvc.dll file
//

HRESULT CTcpipcfg::HrCallDhcpConfig(PWSTR ServerName,
                         PWSTR AdapterName,
                         GUID & guidAdaputer,
                         BOOL IsNewIpAddress,
                         DWORD IpIndex,
                         DWORD IpAddress,
                         DWORD SubnetMask,
                         SERVICE_ENABLE DhcpServiceEnabled)
{

    HRESULT hr = S_OK;

    // Make sure TCP/IP is running.
    // Scoping brackets cause service and service controller to be
    // closed when we don't need them anymore.
    {
        CServiceManager smng;
        CService        serv;

        hr = smng.HrOpenService(&serv, c_szTcpip, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);
        if(SUCCEEDED(hr))
        {
            DWORD dwState;

            hr = serv.HrQueryState(&dwState);
            if(SUCCEEDED(hr))
            {
                if(dwState != SERVICE_RUNNING)
                {
                    //TCPIP must always be running if installed!!!
                    AssertSz(FALSE, "Tcpip service must always be running if installed!");
                    hr = E_FAIL;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        HMODULE hDll;
        FARPROC pDhcpConfig;
        hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                "DhcpNotifyConfigChange",
                &hDll, &pDhcpConfig);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidTcpip,"Begin calling DhcpNotifyConfigChange...");

            // Parameter dump for debugging
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] ServerName:%S", ServerName);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] AdapterName:%S", AdapterName);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IsNewIpAddress:%d", IsNewIpAddress);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IpIndex:%d", IpIndex);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IpAddress:%d", IpAddress);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] SubnetMask:%d", SubnetMask);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] DhcpServiceEnabled:%d", DhcpServiceEnabled);

            DWORD dwError;

            dwError = (*(T_DhcpNotifyConfigChange)pDhcpConfig)(
                                    ServerName,
                                    AdapterName,
                                    IsNewIpAddress,
                                    IpIndex,
                                    IpAddress,
                                    SubnetMask,
                                    DhcpServiceEnabled);

            TraceTag(ttidTcpip,"Finished calling DhcpNotifyConfigChange...");
            hr = HRESULT_FROM_WIN32(dwError);

            if FAILED(hr)
            {
                // Added as part of fix for #107373
                if (ERROR_DUP_NAME == dwError)
                {
                    // Warn the user about duplicate IP address
                    NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                             IDS_DUP_NETIP, MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hr = S_OK;
                }
                else if (ERROR_FILE_NOT_FOUND == dwError)
                {
                    // The adapter we want to reconfig is not connected
                    TraceTag(ttidTcpip, "The adater is disconnected or not bound to TCP/IP.");
                    hr = S_OK;
                }
                else if (STATUS_DUPLICATE_OBJECTID == dwError)
                {
                    // fix for 320797
                    TraceTag(ttidTcpip, "The address is already configured for the adapter");
                    hr = S_OK;
                }
                else if (ERROR_INVALID_DRIVE == dwError)
                {
                    // fix for 320797
                    TraceTag(ttidTcpip, "The address has already been deleted from the stack");
                    hr = S_OK;
                }
                else
                {
                    TraceError("Error on DhcpNotifyConfigChange from dhcpcsvc.dll", hr);

                    FARPROC pfnHrGetPnpDeviceStatus = NULL;
                    HRESULT hrTmp = S_OK;
                    HMODULE hNetman = NULL;
                    NETCON_STATUS   ncStatus = NCS_CONNECTED;
                    hrTmp = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
                                                &hNetman, &pfnHrGetPnpDeviceStatus);

                    if (SUCCEEDED(hrTmp))
                    {
                        Assert(pfnHrGetPnpDeviceStatus);
                        hrTmp = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                                        &guidAdaputer,
                                        &ncStatus);
                        FreeLibrary(hNetman);
                    }

                    if (SUCCEEDED(hrTmp) && NCS_MEDIA_DISCONNECTED == ncStatus)
                    {
                        TraceTag(ttidTcpip, "The connection is media disconnected. Do not need to reboot");
                        hr = S_OK;
                    }
                    else
                    {
                        // Mask the specific error so NCPA does not fail.
                        hr = NETCFG_S_REBOOT;
                    }

                }
            }

            FreeLibrary (hDll);
        }
    }


    TraceError("CTcpipcfg::HrCallDhcpConfig", hr);
    return hr;
}

typedef DWORD (WINAPI * PFNDhcpHandlePnPEvent) (
                                                IN  DWORD               Flags,
                                                IN  DWORD               Caller,
                                                IN  PWSTR              AdapterName,
                                                IN  LPDHCP_PNP_CHANGE   Changes,
                                                IN  LPVOID              Reserved
                                                );

HRESULT CTcpipcfg::HrCallDhcpHandlePnPEvent(ADAPTER_INFO * pAdapterInfo,
                                         LPDHCP_PNP_CHANGE pDhcpPnpChange)
{
    // load the dll and get function pointer
    HMODULE hDll;
    FARPROC pDhcpHandlePnPEvent;
    HRESULT hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                                      "DhcpHandlePnPEvent",
                                      &hDll, &pDhcpHandlePnPEvent);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Flags: 0");
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Caller: DHCP_CALLER_TCPUI");
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] AdapterName: %S", pAdapterInfo->m_strBindName.c_str());
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.DnsListChanged: %d", pDhcpPnpChange->DnsListChanged);
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.DomainChanged: %d", pDhcpPnpChange->DomainChanged);
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.ClassIdChanged: %d", pDhcpPnpChange->ClassIdChanged);

        DWORD dwRet = (*(PFNDhcpHandlePnPEvent)pDhcpHandlePnPEvent)(
                            0,
                            DHCP_CALLER_TCPUI,
                            (PWSTR)pAdapterInfo->m_strBindName.c_str(),
                            pDhcpPnpChange,
                            NULL);

        hr = HRESULT_FROM_WIN32(dwRet);

        if (ERROR_FILE_NOT_FOUND == dwRet)
        {
            // The adapter we want to reconfig is not connected
            TraceTag(ttidTcpip, "DhcpHandlePnPEvent returns ERROR_FILE_NOT_FOUND. The adater is disconnected or not bound to TCP/IP.");
            hr = S_OK;
        }

        FreeLibrary (hDll);
    }

    TraceError("CTcpipcfg::HrCallDhcpHandlePnPEvent", hr);
    return hr;
}

typedef DWORD (WINAPI * PFDhcpFallbackRefreshParams) (
                                                IN  LPWSTR              AdapterName
                                                );

HRESULT CTcpipcfg::HrDhcpRefreshFallbackParams(ADAPTER_INFO * pAdapterInfo)
{
    // load the dll and get function pointer
    HMODULE hDll;
    FARPROC pDhcpFallbackRefreshParams;
    HRESULT hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                                      "DhcpFallbackRefreshParams",
                                      &hDll, &pDhcpFallbackRefreshParams);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidTcpip, "[DhcpFallbackRefreshParams] AdapterName: %S", pAdapterInfo->m_strBindName.c_str());
        DWORD dwRet = (*(PFDhcpFallbackRefreshParams)pDhcpFallbackRefreshParams)(
                            (LPWSTR)pAdapterInfo->m_strBindName.c_str()
                            );

        hr = HRESULT_FROM_WIN32(dwRet);

        if (ERROR_FILE_NOT_FOUND == dwRet)
        {
            // The adapter we want to reconfig is not connected
            TraceTag(ttidTcpip, "DhcpFallbackRefreshParams returns ERROR_FILE_NOT_FOUND. The adater is disconnected or not bound to TCP/IP.");
            hr = S_OK;
        }

        FreeLibrary (hDll);
    }
    
    TraceError("CTcpipcfg::HrDhcpRefreshFallbackParams", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcperror.h ===
#pragma once
#include "tcpip.h"

typedef enum _IP_VALIDATION_ERR
{
	ERR_NONE = 0,
	ERR_NO_IP,
	ERR_NO_SUBNET,
	ERR_UNCONTIGUOUS_SUBNET,
	ERR_HOST_ALL0,
	ERR_HOST_ALL1,
	ERR_SUBNET_ALL0,
	ERR_INCORRECT_IP
} IP_VALIDATION_ERR;

IP_VALIDATION_ERR IsValidIpandSubnet(PCWSTR szIp, PCWSTR szSubnet);
IP_VALIDATION_ERR ValidateIp(ADAPTER_INFO * const pvcardAdapterInfo);
int CheckForDuplicates(const VCARD * pvcardAdapterInfo, ADAPTER_INFO * pAdapterInfo, tstring& strIp);
BOOL FHasDuplicateIp(ADAPTER_INFO * pAdapterInfo);
BOOL FIsValidIpFields(PCWSTR szIp, BOOL fIsIpAddr = TRUE);
UINT GetIPValidationErrorMessageID(IP_VALIDATION_ERR err);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpfunc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P F U N C . C P P
//
//  Contents:   Various CTcpipcfg member functions that are not interface
//              methods
//
//  Notes:
//
//  Author:     tongl   1 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncpnp.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncui.h"
#include "tcpconst.h"
#include "tcphelp.h"
#include "tcputil.h"
#include "dhcpcsdk.h"
#include "dlgaddr.h"
#include "atmcommon.h"
#include "regkysec.h"

#include "netconp.h"

#define _PNP_POWER_
#include "ntddip.h"
#undef _PNP_POWER_

#include <atmarpif.h>

// sigh... llinfo.h is needed by ddwanarp.h
#include <llinfo.h>
#include <ddwanarp.h>

extern const WCHAR c_szBiNdisAtm[];
#if ENABLE_1394
extern const WCHAR c_szBiNdis1394[];
#endif // ENABLE_1394
extern const WCHAR c_szBiNdisWanIp[];
extern const WCHAR c_szEmpty[];
extern const WCHAR c_szSvcDnscache[];

extern void CopyVstr(VSTR * vstrDest, const VSTR & vstrSrc);

typedef struct {
    PCWSTR  pszValueName;
    DWORD   dwType;
} ValueType;

const ValueType s_rgNt4Values[] = {
    {RGAS_ENABLE_DHCP, REG_DWORD},
    {RGAS_IPADDRESS, REG_MULTI_SZ},
    {RGAS_SUBNETMASK, REG_MULTI_SZ},
    {RGAS_DEFAULTGATEWAY, REG_MULTI_SZ}
};

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::PAdapterFromInstanceGuid
//
//  Purpose:    Search the adapter info array for an entry with a matching
//              instance guid.  Return a pointer to the ADAPTER_INFO if found.
//
//  Arguments:
//      pGuid [in] pointer to instance guid to search for
//
//  Returns:    Valid pointer if found, NULL if not.
//
//  Author:     shaunco   1 Oct 1998
//
//  Notes:
//
ADAPTER_INFO*
CTcpipcfg::PAdapterFromInstanceGuid (
    const GUID* pGuid)
{
    Assert (pGuid);

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO* pAdapter = *iterAdapter;

        if (pAdapter->m_guidInstanceId == *pGuid)
        {
            return pAdapter;
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::PAdapterFromNetcfgComponent
//
//  Purpose:    Search the adapter info array for an entry with an instance
//              guid matching that of the specified INetCfgComponent.
//              Return a pointer to the ADAPTER_INFO if found.
//
//  Arguments:
//      pncc [in] INetCfgComponent who's instance guid we are looking for.
//
//  Returns:    Valid pointer if found, NULL if not.
//
//  Author:     shaunco   1 Oct 1998
//
//  Notes:
//
ADAPTER_INFO*
CTcpipcfg::PAdapterFromNetcfgComponent (
    INetCfgComponent* pncc)
{
    Assert (pncc);

    HRESULT hr;
    GUID    guidAdapter;

    hr = pncc->GetInstanceGuid (&guidAdapter);
    if (SUCCEEDED(hr))
    {
        return PAdapterFromInstanceGuid (&guidAdapter);
    }
    return NULL;
}

// Called by CTcpipcfg::Initialize.
// We walk the binding path from tcpip and load to first memory state
// all netcards ( both physical cards and Wan adapters )
HRESULT CTcpipcfg::HrGetNetCards()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccTcpip);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of tcpip to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        PWSTR pszInterfaceName;

        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            &pszInterfaceName);
        if (SUCCEEDED(hr))
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS

            GUID    guidClass;
            hr = pnccNetComponent->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr) && IsEqualGUID(guidClass, GUID_DEVCLASS_NET))
            {
                PWSTR pszNetCardTcpipBindPath;
                hr = pnccNetComponent->GetBindName(&pszNetCardTcpipBindPath);

                AssertSz(SUCCEEDED(hr),
                         "Net card on binding path with no bind path name!!");

                
                m_vstrBindOrder.push_back(new tstring(pszNetCardTcpipBindPath));

                hr = HrAddCard(pnccNetComponent,
                               pszNetCardTcpipBindPath,
                               pszInterfaceName);

                if (SUCCEEDED(hr))
                {
                    GUID    guidNetCard;
                    hr = pnccNetComponent->GetInstanceGuid(&guidNetCard);
                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled?
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (S_OK == hr)
                        {   // bind the card in our data strucutres
                            hr = HrBindCard(&guidNetCard, TRUE);
                        }
                        else if (S_FALSE == hr)
                        {
                            hr = HrUnBindCard(&guidNetCard, TRUE);
                        }
                    }
                }

                CoTaskMemFree(pszNetCardTcpipBindPath);
            }

            ReleaseObj(pnccNetComponent);
            CoTaskMemFree(pszInterfaceName);
        }

        ReleaseObj(pncbp);
    }

    if (S_FALSE == hr) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CTcpipcfg::HrGetNetCards", hr);
    return hr;
}

BOOL CTcpipcfg::IsBindOrderChanged()
{
    HRESULT hr = S_OK;

    VSTR    vstrCurrentBindOrder;
    BOOL    fChanged = FALSE;
    
    hr = HrLoadBindingOrder(&vstrCurrentBindOrder);

    if (SUCCEEDED(hr))
    {
        fChanged = !fIsSameVstr(vstrCurrentBindOrder, m_vstrBindOrder);
        FreeCollectionAndItem(vstrCurrentBindOrder);
    }

    return fChanged;
}


HRESULT CTcpipcfg::HrLoadBindingOrder(VSTR *pvstrBindOrder)
{

    Assert(pvstrBindOrder);

    HRESULT                 hr = S_OK;

    CIterNetCfgBindingPath  ncbpIter(m_pnccTcpip);
    INetCfgBindingPath *    pncbp;
    INetCfgComponent *      pnccLast;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
    {
        hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);

        if (SUCCEEDED(hr))
        {
            Assert(pnccLast);

            // The last component should be of NET CLASS
            GUID    guidClass;
            hr = pnccLast->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr) && IsEqualGUID(guidClass, GUID_DEVCLASS_NET))
            {
                PWSTR pszNetCardTcpipBindPath;
                hr = pnccLast->GetBindName(&pszNetCardTcpipBindPath);

                AssertSz(SUCCEEDED(hr),
                         "Net card on binding path with no bind path name!!");

                if (SUCCEEDED(hr))
                {
                    pvstrBindOrder->push_back(new tstring(pszNetCardTcpipBindPath));
                    
                    CoTaskMemFree(pszNetCardTcpipBindPath);
                }
            }

            ReleaseObj(pnccLast);
        }

        ReleaseObj(pncbp);
    }


    if (S_FALSE == hr) // We just got to the end of the loop
    {
        hr = S_OK;
    }

    //if failed, clean up what we added
    if (FAILED(hr))
    {
        FreeCollectionAndItem(*pvstrBindOrder);
    }

    TraceError("CBindingsDlg::HrGetBindOrder", hr);
    return hr;
}

// Called by CTcpipcfg::CancelProperties and CTcpipcfg::ApplyProperties
// Release second memory state
void CTcpipcfg::ExitProperties()
{
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;
}


// Called by CTcpipcfg's destructor
// Release all memory states
void CTcpipcfg::FinalFree()
{
    FreeCollectionAndItem(m_vcardAdapterInfo);

    FreeCollectionAndItem(m_vstrBindOrder);

    delete m_pSecondMemoryAdapterInfo;

    delete m_ipaddr;

    DeleteObject(g_hiconUpArrow);
    DeleteObject(g_hiconDownArrow);

    ReleaseObj(m_pnc);
    ReleaseObj(m_pTcpipPrivate);
    ReleaseObj(m_pnccTcpip);
    ReleaseObj(m_pnccWins);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ?");
    ReleaseObj(m_pUnkContext) ;
}

// Called by CTcpipcfg::HrSetupPropSheets
// Creates the second memory adapter info from the first
// memory structure
// Note: Bound cards only
HRESULT CTcpipcfg::HrLoadAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(&m_guidCurrentConnection);
    if (pAdapter)
    {
        // enabled LAN adapter or any RAS Fake adapter
        if ((pAdapter->m_BindingState == BINDING_ENABLE) ||
            pAdapter->m_fIsRasFakeAdapter)
        {
            m_pSecondMemoryAdapterInfo = new ADAPTER_INFO;
            if (NULL == m_pSecondMemoryAdapterInfo)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                *m_pSecondMemoryAdapterInfo = *pAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CTcpipcfg::HrLoadAdapterInfo", hr);
    return hr;
}

// Called by CTcpipcfg::ApplyProperties
// Saves the second memory state back into the first
HRESULT CTcpipcfg::HrSaveAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(
        &m_pSecondMemoryAdapterInfo->m_guidInstanceId);
    if (pAdapter)
    {
#ifdef DBG
        // The card can not get unbound while in tcpip's properties UI!
        if (!pAdapter->m_fIsRasFakeAdapter)
        {
            Assert(pAdapter->m_BindingState == BINDING_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BINDING_ENABLE);
        }
#endif
        *pAdapter = *m_pSecondMemoryAdapterInfo;
        hr = S_OK;

    }
    AssertSz((S_OK == hr),
             "Adapter in second memory not found in first memory!");

    TraceError("CTcpipcfg::HrSaveAdapterInfo", hr);
    return hr;
}

// Called by CTcpipcfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CTcpipcfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CTcpipcfg::SetContext?");

    if (!m_pUnkContext)
    {
        return E_UNEXPECTED;
    }

    // Is this a lan connection ?
    GUID guidConn;
    INetLanConnectionUiInfo * pLanConnUiInfo;
    HRESULT hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                            reinterpret_cast<PVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        m_ConnType = CONNECTION_LAN;

        hr = pLanConnUiInfo->GetDeviceGuid(&guidConn);

        ReleaseObj(pLanConnUiInfo);
    }
    else
    {
        INetRasConnectionIpUiInfo * pRasConnUiInfo;

        // Is this a wan connection ?
        hr = m_pUnkContext->QueryInterface(IID_INetRasConnectionIpUiInfo,
                               reinterpret_cast<PVOID *>(&pRasConnUiInfo));
        if (SUCCEEDED(hr))
        {
            // yes, RAS connection
            RASCON_IPUI info;
            if (SUCCEEDED(pRasConnUiInfo->GetUiInfo(&info)))
            {
                guidConn = info.guidConnection;

                //currently VPN connections only supports PPP frames, so
                //if RCUIF_VPN is set, RCUIF_PPP should also be there.
                //RCUIF_PPP and RCUIF_SLIP are mutually exclusive
                //m_ConnType is only used to show/hide the controls in the RAS
                //config UI. 
                if (info.dwFlags & RCUIF_VPN)
                {
                    m_ConnType = CONNECTION_RAS_VPN;
                }
                else
                {
                    if (info.dwFlags & RCUIF_PPP)
                    {
                        m_ConnType = CONNECTION_RAS_PPP;
                    }
                    else if (info.dwFlags & RCUIF_SLIP)
                    {
                        m_ConnType = CONNECTION_RAS_SLIP;
                    }
                }

                m_fRasNotAdmin = !!(info.dwFlags & RCUIF_NOT_ADMIN);

                AssertSz(((CONNECTION_RAS_PPP == m_ConnType)||
                        (CONNECTION_RAS_SLIP == m_ConnType) ||
                        (CONNECTION_RAS_VPN == m_ConnType)),
                         "RAS connection type unknown ?");

                UpdateRasAdapterInfo (info);
            }
        }

        ReleaseObj(pRasConnUiInfo);
    }

    if (SUCCEEDED(hr))
    {
        m_guidCurrentConnection = guidConn;
    }

    AssertSz(((CONNECTION_LAN == m_ConnType)||
              (CONNECTION_RAS_PPP == m_ConnType)||
              (CONNECTION_RAS_SLIP == m_ConnType)||
              (CONNECTION_RAS_VPN == m_ConnType)),
             "How come this is neither a LAN connection nor a RAS connection?");

    TraceError("CTcpipcfg::HrSetConnectionContext", hr);
    return hr;
}

// Called by CTcpipcfg::MergePropPages
// Allocate property pages
HRESULT CTcpipcfg::HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryLmhostsFileReset = FALSE;
    m_fSecondMemoryModified = FALSE;

    //IPSec is removed from connection UI   
//    m_fSecondMemoryIpsecPolicySet = FALSE;


    // copy in memory state to tcpip dialog memory state
    // Copy global Info
    m_glbSecondMemoryGlobalInfo = m_glbGlobalInfo;

    // Copy adapter card specific info
    hr = HrLoadAdapterInfo();

    // If we have found the matching adapter
    if (SUCCEEDED(hr))
    {
        cPages = 1;

        delete m_ipaddr;
        m_ipaddr = new CTcpAddrPage(this, g_aHelpIDs_IDD_TCP_IPADDR);

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;

        Assert(m_ConnType != CONNECTION_UNSET);

        if (m_ConnType == CONNECTION_LAN)
            ahpsp[cPages++] = m_ipaddr->CreatePage(IDD_TCP_IPADDR, 0);
        else
            ahpsp[cPages++] = m_ipaddr->CreatePage(IDD_TCP_IPADDR_RAS, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if we don't have any bound cards, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CTcpipcfg::HrSetupPropSheets", hr);
    return hr;
}

// Is there any bound card on the list of physical adapters
BOOL CTcpipcfg::FHasBoundCard()
{
    BOOL fRet = FALSE;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO* pAdapter = *iterAdapter;

        if (pAdapter->m_BindingState == BINDING_ENABLE)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

// Called by CTcpipcfg::NotifyBindingPath
// Handle bind notification of a physical card
HRESULT CTcpipcfg::HrAdapterBindNotify(INetCfgComponent *pnccNetCard,
                                       DWORD dwChangeFlag,
                                       PCWSTR pszInterfaceName)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    Assert(pnccNetCard);

    GUID guidNetCard;
    HRESULT hr = pnccNetCard->GetInstanceGuid(&guidNetCard);
    if (SUCCEEDED(hr))
    {
        if (dwChangeFlag & NCN_ADD)
        {
            PWSTR pszNetCardTcpipBindPath;
            hr = pnccNetCard->GetBindName(&pszNetCardTcpipBindPath);
            AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

            hr = HrAddCard(pnccNetCard,
                           pszNetCardTcpipBindPath,
                           pszInterfaceName);

            CoTaskMemFree(pszNetCardTcpipBindPath);
        }

        if (dwChangeFlag & NCN_ENABLE)
        {
            hr = HrBindCard(&guidNetCard);
        }

        if (dwChangeFlag & NCN_DISABLE)
        {
            hr = HrUnBindCard(&guidNetCard);
        }

        if (dwChangeFlag & NCN_REMOVE)
        {
            hr = HrDeleteCard(&guidNetCard);
        }

    }

    TraceError("CTcpipCfg::HrPhysicalCardBindNotify", hr);
    return hr;
}

// HrAddCard
// Adds a card to the list of cards installed in the system
// pnccNetCard               the netcard's GUID in string form
// szNetCardTcpipBindPath    the bind path name from Tcpip to the card
// strInterfaceName          the upper interface name of the card
HRESULT CTcpipcfg::HrAddCard(INetCfgComponent * pnccNetCard,
                             PCWSTR pszCardTcpipBindPath,
                             PCWSTR pszInterfaceName)
{
    GUID guidNetCard;
    HRESULT hr = pnccNetCard->GetInstanceGuid(&guidNetCard);
    if (SUCCEEDED(hr))
    {
        // Get card bind name
        PWSTR pszNetCardBindName;
        hr = pnccNetCard->GetBindName(&pszNetCardBindName);

        AssertSz(SUCCEEDED(hr),
                 "Net card on binding path with no bind name!!");

        // Get card description
        // This is only needed for physical cards
        //
        BOOL fFreeDescription = TRUE;
        PWSTR pszDescription;

        // If we can't get a description then give it a default one
        if (FAILED(pnccNetCard->GetDisplayName(&pszDescription)))
        {
            pszDescription = const_cast<PWSTR>(
                                SzLoadIds(IDS_UNKNOWN_NETWORK_CARD));
            fFreeDescription = FALSE;
        }
        Assert (pszDescription);

        ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(&guidNetCard);
        if (!pAdapter)
        {
            pAdapter = new ADAPTER_INFO;

            if (NULL == pAdapter)
            {
                return E_OUTOFMEMORY;
            }

            hr = pAdapter->HrSetDefaults(&guidNetCard,
                                         pszDescription,
                                         pszNetCardBindName,
                                         pszCardTcpipBindPath);
            if (SUCCEEDED(hr))
            {
                // add new card to our data structures and initialize it to default values
                m_vcardAdapterInfo.push_back(pAdapter);
            }
            else
            {
                delete pAdapter;
                pAdapter = NULL;
            }
        }
        else
        {
            // Set the flag that this card is now on the binding path
            pAdapter->m_fIsFromAnswerFile = FALSE;
            pAdapter->m_fDeleted = FALSE;

            // reset binding state
            pAdapter->m_BindingState = BINDING_UNSET;
            pAdapter->m_InitialBindingState = BINDING_UNSET;

            // Set CardDescription, BindName and BindPathName
            pAdapter->m_strDescription = pszDescription;
            pAdapter->m_strBindName = pszNetCardBindName;
            pAdapter->m_strTcpipBindPath = pszCardTcpipBindPath;

            pAdapter->m_strNetBtBindPath = c_szTcpip_;
            pAdapter->m_strNetBtBindPath += pAdapter->m_strTcpipBindPath;
        }

        if (SUCCEEDED(hr))
        {
            Assert(pAdapter);

            // set flags if ATM card or Wan adapter
            if (0 == lstrcmpW(pszInterfaceName, c_szBiNdisAtm))
            {
                pAdapter->m_fIsAtmAdapter = TRUE;
            }
            else if (0 == lstrcmpW(pszInterfaceName, c_szBiNdisWanIp))
            {
                pAdapter->m_fIsWanAdapter = TRUE;
            }
        #if ENABLE_1394
            else if (0 == lstrcmpW(pszInterfaceName, c_szBiNdis1394))
            {
                pAdapter->m_fIs1394Adapter = TRUE;
            }
        #endif // ENABLE_1394
        }

        if (fFreeDescription)
        {
            CoTaskMemFree(pszDescription);
        }
        CoTaskMemFree(pszNetCardBindName);
    }

    TraceError("CTcpipcfg::HrAddCard", hr);
    return hr;
}

//HrBindCard    sets the state of a netcard in the list of installed
//              netcards to BOUND
//
// Note: fInitialize is only TRUE when this is called from Initialize,
// the default is FALSE.
//
HRESULT CTcpipcfg::HrBindCard(const GUID* pguid, BOOL fInitialize)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
        AssertSz(pAdapter->m_BindingState != BINDING_ENABLE,
                 "the same netcard was bound twice to TCPIP");

        // Set binding state
        pAdapter->m_BindingState = BINDING_ENABLE;

        if (fInitialize)
            pAdapter->m_InitialBindingState = BINDING_ENABLE;
    }
    else
    {
        AssertSz(FALSE, "Attempt to bind a card which wasn't installed");
    }
    return S_OK;
}

//HrUnBindCard  sets the state of a netcard in the list of installed
//              netcards to UNBOUND
//
// Note: fInitialize is only TRUE when this is called from Initialize,
// the default is FALSE.
//
HRESULT CTcpipcfg::HrUnBindCard(const GUID* pguid, BOOL fInitialize)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
        AssertSz(pAdapter->m_BindingState != BINDING_DISABLE,
                 "attempt to unbind an unbound card");

        // Set binding state to disable
        pAdapter->m_BindingState = BINDING_DISABLE;

        if (fInitialize)
            pAdapter->m_InitialBindingState = BINDING_DISABLE;
    }
    else
    {
        AssertSz(FALSE, "Attempt to unbind a card which wasn't installed");
    }
    return S_OK;
}

// HrDeleteCard
// Deletes a card from the list of cards installed in the system
//
HRESULT CTcpipcfg::HrDeleteCard(const GUID* pguid)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
       pAdapter->m_fDeleted = TRUE;
    }
    else
    {
        AssertSz(FALSE, "A delete attempt was made on a card which doesn't exist");
    }
    return S_OK;
}

//Function to get the list of cards which have been added to the system
//hkeyTcpipParam       "Services\Tcpip\Parameters"
HRESULT CTcpipcfg::MarkNewlyAddedCards(const HKEY hkeyTcpipParam)
{

    //(08/19/98 nsun) changed from Tcpip\Parameters\Interfaces to Tcpip\Parameters\Adapters key
    // to support multiple interfaces
    HKEY hkeyAdapters;
    HRESULT hr = HrRegOpenKeyEx(hkeyTcpipParam,
                        c_szAdaptersRegKey,
                        KEY_READ, &hkeyAdapters);
    if (SUCCEEDED(hr))
    {
        VSTR vstrAdaptersInRegistry;
        Assert(vstrAdaptersInRegistry.empty());

        // Get the list of keys
        hr = HrLoadSubkeysFromRegistry(hkeyAdapters,
                                       &vstrAdaptersInRegistry);
        if (SUCCEEDED(hr))
        {
            //Go through the list of cards we currently have
            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                BOOL fAdded = TRUE;

                // If we have a card in the list which isn't in registry
                // then we add that card to the list of added cards
                for(VSTR_CONST_ITER iter = vstrAdaptersInRegistry.begin();
                    iter != vstrAdaptersInRegistry.end() ; ++iter)
                {
                    if (lstrcmpiW((**iter).c_str(), pAdapter->m_strBindName.c_str()) == 0)
                    {
                        fAdded = FALSE;
                        break;
                    }
                }

                // if the card is new then mark it
                if (fAdded)
                {
                    pAdapter->m_fNewlyChanged = TRUE;
                }
            }

            FreeCollectionAndItem(vstrAdaptersInRegistry);
        }
        RegCloseKey(hkeyAdapters);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        TraceTag(ttidTcpip, "No existing card found.");
        hr = S_OK;
    }

    TraceError("CTcpipcfg::MarkNewlyAddedCards", hr);
    return hr;
}

//+------------------------------------------------------------------------------
//
//  Function:   HrLoadSettings, HrLoadTcpipRegistry, HrLoadWinsRegistry
//
//              HrSaveSettings, HrSaveTcpipRegistry, HrSaveTcpipNdisWanRegistry,
//              HrSetMisc
//
//  Purpose:    Functions to Load/Set registry settings and other system info
//              during Initialize and Apply time
//
// Author:      tongl 5/5/97
//-------------------------------------------------------------------------------

// Called by CTcpipcfg::Initialize
// Load registry settings for a list of net cards
HRESULT CTcpipcfg::HrLoadSettings()
{
    HKEY hkey = NULL;

    // Load Tcpip's parameters
    HRESULT hrTcpip = S_OK;
    hrTcpip = m_pnccTcpip->OpenParamKey(&hkey);
    if (hrTcpip == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hrTcpip = S_OK;
    else if (SUCCEEDED(hrTcpip))
    {
        Assert(hkey);
        hrTcpip = HrLoadTcpipRegistry(hkey);
        RegCloseKey(hkey);
    }
    else
        Assert(!hkey);

    // Load NetBt's parameters
    HRESULT hrWins = S_OK;

    if (m_pnccWins)
    {   // If Wins is not installed don't get WINS information
        hkey = NULL;
        hrWins = m_pnccWins->OpenParamKey(&hkey);
        if (hrWins == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            hrWins = S_OK;
        else if (SUCCEEDED(hrWins))
        {
            Assert(hkey);
            hrWins = HrLoadWinsRegistry(hkey);
            RegCloseKey(hkey);
        }
        else
            Assert(!hkey);
    }

    HRESULT hr = S_OK;
    hr = SUCCEEDED(hrTcpip)         ? hr : hrTcpip;
    hr = SUCCEEDED(hrWins)          ? hr : hrWins;

    TraceError("CTcpipcfg::HrLoadSettings", hr);
    return hr;
}


// Called by CTcpipcfg::HrLoadSettings
// Loads all information under the Services\Tcpip\Parameters registry key
//
// const HKEY hkeyTcpipParam : Handle to Services\Tcpip\Parameters
HRESULT CTcpipcfg::HrLoadTcpipRegistry(const HKEY hkeyTcpipParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(hkeyTcpipParam);

    // Load global parameters

    // DNS server
    // For bug #147476: in NT5 upgrades, somehow the
    // global DNS server list is deleted, but not until after initialize exits
    // So I'm reading in the value here if it exists

    // DNS server list moved from global to per adapter
    hrTmp = HrRegQueryString(hkeyTcpipParam, RGAS_NAMESERVER, &m_strDnsServerList);

    tstring strDnsSuffixList;
    if FAILED(hrTmp = HrRegQueryString(hkeyTcpipParam, c_szSearchList,
                                       &strDnsSuffixList))
    {
        TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
        TraceTag(ttidTcpip, "Failed on loading SearchList, hr: %x", hr);
        hr = S_OK;
    }
    else
    {
        ConvertStringToColString(strDnsSuffixList.c_str(),
                                 c_chListSeparator,
                                 m_glbGlobalInfo.m_vstrDnsSuffixList);
    }

    m_glbGlobalInfo.m_fUseDomainNameDevolution =
                            FRegQueryBool(hkeyTcpipParam,
                                        c_szUseDomainNameDevolution,
                                        m_glbGlobalInfo.m_fUseDomainNameDevolution);

    m_glbGlobalInfo.m_fEnableRouter = FRegQueryBool(hkeyTcpipParam, c_szIpEnableRouter,
                                  m_glbGlobalInfo.m_fEnableRouter);

    //(nsun 11/02/98) gloabl RRAS settings
    m_glbGlobalInfo.m_fEnableIcmpRedirect = FRegQueryBool(hkeyTcpipParam,
                                    c_szEnableICMPRedirect,
                                    m_glbGlobalInfo.m_fEnableIcmpRedirect);

    //PerformRouterDiscoveryDefault was removed to fix bug 405636

    m_glbGlobalInfo.m_fDeadGWDetectDefault = FRegQueryBool(hkeyTcpipParam,
                                    c_szDeadGWDetectDefault,
                                    m_glbGlobalInfo.m_fDeadGWDetectDefault);

    m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault = FRegQueryBool(hkeyTcpipParam,
                                    c_szDontAddDefaultGatewayDefault,
                                    m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);

    m_glbGlobalInfo.m_fEnableFiltering = FRegQueryBool(hkeyTcpipParam,
                                    RGAS_SECURITY_ENABLE,
                                    m_glbGlobalInfo.m_fEnableFiltering);

    // Save old values
    m_glbGlobalInfo.ResetOldValues();

    // (08/18/98 nsun) read multiple interface settings for WAN adapters
    // Open CCS\Services\Tcpip\Parameters\Adapters key
    HKEY hkeyAdapters;
    hr = HrRegOpenKeyEx(hkeyTcpipParam, c_szAdaptersRegKey, KEY_READ,
                        &hkeyAdapters);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) // no adapters key
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end() && SUCCEEDED(hr) ;
            iterAdapter ++)
        {
            //multiple interface only valid for WAN adapters
            if (!((*iterAdapter)->m_fIsWanAdapter))
                continue;

            ADAPTER_INFO * pAdapter = *iterAdapter;
            HKEY hkeyAdapterParam;

            hr = HrRegOpenKeyEx(hkeyAdapters,
                                pAdapter->m_strBindName.c_str(),
                                KEY_READ,
                                &hkeyAdapterParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                 Assert("No registry settings for a WAN adapter on the "
                    "bind path?!");

                 TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                 TraceTag(ttidTcpip, "No registry settings for a WAN adapter "
                    "on the bind path, set to defaults");
                 // We just use the default values
                 hr = S_OK;
            }
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "Loading multiple interface parameters "
                    "for Adapter '%S'", pAdapter->m_strBindName.c_str());

                DWORD   dwNumInterfaces;
                hr = HrRegQueryDword(hkeyAdapterParam,
                                    RGAS_NUMINTERFACES,
                                    &dwNumInterfaces);

                if (FAILED(hr))
                {
                    // the Wan adapter is NOT in mode of supporting multiple
                    // interfaces
                    TraceTag(ttidTcpip, "No mutliple interface for the WAN "
                        "adapter '%S'", pAdapter->m_strBindName.c_str());

                    pAdapter->m_fIsMultipleIfaceMode = FALSE;
                    hr = S_OK;
                }
                else
                {
                    pAdapter->m_fIsMultipleIfaceMode = TRUE;

                    // the WAN adapter supports multiple interface but not
                    // interface is defined yet
                    //
                    if (0 != dwNumInterfaces)
                    {
                        GUID* aguidIds;
                        DWORD cb;

                        hr = HrRegQueryBinaryWithAlloc(hkeyAdapterParam,
                                                      RGAS_IPINTERFACES,
                                                      (LPBYTE*)&aguidIds,
                                                      &cb);
                        if (FAILED(hr))
                        {
                            AssertSz(FALSE, "NumInterfaces and IpInterfaces "
                                "values conflicts");
                            // the Wan adapter is NOT in mode of supporting
                            // multiple interfaces
                            //
                            TraceTag(ttidTcpip, "NumInterfaces and IpInterfaces "
                                "values conflicts for the WAN adapter '%S'",
                                pAdapter->m_strBindName.c_str());

                            hr = S_OK;
                        }
                        else if (NULL != aguidIds)
                        {
                            dwNumInterfaces = cb / sizeof(GUID);

                            for(DWORD i = 0; i < dwNumInterfaces; i++)
                            {
                                pAdapter->m_IfaceIds.push_back(aguidIds[i]);
                            }

                            MemFree(aguidIds);
                        }
                    }
                }

                RegCloseKey(hkeyAdapterParam);
            }
        }
        RegCloseKey(hkeyAdapters);
    }

    // Get per adapter parameters
    // Open CCS\Services\Tcpip\Parameters\Interfaces key
    HKEY    hkeyInterfaces;
    hr = HrRegOpenKeyEx(hkeyTcpipParam, c_szInterfacesRegKey, KEY_READ,
                        &hkeyInterfaces);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) //no adapter interfaces
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        // Get all the subkeys currently in registry
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end() && SUCCEEDED(hr) ;
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            if (pAdapter->m_fIsWanAdapter)
            {
                continue;
            }

            HKEY hkeyInterfaceParam;
            // Open CCS\Services\Tcpip\Parameters\Interfaces\<card bind path> key
            hr = HrRegOpenKeyEx(hkeyInterfaces,
                                pAdapter->m_strTcpipBindPath.c_str(),
                                KEY_READ,
                                &hkeyInterfaceParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                Assert("No registry settings for a card on the bind path?!");

                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "No registry settings for a card on the bind path, set to defaults");
                // We just use the default values
                hr = S_OK;
            }
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "Loading parameters for Interface '%S'",
                    pAdapter->m_strTcpipBindPath.c_str());

                pAdapter->m_fEnableDhcp = FRegQueryBool(hkeyInterfaceParam,
                                              RGAS_ENABLE_DHCP,
                                              pAdapter->m_fEnableDhcp);

                // Get ip address
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_IPADDRESS,
                                                   &(pAdapter->m_vstrIpAddresses))))
                {
                    TraceTag(ttidTcpip, "Failed on loading IpAddress, hr: %x", hr);
                    hr = S_OK;
                }

                // Set subnet mask information
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_SUBNETMASK,
                                                   &(pAdapter->m_vstrSubnetMask))))
                {
                    TraceTag(ttidTcpip, "Failed on loading SubnetMask, hr: %x", hr);
                    hr = S_OK;
                }

                // Set default gateway
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_DEFAULTGATEWAY,
                                                   &(pAdapter->m_vstrDefaultGateway))))
                {
                    TraceTag(ttidTcpip, "Failed on loading Default Gateway, hr: %x", hr);
                    hr = S_OK;
                }

                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                    RGAS_DEFAULTGATEWAYMETRIC,
                                    &(pAdapter->m_vstrDefaultGatewayMetric))))
                {
                    TraceTag(ttidTcpip, "Failed on Loading Default Gateway Metric, hr: %x", hr);
                    hr = S_OK;
                }

                // Dns domain
                if (FAILED(hr = HrRegQueryString(hkeyInterfaceParam,
                                                RGAS_DOMAIN,
                                                &(pAdapter->m_strDnsDomain))))
                {
                    TraceTag(ttidTcpip, "Failed on loading DnsDomain, hr: %x", hr);
                    hr = S_OK;
                }

                // Dns ip address dynamic update
                pAdapter->m_fDisableDynamicUpdate = !DnsIsDynamicRegistrationEnabled(
                                                (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());

                // adapter Dns domain name registration
                pAdapter->m_fEnableNameRegistration = DnsIsAdapterDomainNameRegistrationEnabled(
                                                (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());

                // Dns server search list
                tstring strDnsServerList;
                if (FAILED(hr = HrRegQueryString(hkeyInterfaceParam,
                                                RGAS_NAMESERVER,
                                                &strDnsServerList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading Dns NameServer list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    ConvertStringToColString(strDnsServerList.c_str(),
                                             c_chListSeparator,
                                             pAdapter->m_vstrDnsServerList);

                }

                // Interface metric
                if FAILED(hr = HrRegQueryDword(hkeyInterfaceParam,
                                              c_szInterfaceMetric,
                                              &(pAdapter->m_dwInterfaceMetric)))
                {
                    TraceTag(ttidTcpip, "Failed on loading InterfaceMetric, hr: %x", hr);
                    hr = S_OK;
                }

                // TCP port filter
                VSTR vstrTcpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_TCP,
                                                   &vstrTcpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading TCP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrTcpFilterList, vstrTcpFilterList);
                    FreeCollectionAndItem(vstrTcpFilterList);
                }

                // UDP port filter
                VSTR vstrUdpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_UDP,
                                                   &vstrUdpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading UDP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrUdpFilterList, vstrUdpFilterList);
                    FreeCollectionAndItem(vstrUdpFilterList);
                }

                // IP port filter
                VSTR vstrIpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_IP,
                                                   &vstrIpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading IP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrIpFilterList, vstrIpFilterList);
                    FreeCollectionAndItem(vstrIpFilterList);
                }

                if (FAILED(HrLoadBackupTcpSettings(hkeyInterfaceParam, 
                                                   pAdapter)))
                {
                    TraceTag(ttidTcpip, "Failed on loading Backup IP settings, hr: %x", hr);
                    hr = S_OK;
                }

                // ATM ARP client configurable parameters
                if (pAdapter->m_fIsAtmAdapter)
                {
                    HKEY hkeyAtmarpc = NULL;

                    // Open the Atmarpc subkey
                    hr = HrRegOpenKeyEx(hkeyInterfaceParam,
                                        c_szAtmarpc,
                                        KEY_READ,
                                        &hkeyAtmarpc);

                    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                    {
                        AssertSz(FALSE,"No atmarpc subkey for an atm adapter on the bind path?!");

                        TraceTag(ttidTcpip, "Failed on opening atmarpc subkey, defaults will be used, hr: %x", hr);
                        hr = S_OK;
                    }
                    else if (SUCCEEDED(hr))
                    {
                        // ARP server address list
                        if (FAILED(hr = HrRegQueryColString(hkeyAtmarpc,
                                                           c_szREG_ARPServerList,
                                                           &(pAdapter->m_vstrARPServerList))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading ARPServerList, hr: %x", hr);
                            hr = S_OK;
                        }

                        // MAR server address list
                        if (FAILED(hr = HrRegQueryColString(hkeyAtmarpc,
                                                           c_szREG_MARServerList,
                                                           &(pAdapter->m_vstrMARServerList))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading MARServerList, hr: %x", hr);
                            hr = S_OK;
                        }

                        // Max Transmit Unit
                        if (FAILED(hr = HrRegQueryDword(hkeyAtmarpc,
                                                       c_szREG_MTU,
                                                       &(pAdapter->m_dwMTU))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading MTU, hr: %x", hr);
                            hr = S_OK;
                        }

                        // PVC Only
                        pAdapter->m_fPVCOnly = FRegQueryBool(hkeyAtmarpc,
                                                       c_szREG_PVCOnly,
                                                       pAdapter->m_fPVCOnly);

                        RegCloseKey(hkeyAtmarpc);
                    }
                }

                (*iterAdapter)->ResetOldValues();

                RegCloseKey(hkeyInterfaceParam);
            }
        }
        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrLoadTcpipRegistry", hr);
    return hr;
}

// Called by CTcpipcfg::HrLoadSettings
// Loads all information under the Services\NetBt\Parameters registry key
//
// const HKEY hkeyWinsParam : Handle to Services\NetBt\Parameters
HRESULT CTcpipcfg::HrLoadWinsRegistry(const HKEY hkeyWinsParam)
{
    HRESULT hr = S_OK;

    // Global parameters

    m_glbGlobalInfo.m_fEnableLmHosts = FRegQueryBool( hkeyWinsParam,
                                            RGAS_ENABLE_LMHOSTS,
                                            m_glbGlobalInfo.m_fEnableLmHosts);

    // Save a copy of these values for non-reboot reconfiguration notification
    m_glbGlobalInfo.m_fOldEnableLmHosts = m_glbGlobalInfo.m_fEnableLmHosts;

    HKEY    hkeyInterfaces;
    hr = HrRegOpenKeyEx(hkeyWinsParam, c_szInterfacesRegKey,
                        KEY_READ, &hkeyInterfaces);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            // $REIVEW (nsun 10/05/98) We don't need to read NetBT settings the WAN adapter
            if (pAdapter->m_fIsWanAdapter)
            {
                continue;
            }

            // Open the NetBt\Interfaces\<Something> to get per
            // adapter NetBt settings
            HKEY hkeyInterfaceParam;
            hr = HrRegOpenKeyEx(hkeyInterfaces,
                                pAdapter->m_strNetBtBindPath.c_str(),
                                KEY_READ, &hkeyInterfaceParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                hr = S_OK;
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadWinsRegistry");
                TraceTag(ttidTcpip, "Interface '%S'", pAdapter->m_strNetBtBindPath.c_str());

                // load wins server address list
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                    RGAS_NETBT_NAMESERVERLIST,
                                                    &(pAdapter->m_vstrWinsServerList))))
                {
                    TraceTag(ttidTcpip, "Failed on loading NameServerList, hr: %x", hr);
                    hr = S_OK;
                }

                // Save a copy in m_strOldWinsServerList
                CopyVstr(&(pAdapter->m_vstrOldWinsServerList),
                         pAdapter->m_vstrWinsServerList);

                // load Netbios options
                if (FAILED(hr = HrRegQueryDword(hkeyInterfaceParam,
                                                RGAS_NETBT_NETBIOSOPTIONS,
                                                &(pAdapter->m_dwNetbiosOptions))))
                {
                    TraceTag(ttidTcpip, "Failed on loading NetbiosOptions, hr: %x", hr);
                    hr = S_OK;
                }

                // Save a copy in m_dwOldNetbiosOptions
                pAdapter->m_dwOldNetbiosOptions = pAdapter->m_dwNetbiosOptions;

                RegCloseKey(hkeyInterfaceParam);
            }
        }
        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrLoadWinsRegistry", hr);
    return hr;
}

// Called by CTcpipcfg::Apply
// This function writes all changes to the registy and makes other
// appropriate changes to the system
HRESULT CTcpipcfg::HrSaveSettings()
{
    HRESULT hr = S_OK;

    HRESULT hrTcpip = S_OK;
    HKEY hkeyTcpipParam = NULL;
    Assert(m_pnccTcpip);

    if (m_pnccTcpip)
    {
        hrTcpip = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);

        // We use hr instead of hrTcpip because this operation is NOT part of
        // HrSaveTcpipRegistry.

        // We must get the list of Added Cards before anything else because
        // otherwise the Adapter GUID keys will be written later and we will
        // not know if they didn't exist in the system before.
        if (SUCCEEDED(hrTcpip))
        {
            hrTcpip = MarkNewlyAddedCards(hkeyTcpipParam);

            if (SUCCEEDED(hrTcpip))
            {
                Assert(hkeyTcpipParam);
                hrTcpip = HrSaveTcpipRegistry(hkeyTcpipParam);
            }
            else
                Assert(!hkeyTcpipParam);
        }
    }

    HRESULT hrWins = S_OK;
    HKEY hkeyWinsParam = NULL;

    Assert(m_pnccWins);

    if (m_pnccWins)
    {
        hrWins = m_pnccWins->OpenParamKey(&hkeyWinsParam);
        if (SUCCEEDED(hrWins))
        {
            Assert(hkeyWinsParam);
            hrWins = HrSaveWinsRegistry(hkeyWinsParam);
        }
        else
            Assert(!hkeyWinsParam);
    }

    HRESULT hrMisc = S_OK;

    //if hrTcpip == E_? then this is possible (thus no Assert)
    // yes because hrTcpip can be set to E_? from HrSaveTcpipRegistry
    if ((hkeyTcpipParam) && (hkeyWinsParam))
    {
        hrMisc = HrSetMisc(hkeyTcpipParam, hkeyWinsParam);
    }

    RegSafeCloseKey(hkeyTcpipParam);
    RegSafeCloseKey(hkeyWinsParam);

    hr = SUCCEEDED(hr) ? hrTcpip : hr;
    hr = SUCCEEDED(hr) ? hrWins : hr;
    hr = SUCCEEDED(hr) ? hrMisc : hr;

    TraceError("CTcpipcfg::HrSaveSettings", hr);
    return hr;
}

// Set global and adapter specific parameters under
// CCS\Services\TCpip\Parameters
// hkeyTcpipParam   handle to reg key HKLM\Systems\CCS\Services\TCpip\Parameters
HRESULT CTcpipcfg::HrSaveTcpipRegistry(const HKEY hkeyTcpipParam)
{
    // hr is the first error occurred,
    // but we don't want to stop at the first error
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    // Save global info

    // DNS host name ( only on installing )
    if (m_fInstalling)
    {
        if (!m_fUpgradeGlobalDnsDomain)
        {
            //  Bug 299038, during install of tcpip, try to get the primary dns domain name
            //  create the global DNS domain as an empty string during clean install if
            //  we couldn't find the primary dns domain name (219090).
            //  if we already got the global Dns Domain when processing the answer file, we should
            //  use the value from the answer file
            tstring strTmpDomain;
            hrTmp = HrRegQueryString(hkeyTcpipParam,
                                    RGAS_DOMAIN,
                                    &strTmpDomain);
            if (FAILED(hrTmp))
            {
                hrTmp = HrGetPrimaryDnsDomain(&strTmpDomain);

                if (SUCCEEDED(hrTmp))
                {
                    if (!SetComputerNameEx(ComputerNamePhysicalDnsDomain,
                                            strTmpDomain.c_str()))
                    {
                        hrTmp = GetLastError();
                        TraceError("CTcpipcfg::HrSaveTcpipRegistry: SetComputerNameEx failed.", hrTmp);
                    }
                }
                else
                {
                    //Bug #335626, some SrvApp directly retrive this value, so we need to create it for
                    //standalone machines
                    strTmpDomain = c_szEmpty;
                }
                
                //SetComputerNameEx() will write to "Domain" reg value after reboot. Per GlennC, it's ok to write
                //the Domain value here to solve the SrvApp compatibility issue.
                HrRegSetString(hkeyTcpipParam,
                                   RGAS_DOMAIN,
                                   strTmpDomain);
            }

            //the hrTmp get from this section should not affect the
            //final return value
        }


        //
        //  391590: We've saved the hostname from NT4 into the answerfile so that
        //          we can remember the exact (case-sensitive) string.  If the
        //          saved DNS hostname is the same (except for case) as the current
        //          COMPUTERNAME, we set the NT5 DNS hostname to be the saved one,
        //          for SAP compatibility (they make case-sensitive comparisons).
        //          Otherwise, we use the regular COMPUTERNAME, lowercased, as the
        //          DNS hostname.
        //
        if (!lstrcmpiW(m_glbGlobalInfo.m_strHostName.c_str(),
                       m_glbGlobalInfo.m_strHostNameFromAnswerFile.c_str()))
        {
            hrTmp = HrRegSetString(hkeyTcpipParam,
                                   RGAS_HOSTNAME,
                                   m_glbGlobalInfo.m_strHostNameFromAnswerFile);
            if (S_OK == hrTmp)
            {
                hrTmp = HrRegSetString(hkeyTcpipParam,
                                       RGAS_NVHOSTNAME,
                                       m_glbGlobalInfo.m_strHostNameFromAnswerFile);
            }
        }
        else
        {
            hrTmp = HrRegSetString(hkeyTcpipParam,
                                   RGAS_HOSTNAME,
                                   m_glbGlobalInfo.m_strHostName);
            if (S_OK == hrTmp)
            {
                hrTmp = HrRegSetString(hkeyTcpipParam,
                                       RGAS_NVHOSTNAME,
                                       m_glbGlobalInfo.m_strHostName);
            }
        }

        TraceError("CTcpipcfg::HrSaveTcpipRegistry: Failed to set HostName.", hrTmp);

        //the hrTmp get from this section should not affect the
        //final return value
    }

    // Added per request from Stuart Kwan:
    // only when the global DNS domain is read from answerfile
    if (m_fUpgradeGlobalDnsDomain)
    {
        if (!SetComputerNameEx(ComputerNamePhysicalDnsDomain,
                                m_strUpgradeGlobalDnsDomain.c_str()))
        {
            hrTmp = GetLastError();
            TraceError("CTcpipcfg::HrSaveTcpipRegistry: SetComputerNameEx failed.", hrTmp);
        }

        //If the registry value Services\Tcpip\Parameters\SyncDomainWithMembership != 0,
        //Netlogon will try to overwirte the value with the member domain name when joining
        //into the domain. (See NT bug 310143
        //
        //Due to bug WinSE 7317, most users don't want us to manually set SyncDomainWithMembership
        //reg value as 0 here.
        //
        //As a workaround in order to upgarde the gloabl Dns domain name, the user has to 
        //add SyncDomainWithMembership reg value under tcpip parameters and make it as 0.
        //In the unattended install case, there needs to be a line
        //   SyncDomainWithMembership=0
        //in the global tcpip parameters section if the user want to specify a global DNS
        //domain name that is different with the membership domain name.

        
        //the hrTmp get from this section should not affect the
        //final return value
    }

    // Dns suffix list
    tstring strSearchList;
    ConvertColStringToString(m_glbGlobalInfo.m_vstrDnsSuffixList,
                             c_chListSeparator,
                             strSearchList);

    hrTmp = HrRegSetString(hkeyTcpipParam,
                           RGAS_SEARCHLIST,
                           strSearchList);

    if (SUCCEEDED(hr))
        hr = hrTmp;

    // UseDomainNameDevolution
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szUseDomainNameDevolution,
                          m_glbGlobalInfo.m_fUseDomainNameDevolution);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    // IpEnableRouter
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szIpEnableRouter,
                          m_glbGlobalInfo.m_fEnableRouter);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    //(nsun 11/02/98) parameters of RRAS for unattended install
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szEnableICMPRedirect,
                          m_glbGlobalInfo.m_fEnableIcmpRedirect);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szDeadGWDetectDefault,
                          m_glbGlobalInfo.m_fDeadGWDetectDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szDontAddDefaultGatewayDefault,
                          m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          RGAS_SECURITY_ENABLE,
                          m_glbGlobalInfo.m_fEnableFiltering);
    if (SUCCEEDED(hr))
        hr = hrTmp;


    // Adapter specific info (physical cards)
    HKEY    hkeyAdapters = NULL;
    DWORD   dwDisposition;

    // Create or open the "Adapters" key under "Services\Tcpip\Parameters"
    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, c_szAdaptersRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                             &hkeyAdapters, &dwDisposition);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyAdapters);
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            // No need to do this for RAS fake adapters
            if (pAdapter->m_fIsRasFakeAdapter)
            {
                continue;
            }


            // Create specific card bindname key under
            // "Services\Tcpip\Parameters\Adapters\<card bind name>"
            //
            HKEY hkeyAdapterParam;
            hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                     pAdapter->m_strBindName.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                     &hkeyAdapterParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyAdapterParam);

                // Set LLInterface and IpConfig for new cards
                //
                if (pAdapter->m_fNewlyChanged)
                {
                    PCWSTR pszArpModule = c_szEmpty;

                    if (pAdapter->m_fIsWanAdapter)
                    {
                        pszArpModule = c_szWanArp;
                    }
                    else if (pAdapter->m_fIsAtmAdapter)
                    {
                        pszArpModule = c_szAtmArp;
                    }
                #if ENABLE_1394
                    else if (pAdapter->m_fIs1394Adapter)
                    {
                        pszArpModule = c_sz1394Arp;
                    }
                #endif // ENABLE_1394

                    hrTmp = HrRegSetSz(hkeyAdapterParam,
                                       RGAS_LLINTERFACE,
                                       pszArpModule);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // (08/18/98 nsun) modified to support multiple interfaces of WAN adapter
                    VSTR vstrIpConfig;

                    if (!pAdapter->m_fIsMultipleIfaceMode)
                    {
                        HrRegDeleteValue(hkeyAdapterParam, RGAS_NUMINTERFACES);

                        tstring* pstr = new tstring(RGAS_TCPIP_PARAM_INTERFACES);

                        if (pstr == NULL)
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pstr->append(pAdapter->m_strTcpipBindPath);
                        vstrIpConfig.push_back(pstr);

                        hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              RGAS_IPCONFIG,
                                              vstrIpConfig);
                    }
                    else
                    {
                        AssertSz(pAdapter->m_fIsWanAdapter, "The card is not WAN adapter, but how can it support multiple interface.");

                        tstring strInterfaceName;
                        IFACEITER iterId;

                        for(iterId  = pAdapter->m_IfaceIds.begin();
                            iterId != pAdapter->m_IfaceIds.end();
                            iterId++)
                        {
                            GetInterfaceName(
                                    pAdapter->m_strTcpipBindPath.c_str(),
                                    *iterId,
                                    &strInterfaceName);

                            tstring* pstr = new tstring(RGAS_TCPIP_PARAM_INTERFACES);
                            pstr->append(strInterfaceName);

                            vstrIpConfig.push_back(pstr);
                        }

                        hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              RGAS_IPCONFIG,
                                              vstrIpConfig);

                        if (SUCCEEDED(hr))
                            hr = hrTmp;

                        //$REVIEW (nsun 09/15/98) use NumInterfaces value to identify if the adapter is in the
                        //mode of supporting multiple interfaces. If the NumInterfaces
                        //exists, the adapter supports multiple interfaces.
                        //If NumInterfaces == 0, it means the adapter supports multiple interfaces
                        // but no interface is associated with it. So the IpInterfaces should not
                        // exists. The NumInterfaces and IpInterfaces should alwasy be consistent.

                        DWORD   dwNumInterfaces = pAdapter->m_IfaceIds.size();
                        hrTmp = HrRegSetDword(hkeyAdapterParam,
                                              RGAS_NUMINTERFACES,
                                              dwNumInterfaces);

                        if (SUCCEEDED(hr))
                            hr = hrTmp;

                        if ( 0 != dwNumInterfaces )
                        {
                            GUID* aguid;
                            DWORD cguid;
                            hrTmp = GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
                                        pAdapter->m_IfaceIds,
                                        &aguid,
                                        &cguid);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            Assert(aguid);
                            hrTmp = HrRegSetBinary(hkeyAdapterParam,
                                              RGAS_IPINTERFACES,
                                              (BYTE*) aguid,
                                              cguid * sizeof(GUID));
                            CoTaskMemFree(aguid);
                        }
                        else
                        {
                            hrTmp = HrRegDeleteValue(hkeyAdapterParam, RGAS_IPINTERFACES);

                            //It's fine that the IpInterfaces does not exist at all if
                            // the WAN adapter does not support multiple interfaces.
                            if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                                hrTmp = S_OK;
                        }

                    }

                    FreeCollectionAndItem(vstrIpConfig);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                RegCloseKey(hkeyAdapterParam);
            }
        }

        RegCloseKey(hkeyAdapters);
    }

    // Create or open the "Interfaces" key under "Services\Tcpip\Parameters"
    //
    HKEY    hkeyInterfaces;
    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, c_szInterfacesRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                             &hkeyInterfaces, &dwDisposition);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyInterfaces);
        for(VCARD::iterator iterAdapter =  m_vcardAdapterInfo.begin();
            iterAdapter !=  m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            if ((*iterAdapter)->m_fIsRasFakeAdapter)
            {
                continue;
            }

            ADAPTER_INFO * pAdapter = *iterAdapter;

            //(08/20/98 nsun) modified to support multiple interfaces of WAN adapter
            // NULL != pAdapter->m_IfaceIds means it's in multiple interface mode
            if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
            {
                if (pAdapter->m_fNewlyChanged)
                {
                    HrSaveMultipleInterfaceWanRegistry(hkeyInterfaces, pAdapter);
                }
                continue;
            }

            // Create specific card interface key under
            // "Services\Tcpip\Parameters\Interfaces\<card bind path>"
            //
            HKEY hkeyInterfaceParam;
            hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                     pAdapter->m_strTcpipBindPath.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                     &hkeyInterfaceParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyInterfaceParam);

                if (pAdapter->m_fNewlyChanged)
                {
                    //Bug306259 If UseZeroBroadCast already exists (which means it is from the answer
                    // file), we should not overwrite it with the default value.
                    DWORD dwTmp;
                    hrTmp = HrRegQueryDword(hkeyInterfaceParam,
                                             RGAS_USEZEROBROADCAST,
                                             &dwTmp);
                    if (FAILED(hrTmp))
                    {
                        // ZeroBroadcast
                        hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                              RGAS_USEZEROBROADCAST,
                                              0);
                        if (SUCCEEDED(hr))
                            hr = hrTmp;
                    }

                    if (pAdapter->m_fIsWanAdapter)
                    {   // For new RAS cards
                        hrTmp = HrSaveStaticWanRegistry(hkeyInterfaceParam);
                    }
                    else if (pAdapter->m_fIsAtmAdapter)
                    {
                        // For new ATM cards
                        hrTmp = HrSaveStaticAtmRegistry(hkeyInterfaceParam);
                    }
                #if ENABLE_1394
                    else if (pAdapter->m_fIs1394Adapter)
                    {
                        // For new NIC1394 cards
                        // (nothing to do).
                        hrTmp = S_OK;
                    }
                #endif // ENABLE_1394
                    else
                    {
                        //(nsun 11/02/98) set static RRAS parameters for unattended install

                        //if the values exists, that means they have been set as an unconfigurable 
                        //parameter during upgrade,
                        //we should not set the default value.

                        DWORD   dwTmp;

                        hrTmp = HrRegQueryDword(hkeyInterfaceParam,
                                                c_szDeadGWDetect,
                                                &dwTmp);
                        
                        if (FAILED(hrTmp))
                        {
                            hrTmp = HrRegSetBool(hkeyInterfaceParam,
                                              c_szDeadGWDetect,
                                              m_glbGlobalInfo.m_fDeadGWDetectDefault);
                        }
                    }

                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                // For LAN cards and RAS fake guids
                if (!pAdapter->m_fIsWanAdapter)
                {
                    // Ip address etc
                    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                                          RGAS_ENABLE_DHCP,
                                          pAdapter->m_fEnableDhcp);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    //warning: these VSTRs will contain pointers to strings
                    //that are either local to this function or
                    //that are also pointed to in another VSTR
                    // DO NOT call FreeCollectionAndItem on them!
                    VSTR vstrIpAddresses;
                    VSTR vstrSubnetMask;
                    tstring ZeroAddress(ZERO_ADDRESS);

                    if (pAdapter->m_fEnableDhcp)
                    {
                        vstrIpAddresses.push_back(&ZeroAddress);
                        vstrSubnetMask.push_back(&ZeroAddress);
                    }
                    else
                    {
                        vstrIpAddresses = pAdapter->m_vstrIpAddresses;
                        vstrSubnetMask  = pAdapter->m_vstrSubnetMask;
                    }

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_IPADDRESS,
                                              vstrIpAddresses);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_SUBNETMASK,
                                              vstrSubnetMask);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_DEFAULTGATEWAY,
                                              pAdapter->m_vstrDefaultGateway);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                      RGAS_DEFAULTGATEWAYMETRIC,
                                      pAdapter->m_vstrDefaultGatewayMetric);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // DNS name server list
                    tstring strNameServer;
                    ConvertColStringToString(pAdapter->m_vstrDnsServerList,
                                             c_chListSeparator,
                                             strNameServer);

                    hrTmp = HrRegSetString(hkeyInterfaceParam,
                                           RGAS_NAMESERVER,
                                           strNameServer);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // DNS domain
                    hrTmp = HrRegSetString(hkeyInterfaceParam,
                                           RGAS_DOMAIN,
                                           pAdapter->m_strDnsDomain);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // Dns ip address dynamic update
                    if (pAdapter->m_fDisableDynamicUpdate)
                    {
                        DnsDisableDynamicRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }
                    else
                    {
                        DnsEnableDynamicRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }

                    // adapter Dns domain name registration
                    if (pAdapter->m_fEnableNameRegistration)
                    {
                        DnsEnableAdapterDomainNameRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }
                    else
                    {
                        DnsDisableAdapterDomainNameRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }

                    // InterfaceMetric
                    if (c_dwDefaultIfMetric != pAdapter->m_dwInterfaceMetric)
                    {
                        hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                          c_szInterfaceMetric,
                                          pAdapter->m_dwInterfaceMetric);
                    }
                    else
                    {
                        //The interface metric is default, remove that value.
                        //In such way, it would be much easier to upgrade if the default is changed
                        //in the future
                        hrTmp = HrRegDeleteValue(hkeyInterfaceParam,
                                          c_szInterfaceMetric);

                        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
                            hrTmp = S_OK;
                    }
                    
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // TCPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_TCP,
                                              pAdapter->m_vstrTcpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // UDPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_UDP,
                                              pAdapter->m_vstrUdpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // IPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_IP,
                                              pAdapter->m_vstrIpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // For ATM cards only
                    if (pAdapter->m_fIsAtmAdapter)
                    {
                        HKEY hkeyAtmarpc;

                        // Open the Atmarpc subkey
                        hrTmp = HrRegCreateKeyEx(hkeyInterfaceParam,
                                                 c_szAtmarpc,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_READ_WRITE,
                                                 NULL,
                                                 &hkeyAtmarpc,
                                                 &dwDisposition);

                        if (SUCCEEDED(hrTmp))
                        {
                            hrTmp = HrRegSetColString(hkeyAtmarpc,
                                                     c_szREG_ARPServerList,
                                                     pAdapter->m_vstrARPServerList);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetColString(hkeyAtmarpc,
                                                     c_szREG_MARServerList,
                                                     pAdapter->m_vstrMARServerList);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetDword(hkeyAtmarpc,
                                                  c_szREG_MTU,
                                                  pAdapter->m_dwMTU);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetBool(hkeyAtmarpc,
                                                  c_szREG_PVCOnly,
                                                  pAdapter->m_fPVCOnly);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            RegCloseKey(hkeyAtmarpc);
                        }
                    }

                    hrTmp = HrDuplicateToNT4Location(hkeyInterfaceParam,
                                             pAdapter);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrSaveBackupTcpSettings(hkeyInterfaceParam, 
                                            pAdapter);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                } // For LAN cards and RAS fake guids only

                RegCloseKey(hkeyInterfaceParam);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}

HRESULT CTcpipcfg::HrSaveWinsRegistry(const HKEY hkeyWinsParam)
{
    // hr is the first error occurred,
    // but we don't want to stop at the first error
    HRESULT         hr = S_OK;
    HRESULT         hrTmp = S_OK;

    // Global parameters
    hrTmp = HrRegSetBool(hkeyWinsParam,
                          RGAS_ENABLE_LMHOSTS,
                          m_glbGlobalInfo.m_fEnableLmHosts);
    if (SUCCEEDED(hr))
        hr = hrTmp;
/*$REVIEW (nsun 2/17/98) Bug #293643 We don't want to change any unconfigurable values

    // $REVIEW(tongl 8/3/97): Added NodeType settings #97364.
    // If no adapter has static WINS address, then remove NodeType.
    // otherwise, the user has specified the WINs server address for
    // at least one adapters, set NodeType = 0x08 (H-NODE)
    BOOL fNoWinsAddress = TRUE;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO * pAdapter = *iterAdapter;

        if ((!pAdapter->m_fIsWanAdapter)&&
            (BINDING_ENABLE == pAdapter->m_BindingState)&&
            (pAdapter->m_vstrWinsServerList.size()>0))
        {
            fNoWinsAddress = FALSE;
        }
    }


    DWORD dwNodeType;
    hrTmp = HrRegQueryDword(hkeyWinsParam,
                            c_szNodeType,
                            &dwNodeType);
    // dwNodeType ==0 means the key did not exist before we apply
    if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        dwNodeType =0;

    if (!m_fAnswerFileBasedInstall ||
        (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
    {
        if (!fNoWinsAddress) // set NodeType to 0x08
        {
            if (dwNodeType != c_dwHNode)
            {
                hrTmp = HrRegSetDword(hkeyWinsParam,
                                      c_szNodeType,
                                      c_dwHNode);
                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
        else // remove NodeType key
        {
            if (dwNodeType != 0)
            {
                hrTmp = HrRegDeleteValue(hkeyWinsParam,
                                         c_szNodeType);

                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
    }
*/
    // $REVIEW(tongl 12\1\97): Per agreement with Malam today(see email),
    // NetBt will re-read NodeType when notified of wins address list change.
    // Thus no need to notify change separately below.
    /*
    if (fNodeTypeChanged)
    {
        // Send notification to NetBt
        TraceTag(ttidTcpip,"NodeType parameter changed, send notification on apply.");
        SetReconfig();
        // SetReconfigNbt();
    }
    */

    // Adapter interface specific parameters
    // Create the "Services\NetBt\Interfacess" key
    HKEY    hkeyInterfaces;
    DWORD   dwDisposition;
    hrTmp = HrRegCreateKeyEx(hkeyWinsParam, c_szInterfacesRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                             &hkeyInterfaces, &dwDisposition);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            //(10/05/98 nsun) modified to support multiple interfaces of WAN adapter
            // NULL != pAdapter->m_IfaceIds means it's in multiple interface mode
            if (pAdapter->m_fNewlyChanged &&
                pAdapter->m_fIsWanAdapter &&
                pAdapter->m_fIsMultipleIfaceMode)
            {
                HrSaveWinsMultipleInterfaceWanRegistry(hkeyInterfaces, pAdapter);
                continue;
            }

            HKEY hkeyInterfaceParam;
            hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                     pAdapter->m_strNetBtBindPath.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                     &hkeyInterfaceParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                // For new RAS cards, only set static values
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fNewlyChanged)
                {
                    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                                            RGAS_NETBT_NAMESERVERLIST,
                                            L"\0");
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }
                else // if not RAS adapter
                {
                    // set wins server address list
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                             RGAS_NETBT_NAMESERVERLIST,
                                             pAdapter->m_vstrWinsServerList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // set NetbiosOptions
                    hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                          RGAS_NETBT_NETBIOSOPTIONS,
                                          pAdapter->m_dwNetbiosOptions);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                RegCloseKey(hkeyInterfaceParam);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrSaveWinsRegistry", hr);
    return hr;
}


// Called by CTcpipcfg::SaveSettings
// Does a lot of miscelaneous actions when Apply is called
// Including cleaning up registry and remove isolated cards
//
// HKEY hkeyTcpipParam           Serviess\Tcpip\Parameters
// HKEY hkeyWinsParam            Services\NetBt\Parameters

HRESULT CTcpipcfg::HrSetMisc(const HKEY hkeyTcpipParam, const HKEY hkeyWinsParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    // Registry Cleanup !!

    // We remove DNS domain and DNS server list in NT5 upgrades
    if (m_fUpgradeCleanupDnsKey)
    {
        hrTmp = HrRegDeleteValue(hkeyTcpipParam, RGAS_NAMESERVER);

        // $REVIEW(tongl 3/22/98): Per Stuart Kwan, global DNSDomain key
        // is also used.
        // hrTmp = HrRegDeleteValue(hkeyTcpipParam, RGAS_DOMAIN);
    }

    // remove all keys under the "Services\Tcpip\Parameters\Adapters" reg key
    // that aren't in the list of net cards.
    VSTR vstrNetCardsInTcpipReg;
    HKEY hkeyAdapters = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyTcpipParam, c_szAdaptersRegKey, KEY_READ,
                        &hkeyAdapters);

    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters,
                                          &vstrNetCardsInTcpipReg);
    }
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hr) && vstrNetCardsInTcpipReg.size() > 0)
    {
        // Step through the names of all the registry keys found
        //
        for (VSTR_CONST_ITER iter = vstrNetCardsInTcpipReg.begin();
             iter != vstrNetCardsInTcpipReg.end();
             ++iter)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            //
            BOOL fFound = FALSE;

            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                if (lstrcmpiW(pAdapter->m_strBindName.c_str(), (**iter).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound)
            {
                // if it wasn't in the list of installed adapters
                // then delete it
                //
                if (SUCCEEDED(hrTmp))
                    hrTmp = HrRegDeleteKeyTree(hkeyAdapters, (*iter)->c_str());

                //maybe the key is not there. so we don't check whether this will fail.
                HrDeleteBackupSettingsInDhcp((*iter)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;

            }
        }
    }
    FreeCollectionAndItem(vstrNetCardsInTcpipReg);
    RegSafeCloseKey(hkeyAdapters);

    //we also need to delete the duplicate reg values under Services\{adapter GUID}
    HRESULT hrNt4 = S_OK;
    HKEY    hkeyServices = NULL;
    DWORD   dwDisposition;

    hrNt4 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                            KEY_READ, &hkeyServices);

    if (FAILED(hrNt4))
    {
        TraceTag(ttidTcpip, "HrSetMisc: Failed to open the Services reg key, hr: %x", hr);
    }


    // We remove all keys under the "Services\Tcpip\Parameters\Interfaces" reg key
    // that aren't in our list of net cards.
    VSTR vstrNetCardInterfacesInTcpipReg;

    // Get a list of all keys under the "Services\Tcpip\Parameters\Interfaces" key
    HKEY hkeyInterfaces = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyTcpipParam, c_szInterfacesRegKey, KEY_READ_WRITE_DELETE,
                        &hkeyInterfaces);

    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrLoadSubkeysFromRegistry(hkeyInterfaces,
                                          &vstrNetCardInterfacesInTcpipReg);
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp) && vstrNetCardInterfacesInTcpipReg.size() > 0 )
    {
        // step through the names of all the registry keys found
        for (VSTR_CONST_ITER iterTcpipReg = vstrNetCardInterfacesInTcpipReg.begin() ;
                iterTcpipReg != vstrNetCardInterfacesInTcpipReg.end() ; ++iterTcpipReg)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            BOOL fFound = FALSE;

            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                //(08/18/98 nsun) special case for WAN adapters with multiple interfaces
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
                {
                    IFACEITER   iterId;
                    tstring     strInterfaceName;

                    for(iterId  = pAdapter->m_IfaceIds.begin();
                        iterId != pAdapter->m_IfaceIds.end();
                        iterId++)
                    {
                        GetInterfaceName(
                                pAdapter->m_strTcpipBindPath.c_str(),
                                *iterId,
                                &strInterfaceName);

                        if (lstrcmpiW(strInterfaceName.c_str(), (**iterTcpipReg).c_str()) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (fFound)
                        break;
                }
                else if (lstrcmpiW(pAdapter->m_strTcpipBindPath.c_str(), (**iterTcpipReg).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            // if it wasn't in the list of installed adapters then delete it
            if (!fFound)
            {
                // remove the key
                if (SUCCEEDED(hrTmp))
                    hrTmp = HrRegDeleteKeyTree(hkeyInterfaces, (*iterTcpipReg)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrNt4))
                {
                    hrTmp = HrRegDeleteKeyTree(hkeyServices, (*iterTcpipReg)->c_str());
                    if (FAILED(hrTmp))
                    {
                        TraceTag(ttidTcpip, "CTcpipcfg::SetMisc");
                        TraceTag(ttidTcpip, "Failed on deleting duplicated Nt4 layout key: Services\\%S, hr: %x",
                                 (*iterTcpipReg)->c_str(), hrTmp);
                        hrTmp = S_OK;
                    }
                }
            }
        }
    }
    RegSafeCloseKey(hkeyInterfaces);
    RegSafeCloseKey(hkeyServices);
    FreeCollectionAndItem(vstrNetCardInterfacesInTcpipReg);

    // Now we remove all keys under the "SERVICES\NetBt\Parameters\Interfaces" reg key
    // that aren't in our list of net cards.

    VSTR vstrNetCardInterfacesInWinsReg;

    // Get a list of all keys under the "Services\NetBt\Parameters\Interfaces" key
    HKEY hkeyWinsInterfaces = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyWinsParam, c_szInterfacesRegKey, KEY_READ,
                           &hkeyWinsInterfaces);

    // Get a list of all keys under the "SERVICES\NetBt\Parameters\Interfaces" key
    hrTmp = HrLoadSubkeysFromRegistry( hkeyWinsInterfaces,
                                        &vstrNetCardInterfacesInWinsReg);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp) && vstrNetCardInterfacesInWinsReg.size()>0 )
    {
        // Step through the names of all the registry keys found
        for (VSTR_CONST_ITER iterWinsReg = vstrNetCardInterfacesInWinsReg.begin() ;
             iterWinsReg != vstrNetCardInterfacesInWinsReg.end() ; ++iterWinsReg)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            BOOL fFound = FALSE;

            // All net cards
            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                //(10/05/98 nsun) special case for WAN adapters with multiple interfaces
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
                {
                    IFACEITER   iterId;
                    tstring     strNetBtBindPath;

                    for (iterId  = pAdapter->m_IfaceIds.begin();
                         iterId != pAdapter->m_IfaceIds.end();
                         iterId++)
                    {
                        GetInterfaceName(
                                pAdapter->m_strNetBtBindPath.c_str(),
                                *iterId,
                                &strNetBtBindPath);

                        strNetBtBindPath.insert(0, c_szTcpip_);

                        if (lstrcmpiW(strNetBtBindPath.c_str(), (**iterWinsReg).c_str()) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (fFound)
                        break;
                }
                else if (lstrcmpiW(pAdapter->m_strNetBtBindPath.c_str(), (**iterWinsReg).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            // if it wasn't in the list of installed adapters then delete it
            if (!fFound)
            {
                hrTmp = HrRegDeleteKeyTree(hkeyWinsInterfaces, (*iterWinsReg)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
    }
    FreeCollectionAndItem(vstrNetCardInterfacesInWinsReg);
    RegSafeCloseKey(hkeyWinsInterfaces);

    TraceError("CTcpipcfg::HrSetMisc", hr);
    return hr;
}

// CTcpipcfg::HrGetDhcpOptions
//
// Gets the list of netcard dependend and netcard independent
// values to delete when DHCP is disabled. This list is obtained from:
// "Services\DHCP\Parameters\Options\#\RegLocation"
//
// GlobalOptions           returns the non-netcard specific reg keys
// PerAdapterOptions       returns the netcard specific reg keys

HRESULT CTcpipcfg::HrGetDhcpOptions(OUT VSTR * const GlobalOptions,
                                    OUT VSTR * const PerAdapterOptions)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HKEY hkeyDhcpOptions;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        RGAS_DHCP_OPTIONS,
                        KEY_ENUMERATE_SUB_KEYS,
                        &hkeyDhcpOptions);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        hr = S_OK;

    else if (SUCCEEDED(hr))
    {
        WCHAR szBuf[256];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;

        while(SUCCEEDED(hrTmp = HrRegEnumKeyEx(hkeyDhcpOptions,
                                               dwRegIndex++,
                                               szBuf, &dwSize,
                                               NULL, NULL, &time)))
        {
            dwSize = celems(szBuf);

            HKEY hkeyRegLocation;
            hrTmp = HrRegOpenKeyEx(hkeyDhcpOptions, szBuf,
                                   KEY_QUERY_VALUE,
                                   &hkeyRegLocation);

            if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                hrTmp = S_OK;

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (hkeyRegLocation)
            {
                tstring strRegLocation;
                hrTmp = HrRegQueryString(hkeyRegLocation,
                                         RGAS_REG_LOCATION,
                                         &strRegLocation);

                if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    hrTmp = S_OK;

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrTmp))
                {
                    if (strRegLocation.find(TCH_QUESTION_MARK) == tstring::npos)
                    {
                        GlobalOptions->push_back(new tstring(strRegLocation));
                    }
                    else
                    {
                        PerAdapterOptions->push_back(new tstring(strRegLocation));
                    }
                }

                RegCloseKey(hkeyRegLocation);
            }
        }

        if (hrTmp == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            hrTmp = S_OK;

        if (SUCCEEDED(hr))
            hr = hrTmp;

        RegCloseKey(hkeyDhcpOptions);
    }

    // Add default PerAdapterOption
    // $REVIEW(tongl 5/11): This is directly from ncpa1.1
    // What about DhcpNameServer under NetBt ??

    //"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpIPAddress"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_IPADDRESS));

    //"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpSubnetMask"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_SUBNETMASK));

    //"System\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\?\\DhcpNameServerBackup"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_NAMESERVERBACKUP));

    TraceError("HrGetDhcpOptions", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigIp
//
//  Purpose:    Notify Tcpip of configuration changes
//
//  Arguments:  INetCfgPnpReconfigCallback* pICallback  
//                  the call back interface to handle Ndis Pnp reconfig
//
//  Returns:    HRESULT, S_OK on success, NETCFG_S_REBOOT otherwise
//

HRESULT CTcpipcfg::HrReconfigIp(INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;
    HRESULT hrReconfig = S_OK;

    
    //$$REVIEW bug 329542, we remove the Pnp notification on "EnableSecurityFilters".
    //And then global PnP notification to tcp stack is not needed at all.
    if (m_glbGlobalInfo.m_fEnableFiltering != m_glbGlobalInfo.m_fOldEnableFiltering)
    {
        hr = NETCFG_S_REBOOT;
    }
    


    IP_PNP_RECONFIG_REQUEST IpReconfigRequest;

    ZeroMemory(&IpReconfigRequest, sizeof(IpReconfigRequest));

    // DWORD version
    IpReconfigRequest.version = IP_PNP_RECONFIG_VERSION;
    IpReconfigRequest.arpConfigOffset = 0;

    //we are only interested in gateway and interface metric, because other
    //parameters cannot be changed from the UI
    IpReconfigRequest.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE | 
                              IP_PNP_FLAG_INTERFACE_METRIC_UPDATE ;


    // Submit per adapter reconfig notifications
    // gatewayListUpdate, filterListUpdate
    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter ++) // for each adapter
    {

        ADAPTER_INFO * pAdapter = *iterAdapter;

        // If not wan adapter or RAS fake guid, and adapter is enabled
        if ((!pAdapter->m_fIsWanAdapter) &&
            (!pAdapter->m_fIsRasFakeAdapter) &&
            (pAdapter->m_BindingState == BINDING_ENABLE) &&
            (pAdapter->m_InitialBindingState != BINDING_DISABLE))
        {
            // gateway list
            IpReconfigRequest.gatewayListUpdate =
                !fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                             pAdapter->m_vstrOldDefaultGateway) ||
                !fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                             pAdapter->m_vstrOldDefaultGatewayMetric);

            IpReconfigRequest.InterfaceMetricUpdate =
                !!(pAdapter->m_dwInterfaceMetric !=
                   pAdapter->m_dwOldInterfaceMetric);

            if ((IpReconfigRequest.gatewayListUpdate) ||
                (IpReconfigRequest.InterfaceMetricUpdate))
            {
                TraceTag(ttidTcpip, "Sending notification to Tcpip about parameter changes for adapter %S.", pAdapter->m_strBindName.c_str());
                TraceTag(ttidTcpip, "Gateway list update: %d", IpReconfigRequest.gatewayListUpdate);
                TraceTag(ttidTcpip, "Interface metric update: %d", IpReconfigRequest.InterfaceMetricUpdate);

                hrReconfig  = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                                                    pAdapter->m_strTcpipBindPath.c_str(),
                                                    &IpReconfigRequest,
                                                    sizeof(IP_PNP_RECONFIG_REQUEST));

                //we dont want to request reboot if the error is ERROR_FILE_NOT_FOUND
                //because that means the card is not loaded by the stack yet. Usually this is 
                //because the card was disabled from the connection UI. When the card is re-enabled,
                //the statck will reload the card and load all settings from the registry. So a reboot
                //is not needed
                if (FAILED(hrReconfig) && 
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrReconfig)
                {
                    TraceTag(ttidTcpip,"Notifying tcpip of adapter specific parameter change returns failure, prompt for reboot ...");
                    hr = NETCFG_S_REBOOT;
                }
            }

            // if ATM adapter, notify atmarp if any parameter has changed
            if (pAdapter->m_fIsAtmAdapter)
            {
                hrReconfig = HrReconfigAtmArp(pAdapter, pICallback);

                
                if (hrReconfig != S_OK)
                {
                    TraceTag(ttidTcpip,"Notifying tcpip of ATM ARP cleint of parameter change returns failure, prompt for reboot ...");
                    hr = NETCFG_S_REBOOT;
                }
            }
        #if ENABLE_1394
            else if (pAdapter->m_fIs1394Adapter)
            {
                // $REVIEW JosephJ: I don't think we need to do
                // anything here, because we have no parameters to
                // change.
            }
        #endif // ENABLE_1394

            // ask for reboot if filter list has changed
            if (m_glbGlobalInfo.m_fEnableFiltering)
            {
                if (!fIsSameVstr(pAdapter->m_vstrTcpFilterList, pAdapter->m_vstrOldTcpFilterList) ||
                    !fIsSameVstr(pAdapter->m_vstrUdpFilterList, pAdapter->m_vstrOldUdpFilterList) ||
                    !fIsSameVstr(pAdapter->m_vstrIpFilterList,  pAdapter->m_vstrOldIpFilterList))
                {
                    TraceTag(ttidTcpip, "This is temporary, filter list changed, ask for reboot");
                    hr = NETCFG_S_REBOOT;
                }
            }
        }

        // Send Wanarp reconfig notification if necessary
        //
        else if (pAdapter->m_fIsWanAdapter && pAdapter->m_fNewlyChanged)
        {
            if (FAILED(HrReconfigWanarp(pAdapter, pICallback)))
            {
                TraceTag(ttidTcpip, "Wanarp failed its reconfig.  Need to reboot.");
                hr = NETCFG_S_REBOOT;
            }
        }
    }

    TraceError("CTcpipcfg::HrReconfigIp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrReconfigAtmArp
//
//  Purpose:    Notify ATM ARP of configuration changes
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT if failure
//
HRESULT CTcpipcfg::HrReconfigAtmArp(ADAPTER_INFO *pAdapterInfo,
                                    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;

    // check if any parameter has changed
    DWORD dwFlag = 0;

    // arp server list
    if (!fIsSameVstr(pAdapterInfo->m_vstrARPServerList,
                     pAdapterInfo->m_vstrOldARPServerList))
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_ARPS_LIST_CHANGED;
    }

    // mar server list
    if (!fIsSameVstr(pAdapterInfo->m_vstrMARServerList,
                     pAdapterInfo->m_vstrOldMARServerList))
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_MARS_LIST_CHANGED;
    }

    // MTU
    if (pAdapterInfo->m_dwMTU != pAdapterInfo->m_dwOldMTU)
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_MTU_CHANGED;
    }

    // PVC Only
    if (pAdapterInfo->m_fPVCOnly != pAdapterInfo->m_fOldPVCOnly)
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_PVC_MODE_CHANGED;
    }

    if (dwFlag) // yep, some parameter has changed
    {

        tstring strIpConfigString = RGAS_TCPIP_PARAM_INTERFACES;
        strIpConfigString += pAdapterInfo->m_strTcpipBindPath;

        DWORD dwBytes = sizeof(IP_PNP_RECONFIG_REQUEST) +
                        sizeof(ATMARPC_PNP_RECONFIG_REQUEST) +
                        sizeof(USHORT) +
                        sizeof(WCHAR)*(strIpConfigString.length() + 1);

        PVOID pvBuf;
        hr = HrMalloc (dwBytes, &pvBuf);
        if (SUCCEEDED(hr))
        {
            BYTE* pbByte = reinterpret_cast<BYTE*>(pvBuf);

            // 1) fillup ip reconfig structure
            IP_PNP_RECONFIG_REQUEST * pIpReconfig =
                    reinterpret_cast<IP_PNP_RECONFIG_REQUEST *>(pbByte);

            pIpReconfig->version =1;
            // set valid offset
            pIpReconfig->arpConfigOffset = sizeof(IP_PNP_RECONFIG_REQUEST);

            // set rest to default
            // pIpReconfig->securityEnabled =0;
            // pIpReconfig->filterListUpdate =0;
            pIpReconfig->gatewayListUpdate =0;
            pIpReconfig->IPEnableRouter =0;

            // 2) fill up atmarp reconfig structure
            pbByte += sizeof(IP_PNP_RECONFIG_REQUEST);

            ATMARPC_PNP_RECONFIG_REQUEST * pAtmarpcReconfig =
                    reinterpret_cast<ATMARPC_PNP_RECONFIG_REQUEST *>(pbByte);

            pAtmarpcReconfig->Version = ATMARPC_RECONFIG_VERSION;
                pAtmarpcReconfig->OpType = ATMARPC_RECONFIG_OP_MOD_INTERFACE;

            // now set specifically what has changed
            pAtmarpcReconfig->Flags = dwFlag;

            // set the interface
            pAtmarpcReconfig->IfKeyOffset = sizeof(ATMARPC_PNP_RECONFIG_REQUEST);
            pbByte += sizeof(ATMARPC_PNP_RECONFIG_REQUEST);

            USHORT* puCount = reinterpret_cast<USHORT *>(pbByte);
            Assert (strIpConfigString.length() <= USHRT_MAX);
            *puCount = (USHORT)strIpConfigString.length();
            pbByte += sizeof(USHORT);

            WCHAR * pwszBindName = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pwszBindName, strIpConfigString.c_str());

            TraceTag(ttidTcpip, "Sending notification to AtmArpC for adapter %S", pwszBindName);
            TraceTag(ttidTcpip, "OpType: %d", pAtmarpcReconfig->OpType);
            TraceTag(ttidTcpip, "Flags: %d", pAtmarpcReconfig->Flags);
            TraceTag(ttidTcpip, "WChar Count: %d", *puCount);

            // now send the notification
            hr = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                                       pAdapterInfo->m_strTcpipBindPath.c_str(),
                                       pvBuf,
                                       dwBytes);

            //we dont want to request reboot if the error is ERROR_FILE_NOT_FOUND
            //because that means the card is not loaded by the stack yet. Usually this is 
            //because the card was disabled from the connection UI. When the card is re-enabled,
            //the statck will reload the card and load all settings from the registry. So a reboot
            //is not needed
            if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
            {
                TraceError("pICallback->SendPnpReconfig to AtmArpC returns failure:", hr);
                hr = NETCFG_S_REBOOT;
            }

            MemFree(pvBuf);
        }
    }

    TraceError("CTcpipcfg::HrReconfigAtmArp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigNbt
//
//  Purpose:    Notify NetBt of configuration changes
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT if failure
//
HRESULT CTcpipcfg::HrReconfigNbt(INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;

    NETBT_PNP_RECONFIG_REQUEST NetbtReconfigRequest;

    // DWORD version
    NetbtReconfigRequest.version = 1;

    // Notify NetBt of any wins address changes (per adapter)
    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++) // for each adapter
    {
        ADAPTER_INFO * pAdapter = *iterAdapter;

        // If not wan adapter, and adapter is enabled
        if ((!pAdapter->m_fIsWanAdapter) &&
            (!pAdapter->m_fIsRasFakeAdapter) &&
            (pAdapter->m_BindingState == BINDING_ENABLE) &&
            (pAdapter->m_InitialBindingState != BINDING_DISABLE))
        {
            if ( (!fIsSameVstr(pAdapter->m_vstrWinsServerList,
                               pAdapter->m_vstrOldWinsServerList)) ||
                 (pAdapter->m_dwNetbiosOptions != pAdapter->m_dwOldNetbiosOptions))
            {
                TraceTag(ttidTcpip, "Sending notification to NetBt for per adapter parameter changes.");
                if ( FAILED( pICallback->SendPnpReconfig(NCRL_TDI, c_szNetBt,
                                                   pAdapter->m_strNetBtBindPath.c_str(),
                                                   NULL,
                                                   0)))
                {
                   TraceTag(ttidTcpip,"Notifying NetBt of Wins address change returns failure, prompt for reboot ...");
                   hr = NETCFG_S_REBOOT;
                };
            }
        }
    }

    // Notify NetBt of any global parameter changes
    if (m_fLmhostsFileSet ||
        (m_glbGlobalInfo.m_fEnableLmHosts != m_glbGlobalInfo.m_fOldEnableLmHosts))
    {
        TraceTag(ttidTcpip, "Sending notification to NetBt about NetBt parameter changes.");

        // $REVIEW(tongl 11/14/97): since we do need to send some notification to tcpip,
        // we need to read the correct value of "EnableDns" from registry
        // This is a temporary thing so Malam can keep the ability to reconfigure these
        // settings that used to be configurable in NT5 Beta1.
        // $REVIEW(nsun 04/14/99): Per MalaM, most users don't use this value and NetBT
        // will ignore this value. We should remove it from the data struct after Beta3.
        NetbtReconfigRequest.enumDnsOption = WinsThenDns;
        //     m_glbGlobalInfo.m_fDnsEnableWins ? WinsThenDns : DnsOnly;

        NetbtReconfigRequest.fScopeIdUpdated = FALSE;

        NetbtReconfigRequest.fLmhostsEnabled = !!m_glbGlobalInfo.m_fEnableLmHosts;
        NetbtReconfigRequest.fLmhostsFileSet = !!m_fLmhostsFileSet;

        TraceTag(ttidTcpip, "Sending notification to NetBt for global parameter changes.");
        TraceTag(ttidTcpip, "fLmhostsEnabled: %d", NetbtReconfigRequest.fLmhostsEnabled);
        TraceTag(ttidTcpip, "fLmhostsFileSet: %d", NetbtReconfigRequest.fLmhostsFileSet);

        if ( FAILED(pICallback->SendPnpReconfig(NCRL_TDI, c_szNetBt,
                                          c_szEmpty,
                                          &NetbtReconfigRequest,
                                          sizeof(NETBT_PNP_RECONFIG_REQUEST))) )
        {
           TraceTag(ttidTcpip,"Notifying NetBt component of DNS parameter change returns failure, prompt for reboot ...");
           hr = NETCFG_S_REBOOT;
        };
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigDns
//
//  Purpose:    Notify DNS Cache resolver service of configuration changes
//
//  Arguments:  fDoReconfigWithoutCheckingParams
//                      default is FALSE
//                      if TRUE, then will do Dns reconfig with checking if there
//                      is paramter changes or not
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT otherwise
//
HRESULT CTcpipcfg::HrReconfigDns(BOOL fDoReconfigWithoutCheckingParams)
{
    // Submit a generic reconfig notification to the service
    // if any of the DNS related parameters have changed.
    BOOL fDnsParamChanged = fDoReconfigWithoutCheckingParams;

    if (!fDnsParamChanged)
    {
        // Suffix list and UseDomainNameDevolution changed ?
        BOOL fDnsSuffixChanged =
             !fIsSameVstr(m_glbGlobalInfo.m_vstrDnsSuffixList,
                          m_glbGlobalInfo.m_vstrOldDnsSuffixList);

        if (fDnsSuffixChanged) // suffix changed
        {
            fDnsParamChanged = TRUE;
        }
        else if (m_glbGlobalInfo.m_vstrDnsSuffixList.size() == 0)
        {
            if (m_glbGlobalInfo.m_fUseDomainNameDevolution !=
                m_glbGlobalInfo.m_fOldUseDomainNameDevolution)
                fDnsParamChanged = TRUE;
        }
    }

    // $REVIEW(tongl 6/19/98): DNS also cares about IP address, subnet mask & gateway changes
    if (!fDnsParamChanged)
    {
        // Has any IP setting changed ?
        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
             iterAdapter != m_vcardAdapterInfo.end();
             iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;

            // If not wan adapter
            if (!pAdapter->m_fIsWanAdapter)
            {
                if ( ((!!pAdapter->m_fEnableDhcp) !=
                                    (!!pAdapter->m_fOldEnableDhcp)) ||
                     (!fIsSameVstr(pAdapter->m_vstrIpAddresses,
                                   pAdapter->m_vstrOldIpAddresses)) ||
                     (!fIsSameVstr(pAdapter->m_vstrSubnetMask,
                                   pAdapter->m_vstrOldSubnetMask)) ||
                     (!fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                                   pAdapter->m_vstrOldDefaultGateway)) ||
                     (!fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                                   pAdapter->m_vstrOldDefaultGatewayMetric)) 
                  )
                {
                    fDnsParamChanged = TRUE;
                    break;
                }
            }
        }
    }

    HRESULT hr = S_OK;
    if (fDnsParamChanged)
    {
        TraceTag(ttidTcpip, "Sending notification to Dns about Dns and IP parameter changes.");

        hr = HrSendServicePnpEvent(c_szSvcDnscache,
                        SERVICE_CONTROL_PARAMCHANGE);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) == hr)
            {
                TraceTag(ttidTcpip,"Notifying dnscache service of parameter change failed because DNS cache is not active.");
                hr = S_OK;
            }
            else
            {
                TraceTag(ttidTcpip,"Notifying dnscache service of parameter change failed, prompt for reboot ...");
                hr = NETCFG_S_REBOOT;
            }
        }
    }

    TraceError("CTcpipcfg::HrReconfigDns",hr);
    return hr;
}

HRESULT CTcpipcfg::HrReconfigWanarp(ADAPTER_INFO *pAdapterInfo, 
                                    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;
    DWORD   cbInfo;
    WANARP_RECONFIGURE_INFO* pInfo;

    const IFACECOL& Ifaces = pAdapterInfo->m_IfaceIds;

    cbInfo = sizeof(WANARP_RECONFIGURE_INFO) + (sizeof(GUID) * Ifaces.size());

    hr = HrMalloc(cbInfo, (PVOID*)&pInfo);
    if (SUCCEEDED(hr))
    {
        // Populate the data in the WANARP_RECONFIGURE_INFO structure.
        //
        INT nIndex;

        pInfo->dwVersion = WANARP_RECONFIGURE_VERSION;
        pInfo->wrcOperation = WRC_ADD_INTERFACES;
        pInfo->ulNumInterfaces = Ifaces.size();

        IFACECOL::const_iterator iter;
        for (iter = Ifaces.begin(), nIndex = 0; iter != Ifaces.end();
             iter++, nIndex++)
        {
            pInfo->rgInterfaces[nIndex] = *iter;
        }

        TraceTag(ttidNetCfgPnp, "Sending NDIS reconfig Pnp event to Upper:%S "
            "lower: %S for %d interfaces",
            c_szTcpip,
            pAdapterInfo->m_strTcpipBindPath.c_str(),
            pInfo->ulNumInterfaces);

        hr  = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                    pAdapterInfo->m_strTcpipBindPath.c_str(),
                    pInfo,
                    cbInfo);

        // Send the notification.
        //
        MemFree(pInfo);
    }

    TraceError("CTcpipcfg::HrReconfigWanarp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSetActiveIpsecPolicy
//
//  Purpose:    Set a user chosen local policy
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT otherwise
//
//IPSec is removed from connection UI   
/*
HRESULT CTcpipcfg::HrSetActiveIpsecPolicy()
{
    HRESULT hr = S_OK;

    AssertSz(m_glbGlobalInfo.m_strIpsecPol != c_szIpsecUnset, "Ipsec policy unset ?");

    if (m_glbGlobalInfo.m_strIpsecPol != c_szIpsecUnset)
    {
        // load the polstore dll & get export function
        typedef HRESULT (WINAPI * PFNHrSetAssignedLocalPolicy)(GUID * pActivePolId);

        HMODULE hPolStore;
        FARPROC pfn;

        hr = HrLoadLibAndGetProc (L"polstore.dll",
                                  "HrSetAssignedLocalPolicy",
                                  &hPolStore, &pfn);

        if (S_OK == hr)
        {
            Assert(hPolStore != NULL);
            Assert(pfn != NULL);

            PFNHrSetAssignedLocalPolicy pfnHrSetAssignedLocalPolicy =
                            reinterpret_cast<PFNHrSetAssignedLocalPolicy>(pfn);

            if (m_glbGlobalInfo.m_strIpsecPol == c_szIpsecNoPol)
            {
                // no ipsec
                TraceTag(ttidTcpip, "Calling HrSetAssignedLocalPolicy with NULL.");
                hr = (*pfnHrSetAssignedLocalPolicy)(NULL);
                TraceTag(ttidTcpip, "HrSetActivePolicy returns hr: %x", hr);
            }
            else
            {
                WCHAR szPolicyGuid[c_cchGuidWithTerm];
                BOOL fSucceeded = StringFromGUID2(m_glbGlobalInfo.m_guidIpsecPol,
                                                  szPolicyGuid,
                                                  c_cchGuidWithTerm);

                TraceTag(ttidTcpip, "Calling HrSetActivePolicy with %S.", szPolicyGuid);
                hr = (*pfnHrSetAssignedLocalPolicy)(&(m_glbGlobalInfo.m_guidIpsecPol));
                TraceTag(ttidTcpip, "HrSetAssignedLocalPolicy returns hr: %x", hr);
            }

            if (FAILED(hr))
            {
                TraceError("Failed setting active ipsec policy.", hr);
                NcMsgBoxWithWin32ErrorText(DwWin32ErrorFromHr(hr),
                                           _Module.GetResourceInstance(),
                                           ::GetActiveWindow(),
                                           IDS_MSFT_TCP_TEXT,
                                           IDS_WIN32_ERROR_FORMAT,
                                           IDS_SET_IPSEC_FAILED,
                                           MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                hr = S_OK;
            }

            FreeLibrary (hPolStore);
        }
        else
        {
            TraceTag(ttidTcpip,"Failed to get function HrSetActivePolicy from polstore.dll");
            hr = S_OK;
        }
    }

    TraceError("CTcpipcfg::HrSetActiveIpsecPolicy", hr);
    return hr;
}
*/

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveMultipleInterfaceWanRegistry
//
//  Purpose:    For WAN adapters with multiple interfaces, we need to check every
//              interface to see if it is newly added. If so, create the interface
//              subkey and set the default settings
//
//  Arguments:  hkeyInterface   CCS\Services\Tcpip\Parameters\Interfaces key
//              pAdapter        ADAPTER_INFO pointer to settings of the WAN adapter
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
//  Author:     nsun 08/29/98

HRESULT CTcpipcfg::HrSaveMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces,
                                                      ADAPTER_INFO* pAdapter)
{
    HRESULT hr = S_OK;

    IFACEITER   iterId;
    tstring     strInterfaceName;

    for (iterId  = pAdapter->m_IfaceIds.begin();
         iterId != pAdapter->m_IfaceIds.end();
         iterId ++)
    {
        GetInterfaceName(
                pAdapter->m_strTcpipBindPath.c_str(),
                *iterId,
                &strInterfaceName);

        HRESULT hrTmp;
        HKEY hkeyInterfaceParam;
        DWORD dwDisposition;

        hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                 strInterfaceName.c_str(),
                                 REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                 &hkeyInterfaceParam, &dwDisposition);
        if (SUCCEEDED(hrTmp))
        {
            //We don't set default settings if the WAN interface is NOT newly added.
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                      RGAS_USEZEROBROADCAST,
                                      0);
                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrTmp))
                    hrTmp = HrSaveStaticWanRegistry(hkeyInterfaceParam);
            }

            RegCloseKey(hkeyInterfaceParam);
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveWinsMultipleInterfaceWanRegistry
//
//  Purpose:    For WAN adapters with multiple interfaces, create the interface
//              subkeys and set the default settings
//
//  Arguments:  hkeyInterface   CCS\Services\NetBT\Parameters\Interfaces key
//              pAdapter        ADAPTER_INFO pointer to settings of the WAN adapter
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
//  Author:     nsun 10/05/98

HRESULT CTcpipcfg::HrSaveWinsMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces,
                                                      ADAPTER_INFO* pAdapter)
{
    HRESULT hr = S_OK;
    IFACEITER   iterId;
    tstring     strInterfaceName;

    for (iterId  = pAdapter->m_IfaceIds.begin();
         iterId != pAdapter->m_IfaceIds.end();
         iterId++)
    {
        GetInterfaceName(
                pAdapter->m_strNetBtBindPath.c_str(),
                *iterId,
                &strInterfaceName);

        strInterfaceName.insert(0, c_szTcpip_);

        HRESULT hrTmp;
        HKEY hkeyInterfaceParam;
        DWORD dwDisposition;

        hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                 strInterfaceName.c_str(),
                                 REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                 &hkeyInterfaceParam, &dwDisposition);
        if (SUCCEEDED(hrTmp))
        {
            //We don't set default settings if the WAN interface is NOT newly added.
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                VSTR vstrNameServerList;

                hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                         RGAS_NETBT_NAMESERVERLIST,
                                         vstrNameServerList);
                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }

            RegCloseKey(hkeyInterfaceParam);
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveStaticWanRegistry
//
//  Purpose:    Write static parameters for Wan adapters to registry
//
//  Arguments:  none
//
//  Returns:    S_OK if success, E_FAIL otherwise
//

HRESULT CTcpipcfg::HrSaveStaticWanRegistry(HKEY hkeyInterfaceParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;

    // EnableDHCP = 0
    // IPAddress = 0.0.0.0
    // SubnetMask = 0.0.0.0
    // DefaultGateWay =

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                RGAS_ENABLE_DHCP, FALSE);

    hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_IPADDRESS, L"0.0.0.0\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_SUBNETMASK, L"0.0.0.0\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_DEFAULTGATEWAY, L"\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    //(nsun 11/02/98) set static RRAS parameters for unattended install

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                          c_szDeadGWDetect,
                          m_glbGlobalInfo.m_fDeadGWDetectDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                          c_szDontAddDefaultGateway,
                          m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);

    if (SUCCEEDED(hr))
        hr = hrTmp;


    TraceError("CTcpipcfg::HrSaveStaticWanRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveStaticAtmRegistry
//
//  Purpose:    Write static parameters for Wan adapters to registry
//
//  Arguments:  none
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
HRESULT CTcpipcfg::HrSaveStaticAtmRegistry(HKEY hkeyInterfaceParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    HKEY hkeyAtmarpc;
    DWORD dwDisposition;

    // Open the Atmarpc subkey
    hrTmp = HrRegCreateKeyEx(hkeyInterfaceParam,
                             c_szAtmarpc,
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ_WRITE,
                             NULL,
                             &hkeyAtmarpc,
                             &dwDisposition);

    if (SUCCEEDED(hrTmp))
    {
        // SapSelector
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        hr = hrTmp;

        // AddressResolutionTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_AddressResolutionTimeout,
                              c_dwAddressResolutionTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ARPEntryAgingTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ARPEntryAgingTimeout,
                              c_dwARPEntryAgingTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // InARPWaitTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxRegistrationAttempts
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_InARPWaitTimeout,
                              c_dwInARPWaitTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxResolutionAttempts
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MaxResolutionAttempts,
                              c_dwMaxResolutionAttempts);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MinWaitAfterNak
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerConnectInterval
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MinWaitAfterNak,
                              c_dwMinWaitAfterNak);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerRefreshTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ServerRefreshTimeout,
                              c_dwServerRefreshTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerRegistrationTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ServerRegistrationTimeout,
                              c_dwServerRegistrationTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DefaultVcAgingTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_DefaultVcAgingTimeout,
                              c_dwDefaultVcAgingTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MARSConnectInterval
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MARSConnectInterval,
                              c_dwMARSConnectInterval);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MARSRegistrationTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MARSRegistrationTimeout,
                              c_dwMARSRegistrationTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // JoinTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_JoinTimeout,
                              c_dwJoinTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // LeaveTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_LeaveTimeout,
                              c_dwLeaveTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxDelayBetweenMULTIs
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MaxDelayBetweenMULTIs,
                              c_dwMaxDelayBetweenMULTIs);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        RegCloseKey(hkeyAtmarpc);
    }

    TraceError("CTcpipcfg::HrSaveStaticAtmRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     ReInitializeInternalState
//
//  Purpose:   Reinitialize internal state at the end of Apply if Apply SUCCEEDED
//
//  Arguments:
//
//  Returns:    None
//  Author:     tongl  4 Sept 1997
//  Notes:      Fix bug# 105383
//
//
void CTcpipcfg::ReInitializeInternalState()
{
    // Reset global and adapter parameter values if necessary
    if (m_fSaveRegistry || m_fReconfig)
    {
        m_glbGlobalInfo.ResetOldValues();


        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;
            pAdapter->ResetOldValues();
        }
    }

    // Reset internal flags
    m_fRemoving = FALSE;
    m_fInstalling = FALSE;

    m_fSaveRegistry = FALSE;
    m_fReconfig = FALSE;

    // Initialize the netbt_pnp_reconfig_request structure
    m_fLmhostsFileSet = FALSE;
}

// This functions adds a new RAS fake GUID directly to our memory structure,
// and loads info from the RAS phone book.
HRESULT CTcpipcfg::UpdateRasAdapterInfo(
    const RASCON_IPUI& RasInfo)
{
    HRESULT hr;
    ADAPTER_INFO* pAdapter;

    hr = S_OK;
    m_fSaveRegistry = TRUE;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(RasInfo.guidConnection, szGuid, c_cchGuidWithTerm);

    pAdapter = PAdapterFromInstanceGuid(&RasInfo.guidConnection);
    if (!pAdapter)
    {
        pAdapter = new ADAPTER_INFO;
        hr = pAdapter->HrSetDefaults(&RasInfo.guidConnection,
                                     c_szRasFakeAdapterDesc, szGuid, szGuid);
        if (SUCCEEDED(hr))
        {
            m_vcardAdapterInfo.push_back(pAdapter);

            pAdapter->m_fIsRasFakeAdapter = TRUE;
        }
        else
        {
            delete pAdapter;
            pAdapter = NULL;
            Assert (FAILED(hr));
        }
    }
    else
    {
        //We need to set default even if the ras connection is already in our adapter list
        //because we should update all the paramters based on the phone book
        hr = pAdapter->HrSetDefaults(&RasInfo.guidConnection,
                                     c_szRasFakeAdapterDesc, szGuid, szGuid);
        pAdapter->m_fIsRasFakeAdapter = TRUE;
    }

    if (SUCCEEDED(hr))
    {
        Assert (pAdapter);

        // Now see if we should overwrite some of the parameters
        // from what's in the phone book
        if (RasInfo.dwFlags & RCUIF_USE_IP_ADDR)
        {
            // use static IP address
            pAdapter->m_fEnableDhcp = FALSE;
            pAdapter->m_fOldEnableDhcp = FALSE;

            pAdapter->m_vstrIpAddresses.push_back(new tstring(RasInfo.pszwIpAddr));
            CopyVstr(&pAdapter->m_vstrOldIpAddresses,
                     pAdapter->m_vstrIpAddresses);

            // generate the subnet mask
            tstring strIpAddress = RasInfo.pszwIpAddr;
            tstring strSubnetMask;
            DWORD adwIpAddress[4];

            GetNodeNum(strIpAddress.c_str(), adwIpAddress);
            DWORD nValue = adwIpAddress[0];

            if (nValue <= SUBNET_RANGE_1_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_1;
            }
            else if (nValue <= SUBNET_RANGE_2_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_2;
            }
            else if (nValue <= SUBNET_RANGE_3_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_3;
            }
            else
            {
                AssertSz(FALSE, "Invaid IP address ?");
            }

            pAdapter->m_vstrSubnetMask.push_back(new tstring(strSubnetMask.c_str()));
            CopyVstr(&pAdapter->m_vstrOldSubnetMask,
                     pAdapter->m_vstrSubnetMask);
        }

        if (RasInfo.dwFlags & RCUIF_USE_NAME_SERVERS)
        {
            // use DNS and WINS addresses
            if (RasInfo.pszwDnsAddr && lstrlenW(RasInfo.pszwDnsAddr))
                pAdapter->m_vstrDnsServerList.push_back(new tstring(RasInfo.pszwDnsAddr));

            if (RasInfo.pszwDns2Addr && lstrlenW(RasInfo.pszwDns2Addr))
                pAdapter->m_vstrDnsServerList.push_back(new tstring(RasInfo.pszwDns2Addr));

            CopyVstr(&pAdapter->m_vstrOldDnsServerList,
                     pAdapter->m_vstrDnsServerList);

            if (RasInfo.pszwWinsAddr && lstrlenW(RasInfo.pszwWinsAddr))
                pAdapter->m_vstrWinsServerList.push_back(new tstring(RasInfo.pszwWinsAddr));

            if (RasInfo.pszwWins2Addr && lstrlenW(RasInfo.pszwWins2Addr))
                pAdapter->m_vstrWinsServerList.push_back(new tstring(RasInfo.pszwWins2Addr));

            CopyVstr(&pAdapter->m_vstrOldWinsServerList,
                     pAdapter->m_vstrWinsServerList);
        }

        pAdapter->m_fUseRemoteGateway       = !!(RasInfo.dwFlags & RCUIF_USE_REMOTE_GATEWAY);
        pAdapter->m_fUseIPHeaderCompression = !!(RasInfo.dwFlags & RCUIF_USE_HEADER_COMPRESSION);
        pAdapter->m_dwFrameSize = RasInfo.dwFrameSize;
        pAdapter->m_fIsDemandDialInterface = !!(RasInfo.dwFlags & RCUIF_DEMAND_DIAL);
        
        pAdapter->m_fDisableDynamicUpdate = !!(RasInfo.dwFlags & RCUIF_USE_DISABLE_REGISTER_DNS);
        pAdapter->m_fOldDisableDynamicUpdate = pAdapter->m_fDisableDynamicUpdate;
        
        pAdapter->m_fEnableNameRegistration = !!(RasInfo.dwFlags & RCUIF_USE_PRIVATE_DNS_SUFFIX);
        pAdapter->m_fOldEnableNameRegistration = pAdapter->m_fEnableNameRegistration;

        if (RasInfo.dwFlags & RCUIF_ENABLE_NBT)
        {
            pAdapter->m_dwNetbiosOptions = c_dwEnableNetbios;
            pAdapter->m_dwOldNetbiosOptions = c_dwEnableNetbios;
        }
        else
        {
            pAdapter->m_dwNetbiosOptions = c_dwDisableNetbios;
            pAdapter->m_dwOldNetbiosOptions = c_dwDisableNetbios;
        }

        pAdapter->m_strDnsDomain = RasInfo.pszwDnsSuffix;
        pAdapter->m_strOldDnsDomain = pAdapter->m_strDnsDomain;
    }

    TraceError("CTcpipcfg::UpdateRasAdapterInfo", hr);
    return hr;
}

HRESULT CTcpipcfg::HrDuplicateToNT4Location(HKEY hkeyInterface, ADAPTER_INFO * pAdapter)
{
    Assert(hkeyInterface);
    Assert(pAdapter);

    HRESULT hr = S_OK;

    HKEY hkeyServices = NULL;
    HKEY hkeyNt4 = NULL;

    DWORD   dwDisposition;
    tstring strNt4SubKey = pAdapter->m_strBindName;
    strNt4SubKey += c_szRegParamsTcpip;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                    KEY_READ, &hkeyServices);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrRemoveNt4DuplicateRegistry: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(hkeyServices, strNt4SubKey.c_str(),
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                    &hkeyNt4, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        HRESULT hrRead = S_OK;
        HRESULT hrWrite = S_OK;

        if (REG_CREATED_NEW_KEY == dwDisposition)
        {
            hr = HrSetSecurityForNetConfigOpsOnSubkeys(hkeyServices, strNt4SubKey.c_str());
            hr = S_OK;
        }

        UINT cValues = sizeof(s_rgNt4Values)/sizeof(*s_rgNt4Values);
        VSTR vstrTmp;
        tstring strTmp;
        DWORD   dwTmp;
        BOOL    fTmp;

        for (UINT i = 0; i < cValues; i++)
        {
            switch(s_rgNt4Values[i].dwType)
            {
            case REG_BOOL:
                hrRead = HrRegQueryDword(hkeyInterface,
                                       s_rgNt4Values[i].pszValueName,
                                       &dwTmp);
                if (SUCCEEDED(hrRead))
                {
                    fTmp = !!dwTmp;
                    hrWrite = HrRegSetBool(hkeyNt4,
                                          s_rgNt4Values[i].pszValueName,
                                          fTmp);
                }
                break;

            case REG_DWORD:
                hrRead = HrRegQueryDword(hkeyInterface,
                                        s_rgNt4Values[i].pszValueName,
                                        &dwTmp);
                if (SUCCEEDED(hrRead))
                    hrWrite = HrRegSetDword(hkeyNt4,
                                          s_rgNt4Values[i].pszValueName,
                                          dwTmp);

                break;

            case REG_SZ:
                hrRead = HrRegQueryString(hkeyInterface,
                                            s_rgNt4Values[i].pszValueName,
                                            &strTmp);
                if (SUCCEEDED(hrRead))
                    hrWrite = HrRegSetString(hkeyNt4,
                                           s_rgNt4Values[i].pszValueName,
                                           strTmp);
                break;

            case REG_MULTI_SZ:
               hrRead = HrRegQueryColString( hkeyInterface,
                                             s_rgNt4Values[i].pszValueName,
                                             &vstrTmp);

                if (SUCCEEDED(hrRead))
                {
                    hrWrite = HrRegSetColString(hkeyNt4,
                                            s_rgNt4Values[i].pszValueName,
                                            vstrTmp);
                    DeleteColString(&vstrTmp);
                }
                break;
            }

#ifdef ENABLETRACE
            if(FAILED(hrRead))
            {
                TraceTag(ttidTcpip, "HrDuplicateToNT4Location: Failed on loading %S, hr: %x",
                             s_rgNt4Values[i].pszValueName, hr);
            }

            if(FAILED(hrWrite))
            {
                TraceTag(ttidError,
                    "HrDuplicateToNT4Location: failed to write %S to the registry. hr = %x.",
                    s_rgNt4Values[i].pszValueName, hrWrite);
            }
#endif

            if (SUCCEEDED(hr))
                hr = hrWrite;
        }

        RegSafeCloseKey(hkeyNt4);
    }

    RegSafeCloseKey(hkeyServices);

LERROR:
    TraceError("CTcpipcfg::HrDuplicateToNT4Location", hr);
    return hr;
}


//To solve the compatibility issues of non-nt5 applications, we duplicate some important
//per interface tcpip parameters to the old NT4 location: Services\{adapter GUID}\Parameters\Tcpip
//We need to clean it up when removing tcpip
HRESULT CTcpipcfg::HrRemoveNt4DuplicateRegistry()
{
    //we also need to delete the duplicate reg values under Services\{adapter GUID}
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HKEY    hkeyServices = NULL;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                    KEY_READ_WRITE_DELETE, &hkeyServices);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrRemoveNt4DuplicateRegistry: Failed to open the Services reg key, hr: %x", hr);
    }
    else
    {
        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
             iterAdapter != m_vcardAdapterInfo.end();
             iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;

            if (!pAdapter->m_fIsWanAdapter && !pAdapter->m_fIsRasFakeAdapter)
            {
                hrTmp = HrRegDeleteKeyTree(hkeyServices, pAdapter->m_strBindName.c_str());

#ifdef ENABLETRACE
                if (FAILED(hrTmp))
                {
                    TraceTag(ttidTcpip, "CTcpipcfg::HrRemoveNt4DuplicateRegistry");
                    TraceTag(ttidTcpip, "Failed on deleting duplicated Nt4 layout key: Services\\%S, hr: %x",
                             pAdapter->m_strBindName, hrTmp);
                }
#endif
            }
        }

        RegSafeCloseKey(hkeyServices);
    }

    TraceError("CTcpipcfg::HrRemoveNt4DuplicateRegistry", hr);
    return hr;
}


HRESULT CTcpipcfg::HrCleanUpPerformRouterDiscoveryFromRegistry()
{
    HRESULT hr = S_OK;
    HKEY    hkey = NULL;

    hr = m_pnccTcpip->OpenParamKey(&hkey);
    
    if (SUCCEEDED(hr))
    {
        Assert(hkey);

        HRESULT hrTemp = S_OK;
        
        //delete the global PerformRouterDiscoveryDefault value
        hrTemp = HrRegDeleteValue(hkey,
                        c_szPerformRouterDiscoveryDefault);
        
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTemp)
            hrTemp = S_OK;

        if (SUCCEEDED(hr))
            hr = hrTemp;

        HKEY hkeyInterfaces = NULL;
        hrTemp = HrRegOpenKeyEx(hkey, 
                            c_szInterfacesRegKey, 
                            KEY_READ,
                            &hkeyInterfaces);

        if (SUCCEEDED(hrTemp) && hkeyInterfaces)
        {
            WCHAR szBuf[256];
            DWORD dwSize = celems(szBuf);
            FILETIME time;
            DWORD dwRegIndex = 0;

            while (SUCCEEDED(hrTemp = HrRegEnumKeyEx(hkeyInterfaces,
                                            dwRegIndex++,
                                            szBuf,
                                            &dwSize,
                                            NULL,
                                            NULL,
                                            &time)))
            {
                HKEY hkeyIf = NULL;

                dwSize = celems(szBuf);
                hrTemp = HrRegOpenKeyEx(hkeyInterfaces,
                                szBuf,
                                KEY_READ_WRITE_DELETE,
                                &hkeyIf);
                
                if (SUCCEEDED(hr))
                    hr = hrTemp;

                if (SUCCEEDED(hrTemp))
                {
                    Assert(hkeyIf);

                    DWORD dwTemp = 0;
                    hrTemp = HrRegQueryDword(hkeyIf,
                                            c_szPerformRouterDiscovery,
                                            &dwTemp);
                    if (SUCCEEDED(hrTemp))
                    {
                        if (IP_IRDP_DISABLED != dwTemp)
                        {
                            hrTemp = HrRegDeleteValue(hkeyIf,
                                            c_szPerformRouterDiscovery);

                            if (SUCCEEDED(hr))
                                hr = hrTemp;
                        }

                    }
                    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTemp)
                    {
                        hrTemp = S_OK;
                    }
                    
                    if (SUCCEEDED(hr))
                        hr = hrTemp;

                    RegSafeCloseKey(hkeyIf);
                }

            }

            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrTemp)
                hrTemp = S_OK;

            if (SUCCEEDED(hr))
                hr = hrTemp;

            RegSafeCloseKey(hkeyInterfaces);
        }

        
        RegSafeCloseKey(hkey);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceError("CTcpipcfg::HrCleanUpPerformRouterDiscoveryFromRegistry", hr);
    return hr;
}


HRESULT CTcpipcfg::HrSaveBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter)
{
    HRESULT hr = S_OK;

    HKEY hkeyDhcpConfigs = NULL;
    HKEY hkeyDhcpCfg = NULL;
    DWORD dwDisposition = 0;
    tstring strConfigurationName;
    tstring strReg;

    if (!pAdapter->m_BackupInfo.m_fAutoNet)
    {
        //Set the Configuration option name as "Alternate_{Interface GUID}"
        strConfigurationName = c_szAlternate;
        strConfigurationName += pAdapter->m_strBindName;

        //construct the NULL terminator for the Multi_SZ
        int cch = strConfigurationName.length() + 2;
        WCHAR * pwsz = new WCHAR[cch];
        if (NULL == pwsz)
            return E_OUTOFMEMORY;

        ZeroMemory(pwsz, sizeof(pwsz[0]) * cch);
        lstrcpyW(pwsz, strConfigurationName.c_str());

        hr = HrRegSetMultiSz(hkeyInterfaceParam,
                       c_szActiveConfigurations,
                       pwsz);

        delete [] pwsz;
    }
    else
    {
        hr = HrRegDeleteValue(hkeyInterfaceParam,
                        c_szActiveConfigurations);

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            hr = S_OK;
    }


    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrSaveBackupTcpSettings: Failed to create ActiveConfigurations value, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDhcpConfigurations,
                    REG_OPTION_NON_VOLATILE, KEY_READ, NULL,
                    &hkeyDhcpConfigs, &dwDisposition);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrSaveBackupTcpSettings: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(hkeyDhcpConfigs, strConfigurationName.c_str(),
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                    &hkeyDhcpCfg, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        DWORD           pdwOptionData[2];   // buffer holding the option's Dwords
        DWORD           dwIdxData;          // actual data to be saved into blob for each option

        LPBYTE          pRegRaw = NULL;     // buffer holding the blob
        DWORD           cb = 0;             // blob size in the pRegRaw buffer
        DWORD           cbMax = 0;          // pRegRaw buffer size (assert(cb<=cbMax))

        // fill in the blob pRegRaw to be written to the registry
        // 
        // fill in option 50 (requested IpAddress = Fallback IpAddress) 
        pdwOptionData[0] = htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strIpAddr.c_str()));
        // the adapter's address can't be an empty string hence a 0.0.0.0 address

        hr = HrSaveBackupDwordOption (
                OPTION_REQUESTED_ADDRESS,
                pdwOptionData,
                1,
                &pRegRaw,
                &cb,
                &cbMax);
        
        // fill in option 1 (Fallback subnet mask)
        if (hr == S_OK)
        {
            pdwOptionData[0] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strSubnetMask.c_str()));
            // the adapter's subnet mask can't be an empty string, hence a 0.0.0.0 address

            hr = HrSaveBackupDwordOption (
                    OPTION_SUBNET_MASK,
                    pdwOptionData,
                    1,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // fill in option 3 if any Fallback gateway is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strDefGw.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_ROUTER_ADDRESS,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);

        }

        // fill in option 6 if any Fallback DNS servers (maximum 2 supported for now) is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strPreferredDns.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strAlternateDns.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_DOMAIN_NAME_SERVERS,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // fill in option 44 if any Fallback WINS servers (maximum 2 supported for now) is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strPreferredWins.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strAlternateWins.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_NETBIOS_NAME_SERVER,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // write the blob to the registry
        if (hr == S_OK)
        {
            hr = HrRegSetBinary(hkeyDhcpCfg,
                    c_szConfigOptions,
                    pRegRaw,
                    cb);
        }

        // free whatever mem was allocated
        if (pRegRaw != NULL)
            CoTaskMemFree(pRegRaw);


        RegSafeCloseKey(hkeyDhcpCfg);
    }

    RegSafeCloseKey(hkeyDhcpConfigs);

LERROR:
    return hr;
}

///////////////////////////////////////////////////////////////////
// Fills in a DHCP DWORD option into a blob. Adjusts the size of
// the buffer holding the blob if needed and returns through the
// out params the new buffer, its size and the size of the blob
// it contains.
HRESULT CTcpipcfg::HrSaveBackupDwordOption (
            /*IN*/      DWORD  Option,
            /*IN*/      DWORD  OptionData[],
            /*IN*/      DWORD  OptionDataSz,
            /*IN OUT*/  LPBYTE  *ppBuffer,
            /*IN OUT*/  LPDWORD pdwBlobSz,
            /*IN OUT*/  LPDWORD pdwBufferSz)
{
    DWORD           dwBlobSz;
    REG_BACKUP_INFO *pRegBackupInfo;
    DWORD           dwOptIdx;

    // if no data is available at all, then don't save anything
    if (OptionDataSz == 0)
        return S_OK;

    // calculate the memory size needed for the new updated blob.
    // don't forget, REG_BACKUP_INFO already contains one DWORD from the Option's data
    dwBlobSz = (*pdwBlobSz) + sizeof(REG_BACKUP_INFO) + (OptionDataSz-1)*sizeof(DWORD);

    // check whether the buffer is large enough to hold the new blob
    if ((*pdwBufferSz) < dwBlobSz)
    {
        HRESULT hr;
        LPBYTE  pNewBuffer;
        DWORD   dwBuffSz;

        // get the expected size of the new buffer
        dwBuffSz = max((*pdwBufferSz) + BUFFER_ENLARGEMENT_CHUNK, dwBlobSz);

        // if the pointer provided is NULL...
        if (*ppBuffer == NULL)
        {
            // ...this means we have to do the initial allocation
            pNewBuffer = (LPBYTE)CoTaskMemAlloc(dwBuffSz);
        }
        else
        {
            // ...otherwise is just a buffer enlargement so do a
            // realloc in order to keep the original payload
            pNewBuffer = (LPBYTE)CoTaskMemRealloc((*ppBuffer), dwBuffSz);
                        
        }

        if (pNewBuffer == NULL)
            return E_OUTOFMEMORY;

        // starting from this point we don't expect any other errors
        // so start update the output parameters
        (*ppBuffer) = pNewBuffer;
        (*pdwBufferSz) += dwBuffSz;
    }

    // get the mem storage seen as a REG_BACKUP_INFO struct
    pRegBackupInfo = (REG_BACKUP_INFO *)((*ppBuffer) + (*pdwBlobSz));
    (*pdwBlobSz) = dwBlobSz;
    // update the blob by adding the new option
    pRegBackupInfo->dwOptionId   = Option;
    pRegBackupInfo->dwClassLen   = 0;           // fallback options don't have a class
    pRegBackupInfo->dwDataLen    = OptionDataSz * sizeof(DWORD);
    pRegBackupInfo->dwIsVendor   = 0;           // fallback options are not vendor options
    pRegBackupInfo->dwExpiryTime = 0x7fffffff;  // fallback options don't expire

    // add all the Option's data
    for (dwOptIdx = 0; dwOptIdx < OptionDataSz; dwOptIdx++)
    {
        pRegBackupInfo->dwData[dwOptIdx] = OptionData[dwOptIdx];
    }
    
    return S_OK;
}


HRESULT CTcpipcfg::HrLoadBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter)
{
    HRESULT hr = S_OK;
    
    //construct the string "Alternate_{Interface GUID}"
    tstring strConfigurationName = c_szAlternate;
    strConfigurationName += pAdapter->m_strBindName;

    // if ActiveConfigurations contain a string "Alternate_{Interface GUID}"
    // then there is customized fall-back settings, otherwise Autonet
    VSTR vstrTmp;

    pAdapter->m_BackupInfo.m_fAutoNet = TRUE;
    hr = HrRegQueryColString( hkeyInterfaceParam,
                              c_szActiveConfigurations,
                              &vstrTmp);
    if (SUCCEEDED(hr))
    {
        BOOL fFound = FALSE;
        for (int i = 0; i < (int)vstrTmp.size(); i++)
        {
            if (strConfigurationName == *vstrTmp[i])
            {
                pAdapter->m_BackupInfo.m_fAutoNet = FALSE;
                break;
            }
        }

        DeleteColString(&vstrTmp);
    }


    tstring strReg = c_szDhcpConfigurations;
    strReg += _T("\\");
    strReg += strConfigurationName;

    HKEY hkeyDhcpConfig = NULL;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strReg.c_str(),
                    KEY_READ, &hkeyDhcpConfig);
    if (SUCCEEDED(hr))
    {
        LPBYTE pBackupInfoForReg = NULL;
        DWORD cb = 0;
        
        hr = HrRegQueryBinaryWithAlloc(hkeyDhcpConfig,
                                      c_szConfigOptions,
                                      &pBackupInfoForReg,
                                      &cb);

        if (SUCCEEDED(hr))
        {
            LPBYTE pRaw;

            pRaw = pBackupInfoForReg;
            while (cb >= sizeof(REG_BACKUP_INFO))
            {
                REG_BACKUP_INFO *pOption;

                pOption = (REG_BACKUP_INFO *)pRaw;

                // don't forget REG_BACKUP_INFO already contains one DWORD from
                // the data section. Although the statememnts below are somehow identical
                // the compiler is expected to optimize the code: one constant generated
                // at compile time for sizeof(REG_BACKUP_INFO) - sizeof(DWORD), and one
                // register only used in both lines below.
                cb   -= sizeof(REG_BACKUP_INFO) - sizeof(DWORD);
                pRaw += sizeof(REG_BACKUP_INFO) - sizeof(DWORD);

                // since cb is DWORD take special care to avoid roll over
                if (cb < pOption->dwDataLen)
                    break;

                cb   -= pOption->dwDataLen;
                pRaw += pOption->dwDataLen;

                HrLoadBackupOption(pOption, &pAdapter->m_BackupInfo);
            }

            MemFree(pBackupInfoForReg);
        }

        RegSafeCloseKey(hkeyDhcpConfig);
    }

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        //it's ok if the reg values are missing
        hr = S_OK;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
// transfers data from the registry raw representation of the option
// to the corresponding fields from the BACKUP_CFG_INFO structure
//
HRESULT CTcpipcfg::HrLoadBackupOption(
        /*IN*/  REG_BACKUP_INFO *pOption,
        /*OUT*/ BACKUP_CFG_INFO *pBackupInfo)
{
    tstring *pIp1 = NULL;
    tstring *pIp2 = NULL;
    HRESULT hr = S_OK;

    // depending on what the option is, have pIp1 & pIp2 point to the 
    // fields to be filled in from BACKUP_CFG_INFO
    switch(pOption->dwOptionId)
    {
    case OPTION_REQUESTED_ADDRESS:
        pIp1 = &pBackupInfo->m_strIpAddr;
        break;
    case OPTION_SUBNET_MASK:
        pIp1 = &pBackupInfo->m_strSubnetMask;
        break;
    case OPTION_ROUTER_ADDRESS:
        pIp1 = &pBackupInfo->m_strDefGw;
        break;
    case OPTION_DOMAIN_NAME_SERVERS:
        pIp1 = &pBackupInfo->m_strPreferredDns;
        pIp2 = &pBackupInfo->m_strAlternateDns;
        break;
    case OPTION_NETBIOS_NAME_SERVER:
        pIp1 = &pBackupInfo->m_strPreferredWins;
        pIp2 = &pBackupInfo->m_strAlternateWins;
        break;
    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // each option has at least one IpAddress value
    DwordToIPString(ntohl(pOption->dwData[0]), *pIp1);

    // if the option has more than one IpAddress (meaning two :-)
    // and if it is supposed to allow 2 addresses to be specified
    // then fill up the second field as well.
    if (pOption->dwDataLen > sizeof(DWORD) && pIp2 != NULL)
        DwordToIPString(ntohl(pOption->dwData[1]), *pIp2);

    return hr;
}

//Cleanup the backup settings registry under System\Services\dhcp
// wszAdapterName       GUID of the adapter of which we want to delete the registry
HRESULT CTcpipcfg::HrDeleteBackupSettingsInDhcp(LPCWSTR wszAdapterName)
{
    HRESULT hr = S_OK;
    HKEY hkeyDhcpConfigs = NULL;
    HKEY hkeyDhcpCfg = NULL;
    DWORD dwDisposition = 0;
    tstring strConfigurationName = c_szAlternate;
    strConfigurationName += wszAdapterName;;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDhcpConfigurations,
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                    &hkeyDhcpConfigs, &dwDisposition);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrDeleteBackupSettingsInDhcp: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegDeleteKeyTree(hkeyDhcpConfigs, strConfigurationName.c_str());

    RegSafeCloseKey(hkeyDhcpConfigs);
LERROR:
    return hr;
}

HRESULT CTcpipcfg::HrSetSecurityForNetConfigOpsOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName)
{
    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;

    if (AllocateAndInitializeSid(&sidAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, 0, 0, 0, 0, 0, 0, &psidGroup))
    {
        CRegKeySecurity rkSecurity;

        hr = rkSecurity.RegOpenKey(hkeyRoot, strKeyName);

        if (SUCCEEDED(hr))
        {
            hr = rkSecurity.GetKeySecurity();
            if (SUCCEEDED(hr))
            {
                hr = rkSecurity.GetSecurityDescriptorDacl();
                if (SUCCEEDED(hr))
                {
                    hr = rkSecurity.GrantRightsOnRegKey(psidGroup, KEY_READ_WRITE_DELETE, KEY_ALL);
                }
            }
            rkSecurity.RegCloseKey();
        }

        FreeSid(psidGroup);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcperror.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P E R R O R . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcperror.h"
#include "tcputil.h"
#include "tcpconst.h"
#include "resource.h"

IP_VALIDATION_ERR IsValidIpandSubnet(PCWSTR szIp, PCWSTR szSubnet)
{
    IP_VALIDATION_ERR ret = ERR_NONE;

    DWORD dwAddr = IPStringToDword(szIp);
    DWORD dwMask = IPStringToDword(szSubnet);

    //The host ID cannot contain all 1's
    if ((dwMask | dwAddr) == 0xFFFFFFFF)
    {
        return ERR_HOST_ALL1;
    }

    if (((~dwMask) & dwAddr) == 0)
    {
        return ERR_HOST_ALL0;
    }

    if ((dwMask & dwAddr) == 0)
    {
        return ERR_SUBNET_ALL0;
    }


    DWORD ardwNetID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetNodeNum(szIp, ardwIp);
    GetNodeNum(szSubnet, ardwMask);



    INT nFirstByte = ardwIp[0] & 0xFF ;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    DWORD ardwHostID[4];

    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        ret = ERR_INCORRECT_IP;
    }

    return ret;
}


// return IP_VALIDATION_ERR

IP_VALIDATION_ERR ValidateIp(ADAPTER_INFO * const pAdapterInfo)
{
    IP_VALIDATION_ERR result = ERR_NONE;
    IP_VALIDATION_ERR tmp = ERR_NONE;

    Assert(pAdapterInfo != NULL);

    // if enable DHCP is false;
    if (!pAdapterInfo->m_fEnableDhcp)
    {
        // check the first pair of IP and subnet
        VSTR_ITER iterIpBegin = pAdapterInfo->m_vstrIpAddresses.begin();
        VSTR_ITER iterIpEnd = pAdapterInfo->m_vstrIpAddresses.end();
        VSTR_ITER iterIp = iterIpBegin;

        VSTR_ITER iterSubnetMaskBegin = pAdapterInfo->m_vstrSubnetMask.begin();
        VSTR_ITER iterSubnetMaskEnd = pAdapterInfo->m_vstrSubnetMask.end();
        VSTR_ITER iterSubnetMask = iterSubnetMaskBegin;

        BOOL fSwap = FALSE;

        // If ip address and subnet are both empty
        if((iterIp == iterIpEnd) && (iterSubnetMask == iterSubnetMaskEnd))
        {
            result = ERR_NO_IP;
        }
        else
        {
            for( ;
                 iterIp != iterIpEnd || iterSubnetMask != iterSubnetMaskEnd ;
                 ++iterIp, ++iterSubnetMask)
            {
                if((iterIp == iterIpEnd || **iterIp == L"") && !fSwap)
                {
                    result = ERR_NO_IP;
                    fSwap = TRUE;
                }
                else if((iterSubnetMask == iterSubnetMaskEnd || **iterSubnetMask == L"") && !fSwap)
                {
                    result = ERR_NO_SUBNET;
                    fSwap = TRUE;
                }
                else if(!IsContiguousSubnet((*iterSubnetMask)->c_str()))
                {
                    result = ERR_UNCONTIGUOUS_SUBNET;
                    fSwap = TRUE;
                }
                else if(ERR_NONE != (tmp = IsValidIpandSubnet((*iterIp)->c_str(), (*iterSubnetMask)->c_str())) && !fSwap)
                {
                    result = tmp;
                    fSwap = TRUE;
                }
                

                if(fSwap)
                {
                    tstring * pstrTmp;

                    pstrTmp = *iterIp;
                    *iterIp = *iterIpBegin;
                    *iterIpBegin = pstrTmp;

                    pstrTmp = *iterSubnetMask;
                    *iterSubnetMask = *iterSubnetMaskBegin;
                    *iterSubnetMaskBegin = pstrTmp;

                    break;
                }
            }
        }
    }

    return result;
}

// return >=0   : the adapter that has the duplicate address
// return -1    : all is ok

// Check from duplicate IP address between the adapter in pAdapterInfo and
// any different, enabled, LAN adapters in the pvcardAdapterInfo list
int CheckForDuplicates(const VCARD * pvcardAdapterInfo,
                       ADAPTER_INFO * pAdapterInfo,
                       tstring& strIp)
{
    int nResult = -1;

    Assert(pvcardAdapterInfo != NULL);
    Assert(pAdapterInfo != NULL);
    Assert(!pAdapterInfo->m_fEnableDhcp);

    for(size_t i = 0; ((i < pvcardAdapterInfo->size()) && (nResult == -1)) ; ++i)
    {
        VSTR_ITER iterCompareIpBegin;
        VSTR_ITER iterCompareIpEnd;

        if ((*pvcardAdapterInfo)[i]->m_guidInstanceId ==
            pAdapterInfo->m_guidInstanceId)
        {
            // same adapter
            continue;
        }
        else
        {
            // different adapter

            // Skip the following:
            // 1) disabled adapter
            // 2) ndiswan adapter
            // 3) Dhcp enabled adapter
            // 4) RAS Fake adapters
            if(((*pvcardAdapterInfo)[i]->m_BindingState != BINDING_ENABLE) ||
               ((*pvcardAdapterInfo)[i]->m_fIsWanAdapter) ||
               ((*pvcardAdapterInfo)[i]->m_fEnableDhcp) ||
               ((*pvcardAdapterInfo)[i]->m_fIsRasFakeAdapter))
                continue;

            iterCompareIpBegin = (*pvcardAdapterInfo)[i]->m_vstrIpAddresses.begin();
            iterCompareIpEnd = (*pvcardAdapterInfo)[i]->m_vstrIpAddresses.end();
        }

        VSTR_ITER iterCompareIp = iterCompareIpBegin;

        for ( ; iterCompareIp != iterCompareIpEnd; ++iterCompareIp)
        {
            if(**iterCompareIp == strIp) // if duplicate IP address found
            {
                nResult = i;
                break;

                /*
                nCompareCount++;
                if (nCompareCount >= 1)
                {
                    nResult = i;

                    tstring * pstrTmp;

                    // swap the Current Compared IP and Subnet Mask with the
                    // first IP and first subnetmask that are duplicates

                    pstrTmp = *iterIp;
                    *iterIp = *iterIpBegin;
                    *iterIpBegin = pstrTmp;

                    pstrTmp = *iterSubnetMask;
                    *iterSubnetMask = *iterSubnetMaskBegin;
                    *iterSubnetMaskBegin = pstrTmp;

                    break;
                }
                */
            }
        }
    }

    return nResult;
}

BOOL FHasDuplicateIp(ADAPTER_INFO * pAdapterInfo)
{
    Assert(pAdapterInfo);
    Assert(!pAdapterInfo->m_fEnableDhcp);

    BOOL fDup = FALSE;

    VSTR_ITER iterIpBegin = pAdapterInfo->m_vstrIpAddresses.begin();
    VSTR_ITER iterIpEnd = pAdapterInfo->m_vstrIpAddresses.end();

    VSTR_ITER iterIp = iterIpBegin;

    for( ; ((iterIp != iterIpEnd) && (!fDup)) ; ++iterIp)
    {
        // check only IP addresses one by one
        VSTR_ITER iterCompareIpBegin = iterIp+1;
        VSTR_ITER iterCompareIpEnd = pAdapterInfo->m_vstrIpAddresses.end();

        VSTR_ITER iterCompareIp = iterCompareIpBegin;

        for ( ; iterCompareIp != iterCompareIpEnd; ++iterCompareIp)
        {
            if(**iterCompareIp == **iterIp) // if duplicate IP address found
            {
                fDup = TRUE;
                break;
            }
        }
    }
    return fDup;
}

//Check if all the fields of the IP address are valid
//Arguments: szIp       the IP address
//           fIsIpAddr  whether the szIp is IP address (otherwise, it should be subnet mask)
//                      if szIp is IP address, it's first field should be between 1 and 223, 
//                       and cannot be 127 (loopback address)
BOOL FIsValidIpFields(PCWSTR szIp, BOOL fIsIpAddr)
{
    BOOL fRet = TRUE;

    DWORD ardwIp[4];
    GetNodeNum(szIp, ardwIp);

    // if the address is IP, there are some special rules for its first field
    if (fIsIpAddr && (ardwIp[0] < c_iIPADDR_FIELD_1_LOW || ardwIp[0] > c_iIPADDR_FIELD_1_HIGH ||
        ardwIp[0] == c_iIPADDR_FIELD_1_LOOPBACK))
    {
        fRet = FALSE;
    }
    else
    {
        //if the address is IP, then we have already validate the first field. Otherwise, we need
        // valid the first field here.
        for (INT i = (fIsIpAddr) ? 1 : 0; i < 4; i++)
        {
#pragma warning(push)
#pragma warning(disable:4296)
            if (ardwIp[i] < (DWORD)c_iIpLow || ardwIp[i] > c_iIpHigh)
            {
                fRet = FALSE;
                break;
            }
#pragma warning(pop)
        }
    }

    return fRet;
}

//Get the resource ID of the error message based on the IP validation err
UINT GetIPValidationErrorMessageID(IP_VALIDATION_ERR err)
{
    UINT uID = 0;
    switch(err)
    {
    case ERR_NONE:
        uID = 0;
        break;
    case ERR_HOST_ALL0:
        uID = IDS_INVALID_HOST_ALL_0;
        break;
    case ERR_HOST_ALL1:
        uID = IDS_INVALID_HOST_ALL_1;
        break;
    case ERR_SUBNET_ALL0:
        uID = IDS_INVALID_SUBNET_ALL_0;
        break;
    case ERR_INCORRECT_IP:
        uID = IDS_INCORRECT_IPADDRESS;
        break;
    case ERR_NO_IP:
        uID = IDS_INVALID_NO_IP;
        break;
    case ERR_NO_SUBNET:
        uID = IDS_INVALID_NOSUBNET;
        break;
    case ERR_UNCONTIGUOUS_SUBNET:
        uID = IDS_ERROR_UNCONTIGUOUS_SUBNET;
        break;
    default:
        uID = IDS_INCORRECT_IPADDRESS;
        break;
    }

    return uID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcphelp.h ===
#define	IDH_CHK_ATM_PVCONLY	110000050
#define	IDH_CHK_USE_COMPRESSION	110000501
#define	IDH_CMB_FRAME_SIZE	110000502
//IPSec is removed from connection UI	
//#define	IDH_CMB_IPSEC_POLICY_LIST	110000452
#define	IDH_DNS_ADDR_REG	110000566
#define	IDH_DNS_CHANGE_SERVER	110000100
#define	IDH_DNS_CHANGE_SUFFIX	110000150
#define	IDH_DNS_DHCP	110000605
#define	IDH_DNS_DOMAIN	110000556
#define	IDH_DNS_FIXED	110000606
#define	IDH_DNS_NAME_REG	110000567
#define	IDH_DNS_PRIMARY	110000607
#define	IDH_DNS_SEARCH_DOMAIN	110000557
#define	IDH_DNS_SEARCH_PARENT_DOMAIN	110000558
#define	IDH_DNS_SECONDARY	110000608
#define	IDH_DNS_SERVER_ADD	110000553
#define	IDH_DNS_SERVER_DOWN	110000552
#define	IDH_DNS_SERVER_EDIT	110000554
#define	IDH_DNS_SERVER_LIST	110000550
#define	IDH_DNS_SERVER_REMOVE	110000555
#define	IDH_DNS_SERVER_UP	110000551
#define	IDH_DNS_SUFFIX_ADD	110000563
#define	IDH_DNS_SUFFIX_DOWN	110000562
#define	IDH_DNS_SUFFIX_EDIT	110000564
#define	IDH_DNS_SUFFIX_LIST	110000560
#define	IDH_DNS_SUFFIX_REMOVE	110000565
#define	IDH_DNS_SUFFIX_UP	110000561
#define	IDH_DNS_USE_SUFFIX_LIST	110000559
#define	IDH_EDT_ATM_Address	110000000
#define	IDH_EDT_ATM_MaxTU	110000063
//IPSec is removed from connection UI	
//#define	IDH_EDT_POLICY_DESC	110000453
#define	IDH_FILTERING_ADD_EDIT	110000250
#define	IDH_FILTERING_ENABLE	110000200
#define	IDH_FILTERING_FILTER_IP	110000211
#define	IDH_FILTERING_FILTER_IP_SEL	110000212
#define	IDH_FILTERING_FILTER_TCP	110000201
#define	IDH_FILTERING_FILTER_TCP_SEL	110000202
#define	IDH_FILTERING_FILTER_UDP	110000206
#define	IDH_FILTERING_FILTER_UDP_SEL	110000207
#define	IDH_FILTERING_IP	110000213
#define	IDH_FILTERING_IP_ADD	110000214
#define	IDH_FILTERING_IP_REMOVE	110000215
#define	IDH_FILTERING_TCP	110000203
#define	IDH_FILTERING_TCP_ADD	110000204
#define	IDH_FILTERING_TCP_REMOVE	110000205
#define	IDH_FILTERING_UDP	110000208
#define	IDH_FILTERING_UDP_ADD	110000209
#define	IDH_FILTERING_UDP_REMOVE	110000210
#define	IDH_IP_DHCP	110000600
#define	IDH_IP_FIXED	110000601
#define	IDH_IPADDR_ADDGATE	110000305
#define	IDH_IPADDR_ADDIP	110000301
#define	IDH_IPADDR_ADV_CHANGE_GATEWAY	110000350
#define	IDH_IPADDR_ADV_CHANGE_METRIC	110000351
#define	IDH_IPADDR_ADV_CHANGEIP_IP	110000400
#define	IDH_IPADDR_ADV_CHANGEIP_SUB	110000401
#define	IDH_IPADDR_ADVANCED	110000609
#define	IDH_IPADDR_ADVIP	110000300
#define	IDH_IPADDR_EDITGATE	110000306
#define	IDH_IPADDR_EDITIP	110000302
#define	IDH_IPADDR_GATE	110000304
#define	IDH_IPADDR_GATE_TCP	110000604
#define	IDH_IPADDR_IP	110000602
#define	IDH_IPADDR_METRIC	110000308
#define IDH_AUTO_METRIC 110000309
#define	IDH_IPADDR_REMOVEGATE	110000307
#define	IDH_IPADDR_REMOVEIP	110000303
#define	IDH_IPADDR_SUB	110000603
#define	IDH_LBX_ATM_ArpsAddrs	110000051
#define	IDH_LBX_ATM_MarsAddrs	110000057
#define	IDH_LVW_OPTIONS	110000700
#define	IDH_OPT_DESC	110000702
#define	IDH_OPT_PROPERTIES	110000701
#define	IDH_PSB_ATM_ArpsAdd	110000054
#define	IDH_PSB_ATM_ArpsDown	110000053
#define	IDH_PSB_ATM_ArpsEdt	110000055
#define	IDH_PSB_ATM_ArpsRmv	110000056
#define	IDH_PSB_ATM_ArpsUp	110000052
#define	IDH_PSB_ATM_MarsAdd	110000060
#define	IDH_PSB_ATM_MarsDown	110000059
#define	IDH_PSB_ATM_MarsEdt	110000061
#define	IDH_PSB_ATM_MarsRmv	110000062
#define	IDH_PSB_ATM_MarsUp	110000058
#define	IDH_RAD_DISABLE_NETBT	110000759
#define	IDH_RAD_ENABLE_NETBT	110000758
//IPSec is removed from connection UI	
//#define	IDH_RAD_IPSEC_CUSTOM	110000451
//#define	IDH_RAD_IPSEC_NOIPSEC	110000450
#define	IDH_RAD_UNSET_NETBT	110000760
#define	IDH_REMOTE_GATEWAY	110000500
#define	IDH_WINS_ADD	110000753
#define	IDH_WINS_CHANGE_SERVER	110000800
#define	IDH_WINS_DOWN	110000752
#define	IDH_WINS_EDIT	110000754
#define	IDH_WINS_LMHOST	110000757
#define	IDH_WINS_LOOKUP	110000756
#define	IDH_WINS_REMOVE	110000755
#define	IDH_WINS_SERVER_LIST	110000750
#define	IDH_WINS_UP	110000751

#define	IDH_AC_APIPA	110000850
#define	IDH_AC_USRCFG	110000851
#define	IDH_AC_IPADDR	110000852
#define	IDH_AC_SUBMASK	110000853
#define	IDH_AC_DG		110000854
#define	IDH_AC_DNS_PRE	110000855
#define	IDH_AC_DNS_ALT	110000856
#define	IDH_AC_WINS_PRE	110000857
#define	IDH_AC_WINS_ALT	110000858

const DWORD g_aHelpIDs_IDD_ATM_ADDR[]=
{
	IDC_EDT_ATM_Address,IDH_EDT_ATM_Address,
	0,0
};

const DWORD g_aHelpIDs_IDD_ATM_ARPC[]=
{
	IDC_PSB_ATM_MarsAdd,IDH_PSB_ATM_MarsAdd,
	IDC_EDT_ATM_MaxTU,IDH_EDT_ATM_MaxTU,
	IDC_PSB_ATM_MarsEdt,IDH_PSB_ATM_MarsEdt,
	IDC_PSB_ATM_MarsDown,IDH_PSB_ATM_MarsDown,
	IDC_PSB_ATM_MarsUp,IDH_PSB_ATM_MarsUp,
	IDC_LBX_ATM_MarsAddrs,IDH_LBX_ATM_MarsAddrs,
	IDC_PSB_ATM_ArpsEdt,IDH_PSB_ATM_ArpsEdt,
	IDC_PSB_ATM_ArpsAdd,IDH_PSB_ATM_ArpsAdd,
	IDC_PSB_ATM_ArpsDown,IDH_PSB_ATM_ArpsDown,
	IDC_PSB_ATM_MarsRmv,IDH_PSB_ATM_MarsRmv,
	IDC_PSB_ATM_ArpsUp,IDH_PSB_ATM_ArpsUp,
	IDC_LBX_ATM_ArpsAddrs,IDH_LBX_ATM_ArpsAddrs,
	IDC_CHK_ATM_PVCONLY,IDH_CHK_ATM_PVCONLY,
	IDC_PSB_ATM_ArpsRmv,IDH_PSB_ATM_ArpsRmv,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DNS_SERVER[]=
{
	IDC_DNS_CHANGE_SERVER,IDH_DNS_CHANGE_SERVER,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DNS_SUFFIX[]=
{
	IDC_DNS_CHANGE_SUFFIX,IDH_DNS_CHANGE_SUFFIX,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER[]=
{
	IDC_FILTERING_FILTER_UDP,IDH_FILTERING_FILTER_UDP,
	IDC_FILTERING_IP_ADD,IDH_FILTERING_IP_ADD,
	IDC_FILTERING_IP,IDH_FILTERING_IP,
	IDC_FILTERING_FILTER_IP_SEL,IDH_FILTERING_FILTER_IP_SEL,
	IDC_FILTERING_FILTER_IP,IDH_FILTERING_FILTER_IP,
	IDC_FILTERING_UDP_REMOVE,IDH_FILTERING_UDP_REMOVE,
	IDC_FILTERING_UDP_ADD,IDH_FILTERING_UDP_ADD,
	IDC_FILTERING_IP_REMOVE,IDH_FILTERING_IP_REMOVE,
	IDC_FILTERING_TCP_REMOVE,IDH_FILTERING_TCP_REMOVE,
	IDC_FILTERING_TCP_ADD,IDH_FILTERING_TCP_ADD,
	IDC_FILTERING_TCP,IDH_FILTERING_TCP,
	IDC_FILTERING_FILTER_TCP_SEL,IDH_FILTERING_FILTER_TCP_SEL,
	IDC_FILTERING_FILTER_TCP,IDH_FILTERING_FILTER_TCP,
	IDC_FILTERING_ENABLE,IDH_FILTERING_ENABLE,
	IDC_FILTERING_FILTER_UDP_SEL,IDH_FILTERING_FILTER_UDP_SEL,
	IDC_FILTERING_UDP,IDH_FILTERING_UDP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER_ADD[]=
{
	IDC_FILTERING_TEXT, IDH_FILTERING_ADD_EDIT,
	IDC_FILTERING_ADD_EDIT,IDH_FILTERING_ADD_EDIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV[]=
{
	IDC_IPADDR_ADDIP,IDH_IPADDR_ADDIP,
    IDC_AUTO_METRIC, IDH_AUTO_METRIC,
	IDC_STATIC_IF_METRIC,IDH_IPADDR_METRIC,
	IDC_IPADDR_METRIC,IDH_IPADDR_METRIC,
	IDC_IPADDR_REMOVEGATE,IDH_IPADDR_REMOVEGATE,
	IDC_IPADDR_EDITGATE,IDH_IPADDR_EDITGATE,
	IDC_IPADDR_ADDGATE,IDH_IPADDR_ADDGATE,
	IDC_IPADDR_GATE,IDH_IPADDR_GATE,
	IDC_IPADDR_EDITIP,IDH_IPADDR_EDITIP,
	IDC_IPADDR_ADVIP,IDH_IPADDR_ADVIP,
	IDC_IPADDR_REMOVEIP,IDH_IPADDR_REMOVEIP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE[]=
{
	IDC_IPADDR_ADV_CHANGE_GATEWAY,IDH_IPADDR_ADV_CHANGE_GATEWAY,
	IDC_IPADDR_ADV_CHANGE_METRIC,IDH_IPADDR_ADV_CHANGE_METRIC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP[]=
{
	IDC_IPADDR_ADV_CHANGEIP_IP,IDH_IPADDR_ADV_CHANGEIP_IP,
	IDC_IPADDR_ADV_CHANGEIP_SUB,IDH_IPADDR_ADV_CHANGEIP_SUB,
	0, 0
};

/* IP Security dialog is removed
const DWORD g_aHelpIDs_IDD_IPSEC[]=
{
	IDC_CMB_IPSEC_POLICY_LIST,IDH_CMB_IPSEC_POLICY_LIST,
	IDC_RAD_IPSEC_NOIPSEC,IDH_RAD_IPSEC_NOIPSEC,
	IDC_EDT_POLICY_DESC,IDH_EDT_POLICY_DESC,
	IDC_RAD_IPSEC_CUSTOM,IDH_RAD_IPSEC_CUSTOM,
	0, 0
};
*/

const DWORD g_aHelpIDs_IDD_OPT_RAS[]=
{
	IDC_REMOTE_GATEWAY,IDH_REMOTE_GATEWAY,
	IDC_CHK_USE_COMPRESSION,IDH_CHK_USE_COMPRESSION,
	IDC_STATIC_FRAME_SIZE,IDH_CMB_FRAME_SIZE,
	IDC_CMB_FRAME_SIZE,IDH_CMB_FRAME_SIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_DNS[]=
{
	IDC_DNS_SEARCH_DOMAIN,IDH_DNS_SEARCH_DOMAIN,
	IDC_DNS_ADDR_REG,IDH_DNS_ADDR_REG,
	IDC_DNS_SUFFIX_REMOVE,IDH_DNS_SUFFIX_REMOVE,
	IDC_DNS_SUFFIX_EDIT,IDH_DNS_SUFFIX_EDIT,
	IDC_DNS_SUFFIX_ADD,IDH_DNS_SUFFIX_ADD,
	IDC_DNS_SUFFIX_DOWN,IDH_DNS_SUFFIX_DOWN,
	IDC_DNS_SUFFIX_UP,IDH_DNS_SUFFIX_UP,
	IDC_DNS_SUFFIX_LIST,IDH_DNS_SUFFIX_LIST,
	IDC_DNS_SEARCH_PARENT_DOMAIN,IDH_DNS_SEARCH_PARENT_DOMAIN,
	IDC_DNS_NAME_REG,IDH_DNS_NAME_REG,
	IDC_DNS_DOMAIN_STATIC,IDH_DNS_DOMAIN,
	IDC_DNS_DOMAIN,IDH_DNS_DOMAIN,
	IDC_DNS_SERVER_REMOVE,IDH_DNS_SERVER_REMOVE,
	IDC_DNS_SERVER_EDIT,IDH_DNS_SERVER_EDIT,
	IDC_DNS_SERVER_ADD,IDH_DNS_SERVER_ADD,
	IDC_DNS_SERVER_DOWN,IDH_DNS_SERVER_DOWN,
	IDC_DNS_SERVER_UP,IDH_DNS_SERVER_UP,
	IDC_DNS_SERVER_LIST,IDH_DNS_SERVER_LIST,
	IDC_DNS_USE_SUFFIX_LIST,IDH_DNS_USE_SUFFIX_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_IPADDR[]=
{
	IDC_DNS_DHCP,IDH_DNS_DHCP,
	IDC_DNS_SECONDARY_TEXT,IDH_DNS_SECONDARY,
	IDC_DNS_SECONDARY,IDH_DNS_SECONDARY,
	IDC_IPADDR_ADVANCED,IDH_IPADDR_ADVANCED,
	IDC_DNS_PRIMARY_TEXT,IDH_DNS_PRIMARY,
	IDC_DNS_PRIMARY,IDH_DNS_PRIMARY,
	IDC_DNS_FIXED,IDH_DNS_FIXED,
	IDC_IPADDR_SUBTEXT,IDH_IPADDR_SUB,
	IDC_IPADDR_SUB,IDH_IPADDR_SUB,
	IDC_IPADDR_IPTEXT,IDH_IPADDR_IP,
	IDC_IPADDR_IP,IDH_IPADDR_IP,
	IDC_IP_DHCP,IDH_IP_DHCP,
	IDC_IPADDR_GATETEXT,IDH_IPADDR_GATE_TCP,
	IDC_IPADDR_GATE,IDH_IPADDR_GATE_TCP,
	IDC_IP_FIXED,IDH_IP_FIXED,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_IPADDR_RAS[]=
{
	IDC_DNS_DHCP,IDH_DNS_DHCP,
	IDC_DNS_SECONDARY_TEXT,IDH_DNS_SECONDARY,
	IDC_DNS_SECONDARY,IDH_DNS_SECONDARY,
	IDC_IPADDR_ADVANCED,IDH_IPADDR_ADVANCED,
	IDC_DNS_PRIMARY_TEXT,IDH_DNS_PRIMARY,
	IDC_DNS_PRIMARY,IDH_DNS_PRIMARY,
	IDC_DNS_FIXED,IDH_DNS_FIXED,
	IDC_IPADDR_IPTEXT,IDH_IPADDR_IP,
	IDC_IPADDR_IP,IDH_IPADDR_IP,
	IDC_IP_DHCP,IDH_IP_DHCP,
	IDC_IP_FIXED,IDH_IP_FIXED,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_OPTIONS[]=
{
	IDC_LVW_OPTIONS,IDH_LVW_OPTIONS,
	IDC_OPT_PROPERTIES,IDH_OPT_PROPERTIES,
	IDC_OPT_DESC,IDH_OPT_DESC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_WINS[]=
{
	IDC_WINS_UP,IDH_WINS_UP,
	IDC_STATIC_DEFALUT_NBT,IDH_RAD_UNSET_NETBT,
	IDC_RAD_UNSET_NETBT,IDH_RAD_UNSET_NETBT,
	IDC_RAD_DISABLE_NETBT,IDH_RAD_DISABLE_NETBT,
	IDC_RAD_ENABLE_NETBT,IDH_RAD_ENABLE_NETBT,
	IDC_WINS_LMHOST,IDH_WINS_LMHOST,
	IDC_WINS_LOOKUP,IDH_WINS_LOOKUP,
	IDC_WINS_REMOVE,IDH_WINS_REMOVE,
	IDC_WINS_EDIT,IDH_WINS_EDIT,
	IDC_WINS_DOWN,IDH_WINS_DOWN,
	IDC_WINS_SERVER_LIST,IDH_WINS_SERVER_LIST,
	IDC_WINS_ADD,IDH_WINS_ADD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WINS_SERVER[]=
{
	IDC_WINS_CHANGE_SERVER,IDH_WINS_CHANGE_SERVER,
	0, 0
};

const DWORD g_aHelpIDS_IDD_BACK_UP[]=
{
    IDC_BKUP_RD_AUTO,IDH_AC_APIPA,
	IDC_BKUP_RD_USER,IDH_AC_USRCFG,
	IDC_BKUP_IPADDR_TEXT,IDH_AC_IPADDR,
	IDC_BKUP_IPADDR,IDH_AC_IPADDR,
	IDC_BKUP_SUBNET_TEXT,IDH_AC_SUBMASK,
	IDC_BKUP_SUBNET,IDH_AC_SUBMASK,
	IDC_BKUP_GATEWAY_TEXT,IDH_AC_DG,
	IDC_BKUP_GATEWAY,IDH_AC_DG,
	IDC_BKUP_PREF_DNS_TEXT,IDH_AC_DNS_PRE,
	IDC_BKUP_PREF_DNS,IDH_AC_DNS_PRE,
	IDC_BKUP_ALT_DNS_TEXT,IDH_AC_DNS_ALT,
	IDC_BKUP_ALT_DNS,IDH_AC_DNS_ALT,
	IDC_BKUP_WINS1_TEXT,IDH_AC_WINS_PRE,
	IDC_BKUP_WINS1,IDH_AC_WINS_PRE,
	IDC_WINS2_TEXT,IDH_AC_WINS_ALT,
	IDC_BKUP_WINS2,IDH_AC_WINS_ALT,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpconst.h ===
//
// T C P C O N S T . H
//
// Constants used in tcpipcfg
//

#pragma once

#define TCH_QUESTION_MARK   L'?'
#define CH_DOT              L'.'
#define BACK_SLASH          L'\\'

static const WCHAR  c_chListSeparator  = L',';

// 0 - 9999 seconds
#define MIN_HOPSTHRESHOLD       0
#define MAX_HOPSTHRESHOLD       16
#define DEF_HOPSTHRESHOLD       4

#define MIN_SECSTHRESHOLD       0
#define MAX_SECSTHRESHOLD       0x270F
#define DEF_SECSTHRESHOLD       4

// Tcpip
#define RGAS_TCPIP_PARAM_INTERFACES     L"Tcpip\\Parameters\\Interfaces\\"

// Tcpip global Parameter
#define RGAS_NAMESERVER         L"NameServer"
#define RGAS_HOSTNAME           L"Hostname"
#define RGAS_NVHOSTNAME         L"NV Hostname"

#define RGAS_DOMAIN             L"Domain"
#define RGAS_SEARCHLIST         L"SearchList"
#define RGAS_SECURITY_ENABLE    L"EnableSecurityFilters"

// Tcpip adapter Parameter
#define RGAS_LLINTERFACE        L"LLInterface"
#define RGAS_IPCONFIG           L"IpConfig"
#define RGAS_IPINTERFACES       L"IpInterfaces"
#define RGAS_NUMINTERFACES      L"NumInterfaces"

// Tcpip interface Parameter

// NTEContextLists, used to preserve the value when a WAN card becomes
// support multiple interfaces
#define RGAS_NTECONTEXTLIST        L"NTEContextList"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_ENABLE_DHCP        L"EnableDHCP"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_DEFAULTGATEWAY     L"DefaultGateway"
#define RGAS_DEFAULTGATEWAYMETRIC   L"DefaultGatewayMetric"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_IPADDRESS          L"IPAddress"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_SUBNETMASK         L"SubnetMask"

#define RGAS_FILTERING_TCP       L"TCPAllowedPorts"
#define RGAS_FILTERING_UDP       L"UDPAllowedPorts"
#define RGAS_FILTERING_IP        L"RawIPAllowedProtocols"

#define RGAS_USEZEROBROADCAST   L"UseZeroBroadcast"

// Wins global parameter
#define RGAS_ENABLE_DNS         L"EnableDNS"
#define RGAS_ENABLE_LMHOSTS     L"EnableLMHOSTS"

// Wins interface parameter
#define RGAS_PRIMARY_WINS       L"NameServer"
#define RGAS_SECONDARY_WINS     L"NameServerBackup"

// DHCP options
#define RGAS_REG_LOCATION                   L"RegLocation"

// Notify RAS team to update Load\SaveTcpipInfo if this changes
#define RGAS_DHCP_IPADDRESS                 L"DhcpIPAddress"

// Notify RAS team to update Load\SaveTcpipInfo if this changes
#define RGAS_DHCP_SUBNETMASK                L"DhcpSubnetMask"

#define RGAS_DHCP_OPTIONS                   L"System\\CurrentControlSet\\Services\\DHCP\\Parameters\\Options"
#define RGAS_DHCP_OPTION_IPADDRESS          L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpIPAddress"
#define RGAS_DHCP_OPTION_SUBNETMASK         L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpSubnetMask"
#define RGAS_DHCP_OPTION_NAMESERVERBACKUP   L"System\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\?\\DhcpNameServerBackup"

// LmHosts
#define RGAS_LMHOSTS_PATH          L"\\drivers\\etc\\lmhosts"
#define RGAS_LMHOSTS_PATH_BACKUP   L"\\drivers\\etc\\lmhosts.bak"

// Components
const WCHAR c_szTcpip[] =       L"Tcpip";
const WCHAR c_szNetBt[] =       L"NetBT";
const WCHAR c_szDhcp[] =        L"DHCP";

// Constant strings
extern const WCHAR c_szEmpty[];

const WCHAR     c_mszNull[] = L"\0";
const WCHAR     c_szDisableFiltering[] = L"0";
const WCHAR     c_szAdaptersRegKey[] = L"Adapters";

// Notify RAS team to update Load\SaveTcpipInfo
const WCHAR     c_szInterfacesRegKey[] = L"Interfaces";

// Notify RAS team to update Load\SaveTcpipInfo
const WCHAR     c_szTcpip_[] = L"Tcpip_";

// LLInterface values ( for ARP modules )
const WCHAR     c_szWanArp[] = L"WANARP";
const WCHAR     c_szAtmArp[] = L"ATMARPC";
const WCHAR     c_sz1394Arp[] = L"ARP1394";
const WCHAR     c_szAtmarpc[] = L"AtmArpC";

// Other constants
const int c_cchRemoveCharatersFromEditOrAddButton = 3;

const WCHAR c_szBASE_SUBNET_MASK_1[] =  L"255.0.0.0";
const WCHAR c_szBASE_SUBNET_MASK_2[] =  L"255.255.0.0";
const WCHAR c_szBASE_SUBNET_MASK_3[] =  L"255.255.255.0";

const BYTE  SUBNET_RANGE_1_MAX   =   127;
const BYTE  SUBNET_RANGE_2_MAX   =   191;
const BYTE  SUBNET_RANGE_3_MAX   =   223;

// Default range for IP address fields
const int c_iIpLow =0;
const int c_iIpHigh = 255;
const int c_iEmptyIpField = -1;

// IP address field range
const int c_iIPADDR_FIELD_1_LOW = 1;
const int c_iIPADDR_FIELD_1_HIGH = 223;

// IP loopback address
const int c_iIPADDR_FIELD_1_LOOPBACK = 127;

// Ip address length
const int IP_LIMIT  = 32;

const WCHAR c_szItoa[] = L"%d";

// ATM ARP client parameters
// Configurable parameters
const WCHAR c_szREG_ARPServerList[] = L"ARPServerList";
const WCHAR c_szREG_MARServerList[] = L"MARServerList";
const WCHAR c_szREG_MTU[] = L"MTU";
const WCHAR c_szREG_PVCOnly[] = L"PVCOnly";

const WCHAR c_szDefaultAtmArpServer[] = L"4700790001020000000000000000A03E00000200";
const WCHAR c_szDefaultAtmMarServer[] = L"4700790001020000000000000000A03E00000200";
const DWORD c_dwDefaultAtmMTU = 9180;

// Static parameters
const WCHAR c_szREG_SapSelector[] = L"SapSelector";
const WCHAR c_szREG_AddressResolutionTimeout[] = L"AddressResolutionTimeout";
const WCHAR c_szREG_ARPEntryAgingTimeout[] = L"ARPEntryAgingTimeout";
const WCHAR c_szREG_InARPWaitTimeout[] = L"InARPWaitTimeout";
const WCHAR c_szREG_MaxRegistrationAttempts[] = L"MaxRegistrationAttempts";
const WCHAR c_szREG_MaxResolutionAttempts[] = L"MaxResolutionAttempts";
const WCHAR c_szREG_MinWaitAfterNak[] = L"MinWaitAfterNak";
const WCHAR c_szREG_ServerConnectInterval[] = L"ServerConnectInterval";
const WCHAR c_szREG_ServerRefreshTimeout[] = L"ServerRefreshTimeout";
const WCHAR c_szREG_ServerRegistrationTimeout[] = L"ServerRegistrationTimeout";
const WCHAR c_szREG_DefaultVcAgingTimeout[] = L"DefaultVcAgingTimeout";
const WCHAR c_szREG_MARSConnectInterval[] = L"MARSConnectInterval";
const WCHAR c_szREG_MARSRegistrationTimeout[] = L"MARSRegistrationTimeout";
const WCHAR c_szREG_JoinTimeout[] = L"JoinTimeout";
const WCHAR c_szREG_LeaveTimeout[] = L"LeaveTimeout";
const WCHAR c_szREG_MaxDelayBetweenMULTIs[] = L"MaxDelayBetweenMULTIs";

const DWORD c_dwSapSelector= 1;
const DWORD c_dwAddressResolutionTimeout= 3;
const DWORD c_dwARPEntryAgingTimeout= 900;
const DWORD c_dwInARPWaitTimeout= 5;
const DWORD c_dwMaxRegistrationAttempts= 5;
const DWORD c_dwMaxResolutionAttempts= 4;
const DWORD c_dwMinWaitAfterNak= 10;
const DWORD c_dwServerConnectInterval= 5;
const DWORD c_dwServerRefreshTimeout= 900;
const DWORD c_dwServerRegistrationTimeout= 3;
const DWORD c_dwDefaultVcAgingTimeout= 60;
const DWORD c_dwMARSConnectInterval= 5;
const DWORD c_dwMARSRegistrationTimeout= 3;
const DWORD c_dwJoinTimeout= 10;
const DWORD c_dwLeaveTimeout= 10;
const DWORD c_dwMaxDelayBetweenMULTIs= 10;

// Reg value
const WCHAR  c_szIpEnableRouter[] = L"IPEnableRouter";
const WCHAR  c_szPerformRouterDiscovery[] =  L"PerformRouterDiscovery";
const WCHAR  c_szInterfaceMetric[] = L"InterfaceMetric";

//(nsun) added to support unattended install for RRAS (global settings)
const WCHAR c_szEnableICMPRedirect[] = L"EnableICMPRedirect";
const WCHAR c_szPerformRouterDiscoveryDefault[] = L"PerformRouterDiscoveryDefault";
const WCHAR c_szDeadGWDetectDefault[] = L"DeadGWDetectDefault";
const WCHAR c_szDontAddDefaultGatewayDefault[] = L"DontAddDefaultGatewayDefault";

//(nsun) added to support unattended install for RRAS (per interface settings)
const WCHAR c_szDeadGWDetect[] = L"EnableDeadGWDetect";
const WCHAR c_szDontAddDefaultGateway[] = L"DontAddDefaultGateway";


const WCHAR  c_szSearchList[] = L"SearchList";
const WCHAR  c_szUseDomainNameDevolution[] = L"UseDomainNameDevolution";
const WCHAR  c_szSvcDnsServer[] = L"DNS";

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_NETBT_NAMESERVERLIST   L"NameServerList"
#define RGAS_NETBT_NETBIOSOPTIONS   L"NetbiosOptions"

// Dhcp parameter key
const WCHAR c_szDhcpParam[] = L"SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters";

const WCHAR c_szRegServices[] = L"SYSTEM\\CurrentControlSet\\Services";
const WCHAR c_szRegParamsTcpip[] = L"\\Parameters\\Tcpip";

// ServiceProvider key
static const WCHAR c_szProviderOrderVal[]      = L"ProviderOrder";
static const WCHAR c_szSrvProvOrderKey[]       = L"System\\CurrentControlSet\\Control\\ServiceProvider\\Order";

// IsRasFakeGuid
static const WCHAR c_szIsRasFakeAdapter[] = L"IsRasFakeAdapter";
static const DWORD c_dwIsRasFakeAdapter = 0x01;

static const WCHAR c_szRasFakeAdapterDesc[] = L"Ras connection";

const WCHAR c_szREG_UseRemoteGateway[] = L"UseRemoteGateway";
const WCHAR c_szREG_UseIPHeaderCompression[] = L"UseIPHeaderCompression";
const WCHAR c_szREG_FrameSize[] = L"UseIPHeaderCompression";


// Tcpip options
const int c_iIpFilter = 0;


const DWORD c_dwUnsetNetbios   =0x0;
const DWORD c_dwEnableNetbios  =0x01;
const DWORD c_dwDisableNetbios =0x02;

// Ras connection: frame size
const WCHAR c_szFrameSize1500[] = L"1500";
const WCHAR c_szFrameSize1006[] = L"1006";

const DWORD c_dwFrameSize1500 = 1500;
const DWORD c_dwFrameSize1006 = 1006;

//IPSec is removed from connection UI	
// Constants for Ipsec policy
/*
const WCHAR c_szIpsecNoPol[] = L"IPSEC_NOPOL";
const WCHAR c_szIpsecUnset[] = L"IPSEC_UNSET";
const WCHAR c_szIpsecDefPol[]= L"IPSEC_DEFAULT_POLICIES";
*/

// Constants for metric
#define MAX_GATEWAY             5
#define MAX_METRIC_DIGITS       4       //maximum number of digits for metric
#define MAX_METRIC    9999

// Constants for identifiers in option list of REMOTE_IPINFO
const WCHAR c_chOptionSeparator = L';';
const WCHAR c_szIfMetric[] = L"IfMetric=";
const WCHAR c_szDefGw[] = L"DefGw=";
const WCHAR c_szGwMetric[] = L"GwMetric=";
const WCHAR c_szDNS[] = L"DNS=";
const WCHAR c_szWINS[] = L"WINS=";
const WCHAR c_szDynamicUpdate[] = L"DynamicUpdate=";
const WCHAR c_szNameRegistration[] = L"NameRegistration=";

const DWORD c_dwDefaultMetricOfGateway = 0;  //default metric value for a gateway

// Multiple LAN configuration reg values
const WCHAR c_szActiveConfigurations[] = L"ActiveConfigurations";
const WCHAR c_szAlternate[] = L"Alternate_";
const WCHAR c_szConfigOptions[] = L"Options";
const WCHAR c_szDhcpConfigurations[] = L"SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Configurations";

const DWORD c_dwDefaultIfMetric = 0; //default interface metric (auto metric)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P . H
//
//  Contents:   Tcpip config memory structure definitions
//
//  Notes:
//
//  Author:     tongl 13 Nov, 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"

#define ZERO_ADDRESS    L"0.0.0.0"
#define FF_ADDRESS      L"255.0.0.0"

typedef vector<tstring *>       VSTR;
typedef VSTR::iterator          VSTR_ITER;
typedef VSTR::const_iterator    VSTR_CONST_ITER;

//(08/18/98 nsun): for multiple interfaces of WAN adapters
typedef vector<GUID>            IFACECOL;   // interface collection
typedef IFACECOL::iterator      IFACEITER;  // interface iterator

struct HANDLES
{
    HWND    m_hList;
    HWND    m_hAdd;
    HWND    m_hEdit;
    HWND    m_hRemove;
    HWND    m_hUp;
    HWND    m_hDown;
};

//
// ADAPTER_INFO data strucut:
// contains adapter specific info for Tcpip
//

enum BindingState
{
    BINDING_ENABLE,
    BINDING_DISABLE,
    BINDING_UNSET
};

enum ConnectionType
{
    CONNECTION_LAN,
    CONNECTION_RAS_PPP,
    CONNECTION_RAS_SLIP,
    CONNECTION_RAS_VPN,
    CONNECTION_UNSET
};

struct BACKUP_CFG_INFO
{
    tstring m_strIpAddr;
    tstring m_strSubnetMask;
    tstring m_strDefGw;
    tstring m_strPreferredDns;
    tstring m_strAlternateDns;
    tstring m_strPreferredWins;
    tstring m_strAlternateWins;
    BOOL m_fAutoNet;
};

struct ADAPTER_INFO
{
private:
    ADAPTER_INFO(const& ADAPTER_INFO); // do not allow others to use!

public:
    ADAPTER_INFO() {}
    ~ADAPTER_INFO();

    ADAPTER_INFO &  operator=(const ADAPTER_INFO & info);  // copy operator
    HRESULT         HrSetDefaults(const GUID* pguid,
                                  PCWSTR szNetCardDescription,
                                  PCWSTR szNetCardBindName,
                                  PCWSTR szNetCardTcpipBindPath);
    void ResetOldValues();

public:
    //There is no Pnp for the backup config info
    BACKUP_CFG_INFO m_BackupInfo;

    // If the netcard has been unbound from NCPA (or anywhere else)
    BindingState    m_BindingState;

    // Remember the initial bind state of the adapter
    BindingState    m_InitialBindingState;

    // Inst Guid of net card ( we get the guid to identify cards from answer file )
    // tstring m_strServiceName;
    GUID    m_guidInstanceId;

    // Bindname of the net card, such as El59x1{inst guid}
    tstring m_strBindName;

    // Bind path name from Tcpip's linkage\Bind key to the adapter
    tstring m_strTcpipBindPath;

    // Bind path name from NetBt's linkage key to the adapter
    tstring m_strNetBtBindPath;

    // User viewable net card description
    tstring m_strDescription;

    tstring m_strDnsDomain;         // DNS -> Domain name
    tstring m_strOldDnsDomain;

    VSTR    m_vstrIpAddresses;      // IP Address
    VSTR    m_vstrOldIpAddresses;

    VSTR    m_vstrSubnetMask;       // SubnetMask
    VSTR    m_vstrOldSubnetMask;

    VSTR    m_vstrDefaultGateway;   // Default Gateways
    VSTR    m_vstrOldDefaultGateway;

    VSTR    m_vstrDefaultGatewayMetric;   // Default gateway metrics
    VSTR    m_vstrOldDefaultGatewayMetric;

    VSTR    m_vstrDnsServerList;    // DNS -> DNS server Search Order list
    VSTR    m_vstrOldDnsServerList;

    VSTR    m_vstrWinsServerList;   // WINS -> WINS server Serach Order list
    VSTR    m_vstrOldWinsServerList;

    // $REVIEW (tongl 9/6/98)Filter information (Added per bugs #109161, #216559)
    VSTR    m_vstrTcpFilterList;    // Options -> Filterng -> TCP Ports
    VSTR    m_vstrOldTcpFilterList;

    VSTR    m_vstrUdpFilterList;    // Options -> Filterng -> UDP Ports
    VSTR    m_vstrOldUdpFilterList;

    VSTR    m_vstrIpFilterList;     // Options -> Filterng -> IP Protocols
    VSTR    m_vstrOldIpFilterList;

    // ATMARP client configurable parameters ( all per adapter based )
    VSTR    m_vstrARPServerList;     // list of ARP server addresses
    VSTR    m_vstrOldARPServerList;

    VSTR    m_vstrMARServerList;     // list of MAR server addresses
    VSTR    m_vstrOldMARServerList;

    DWORD   m_dwMTU;                 // Maximum Transmission Unit
    DWORD   m_dwOldMTU;

    DWORD   m_dwInterfaceMetric;     // metric for interface-local routes
    DWORD   m_dwOldInterfaceMetric;

    DWORD   m_dwNetbiosOptions;     // (New, added inNT5 Beta2): Option to turn NetBt off
    DWORD   m_dwOldNetbiosOptions;

    // RAS connection specific parameters
    // No dynamic reconfig, so no need to remember old values
    DWORD   m_dwFrameSize;
    BOOL    m_fUseRemoteGateway : 1;
    BOOL    m_fUseIPHeaderCompression : 1;
    BOOL    m_fIsDemandDialInterface : 1;
    
    BOOL    m_fEnableDhcp : 1;        // DHCP Enable  -> Obtain an IP Address from a DHCP Server
    BOOL    m_fOldEnableDhcp : 1;

    BOOL    m_fDisableDynamicUpdate : 1;  // Disable Ip address dynamic update on DNS server
    BOOL    m_fOldDisableDynamicUpdate : 1;

    BOOL    m_fEnableNameRegistration : 1;
    BOOL    m_fOldEnableNameRegistration : 1;

    BOOL    m_fPVCOnly : 1;              // PVC only
    BOOL    m_fOldPVCOnly : 1;

    // Is this card only added from answerfile,
    // i.e. not on binding path to Tcpip yet
    BOOL    m_fIsFromAnswerFile : 1;

    // Is this an ATM card ?
    // ( ATM cards needs extra property page for ARP Client configuration)
    BOOL    m_fIsAtmAdapter : 1;

    // Is this a WanAdapter ?
    // ( Wan adapters only have static parameters and don't show in UI)
    BOOL    m_fIsWanAdapter : 1;


    // Is this a 1394 NET device?
    // (1394 devices currently do not need any special properties, 
    //  but they are associated with a specific arp module).
    BOOL   m_fIs1394Adapter : 1;

    // Is this an fake adapter that represents a RAS connection,
    // but is not an adapter and does not bind
    BOOL    m_fIsRasFakeAdapter : 1;

    // Is the card marked as for deletion
    BOOL    m_fDeleted : 1;

    // Has this card been newly added.  Valid only after calling
    // MarkNewlyAddedCards.
    // or Has the interfaces of the card been changed if it is a WAN adapter
    // Previously was m_fNewlyAdded
    BOOL    m_fNewlyChanged : 1;

    // (08/18/98 nsun) added for multiple interfaces of WAN adapters
    // m_IfaceIds: collection of interface IDs
    BOOL        m_fIsMultipleIfaceMode : 1;

    BOOL    m_fBackUpSettingChanged : 1;

    IFACECOL    m_IfaceIds;
};

typedef vector<ADAPTER_INFO *>  VCARD;


//
// GLOBAL_INFO - TCP/IP global information data structure.
struct GLOBAL_INFO
{
public:
    tstring m_strHostName;                  // DNS Host Name

    tstring m_strHostNameFromAnswerFile;    // DNS Host Name from the answerfile

    //IPSec is removed from connection UI   
    /*
    tstring m_strIpsecPol;                  // the ipsec local policy
    GUID    m_guidIpsecPol;
    */

    VSTR    m_vstrDnsSuffixList;            // DNS: domain search suffix list
    VSTR    m_vstrOldDnsSuffixList;

    BOOL    m_fEnableLmHosts : 1;           // WINS -> Enable LMHOSTS Lookup
    BOOL    m_fOldEnableLmHosts : 1;

    BOOL    m_fUseDomainNameDevolution : 1; // DNS: whether parent doamins should be searched
    BOOL    m_fOldUseDomainNameDevolution : 1;

    BOOL    m_fEnableRouter : 1;            // ROUTING -> Enable IP Forwarding

    // unattended install for RRAS
    BOOL    m_fEnableIcmpRedirect : 1;
    BOOL    m_fDeadGWDetectDefault : 1;
    BOOL    m_fDontAddDefaultGatewayDefault : 1;

    // $REVIEW (tongl 9/6/98)Filter information (Added per bugs #109161, #216559)
    BOOL    m_fEnableFiltering : 1;         // Options -> Filtering -> Enabled Filtering
    BOOL    m_fOldEnableFiltering : 1;

private:
    GLOBAL_INFO(const & GLOBAL_INFO); // no not allow others to use!

public:
    GLOBAL_INFO() {};
    ~GLOBAL_INFO();

    GLOBAL_INFO& operator=(GLOBAL_INFO& glb); // copy operator

    HRESULT HrSetDefaults();

    void    ResetOldValues();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpip.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P . C P P
//
//  Contents:   Tcpip config memory structure member functions
//
//  Notes:
//
//  Author:     tongl 13 Nov, 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define _PNP_POWER_
#include "ntddip.h"
#undef _PNP_POWER_

#include "ncstl.h"
#include "tcpip.h"
#include "tcpconst.h"
#include "ncmisc.h"


void CopyVstr(VSTR * vstrDest, const VSTR & vstrSrc)
{
    FreeCollectionAndItem(*vstrDest);
    vstrDest->reserve(vstrSrc.size());

    for(VSTR_CONST_ITER iter = vstrSrc.begin(); iter != vstrSrc.end(); ++iter)
        vstrDest->push_back(new tstring(**iter));
}


//+---------------------------------------------------------------------------
//
//  Name:     ADAPTER_INFO::~ADAPTER_INFO
//
//  Purpose:   Destructor
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
ADAPTER_INFO::~ADAPTER_INFO()
{
    FreeCollectionAndItem(m_vstrIpAddresses);
    FreeCollectionAndItem(m_vstrOldIpAddresses);

    FreeCollectionAndItem(m_vstrSubnetMask);
    FreeCollectionAndItem(m_vstrOldSubnetMask);

    FreeCollectionAndItem(m_vstrDefaultGateway);
    FreeCollectionAndItem(m_vstrOldDefaultGateway);

    FreeCollectionAndItem(m_vstrDefaultGatewayMetric);
    FreeCollectionAndItem(m_vstrOldDefaultGatewayMetric);

    FreeCollectionAndItem(m_vstrDnsServerList);
    FreeCollectionAndItem(m_vstrOldDnsServerList);

    FreeCollectionAndItem(m_vstrWinsServerList);
    FreeCollectionAndItem(m_vstrOldWinsServerList);

    FreeCollectionAndItem(m_vstrARPServerList);
    FreeCollectionAndItem(m_vstrOldARPServerList);

    FreeCollectionAndItem(m_vstrMARServerList);
    FreeCollectionAndItem(m_vstrOldMARServerList);

    FreeCollectionAndItem(m_vstrTcpFilterList);
    FreeCollectionAndItem(m_vstrOldTcpFilterList);

    FreeCollectionAndItem(m_vstrUdpFilterList);
    FreeCollectionAndItem(m_vstrOldUdpFilterList);

    FreeCollectionAndItem(m_vstrIpFilterList);
    FreeCollectionAndItem(m_vstrOldIpFilterList);
}

//+---------------------------------------------------------------------------
//
//  Name:   ADAPTER_INFO::HrSetDefaults
//
//  Purpose:    Function to set all the default values of the ADAPTER_INFO
//              structure.  This is done whenever a new netcard is added
//              to the list of netcards before any real information is
//              added to the structure so that any missing parameters
//              are defaulted
//
//  Arguments:  pguidInstanceId
//              pszNetCardDescription
//              pszNetCardBindName
//              pszNetCardTcpipBindPath
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
HRESULT ADAPTER_INFO::HrSetDefaults(const GUID* pguidInstanceId,
                                    PCWSTR pszNetCardDescription,
                                    PCWSTR pszNetCardBindName,
                                    PCWSTR pszNetCardTcpipBindPath )
{
    Assert (pguidInstanceId);

    m_BackupInfo.m_fAutoNet = TRUE;
    m_BackupInfo.m_strIpAddr = c_szEmpty;
    m_BackupInfo.m_strSubnetMask = c_szEmpty;
    m_BackupInfo.m_strPreferredDns = c_szEmpty;
    m_BackupInfo.m_strAlternateDns = c_szEmpty;
    m_BackupInfo.m_strPreferredWins = c_szEmpty;
    m_BackupInfo.m_strAlternateWins = c_szEmpty;

    m_BindingState       = BINDING_UNSET;
    m_InitialBindingState= BINDING_UNSET;

    m_guidInstanceId     = *pguidInstanceId;
    m_strBindName        = pszNetCardBindName;
    m_strTcpipBindPath   = pszNetCardTcpipBindPath;
    m_strDescription     = pszNetCardDescription;

    // Create the "Services\NetBt\Adapters\<netcard bind path>" key
    // $REVIEW Since we don't have a
    // notification object for NetBt and NetBt has just been changed
    // to bind to Tcpip. For first checkin we hard code the netcard's
    // bindpath to be "Tcpip_"+<Bind path to Tcpip>

    m_strNetBtBindPath = c_szTcpip_;
    m_strNetBtBindPath += m_strTcpipBindPath;

    // $REVIEW(tongl 5/17): behaviour change: enable Dhcp is now the default
    m_fEnableDhcp        = TRUE;
    m_fOldEnableDhcp     = TRUE;

    FreeCollectionAndItem(m_vstrIpAddresses);
    FreeCollectionAndItem(m_vstrOldIpAddresses);

    FreeCollectionAndItem(m_vstrSubnetMask);
    FreeCollectionAndItem(m_vstrOldSubnetMask);

    FreeCollectionAndItem(m_vstrDefaultGateway);
    FreeCollectionAndItem(m_vstrOldDefaultGateway);

    FreeCollectionAndItem(m_vstrDefaultGatewayMetric);
    FreeCollectionAndItem(m_vstrOldDefaultGatewayMetric);

    m_strDnsDomain     = c_szEmpty;
    m_strOldDnsDomain  = c_szEmpty;

    m_fDisableDynamicUpdate = FALSE;
    m_fOldDisableDynamicUpdate = FALSE;

    m_fEnableNameRegistration = FALSE;
    m_fOldEnableNameRegistration = FALSE;

    FreeCollectionAndItem(m_vstrDnsServerList);
    FreeCollectionAndItem(m_vstrOldDnsServerList);

    FreeCollectionAndItem(m_vstrWinsServerList);
    FreeCollectionAndItem(m_vstrOldWinsServerList);

    m_dwNetbiosOptions = c_dwUnsetNetbios;
    m_dwOldNetbiosOptions = c_dwUnsetNetbios;

    m_dwInterfaceMetric               = c_dwDefaultIfMetric;
    m_dwOldInterfaceMetric            = c_dwDefaultIfMetric;

    // Filtering list
    FreeCollectionAndItem(m_vstrTcpFilterList);
    m_vstrTcpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldTcpFilterList);
    m_vstrOldTcpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrUdpFilterList);
    m_vstrUdpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldUdpFilterList);
    m_vstrOldUdpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrIpFilterList);
    m_vstrIpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldIpFilterList);
    m_vstrOldIpFilterList.push_back(new tstring(c_szDisableFiltering));

    // list of ARP server addresses
    FreeCollectionAndItem(m_vstrARPServerList);
    m_vstrARPServerList.push_back(new tstring(c_szDefaultAtmArpServer));

    FreeCollectionAndItem(m_vstrOldARPServerList);
    m_vstrOldARPServerList.push_back(new tstring(c_szDefaultAtmArpServer));

    // list of MAR server addresses
    FreeCollectionAndItem(m_vstrMARServerList);
    m_vstrMARServerList.push_back(new tstring(c_szDefaultAtmMarServer));

    FreeCollectionAndItem(m_vstrOldMARServerList);
    m_vstrOldMARServerList.push_back(new tstring(c_szDefaultAtmMarServer));

    // default is no support for mulitiple interfaces
    m_fIsMultipleIfaceMode = FALSE;
    m_IfaceIds.clear ();

    m_fBackUpSettingChanged = FALSE;

    // MTU
    m_dwMTU = c_dwDefaultAtmMTU;
    m_dwOldMTU = c_dwDefaultAtmMTU;

    // PVC only
    m_fPVCOnly = FALSE;
    m_fOldPVCOnly = FALSE;

    // RAS connection special parameters
    m_fUseRemoteGateway = TRUE;
    m_fUseIPHeaderCompression = TRUE;
    m_dwFrameSize = 1006;
    m_fIsDemandDialInterface = FALSE;

    // Set all special flags to FALSE
    m_fIsFromAnswerFile = FALSE;
    m_fIsAtmAdapter = FALSE;
    m_fIsWanAdapter = FALSE;
    m_fIs1394Adapter = FALSE;
    m_fIsRasFakeAdapter = FALSE;
    m_fDeleted = FALSE;
    m_fNewlyChanged = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Name:     ADAPTER_INFO & ADAPTER_INFO::operator=
//
//  Purpose:   Copy operator
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
ADAPTER_INFO & ADAPTER_INFO::operator=(const ADAPTER_INFO & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    m_BackupInfo            = info.m_BackupInfo;
    m_BindingState          = info.m_BindingState;
    m_InitialBindingState   = info.m_InitialBindingState;

    m_guidInstanceId        = info.m_guidInstanceId;
    m_strDescription        = info.m_strDescription;
    m_strBindName           = info.m_strBindName;
    m_strTcpipBindPath      = info.m_strTcpipBindPath;
    m_strNetBtBindPath      = info.m_strNetBtBindPath;

    m_fEnableDhcp           = info.m_fEnableDhcp;
    m_fOldEnableDhcp        = info.m_fOldEnableDhcp;

    CopyVstr(&m_vstrIpAddresses, info.m_vstrIpAddresses);
    CopyVstr(&m_vstrOldIpAddresses, info.m_vstrOldIpAddresses);

    CopyVstr(&m_vstrSubnetMask, info.m_vstrSubnetMask);
    CopyVstr(&m_vstrOldSubnetMask, info.m_vstrOldSubnetMask);

    CopyVstr(&m_vstrDefaultGateway, info.m_vstrDefaultGateway);
    CopyVstr(&m_vstrOldDefaultGateway, info.m_vstrOldDefaultGateway);

    CopyVstr(&m_vstrDefaultGatewayMetric, info.m_vstrDefaultGatewayMetric);
    CopyVstr(&m_vstrOldDefaultGatewayMetric, info.m_vstrOldDefaultGatewayMetric);

    m_strDnsDomain      = info.m_strDnsDomain;
    m_strOldDnsDomain   = info.m_strOldDnsDomain;

    m_fDisableDynamicUpdate = info.m_fDisableDynamicUpdate;
    m_fOldDisableDynamicUpdate = info.m_fOldDisableDynamicUpdate;

    m_fEnableNameRegistration = info.m_fEnableNameRegistration;
    m_fOldEnableNameRegistration = info.m_fOldEnableNameRegistration;

    CopyVstr(&m_vstrDnsServerList, info.m_vstrDnsServerList);
    CopyVstr(&m_vstrOldDnsServerList, info.m_vstrOldDnsServerList);

    CopyVstr(&m_vstrWinsServerList, info.m_vstrWinsServerList);
    CopyVstr(&m_vstrOldWinsServerList, info.m_vstrOldWinsServerList);

    m_dwNetbiosOptions =    info.m_dwNetbiosOptions;
    m_dwOldNetbiosOptions = info.m_dwOldNetbiosOptions;

    m_dwInterfaceMetric             = info.m_dwInterfaceMetric;
    m_dwOldInterfaceMetric          = info.m_dwOldInterfaceMetric;

    CopyVstr(&m_vstrTcpFilterList, info.m_vstrTcpFilterList);
    CopyVstr(&m_vstrOldTcpFilterList, info.m_vstrOldTcpFilterList);

    CopyVstr(&m_vstrUdpFilterList, info.m_vstrUdpFilterList);
    CopyVstr(&m_vstrOldUdpFilterList, info.m_vstrOldUdpFilterList);

    CopyVstr(&m_vstrIpFilterList, info.m_vstrIpFilterList);
    CopyVstr(&m_vstrOldIpFilterList, info.m_vstrOldIpFilterList);

    m_fIsAtmAdapter = info.m_fIsAtmAdapter;
    if (m_fIsAtmAdapter)
    {
        CopyVstr(&m_vstrARPServerList, info.m_vstrARPServerList);
        CopyVstr(&m_vstrOldARPServerList, info.m_vstrOldARPServerList);

        CopyVstr(&m_vstrMARServerList, info.m_vstrMARServerList);
        CopyVstr(&m_vstrOldMARServerList, info.m_vstrOldMARServerList);

        m_dwMTU     = info.m_dwMTU;
        m_dwOldMTU  = info.m_dwOldMTU;

        m_fPVCOnly     = info.m_fPVCOnly;
        m_fOldPVCOnly  = info.m_fOldPVCOnly;
    }

    m_fIs1394Adapter = info.m_fIs1394Adapter;
    if (m_fIs1394Adapter)
    {
        // TODO currently no thing more to copy.
    }

    m_fIsRasFakeAdapter = info.m_fIsRasFakeAdapter;
    if (m_fIsRasFakeAdapter)
    {
        m_fUseRemoteGateway = info.m_fUseRemoteGateway;
        m_fUseIPHeaderCompression = info.m_fUseIPHeaderCompression;
        m_dwFrameSize = info.m_dwFrameSize;
        m_fIsDemandDialInterface = info.m_fIsDemandDialInterface;
    }

    m_fNewlyChanged = info.m_fNewlyChanged;

    m_fBackUpSettingChanged = info.m_fBackUpSettingChanged;

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Name: ADAPTER_INFO::ResetOldValues
//
//  Purpose:  This is for initializing the "old" values after the current values
//            are first loaded from registry, also for resetting the "old" values
//            to current ones when "Apply"(instead of "ok") is hit.
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
void ADAPTER_INFO::ResetOldValues()
{
    m_fOldEnableDhcp        = m_fEnableDhcp  ;

    CopyVstr(&m_vstrOldIpAddresses, m_vstrIpAddresses);
    CopyVstr(&m_vstrOldSubnetMask,  m_vstrSubnetMask);
    CopyVstr(&m_vstrOldDefaultGateway, m_vstrDefaultGateway);
    CopyVstr(&m_vstrOldDefaultGatewayMetric, m_vstrDefaultGatewayMetric);

    m_strOldDnsDomain = m_strDnsDomain;

    m_fOldDisableDynamicUpdate = m_fDisableDynamicUpdate;

    m_fOldEnableNameRegistration = m_fEnableNameRegistration;

    CopyVstr(&m_vstrOldDnsServerList,  m_vstrDnsServerList);
    CopyVstr(&m_vstrOldWinsServerList, m_vstrWinsServerList);

    m_dwOldNetbiosOptions = m_dwNetbiosOptions;

    m_dwOldInterfaceMetric          = m_dwInterfaceMetric;

    CopyVstr(&m_vstrOldTcpFilterList, m_vstrTcpFilterList);
    CopyVstr(&m_vstrOldUdpFilterList, m_vstrUdpFilterList);
    CopyVstr(&m_vstrOldIpFilterList, m_vstrIpFilterList);

    if (m_fIsAtmAdapter)
    {
        CopyVstr(&m_vstrOldARPServerList, m_vstrARPServerList);
        CopyVstr(&m_vstrOldMARServerList, m_vstrMARServerList);
        m_dwOldMTU  = m_dwMTU;
        m_fOldPVCOnly = m_fPVCOnly;
    }
}


//+---------------------------------------------------------------------------
//
//  Name:   GLOBAL_INFO::~GLOBAL_INFO
//
//  Purpose:   Destructor
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
GLOBAL_INFO::~GLOBAL_INFO()
{
    FreeCollectionAndItem(m_vstrDnsSuffixList);
    FreeCollectionAndItem(m_vstrOldDnsSuffixList);
}

//+---------------------------------------------------------------------------
//
//  Name:   GLOBAL_INFO::HrSetDefaults
//
//  Purpose:    Function to set all the default values of the GLOBAL_INFO
//              structure.  This is done to the system's GLOBAL_INFO
//              before reading the Registry so that any missing
//              parameters are defaulted
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
HRESULT GLOBAL_INFO::HrSetDefaults()
{
    HRESULT hr = S_OK;

    // Get the ComputerName -> used for default HostName
    WCHAR szComputerName [MAX_COMPUTERNAME_LENGTH + 1];
    szComputerName[0] = L'\0';

    DWORD dwCch = celems(szComputerName);
    BOOL fOk = ::GetComputerName(szComputerName, &dwCch);

    Assert(szComputerName[dwCch] == 0);

    //
    // 398325: DNS hostnames should be lower case whenever possible.
    //
    LowerCaseComputerName(szComputerName);

    m_strHostName   = szComputerName;

    // Set defaults
    FreeCollectionAndItem(m_vstrDnsSuffixList);
    FreeCollectionAndItem(m_vstrOldDnsSuffixList);

    //Bug #265732: per SKwan, the default of m_fUseDomainNameDevolution should be TRUE
    m_fUseDomainNameDevolution    = TRUE;
    m_fOldUseDomainNameDevolution = TRUE;

    m_fEnableLmHosts        = TRUE;
    m_fOldEnableLmHosts     = TRUE;

    m_fEnableRouter         = FALSE;

    m_fEnableIcmpRedirect   = TRUE;
    m_fDeadGWDetectDefault  = TRUE;
    m_fDontAddDefaultGatewayDefault = FALSE;




    m_fEnableFiltering      = FALSE;
    m_fOldEnableFiltering   = FALSE;

    //IPSec is removed from connection UI   
    //m_strIpsecPol = c_szIpsecUnset;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     GLOBAL_INFO::operator=
//
//  Purpose:   Copy operator
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
GLOBAL_INFO& GLOBAL_INFO::operator=(GLOBAL_INFO& info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    CopyVstr(&m_vstrDnsSuffixList, info.m_vstrDnsSuffixList);
    CopyVstr(&m_vstrOldDnsSuffixList, info.m_vstrOldDnsSuffixList);

    m_fUseDomainNameDevolution      = info.m_fUseDomainNameDevolution;
    m_fOldUseDomainNameDevolution   = info.m_fOldUseDomainNameDevolution;

    m_fEnableLmHosts        = info.m_fEnableLmHosts;
    m_fOldEnableLmHosts     = info.m_fOldEnableLmHosts;

    m_fEnableRouter         = info.m_fEnableRouter;

    m_fEnableIcmpRedirect   = info.m_fEnableIcmpRedirect;
    m_fDeadGWDetectDefault  = info.m_fDeadGWDetectDefault;
    m_fDontAddDefaultGatewayDefault = info.m_fDontAddDefaultGatewayDefault;



    m_fEnableFiltering      = info.m_fEnableFiltering;
    m_fOldEnableFiltering   = info.m_fOldEnableFiltering;

    //IPSec is removed from connection UI   
    /*
    m_guidIpsecPol = info.m_guidIpsecPol;
    m_strIpsecPol = info.m_strIpsecPol;
    */

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Name:     GLOBAL_INFO::ResetOldValues()
//
//  Purpose:  This is for initializing the "old" values after the current values
//            are first loaded from registry, also for resetting the "old" values
//            to current ones when "Apply"(instead of "ok") is hit.
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
void GLOBAL_INFO::ResetOldValues()
{
    CopyVstr(&m_vstrOldDnsSuffixList, m_vstrDnsSuffixList);

    m_fOldEnableLmHosts     = m_fEnableLmHosts;
    m_fOldEnableFiltering   = m_fEnableFiltering;
    m_fOldUseDomainNameDevolution = m_fUseDomainNameDevolution;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpipobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P O B J . C P P
//
//  Contents:   TCP/IP notify object
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncreg.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "tcpipobj.h"
#include "tcputil.h"
#include "tcprsvp.h"

extern const WCHAR c_szBiNdisAtm[];

extern const WCHAR c_szInfId_MS_NetBT[];
extern const WCHAR c_szInfId_MS_NetBT_SMB[];
extern const WCHAR c_szInfId_MS_RSVP[];


HICON   g_hiconUpArrow;
HICON   g_hiconDownArrow;

// Constructor
CTcpipcfg::CTcpipcfg()
:   m_ipaddr(NULL),
    m_pUnkContext(NULL),
    m_pnc(NULL),
    m_pnccTcpip(NULL),
    m_pTcpipPrivate(NULL),
    m_pnccWins(NULL),
    m_fRemoving(FALSE),
    m_fInstalling(FALSE),
    m_fUpgradeCleanupDnsKey(FALSE),
    m_fUpgradeGlobalDnsDomain(FALSE),
    m_pSecondMemoryAdapterInfo(NULL)
{ }

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Initialize
//
STDMETHODIMP CTcpipcfg::Initialize(INetCfgComponent * pnccTcpip,
                                   INetCfg * pncNetCfg,
                                   BOOL fInstalling)
{
    HRESULT hr = S_OK;

    Assert(pncNetCfg);
    Assert(pnccTcpip);

    m_fRemoving = FALSE;
    m_fInstalling = FALSE;

    m_fSaveRegistry = FALSE;

    m_ConnType = CONNECTION_UNSET;
    m_fReconfig = FALSE;

    // we havn't changed LmHost file
    m_fLmhostsFileSet = FALSE;

    // IPSec is removed from connection UI
    // we have not change ipsec policy
    //m_fIpsecPolicySet = FALSE;

    // by default, this should be an admin
    m_fRasNotAdmin = FALSE;

    Validate_INetCfgNotify_Initialize(pnccTcpip, pncNetCfg, fInstalling);

    do // psudo loop ( so we don't use goto's on err )
    {
        // in case of Initialize called twice, for resurect the component
        ReleaseObj(m_pnc);
        m_pnc = NULL;

        ReleaseObj(m_pnccTcpip);
        m_pnccTcpip = NULL;

        ReleaseObj(m_pTcpipPrivate);
        m_pTcpipPrivate = NULL;

        ReleaseObj(m_pnccWins);
        m_pnccWins = NULL;

        // store reference to the INetCfg in our object
        m_pnc = pncNetCfg;
        m_pnc->AddRef();

        // Store a reference to the INetCfgComponent for tcpip in our object
        m_pnccTcpip = pnccTcpip;
        m_pnccTcpip->AddRef();

        hr = pnccTcpip->QueryInterface(
                    IID_INetCfgComponentPrivate,
                    reinterpret_cast<void**>(&m_pTcpipPrivate));
        if (FAILED(hr))
            break;

        // Get a copy of the WINS component and store in our object

        // NOTE: WINS client is not necessarily installed yet!
        // we also try to get a pointer at the Install sections
        hr = pncNetCfg->FindComponent(c_szInfId_MS_NetBT,
                            &m_pnccWins);
        if (FAILED(hr))
            break;

        if (S_FALSE == hr) // NetBt not found
        {
            if (!fInstalling) // We are in trouble if NetBt is not there
            {
                TraceError("CTcpipcfg::Initialize - NetBt has not been installed yet", hr);
                break;
            }
            else // We are ok since tcpip will install netbt
            {
                hr = S_OK;
            }
        }

        // Set default global parameters
        hr = m_glbGlobalInfo.HrSetDefaults();
        if (FAILED(hr))
            break;

        // If tcpip is being installed, we don't have any cards to load
        if (!fInstalling)
        {
            // Get list of cards which are currently in the system + if they are bound
            hr = HrGetNetCards();

            if (SUCCEEDED(hr))
            {
                // Let's read parameters from registry
                hr = HrLoadSettings();
            }
        }
    } while(FALSE);

    // Have we got any bound cards ?
    m_fHasBoundCardOnInit = FHasBoundCard();

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CTcpipcfg::Initialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Validate
//
STDMETHODIMP CTcpipcfg::Validate()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Cancel
//
STDMETHODIMP CTcpipcfg::CancelChanges()
{
    // Note: first memory state is release in destructor

    // If the lmhosts file was set, we need to roll it back to the backup
    if (m_fLmhostsFileSet)
    {
        ResetLmhostsFile();
        m_fLmhostsFileSet = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ApplyRegistryChanges
//
STDMETHODIMP CTcpipcfg::ApplyRegistryChanges()
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    if (m_fRemoving)
    {
        // (nsun) we should remove the Nt4 duplicate registry here because the cards
        // may have been marked as deleted
        hr = HrRemoveNt4DuplicateRegistry();

        ReleaseObj(m_pnccWins);
        m_pnccWins = NULL;

        // $REVIEW(tongl 9/29/97): Removing ServiceProvider value from registry
        // Remove "Tcpip" from the:
        // System\CurrentControlSet\Control\ServiceProvider\Order\ProviderOrder value
        hrTmp = ::HrRegRemoveStringFromMultiSz(c_szTcpip,
                                            HKEY_LOCAL_MACHINE,
                                            c_szSrvProvOrderKey,
                                            c_szProviderOrderVal,
                                            STRING_FLAG_REMOVE_ALL);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Remove RSVP providers
        //
        RemoveRsvpProvider();
    }
    else
    {
        // Cleanup the adapters marked as for deletion from the memory structure
        // Change made for #95637
        for(size_t i = 0 ; i < m_vcardAdapterInfo.size() ; ++i)
        {
            if (m_vcardAdapterInfo[i]->m_fDeleted)
            {
                //delete it
                FreeVectorItem(m_vcardAdapterInfo, i);
                i--; //move the pointer back ?
            }
        }

        // install RSVP providers
        //
        if (m_fInstalling)
        {
            hr = HrInstallRsvpProvider();
            TraceError("CTcpipcfg::ApplyRegistryChanges: HrInstallRsvpProvider failed", hr);

            // if RSVP install fails, we still want to continue apply
            //
            hr = S_OK;
        }

        if (m_fSaveRegistry)
        {
            // Save info in first memory state to registry
            // m_glbGlobalInfo and m_vcardAdapterInfo
            hrTmp = HrSaveSettings();
            if (SUCCEEDED(hr))
                hr = hrTmp;
        }
        else
        {
            // No change
            hr = S_FALSE;
        }
    }


    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CTcpipcfg::ApplyRegistryChanges", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ApplyPnpChanges
//
STDMETHODIMP CTcpipcfg::ApplyPnpChanges(IN INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(pICallback);

    if (!m_fRemoving)
    {
        if(!m_fInstalling)
        {
            if (m_fReconfig)
            {
                // Notify protocols/services of changes

                // Notify Tcpip of any changes in the IP Addresses
                hrTmp = HrNotifyDhcp();
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig tcpip
                hrTmp = HrReconfigIp(pICallback);
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig netbt
                hrTmp = HrReconfigNbt(pICallback);
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig dns
                hrTmp = HrReconfigDns();
                if (S_OK == hr)
                    hr = hrTmp;
            }

            if (IsBindOrderChanged())
            {
                //notify DNS cache of binding order changes
                hrTmp = HrReconfigDns(TRUE);
                if (S_OK == hr)
                    hr = hrTmp;
            }

        }

        
//IPSec is removed from connection UI
//        if (m_fIpsecPolicySet)
//            hrTmp = HrSetActiveIpsecPolicy();

        if (S_OK == hr)
            hr = hrTmp;
    }

    // Current state has been applied, reset the flags and
    // "Old" value of parameters
    if (S_OK == hr)
    {
        ReInitializeInternalState();
    }

    TraceError("CTcpipcfg::ApplyPnpChanges", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgComponentSetUp
//
//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Install
//
STDMETHODIMP CTcpipcfg::Install(DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install(dwSetupFlags);

    m_fSaveRegistry = TRUE;
    m_fInstalling = TRUE;

    // Install the WINS client on behalf of TCPIP.
    Assert(!m_pnccWins);
    hr = HrInstallComponentOboComponent(m_pnc, NULL,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NetBT, m_pnccTcpip,
            &m_pnccWins);

    if (SUCCEEDED(hr))
    {
        Assert(m_pnccWins);

        hr = HrInstallComponentOboComponent(m_pnc, NULL,
                GUID_DEVCLASS_NETTRANS,
                c_szInfId_MS_NetBT_SMB, m_pnccTcpip,
                NULL);

        if (SUCCEEDED(hr))
        {
            // Install RSVP client on behalf of TCPIP.
            hr = HrInstallComponentOboComponent(m_pnc, NULL,
                    GUID_DEVCLASS_NETSERVICE,
                    c_szInfId_MS_RSVP, m_pnccTcpip,
                    NULL);
        }
    }

    TraceError("CTcpipcfg::Install", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Upgrade
//
STDMETHODIMP CTcpipcfg::Upgrade(DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo )
{
    HrCleanUpPerformRouterDiscoveryFromRegistry();
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  7 May 1997
//
//  Notes:
//
STDMETHODIMP CTcpipcfg::ReadAnswerFile( PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    m_fSaveRegistry = TRUE;

    if (pszAnswerFile && pszAnswerSection)
    {
        // Process answer file
        (void) HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Removing
//
STDMETHODIMP CTcpipcfg::Removing()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove NetBt protocol. This doesn't actually remove the
    // component, it simply marks it as needing to be removed,
    // and in Apply() it will be fully removed.
    hr = HrRemoveComponentOboComponent(
            m_pnc, GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NetBT, m_pnccTcpip);
    if (SUCCEEDED(hr))
    {
        // remove NetBt_SMB
        hr = HrRemoveComponentOboComponent(
                m_pnc, GUID_DEVCLASS_NETTRANS,
                c_szInfId_MS_NetBT_SMB, m_pnccTcpip);

    }

    // Also remove RSVP
    if (SUCCEEDED(hr))
    {
        hr = HrRemoveComponentOboComponent(
                m_pnc, GUID_DEVCLASS_NETSERVICE,
                c_szInfId_MS_RSVP, m_pnccTcpip);
    }

    TraceError("CTcpipcfg::Removing", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CTcpipcfg::SetContext(IUnknown * pUnk)
{
    // release previous context, if any
    ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CTcpipcfg::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    HRESULT hr = HrSetConnectionContext();

    if (SUCCEEDED(hr))
    {
        AssertSz(((CONNECTION_LAN == m_ConnType)||
                  (CONNECTION_RAS_PPP == m_ConnType)||
                  (CONNECTION_RAS_SLIP == m_ConnType)||
                  (CONNECTION_RAS_VPN == m_ConnType)),
                  "How come we don't know the connection type yet on MergePropPages?");

        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;

            // Set the global up\down arrows
            if (!g_hiconUpArrow && !g_hiconDownArrow)
            {
                g_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                                  MAKEINTRESOURCE(IDI_UP_ARROW),
                                                  IMAGE_ICON, 16, 16, 0);
                g_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                                    IMAGE_ICON, 16, 16, 0);
            }

        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);

        }
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CTcpipcfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CTcpipcfg::CancelProperties()
{
    // If the lmhosts file was set, we need to roll it back to the backup
    if (m_fSecondMemoryLmhostsFileReset)
    {
        ResetLmhostsFile();
    }

    // Release second memory state
    ExitProperties();

    return S_OK;
}

STDMETHODIMP CTcpipcfg::ApplyProperties()
{
    HRESULT hr = S_OK;

    if (!m_fReconfig)
    {
        m_fReconfig = m_fSecondMemoryModified ||
                      m_fSecondMemoryLmhostsFileReset;

        //IPSec is removed from connection UI
        // || m_fSecondMemoryIpsecPolicySet;
    }

    if (!m_fLmhostsFileSet)
        m_fLmhostsFileSet = m_fSecondMemoryLmhostsFileReset;

    //IPSec is removed from connection UI
    //if (!m_fIpsecPolicySet)
    //    m_fIpsecPolicySet = m_fSecondMemoryIpsecPolicySet;

    if (!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        m_glbGlobalInfo = m_glbSecondMemoryGlobalInfo;
        hr = HrSaveAdapterInfo();
    }

    // Release second memory state
    ExitProperties();

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    TraceError("CTcpipcfg::ApplyProperties", hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::QueryBindingPath(DWORD dwChangeFlag,
                                         INetCfgBindingPath * pncbp)
{
    HRESULT hr = S_OK;

    // If the binding is to an atm adapter (i.e. interface = ndisatm),
    // then return NETCFG_S_DISABLE_QUERY
    //
    if (dwChangeFlag & NCN_ADD)
    {

        INetCfgComponent* pnccLastComponent;
        PWSTR pszInterfaceName;

        hr = HrGetLastComponentAndInterface(pncbp,
                &pnccLastComponent,
                &pszInterfaceName);

        if (SUCCEEDED(hr))
        {
            // If adding an adapter through interface ndisatm,
            // we want to disable the binding interface since it's
            // the IP over ATM direct binding
            if (0 == lstrcmpW(c_szBiNdisAtm,  pszInterfaceName))
            {
                hr = NETCFG_S_DISABLE_QUERY;
            }

            ReleaseObj (pnccLastComponent);
            CoTaskMemFree (pszInterfaceName);
        }
    }

    TraceError("CTcpipcfg::QueryBindingPath",
        (NETCFG_S_DISABLE_QUERY == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::NotifyBindingPath(
    DWORD                   dwChangeFlag,
    INetCfgBindingPath *    pncbp)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath(dwChangeFlag, pncbp);

    INetCfgComponent * pnccLastComponent;
    PWSTR pszInterfaceName;
    hr = HrGetLastComponentAndInterface(pncbp,
            &pnccLastComponent,
            &pszInterfaceName);
    if (SUCCEEDED(hr))
    {
#if DBG
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(
            SUCCEEDED(hr) &&
            IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET),
            "Why the last component on the path is not an adapter?");
#endif

        // If we are adding/removing cards, set m_fSaveRegistry
        // so we apply the changes to registry

        if (dwChangeFlag & (NCN_ADD | NCN_REMOVE))
            m_fSaveRegistry = TRUE;

        hr = HrAdapterBindNotify(pnccLastComponent,
                                 dwChangeFlag,
                                 pszInterfaceName);

        ReleaseObj (pnccLastComponent);
        CoTaskMemFree (pszInterfaceName);
    }

    if (SUCCEEDED(hr))
        hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CTcpipcfg::NotifyBindingPath", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgComponentUpperEdge
//

// Return an array of interface ids for an adapter bound to
// this component.  If the specified adapter does not have explicit
// interfaces exported from it, S_FALSE is returned.
// pAdapter is the adapter in question.
// pdwNumInterfaces is the address of a DWORD where the count of elements
// returned via ppguidInterfaceIds is stored.
// ppguidInterfaceIds is the address of a pointer where an allocated
// block of memory is returned.  This memory is an array of interface ids.
// *ppguidInterfaceIds should be free with CoTaskMemFree if S_OK is returned.
// if S_FALSE is returned, *pdwNumInterfaces and *ppguidInterfaceIds should
// be NULL.
//

HRESULT
CTcpipcfg::GetInterfaceIdsForAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD*              pdwNumInterfaces,
    GUID**              ppguidInterfaceIds)
{
    Assert (pnccAdapter);
    Assert (pdwNumInterfaces);

    HRESULT hr = S_FALSE;

    // Initialize output parameters.
    //
    *pdwNumInterfaces = 0;
    if (ppguidInterfaceIds)
    {
        *ppguidInterfaceIds = NULL;
    }

    ADAPTER_INFO* pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter &&
        pAdapterInfo->m_fIsMultipleIfaceMode)
    {
        hr = GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
                pAdapterInfo->m_IfaceIds,
                ppguidInterfaceIds,
                pdwNumInterfaces);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CTcpipcfg::GetInterfaceIdsForAdapter");
    return hr;
}


// Add the specified number of new interfaces to the specified adapter.
// The implementation will choose the interface ids.
//
HRESULT
CTcpipcfg::AddInterfacesToAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD               dwNumInterfaces)
{
    Assert (pnccAdapter);

    HRESULT         hr = S_FALSE;
    ADAPTER_INFO*   pAdapterInfo;

    if ((NULL == pnccAdapter) || (0 == dwNumInterfaces))
    {
        hr = E_INVALIDARG;
        goto end_AddInterfacesToAdapter;
    }

    pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter)
    {
        AddInterfacesToAdapterInfo(
            pAdapterInfo,
            dwNumInterfaces);

        pAdapterInfo->m_fIsMultipleIfaceMode = TRUE;
        pAdapterInfo->m_fNewlyChanged = TRUE;
        m_fSaveRegistry = TRUE;
        m_fReconfig = TRUE;

        // Notify the binding engine that our upper edge has changed.
        //
        (VOID)m_pTcpipPrivate->NotifyUpperEdgeConfigChange ();
        hr = S_OK;
    }

end_AddInterfacesToAdapter:
    TraceErrorSkip1("CTcpipcfg::AddInterfacesToAdapter", hr, S_FALSE);
    return hr;
}


// Remove the specified interface ids from the specified adapter.
// pguidInterfaceIds is the array of ids to be removed.  dwNumInterfaces
// is the count in that array.
//
HRESULT
CTcpipcfg::RemoveInterfacesFromAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD               dwNumInterfaces,
    const GUID*         pguidInterfaceIds)
{
    Assert (pnccAdapter);
    Assert (pguidInterfaceIds);

    HRESULT         hr = E_UNEXPECTED;
    ADAPTER_INFO*   pAdapterInfo;

    if ((NULL == pnccAdapter) ||
        (0 == dwNumInterfaces) ||
        (NULL == pguidInterfaceIds))
    {
        hr = E_INVALIDARG;
        goto end_RemoveInterfacesFromAdapter;
    }

    pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    AssertSz( pAdapterInfo,
        "CTcpipcfg::AddInterfacesToAdapter cannot find the adapter "
        "GUID from the adapter list");

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter &&
        pAdapterInfo->m_fIsMultipleIfaceMode)
    {
        DWORD       dwNumRemoved = 0;
        IFACEITER   iter;
        for (DWORD i = 0; i < dwNumInterfaces; i++)
        {
            iter = find(pAdapterInfo->m_IfaceIds.begin(),
                        pAdapterInfo->m_IfaceIds.end(),
                        pguidInterfaceIds[i]);

            if (iter != pAdapterInfo->m_IfaceIds.end())
            {
                pAdapterInfo->m_IfaceIds.erase(iter);
                dwNumRemoved++;
            }
        }

        //$REVIEW (nsun) mark the adapter as NewlyAdded so that we will re-write its adapter registry
        if (dwNumRemoved > 0)
        {
            pAdapterInfo->m_fNewlyChanged = TRUE;
            m_fSaveRegistry = TRUE;
        }

        // Notify the binding engine that our upper edge has changed.
        //
        (VOID)m_pTcpipPrivate->NotifyUpperEdgeConfigChange ();

        hr = (dwNumRemoved == dwNumInterfaces) ? S_OK : S_FALSE;
    }

end_RemoveInterfacesFromAdapter:
    TraceError("CTcpipcfg::RemoveInterfacesFromAdapter", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// ITcpipProperties
//

// The following two methods are for remote tcpip configuration.
/*
typedef struct tagREMOTE_IPINFO
{
    DWORD   dwEnableDhcp;
    PWSTR pszIpAddrList;
    PWSTR pszSubnetMaskList;
    PWSTR pszOptionList;

} REMOTE_IPINFO;
*/

HRESULT CTcpipcfg::GetIpInfoForAdapter(const GUID*      pguidAdapter,
                                       REMOTE_IPINFO**  ppRemoteIpInfo)
{
    Assert(pguidAdapter);
    Assert(ppRemoteIpInfo);

    // Initialize the output parameter.
    //
    *ppRemoteIpInfo = NULL;

    HRESULT hr = S_OK;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguidAdapter);
    if (pAdapter)
    {
        // get the strings from the list
        tstring strIpAddressList;
        ConvertColStringToString(pAdapter->m_vstrIpAddresses,
                                 c_chListSeparator,
                                 strIpAddressList);

        tstring strSubnetMaskList;
        ConvertColStringToString(pAdapter->m_vstrSubnetMask,
                                 c_chListSeparator,
                                 strSubnetMaskList);

        //bug 272647 add gateway metric and interface metric into REMOTE_IPINFO
        tstring strOptionList;
        ConstructOptionListString(pAdapter,
                                  strOptionList);

        // allocate buffer for the output param
        DWORD dwBytes = sizeof(REMOTE_IPINFO) +
                        sizeof(WCHAR)*(strIpAddressList.length() + 1) +
                        sizeof(WCHAR)*(strSubnetMaskList.length() + 1) +
                        sizeof(WCHAR)*(strOptionList.length() + 1);

        PVOID   pbBuf;
        hr = HrCoTaskMemAlloc(dwBytes, &pbBuf);

        if (SUCCEEDED(hr))
        {
            ZeroMemory(pbBuf, dwBytes);

            REMOTE_IPINFO * pRemoteIpInfo = reinterpret_cast<REMOTE_IPINFO *>(pbBuf);
            pRemoteIpInfo->dwEnableDhcp = pAdapter->m_fEnableDhcp;

            BYTE* pbByte = reinterpret_cast<BYTE*>(pbBuf);

            // ip address
            pbByte+= sizeof(REMOTE_IPINFO);
            pRemoteIpInfo->pszwIpAddrList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwIpAddrList, strIpAddressList.c_str());

            // subnet mask
            pbByte += sizeof(WCHAR)*(strIpAddressList.length() + 1);
            pRemoteIpInfo->pszwSubnetMaskList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwSubnetMaskList, strSubnetMaskList.c_str());

            // default gateway
            pbByte += sizeof(WCHAR)*(strSubnetMaskList.length() + 1);
            pRemoteIpInfo->pszwOptionList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwOptionList, strOptionList.c_str());

            *ppRemoteIpInfo = pRemoteIpInfo;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TraceError("CTcpipcfg::GetIpInfoForAdapter", hr);
    return hr;
}

HRESULT CTcpipcfg::SetIpInfoForAdapter(const GUID*      pguidAdapter,
                                       REMOTE_IPINFO*   pRemoteIpInfo)
{
    Assert(pguidAdapter);
    Assert(pRemoteIpInfo);

    HRESULT hr = S_OK;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguidAdapter);
    if (pAdapter)
    {
    
        // Tell INetCfg that our component is dirty
        Assert(m_pTcpipPrivate);
        m_pTcpipPrivate->SetDirty();

        // set the flags so we write this to registry & send notification
        // at apply
        m_fSaveRegistry = TRUE;
        m_fReconfig = TRUE;

        // copy over the info to our data structure
        pAdapter->m_fEnableDhcp = !!pRemoteIpInfo->dwEnableDhcp;

        ConvertStringToColString(pRemoteIpInfo->pszwIpAddrList,
                                 c_chListSeparator,
                                 pAdapter->m_vstrIpAddresses);

        ConvertStringToColString(pRemoteIpInfo->pszwSubnetMaskList,
                                 c_chListSeparator,
                                 pAdapter->m_vstrSubnetMask);

        hr = HrParseOptionList(pRemoteIpInfo->pszwOptionList, pAdapter);

    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TraceError("CTcpipcfg::SetIpInfoForAdapter", hr);
    return hr;
}


STDMETHODIMP
CTcpipcfg::GetUiInfo (
    RASCON_IPUI*  pIpui)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pIpui)
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory (pIpui, sizeof(*pIpui));

        ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(
                                    &m_guidCurrentConnection);
        if (pAdapter)
        {
            if (!pAdapter->m_fEnableDhcp &&
                pAdapter->m_vstrIpAddresses.size())
            {
                pIpui->dwFlags |= RCUIF_USE_IP_ADDR;

                lstrcpyW(pIpui->pszwIpAddr,
                        pAdapter->m_vstrIpAddresses[0]->c_str());
            }

            if (pAdapter->m_vstrDnsServerList.size() > 0)
            {
                pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

                lstrcpyW(pIpui->pszwDnsAddr,
                        pAdapter->m_vstrDnsServerList[0]->c_str());

                if (pAdapter->m_vstrDnsServerList.size() > 1)
                {
                    lstrcpyW(pIpui->pszwDns2Addr,
                            pAdapter->m_vstrDnsServerList[1]->c_str());
                }
            }

            if (pAdapter->m_vstrWinsServerList.size() > 0)
            {
                pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

                lstrcpyW(pIpui->pszwWinsAddr,
                        pAdapter->m_vstrWinsServerList[0]->c_str());

                if (pAdapter->m_vstrWinsServerList.size() > 1)
                {
                    lstrcpyW(pIpui->pszwWins2Addr,
                            pAdapter->m_vstrWinsServerList[1]->c_str());
                }
            }

            if (pAdapter->m_fUseRemoteGateway)
            {
                 pIpui->dwFlags |= RCUIF_USE_REMOTE_GATEWAY;
            }

            if (pAdapter->m_fUseIPHeaderCompression)
            {
                pIpui->dwFlags |= RCUIF_USE_HEADER_COMPRESSION;
            }

            if (pAdapter->m_fDisableDynamicUpdate)
            {
                pIpui->dwFlags |= RCUIF_USE_DISABLE_REGISTER_DNS;
            }

            if (pAdapter->m_fEnableNameRegistration)
            {
                pIpui->dwFlags |= RCUIF_USE_PRIVATE_DNS_SUFFIX;
            }

            if (c_dwEnableNetbios == pAdapter->m_dwNetbiosOptions)
            {
                pIpui->dwFlags |= RCUIF_ENABLE_NBT;
            }

            lstrcpynW(pIpui->pszwDnsSuffix, 
                     pAdapter->m_strDnsDomain.c_str(), 
                     sizeof(pIpui->pszwDnsSuffix)/sizeof(pIpui->pszwDnsSuffix[0]));

            pIpui->dwFrameSize = pAdapter->m_dwFrameSize;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    TraceError("CTcpipcfg::GetUiInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcprsvp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P R S V P . H
//
//  Contents:   RSVP portion of TCP/IP
//
//  Notes:
//
//  Author:     kumarp    19-March-98
//
//----------------------------------------------------------------------------

#pragma once

HRESULT HrInstallRsvpProvider(VOID);
void RemoveRsvpProvider(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpmacro.h ===
// $REVIEW(tongl) the win32 Macros does not call ::SendMessage !!!
// This is a temporary solution, sent mail to BryanT, vcsig
#pragma once

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#ifndef POSTMSG
#ifdef __cplusplus
#define POSTMSG ::PostMessage
#else
#define POSTMSG PostMessage
#endif
#endif // ifndef POSTMSG

// ListBox_InsertString
#define Tcp_ListBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SNDMSG((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(PCWSTR)(lpsz)))

// ListBox_AddString
#define Tcp_ListBox_AddString(hwndCtl, lpsz) ((int)(DWORD)SNDMSG((hwndCtl), LB_ADDSTRING, 0L, (LPARAM)(PCWSTR)(lpsz)))

// ListBox_DeleteString
#define Tcp_ListBox_DeleteString(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

// ListBox_SetCurSel
#define Tcp_ListBox_SetCurSel(hwndCtl, index)  ((int)(DWORD)SNDMSG((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

// ListBox_GetCount
#define Tcp_ListBox_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0L, 0L))

// ListBox_GetTextLen
#define Tcp_ListBox_GetTextLen(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))

// ListBox_GetText
#define Tcp_ListBox_GetText(hwndCtl, index, lpszBuffer) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(PCWSTR)(lpszBuffer)))

// ListBox_GetCount
#define Tcp_ListBox_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0L, 0L))

// ListBox_DeleteString
#define Tcp_ListBox_DeleteString(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

// ListBox_GetCurSel
#define Tcp_ListBox_GetCurSel(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCURSEL, 0L, 0L))

// ListBox_ResetContent
#define Tcp_ListBox_ResetContent(hwndCtl)  ((BOOL)(DWORD)SNDMSG((hwndCtl), LB_RESETCONTENT, 0L, 0L))

// ListBox_FindStrExact
#define Tcp_ListBox_FindStrExact(hwndCtl, lpszStr) ((int)(DWORD)SNDMSG((hwndCtl), LB_FINDSTRINGEXACT, -1, (LPARAM)(PCWSTR)lpszStr))

// ComboBox_SetCurSel
#define Tcp_ComboBox_SetCurSel(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

// ComboBox_GetCurSel
#define Tcp_ComboBox_GetCurSel(hwndCtl)  ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCURSEL, 0L, 0L))

// ComboBox_GetCount
#define Tcp_ComboBox_GetCount(hwndCtl)  ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCOUNT, 0L, 0L))

// Tcp_Edit_LineLength
#define Tcp_Edit_LineLength(hwndCtl, line) ((int)(DWORD)SNDMSG((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

// PropSheet_CancelToClose (in prsht.h)
#define Tcp_PropSheet_CancelToClose(hDlg) POSTMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcpipobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P O B J . H
//
//  Contents:   Declaration of CTcpipcfg and helper functions.
//
//  Notes:
//
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <ncres.h>
#include <notifval.h>
#include "resource.h"
#include "tcpip.h"

#include "netconp.h"

extern "C"
{
#include "dhcpcapi.h"
};

/////////////////////////////////////////////////////////////////////////////
// Data types & Constants
struct REG_BACKUP_INFO
{
    DWORD dwOptionId;
    DWORD dwClassLen;
    DWORD dwDataLen;
    DWORD dwIsVendor;
    DWORD dwExpiryTime;
    DWORD dwData[1];
};

// when building the blob to be stored into the registry, the memory buffer
// that holds it is enlarged dynamically with chunks of the size below
// (for now, there are only 5 options of at most 2 dwords each - so prepare
// the chunk such that only one allocation is needed)
#define BUFFER_ENLARGEMENT_CHUNK    5*(sizeof(REG_BACKUP_INFO) + sizeof(DWORD))

// Max number of property sheet pages on tcpip's property sheet
static const INT c_cMaxTcpipPages = 6;

extern HICON   g_hiconUpArrow;
extern HICON   g_hiconDownArrow;

/////////////////////////////////////////////////////////////////////////////
// tcpipcfg

class ATL_NO_VTABLE CTcpipcfg :
    public CComObjectRoot,
    public CComCoClass<CTcpipcfg, &CLSID_CTcpipcfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentUpperEdge,
    public INetRasConnectionIpUiInfo,
    public ITcpipProperties,
    public INetCfgComponentSysPrep
{
public:

    CTcpipcfg();
    ~CTcpipcfg() { FinalFree(); }

    BEGIN_COM_MAP(CTcpipcfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentUpperEdge)
        COM_INTERFACE_ENTRY(INetRasConnectionIpUiInfo)
        COM_INTERFACE_ENTRY(ITcpipProperties)
        COM_INTERFACE_ENTRY(INetCfgComponentSysPrep)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CTcpipcfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_TCPIPCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgComponentUpperEdge
    STDMETHOD (GetInterfaceIdsForAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD*              pdwNumInterfaces,
        GUID**              ppguidInterfaceIds);

    STDMETHOD (AddInterfacesToAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD               dwNumInterfaces);

    STDMETHOD (RemoveInterfacesFromAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD               dwNumInterfaces,
        const GUID*         pguidInterfaceIds);

// INetRasConnectionIpUiInfo
    STDMETHOD (GetUiInfo) (RASCON_IPUI*  pInfo);

// ITcpipProperties
    STDMETHOD (GetIpInfoForAdapter) (const GUID* pguidAdapter,
                                     REMOTE_IPINFO**  ppInfo);
    STDMETHOD (SetIpInfoForAdapter) (const GUID* pguidAdapter,
                                     REMOTE_IPINFO* pInfo);

    // INetCfgComponentSysPrep
    STDMETHOD (SaveAdapterParameters) (
            INetCfgSysPrep* pncsp,
            LPCWSTR pszwAnswerSections,
            GUID* pAdapterInstanceGuid);

    STDMETHOD (RestoreAdapterParameters) (
            LPCWSTR pszwAnswerFile, 
            LPCWSTR pszwAnswerSection,
            GUID*   pAdapterInstanceGuid);
public:

    GLOBAL_INFO  m_glbSecondMemoryGlobalInfo;

    // Place to keep pointer to INetCfg from Initialize
    INetCfg * m_pnc;

    // Place to keep the pointer to context
    IUnknown * m_pUnkContext;

    // Access methods to second memory state
    const GLOBAL_INFO *     GetConstGlobalInfo() { return &m_glbSecondMemoryGlobalInfo; };
    GLOBAL_INFO *           GetGlobalInfo() { return &m_glbSecondMemoryGlobalInfo; };

    const VCARD *    GetConstAdapterInfoVector() { return &m_vcardAdapterInfo; };

    void    SetReconfig() { m_fReconfig = TRUE; };

    void    SetSecondMemoryLmhostsFileReset() { m_fSecondMemoryLmhostsFileReset = TRUE; };
    BOOL    FIsSecondMemoryLmhostsFileReset() { return m_fSecondMemoryLmhostsFileReset; }

//IPSec is removed from connection UI
//    void    SetSecondMemoryIpsecPolicySet() { m_fSecondMemoryIpsecPolicySet = TRUE; };

    void    SetSecondMemoryModified() { m_fSecondMemoryModified = TRUE; };

private:
    GLOBAL_INFO         m_glbGlobalInfo;
    VCARD               m_vcardAdapterInfo;

    ADAPTER_INFO*       m_pSecondMemoryAdapterInfo;

    VSTR                m_vstrBindOrder;

    class CTcpAddrPage*  m_ipaddr;

    INetCfgComponent*           m_pnccTcpip;
    INetCfgComponentPrivate*    m_pTcpipPrivate;
    INetCfgComponent*           m_pnccWins;

    tstring m_strDnsServerList;
    tstring m_strUpgradeGlobalDnsDomain;

    // Connection type
    ConnectionType  m_ConnType;
    GUID            m_guidCurrentConnection;

    BOOL    m_fSaveRegistry : 1;
    BOOL    m_fRemoving : 1;
    BOOL    m_fInstalling : 1;

    BOOL    m_fUpgradeCleanupDnsKey : 1;

    BOOL    m_fUpgradeGlobalDnsDomain : 1;

    // whether reconfig notification should be sent
    BOOL    m_fReconfig : 1; // Call SendHandlePnpEvent

    // Is there any bound physical card on Initialize
    // This is needed for Add/Remove LmHosts service
    // at apply time
    BOOL    m_fHasBoundCardOnInit : 1;

    BOOL    m_fLmhostsFileSet : 1;
    BOOL    m_fSecondMemoryLmhostsFileReset : 1;
    BOOL    m_fSecondMemoryModified : 1;

    //IPSec is removed from connection UI
    //BOOL    m_fIpsecPolicySet : 1;
    //BOOL    m_fSecondMemoryIpsecPolicySet : 1;

    // Fix 406630: Only used for RAS connection to identify whether the USER has 
    // write access to Global settings
    BOOL    m_fRasNotAdmin : 1;


private:
    void    FinalFree();
    void    ExitProperties();

    BOOL    FHasBoundCard();

    ADAPTER_INFO*   PAdapterFromInstanceGuid (const GUID* pGuid);
    ADAPTER_INFO*   PAdapterFromNetcfgComponent (INetCfgComponent* pncc);

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);

    HRESULT HrLoadGlobalParamFromAnswerFile(HINF hinf,
                                            PCWSTR pszAnswerSection);
    HRESULT HrLoadAdapterParameterFromAnswerFile(HINF hinf,
                                                 PCWSTR mszAdapterList);

    // Set router related parameters at install time
    // HRESULT HrInitRouterParamsAtInstall();

    // Initialize first in memory state
    HRESULT     HrGetNetCards();

    // Load adapterinfo for bound cards from first memory to second memory
    HRESULT HrLoadAdapterInfo();

    // Save adapterinfo from second memory to first memory
    HRESULT HrSaveAdapterInfo();

    // Set connection context
    HRESULT HrSetConnectionContext();

    // Allocate and deallocate property pages
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT *cPages);
    VOID CleanupPropPages(VOID);

    // Handle Add/Remove/Enable/Disable adapters on BindingPathNotify
    HRESULT HrAdapterBindNotify(INetCfgComponent *pnccNetCard,
                                DWORD dwChangeFlag,
                                PCWSTR szInterfaceName);

    HRESULT HrAddCard(INetCfgComponent * pnccNetCard,
                      PCWSTR szNetCardTcpipBindPath,
                      PCWSTR szInterfaceName);

    HRESULT HrDeleteCard(const GUID* pguid);
    HRESULT HrBindCard  (const GUID* pguid, BOOL fInitialize = FALSE);
    HRESULT HrUnBindCard(const GUID* pguid, BOOL fInitialize = FALSE);

    // Help functions to interface methods
    HRESULT MarkNewlyAddedCards(const HKEY hkeyTcpipParam);

    HRESULT HrGetListOfAddedNdisWanCards(const HKEY hkeyTcpipParam,
                                         VSTR * const pvstrAddedNdisWanCards);

    HRESULT HrLoadSettings();
    HRESULT HrLoadTcpipRegistry(const HKEY hkeyTcpipParam);
    HRESULT HrLoadWinsRegistry(const HKEY hkeyWinsParam);

    HRESULT HrSaveSettings();
    HRESULT HrSaveTcpipRegistry(const HKEY hkeyTcpipParam);
    HRESULT HrSaveMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces, ADAPTER_INFO* pAdapter);
    HRESULT HrSaveWinsMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces, ADAPTER_INFO* pAdapter);
    HRESULT HrSaveWinsRegistry(const HKEY hkeyWinsParam);
    HRESULT HrSetMisc(const HKEY hkeyTcpipParam, const HKEY hkeyWinsParam);
    HRESULT HrGetDhcpOptions(OUT VSTR * const GlobalOptions,
                             OUT VSTR * const PerAdapterOptions);

    HRESULT HrSaveStaticWanRegistry(HKEY hkeyInterfaceParam);
    HRESULT HrSaveStaticAtmRegistry(HKEY hkeyInterfaceParam);

    // Dhcp functions
    HRESULT HrNotifyDhcp();

    HRESULT HrCallDhcpConfig(PWSTR ServerName,
                             PWSTR AdapterName,
                             GUID  & guidAdapter,
                             BOOL IsNewIpAddress,
                             DWORD IpIndex,
                             DWORD IpAddress,
                             DWORD SubnetMask,
                             SERVICE_ENABLE DhcpServiceEnabled);

    HRESULT HrCallDhcpHandlePnPEvent(ADAPTER_INFO * pAdapterInfo,
                                     LPDHCP_PNP_CHANGE pDhcpPnpChange);

    HRESULT HrDhcpRefreshFallbackParams(ADAPTER_INFO * pAdapterInfo);

    // Call SendNdisHandlePnpEvent to notify tcpip and netbt of
    // parameter changes
    HRESULT HrReconfigAtmArp(ADAPTER_INFO* pAdapterInfo,
                            INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigDns(BOOL fDoReconfigWithoutCheckingParams = FALSE);
    HRESULT HrReconfigIp(INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigNbt(INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigWanarp(ADAPTER_INFO* pAdapterInfo,
                            INetCfgPnpReconfigCallback* pICallback);

//IPSec is removed from connection UI
//    HRESULT HrSetActiveIpsecPolicy();

    //Some tcpip params are duplicated to the old Nt4 location to solve compatibility issues.
    HRESULT HrDuplicateToNT4Location(HKEY hkeyInterface, ADAPTER_INFO * pAdapter);
    //We need to clean it up when removing tcpip
    HRESULT HrRemoveNt4DuplicateRegistry();

    // Reinitialize internal state if Apply or Cancel is called
    void ReInitializeInternalState();

    // Upgrade registry in post pnp checkin cases
    HRESULT HrUpgradePostPnpRegKeyChange();

    // Add a new RAS fake GUID if the one set in context is not yet added.
    HRESULT UpdateRasAdapterInfo(
        const RASCON_IPUI& RasInfo);

    HRESULT HrLoadBindingOrder(VSTR *pvstrBindOrder);
    BOOL IsBindOrderChanged();

    HRESULT HrCleanUpPerformRouterDiscoveryFromRegistry();

    // Loads Fallback configuration from registry
    HRESULT HrLoadBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter);
    // Loads one option from the registry blob into the BACKUP_CFG_INFO structure
    HRESULT HrLoadBackupOption(REG_BACKUP_INFO *pOption, BACKUP_CFG_INFO *pBackupInfo);

    // Saves Fallback configuration to registry
    HRESULT HrSaveBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter);
    // Appends one option to the blob to be written into the registry
    HRESULT HrSaveBackupDwordOption (
                DWORD  Option,
                DWORD  OptionData[],
                DWORD  OptionDataSz,
                LPBYTE  *ppBuffer,
                LPDWORD pdwBlobSz,
                LPDWORD pdwBufferSz);

    HRESULT HrDeleteBackupSettingsInDhcp(LPCWSTR wszAdapterName);

    HRESULT HrOpenTcpipInterfaceKey(
                    const GUID & guidInterface,
                    HKEY * phKey,
                    REGSAM sam);

    HRESULT HrOpenNetBtInterfaceKey(
                    const GUID & guidInterface,
                    HKEY * phKey,
                    REGSAM sam);

    HRESULT HrSetSecurityForNetConfigOpsOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName);

public:
    ADAPTER_INFO * GetConnectionAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    };

    ConnectionType GetConnectionType()
    {
        return m_ConnType;
    };

    BOOL IsRasNotAdmin()
    {
        return m_fRasNotAdmin;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcputil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P U T I L . C P P
//
//  Contents: Utility functions used by tcpipcfg
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <dsrole.h>
#include "ncatlui.h"
#include <time.h>
#include "ncreg.h"
#include "ncstl.h"
#include "ncui.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "resource.h"
#include "tcpmacro.h"
#include "atmcommon.h"

#define MAX_NUM_DIGIT_MULTI_INTERFACES  10

extern const WCHAR c_szNetCfgHelpFile[];

// HrLoadSubkeysFromRegistry
// Gets the list of subkeys under a registry key
// hkey             the root registry key
// pvstrAdapters    returns the list of subkeykey names from hkey

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkey,
                                  OUT VSTR * const pvstrSubkeys)
{
    HRESULT hr = S_OK;
    Assert(pvstrSubkeys);

    // Initialize output parameter
    FreeCollectionAndItem(*pvstrSubkeys);

    WCHAR szBuf[256];
    FILETIME time;
    DWORD dwSize = celems(szBuf);
    DWORD dwRegIndex = 0;

    while(SUCCEEDED(hr = HrRegEnumKeyEx(hkey, dwRegIndex++, szBuf,
                                        &dwSize, NULL, NULL, &time)))
    {
        dwSize = celems(szBuf);
        Assert(szBuf);
        pvstrSubkeys->push_back(new tstring(szBuf));
    }

    if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        hr = S_OK;

    TraceError("HrLoadSubkeysFromRegistry", hr);
    return hr;
}

//
//HrIsComponentInstalled      Given a Component ID, determins if the component
//                            is installed in the system
// Note: The net class of the component must be
//
//pnc              the system's INetCfg
//rguidClass       the Net Class of this component we are earching for
//pszInfId          the Component ID
//pfInstalled      returns a flag to determine if the component is installed
//
// Returns S_OK if succeed ( whether component found or not
//         Other: ERROR

HRESULT HrIsComponentInstalled(INetCfg * pnc,
                             const GUID& rguidClass,
                             PCWSTR pszInfId,
                             OUT BOOL * const pfInstalled)
{
    Assert(pnc);
    Assert(pszInfId);
    Assert(pfInstalled);

    *pfInstalled = FALSE;

    INetCfgComponent *  pncc;

    HRESULT hr = pnc->FindComponent(pszInfId, &pncc);

    if(hr == S_OK)
    {
        Assert(pncc);
        *pfInstalled = TRUE;
    }
    else if(hr == S_FALSE)
    {
        Assert(!pncc);
        *pfInstalled = FALSE;
        hr = S_OK;
    }

    ReleaseObj(pncc);

    TraceError("HrIsComponentInstalled", hr);
    return hr;
}

//
//  GetNodeNum
//
//  Get an IP Address and return the 4 numbers in the IP address.
//
//  pszIpAddress:    IP Address
//  ardw[4]:        The 4 numbers in the IP Address

VOID GetNodeNum(PCWSTR pszIpAddress, DWORD ardw[4])
{
    VSTR    vstr;

    tstring strIpAddress(pszIpAddress);

    ConvertStringToColString(strIpAddress.c_str(),
                             CH_DOT,
                             vstr);

    VSTR_ITER iter = vstr.begin();
    // Go through each field and get the number value

    ardw[0] = 0;
    ardw[1] = 0;
    ardw[2] = 0;
    ardw[3] = 0;

    if(iter != vstr.end())
    {
        ardw[0] = _ttol((*iter++)->c_str());
        if(iter != vstr.end())
        {
            ardw[1] = _ttol((*iter++)->c_str());
            if(iter != vstr.end())
            {
                ardw[2] = _ttol((*iter++)->c_str());
                if(iter != vstr.end())
                {
                    ardw[3] = _ttol((*iter++)->c_str());
                }
            }
        }
    }
    FreeCollectionAndItem(vstr);
}

//Check if the subnet mask is contiguous
//Return:   TRUE    contiguous
//          FALSE   uncontigous
BOOL IsContiguousSubnet(PCWSTR pszSubnet)
{
    DWORD ardwSubnet[4];

    GetNodeNum(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
             + (ardwSubnet[2] << 8) + ardwSubnet[3];


    DWORD i, dwContiguousMask;

    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;
    for (i = 0; i < sizeof(dwMask)*8; i++)
    {
        dwContiguousMask |= 1 << i;

        if (dwContiguousMask & dwMask)
            break;
    }

    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}

// Replace first element of a vector of tstrings
VOID ReplaceFirstAddress(VSTR * pvstr, PCWSTR pszIpAddress)
{
    Assert(pszIpAddress);

    if(pvstr->empty())
    {
        pvstr->push_back(new tstring(pszIpAddress));
    }
    else
    {
        *(*pvstr)[0] = pszIpAddress;
    }
}

// Replace second element of a vector of tstrings
VOID ReplaceSecondAddress(VSTR * pvstr, PCWSTR pszIpAddress)
{
    Assert(pszIpAddress);

    if (pvstr->size()<2)
    {
        pvstr->push_back(new tstring(pszIpAddress));
    }
    else
    {
        *(*pvstr)[1] = pszIpAddress;
    }
}

// Generate subnetmask for an IP address
BOOL GenerateSubnetMask(IpControl & ipAddress,
                        tstring * pstrSubnetMask)
{
    BOOL bResult = TRUE;

    if (!ipAddress.IsBlank())
    {
        tstring strAddress;
        DWORD adwIpAddress[4];

        ipAddress.GetAddress(&strAddress);
        GetNodeNum(strAddress.c_str(), adwIpAddress);

        DWORD nValue = adwIpAddress[0];

        if(nValue <= SUBNET_RANGE_1_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_1;
        }
        else if( nValue <= SUBNET_RANGE_2_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_2;
        }
        else if( nValue <= SUBNET_RANGE_3_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_3;
        }
        else
        {
            Assert(FALSE);
            bResult = FALSE;
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

// BOOL fIsSameVstr
// Return TRUE is all strings in a vstr are the same and in same order
BOOL fIsSameVstr(const VSTR vstr1, const VSTR vstr2)
{
    int iCount1 = vstr1.size();
    int iCount2 = vstr2.size();
    int idx =0;

    if (iCount1 != iCount2)
    {
        return FALSE;
    }
    else // same size
    {
        // For each string in both vstr1 and vstr2
        for (idx=0; idx<iCount1; idx++)
        {
            // if mismatch found
            if((*vstr1[idx] != *vstr2[idx]))
            {
                return FALSE;
            }
        }
    }

    Assert((iCount1==iCount2) && (iCount1==idx));
    return TRUE;
}

// Registry access help functions for Boolean type
// FRegQueryBool
// hkey         the regisry key
// pszName       the value in the registry key
// fValue       the default vaule
//
// NOTE:    If the function failed to read the value from the registry, it will return
//          the default value.

BOOL    FRegQueryBool(const HKEY hkey, PCWSTR pszName, BOOL fDefaultValue)
{
    BOOL fRetValue = fDefaultValue;
    DWORD dwValue;

    HRESULT hr = HrRegQueryDword(hkey, pszName, &dwValue);

    if (S_OK == hr)
    {
        fRetValue = !!dwValue;
    }
#ifdef ENABLETRACE
    else
    {
        const HRESULT hrNoRegValue = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        if (hr == hrNoRegValue)
        {
            TraceTag(ttidTcpip, "FRegQueryBool: registry key %S not found", pszName);
            hr = S_OK;
        }
    }
#endif

    TraceError("FRegQueryBool", hr);
    return fRetValue;
}



// ResetLmhostsFile
// Called by Cancel and Cancelproperties to roll back changes to the file lmhosts
VOID ResetLmhostsFile()
{
    WCHAR szSysPath[MAX_PATH] = {0};
    WCHAR szSysPathBackup[MAX_PATH];

    BOOL fSysPathFound = (GetSystemDirectory(szSysPath, MAX_PATH) != 0);

    lstrcpyW(szSysPathBackup, szSysPath);

    wcscat(szSysPath, RGAS_LMHOSTS_PATH);
    wcscat(szSysPathBackup, RGAS_LMHOSTS_PATH_BACKUP);

    WIN32_FIND_DATA FileData;
    if (FindFirstFile(szSysPathBackup, &FileData) == INVALID_HANDLE_VALUE)
    {
        AssertSz(FALSE, "lmhosts.bak file not found");
    }
    else
    {
        BOOL ret;

        // Rename lmhosts.bak file to lmhosts
        ret = MoveFileEx(szSysPathBackup, szSysPath, MOVEFILE_REPLACE_EXISTING);
        AssertSz(ret, "Failed to restore lmhosts file!");
    }
}

//
//  IPAlertPrintf() - Does a printf to a message box for IP address
//
//  ids: message string, IDS_IPBAD_FIELD_VALUE
//  iCurrent: value of the field
//  iLow: Low range of the field
//  iHigh: High range of the field
//
int IPAlertPrintf(HWND hwndParent, UINT ids,
                  int iCurrent, int iLow, int iHigh)
{

    if (ids != IDS_IPNOMEM)
    {
        WCHAR szCurrent[3];
        wsprintfW(szCurrent, c_szItoa, iCurrent);

        WCHAR szLow[3];
        wsprintfW(szLow, c_szItoa, iLow);

        WCHAR szHigh[3];
        wsprintfW(szHigh, c_szItoa, iHigh);

        return NcMsgBox(hwndParent,
                        IDS_IPMBCAPTION,
                        ids,
                        MB_ICONEXCLAMATION,
                        szCurrent, szLow, szHigh);
    }
    else
        return NcMsgBox(hwndParent,
                        IDS_IPMBCAPTION,
                        ids,
                        MB_ICONEXCLAMATION);

}

// IpRangeError
//
VOID IpCheckRange(LPNMIPADDRESS lpnmipa, HWND hWnd, int iLow, int iHigh, BOOL fCheckLoopback)
{
    /*
    // This is a workaround because the IP control will send this notification
    // twice if I don't set the out of range value in this code. However there
    // is no way to set the value of an individual field. Send request to strohma.
    static BOOL fNotified = FALSE;
    static int iNotifiedValue = 0;

    if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
    {
        if (!fNotified) // If we havn't been notified yet
        {
            fNotified = TRUE;
            iNotifiedValue = lpnmipa->iValue;

            IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                          lpnmipa->iValue, iLow, iHigh);
        }
        else // ignor the second notify
        {
            // Make sure we are alerted of change in the workaround from common control
            AssertSz(iNotifiedValue == lpnmipa->iValue, "Common control behaviour changed!!");
            fNotified = FALSE;
            iNotifiedValue =0;
        }
    };
    */
/*
    // This is a workaround because the IP control will send this notification
    // twice if I don't set the out of range value in this code. However there
    // is no way to set the value of an individual field. Send request to strohma.
    if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
    {
        IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                      lpnmipa->iValue, iLow, iHigh);
        if (lpnmipa->iValue<iLow)
            lpnmipa->iValue = iLow;
        else
            lpnmipa->iValue = iHigh;

    };
*/

    //$REVIEW (nsun) BUG171839 this is a workaround because the IP control will send this notifcation
    // twice when I put a 3 digit value. I added a static value to make sure every error message
    // is brought up only once
    // The static values that should be able to uniquely identify a notification
    static UINT idIpControl = 0;
    static int  iField = 0;
    static int  iValue = 0;

    //we know the notification may be sent twice
    //We only want to the second duplcate notifiction
    //If we receive the third notification with the same control, field and value, it should
    //be real notification and we shouldn't ignore it.
    static UINT  cRejectTimes = 0;

    if(idIpControl != lpnmipa->hdr.idFrom ||
       iField != lpnmipa->iField || iValue != lpnmipa->iValue || cRejectTimes > 0)
    {
        //update the static values
        //(nsun) We have to update the static values before the error
        //  message box because there will be IPN_FIELDCHANGED notification
        //  sent out when the message box is brought up.
        cRejectTimes = 0;
        idIpControl = lpnmipa->hdr.idFrom;
        iField = lpnmipa->iField;
        iValue = lpnmipa->iValue;

        if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
        {
            IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                          lpnmipa->iValue, iLow, iHigh);
        }

        if (fCheckLoopback && lpnmipa->iValue == c_iIPADDR_FIELD_1_LOOPBACK
            && 0 == lpnmipa->iField)
        {
            IPAlertPrintf(hWnd, IDS_INCORRECT_IP_LOOPBACK,
                          lpnmipa->iValue, iLow, iHigh);
            lpnmipa->iValue = iLow;
        }
    }
    else
    {
        cRejectTimes++;
    }

}


//+---------------------------------------------------------------------------
//
//  Name:     SetButtons
//
//  Purpose:   Enables/disables push buttons based on item count and current selection
//             in the list.
//             Used by DNS and ATM ARPC pages that have group of HANDLES
//
//  Arguments:
//      h         [in]   The group of handles
//      nNumLimit [in]   Limit of number of elements allowed in the list
//
//  Returns:    Nothing
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
VOID SetButtons(HANDLES& h, const int nNumLimit)
{
    Assert(IsWindow(h.m_hList));
    Assert(IsWindow(h.m_hAdd));
    Assert(IsWindow(h.m_hEdit));
    Assert(IsWindow(h.m_hRemove));

    // $REVIEW(tongl):macro problem
    int nCount = Tcp_ListBox_GetCount(h.m_hList);

    // If there are currently no item in list, set focus to "Add" button
    if (!nCount)
    {
        // remove the default on the remove button, if any
        SendMessage(h.m_hRemove, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        // move focus to Add button
        ::SetFocus(h.m_hAdd);
    }

    // If number of items less than limit, enable "Add" button
    // Otherwise disable it
    if (nCount != nNumLimit)
        ::EnableWindow(h.m_hAdd, TRUE);
    else
    {
        //disable the button and move focus only if the add button is currently enabled
        if (::IsWindowEnabled(h.m_hAdd))
        {
            // disable "Add button"
            ::EnableWindow(h.m_hAdd, FALSE);

            // remove the default on the add button, if any
            SendMessage(h.m_hAdd, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            // move focus to edit button
            ::SetFocus(h.m_hEdit);
        }
    }

    // If number of items >0, enable "Edit" and "Remove" buttons
    // Otherwise disable them

    ::EnableWindow(h.m_hEdit, nCount);
    ::EnableWindow(h.m_hRemove, nCount);

    // Enable/disable the "Up" and "Down" buttons

    // determine Up and Down logic
    if (nCount > 1)
    {
        int idxCurSel = Tcp_ListBox_GetCurSel(h.m_hList);
        Assert(idxCurSel != CB_ERR );

        BOOL fChangeFocus = FALSE;

        if (idxCurSel == 0)
        {
            if (h.m_hUp == ::GetFocus())
                fChangeFocus = TRUE;

            ::EnableWindow(h.m_hUp, FALSE);
            ::EnableWindow(h.m_hDown, TRUE);

            // remove the default on the up button, if any
            SendMessage(h.m_hUp, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            if (fChangeFocus)
                ::SetFocus(h.m_hDown);
        }
        else if (idxCurSel == (nCount-1))
        {
            if (h.m_hDown == ::GetFocus())
                fChangeFocus = TRUE;

            ::EnableWindow(h.m_hUp, TRUE);
            ::EnableWindow(h.m_hDown, FALSE);

            // remove the default on the down button, if any
            SendMessage(h.m_hDown, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            if (fChangeFocus)
                ::SetFocus(h.m_hUp);
        }
        else
        {
            ::EnableWindow(h.m_hUp, TRUE);
            ::EnableWindow(h.m_hDown, TRUE);
        }
    }
    else
    {
        ::EnableWindow(h.m_hUp, FALSE);
        ::EnableWindow(h.m_hDown, FALSE);
    }

}

//+---------------------------------------------------------------------------
//
//  Name:     ListBoxRemoveAt
//
//  Purpose:   Remove an item from a list box and save it to a tstring
//             Used by DNS and ATM ARPC pages.
//
//  Arguments:
//      hListBox            [in]   Handle to the list box
//      idx                 [in]   Index of the item to remove
//      pstrRemovedItem     [out]  The content of the removed item
//
//  Returns:    TRUE if succeeded, else FALSE
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
BOOL ListBoxRemoveAt(HWND hListBox, int idx, tstring * pstrRemovedItem)
{
    BOOL bResult = FALSE;

    Assert(idx >=0);
    Assert(hListBox);

    WCHAR buf[MAX_PATH];
    int len;
    if((len = Tcp_ListBox_GetTextLen(hListBox, idx)) >= celems(buf))
    {
        Assert(FALSE);
        return FALSE;
    }
    Assert(len != 0);

    Tcp_ListBox_GetText(hListBox, idx, buf);
    *pstrRemovedItem = buf;

    if (len != 0)
    {
        if (::SendMessage(hListBox,
                          LB_DELETESTRING,
                          (WPARAM)(int)(idx), 0L) != LB_ERR)

            bResult = TRUE;
    }

    return bResult;
}

//+---------------------------------------------------------------------------
//
//  Name:     ListBoxInsertAfter
//
//  Purpose:   Insert an item into a list box
//             Used by DNS and ATM ARPC pages
//
//  Arguments:
//      hListBox    [in]   Handle to the list box
//      idx         [in]   Index of the item to insert after
//      pszItem      [out]  The item to insert
//
//  Returns:    TRUE if succeeded, else FALSE
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
BOOL ListBoxInsertAfter(HWND hListBox, int idx, PCWSTR pszItem)
{
#ifdef DBG
    Assert(hListBox);

    // validate the range
    int nCount = Tcp_ListBox_GetCount(hListBox);

    Assert(idx >=0);
    Assert(idx <= nCount);

    // insist there is a string
    Assert(pszItem);
#endif

    return (Tcp_ListBox_InsertString(hListBox, idx, pszItem) == idx);
}

//+---------------------------------------------------------------------------
//
//  Name:     HrRegRenameTree
//
//  Purpose:   Rename a registr subkey
//
//  Arguments:
//      hkeyRoot    [in]   The root key where the subkey to be renamed exists
//      pszOldName   [in]   The existing name of the sub key
//      pszNewName   [in]   The new name of the sub key
//
//  Returns:    S_OK if succeeded,
//              E_FAIL otherwise
//
//  Author:     tongl  7 Aug 1997
//
//  Notes:
//
HRESULT HrRegRenameTree(HKEY hkeyRoot, PCWSTR pszOldName, PCWSTR pszNewName)
{
    HRESULT hr = S_OK;
    HKEY hkeyNew = NULL;
    HKEY hkeyOld = NULL;
    DWORD dwDisposition;

    //$REVIEW (nsun) make sure we don't rename the same tree
    if(0 == lstrcmpiW (pszOldName, pszNewName))
        return S_OK;

    // Create new subkey
    hr = HrRegCreateKeyEx(hkeyRoot,
                          pszNewName,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ_WRITE,
                          NULL,
                          &hkeyNew,
                          &dwDisposition);

    if (S_OK == hr)
    {
        // Copy all items under old subkey to new subkey
        hr = HrRegOpenKeyEx(hkeyRoot,
                            pszOldName,
                            KEY_READ_WRITE_DELETE,
                            &hkeyOld);
        if (S_OK == hr)
        {
            hr = HrRegCopyKeyTree(hkeyNew, hkeyOld);
            RegSafeCloseKey(hkeyOld);

            if (S_OK == hr)
            {
                // Delete old subkey
                hr = HrRegDeleteKeyTree(hkeyRoot, pszOldName);
            }
        }
    }
    RegSafeCloseKey(hkeyNew);

    TraceTag(ttidTcpip, "HrRegRenameTree failed to rename %S to %S", pszOldName, pszNewName);

    TraceError("Tcpipcfg: HrRegRenameTree failed", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrRegCopyKeyTree
//
//  Purpose:   Copies a registry subtree to a new location
//
//  Arguments:
//      hkeyDest    [in]   The subkey to copy to
//      hkeySrc     [in]   The subkey to copy from
//
//  Returns:    S_OK if succeeded,
//              E_FAIL otherwise
//
//  Author:     tongl  7 Aug 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//
HRESULT HrRegCopyKeyTree(HKEY hkeyDest, HKEY hkeySrc )
{
    HRESULT hr = S_OK;
    FILETIME ftLastWrite;

    DWORD cchMaxSubKeyLen;
    DWORD cchMaxClassLen;
    DWORD cchMaxValueNameLen;
    DWORD cbMaxValueLen;

    DWORD  iItem;
    PWSTR pszName;
    PWSTR pszClass;
    PBYTE pbData;

    DWORD cchName;
    DWORD cchClass;
    DWORD cbData;

    HKEY hkeyChildDest = NULL;
    HKEY hkeyChildSrc = NULL;

    DWORD dwDisposition;

    // Find out the longest name and data field and create the buffers
    // to store enumerations in
    //
    LONG lrt;
    lrt =  RegQueryInfoKeyW( hkeySrc,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &cchMaxSubKeyLen,
                            &cchMaxClassLen,
                            NULL,
                            &cchMaxValueNameLen,
                            &cbMaxValueLen,
                            NULL,
                            &ftLastWrite );
    do
    {
        if (ERROR_SUCCESS != lrt)
        {
            hr = HrFromLastWin32Error();
            break;
        }

        // use only one buffer for all names, values or keys
        cchMaxValueNameLen = max( cchMaxSubKeyLen, cchMaxValueNameLen );

        // allocate buffers
        hr = E_OUTOFMEMORY;

        pszName = new WCHAR[cchMaxValueNameLen + 1];
        if (NULL == pszName)
        {
            break;
        }

        pszClass = new WCHAR[cchMaxClassLen + 1];
        if (NULL == pszClass)
        {
            delete [] pszName;
            break;
        }

        pbData = new BYTE[ cbMaxValueLen ];
        if (NULL == pbData)
        {
            delete [] pszName;
            delete [] pszClass;
            break;
        }

        hr = S_OK;

        // enum all sub keys and copy them
        //
        iItem = 0;
        do
        {
            cchName = cchMaxValueNameLen + 1;
            cchClass = cchMaxClassLen + 1;

            // Enumerate the subkeys
            hr = HrRegEnumKeyEx(hkeySrc,
                                iItem,
                                pszName,
                                &cchName,
                                pszClass,
                                &cchClass,
                                &ftLastWrite );
            iItem++;
            if (SUCCEEDED(hr))
            {
                // create key at destination
                // Note: (tongl 8/7/97): Netcfg common code sets class to NULL ??
                hr = HrRegCreateKeyEx(  hkeyDest,
                                        pszName,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE,
                                        NULL,
                                        &hkeyChildDest,
                                        &dwDisposition );

                if (S_OK != hr)
                {
                    break;
                }

                // open the key at source
                hr = HrRegOpenKeyEx(hkeySrc,
                                    pszName,
                                    KEY_READ_WRITE,
                                    &hkeyChildSrc );

                if (S_OK != hr)
                {
                    RegSafeCloseKey(hkeyChildDest);
                    break;
                }

                // copy this sub-tree
                hr = HrRegCopyKeyTree(hkeyChildDest, hkeyChildSrc);

                RegSafeCloseKey(hkeyChildDest);
                RegSafeCloseKey(hkeyChildSrc);
            }

        } while (S_OK == hr);

        // We are done with the subkeys, now onto copying values
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            // enum completed, no errors
            //

            DWORD dwType;
            // enum all values and copy them
            //
            iItem = 0;
            do
            {
                cchName = cchMaxValueNameLen + 1;
                cbData = cbMaxValueLen;

                hr = HrRegEnumValue(hkeySrc,
                                    iItem,
                                    pszName,
                                    &cchName,
                                    &dwType,
                                    pbData,
                                    &cbData );
                iItem++;
                if (S_OK == hr)
                {
                    // write the value to the destination
                    hr = HrRegSetValueEx(hkeyDest,
                                         pszName,
                                         dwType,
                                         pbData,
                                         cbData );
                }
            } while (S_OK == hr);

            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // if we hit the end of the enum without error
                // reset error code to success
                //
                hr = S_OK;
            }
        }

        // free our buffers
        delete [] pszName;
        delete [] pszClass;
        delete [] pbData;
    } while ( FALSE );

    TraceError("HrRegCopyKeyTree failed.", hr);
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Name:     fQueryFirstAddress
//
//  Purpose:   Retrieves the first string in a vector of strings
//
//  Arguments:
//      vstr    [in]   The vector of strings
//      pstr    [in]   The first string
//
//  Returns:    TRUE if succeeded,
//              FALSE otherwise
//
//  Author:     tongl  10 Nov 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//

BOOL fQueryFirstAddress(const VSTR & vstr, tstring * const pstr)
{
    if(vstr.empty())
    {
        *pstr = L"";
        return FALSE;
    }
    else
    {
        *pstr = *vstr[0];
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Name:     fQuerySecondAddress
//
//  Purpose:   Retrieves the first string in a vector of strings
//
//  Arguments:
//      vstr    [in]   The vector of strings
//      pstr    [in]   The second string
//
//  Returns:    TRUE if succeeded,
//              FALSE otherwise
//
//  Author:     tongl  10 Nov 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//

BOOL fQuerySecondAddress(const VSTR & vstr, tstring * const pstr)
{
    if(vstr.size()<2)
    {
        *pstr = L"";
        return FALSE;
    }
    else
    {
        *pstr = *vstr[1];
        return TRUE;
    }
}

// Function that decides whether a string is a valid ATM address
// Return TRUE if Valid, return FALSE and the index of the first
// invalid character if invalid.
BOOL FIsValidAtmAddress(PCWSTR pszAtmAddress,
                        INT * piErrCharPos,
                        INT * pnId)
{
    const WCHAR * pch;
    *piErrCharPos =0;
    *pnId =0;

    // 1. Validate characters must be '+' (first character),
    //    '.', or hex digits '0'~'F'
    for (pch=pszAtmAddress; *pch; pch++)
    {
        if (!(((*pch == L'+') && (pch == pszAtmAddress))||
              (*pch == L'.')||
              (((*pch >= L'0') && (*pch <= L'9'))||
               ((*pch >= L'A') && (*pch <= L'F'))||
               ((*pch >= L'a') && (*pch <= L'f')))))
        {
            *piErrCharPos = pch - pszAtmAddress;
            *pnId = IDS_ATM_INVALID_CHAR;
            return FALSE;
        }

        if (*pch == L'.')
        {
            // '.' is for punctuation, so it should not be at the beginning,
            // end or have two in a row

            if ((pch == pszAtmAddress) ||
                (pch == pszAtmAddress+lstrlenW(pszAtmAddress)-1) ||
                (*pch == *(pch+1)))
            {
                *piErrCharPos = pch-pszAtmAddress;
                *pnId = IDS_ATM_INVALID_CHAR;
                return FALSE;
            }
        }
    }

    // 2. Strip off all punctuation characters ('.' characters)
    PWSTR pszBuff = new WCHAR[lstrlenW(pszAtmAddress)+1];
    if (NULL == pszBuff)
        return TRUE;

    PWSTR pchBuff = pszBuff;
    pch = pszAtmAddress;

    for (pch = pszAtmAddress; *pch; pch++)
    {
        if (*pch != L'.')
        {
            *pchBuff = *pch;
            pchBuff++;
        }
    }

    *pchBuff = L'\0';

    // 3. Decide whether the address is E.164 or NSAP
    //    and check syntax accordingly

    if ((lstrlenW(pszBuff) <= 15) ||
        ((*pszBuff == L'+') && (lstrlenW(pszBuff) <= 16)))
    {
        // The address is E.164;
        // Check if string is empty
        if (*pchBuff == L'+')
        {
            pchBuff++;

            if (lstrlenW(pchBuff) == 0) // empty string
            {
                *pnId = IDS_ATM_EMPTY_ADDRESS;
                delete pszBuff;

                return FALSE;
            }
        }

        // Check that all characters are in range '0' through '9'
        // i.e. (ASCII values)
        pch = pszAtmAddress;
        if (*pch == L'+')
        {
            pch++;
        }

        while (*pch)
        {
            if ((*pch != L'.') &&
                (!((*pch >= L'0') && (*pch <= L'9'))))
            {
                *piErrCharPos = pch-pszAtmAddress;
                *pnId = IDS_ATM_INVALID_CHAR;

                delete pszBuff;
                return FALSE;
            }
            pch++;
        }
    }
    else
    {
        // The address is NSAP;
        if (lstrlenW(pszBuff) != 40)
        {
            *pnId = IDS_ATM_INVALID_LENGTH;

            delete pszBuff;
            return FALSE;
        }
    }

    delete pszBuff;
    return TRUE;
}

BOOL FIsIpInRange(PCWSTR pszIp)
{
    BOOL fReturn = TRUE;
    DWORD ardwIp[4];
    GetNodeNum(pszIp, ardwIp);

    if ((ardwIp[0] > c_iIPADDR_FIELD_1_HIGH) ||
        (ardwIp[0] < c_iIPADDR_FIELD_1_LOW))
    {
        fReturn = FALSE;
    }

    return fReturn;
}

VOID ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs)
{
    if (pdwHelpIDs != NULL)
    {
        WinHelp(hDlg,
                c_szNetCfgHelpFile,
                uCommand,
                (ULONG_PTR)pdwHelpIDs);
    }
}


//+---------------------------------------------------------------------------
//
//  Name:     AddInterfacesToAdapterInfo
//
//  Purpose:   Add several interfaces IDs into the interface list
//
//  Arguments:
//      pAdapter        [in]    Adapter info to add interfaces to
//      dwNumInterfaces [in]    Number of interface IDs to be added
//
//  Returns:    None
//
//  Author:     nsun  22 August 1998
//
//
VOID AddInterfacesToAdapterInfo(
    ADAPTER_INFO*   pAdapter,
    DWORD           dwNumInterfaces)
{
    DWORD i;
    GUID  guid;

    for (i = 0; i < dwNumInterfaces; i++)
    {
        if (SUCCEEDED(CoCreateGuid(&guid)))
        {
            pAdapter->m_IfaceIds.push_back(guid);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Name:     GetGuidArrayFromIfaceColWithCoTaskMemAlloc
//
//  Purpose:   Get the data as a DWORD array from a DWORD list.
//             The caller is responsible to free the array by
//             calling CoTaskMemFree()
//
//  Arguments:
//      ldw     [in]    The DWORD list
//      ppdw    [out]   Pointer to the array
//      pcguid  [out]   The count of guids placed in the array.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Author:     nsun  22 August 1998
//
//
HRESULT GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
    const IFACECOL& Ifaces,
    GUID**          ppguid,
    DWORD*          pcguid)
{
    Assert(pcguid);

    // Initialize output parameters
    //
    if (ppguid)
    {
        *ppguid = NULL;
    }

    HRESULT hr = S_OK;
    DWORD cguid = Ifaces.size();

    if ((cguid > 0) && ppguid)
    {
        GUID* pguid = (GUID*)CoTaskMemAlloc(cguid * sizeof(GUID));
        if (pguid)
        {
            *ppguid = pguid;
            *pcguid = cguid;

            IFACECOL::const_iterator iter;
            for (iter  = Ifaces.begin();
                 iter != Ifaces.end();
                 iter++)
            {
                *(pguid++) = *iter;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // Caller just wants the count.
        //
        *pcguid = 0;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "GetGuidArrayFromIfaceColWithCoTaskMemAlloc");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     GetInterfaceName
//
//  Purpose:   Get the interface name as <Adapter name>_<interface ID>
//             to support multiple interface for WAN adapters.
//
//  Arguments:
//      pszAdapterName  [in]   The adapter name
//      guidIfaceId     [in]   The interface ID
//      pstrIfaceName   [out]  The interface name
//
//  Returns:    None
//
//  Author:     nsun  12 Sept 1998
//
//  Note:       This function is also used to construct NetBt binding
//              interface names from NetBt binding path
//
VOID GetInterfaceName(
    PCWSTR      pszAdapterName,
    const GUID& guidIfaceId,
    tstring*    pstrIfaceName)
{
    Assert(pszAdapterName);
    Assert(pstrIfaceName);

    WCHAR pszGuid [c_cchGuidWithTerm];

    StringFromGUID2 (guidIfaceId, pszGuid, c_cchGuidWithTerm);

//    pstrIfaceName->assign(pszAdapterName);
//    pstrIfaceName->append(pszGuid);
    pstrIfaceName->assign(pszGuid);
}


//+---------------------------------------------------------------------------
//
//  Name:     RetrieveStringFromOptionList
//
//  Purpose:   Retrieve a substring from the option list of REMOTE_IPINFO
//
//
//  Arguments:
//      pszOption       [in]   The string of option list
//      szIdentifier    [in]   The identifier of the substring to retrieve
//      str             [out]  The substring
//
//  Returns:    S_OK
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//              E_INVALIDARG
//
//  Author:     nsun  01/11/99
//
//
HRESULT RetrieveStringFromOptionList(PCWSTR pszOption,
                                     PCWSTR szIdentifier,
                                     tstring & str)
{
    Assert(szIdentifier);

    HRESULT hr = S_OK;
    WCHAR*  pszBegin;
    WCHAR*  pszEnd;
    PWSTR  pszString = NULL;

    str = c_szEmpty;

    if (!pszOption)
    {
        goto LERROR;
    }

    pszBegin = wcsstr(pszOption, szIdentifier);
    if (!pszBegin)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto LERROR;
    }

    pszString = (PWSTR) MemAlloc((wcslen(pszOption)+1) * sizeof(WCHAR));
    if (NULL == pszString)
    {
        hr = E_OUTOFMEMORY;
        goto LERROR;
    }

    pszBegin += wcslen(szIdentifier);

    wcscpy(pszString, pszBegin);

    pszEnd = wcschr(pszString, c_chOptionSeparator);
    if(!pszEnd)
        hr = E_INVALIDARG;
    else
    {
        //set the end of the string
        *pszEnd = 0;
        str = pszString;
    }

LERROR:

    //it's ok to MemFree(NULL)
    MemFree(pszString);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Name:     ConstructOptionListString
//
//  Purpose:  Construct the option list of REMOTE_IPINFO
//
//
//  Arguments:
//      pAdapter        [in]   Pointer to info of the adapter
//      strOptionList   [out]  The OptionList string
//
//  Returns:    None
//
//  Author:     nsun  01/12/99
//
//  Note:   Syntax of the Option list:
//          "<Identifier><data>;<Identifier><data>;...;"
//          The order of identifiers does not matter.
//
//          Example:
//          "DefGw=111.111.111.111,222.222.222.222;GwMetric=1,2;IfMetric=1;DNS=1.1.1.1;WINS=2.2.2.2"
//
VOID ConstructOptionListString(ADAPTER_INFO*   pAdapter,
                               tstring &       strOptionList)
{
    Assert(pAdapter);

    strOptionList = c_szEmpty;

    //add gateway list
    tstring str = c_szEmpty;
    tstring strGatewayList = c_szDefGw;
    ConvertColStringToString(pAdapter->m_vstrDefaultGateway,
                             c_chListSeparator,
                             str);
    strGatewayList += str;
    strOptionList += strGatewayList;
    strOptionList += c_chOptionSeparator;

    //add gateway metric list
    tstring strMetricList = c_szGwMetric;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrDefaultGatewayMetric,
                             c_chListSeparator,
                             str);
    strMetricList += str;
    strOptionList += strMetricList;
    strOptionList += c_chOptionSeparator;

    //add interface metric info to option list
    strOptionList += c_szIfMetric;
    WCHAR szBuf[MAX_METRIC_DIGITS + 1];
    _ltot(pAdapter->m_dwInterfaceMetric, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;

    //add DNS server list
    strOptionList += c_szDNS;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrDnsServerList,
                             c_chListSeparator,
                             str);
    strOptionList += str;
    strOptionList += c_chOptionSeparator;

    //add WINS server list
    strOptionList += c_szWINS;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrWinsServerList,
                             c_chListSeparator,
                             str);
    strOptionList += str;
    strOptionList += c_chOptionSeparator;

    //add DNS update parameters
    strOptionList += c_szDynamicUpdate;
    ZeroMemory(szBuf, sizeof(szBuf));
    _ltot(pAdapter->m_fDisableDynamicUpdate ? 0 : 1, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;

    strOptionList += c_szNameRegistration;
    ZeroMemory(szBuf, sizeof(szBuf));
    _ltot(pAdapter->m_fEnableNameRegistration ? 1 : 0, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrParseOptionList
//
//  Purpose:  Parse the option list string of REMOTE_IPINFO and load the 
//            settings to the adapter info struct
//
//  Arguments:
//      pszOption       [in]       The OptionList string
//      pAdapter        [in/out]   Pointer to info of the adapter
//
//  Returns:    S_OK if succeed
//              Otherwise, the hresult error
//
//  Author:     nsun  07/11/99
//
//
HRESULT HrParseOptionList(PCWSTR pszOption, 
                          ADAPTER_INFO*   pAdapter)
{
    HRESULT hr = S_OK;
    Assert(pAdapter);

    if (NULL == pszOption)
        return hr;

    HRESULT hrTmp = S_OK;

    tstring str;
    DWORD dwTemp = 0;

    //Get default gateways
    hr = RetrieveStringFromOptionList(pszOption,
                                      c_szDefGw,
                                      str);
    if(SUCCEEDED(hr))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrDefaultGateway);


        //Get gateway metrics
        hr = RetrieveStringFromOptionList(pszOption,
                                          c_szGwMetric,
                                          str);
        if(SUCCEEDED(hr))
        {
            ConvertStringToColString(str.c_str(),
                                     c_chListSeparator,
                                     pAdapter->m_vstrDefaultGatewayMetric);
        }
    }
    
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        //the option list doesn't have to have any of the tags
        hr = S_OK;
    }

    //Get interface metric
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szIfMetric,
                                         str);
    if(SUCCEEDED(hrTmp) && !str.empty())
    {
        DWORD dwIfMetric = _wtol(str.c_str());
        pAdapter->m_dwInterfaceMetric = dwIfMetric;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get DNS servers
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szDNS,
                                         str);
    if (SUCCEEDED(hrTmp))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrDnsServerList);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get WINS servers
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szWINS,
                                         str);
    if (SUCCEEDED(hrTmp))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrWinsServerList);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get DNS dynamic update parameters
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                        c_szDynamicUpdate,
                                        str);
    if (SUCCEEDED(hrTmp))
    {
        dwTemp = _wtol(str.c_str());
        pAdapter->m_fDisableDynamicUpdate = !dwTemp;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                        c_szNameRegistration,
                                        str);
    if (SUCCEEDED(hrTmp))
    {
        dwTemp = _wtol(str.c_str());
        pAdapter->m_fEnableNameRegistration = !!dwTemp;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrGetPrimaryDnsDomain
//
//  Purpose:  Get the Primary Dns Domain name
//
//
//  Arguments:
//      pstr   [out]  The string contains the Primary Dns Domain name
//
//  Returns:    HRESULT
//
//  Author:     nsun  03/03/99
HRESULT HrGetPrimaryDnsDomain(tstring *pstr)
{
    HRESULT hr = S_OK;

    Assert(pstr);

    DWORD dwErr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomainInfo = NULL;


    dwErr = DsRoleGetPrimaryDomainInformation( NULL,
                                        DsRolePrimaryDomainInfoBasic,
                                        (PBYTE *) &pPrimaryDomainInfo);
    if (ERROR_SUCCESS == dwErr && NULL != pPrimaryDomainInfo )
    {
        if (pPrimaryDomainInfo->DomainNameDns)
            *pstr = pPrimaryDomainInfo->DomainNameDns;
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        DsRoleFreeMemory(pPrimaryDomainInfo);
    }
    else
        hr = HRESULT_FROM_WIN32(dwErr);

    TraceError("CTcpipcfg::HrGetPrimaryDnsDomain:", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Name:     WriteSetupErrorLog
//
//  Purpose:  Write an error to setuperr.log
//
//
//  Arguments:
//      nIdErrorFormat   [in]       The ID of the error format string
//
//  Returns:    None, but Error trace will be generated if fails to write setup
//              error log
//
//  Author:     nsun  03/21/99
VOID WriteTcpSetupErrorLog(UINT nIdErrorFormat, ...)
{
    PCWSTR pszFormat = SzLoadIds(nIdErrorFormat);

    PWSTR pszText = NULL;
    DWORD dwRet;

    va_list val;
    va_start(val, nIdErrorFormat);
    dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    if (dwRet && pszText)
    {
        tstring strMsg = L"";

        //Add the current time at the begining of the error log
        time_t tclock;
        time(&tclock);

        struct tm * ptmLocalTime;
        ptmLocalTime = localtime(&tclock);

        if (ptmLocalTime)
        {
            LPWSTR pwsz = _wasctime(ptmLocalTime);
            if (pwsz)
            {
                strMsg = pwsz;
            }
        }

        strMsg += pszText;

        if (!SetupLogError(strMsg.c_str(), LogSevError))
        {
            TraceError("Tcpip: WriteSetupErrorLog", HRESULT_FROM_WIN32(GetLastError()));
        }
        LocalFree(pszText);
    }
    else
    {
        TraceError("Tcpip: WriteSetupErrorLog: unable to FormatMessage()", HRESULT_FROM_WIN32(GetLastError()));
    }
}

DWORD IPStringToDword(LPCTSTR szIP)
{
    if (NULL == szIP || 0 == lstrlenW(szIP))
    {
        return 0;
    }
    
    DWORD arrdwIp[4];
    GetNodeNum(szIP, arrdwIp);

    return (arrdwIp[0] << 24) + (arrdwIp[1] << 16)
             + (arrdwIp[2] << 8) + arrdwIp[3];
}

void DwordToIPString(DWORD dwIP, tstring & strIP)
{
    if (0 == dwIP)
    {
        strIP = c_szEmpty;
        return;
    }

    WCHAR szTemp[4];
    
    wsprintf(szTemp, L"%d", dwIP >> 24);
    strIP = szTemp;
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x00FF0000) >> 16);
    strIP += szTemp;    
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x0000FF00) >> 8);
    strIP += szTemp;    
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x000000FF));
    strIP += szTemp;

    return;
}

//Seach a List view for an item contains the specified string
//Arguments:
//          hListView   [IN]    Handle to the list view
//          iSubItem    [IN]    Subitem to search
//          psz         [IN]    The string to search
//Return
//          -1 if no items are found
//          otherwise the index of the first item matching the string
//
int SearchListViewItem(HWND hListView, int iSubItem, LPCWSTR psz)
{
    int iRet = -1;
    int nlvCount = ListView_GetItemCount(hListView);

    WCHAR szBuf[256];

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = szBuf;
    lvItem.cchTextMax = celems(szBuf);

    for (int i = 0; i < nlvCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = iSubItem;
        ListView_GetItem(hListView, &lvItem);

        if (lstrcmpiW(psz, szBuf) == 0)
        {
            iRet = i;
            break;
        }
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcprsvp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P R S V P . C P P
//
//  Contents:   RSVP portion of TCP/IP
//
//  Notes:
//
//  Author:     kumarp    19-March-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include <ws2spi.h>
#include "ncsvc.h"

const GUID c_guidRsvpNtName = { /* 9d60a9e0-337a-11d0-bd88-0000c082e69a */
     0x9d60a9e0,
     0x337a,
     0x11d0,
     {0xbd, 0x88, 0x00, 0x00, 0xc0, 0x82, 0xe6, 0x9a}
   };


static const WCHAR*     c_szChainNameUdp    = L"RSVP UDP Service Provider";
static const WCHAR*     c_szChainNameTcp    = L"RSVP TCP Service Provider";

static const WCHAR*     c_szRsvpFullPath    = L"%SystemRoot%\\system32\\rsvpsp.dll";

// ----------------------------------------------------------------------
//
// Function:  HrInstallRsvpProvider
//
// Purpose:   This registers with winsock the RSVP TCP and UDP provider.
//            This allows QoS for TCP and UDP
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-March-98
//
// Notes:     This function was written mainly by cwill.
//
HRESULT HrInstallRsvpProvider(VOID)
{
    HRESULT             hr              = S_OK;
    INT                 err             = 0;
    INT                 result          = 0;
    WSAPROTOCOL_INFO    awpiRsvp[2];

    // Note: CWill : 08/08/97 : This is a hack to get TCP/IP
    //       registered before RSVP.  We have to get some way
    //       of ordering RSVP after TCP/IP
    (VOID) HrRunWinsock2Migration();

    //
    // Setup the UDP provider
    //

    awpiRsvp[0].dwServiceFlags1     =
        XP1_QOS_SUPPORTED
        | XP1_CONNECTIONLESS
        | XP1_MESSAGE_ORIENTED
        | XP1_SUPPORT_BROADCAST
        | XP1_SUPPORT_MULTIPOINT
        | XP1_IFS_HANDLES;

    awpiRsvp[0].dwServiceFlags2     = 0;
    awpiRsvp[0].dwServiceFlags3     = 0;
    awpiRsvp[0].dwServiceFlags4     = 0;
    awpiRsvp[0].dwProviderFlags     = PFL_MATCHES_PROTOCOL_ZERO;

    // Copy the GUID
    memcpy(&(awpiRsvp[0].ProviderId), &c_guidRsvpNtName,
            sizeof(awpiRsvp[0].ProviderId));

    awpiRsvp[0].dwCatalogEntryId    = 0;
    awpiRsvp[0].ProtocolChain.ChainLen = 1;
    // Change history
    // 2 in Win98 and in NT 5 during development
    // 4 in Windows 2000, to be different from Win98 as the API changed slightly (RAID #299558)
    // 6 In Whistler as RSVPSP calls default provider rather than MSAFD, to handle Proxy client
    awpiRsvp[0].iVersion            = 6;
    awpiRsvp[0].iAddressFamily      = AF_INET;
    awpiRsvp[0].iMaxSockAddr        = 16;
    awpiRsvp[0].iMinSockAddr        = 16;
    awpiRsvp[0].iSocketType         = SOCK_DGRAM;
    awpiRsvp[0].iProtocol           = IPPROTO_UDP;
    awpiRsvp[0].iProtocolMaxOffset  = 0;
    awpiRsvp[0].iNetworkByteOrder   = BIGENDIAN;
    awpiRsvp[0].iSecurityScheme     = SECURITY_PROTOCOL_NONE;

    //$ REVIEW : CWill : 08/07/97 : This is what UDP returns...
    awpiRsvp[0].dwMessageSize       = 0x0000ffbb;
    awpiRsvp[0].dwProviderReserved  = 0;

    // Copy over the name
    lstrcpynW(awpiRsvp[0].szProtocol, c_szChainNameUdp,
            (WSAPROTOCOL_LEN + 1));


    //
    // Setup the TCP provider
    //

    awpiRsvp[1].dwServiceFlags1 =
            XP1_GUARANTEED_DELIVERY
            | XP1_GUARANTEED_ORDER
            | XP1_GRACEFUL_CLOSE
            | XP1_EXPEDITED_DATA
            | XP1_QOS_SUPPORTED
            | XP1_IFS_HANDLES;

    awpiRsvp[1].dwServiceFlags2     = 0;
    awpiRsvp[1].dwServiceFlags3     = 0;
    awpiRsvp[1].dwServiceFlags4     = 0;
    awpiRsvp[1].dwProviderFlags     = PFL_MATCHES_PROTOCOL_ZERO;

    // Copy the GUID
    memcpy(&(awpiRsvp[1].ProviderId), &c_guidRsvpNtName,
            sizeof(awpiRsvp[1].ProviderId));

    awpiRsvp[1].dwCatalogEntryId    = 0;
    awpiRsvp[1].ProtocolChain.ChainLen = 1;
    // Change history
    // 2 in Win98 and in NT 5 during development
    // 4 in Windows 2000, to be different from Win98 as the API changed slightly (RAID #299558)
    // 6 In Whistler, as RSVPSP calls default provider rather than MSAFD, to handle Proxy client
    awpiRsvp[1].iVersion            = 6;
    awpiRsvp[1].iAddressFamily      = AF_INET;
    awpiRsvp[1].iMaxSockAddr        = 16;
    awpiRsvp[1].iMinSockAddr        = 16;
    awpiRsvp[1].iSocketType         = SOCK_STREAM;
    awpiRsvp[1].iProtocol           = IPPROTO_TCP;
    awpiRsvp[1].iProtocolMaxOffset  = 0;
    awpiRsvp[1].iNetworkByteOrder   = BIGENDIAN;
    awpiRsvp[1].iSecurityScheme     = SECURITY_PROTOCOL_NONE;
    awpiRsvp[1].dwMessageSize       = 0;
    awpiRsvp[1].dwProviderReserved  = 0;

    // Copy over the name
    lstrcpynW(awpiRsvp[1].szProtocol, c_szChainNameTcp,
            (WSAPROTOCOL_LEN + 1));


    // Install the provider
#ifdef _WIN64
    // On 64 bit machines modify both 64 and 32 bit catalogs.
    result = ::WSCInstallProvider64_32(
#else
    result = ::WSCInstallProvider(
#endif
            (GUID*) &c_guidRsvpNtName,
            c_szRsvpFullPath,
            awpiRsvp,
            celems(awpiRsvp),
            &err);

    if (SOCKET_ERROR == result)
    {
        hr = HRESULT_FROM_WIN32(err);
    }

    TraceError("HrInstallRsvpProvider", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     RemoveRsvpProvider
//
//  Purpose:    Remove RSVP from the list of registered WinSock providers
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID RemoveRsvpProvider(VOID)
{
    HRESULT             hr              = S_OK;
    INT                 err             = NO_ERROR;
    ULONG               result          = NO_ERROR;
    DWORD               dwBuffSize      = 0;
    WSAPROTOCOL_INFO*   pwpiProtoInfo   = NULL;
    WSAPROTOCOL_INFO*   pwpiInfo        = NULL;

    // Find all the protocols that are installed
    //
    result = ::WSCEnumProtocols(
            NULL,
            NULL,
            &dwBuffSize,
            &err);
    if ((SOCKET_ERROR == result) && (WSAENOBUFS != err))
    {
        // We have a real error
        //
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    else
    {
        pwpiProtoInfo = reinterpret_cast<WSAPROTOCOL_INFO*>(new BYTE[dwBuffSize]);
        if (pwpiProtoInfo)
        {
            // Find out all the protocols on the system
            //
            result = ::WSCEnumProtocols(
                    NULL,
                    pwpiProtoInfo,
                    &dwBuffSize,
                    &err);

            pwpiInfo = pwpiProtoInfo;
            if (SOCKET_ERROR != result)
            {
                DWORD   cProt;

                cProt = result;
                hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_FOUND);

                // Look for the RSVP protocol
                //
                while (cProt--)
                {
                    if (pwpiInfo->ProviderId == c_guidRsvpNtName)
                    {
                        AssertSz((XP1_QOS_SUPPORTED
                            & pwpiInfo->dwServiceFlags1),
                                "Why is QoS not supported?");
                        AssertSz(((IPPROTO_UDP == pwpiInfo->iProtocol)
                            || (IPPROTO_TCP == pwpiInfo->iProtocol)),
                                "Unknown RSVP protocol");

                        // Remove the RSVP provider
                        //
                        result = ::WSCDeinstallProvider(
                                &(pwpiInfo->ProviderId), &err);
                        if (SOCKET_ERROR == result)
                        {
                            hr = HRESULT_FROM_WIN32(err);
                            TraceTag(ttidError,
                                    "Failed to De-Install Protocol, error = %d, Proto = %X\n",
                                    err,
                                    pwpiInfo->iProtocol);
                        }

#ifdef _WIN64
                        //
                        // Deinstall 32 bit provider as well.
                        // We always install both versions, so should uninstall both
                        // as well (both providers have the same ID, so we do not
                        // need to enumerate 32 bit catalog).
                        result = ::WSCDeinstallProvider32(
                                &(pwpiInfo->ProviderId), &err);
                        if (SOCKET_ERROR == result)
                        {
                            hr = HRESULT_FROM_WIN32(err);
                            TraceTag(ttidError,
                                    "Failed to De-Install Protocol (32 bit), error = %d, Proto = %X\n",
                                    err,
                                    pwpiInfo->iProtocol);
                        }
#endif
                        // We have found it
                        //
                        hr = S_OK;
                        break;
                    }

                    pwpiInfo++;
                }
            }
            else
            {
                TraceTag(
                        ttidError,
                        "Failed to Enumerate protocols, error = %d\n",
                        err);
                hr = HRESULT_FROM_WIN32(err);
            }

            // Free the allocation
            //
            delete pwpiProtoInfo;
        }
    }

    TraceErrorOptional("RemoveRsvpProvider", hr,
            (ERROR_SERVICE_NOT_FOUND == hr));
    return;
}

/*
// ----------------------------------------------------------------------
//
// Function:  HrFindRsvpProvider
//
// Purpose:
//      This routine installs the service provider.
//
// Arguments:
//    iProtocolId      [in]  protocol to find
//    pwpiOutProtoInfo [in]  pointer to returned proto info
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-March-98
//
// Notes:     This function was written mainly by cwill.
//
HRESULT HrFindRsvpProvider(INT iProtocolId, WSAPROTOCOL_INFO* pwpiOutProtoInfo)
{
    HRESULT             hr              = S_OK;
    INT                 err             = NO_ERROR;
    ULONG               result          = NO_ERROR;
    DWORD               dwBuffSize      = 0;
    WSAPROTOCOL_INFO*   pwpiProtoInfo   = NULL;
    WSAPROTOCOL_INFO*   pwpiInfo        = NULL;

    result = WSCEnumProtocols(
            NULL,
            NULL,
            &dwBuffSize,
            &err);

    if ((SOCKET_ERROR == result) && (WSAENOBUFS != err))
    {
        // We have a real error
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    else
    {
        pwpiProtoInfo = reinterpret_cast<WSAPROTOCOL_INFO*>(new BYTE[dwBuffSize]);
        if (pwpiProtoInfo)
        {
            // Find out all the protocols on the system
            result = WSCEnumProtocols(
                    NULL,
                    pwpiProtoInfo,
                    &dwBuffSize,
                    &err);

            pwpiInfo = pwpiProtoInfo;
            if (SOCKET_ERROR != result)
            {
                DWORD   cProt;

                cProt = result;
                hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_FOUND);

                // Look for a protocol that supports QoS
                while (cProt--)
                {
                    if ((pwpiInfo->iProtocol == iProtocolId)
                        && (XP1_QOS_SUPPORTED & pwpiInfo->dwServiceFlags1))
                    {

                        *pwpiOutProtoInfo = *pwpiInfo;
                        hr = S_OK;
                        break;
                    }
                    pwpiInfo++;
                }
            }
            else
            {
                TraceTag(
                        ttidError,
                        "Failed to Enumerate protocols, error = %d\n",
                        err);
                hr = HRESULT_FROM_WIN32(err);
            }

            delete pwpiProtoInfo;
        }
    }

    TraceErrorOptional("HrFindRsvpProvider", hr,
            (ERROR_SERVICE_NOT_FOUND == hr));
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  RemoveRsvpProvider
//
// Purpose:   Remove RSVP provider
//
// Arguments:
//    iProtocolId [in]  protocol id to remove
//
// Returns:
//
// Author:    kumarp 19-March-98
//
// Notes:     This function was written mainly by cwill.
//
VOID RemoveRsvpProvider(INT iProtocolId)
{
    HRESULT             hr              = S_OK;
    WSAPROTOCOL_INFO    wpiProtoInfo;

    // Find the provider and remove it
    hr = HrFindRsvpProvider(iProtocolId, &wpiProtoInfo);

    if (SUCCEEDED(hr))
    {
        INT                 err         = NO_ERROR;
#ifdef DBG
        INT                 result      =
#endif // DBG

        WSCDeinstallProvider(&wpiProtoInfo.ProviderId, &err);

#ifdef DBG
        if (SOCKET_ERROR == result)
        {
            hr = HRESULT_FROM_WIN32(err);
            TraceTag(ttidError,
                    "Failed to De-Install Protocol, error = %d, Proto = %X\n",
                    err,
                    iProtocolId);
        }
#endif // DBG
    }

    TraceErrorOptional("HrFindRsvpProvider", hr,
            (ERROR_SERVICE_NOT_FOUND == hr));
    return;
}

// ----------------------------------------------------------------------
//
// Function:  RemoveRsvpProviders
//
// Purpose:   Remove RSVP providers
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 19-March-98
//
// Notes:
//
void RemoveRsvpProviders(VOID)
{
    // Remove the providers if they are present
    RemoveRsvpProvider(IPPROTO_UDP);
    RemoveRsvpProvider(IPPROTO_TCP);
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\tcputil.h ===
//
// T C P U T I L . H
//
// Header of utility functions
//

#pragma once
#include "netcfgx.h"
#include "tcpip.h"
#include "ipctrl.h"

inline BOOL FHrFailed(HRESULT hr)
{
    return FAILED(hr);
}

#define CORg(hResult) \
    do\
        {\
        hr = (hResult);\
        if (FHrFailed(hr))\
          {\
            goto Error;\
          }\
        }\
    while (FALSE)

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkeyParam,
                                  OUT VSTR * const pvstrAdapters);

HRESULT HrIsComponentInstalled(INetCfg * pnc,
                               const GUID& rguidClass,
                               PCWSTR szInfId,
                               OUT BOOL * const pfInstalled);

// Get the four numbers from an Ip Address
VOID GetNodeNum(PCWSTR szIpAddress, DWORD ardw[4]);

BOOL IsContiguousSubnet(PCWSTR pszSubnet);

VOID ReplaceFirstAddress(VSTR * pvstr, PCWSTR szIpAddress);
VOID ReplaceSecondAddress(VSTR * pvstr, PCWSTR szIpAddress);

BOOL GenerateSubnetMask(IpControl & ipAddress,
                        tstring * pstrSubnetMask);

BOOL    FRegQueryBool(const HKEY hkey, PCWSTR szName, BOOL fDefaultValue);

VOID ResetLmhostsFile();

int IPAlertPrintf(HWND hwndParent, UINT ids,
                  int iCurrent, int iLow, int iHigh);

VOID IpCheckRange(LPNMIPADDRESS lpnmipa, HWND hWnd,
                  int iLow, int iHigh, BOOL fCheckLoopback = FALSE);

VOID SetButtons(HANDLES& h, const int nNumLimit = -1);

BOOL ListBoxRemoveAt(HWND hListBox, int idx, tstring * pstrRemovedItem);
BOOL ListBoxInsertAfter(HWND hListBox, int idx, PCWSTR szItem);

HRESULT HrRegRenameTree(HKEY hkeyRoot, PCWSTR szOldName, PCWSTR szNewName);
HRESULT HrRegCopyKeyTree(HKEY hkeyDest, HKEY hkeySrc );

BOOL fQueryFirstAddress(const VSTR & vstr, tstring * const pstr);
BOOL fQuerySecondAddress(const VSTR & vstr, tstring * const pstr);

BOOL FIsIpInRange(PCWSTR szIp);

VOID ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs);

VOID AddInterfacesToAdapterInfo(
    ADAPTER_INFO*   pAdapter,
    DWORD           dwNumInterfaces);

HRESULT GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
    const IFACECOL& IfaceIds,
    GUID** ppdw,
    DWORD* pdwSize);

VOID GetInterfaceName(
    PCWSTR     pszAdapterName,
    const GUID& guidIfaceId,
    tstring*    pstrIfaceName);

HRESULT RetrieveStringFromOptionList(PCWSTR pszOption,
                                    PCWSTR szIdentifier,
                                    tstring & str);

VOID ConstructOptionListString(ADAPTER_INFO*   pAdapter,
                               tstring &       strOptionList);

HRESULT HrParseOptionList(PCWSTR pszOption, 
                          ADAPTER_INFO*   pAdapter);

HRESULT HrGetPrimaryDnsDomain(tstring *pstr);

VOID WriteTcpSetupErrorLog(UINT nIdErrorFormat, ...);

DWORD IPStringToDword(LPCTSTR strIP);

void DwordToIPString(DWORD dwIP, tstring & strIP);

int SearchListViewItem(HWND hListView, int iSubItem, LPCWSTR psz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\debug.h ===
#ifndef DEBUG_H
#define DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>


//
// Macros for debugging support.
//
// ASSERT(exp)   Popup a dialogbox, if exp is FALSE
// ASSERTMSG(exp, msg)  Similar to ASSERT.  Except the msg is displayed instead of the expression
//
// Use TRACE(x) for output, where x is a list of printf()-style parameters.  
//     TRACEn() is TRACE with n printf arguments
//     For example, TRACE2("This shows how to print stuff, like a string %s, and a number %u.","string",5);
//
// USE VERIFY for expressions executed for both debug and release version
//

#undef ASSERT
#undef ASSERTMSG

/*
//
// Used by atl
//
#ifdef _ATL_NO_DEBUG_CRT
#define _ASSERTE ASSERT
#define _ASSERT ASSERT
#endif
*/


#ifdef DBG
#define DEBUG
#endif

#if	( defined(DEBUG) || defined(_DEBUG))

#ifdef UNICODE
#define AssertMessage AssertMessageW
#else
#define AssertMessage AssertMessageA
#endif

void AssertMessage(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg);

#define ASSERT(x)		(void)((x) || (AssertMessage(TEXT(__FILE__),__LINE__,TEXT(#x)),0))
#define ASSERTMSG(exp, msg)   (void)((exp) || (AssertMessage(TEXT(__FILE__),__LINE__,msg),0))

#define VERIFY(x)		    ASSERT(x)

// {ASSERT(pObj);pObj->AssertValid();} 
#define ASSERT_VALID(pObj) ((ASSERT(pObj),1) && ((pObj)->AssertValid(),1))

#else // DEBUG

#define ASSERT_VALID(pObj) 
#define ASSERT(x)           ((void)0)
#define ASSERTMSG(exp, msg) ((void)0)
#define VERIFY(x)           (x)       
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\help.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - help section mappings to the controls

Author:

    kyrilf

--*/

#pragma once
#include "resource.h"

#define IDH_GROUP_CL_IP           IDC_GROUP_CL_IP
#define IDH_EDIT_CL_IP            IDC_EDIT_CL_IP
#define IDH_EDIT_CL_MASK          IDC_EDIT_CL_MASK
#define IDH_EDIT_DOMAIN           IDC_EDIT_DOMAIN
#define IDH_EDIT_ETH              IDC_EDIT_ETH
#define IDH_GROUP_CL_MODE         IDC_GROUP_CL_MODE
#define IDH_RADIO_UNICAST         IDC_RADIO_UNICAST
#define IDH_RADIO_MULTICAST       IDC_RADIO_MULTICAST
#define IDH_CHECK_IGMP            IDC_CHECK_IGMP
#define IDH_CHECK_RCT             IDC_CHECK_RCT
#define IDH_EDIT_PASSW            IDC_EDIT_PASSW
#define IDH_EDIT_PASSW2           IDC_EDIT_PASSW2

const DWORD g_aHelpIDs_IDD_DIALOG_CLUSTER [] = {
    IDC_GROUP_CL_IP,              IDH_GROUP_CL_IP,
    IDC_TEXT_CL_IP,               IDH_EDIT_CL_IP,
    IDC_EDIT_CL_IP,               IDH_EDIT_CL_IP,
    IDC_TEXT_CL_MASK,             IDH_EDIT_CL_MASK,
    IDC_EDIT_CL_MASK,             IDH_EDIT_CL_MASK,
    IDC_TEXT_DOMAIN,              IDH_EDIT_DOMAIN,
    IDC_EDIT_DOMAIN,              IDH_EDIT_DOMAIN,
    IDC_TEXT_ETH,                 IDH_EDIT_ETH,
    IDC_EDIT_ETH,                 IDH_EDIT_ETH,
    IDC_GROUP_CL_MODE,            IDH_GROUP_CL_MODE,
    IDC_RADIO_UNICAST,            IDH_RADIO_UNICAST,
    IDC_RADIO_MULTICAST,          IDH_RADIO_MULTICAST,
    IDC_CHECK_IGMP,               IDH_CHECK_IGMP,
    IDC_GROUP_RCT,                IDH_CHECK_RCT,
    IDC_CHECK_RCT,                IDH_CHECK_RCT,
    IDC_TEXT_PASSW,               IDH_EDIT_PASSW,
    IDC_EDIT_PASSW,               IDH_EDIT_PASSW,
    IDC_TEXT_PASSW2,              IDH_EDIT_PASSW2,
    IDC_EDIT_PASSW2,              IDH_EDIT_PASSW2,
    0, 0
};

#define IDH_EDIT_PRI              IDC_EDIT_PRI
#define IDH_GROUP_DED_IP          IDC_GROUP_DED_IP
#define IDH_EDIT_DED_IP           IDC_EDIT_DED_IP
#define IDH_EDIT_DED_MASK         IDC_EDIT_DED_MASK
#define IDH_CHECK_ACTIVE          IDC_CHECK_ACTIVE

const DWORD g_aHelpIDs_IDD_DIALOG_HOST [] = {
    IDC_TEXT_PRI,                 IDH_EDIT_PRI,
    IDC_EDIT_PRI,                 IDH_EDIT_PRI,
    IDC_SPIN_PRI,                 IDH_EDIT_PRI,
    IDC_GROUP_DED_IP,             IDH_GROUP_DED_IP,
    IDC_TEXT_DED_IP,              IDH_EDIT_DED_IP,
    IDC_EDIT_DED_IP,              IDH_EDIT_DED_IP,
    IDC_TEXT_DED_MASK,            IDH_EDIT_DED_MASK,
    IDC_EDIT_DED_MASK,            IDH_EDIT_DED_MASK,
    IDC_CHECK_ACTIVE,             IDH_CHECK_ACTIVE,
    0, 0
};

#define IDH_LIST_PORT_RULE        IDC_LIST_PORT_RULE
#define IDH_BUTTON_ADD            IDC_BUTTON_ADD
#define IDH_BUTTON_MODIFY         IDC_BUTTON_MODIFY
#define IDH_BUTTON_DEL            IDC_BUTTON_DEL
#define IDH_GROUP_PORT_RULE_DESCR IDC_GROUP_PORT_RULE_DESCR

#define IDH_GROUP_RANGE           IDC_GROUP_RANGE
#define IDH_EDIT_START            IDC_EDIT_START
#define IDH_EDIT_END              IDC_EDIT_END
#define IDH_GROUP_PROTOCOLS       IDC_GROUP_PROTOCOLS
#define IDH_RADIO_TCP             IDC_RADIO_TCP
#define IDH_RADIO_UDP             IDC_RADIO_UDP
#define IDH_RADIO_BOTH            IDC_RADIO_BOTH
#define IDH_GROUP_FILTERING       IDC_GROUP_MULTIPLE
#define IDH_RADIO_MULTIPLE        IDC_RADIO_MULTIPLE
#define IDH_AFFINITY              IDC_TEXT_AFF
#define IDH_RADIO_AFF_NONE        IDC_RADIO_AFF_NONE
#define IDH_RADIO_AFF_SINGLE      IDC_RADIO_AFF_SINGLE
#define IDH_RADIO_AFF_CLASSC      IDC_RADIO_AFF_CLASSC
#define IDH_LOAD_WEIGHT           IDC_TEXT_MULTI
#define IDH_EDIT_MULTI            IDC_EDIT_MULTI
#define IDH_CHECK_EQUAL           IDC_CHECK_EQUAL
#define IDH_RADIO_SINGLE          IDC_RADIO_SINGLE
#define IDH_EDIT_SINGLE           IDC_EDIT_SINGLE
#define IDH_RADIO_DISABLED        IDC_RADIO_DISABLED

const DWORD g_aHelpIDs_IDD_DIALOG_PORTS [] = {
    IDC_TEXT_PORT_RULE,           IDH_LIST_PORT_RULE,
    IDC_LIST_PORT_RULE,           IDH_LIST_PORT_RULE,
    IDC_BUTTON_ADD,               IDH_BUTTON_ADD,
    IDC_BUTTON_MODIFY,            IDH_BUTTON_MODIFY,
    IDC_BUTTON_DEL,               IDH_BUTTON_DEL,
    IDC_GROUP_PORT_RULE_DESCR,    IDH_GROUP_PORT_RULE_DESCR,
    IDC_TEXT_PORT_RULE_DESCR,     IDH_GROUP_PORT_RULE_DESCR,

    IDC_GROUP_RANGE,              IDH_GROUP_RANGE,
    IDC_TEXT_START,               IDH_EDIT_START,
    IDC_EDIT_START,               IDH_EDIT_START,
    IDC_SPIN_START,               IDH_EDIT_START,
    IDC_TEXT_END,                 IDH_EDIT_END,
    IDC_EDIT_END,                 IDH_EDIT_END,
    IDC_SPIN_END,                 IDH_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDH_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDH_RADIO_TCP,
    IDC_RADIO_UDP,                IDH_RADIO_UDP,
    IDC_RADIO_BOTH,               IDH_RADIO_BOTH,
    IDC_GROUP_MULTIPLE,           IDH_GROUP_FILTERING,
    IDC_RADIO_MULTIPLE,           IDH_RADIO_MULTIPLE,
    IDC_TEXT_AFF,                 IDH_AFFINITY,
    IDC_RADIO_AFF_NONE,           IDH_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDH_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDH_RADIO_AFF_CLASSC,
    IDC_TEXT_MULTI,               IDH_LOAD_WEIGHT,
    IDC_EDIT_MULTI,               IDH_EDIT_MULTI,
    IDC_SPIN_MULTI,               IDH_EDIT_MULTI,
    IDC_CHECK_EQUAL,              IDH_CHECK_EQUAL,
    IDC_GROUP_SINGLE,             IDH_GROUP_FILTERING,
    IDC_RADIO_SINGLE,             IDH_RADIO_SINGLE,
    IDC_TEXT_SINGLE,              IDH_EDIT_SINGLE,
    IDC_EDIT_SINGLE,              IDH_EDIT_SINGLE,
    IDC_SPIN_SINGLE,              IDH_EDIT_SINGLE,
    IDC_GROUP_DISABLED,           IDH_GROUP_FILTERING,
    IDC_RADIO_DISABLED,           IDH_RADIO_DISABLED,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\clusterdlg.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    ClusterDlg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - cluster config tab

Author:

    kyrilf
    shouse

--*/

#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

class CDialogCluster : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogCluster)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDC_EDIT_CL_IP, OnEditClIp)
    COMMAND_ID_HANDLER (IDC_EDIT_CL_MASK, OnEditClMask)
    COMMAND_ID_HANDLER (IDC_CHECK_RCT, OnCheckRct)
    COMMAND_ID_HANDLER (IDC_BUTTON_HELP, OnButtonHelp)
    COMMAND_ID_HANDLER (IDC_RADIO_UNICAST, OnCheckMode)
    COMMAND_ID_HANDLER (IDC_RADIO_MULTICAST, OnCheckMode)
    COMMAND_ID_HANDLER (IDC_CHECK_IGMP, OnCheckIGMP)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogCluster (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogCluster ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogHost;
    friend class CDialogPorts;

private:
    void SetClusterMACAddress ();
    BOOL CheckClusterMACAddress ();

    void PrintIPRangeError (unsigned int ids, int value, int low, int high);

    void SetInfo ();
    void UpdateInfo ();

    LRESULT ValidateInfo ();          

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rct_warned;
    BOOL m_igmp_warned;
    BOOL m_igmp_mcast_warned;

    WCHAR m_passw[CVY_MAX_RCT_CODE + 1];
    WCHAR m_passw2[CVY_MAX_RCT_CODE + 1];

    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\clusterdlg.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    cluster.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - cluster config tab

Author:

    kyrilf
    shouse

--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include <locale.h>
#include <process.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbsconfig.h"
#include "ClusterDlg.h"
#include "utils.h"

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

#define DUMMY_PASSWORD L"somepassword"
#define EMPTY_PASSWORD L""

/*
 * Method: CDialogCluster
 * Description: The class constructor.
 */
CDialogCluster::CDialogCluster (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {

    TraceMsg(L"CDialogCluster::CDialogCluster\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rct_warned = FALSE;
    m_igmp_warned = FALSE;
    m_igmp_mcast_warned = FALSE;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));

    _wsetlocale (LC_ALL, L".OCP");
}

/*
 * Method: CDialogCluster
 * Description: The class destructor.
 */
CDialogCluster::~CDialogCluster () {

    TraceMsg(L"CDialogCluster::~CDialogCluster\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the cluster properties dialog.
 */
LRESULT CDialogCluster::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnInitDialog\n");

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* Limit the field ranges for the address and password fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, EM_SETLIMITTEXT, CVY_MAX_CL_IP_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, EM_SETLIMITTEXT, CVY_MAX_CL_NET_MASK, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, EM_SETLIMITTEXT, CVY_MAX_DOMAIN_NAME, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, EM_SETLIMITTEXT, CVY_MAX_NETWORK_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);

    /* Limit the zeroth field of the cluster IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* Disable the MAC address field.  It should be read-only. */
    if (m_paramp->fConvertMac) ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_ETH), FALSE);

    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */
    if (!wcscmp(m_paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) m_paramp->cl_ip_addr[0] = 0;
    if (!wcscmp(m_paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) m_paramp->cl_net_mask[0] = 0;

    /* Copy a dummy password into the parameter set. */
    wcsncpy(m_passw, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);
    wcsncpy(m_passw2, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogCluster::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogCluster::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the cluster settings tab becomes active (is clicked). 
 */
LRESULT CDialogCluster::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* Enable/disable the password entry boxes based on the state of the remote control checkbox. */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));

    /* Enable/disable the IGMP checkbox based on the state of the multicast checkbox. */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTICAST));

    /* Fill in the cluster MAC address, based on the values of multicast, IGMP, and the cluster IP. */
    SetClusterMACAddress();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the cluster settings tab.
 */
LRESULT CDialogCluster::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogCluster::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LRESULT fError = PSNRET_NOERROR;

    TraceMsg(L"CDialogCluster::OnApply\n");

    /* Validate the UI values entered by the user. */
    fError = ValidateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);

    return fError;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogCluster::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCancel\n");

    return 0;
}

/*
 * Method: OnButtonHelp
 * Description: Called when the user clicks the NLB "Help" button.
 */
LRESULT CDialogCluster::OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    WCHAR wbuf[CVY_STR_SIZE];

    TraceMsg(L"CDialogCluster::OnButtonHelp\n");

    switch (wNotifyCode) {
        case BN_CLICKED:
            /* Spawn the windows help process. */
            swprintf(wbuf, L"%%WINDIR%%\\help\\%ls::/installation.htm", CVY_HELP_FILE);
            _wspawnlp(P_NOWAIT, L"hh.exe", L"hh.exe", wbuf, NULL);
            break;
    }

    return 0;
}

/*
 * Method: OnEditClIp
 * Description: Called when the user edits the cluster IP address.
 */
LRESULT CDialogCluster::OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnEditClIp\n");

    switch (wNotifyCode) {
        case EN_CHANGE:
            /* Update the cluster MAC address. */
            SetClusterMACAddress();
            break;
    }

    return 0;
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in 
 *              an IP address octet.
 */
void CDialogCluster::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    WCHAR szCurrent[10];
    WCHAR szLow[10];
    WCHAR szHigh[10];

    TraceMsg(L"CDialogCluster::PrintIPRangeError\n");

    /* Fill in the allowed range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szCurrent, L"%d", value);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogCluster::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    TraceMsg(L"CDialogCluster::OnIpFieldChange\n");

    Ip = (LPNMIPADDRESS)pnmh;
        
    switch(idCtrl) {
    case IDC_EDIT_CL_IP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    case IDC_EDIT_CL_MASK:
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = Ip->hdr.idFrom;
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;
            
            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError((idCtrl == IDC_EDIT_CL_IP) ? IDS_PARM_CL_IP_FIELD : IDS_PARM_CL_NM_FIELD, Ip->iValue, low, high);
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    return 0;
}

/*
 * Method: OnEditClMask
 * Description: Called when the user modifies the cluster netmask.
 */
LRESULT CDialogCluster::OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mask_addr[CVY_MAX_CL_NET_MASK + 1];

    TraceMsg(L"CDialogCluster::OnEditClMask\n");

    switch (wNotifyCode) {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0)) {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(cl_ip_addr, cl_mask_addr);

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_SETTEXT, 0, (LPARAM)cl_mask_addr);

                break;
            }
    }

    return 0;
}

/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CDialogCluster::OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckRct\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Decide whether to enable or diable the password entry boxes based on the value of the remote checkbox. */
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) && !m_rct_warned) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_RCT_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_rct_warned = TRUE;
        }
        
        break;
    }
    
    return 0;
}

/*
 * Method: OnCheckMode
 * Description: Called when the user changes cluster mode.
 */
LRESULT CDialogCluster::OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If the user has IGMP checked, but is turning off multicast support, warn them. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST)) {
            if (!m_igmp_mcast_warned) {
                /* Alert the user. */
                NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_MCAST,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);            

                /* Only warn the user once. */
                m_igmp_mcast_warned = TRUE;
            } 

            /* Uncheck and disable the IGMP checkbox and set the IGMP support flag to FALSE. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, FALSE);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE);
            m_paramp->fIGMPSupport = FALSE;
        } else {
            /* Enable/disable and check/uncheck the IGMP checkbox based on the value of the cluster mode radio buttons. */
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST));
        }

        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        break;
    }

    return 0;
}

/*
 * Method: OnCheckIGMP
 * Description: Called when the user checks/unchecks the IGMP support checkbox.
 */
LRESULT CDialogCluster::OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckIGMP\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !m_igmp_warned) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_igmp_warned = TRUE;
        }

        break;
    }

    return 0;
}

/*
 * Method: SetClusterMACAddress
 * Description: Used to determine the cluster MAC address based on the cluster IP, and the
 *              state of multicast and IGMP support.
 */
void CDialogCluster::SetClusterMACAddress () {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];

    TraceMsg(L"CDialogCluster::SetClusterMACAddress\n");

    /* If the convert MAC flag isn't set, the bail out. */
    if (!m_paramp->fConvertMac) return;

    /* Retrieve the cluster IP address from the UI. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);
    
    /* Generate the cluster MAC address. */
    ParamsGenerateMAC(cl_ip_addr, cl_mac_addr, m_paramp->szMCastIpAddress, m_paramp->fConvertMac, ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST), 
                      ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP), m_paramp->fIpToMCastIp);
    
    /* Set the cluster MAC address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)cl_mac_addr);
}

/*
 * Method: CheckClusterMACAddress
 * Description: Used to check the cluster MAC address in the case where we aren't generating it ourselves.
 */
BOOL CDialogCluster::CheckClusterMACAddress () {
    PWCHAR p1, p2;
    WCHAR mac_addr[WLBS_MAX_NETWORK_ADDR + 1];
    DWORD i, j;
    BOOL flag = TRUE;
    
    /* Valid formats include:
       02:bf:0b:0b:01:01
       02-bf-0b-0b-01-01
       02:bf:0b:b:01:1 */

    /* Make a copy of the MAC address. */
    _tcscpy(mac_addr, m_paramp->cl_mac_addr);
    
    /* Point to the beginning of the MAC. */
    p2 = p1 = mac_addr;
    
    /* Loop through all six bytes. */
    for (i = 0 ; i < 6 ; i++) {
        /* If we are pointing at the end of the string, its invalid. */
        if (*p2 == _TEXT('\0')) return FALSE;
        
        /* Convert the hex characters into decimal. */
        j = _tcstoul(p1, &p2, 16);
        
        /* If the number is greater than 255, then the format is bad. */
        if (j > 255) return FALSE;
        
        /* If the NEXT character is neither a -, :, nor the NUL character, then the format is bad. */
        if (!((*p2 == _TEXT('-')) || (*p2 == _TEXT(':')) || (*p2 == _TEXT('\0')))) return FALSE;
        
        /* If the NEXT character is the end of the string, but we don't have enough bytes yet, bail out. */
        if (*p2 == _TEXT('\0') && i < 5) return FALSE;
        
        /* Repoint to the NEXT character. */
        p1 = p2 + 1;
        p2 = p1;
    }

    return TRUE;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current cluster settings.
 */
void CDialogCluster::SetInfo () {
    DWORD addr[4];

    TraceMsg(L"CDialogCluster::SetInfo %x %x\n", m_hWnd, ::GetActiveWindow());

    /* Check (or uncheck) the checkboxes. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, m_paramp->fRctEnabled);

    /* Check the appropriate radio button for cluster mode. */
    if (m_paramp->fMcastSupport) {
        ::CheckDlgButton(m_hWnd, IDC_RADIO_MULTICAST, TRUE);

        if (m_paramp->fIGMPSupport) ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, TRUE);
    } else 
        ::CheckDlgButton(m_hWnd, IDC_RADIO_UNICAST, TRUE);

    /* If the cluster IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!m_paramp->cl_ip_addr[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->cl_ip_addr, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* If the cluster subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!m_paramp->cl_net_mask[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->cl_net_mask, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* Fill in the edit boxes. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_SETTEXT, 0, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_SETTEXT, 0, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_SETTEXT, 0, (LPARAM)m_passw2);
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the cluster configuration.
 */
void CDialogCluster::UpdateInfo () {

    TraceMsg(L"CDialogCluster::UpdateInfo\n");

    /* Retrieve the checkbox values. */
    m_paramp->fRctEnabled = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) == 1;

    /* Retrieve the cluster mode radio button value. */
    m_paramp->fIGMPSupport = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) == 1;
    m_paramp->fMcastSupport = ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST) == 1;

    /* If the cluster IP entry box is empty, then the cluster IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0))
        m_paramp->cl_ip_addr[0] = 0;
    else 
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)m_paramp->cl_ip_addr);

    /* If the cluster net mask entry box is empty, then the cluster net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0))
        m_paramp->cl_net_mask[0] = 0;
    else 
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)m_paramp->cl_net_mask);

    /* Retrieve the entry box values. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw2);
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
LRESULT CDialogCluster::ValidateInfo () {
    BOOL fError = FALSE;
    DWORD IPAddr;

    TraceMsg(L"CDialogCluster::ValidateInfo\n");

    /* Check for a blank cluster IP address. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for a blank cluster net mask and fill it in if necessary. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0)) {
        /* Fill in the netmask for the user. */
        OnEditClMask(EN_SETFOCUS, 0, 0, fError);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)m_paramp->cl_net_mask);

        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Get the cluster IP address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);

    /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
    if (!FIRST_IPADDRESS(IPAddr)) {
        /* Make the first octet 1 instead of the erroneous 0. */
        IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);

        /* Set the IP address and update our cluster IP address string. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)m_paramp->cl_ip_addr);
      
        /* Alert the user. */
        PrintIPRangeError(IDS_PARM_CL_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

        return PSNRET_INVALID;
    }

    /* Check for valid cluster IP address/netmask pairs. */
    if (!IsValidIPAddressSubnetMaskPair(m_paramp->cl_ip_addr, m_paramp->cl_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_IP,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }
    
    /* Check to make sure that the netmask is contiguous. */
    if (!IsContiguousSubnetMask(m_paramp->cl_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_MASK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }
        
    /* Check to make sure that the dedicated IP and cluster IP are not the same. */
    if (!wcscmp(m_paramp->ded_ip_addr, m_paramp->cl_ip_addr)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_IP_CONFLICT,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* An error occurred. */
        return PSNRET_INVALID;
    }

    if (!m_paramp->fConvertMac && !CheckClusterMACAddress()) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_MAC,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only check for invalid passwords and update if remote control is enabled. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)) {
        /* Make sure the passwords match. */
        if (wcscmp(m_passw, m_passw2) != 0) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_PASSWORD,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);

            /* Empty the passwords. */
            m_passw [0] = m_passw2 [0] = 0;

            /* An error occurred. */
            return PSNRET_INVALID;
        } else {
            /* If the new password is not the dummy password, update the password. */
            if (wcscmp (m_passw, DUMMY_PASSWORD) != 0) {
                lstrcpy(m_paramp->szPassword, m_passw);
                m_paramp->fChangePassword = true;
            }

        }
    }

    return PSNRET_NOERROR;
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg (PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    vswprintf(szTempBufW, pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg
       so that it was not necessary to change all pre-existing calls thereof. */
    WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, 4096, NULL, NULL);
    
    /* Traced messages are now sent through the netcfg TraceTag routine so that
       they can be turned on/off dynamically. */
    TraceTag(ttidWlbs, szTempBufA);

    va_end(arglist);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\debug.cpp ===
//+----------------------------------------------------------------------------
//
// File: debug.cpp    	 
//
// Module:	Network Load Balancing
//
// Synopsis: Provide the functionality of ASSERT and TRACE 
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    8/3/98
//
//+----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

// #include "precomp.h"

#include "debug.h"

#if	( defined(DEBUG) || defined(_DEBUG) || defined (DBG))

#ifndef MB_SERVICE_NOTIFICATION
#define MB_SERVICE_NOTIFICATION 0
#endif

static long dwAssertCount = 0;  // Avoid another assert while the messagebox is up


//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageW(const TCHAR *pszFmt, ...) 
{
	va_list valArgs;
	TCHAR szOutput[512];

	va_start(valArgs,pszFmt);
	wvsprintf(szOutput,pszFmt,valArgs);
	va_end(valArgs);
	
	lstrcat(szOutput,TEXT("\r\n"));
	
	OutputDebugString(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessage
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageW(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg) 
{
	TCHAR szOutput[1024];

	wsprintf(szOutput,TEXT("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
	OutputDebugString(szOutput);

	wsprintf(szOutput,TEXT("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;


    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
		dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        WCHAR szFileName[MAX_PATH + 1];
        szFileName[0] = L'\0';   // in case of failure

        GetModuleFileNameW(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlen(szFileName);i != 0 && szFileName[i-1] != L'\\'; i--)
           ;

        WCHAR szTitle[48];
        lstrcpyW(szTitle, L"Assertion Failed - ");
        lstrcpynW(&szTitle[lstrlenW(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenW(szTitle) -1);  // there is no lstrcatn


		nCode = MessageBoxEx(NULL,szOutput,szTitle,
			MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);


	    dwAssertCount--;
    }


    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
		//
		// break into the debugger .
		// Step out of this fuction to get to your ASSERT() code
		//
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}




//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageA(const CHAR *pszFmt, ...) 
{
	va_list valArgs;
	CHAR szOutput[512];

	va_start(valArgs,pszFmt);
	wvsprintfA(szOutput,pszFmt,valArgs);
	va_end(valArgs);
	
	lstrcatA(szOutput,("\r\n"));
	
	OutputDebugStringA(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessageA
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageA(const CHAR *pszFile, unsigned nLine, const CHAR *pszMsg) 
{
	CHAR szOutput[1024];

	wsprintfA(szOutput,("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
	OutputDebugStringA(szOutput);

	wsprintfA(szOutput,("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;

    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
		dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        CHAR szFileName[MAX_PATH + 1];
        szFileName[0] = '\0';   // in case of failure

        GetModuleFileNameA(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlenA(szFileName);i != 0 && szFileName[i-1] != '\\'; i--)
           ;

        CHAR szTitle[48];
        lstrcpyA(szTitle, "Assertion Failed - ");
        lstrcpynA(&szTitle[lstrlenA(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenA(szTitle) -1);  // there is no lstrcatn

        nCode = MessageBoxExA(NULL,szOutput,szTitle,
			MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);

	    dwAssertCount--;
    }

    dwAssertCount--;

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
		//
		// break into the debugger .
		// Step out of this fuction to get to your ASSERT() code
		//
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\host.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    host.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - host config tab

Author:

    kyrilf
    shouse

--*/

#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

#define WLBS_BLANK_HPRI -1

class CDialogHost : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogHost)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDC_EDIT_DED_MASK, OnEditDedMask)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogHost (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogHost ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditDedMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    LRESULT OnFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    friend class CDialogCluster;
    friend class CDialogPorts;

private:
    void PrintRangeError (unsigned int ids, int low, int high);
    void PrintIPRangeError (unsigned int ids, int value, int low, int high);

    void SetInfo ();
    void UpdateInfo ();

    BOOL ValidateInfo ();

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\license.h ===
#ifdef  __cplusplus
extern "C"
{
#endif

ULONG License_string_encode (
    PCHAR               str);               /* NULL-terminated character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/

ULONG License_wstring_encode (
    PWCHAR              str);               /* NULL-terminated wide character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/


BOOL License_data_encode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Encodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY  bytes

  function:
*/


BOOL License_data_decode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Decodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY bytes

  function:
*/

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\netcfgcluster.h ===
#pragma once

#include "wlbscfg.h"

//+----------------------------------------------------------------------------
//
// class CNetcfgCluster
//
// Description: Provide cluster config functionality for netcfg .
//              SetConfig caches the settings without saving to registry            
//              and can be retrieved by GetConfig.
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------

HRESULT GetAdapterFromGuid(INetCfg *pNetCfg, const GUID& NetCardGuid, OUT INetCfgComponent** ppNetCardComponent);

class CNetcfgCluster
{
public:
    CNetcfgCluster(CWlbsConfig* pConfig);
    ~CNetcfgCluster();

    DWORD InitializeFromRegistry(const GUID& guidAdapter, bool fBindingEnabled, bool fUpgradeFromWin2k);
    HRESULT InitializeFromAnswerFile(const GUID& AdapterGuid, CSetupInfFile& caf, PCWSTR answer_sections);
    void InitializeWithDefault(const GUID& guidAdapter);

    void SetConfig(const NETCFG_WLBS_CONFIG* pClusterConfig);
    void GetConfig(NETCFG_WLBS_CONFIG* pClusterConfig);

    void NotifyBindingChanges(DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

    DWORD NotifyAdapter (INetCfgComponent * pAdapter, DWORD newStatus);

    DWORD ApplyRegistryChanges(bool fUninstall);
    DWORD ApplyPnpChanges(HANDLE hWlbsDevice);

    const GUID& GetAdapterGuid() { return m_AdapterGuid;}

    bool CheckForDuplicateClusterIPAddress (WCHAR * szOtherIP);

    bool IsReloadRequired () { return m_fReloadRequired; };
    static void ResetMSCSLatches();
protected:

    GUID m_AdapterGuid;

    WLBS_REG_PARAMS m_OriginalConfig;        // original config 
    WLBS_REG_PARAMS m_CurrentConfig;         // cached config

    bool m_fHasOriginalConfig;               // whether the adapter has an original config
    bool m_fOriginalBindingEnabled;          // whether the binding to the adapter is originally enabled
    bool m_fRemoveAdapter;                   // whether the adapter is to be removed
    bool m_fMacAddrChanged;                  // whether we need to reload the nic driver
    bool m_fReloadRequired;                  // set if changes in registry need to be picked by wlbs driver
    bool m_fReenableAdapter;                 // do we need to re-enable this adapter (did WE disable it?)
    static bool m_fMSCSWarningEventLatched;  // Throw MSCS warning only once when binding NLB
    static bool m_fMSCSWarningPopupLatched;  // Popup MSCS warning only once when binding NLB

    CWlbsConfig* m_pConfig;                  // pointer to access m_pWlbsApiFuncs
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\host.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

        host.cpp

Abstract:

        Windows Load Balancing Service (WLBS)
    Notifier object UI - host config tab

Author:

    kyrilf
    shouse

--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"
#include "host.h"
#include "utils.h"

#if DBG
static void TraceMsg(PCTSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

/*
 * Method: CDialogHost
 * Description: The class constructor.
 */
CDialogHost::CDialogHost (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {

    TraceMsg(L"CDialogHost::CDialogHost\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
}

/*
 * Method: ~CDialogHost
 * Description: The class destructor.
 */
CDialogHost::~CDialogHost () {

    TraceMsg(L"CDialogHost::~CDialogHost\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the host properties dialog.
 */
LRESULT CDialogHost::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnInitDialog\n");

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* Limit the field ranges for the address and priority fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, EM_SETLIMITTEXT, CVY_MAX_DED_IP_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, EM_SETLIMITTEXT, CVY_MAX_DED_NET_MASK, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PRI, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_PRI, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, m_paramp->dwMaxHosts);

    /* Limit the zeroth field of the dedicated IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */
    if (!wcscmp(m_paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) m_paramp->ded_ip_addr[0] = 0;
    if (!wcscmp(m_paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) m_paramp->ded_net_mask[0] = 0;

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogHost::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogHost::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the host settings tab becomes active (is clicked). 
 */
LRESULT CDialogHost::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the host settings tab.
 */
LRESULT CDialogHost::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogHost::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LRESULT fError = PSNRET_NOERROR;

    TraceMsg(L"CDialogHost::OnApply\n");

    /* Validate the UI values entered by the user. */
    fError = ValidateInfo();

    /* If the user has not specified dedicated IP address information, copy the defaults back. */
    if (!fError && !m_paramp->ded_ip_addr[0]) lstrcpy(m_paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR);
    if (!fError && !m_paramp->ded_net_mask[0]) lstrcpy(m_paramp->ded_net_mask, CVY_DEF_DED_NET_MASK);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);

    return fError;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogHost::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnCancel\n");

    return 0;
}

/*
 * Method: OnEditDedMask
 * Description: Called when the user modifies the host netmask.
 */
LRESULT CDialogHost::OnEditDedMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    WCHAR ded_ip_addr [CVY_MAX_DED_IP_ADDR + 1];
    WCHAR ded_mask_addr [CVY_MAX_DED_NET_MASK + 1];

    TraceMsg(L"CDialogHost::OnEditDedMask\n");

    switch (wNotifyCode) {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0)) {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR + 1, (LPARAM)ded_ip_addr);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(ded_ip_addr, ded_mask_addr);

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_SETTEXT, 0, (LPARAM)ded_mask_addr);

                break;
            }
    }

    return 0;
}

/*
 * Method: PrintRangeError
 * Description: Displays a message box warning the user of an out-of-range entry.
 */
void CDialogHost::PrintRangeError (unsigned int ids, int low, int high) {
    WCHAR szLow[10];
    WCHAR szHigh[10];

    TraceMsg(L"CDialogHost::PrintRangeError\n");

    /* Fill in the range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szLow, szHigh);
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in
 *              an IP address octet.
 */
void CDialogHost::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    WCHAR szCurrent[10];
    WCHAR szLow[10];
    WCHAR szHigh[10];

    TraceMsg(L"CDialogHost::PrintIPRangeError\n");

    /* Fill in the range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szCurrent, L"%d", value);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the dedicated IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogHost::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    TraceMsg(L"CDialogHost::OnIpFieldChange\n");

    Ip = (LPNMIPADDRESS)pnmh;

    switch(idCtrl) {
    case IDC_EDIT_DED_IP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    case IDC_EDIT_DED_MASK:
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = Ip->hdr.idFrom;
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;

            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError((idCtrl == IDC_EDIT_DED_IP) ? IDS_PARM_DED_IP_FIELD : IDS_PARM_DED_NM_FIELD, Ip->iValue, low, high);
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    return 0;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current host settings.
 */
void CDialogHost::SetInfo () {
    DWORD addr[4];

    TraceMsg(L"CDialogHost::SetInfo\n");

    /* Check (or uncheck) the initial cluster statecheckbox. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_ACTIVE, m_paramp->fJoinClusterOnBoot);

    /* If the dedicated IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!m_paramp->ded_ip_addr[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->ded_ip_addr, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* If the host subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!m_paramp->ded_net_mask[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->ded_net_mask, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* Fill in the host priority entry box.  If the entry is blank, insert an empty string. */
    if (m_paramp->dwHostPriority != WLBS_BLANK_HPRI)
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_PRI, m_paramp->dwHostPriority, FALSE);
    else
        ::SetDlgItemText(m_hWnd, IDC_EDIT_PRI, L"");
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the host configuration.
 */
void CDialogHost::UpdateInfo () {
    BOOL fValid = TRUE;

    TraceMsg(L"CDialogHost::UpdateInfo\n");

    /* Retrieve the active on boot flag value. */
    m_paramp->fJoinClusterOnBoot = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_ACTIVE) == 1;
    
    /* If the dedicated IP entry box is empty, then the dedicated IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0))
        m_paramp->ded_ip_addr[0] = 0;
    else
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR, (LPARAM)m_paramp->ded_ip_addr);

    /* If the host net mask entry box is empty, then the host net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0))
        m_paramp->ded_net_mask[0] = 0;
    else
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_GETTEXT, CVY_MAX_DED_NET_MASK, (LPARAM)m_paramp->ded_net_mask);

    /* Retrieve the host priority from the entry box. */
    m_paramp->dwHostPriority = ::GetDlgItemInt(m_hWnd, IDC_EDIT_PRI, &fValid, FALSE);

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. 
       In this case, we set the priority to a sentinnel value that will be checked later. */
    if (!fValid) m_paramp->dwHostPriority = WLBS_BLANK_HPRI;
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
BOOL CDialogHost::ValidateInfo () {
    BOOL fError = FALSE;
    DWORD IPAddr;

    TraceMsg(L"CDialogHost::ValidateInfo\n");

    /* Check for an invalid host priority. */
    if ((m_paramp->dwHostPriority < CVY_MIN_HOST_PRIORITY) || (m_paramp->dwHostPriority > m_paramp->dwMaxHosts)) {
        /* Help the user by setting the priority to the closest viable value. */
        if (m_paramp->dwHostPriority != WLBS_BLANK_HPRI) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_PRI, CVY_MIN_HOST_PRIORITY, CVY_MAX_HOST_PRIORITY);

            CVY_CHECK_MIN(m_paramp->dwHostPriority, CVY_MIN_HOST_PRIORITY);
            CVY_CHECK_MAX(m_paramp->dwHostPriority, CVY_MAX_HOST_PRIORITY);

            /* Set the handling priority to the now valid entry. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_PRI, m_paramp->dwHostPriority, FALSE);
        } else {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_PRI_BLANK, CVY_MIN_HOST_PRIORITY, CVY_MAX_HOST_PRIORITY);
        }

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for blank dedicated IP address with a non-empty netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0) &&
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DED_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for blank netmask with a non-empty dedicated IP address and fill in the netmask if necessary. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0) &&
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0)) {
        /* Fill in the netmask for the user. */
        OnEditDedMask(EN_SETFOCUS, 0, 0, fError);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_GETTEXT, CVY_MAX_DED_NET_MASK, (LPARAM)m_paramp->ded_net_mask);

        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DED_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only perform the rest of the IP checking if the user has specified both a dedicated
       IP address and a corresponding netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0) &&
        !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0)) {
        /* Get the dedicated IP address. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);
        
        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);
            
            /* Set the IP address and update our dedicated IP address string. */
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR, (LPARAM)m_paramp->ded_ip_addr);
            
            /* Alert the user. */
            PrintIPRangeError(IDS_PARM_DED_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);
            
            return PSNRET_INVALID;
        }

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(m_paramp->ded_ip_addr, m_paramp->ded_net_mask)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_DED_IP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* An error occurred. */
            return PSNRET_INVALID;
        }
        
        /* Check to make sure that the netmask is contiguous. */
        if (!IsContiguousSubnetMask(m_paramp->ded_net_mask)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_DED_MASK,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* An error occurred. */
            return PSNRET_INVALID;
        }

        /* Check if the Dedicated IP Address is not the same as one of the VIPs */
        DWORD dwNumRules = m_paramp->dwNumRules;
        while(dwNumRules--)
        {
            if (IpAddressFromAbcdWsz(m_paramp->ded_ip_addr) == IpAddressFromAbcdWsz(m_paramp->port_rules[dwNumRules].virtual_ip_addr)) 
            {
                /* Alert the user. */
                NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DIP_CONFLICT_VIP,
                         MB_APPLMODAL | MB_ICONSTOP | MB_OK);

                /* An error occurred. */
                return PSNRET_INVALID;
            }
        }

    }

    return PSNRET_NOERROR;
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg (PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    vswprintf(szTempBufW, pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, 4096, NULL, NULL);
    
    /* Traced messages are now sent through the netcfg TraceTag routine so that
       they can be turned on/off dynamically.   */
    TraceTag(ttidWlbs, szTempBufA);

    va_end(arglist);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\license.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    license.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Code to encrypt/decrypt passwords and port rules.

Author:

    kyrilf

History:

    JosephJ 11/22/00 Gutted this file and folded in three constants from
                the now defunct license.h. Basically the functions in this
                file used to do lots of things but now only encrypt/decrypt
                port rules and passwords. The port rules stuff is only used
                for upgrading from olde versions of wlbs so that may go away
                as well.

        This file is located in two places:
            WLBS netconfig code -- net\config\netcfg\wlbscfg
            WLBS API code -- net\wlbs\api

        Because this involves password encryption, we don't want to make
        the functions callable via a DLL entrypoint, and setting up
        a static library to be shared between netconfig and api stuff is
        not trivial and overkill because the two trees are far apart.
        
--*/
// #include <precomp.h>
#include <windows.h>
#include "wlbsparm.h"
#include "license.h"


/* CONSTANTS */


static UCHAR    data_key [] =
                            { 0x3f, 0xba, 0x6e, 0xf0, 0xe1, 0x44, 0x1b, 0x45,
                              0x41, 0xc4, 0x9f, 0xfb, 0x46, 0x54, 0xbc, 0x43 };

static UCHAR    str_key [] =

                           { 0xdb, 0x1b, 0xac, 0x1a, 0xb9, 0xb1, 0x18, 0x03,
                             0x55, 0x57, 0x4a, 0x62, 0x36, 0x21, 0x7c, 0xa6 };


/* Encryption and decryption routines are based on a public-domain Tiny
   Encryption Algorithm (TEA) by David Wheeler and Roger Needham at the
   Computer Laboratory of Cambridge University. For reference, please
   consult http://vader.brad.ac.uk/tea/tea.shtml */


static VOID License_decipher (
    PULONG              v,
    PULONG              k)
{
   ULONG                y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0xC6EF3720,
                        delta = 0x9E3779B9;

    /* sum = delta<<5, in general sum = delta * n */

    while (n-- > 0)
    {
        z -= (y << 4) + c ^ y + sum ^ (y >> 5) + d;
        y -= (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        sum -= delta;
    }

    v [0] = y; v [1] = z;

} /* end License_decipher */


static VOID License_encipher (
    PULONG              v,
    PULONG              k)
{
    ULONG               y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0,
                        delta = 0x9E3779B9;

    while (n-- > 0)
    {
        sum += delta;
        y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;
    }

    v [0] = y; v [1] = z;

} /* end License_encipher */



BOOL License_data_decode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_decipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_decode */


ULONG License_string_encode (
    PCHAR               str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_string_encode */

ULONG License_wstring_encode (
    PWCHAR              str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = (UCHAR)str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_wstring_encode */


BOOL License_data_encode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_encipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_encode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\netcfgconfig.cpp ===
//+----------------------------------------------------------------------------
//
// File:         netcfgconfig.cpp
//
// Module:       
//
// Description: Implement class CNetcfgCluster and class CWlbsConfig
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define ENABLE_PROFILE

#include <winsock2.h>
#include <windows.h>
#include <clusapi.h>
#include "debug.h"
#include "netcon.h"
#include "ncatlui.h"
#include "ndispnp.h"
#include "ncsetup.h"
#include "netcfgn.h"
#include "afilestr.h"

#include "help.h"
#include "resource.h"
#include "ClusterDlg.h"
#include "host.h"
#include "ports.h"
#include "wlbsparm.h"
#include "wlbsconfig.h"
#include "wlbscfg.h"
#include <time.h>
#include "netcfgcluster.h"
#include "license.h"
#include "tracelog.h"
#include "utils.h"
#include "netcfgconfig.tmh"
#include "log_msgs.h"

#define NETCFG_WLBS_ID L"ms_wlbs"

// Used by Netsetup and Component's who's answer file references AdapterSections
static const WCHAR c_szAdapterSections[] = L"AdapterSections";

void WlbsToNetcfgConfig(const WlbsApiFuncs* pApiFuncs, const WLBS_REG_PARAMS* pWlbsConfig, NETCFG_WLBS_CONFIG* pBNetcfgConfig);

void RemoveAllPortRules(PWLBS_REG_PARAMS reg_data);

HRESULT ParamReadAnswerFile(CSetupInfFile& caf, PCWSTR answer_sections, WLBS_REG_PARAMS* paramp);

bool WriteAdapterName(CWlbsConfig* pConfig, GUID& AdapterGuid);

bool ValidateVipInRule(const PWCHAR pwszRuleString, const WCHAR pwToken, DWORD& dwVipLen);

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#define DbgDumpBindPath NOP_FUNCTION
#endif

//
// Function pointers to avoid link with wlbsctrl.dll
//
bool WINAPI ParamReadReg(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data, bool fUpgradeFromWin2k = false, bool *pfPortRulesInBinaryForm = NULL);
typedef bool (WINAPI* ParamReadRegFUNC)(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data, bool fUpgradeFromWin2k = false, bool *pfPortRulesInBinaryForm = NULL);

bool  WINAPI ParamWriteReg(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data);
typedef bool (WINAPI* ParamWriteRegFUNC)(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data);

bool  WINAPI ParamDeleteReg(const GUID& AdaperGuid, bool fDeleteObsoleteEntries = false);
typedef bool (WINAPI* ParamDeleteRegFUNC)(const GUID& AdaperGuid, bool fDeleteObsoleteEntries = false);

DWORD  WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data);
typedef DWORD (WINAPI* ParamSetDefaultsFUNC)(PWLBS_REG_PARAMS    reg_data);

bool  WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);
typedef bool(WINAPI* RegChangeNetworkAddressFUNC) (const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);

void  WINAPI NotifyAdapterAddressChange(const WCHAR* pszPnpDevNodeId);
typedef void (WINAPI* NotifyAdapterAddressChangeFUNC)(const WCHAR* pszPnpDevNodeId);

DWORD WINAPI WlbsAddPortRule(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rule);
typedef DWORD (WINAPI* WlbsAddPortRuleFUNC)(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rule);

DWORD WINAPI WlbsSetRemotePassword(PWLBS_REG_PARAMS reg_data, const WCHAR* password);
typedef DWORD (WINAPI* WlbsSetRemotePasswordFUNC)(const PWLBS_REG_PARAMS reg_data, const WCHAR* password);

DWORD WINAPI WlbsEnumPortRules(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rules, PDWORD num_rules);
typedef DWORD (WINAPI* WlbsEnumPortRulesFUNC)(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rules, PDWORD num_rules);

DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid);
typedef DWORD (WINAPI* NotifyDriverConfigChangesFUNC)(HANDLE hDeviceWlbs, const GUID& AdapterGuid);

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly);
typedef HKEY (WINAPI* RegOpenWlbsSettingFUNC)(const GUID& AdapterGuid, bool fReadOnly);

struct WlbsApiFuncs {
    ParamReadRegFUNC pfnParamReadReg;
    ParamWriteRegFUNC pfnParamWriteReg;
    ParamDeleteRegFUNC pfnParamDeleteReg;
    ParamSetDefaultsFUNC pfnParamSetDefaults;
    RegChangeNetworkAddressFUNC pfnRegChangeNetworkAddress;
    NotifyAdapterAddressChangeFUNC pfnNotifyAdapterAddressChange;
    WlbsAddPortRuleFUNC pfnWlbsAddPortRule;
    WlbsSetRemotePasswordFUNC pfnWlbsSetRemotePassword;
    WlbsEnumPortRulesFUNC pfnWlbsEnumPortRules;
    NotifyDriverConfigChangesFUNC pfnNotifyDriverConfigChanges;
    RegOpenWlbsSettingFUNC pfnRegOpenWlbsSetting;
};

//+----------------------------------------------------------------------------
//
// Function:  LoadWlbsCtrlDll
//
// Description:  Load wlbsctrl.dll and get all function pointers
//
// Arguments: WlbsApiFuncs* pFuncs - 
//
// Returns:   HINSTANCE - wlbsctrl.dll handle
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
HINSTANCE LoadWlbsCtrlDll(WlbsApiFuncs* pFuncs) {

    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"LoadWlbsCtrlDll");

    ASSERT(pFuncs);

    HINSTANCE hDll;
	DWORD dwStatus = 0;

    hDll = LoadLibrary(L"wlbsctrl.dll");

    if (hDll == NULL) {
		dwStatus = GetLastError();
        TraceError("Failed to load wlbsctrl.dll", dwStatus);
        TRACE_CRIT("%!FUNC! Could not load wlbsctrl.dll with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return NULL;
    }

    pFuncs->pfnParamReadReg = (ParamReadRegFUNC)GetProcAddress(hDll, "ParamReadReg");
    pFuncs->pfnParamWriteReg = (ParamWriteRegFUNC)GetProcAddress(hDll, "ParamWriteReg");
    pFuncs->pfnParamDeleteReg = (ParamDeleteRegFUNC)GetProcAddress(hDll, "ParamDeleteReg");
    pFuncs->pfnParamSetDefaults = (ParamSetDefaultsFUNC)GetProcAddress(hDll, "ParamSetDefaults");
    pFuncs->pfnRegChangeNetworkAddress = (RegChangeNetworkAddressFUNC)GetProcAddress(hDll, "RegChangeNetworkAddress");
    pFuncs->pfnNotifyAdapterAddressChange = (NotifyAdapterAddressChangeFUNC)GetProcAddress(hDll, "NotifyAdapterAddressChange");
    pFuncs->pfnWlbsAddPortRule = (WlbsAddPortRuleFUNC)GetProcAddress(hDll, "WlbsAddPortRule");
    pFuncs->pfnWlbsSetRemotePassword = (WlbsSetRemotePasswordFUNC)GetProcAddress(hDll, "WlbsSetRemotePassword");
    pFuncs->pfnWlbsEnumPortRules = (WlbsEnumPortRulesFUNC)GetProcAddress(hDll, "WlbsEnumPortRules");
    pFuncs->pfnNotifyDriverConfigChanges = (NotifyDriverConfigChangesFUNC)GetProcAddress(hDll, "NotifyDriverConfigChanges");
    pFuncs->pfnRegOpenWlbsSetting = (RegOpenWlbsSettingFUNC)GetProcAddress(hDll, "RegOpenWlbsSetting");

    ASSERT (pFuncs->pfnParamReadReg != NULL); 
    ASSERT (pFuncs->pfnParamWriteReg != NULL); 
    ASSERT (pFuncs->pfnParamDeleteReg != NULL);
    ASSERT (pFuncs->pfnParamSetDefaults != NULL);
    ASSERT (pFuncs->pfnRegChangeNetworkAddress != NULL);
    ASSERT (pFuncs->pfnNotifyAdapterAddressChange != NULL);
    ASSERT (pFuncs->pfnWlbsAddPortRule != NULL);
    ASSERT (pFuncs->pfnWlbsSetRemotePassword != NULL);
    ASSERT (pFuncs->pfnWlbsEnumPortRules != NULL);
    ASSERT (pFuncs->pfnNotifyDriverConfigChanges != NULL);
    ASSERT (pFuncs->pfnRegOpenWlbsSetting != NULL);

    if (pFuncs->pfnParamReadReg == NULL ||
        pFuncs->pfnParamWriteReg == NULL||
        pFuncs->pfnParamDeleteReg == NULL||
        pFuncs->pfnParamSetDefaults == NULL||
        pFuncs->pfnRegChangeNetworkAddress == NULL||
        pFuncs->pfnNotifyAdapterAddressChange == NULL||
        pFuncs->pfnWlbsAddPortRule == NULL||
        pFuncs->pfnWlbsSetRemotePassword == NULL||
        pFuncs->pfnWlbsEnumPortRules == NULL||
        pFuncs->pfnNotifyDriverConfigChanges == NULL ||
        pFuncs->pfnRegOpenWlbsSetting == NULL) {

		dwStatus = GetLastError();
        TraceError("LoadWlbsCtrlDll GetProcAddress failed %d", dwStatus);
        TRACE_CRIT("%!FUNC! GetProcAddress failed %d", dwStatus);

        FreeLibrary(hDll);
        TRACE_VERB("<-%!FUNC!");
        
        return NULL;
    }

    TRACE_VERB("<-%!FUNC!");

    return hDll;
}

// Maximum characters in an IP address string of the form a.b.c.d
const DWORD MAXIPSTRLEN = 20;

void TransformOldPortRulesToNew(PWLBS_OLD_PORT_RULE  p_old_port_rules,
                                PWLBS_PORT_RULE      p_new_port_rules, 
                                DWORD                num_rules)
{
    TRACE_VERB("->%!FUNC!");
    if (num_rules == 0)
    {
        TRACE_INFO("%!FUNC! No port rules");
        TRACE_VERB("<-%!FUNC!");
        return;
    }
            
    while(num_rules--)
    {
        lstrcpy(p_new_port_rules->virtual_ip_addr, CVY_DEF_ALL_VIP);
        p_new_port_rules->start_port      = p_old_port_rules->start_port;
        p_new_port_rules->end_port        = p_old_port_rules->end_port;
 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->code            = p_old_port_rules->code;
 #else
        p_new_port_rules->Private1        = p_old_port_rules->Private1;
 #endif
        p_new_port_rules->mode            = p_old_port_rules->mode;
        p_new_port_rules->protocol        = p_old_port_rules->protocol;

 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->valid           = p_old_port_rules->valid;
 #else
        p_new_port_rules->Private2        = p_old_port_rules->Private2;
 #endif
        switch (p_new_port_rules->mode) 
        {
        case CVY_MULTI :
             p_new_port_rules->mode_data.multi.equal_load = p_old_port_rules->mode_data.multi.equal_load;
             p_new_port_rules->mode_data.multi.affinity   = p_old_port_rules->mode_data.multi.affinity;
             p_new_port_rules->mode_data.multi.load       = p_old_port_rules->mode_data.multi.load;
             break;
        case CVY_SINGLE :
             p_new_port_rules->mode_data.single.priority  = p_old_port_rules->mode_data.single.priority;
             break;
        default:
             break;
        }
        p_old_port_rules++;
        p_new_port_rules++;
    }

    TRACE_VERB("<-%!FUNC!");

    return;
}

/* Initialize static data members of CNetcfgCluster */
bool CNetcfgCluster::m_fMSCSWarningEventLatched = false;
bool CNetcfgCluster::m_fMSCSWarningPopupLatched = false;

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::CNetcfgCluster
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster::CNetcfgCluster(CWlbsConfig* pConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::CNetcfgCluster");

    m_fHasOriginalConfig = false;
    m_fMacAddrChanged = false;
    m_fReloadRequired = false;
    m_fRemoveAdapter = false;
    m_fOriginalBindingEnabled = false;
    m_fReenableAdapter = false;

    ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));

    ASSERT(pConfig);
    
    m_pConfig = pConfig;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::~CNetcfgCluster
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster::~CNetcfgCluster() {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::~CNetcfgCluster");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeFromRegistry
//
// Description:  Read the cluster settings from registry
//
// Arguments: const GUID& guidAdapter - 
//
// Returns:   DWORD - Win32 Error
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::InitializeFromRegistry(const GUID& guidAdapter, bool fBindingEnabled, bool fUpgradeFromWin2k) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeFromRegistry");

    bool fPortRulesInBinaryForm = false;

    ASSERT(m_fHasOriginalConfig == false);

    m_fHasOriginalConfig = true;
    m_fOriginalBindingEnabled = fBindingEnabled;
    m_AdapterGuid = guidAdapter;

    if (!m_pConfig->m_pWlbsApiFuncs->pfnParamReadReg(m_AdapterGuid, &m_OriginalConfig, fUpgradeFromWin2k, &fPortRulesInBinaryForm))
    {
        TRACE_VERB("%!FUNC! error reading settings from the registry"); // This is verbose because this is invoked for non-NLB adapters too.
        TRACE_VERB("<-%!FUNC!");
        return ERROR_CANTREAD;
    }
    
    /* Force a write at apply. */
    if (fUpgradeFromWin2k || fPortRulesInBinaryForm)
	{
        m_fHasOriginalConfig = false;  
        TRACE_INFO("%!FUNC! upgrading from win2k or port rules are in binary form");
	}

    CopyMemory(&m_CurrentConfig, &m_OriginalConfig, sizeof(m_CurrentConfig));

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeFromAnswerFile
//
// Description:  Read cluster settings from answer file
//
// Arguments: PCWSTR answer_file - 
//            PCWSTR answer_sections - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
HRESULT CNetcfgCluster::InitializeFromAnswerFile(const GUID& AdapterGuid, CSetupInfFile& caf, PCWSTR answer_sections) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeFromAnswerFile");

    /* Setup with the default values first. */
    InitializeWithDefault(AdapterGuid);

    HRESULT hr = ParamReadAnswerFile(caf, answer_sections, &m_CurrentConfig);

    if (FAILED(hr)) {
        TRACE_CRIT("%!FUNC! failed CNetcfgCluster::ParamReadAnswerFile failed. returned: %d", hr);
        TraceError("CNetcfgCluster::InitializeFromAnswerFile failed at ParamReadAnswerFile", hr);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeWithDefault
//
// Description:  Set the cluster settings to default
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::InitializeWithDefault(const GUID& guidAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeWithDefault");

    time_t cur_time;

    ASSERT(m_fHasOriginalConfig == false);

    m_fHasOriginalConfig = false;

    m_pConfig->m_pWlbsApiFuncs->pfnParamSetDefaults(&m_CurrentConfig); // Always returns WLBS_OK

    m_CurrentConfig.install_date = time(& cur_time);

    // JosephJ 11/00 -- We used to call License_stamp to set this value,
    //                  but that was a holdover from convoy days.
    //                  We no longer use this field.
    //
    m_CurrentConfig.i_verify_date = 0;

    m_AdapterGuid = guidAdapter;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::SetConfig
//
// Description:  SetConfig caches the settings without saving to registry            
//               and can be retrieved by GetConfig.
//
// Arguments: const NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::SetConfig(const NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::SetConfig");

    DWORD dwStatus = WLBS_OK; // Used for tracing output

    ASSERT(pClusterConfig != NULL);

    m_CurrentConfig.host_priority = pClusterConfig->dwHostPriority;
    m_CurrentConfig.rct_enabled = pClusterConfig->fRctEnabled ;
    m_CurrentConfig.cluster_mode = pClusterConfig->fJoinClusterOnBoot;
    m_CurrentConfig.mcast_support = pClusterConfig->fMcastSupport;
    m_CurrentConfig.fIGMPSupport = pClusterConfig->fIGMPSupport;
    m_CurrentConfig.fIpToMCastIp = pClusterConfig->fIpToMCastIp;

    lstrcpy(m_CurrentConfig.szMCastIpAddress, pClusterConfig->szMCastIpAddress);
    lstrcpy(m_CurrentConfig.cl_mac_addr, pClusterConfig->cl_mac_addr);
    lstrcpy(m_CurrentConfig.cl_ip_addr, pClusterConfig->cl_ip_addr);
    lstrcpy(m_CurrentConfig.cl_net_mask, pClusterConfig->cl_net_mask);
    lstrcpy(m_CurrentConfig.ded_ip_addr, pClusterConfig->ded_ip_addr);
    lstrcpy(m_CurrentConfig.ded_net_mask, pClusterConfig->ded_net_mask);
    lstrcpy(m_CurrentConfig.domain_name, pClusterConfig->domain_name);

    if (pClusterConfig->fChangePassword)
    {
        dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnWlbsSetRemotePassword(&m_CurrentConfig, (WCHAR*)pClusterConfig->szPassword);
        if (WLBS_OK != dwStatus)
        {
            TRACE_CRIT("%!FUNC! set password failed with return code = %d", dwStatus);
        }
    }

    RemoveAllPortRules(&m_CurrentConfig);

    for (DWORD i=0; i<pClusterConfig->dwNumRules; i++) {
        WLBS_PORT_RULE PortRule;
        
        ZeroMemory(&PortRule, sizeof(PortRule));

        lstrcpy(PortRule.virtual_ip_addr, pClusterConfig->port_rules[i].virtual_ip_addr);
        PortRule.start_port = pClusterConfig->port_rules[i].start_port;
        PortRule.end_port = pClusterConfig->port_rules[i].end_port;
        PortRule.mode = pClusterConfig->port_rules[i].mode;
        PortRule.protocol = pClusterConfig->port_rules[i].protocol;

        if (PortRule.mode == WLBS_AFFINITY_SINGLE) {
            PortRule.mode_data.single.priority = 
            pClusterConfig->port_rules[i].mode_data.single.priority;
        } else {
            PortRule.mode_data.multi.equal_load = 
            pClusterConfig->port_rules[i].mode_data.multi.equal_load;
            PortRule.mode_data.multi.affinity = 
            pClusterConfig->port_rules[i].mode_data.multi.affinity;
            PortRule.mode_data.multi.load = 
            pClusterConfig->port_rules[i].mode_data.multi.load;
        }

        PortRule.valid = TRUE;
        
        CVY_RULE_CODE_SET(&PortRule);

        dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnWlbsAddPortRule( &m_CurrentConfig, &PortRule );
        if (WLBS_OK != dwStatus)
        {
            TRACE_CRIT("%!FUNC! add port rule failed with return code = %d", dwStatus);
        }

    }
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::GetConfig
//
// Description:  Get the config, which could be cached by SetConfig call
//
// Arguments: NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::GetConfig(NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::GetConfig");

    ASSERT(pClusterConfig != NULL);

    WlbsToNetcfgConfig(m_pConfig->m_pWlbsApiFuncs, &m_CurrentConfig, pClusterConfig);
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::NotifyBindingChanges
//
// Description:  Notify binding changes
//
// Arguments: DWORD dwChangeFlag - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::NotifyBindingChanges(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::NotifyBindingChanges");

    ASSERT(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    if (dwChangeFlag & NCN_ADD) { m_fRemoveAdapter = false; }

    if ((dwChangeFlag & NCN_ENABLE) && !m_fMSCSWarningPopupLatched)
    {
        /* Warn the user via a pop-up if we detect MSCS is installed, but allow the NLB install to proceed. */
        DWORD dwClusterState = 0;
        if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
        {
            if (ClusterStateNotRunning == dwClusterState || ClusterStateRunning == dwClusterState)
            {
                NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_MSCS_INSTALLED,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                m_fMSCSWarningPopupLatched = true;
                TRACE_INFO("%!FUNC! Cluster Service is installed");
                TraceMsg(L"CNetcfgCluster::NotifyBindingChanges Cluster Service is installed.");
            } else { /* MSCS is not installed. That's good! */ }
        } else {
            TRACE_CRIT("%!FUNC! error determining if MSCS is installed.");
            TraceMsg(L"CNetcfgCluster::NotifyBindingChanges error getting MSCS status.");
        }
    }

    if (dwChangeFlag & NCN_REMOVE) { m_fRemoveAdapter = true; }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Function: CNetcfgCluster::NotifyAdapter
 * Description: Notify an adapter of a state change
 * Author: shouse 6.1.00
 */
DWORD CNetcfgCluster::NotifyAdapter (INetCfgComponent * pAdapter, DWORD newStatus) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    PWSTR pszPnpDevNodeId;

    switch (newStatus) {
        case DICS_PROPCHANGE: 
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Reload the adapter\n");
            break;
        case DICS_DISABLE:
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Disable the adapter\n");
            break;
        case DICS_ENABLE:
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Enable the adapter\n");
            break;
        default:
            TRACE_CRIT("%!FUNC! Invalid Notification 0x%x", newStatus);
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Invalid Notification 0x%x\n", newStatus);
            return ERROR_INVALID_PARAMETER;                              
    }

    if ((hr = HrSetupDiCreateDeviceInfoList(& GUID_DEVCLASS_NET, NULL, &hdi)) == S_OK) {
        if ((hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId)) == S_OK) {
            if ((hr = HrSetupDiOpenDeviceInfo (hdi, pszPnpDevNodeId, NULL, 0, &deid)) == S_OK) {
                if ((hr = HrSetupDiSendPropertyChangeNotification (hdi, & deid, newStatus, DICS_FLAG_GLOBAL, 0)) == S_OK) {
                    TraceMsg(L"##### CWLBS::HrNotifyAdapter notified NIC\n");
                } else {
                    TRACE_CRIT("%!FUNC! error %x in HrSetupDiSendPropertyChangeNotification", hr);
                    TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiSendPropertyChangeNotification\n", hr);
                }
            } else {
                TRACE_CRIT("%!FUNC! error %x in HrSetupDiOpenDeviceInfo", hr);
                TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiOpenDeviceInfo\n", hr);
            }
        } else {
            TRACE_CRIT("%!FUNC! error %x in GetPnpDevNodeId", hr);
            TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in GetPnpDevNodeId\n", hr);
        }
        
        SetupDiDestroyDeviceInfoList (hdi);
    } else {
        TRACE_CRIT("%!FUNC! error %x in HrSetupDiCreateDeviceInfoList for Change: 0x%x", hr, newStatus);
        TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiCreateDeviceInfoList for Change: 0x%x\n", newStatus);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ApplyRegistryChanges
//
// Description:  Apply registry changes
//
// Arguments: None
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::ApplyRegistryChanges(bool fUninstall) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;

    /* Uninstall WLBS or remove the adapter. */
    if (fUninstall || m_fRemoveAdapter) {
        if (m_fHasOriginalConfig &&m_OriginalConfig.mcast_support == false ) {
            /* If we were in unicast mode, remove the mac, and reload Nic driver upon PnP. */
            if (fUninstall) {
                INetCfgComponent * pAdapter = NULL;
                
                /* If the adapter is enabled, disable it when the MAC address changes.  This prevents a
                   switch from learning a MAC address due to ARPs that TCP/IP sends out before WLBS is
                   enabled and able to spoof the source MAC. The NIC will be re-enabled in ApplyPnpChanges(). */
                if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) == S_OK) {
                    ULONG status = 0UL;
                    
                    /* Only disable the adapter if the adapter is currently enabled and NLB was initially 
                       (in this netcfg session) bound to the adapter. */
                    if (m_fOriginalBindingEnabled) {
                        if ((hr = pAdapter->GetDeviceStatus(&status)) == S_OK) {
                            if (status != CM_PROB_DISABLED) {
                                m_fReenableAdapter = true;
                                NotifyAdapter(pAdapter, DICS_DISABLE); 
                            }
                        }
                    }

                    pAdapter->Release();
                    pAdapter = NULL;
                }

                m_fMacAddrChanged = true;
            }

            /*  remove mac addr, */
            if (m_pConfig->m_pWlbsApiFuncs->pfnRegChangeNetworkAddress(m_AdapterGuid, m_OriginalConfig.cl_mac_addr, true) == false) {
                dwStatus = GetLastError();
				TraceError("CWlbsCluster::WriteConfig failed at RegChangeNetworkAddress", dwStatus);
                TRACE_CRIT("<-%!FUNC! failed removing MAC address with %d", dwStatus);
			}
        }

        m_pConfig->m_pWlbsApiFuncs->pfnParamDeleteReg(m_AdapterGuid); 

        TRACE_INFO("<-%!FUNC! Exiting on success removing adapter or uninstalling NLB");
        TRACE_VERB("<-%!FUNC!");
        return ERROR_SUCCESS;
    }

    /* Find out whether the adapter is bound to NLB. */
    INetCfgComponent* pAdapter = NULL;
    bool fCurrentBindingEnabled;
    bool fOriginalMacAddrSet; bool fCurrentMacAddrSet;

    if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
        fCurrentBindingEnabled = false;
    } else {
        fCurrentBindingEnabled = (m_pConfig->IsBoundTo(pAdapter) == S_OK);
        pAdapter->Release();
        pAdapter = NULL;
    }

    if ((m_fOriginalBindingEnabled == fCurrentBindingEnabled) && m_fHasOriginalConfig) {
        if (!memcmp(&m_OriginalConfig, &m_CurrentConfig, sizeof(m_CurrentConfig))) {
            /* If the binding hasn't changed and we have previously bound to this adapter
               (originalconfig -> loaded from registry) and the NLB parameters haven't 
               changed, then nothing changed and we can bail out here. */
            LOG_INFO("CNetcfgCluster::ApplyRegistryChanges, Exiting !!!");
            TRACE_INFO("%!FUNC! no changes needed...exiting");
            TRACE_VERB("<-%!FUNC!");
            return WLBS_OK;
        } else {
            /* Otherwise, if the binding hasn't changed, NLB is currently bound, and we have 
               previously bound to this adapter (originalconfig -> loaded from registry) 
               and the NLB parameters HAVE changed, then we need to reload the driver. */
            if (fCurrentBindingEnabled) m_fReloadRequired = true;
        }
    }

    /* If MSCS is installed and NLB is bound, throw an NT event (event is latched, so check this too) */
    DWORD dwClusterState = 0;
    if (fCurrentBindingEnabled && !m_fMSCSWarningEventLatched)
    {
        if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
        {
            if (ClusterStateNotRunning == dwClusterState || ClusterStateRunning == dwClusterState)
            {
                /* Log NT event -- Do not throw an error if these calls fail. This is just best effort. */
                HANDLE hES = RegisterEventSourceW (NULL, CVY_NAME);
                if (NULL != hES)
                {
                    TRACE_INFO("%!FUNC! detected that MSCS is installed");
                    TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges MSCS warning event needs to be logged.");
                    if (ReportEventW(hES,                                /* Handle to event log*/
                                     EVENTLOG_WARNING_TYPE,              /* Event type */
                                     0,                                  /* Category */
                                     IDS_INSTALL_WITH_MSCS_INSTALLED,    /* MessageId */
                                     NULL,                               /* Security identifier */
                                     0,                                  /* Num args to event string */ 
                                     0,                                  /* Size of binary data */
                                     NULL,                               /* Ptr to args for event string */
                                     NULL))                              /* Ptr to binary data */
                    {
                        /* Latch the event, so it won't be thrown again */
                        m_fMSCSWarningEventLatched = true;
                    }
                    else
                    {
                        /* Couldn't log the NT event. Don't fail anything; we aren't latched so we'll try to log again on next change */
                        TRACE_CRIT("%!FUNC! call to write the MSCS warning event failed");
                        TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges failed to write MSCS warning event to log.");
                    }
                    DeregisterEventSource(hES);
                }
                else
                {
                    TRACE_CRIT("%!FUNC! failed call to RegisterEventSource to log the MSCS warning event.");
                    TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges failed call to RegisterEventSource for MSCS warning event.");
                }
            }
            else { /* MS Cluster Service is not installed. That's good! */ }
        }
        else
        {
            TRACE_CRIT("%!FUNC! error determining if MSCS is installed.");
            TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges error checking MSCS state.");
        }
    }

    // The m_fHasOriginalConfig flag will be false if 
    // 1. Bind NLB for the first time
    // 2. Clean Installs with NLB info in Answer file
    // 3. Upgrade from NT 4 or Win 2k or XP with Port Rules in Binary format
    // In case #1 & #2, the following attempt to delete registry entries from the old location
    // will be a no-op 'cos there will be no old registry entries to delete
    bool bStatus = true;
    if (!m_fHasOriginalConfig)
    {
        if (!m_pConfig->m_pWlbsApiFuncs->pfnParamDeleteReg(m_AdapterGuid, true))
        {
            TRACE_CRIT("%!FUNC! error deleting parameters from the registry");
        }
    }

    if (!m_pConfig->m_pWlbsApiFuncs->pfnParamWriteReg(m_AdapterGuid, &m_CurrentConfig))
    {
        TRACE_CRIT("%!FUNC! error writing parameters into the registry");
        TRACE_VERB("<-%!FUNC!");
        return WLBS_REG_ERROR;
    }

    /* Write adapter name into the registry for API use. */
    if(!WriteAdapterName(m_pConfig, m_AdapterGuid))
    {
        TRACE_CRIT("%!FUNC! error writing adapter name into the registry (for API use)");
    }

    /* Figure out whether we need to change MAC address. */
    if (!m_fOriginalBindingEnabled || !m_fHasOriginalConfig)
        fOriginalMacAddrSet = false;
    else
        fOriginalMacAddrSet = !m_OriginalConfig.mcast_support;

    if (!fCurrentBindingEnabled)
        fCurrentMacAddrSet = false;
    else
        fCurrentMacAddrSet = !m_CurrentConfig.mcast_support;

    /* If the MAC address changes for any reason, disable/enable the adapter. */
    if ((fOriginalMacAddrSet != fCurrentMacAddrSet) || wcscmp(m_CurrentConfig.cl_mac_addr, m_OriginalConfig.cl_mac_addr))
    {
        INetCfgComponent * pAdapter = NULL;

        /* If the adapter is enabled, disable it when the MAC address changes.  This prevents a 
           switch from learning a MAC address due to ARPs that TCP/IP sends out before WLBS is 
           enabled and able to spoof the source MAC. The NIC will be re-enabled in ApplyPnpChanges(). */
        if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) == S_OK) {
            ULONG status = 0UL;

            if ((hr = pAdapter->GetDeviceStatus(&status)) == S_OK) {
                if (status != CM_PROB_DISABLED) {
                    m_fReenableAdapter = true;
                    m_fReloadRequired = false; /* If we are disabling/enabling the adapter, we don't need to reload too. */
                    LOG_INFO("CNetcfgCluster::ApplyRegistryChanges, About to Disable Adapter");
                    dwStatus = NotifyAdapter(pAdapter, DICS_DISABLE);
                    LOG_INFO("CNetcfgCluster::ApplyRegistryChanges, Returned from Disabling Adapter");
					if (!SUCCEEDED(dwStatus))
					{
						TRACE_CRIT("%!FUNC! a call to NotifyAdapter to disable the adapter for a MAC address change failed with %d", dwStatus);
					} else
					{
						TRACE_INFO("%!FUNC! a call to NotifyAdapter to disable the adapter for a MAC address change succeeded");
					}
                }
            }

            pAdapter->Release();
            pAdapter = NULL;
        }        

        /* Change the mac address. */
        m_fMacAddrChanged = true;
        m_pConfig->m_pWlbsApiFuncs->pfnRegChangeNetworkAddress(m_AdapterGuid, m_CurrentConfig.cl_mac_addr, !fCurrentMacAddrSet);
        TraceMsg(L"New MAC address written to registry");
		TRACE_INFO("%!FUNC! new MAC address written to registry");
    }

    CopyMemory(&m_OriginalConfig, &m_CurrentConfig, sizeof(m_CurrentConfig));

    m_fHasOriginalConfig = true;
    m_fOriginalBindingEnabled = fCurrentBindingEnabled;

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ResetMSCSLatches
//
// Description:  Resets the static flags for latching warning popup and NT event
//               when MSCS is already installed. This reset allows the user to
//               control the period during which latching is valid
//
// Arguments: None
//
// Returns:   None
//
// History:   chrisdar Created: 01.05.07
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::ResetMSCSLatches() {
    TRACE_VERB("->%!FUNC!");
    CNetcfgCluster::m_fMSCSWarningEventLatched = false;
    CNetcfgCluster::m_fMSCSWarningPopupLatched = false;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ApplyPnpChanges
//
// Description:  Apply the changes to drivers
//
// Arguments: HANDLE hWlbsDevice - 
//
// Returns:   DWORD - Win32 Error
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::ApplyPnpChanges(HANDLE hDeviceWlbs) {
    TRACE_VERB("->%!FUNC!");

    if (m_fReloadRequired && (hDeviceWlbs != INVALID_HANDLE_VALUE)) {
        DWORD dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnNotifyDriverConfigChanges(hDeviceWlbs, m_AdapterGuid); // Always returns ERROR_SUCCESS
        TraceMsg(L"NLB driver notified of configuration changes");
        TRACE_INFO("%!FUNC! nlb driver notified of configuration changes and returned %d where %d indicates success", dwStatus, ERROR_SUCCESS);
    }

    if (m_fMacAddrChanged) {
        PWSTR pszPnpDevNodeId = NULL;
        INetCfgComponent* pAdapter = NULL;
        HRESULT hr;

        hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter);
        
        if (hr != S_OK) {
            TraceError("GetAdapterFromGuid failed at GetPnpDevNodeId", hr);
            TRACE_CRIT("%!FUNC! call to GetAdapterFromGuid failed with %d", hr);
            return false;
        }

        hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId);

        if (hr != S_OK) {
            TraceError("HrWriteAdapterName failed at GetPnpDevNodeId", hr);
            TRACE_CRIT("%!FUNC! call to GetPnpDevNodeId failed with %d", hr);
            return false;
        }

        m_pConfig->m_pWlbsApiFuncs->pfnNotifyAdapterAddressChange(pszPnpDevNodeId); // No return value to check
        TraceMsg(L"Adapter notified of new MAC address");
        TRACE_INFO("%!FUNC! adapter notified of new MAC address");

        /* If the adapter was disabled in ApplyRegistryChanges() because the MAC 
           address changed and the NIC was enabled, then re-enable it here. */
        if (m_fReenableAdapter) {
            LOG_INFO("CNetcfgCluster::ApplyPnpChanges, About to Enable Adapter");
            DWORD dwStatus = NotifyAdapter(pAdapter, DICS_ENABLE);
            LOG_INFO("CNetcfgCluster::ApplyPnpChanges, Returned from Enabling Adapter");
			if (!SUCCEEDED(dwStatus))
			{
                TRACE_CRIT("%!FUNC! a call to NotifyAdapter to reenable the adapter after a previous disable for a MAC address change failed with %d", dwStatus);
			} else
			{
                TRACE_INFO("%!FUNC! a call to NotifyAdapter to reenable the adapter after a previous disable for a MAC address change succeeded");
			}
        }

        pAdapter->Release();
        pAdapter = NULL;

        CoTaskMemFree(pszPnpDevNodeId);
    }

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

/*
 * Function: CNetcfgCluster::CheckForDuplicateClusterIPAddress
 * Description: Used to check for duplicate cluster IP addresses across multiple NICs.
 * Author: shouse 10.24.00
 */
bool CNetcfgCluster::CheckForDuplicateClusterIPAddress (WCHAR * szOtherIP) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::CheckForDuplicateClusterIPAddress");

    HRESULT hr = S_OK;

    /* First check to see whether the cluster IP addresses match. */
    if (!wcscmp(m_CurrentConfig.cl_ip_addr, szOtherIP)) {
        INetCfgComponent* pAdapter = NULL;
        
        /* If they do match, get the INetCfgComponent interface for this GUID. */
        if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
            TraceError("GetAdapterFromGuid failed in CNetcfgCluster::CheckForDuplicateClusterIPAddress", hr);
            TRACE_CRIT("%!FUNC! call to GetAdapterFromGuid failed with %d", hr);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
        
        /* If NLB is bound to this adapter, then there is a conflict. */
        if (m_pConfig->IsBoundTo(pAdapter) == S_OK)
        {
            TRACE_INFO("%!FUNC! duplicate IP address found");
            TRACE_VERB("<-%!FUNC!");
            return TRUE;
        }
    }

    TRACE_INFO("%!FUNC! no duplicate IP address was found");
    TRACE_VERB("<-%!FUNC!");
    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::CWlbsConfig
//
// Purpose:   constructor for class CWlbsConfig
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWlbsConfig::CWlbsConfig(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::CWlbsConfig");

    m_pWlbsComponent = NULL;
    m_pNetCfg = NULL;
    m_ServiceOperation = WLBS_SERVICE_NONE;
    m_hDeviceWlbs = INVALID_HANDLE_VALUE;
    m_hdllWlbsCtrl = NULL;
    m_pWlbsApiFuncs = NULL;
    /* Initialize latched flags of CNetCfgCluster so that we get pristine
       MSCS popup and NT events when making config changes and MSCS is installed.
       Comment out this call if the NT event and popup should be thrown only
       once per loading of this dll */
    CNetcfgCluster::ResetMSCSLatches();
    TRACE_VERB("<-%!FUNC!");
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::~CWlbsConfig
//
// Purpose:   destructor for class CWlbsConfig
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWlbsConfig::~CWlbsConfig(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::~CWlbsConfig");

    /* Release interfaces if acquired. */
    ReleaseObj(m_pWlbsComponent);
    ReleaseObj(m_pNetCfg);

    if (m_pWlbsApiFuncs) delete m_pWlbsApiFuncs;

    if (m_hdllWlbsCtrl) FreeLibrary(m_hdllWlbsCtrl);

    /* Free all clusters. */
    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;
        ASSERT(pCluster != NULL);
        delete pCluster;
    }
    TRACE_VERB("<-%!FUNC!");
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Initialize(INetCfg* pNetCfg, BOOL fInstalling) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Initialize");

    HRESULT hr = S_OK;

    /* Load wlbsctrl.dll */
    ASSERT(m_pWlbsApiFuncs == NULL);
    ASSERT(m_hdllWlbsCtrl == NULL);

    m_pWlbsApiFuncs = new WlbsApiFuncs;

    if (m_pWlbsApiFuncs == NULL)
    {
        TRACE_CRIT("%!FUNC! memory allocation failed for m_pWlbsApiFuncs");
        return E_OUTOFMEMORY;
    }

    m_hdllWlbsCtrl = LoadWlbsCtrlDll(m_pWlbsApiFuncs);

    if (m_hdllWlbsCtrl == NULL) {
		DWORD dwStatus = GetLastError();
        TRACE_CRIT("%!FUNC! failed to load wlbsctrl.dll with error %d", dwStatus);
        TraceError("CWlbsConfig::Initialize Failed to load wlbsctrl.dll", dwStatus);
    
        // CLD: What in the world is going on here?
        if (dwStatus == ERROR_SUCCESS)
		{
            TRACE_VERB("<-%!FUNC!");
			return E_FAIL;
		}

        TRACE_VERB("<-%!FUNC!");
        return HRESULT_FROM_WIN32(dwStatus);
    }

    AddRefObj (m_pNetCfg = pNetCfg);

    /* Find the WLBS component. */
    ASSERT(m_pWlbsComponent == NULL);
    m_pWlbsComponent = NULL;

    /* The WLBS conponent object is not available at installation time. */
    if (!fInstalling) {
        if (FAILED(hr = pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
            ASSERT(fInstalling);
            TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", hr);
            TraceError("INetCfg::FindComponent failed",hr);
        }

        hr = LoadAllAdapterSettings(false);  // fUpgradeFromWin2k = false
		if (FAILED(hr))
		{
            TRACE_CRIT("%!FUNC! loading all adapter settings for a non-window 2000 upgrade failed with %d", hr);
		}
    }

    ASSERT_VALID(this);

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::LoadAllAdapters
//
// Description:  Load all cluster settings from registry
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
HRESULT CWlbsConfig::LoadAllAdapterSettings(bool fUpgradeFromWin2k) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::LoadAllAdapterSettings");

    HRESULT hr = S_OK;
    INetCfgClass *pNetCfgClass = NULL;
    INetCfgComponent* pNetCardComponent = NULL;

    ASSERT_VALID(this);

    hr = m_pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET, IID_INetCfgClass, (void **)&pNetCfgClass);

    if (FAILED(hr)) {
        TraceError("INetCfg::QueryNetCfgClass failed", hr);
        TRACE_CRIT("%!FUNC! call to QueryNetCfgClass failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr; 
    }

    /* Get an enumerator to list all network devices. */
    IEnumNetCfgComponent *pIEnumComponents = NULL;

    if (FAILED(hr = pNetCfgClass->EnumComponents(&pIEnumComponents))) {
        TraceError("INetCfg::EnumComponents failed", hr);
        TRACE_CRIT("%!FUNC! call to enumerate components failed with %d", hr);
        pNetCfgClass->Release();
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    /* Go through all the adapters and load settings for adapters that are bound to WLBS. */
    while (pIEnumComponents->Next(1, &pNetCardComponent, NULL) == S_OK) {
        GUID AdapterGuid;

        /* Retrieve the instance GUID of the component. */
        if (FAILED(hr = (pNetCardComponent)->GetInstanceGuid(&AdapterGuid))) {
            pNetCardComponent->Release();
            pNetCardComponent = NULL;
            TraceError("GetInstanceGuid failed", hr);
            TRACE_CRIT("%!FUNC! call to retrieve the guid instance of the adapter failed with %d", hr);
            continue;
        }

        bool fBound = (IsBoundTo(pNetCardComponent) == S_OK);

        pNetCardComponent->Release();
        pNetCardComponent = NULL;

        /* Win2k support only one adapter.  The settings will be lost if not bound. */
        if (fUpgradeFromWin2k && !fBound) continue;

        /* Load settings regardless of bindings for non-upgrade case. */
        CNetcfgCluster* pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! failed memory allocation for CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_OUTOFMEMORY;
        }

		DWORD dwStatus = pCluster->InitializeFromRegistry(AdapterGuid, fBound, fUpgradeFromWin2k);
        if (dwStatus != ERROR_SUCCESS) {
            /* If NLB is already bound to this adapter, this is an issue - if not, its fine. */
            if (fBound) {
                TRACE_CRIT("%!FUNC! reading nlb information from registry failed with %d", dwStatus);
                ASSERT(!fBound);
            }

            delete pCluster;
            continue;
        }

        m_vtrCluster.push_back(pCluster);    
    }

    pIEnumComponents->Release();
    pNetCfgClass->Release();
    TRACE_VERB("<-%!FUNC!");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure WLBS
//
// Arguments:
//    pszAnswerFile     [in]  name of AnswerFile
//    pszAnswerSection  [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ReadAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ReadAnswerFile");

    HRESULT hr = S_OK;
    CSetupInfFile caf;

    ASSERT_VALID(this);

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = caf.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

    if (FAILED(hr)) {
        TraceError("caf.HrOpen failed", hr);
        TRACE_CRIT("%!FUNC! attempt to open answer file failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    // Get the adapter specific parameters
    WCHAR * mszAdapterList;

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(), pszAnswerSection, c_szAdapterSections, &mszAdapterList);

    if (FAILED(hr)) {
        TraceError("WLBS HrSetupGetFirstMultiSzFieldWithAlloc failed", hr);
        TRACE_CRIT("%!FUNC! attempt to retrieve adapter list from answer file failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    tstring  strAdapterName;
    tstring  strInterfaceRegPath;

    for (PCWSTR pszAdapterSection = mszAdapterList; *pszAdapterSection; pszAdapterSection += lstrlenW(pszAdapterSection) + 1) {
        // Get the card name "SpecificTo = ..."
        hr = HrSetupGetFirstString(caf.Hinf(), pszAdapterSection, c_szAfSpecificTo, &strAdapterName);

        if (FAILED(hr)) {
            TraceError("WLBS HrSetupGetFirstString failed", hr);
            TRACE_CRIT("%!FUNC! attempt to retrieve adapter name from answer file failed with %d. Skipping to next adapter", hr);
            continue;
        }

        GUID guidNetCard;

        if (!FGetInstanceGuidOfComponentInAnswerFile(strAdapterName.c_str(), m_pNetCfg, &guidNetCard)) {
            TraceError("WLBS FGetInstanceGuidOfComponentInAnswerFile failed", FALSE);
            TRACE_CRIT("%!FUNC! attempt to retrieve netcard guid from answer file failed. Skipping to next adapter");
            continue;
        }

        CNetcfgCluster* pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
		{
            TRACE_CRIT("%!FUNC! memory allocation failure for CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
			return ERROR_OUTOFMEMORY;
		}

        if (FAILED(hr = pCluster->InitializeFromAnswerFile(guidNetCard, caf, pszAdapterSection))) {
            TraceError("WLBS InitializeFromAnswerFile failed", hr);
            TRACE_CRIT("%!FUNC! attempt to initialize the adapter settings from answer file failed with %d. Skipping to next adapter", hr);
            delete pCluster;
            continue;
        }

        m_vtrCluster.push_back(pCluster);    
    }

    delete [] mszAdapterList;

    caf.Close();

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Install(DWORD /* dw */) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Install");

    HRESULT hr = S_OK;

    ASSERT_VALID(this);

    /* Start up the install process. */
    m_ServiceOperation = WLBS_SERVICE_INSTALL;

    if (m_pWlbsComponent == NULL && FAILED(m_pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
        TraceError("INetCfg::FindComponent failed at Install",hr);
        TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", hr);
    }

    TRACE_VERB("->%!FUNC!");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Upgrade
//
// Purpose:   Do operations necessary for upgrade.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Upgrade(DWORD /* dwSetupFlags */, DWORD /* dwUpgradeFromBuildNo */) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Upgrade");

    ASSERT_VALID(this);

    /*  If we do not have any cluster, there might be 
        old registry settings under different place. */
    if (m_vtrCluster.size() == 0)
	{
		HRESULT hr = LoadAllAdapterSettings(true); // fUpgradeFromWin2k = true
		if (FAILED(hr))
		{
            TRACE_CRIT("%!FUNC! loading all adapter settings for a window 2000 upgrade failed with %d", hr);
		}
	}

    m_ServiceOperation = WLBS_SERVICE_UPGRADE;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Removing(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"##### CWlbsConfig::Removing\n");

    ASSERT_VALID(this);

    m_ServiceOperation = WLBS_SERVICE_REMOVE;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::GetAdapterConfig
//
// Description:  Read the adapter config, which could be cached by SetAdapterConfig
//
// Arguments: const GUID& AdapterGuid - 
//            NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   STDMETHODIMP - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::GetAdapterConfig(const GUID& AdapterGuid, NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::GetAdapterConfig");

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL)
    {
        TRACE_INFO("%!FUNC! did not find cluster");
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    pCluster->GetConfig(pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::SetAdapterConfig
//
// Description: Set the adapter config, the result is cached and not saved to registry 
//
// Arguments: const GUID& AdapterGuid - 
//            NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   STDMETHODIMP - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::SetAdapterConfig(const GUID& AdapterGuid, NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::SetAdapterConfig");

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL) {
        TRACE_INFO("%!FUNC! did not find cluster. Will create instance");
        pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! memory allocation failure creating instance of CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
            return E_OUTOFMEMORY;
        }

        pCluster->InitializeWithDefault(AdapterGuid); // Returns void

        //
        // See bug 233962, NLB configuration lost when leaving nlb properties
        // The reason is that NLB notifier object is not notified when NLB is checked.
        // Currently, there is no consistant repro.  Uncommented the code below will fix the peoblem.
        // But will leaves potential bug in netcfg hard to catch.
        // Uncomment the code only after the netcfg bug is fixed.
        //
        // m_vtrCluster.push_back(pCluster);    
    }

    pCluster->SetConfig(pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
// 
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ApplyRegistryChanges(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ApplyRegistryChanges");

    ASSERT_VALID(this);

    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL)
		{
			DWORD dwStatus = pCluster->ApplyRegistryChanges(m_ServiceOperation == WLBS_SERVICE_REMOVE);
			if (ERROR_SUCCESS != dwStatus && WLBS_OK != dwStatus)
			{
                TRACE_CRIT("%!FUNC! applying registry changes to a CNetcfgCluster failed with %d. Continue with next instance", dwStatus);
			}
		}
		else
		{
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster");
		}
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Propagate changes to the driver.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ApplyPnpChanges() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ApplyPnpChanges");

    vector<CNetcfgCluster*>::iterator iter;
    bool bCreateDevice = FALSE;
    DWORD dwStatus = ERROR_SUCCESS;

    ASSERT_VALID(this);

    /* Check to see if we need to open the IOCTL interface to the driver.  This is necessary
       if any adapter in our cluster list requries a reload (which is done via an IOCTL). */
    for (iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        if (bCreateDevice |= pCluster->IsReloadRequired()) break;
    }
    
    /* Open the file and return an error if this is unsuccessful. */
    if (bCreateDevice) {
        TRACE_INFO("%!FUNC! at least one adapter requires a reload. Open an IOCTL.");
        ASSERT(m_hDeviceWlbs == INVALID_HANDLE_VALUE);
        
        m_hDeviceWlbs = CreateFile(_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
        
        if (m_hDeviceWlbs == INVALID_HANDLE_VALUE) {
			dwStatus = GetLastError();
            TraceMsg(L"Error opening \\\\.\\WLBS device %x", dwStatus);
            TraceError("Invalid \\\\.\\WLBS handle", dwStatus);
            TRACE_CRIT("%!FUNC! invalid handle opening \\\\.\\WLBS device. Error is %d", dwStatus);
            return HRESULT_FROM_WIN32(dwStatus);
        }
        
        ASSERT(m_hDeviceWlbs != INVALID_HANDLE_VALUE);
    }

    for (iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL)
		{
			dwStatus = pCluster->ApplyPnpChanges(m_hDeviceWlbs);
			if (ERROR_SUCCESS != dwStatus)
			{
                TRACE_CRIT("%!FUNC! apply pnp changes on CNetcfgCluster failed with %d", dwStatus);
			}
		}
		else
		{
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster");
		}
    }

    if (m_hDeviceWlbs != INVALID_HANDLE_VALUE)
	{
		if (!CloseHandle(m_hDeviceWlbs))
		{
			dwStatus = GetLastError();
            TRACE_CRIT("%!FUNC! close nlb device handle failed with %d", dwStatus);
		}
	}

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::QueryBindingPath(DWORD dwChangeFlag, INetCfgComponent* pAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::QueryBindingPath");

    ASSERT_VALID(this);

    TRACE_VERB("<-%!FUNC!");
    return NETCFG_S_DISABLE_QUERY;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::NotifyBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::NotifyBindingPath");

    HRESULT hr = S_OK;
    INetCfgComponent * pAdapter;
    PWSTR pszInterfaceName;
    GUID AdapterGuid;
	DWORD dwStatus = 0;

    ASSERT_VALID(this);

    if (m_pWlbsComponent == NULL && FAILED(m_pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
		dwStatus = GetLastError();
        TraceError("NotifyBindingPath failed at INetCfg::FindComponent\n", dwStatus);
        TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return S_FALSE;
    }

    hr = HrGetLastComponentAndInterface (pncbp, &pAdapter, &pszInterfaceName);

    if (FAILED(hr))
    {
        TRACE_CRIT("%!FUNC! enumerating binding path failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    CoTaskMemFree(pszInterfaceName);

    hr = pAdapter->GetInstanceGuid(&AdapterGuid);

    pAdapter->Release();
    pAdapter = NULL;

    if (FAILED(hr))
    {
        TRACE_CRIT("%!FUNC! retrieval of adapter guid from adapter failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL) {
        if (dwChangeFlag & NCN_ENABLE) {
            /* new configuration. */
            pCluster = new CNetcfgCluster(this);

            if (pCluster == NULL)
            {
                TRACE_CRIT("%!FUNC! memory allocation failure creating instance of CNetcfgCluster");
                TRACE_VERB("<-%!FUNC!");
                return E_OUTOFMEMORY;
            }

            pCluster->InitializeWithDefault(AdapterGuid); // Returns void

            m_vtrCluster.push_back(pCluster);
        } else {
            TraceMsg(L"CWlbsConfig::NotifyBindingPath adapter not bound");
            TRACE_INFO("%!FUNC! adapter is not bound");
            TRACE_VERB("<-%!FUNC!");
            return S_OK;
        }
    }

    pCluster->NotifyBindingChanges(dwChangeFlag, pncbp); // Returns void

    /* If we are enabling a binding path, then check for cluster IP address conflicts. */
    if (dwChangeFlag & NCN_ENABLE) {
        NETCFG_WLBS_CONFIG adapterConfig;
        
        /* Retrieve the cluster configuration. */
        pCluster->GetConfig(&adapterConfig); // Returns void
        
        /* If we detect another bound adapter with this cluster IP address, then revert this cluster's 
           cluster IP Address to the default value.  If the user opens the property dialog, they can
           change the IP address, but we CANNOT warn them here - this code can be run programmatically.
           However, because the user CAN bind NLB without opening the properties, we MUST check this here. */
        if ((hr = CheckForDuplicateCLusterIPAddresses(AdapterGuid, &adapterConfig)) != S_OK) {
            TRACE_CRIT("%!FUNC! another adapter is bound and has the same cluster IP address %ls. Status of check is %d", adapterConfig.cl_ip_addr, hr);
            /* Revert this cluster IP Address to the default (0.0.0.0). */
            lstrcpy(adapterConfig.cl_ip_addr, CVY_DEF_CL_IP_ADDR);
            
            /* Revert this cluster IP Address to the default (0.0.0.0). */
            lstrcpy(adapterConfig.cl_net_mask, CVY_DEF_CL_NET_MASK);
            
            /* Set the cluster configuration. */
            pCluster->SetConfig(&adapterConfig); // Returns void
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::GetCluster
//
// Description:  
//
// Arguments: const GUID& AdapterGuid - 
//
// Returns:   CNetcfgCluster* - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster* CWlbsConfig::GetCluster(const GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::GetCluster");

    ASSERT_VALID(this);

    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL) {
            if (IsEqualGUID(pCluster->GetAdapterGuid(), AdapterGuid))
            {
                TRACE_INFO("%!FUNC! cluster instance found");
                TRACE_VERB("<-%!FUNC!");
                return pCluster;
            }
        }
		else
		{
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster. Skipping it.");
		}
    }

    TRACE_INFO("%!FUNC! cluster instance not found");
    TRACE_VERB("<-%!FUNC!");
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::IsBoundTo
//
// Description:  
//
// Arguments: INetCfgComponent* pAdapter - 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
HRESULT CWlbsConfig::IsBoundTo(INetCfgComponent* pAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::IsBoundTo");

    HRESULT hr;

    ASSERT_VALID(this);
    ASSERT(pAdapter != NULL);

    if (m_pWlbsComponent == NULL) {
        TraceMsg(L"CWlbsConfig::IsBoundTo wlbs not installed");
        TRACE_INFO("%!FUNC! nlb is not installed");
        TRACE_VERB("<-%!FUNC!");
        return S_FALSE;
    }

    INetCfgComponentBindings *pIBinding = NULL;

    if (FAILED(m_pWlbsComponent->QueryInterface(IID_INetCfgComponentBindings, (void**)&pIBinding))) {
        DWORD dwStatus = GetLastError();
        TraceError("QI for INetCfgComponentBindings failed\n", dwStatus);
        TRACE_INFO("%!FUNC! QueryInterface on the nlb component object failed with %d", dwStatus);
    }

    if (FAILED(hr = pIBinding->IsBoundTo(pAdapter))) {
        TraceError("Failed to IsBoundTo", hr);
        TRACE_INFO("%!FUNC! the check whether nlb is bound to an adapter failed with %d", hr);
    }

    if (pIBinding) pIBinding->Release();

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::SetDefaults
//
// Description:  
//
// Arguments: NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
void CWlbsConfig::SetDefaults(NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::SetDefaults");

    WLBS_REG_PARAMS config;

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);
    ASSERT(m_pWlbsApiFuncs);
    ASSERT(m_pWlbsApiFuncs->pfnParamSetDefaults);

    DWORD dwStatus = m_pWlbsApiFuncs->pfnParamSetDefaults(&config);
	if (WLBS_OK != dwStatus)
	{
        TRACE_CRIT("%!FUNC! failed to set defaults for the cluster configuration");
	}

    WlbsToNetcfgConfig(m_pWlbsApiFuncs, &config, pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
}

/*
 * Function: CWlbsConfig::ValidateProperties
 * Description: Check for conflicting cluster IP addresses and alert the user.
 * Author: shouse 7.13.00
 */
STDMETHODIMP CWlbsConfig::ValidateProperties (HWND hwndSheet, GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ValidateProperties");

    HRESULT hr = S_OK;

    ASSERT_VALID(this);

    /* If we detect another bound adapter with this cluster IP address, then fail the check and 
       pop-up an error message warning the user that there are conflicting IP addresses. */
    if ((hr = CheckForDuplicateCLusterIPAddresses(adapterGUID, adapterConfig)) != S_OK)
	{
        NcMsgBox(hwndSheet, IDS_PARM_ERROR, IDS_PARM_MULTINIC_IP_CONFLICT, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        TRACE_CRIT("%!FUNC! another network adapter is using IP address %ls", adapterConfig->cl_ip_addr);
	}

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

/*
 * Function: CWlbsConfig::CheckForDuplicateCLusterIPAddresses
 * Description: Loop through all adapters and check for conflicting cluster IP addresses.
 * Author: shouse 7.13.00
 */
STDMETHODIMP CWlbsConfig::CheckForDuplicateCLusterIPAddresses (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::CheckForDuplicateCLusterIPAddresses");

    CNetcfgCluster * pClusterMe = NULL;

    ASSERT_VALID(this);

    /* Get the cluster pointer for this adapter GUID. */
    pClusterMe = GetCluster(adapterGUID);

    ASSERT(pClusterMe);
    if (!pClusterMe)
    {
        TRACE_INFO("%!FUNC! no cluster instance was found for the supplied adapter");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* If the cluster IP address is the default, then don't check other adapters because
       if they have not been configured yet, this may cause confusion for the user.  We 
       will ignore the error here and other validation in the cluster properties should
       catch this error instead. */
    if (!lstrcmpi(adapterConfig->cl_ip_addr, CVY_DEF_CL_IP_ADDR))
    {
        TRACE_INFO("%!FUNC! the adapter config is using the default cluster IP address. No checking needed.");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* Loop through the rest of the list and check this cluster IP against the cluster
       IP of each adapter left in the list. */
    for (vector<CNetcfgCluster *>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster * pCluster = *iter;

        ASSERT(pCluster);
        if (!pCluster)
        {
            /* CLD: 05.17.01 is this a no op or do we store nulls in the vector? */
            TRACE_INFO("%!FUNC! Found NULL pointer to a CNetcfgCluster. No further checking needed.");
            TRACE_VERB("<-%!FUNC!");
            return S_OK;
        }

        /* Obviously, don't check against myself. */
        if (pClusterMe == pCluster) continue;

        /* If we find a match, report and error and do not allow the dialog to close. */
        if (pCluster->CheckForDuplicateClusterIPAddress(adapterConfig->cl_ip_addr)) 
        {
            TRACE_INFO("%!FUNC! duplicate cluster IP address found.");
            TRACE_VERB("<-%!FUNC!");
            return S_FALSE;
        }
    }
    
    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsToNetcfgConfig
//
// Description:  
//
// Arguments: const WLBS_REG_PARAMS* pWlbsConfig - 
//            NETCFG_WLBS_CONFIG* pNetcfgConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
void WlbsToNetcfgConfig(const WlbsApiFuncs* pWlbsApiFuncs, const WLBS_REG_PARAMS* pWlbsConfig, NETCFG_WLBS_CONFIG* pNetcfgConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"WlbsToNetcfgConfig");

    ASSERT(pNetcfgConfig != NULL);
    ASSERT(pWlbsConfig != NULL);
    ASSERT(pWlbsApiFuncs);
    ASSERT(pWlbsApiFuncs->pfnWlbsEnumPortRules);

    pNetcfgConfig->dwHostPriority = pWlbsConfig->host_priority;
    pNetcfgConfig->fRctEnabled = (pWlbsConfig->rct_enabled != FALSE);
    pNetcfgConfig->fJoinClusterOnBoot = (pWlbsConfig->cluster_mode != FALSE);
    pNetcfgConfig->fMcastSupport = (pWlbsConfig->mcast_support != FALSE);
    pNetcfgConfig->fIGMPSupport = (pWlbsConfig->fIGMPSupport != FALSE);
    pNetcfgConfig->fIpToMCastIp = (pWlbsConfig->fIpToMCastIp != FALSE);
    pNetcfgConfig->fConvertMac = (pWlbsConfig->i_convert_mac != FALSE);
    pNetcfgConfig->dwMaxHosts = pWlbsConfig->i_max_hosts;
    pNetcfgConfig->dwMaxRules = pWlbsConfig->i_max_rules;

    lstrcpy(pNetcfgConfig->szMCastIpAddress, pWlbsConfig->szMCastIpAddress);
    lstrcpy(pNetcfgConfig->cl_mac_addr, pWlbsConfig->cl_mac_addr);
    lstrcpy(pNetcfgConfig->cl_ip_addr, pWlbsConfig->cl_ip_addr);
    lstrcpy(pNetcfgConfig->cl_net_mask, pWlbsConfig->cl_net_mask);
    lstrcpy(pNetcfgConfig->ded_ip_addr, pWlbsConfig->ded_ip_addr);
    lstrcpy(pNetcfgConfig->ded_net_mask, pWlbsConfig->ded_net_mask);
    lstrcpy(pNetcfgConfig->domain_name, pWlbsConfig->domain_name);

    pNetcfgConfig->fChangePassword =false;
    pNetcfgConfig->szPassword[0] = L'\0';

    ZeroMemory(pNetcfgConfig->port_rules, sizeof(pNetcfgConfig->port_rules));

    WLBS_PORT_RULE PortRules[WLBS_MAX_RULES];
    DWORD dwNumRules = WLBS_MAX_RULES;

    if (pWlbsApiFuncs->pfnWlbsEnumPortRules((WLBS_REG_PARAMS*)pWlbsConfig, PortRules,  &dwNumRules)!= WLBS_OK) {
        DWORD dwStatus = GetLastError();
        TraceError("CNetcfgCluster::GetConfig failed at WlbsEnumPortRules", dwStatus);
        TRACE_CRIT("%!FUNC! api call to enumerate port rules failed with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    ASSERT(dwNumRules <= WLBS_MAX_RULES);
    pNetcfgConfig->dwNumRules = dwNumRules; 

    for (DWORD i=0; i<dwNumRules; i++) {
        lstrcpy(pNetcfgConfig->port_rules[i].virtual_ip_addr, PortRules[i].virtual_ip_addr);
        pNetcfgConfig->port_rules[i].start_port = PortRules[i].start_port;
        pNetcfgConfig->port_rules[i].end_port = PortRules[i].end_port;
        pNetcfgConfig->port_rules[i].mode = PortRules[i].mode;
        pNetcfgConfig->port_rules[i].protocol = PortRules[i].protocol;

        if (pNetcfgConfig->port_rules[i].mode == WLBS_AFFINITY_SINGLE) {
            pNetcfgConfig->port_rules[i].mode_data.single.priority = 
            PortRules[i].mode_data.single.priority;
        } else {
            pNetcfgConfig->port_rules[i].mode_data.multi.equal_load = 
            PortRules[i].mode_data.multi.equal_load;
            pNetcfgConfig->port_rules[i].mode_data.multi.affinity = 
            PortRules[i].mode_data.multi.affinity;
            pNetcfgConfig->port_rules[i].mode_data.multi.load = 
            PortRules[i].mode_data.multi.load;
        }

    }
}

#if DBG
void TraceMsg(PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    vswprintf(szTempBufW, pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, 4096, NULL, NULL);
    
    /* Traced messages are now sent through the netcfg TraceTag routine so that 
       they can be turned on/off dynamically. */
    TraceTag(ttidWlbs, szTempBufA);

    va_end(arglist);
}
#endif


#ifdef DEBUG
void CWlbsConfig::AssertValid() {
    ASSERT(m_ServiceOperation >= WLBS_SERVICE_NONE && m_ServiceOperation <= WLBS_SERVICE_UPGRADE);
    ASSERT(m_pNetCfg != NULL);
    ASSERT(m_hdllWlbsCtrl != NULL);
    ASSERT(m_pWlbsApiFuncs != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnParamReadReg != NULL); 
    ASSERT (m_pWlbsApiFuncs->pfnParamWriteReg != NULL); 
    ASSERT (m_pWlbsApiFuncs->pfnParamDeleteReg != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnParamSetDefaults != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnRegChangeNetworkAddress != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnNotifyAdapterAddressChange != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsAddPortRule != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsSetRemotePassword != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsEnumPortRules != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnNotifyDriverConfigChanges != NULL);
    ASSERT(m_vtrCluster.size()<=128);
}    
#endif

//+----------------------------------------------------------------------------
//
// Function:  ParamReadAnswerFile
//
// Description:  
//
// Arguments: CWSTR         answer_file - 
//            PCWSTR         answer_sections - 
//            WLBS_REG_PARAMS*     paramp - 
//
// Returns:   HRESULT - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
HRESULT ParamReadAnswerFile(CSetupInfFile& caf, PCWSTR answer_sections, WLBS_REG_PARAMS* paramp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"ParamReadAnswerFile");

    HRESULT hr = S_OK;
    tstring str;
    DWORD dword;
    ULONG i, code;
    PWLBS_PORT_RULE rp;
    INFCONTEXT ctx;
    PWCHAR port_str;

    hr = caf.HrGetDword(answer_sections, CVY_NAME_VERSION, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_parms_ver = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_HOST_PRIORITY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> host_priority = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CLUSTER_MODE, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> cluster_mode = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_NETWORK_ADDR, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> cl_mac_addr, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> cl_mac_addr) - sizeof (WCHAR) ?
                sizeof (paramp -> cl_mac_addr) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_NETWORK_ADDR, paramp -> cl_mac_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_NETWORK_ADDR, paramp -> cl_mac_addr);
    }
	else
	{
        if (NULL != str.c_str())
		{
			TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %ls", CVY_NAME_NETWORK_ADDR, str.c_str());
		} else {
			TRACE_CRIT("%!FUNC! failed reading %ls. String was not retrieved", CVY_NAME_NETWORK_ADDR);
		}
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_CL_IP_ADDR, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> cl_ip_addr, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> cl_ip_addr) - sizeof (WCHAR) ?
                sizeof (paramp -> cl_ip_addr) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_CL_IP_ADDR, paramp -> cl_ip_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_CL_IP_ADDR, paramp -> cl_ip_addr);
    }
	else
	{
		TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_CL_IP_ADDR);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_CL_NET_MASK, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> cl_net_mask, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> cl_net_mask) - sizeof (WCHAR) ?
                sizeof (paramp -> cl_net_mask) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_CL_NET_MASK, paramp -> cl_net_mask);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_CL_NET_MASK, paramp -> cl_net_mask);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_CL_NET_MASK);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_DED_IP_ADDR, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> ded_ip_addr, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> ded_ip_addr) - sizeof (WCHAR) ?
                sizeof (paramp -> ded_ip_addr) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DED_IP_ADDR, paramp -> ded_ip_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DED_IP_ADDR, paramp -> ded_ip_addr);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls", CVY_NAME_DED_IP_ADDR);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_DED_NET_MASK, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> ded_net_mask, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> ded_net_mask) - sizeof (WCHAR) ?
                sizeof (paramp -> ded_net_mask) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DED_NET_MASK, paramp -> ded_net_mask);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DED_NET_MASK, paramp -> ded_net_mask);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_DED_NET_MASK);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_DOMAIN_NAME, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> domain_name, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> domain_name) - sizeof (WCHAR) ?
                sizeof (paramp -> domain_name) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DOMAIN_NAME, paramp -> domain_name);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DOMAIN_NAME, paramp -> domain_name);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_DOMAIN_NAME);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ALIVE_PERIOD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> alive_period = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ALIVE_TOLER, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> alive_tolerance = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_ACTIONS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_actions = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_PACKETS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_packets = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_SEND_MSGS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_send_msgs = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_DSCR_PER_ALLOC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> dscr_per_alloc = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MAX_DSCR_ALLOCS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> max_dscr_allocs = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_SCALE_CLIENT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_scale_client = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CLEANUP_DELAY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_cleanup_delay = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NBT_SUPPORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_nbt_support = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MCAST_SUPPORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> mcast_support = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MCAST_SPOOF, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_mcast_spoof = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MASK_SRC_MAC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> mask_src_mac = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NETMON_ALIVE, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_netmon_alive = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_IP_CHG_DELAY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_ip_chg_delay = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CONVERT_MAC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_convert_mac = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_LICENSE_KEY, & str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp -> i_license_key, str.c_str(), wcslen(str.c_str()) > sizeof (paramp -> i_license_key) - sizeof (WCHAR) ?
                sizeof (paramp -> i_license_key) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_LICENSE_KEY, paramp -> i_license_key);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_LICENSE_KEY, paramp -> i_license_key);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_LICENSE_KEY);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RMT_PASSWORD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_rmt_password = dword;
        TRACE_VERB("%!FUNC! read %ls %x", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %x\n", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %x", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_PASSWORD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_rct_password = dword;
        TRACE_VERB("%!FUNC! read %ls %x", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %x\n", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %x", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_PORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> rct_port = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_RCT_PORT, paramp -> rct_port);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_RCT_PORT, paramp -> rct_port);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_RCT_PORT, paramp -> rct_port);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_ENABLED, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> rct_enabled = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_PASSWORD, & str);

    if (SUCCEEDED(hr)) {
        WCHAR passw [LICENSE_STR_IMPORTANT_CHARS + 1];

        wcsncpy(passw, str.c_str(), wcslen(str.c_str()) > sizeof (passw) - sizeof (WCHAR) ?
                sizeof (passw) - sizeof (WCHAR) : wcslen(str.c_str()) + 1);

        paramp -> i_rct_password = License_wstring_encode (passw);

        TRACE_VERB("%!FUNC! read %ls %ls %x", CVY_NAME_PASSWORD, passw, paramp -> i_rct_password);
        TraceMsg(TEXT("#### ParamReadAnswerFile read %ls %ls %x\n"), CVY_NAME_PASSWORD, passw, paramp -> i_rct_password);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_PASSWORD);
	}

    /* IGMP support. */
    hr = caf.HrGetDword(answer_sections, CVY_NAME_IGMP_SUPPORT, &dword);

    if (SUCCEEDED(hr)) {
        paramp->fIGMPSupport = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_IP_TO_MCASTIP, &dword);

    if (SUCCEEDED(hr)) {
        paramp->fIpToMCastIp = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
	}

    hr = caf.HrGetString(answer_sections, CVY_NAME_MCAST_IP_ADDR, &str);

    if (SUCCEEDED(hr)) {
        wcsncpy(paramp->szMCastIpAddress, str.c_str(), wcslen(str.c_str()) > sizeof(paramp->szMCastIpAddress) - sizeof(WCHAR) ?
                sizeof(paramp->szMCastIpAddress) - sizeof(WCHAR) : wcslen(str.c_str()) + 1);
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_MCAST_IP_ADDR, paramp->szMCastIpAddress);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_MCAST_IP_ADDR, paramp->szMCastIpAddress);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_MCAST_IP_ADDR);
	}
    /* End IGMP support. */

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(), answer_sections, CVY_NAME_PORTS, & port_str);

    if (SUCCEEDED(hr)) {
        PWCHAR ptr;
        PWLBS_PORT_RULE rp, rulep;

        /* distinct rule elements for parsing */

        typedef enum
        {
            vip,
            start,
            end,
            protocol,
            mode,
            affinity,
            load,
            priority
        }
        CVY_RULE_ELEMENT;

        CVY_RULE_ELEMENT elem = vip;
        DWORD count = 0;
        DWORD i;
        DWORD dwVipLen = 0;
        const DWORD dwVipAllNameLen = sizeof(CVY_NAME_PORTRULE_VIPALL)/sizeof(WCHAR) - 1; // Used below in a loop. Set it here since it is a constant.
        WCHAR wszTraceOutputTmp[WLBS_MAX_CL_IP_ADDR + 1];
        bool bFallThrough = false; // Used in 'vip' case statement below.

        ptr = port_str;

        TRACE_VERB("%!FUNC! %ls", ptr);
        TraceMsg(L"%ls\n", ptr);

        while (!(*ptr == 0 && *(ptr+1) == 0)) {
            if (*ptr == 0) {
                *ptr = L',';
                TRACE_VERB("%!FUNC! %ls", ptr);
                TraceMsg(L"%ls\n", ptr);
            }

            ptr++;
        }

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_PORTS, port_str);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_PORTS, port_str);

        rulep = paramp->i_port_rules;
        ptr = port_str;

        while (ptr != NULL) {
            switch (elem) {
                case vip:
                    // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME BEFORE THE 'start' CASE STATEMENT. See FALLTHROUGH comment below.
                    bFallThrough = false;
                    dwVipLen = 0;
                    if (ValidateVipInRule(ptr, L',', dwVipLen))
                    {
                        ASSERT(dwVipLen <= WLBS_MAX_CL_IP_ADDR);

                        // rulep->virtual_ip_addr is a TCHAR and ptr is a WCHAR.
                        // Data is moved from the latter to the former so ASSERT TCHAR is WCHAR.
                        ASSERT(sizeof(TCHAR) == sizeof(WCHAR));

                        // This is a rule for a specific VIP
                        _tcsncpy(rulep->virtual_ip_addr, ptr, dwVipLen);
                        (rulep->virtual_ip_addr)[dwVipLen] = '\0';
                    }
                    else
                    {
                        // This is either an 'all' rule, a VIP-less rule or a malformed rule. We can't distinguish a malformed rule
                        // from a VIP-less rule, so we will assume the rule is either an 'all' rule or a VIP-less rule. In both cases
                        // set the VIP component of the rule to be the default or 'all' value.

                        // Copy the 'all' IP into the rule.
                        _tcscpy(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP);

                        if (dwVipAllNameLen != dwVipLen || (_tcsnicmp(ptr, CVY_NAME_PORTRULE_VIPALL, dwVipAllNameLen) != 0))
                        {
                            // The rule is either VIP-less or it is malformed. We assume it is VIP-less and let the 'start'
                            // case handle the current token as a start_port property by falling through to the next case clause
                            // rather than breaking.
                            bFallThrough = true;

                            _tcsncpy(wszTraceOutputTmp, ptr, dwVipLen);
                            wszTraceOutputTmp[dwVipLen] = '\0';
                            TRACE_VERB("%!FUNC! VIP element of port rule is invalid = %ls", wszTraceOutputTmp);
                            TraceMsg(L"-----\n#### VIP element of port rule is invalid = %s\n", wszTraceOutputTmp);
                        }
                    }
                    TRACE_VERB("%!FUNC! Port rule vip = %ls", rulep->virtual_ip_addr);
                    TraceMsg(L"-----\n#### Port rule vip = %s\n", rulep->virtual_ip_addr);
                    
                    elem = start;
                    // !!!!!!!!!!!!!!!!!!!!
                    // FALLTHROUGH
                    // !!!!!!!!!!!!!!!!!!!!
                    // When we have a VIP-less port rule, we will fall through this case statement into the 'start' case statement
                    // below so that the current token can be used as the start_port for a port rule.
                    if (!bFallThrough)
                    {
                        // We have a VIP in the port rule. We do a "break;" as std operating procedure.
                        TRACE_VERB("%!FUNC! Fallthrough case statement from port rule vip to start");
                        TraceMsg(L"-----\n#### Fallthrough case statement from port rule vip to start\n");
                        break;
                    }
                    // NO AUTOMATIC "break;" STATEMENT HERE. Above, we conditionally flow to the 'start' case...
                case start:
                    // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME AFTER THE 'vip' CASE STATEMENT.
                    // See comments (FALLTHROUGH) inside the 'vip' case statement.
                    rulep->start_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->start_port, CVY_MIN_PORT);
                    CVY_CHECK_MAX (rulep->start_port, CVY_MAX_PORT);
                    TRACE_VERB("%!FUNC! Start port   = %d", rulep->start_port);
                    TraceMsg(L"-----\n#### Start port   = %d\n", rulep->start_port);
                    elem = end;
                    break;
                case end:
                    rulep->end_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->end_port, CVY_MIN_PORT);
                    CVY_CHECK_MAX (rulep->end_port, CVY_MAX_PORT);
                    TRACE_VERB("%!FUNC! End port     = %d", rulep->end_port);
                    TraceMsg(L"#### End port     = %d\n", rulep->end_port);
                    elem = protocol;
                    break;
                case protocol:
                    switch (ptr [0]) {
                        case L'T':
                        case L't':
                            rulep->protocol = CVY_TCP;
                            TRACE_VERB("%!FUNC! Protocol     = TCP");
                            TraceMsg(L"#### Protocol     = TCP\n");
                            break;
                        case L'U':
                        case L'u':
                            rulep->protocol = CVY_UDP;
                            TRACE_VERB("%!FUNC! Protocol     = UDP");
                            TraceMsg(L"#### Protocol     = UDP\n");
                            break;
                        default:
                            rulep->protocol = CVY_TCP_UDP;
                            TRACE_VERB("%!FUNC! Protocol     = Both");
                            TraceMsg(L"#### Protocol     = Both\n");
                            break;
                    }

                    elem = mode;
                    break;
                case mode:
                    switch (ptr [0]) {
                        case L'D':
                        case L'd':
                            rulep->mode = CVY_NEVER;
                            TRACE_VERB("%!FUNC! Mode         = Disabled");
                            TraceMsg(L"#### Mode         = Disabled\n");
                            goto end_rule;
                        case L'S':
                        case L's':
                            rulep->mode = CVY_SINGLE;
                            TRACE_VERB("%!FUNC! Mode         = Single");
                            TraceMsg(L"#### Mode         = Single\n");
                            elem = priority;
                            break;
                        default:
                            rulep->mode = CVY_MULTI;
                            TRACE_VERB("%!FUNC! Mode         = Multiple");
                            TraceMsg(L"#### Mode         = Multiple\n");
                            elem = affinity;
                            break;
                    }
                    break;
                case affinity:
                    switch (ptr [0]) {
                        case L'C':
                        case L'c':
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_CLASSC;
                            TRACE_VERB("%!FUNC! Affinity     = Class C");
                            TraceMsg(L"#### Affinity     = Class C\n");
                            break;
                        case L'N':
                        case L'n':
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_NONE;
                            TRACE_VERB("%!FUNC! Affinity     = None");
                            TraceMsg(L"#### Affinity     = None\n");
                            break;
                        default:
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_SINGLE;
                            TRACE_VERB("%!FUNC! Affinity     = Single");
                            TraceMsg(L"#### Affinity     = Single\n");
                            break;
                    }

                    elem = load;
                    break;
                case load:
                    if (ptr [0] == L'E' || ptr [0] == L'e') {
                        rulep->mode_data.multi.equal_load = TRUE;
                        rulep->mode_data.multi.load       = CVY_DEF_LOAD;
                        TRACE_VERB("%!FUNC! Load         = Equal");
                        TraceMsg(L"#### Load         = Equal\n");
                    } else {
                        rulep->mode_data.multi.equal_load = FALSE;
                        rulep->mode_data.multi.load       = _wtoi(ptr);
//                        CVY_CHECK_MIN (rulep->mode_data.multi.load, CVY_MIN_LOAD);
                        CVY_CHECK_MAX (rulep->mode_data.multi.load, CVY_MAX_LOAD);
                        TRACE_VERB("%!FUNC! Load         = %d", rulep->mode_data.multi.load);
                        TraceMsg(L"#### Load         = %d\n", rulep->mode_data.multi.load);
                    }
                    goto end_rule;
                case priority:
                    rulep->mode_data.single.priority = _wtoi(ptr);
                    CVY_CHECK_MIN (rulep->mode_data.single.priority, CVY_MIN_PRIORITY);
                    CVY_CHECK_MAX (rulep->mode_data.single.priority, CVY_MAX_PRIORITY);
                    TRACE_VERB("%!FUNC! Priority     = %d", rulep->mode_data.single.priority);
                    TraceMsg(L"#### Priority     = %d\n", rulep->mode_data.single.priority);
                    goto end_rule;
                default:
                    TRACE_VERB("%!FUNC! Bad rule element %d", elem);
                    TraceMsg(L"#### Bad rule element %d\n", elem);
                    break;
            }

        next_field:

            ptr = wcschr(ptr, L',');

            if (ptr != NULL) {
                ptr ++;
                continue;
            } else break;

        end_rule:

            elem = vip;

            for (i = 0; i < count; i ++) {
                rp = paramp->i_port_rules + i;

                if ((rulep -> start_port < rp -> start_port &&
                     rulep -> end_port >= rp -> start_port) ||
                    (rulep -> start_port >= rp -> start_port &&
                     rulep -> start_port <= rp -> end_port)) {
                    TRACE_VERB("%!FUNC! Rule %d (%d - %d) overlaps with rule %d (%d - %d)", i, rp -> start_port, rp -> end_port, count, rulep -> start_port, rulep -> end_port);
                    TraceMsg(L"#### Rule %d (%d - %d) overlaps with rule %d (%d - %d)\n", i, rp -> start_port, rp -> end_port, count, rulep -> start_port, rulep -> end_port);
                    break;
                }
            }

            rulep -> valid = TRUE;
            CVY_RULE_CODE_SET (rulep);

            if (i >= count) {
                count++;
                rulep++;

                if (count >= CVY_MAX_RULES) break;
            }

            goto next_field;
        }

        TRACE_VERB("%!FUNC! Port rules   = %d", count);
        TraceMsg(L"-----\n#### Port rules   = %d\n", count);
        paramp->i_num_rules = count;

        delete [] port_str;
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_MCAST_IP_ADDR);
	}

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_RULES, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_num_rules = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
    }
	else
	{
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
	}

    WLBS_OLD_PORT_RULE  old_port_rules [WLBS_MAX_RULES];

    hr = HrSetupFindFirstLine (caf.Hinf(), answer_sections, CVY_NAME_OLD_PORT_RULES, & ctx);

    if (SUCCEEDED(hr)) {
        // hr = HrSetupGetBinaryField (ctx, 1, (PBYTE) paramp -> i_port_rules, sizeof (paramp -> i_port_rules), & dword);
        hr = HrSetupGetBinaryField (ctx, 1, (PBYTE) old_port_rules, sizeof (old_port_rules), & dword);

        if (SUCCEEDED(hr)) {
            TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_OLD_PORT_RULES, dword);
            TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_OLD_PORT_RULES, dword);

            if (dword % sizeof (WLBS_OLD_PORT_RULE) != 0 ||
                paramp -> i_num_rules != dword / sizeof (WLBS_OLD_PORT_RULE)) {
                TRACE_VERB("%!FUNC! bad port rules length %d %d %d", paramp -> i_num_rules, sizeof (WLBS_OLD_PORT_RULE), dword);
                TraceMsg(L"#### ParamReadAnswerFile bad port rules length %d %d %d\n", paramp -> i_num_rules, sizeof (WLBS_OLD_PORT_RULE), dword),
                paramp -> i_num_rules = 0;
            }
            else // Convert the port rules to new format
            {
                if (paramp -> i_parms_ver > 3) 
                {
                    TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules); // Returns void
                    TRACE_INFO("%!FUNC! transformed binary port rules to current format");
                }
				else
				{
                    TRACE_INFO("%!FUNC! will not transform port rules to current format because param version is <=3: %d", paramp -> i_parms_ver);
				}
            }
        }
		else
		{
            paramp -> i_num_rules = 0;
            TRACE_CRIT("%!FUNC! failed retrieve of binary port rules %ls while reading %d", CVY_NAME_OLD_PORT_RULES, dword);
		}
    }
    else // Did the answer file contain port rules in the non-binary form and ParametersVersion <= 3 ?
    {
        if ((paramp -> i_parms_ver <= 3) && (paramp -> i_num_rules > 0))
        {
            TRACE_VERB("%!FUNC! Answer file contains port rules in the non-binary format and yet the version number is <=3, Assuming default port rule");
            TraceMsg(L"#### ParamReadAnswerFile Answer file contains port rules in the non-binary format and yet the version number is <=3, Assuming default port rule\n");
            paramp -> i_num_rules = 0;
        }
    }

    /* decode port rules prior to version 3 */
    if (paramp -> i_parms_ver <= 3) {
        TRACE_VERB("%!FUNC! converting port rules from version <= 3");
        TraceMsg(L"#### ParamReadAnswerFile converting port rules from version 3\n");

        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* decode the port rules */

        if (paramp -> i_num_rules > 0)
        {
            if (! License_data_decode ((PCHAR) old_port_rules, paramp -> i_num_rules * sizeof (WLBS_OLD_PORT_RULE))) 
            {
                paramp -> i_num_rules = 0;
                TRACE_CRIT("%!FUNC! license data decode failed. Port rules will not be converted to new format.");
            }
            else
			{
                TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);
                TRACE_INFO("%!FUNC! transformed port rules to current format. Old port rule version = %d", paramp -> i_parms_ver);
			}
        }
		else
		{
            TRACE_INFO("%!FUNC! there were no port rules to transform");
		}
    }

    /* upgrade port rules from params V1 to params V2 */

    if (paramp -> i_parms_ver == 1) {
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        TRACE_VERB("%!FUNC! converting from version 1");
        TraceMsg(L"#### ParamReadAnswerFile converting from version 1\n");

        /* keep multicast off by default for old users */

        paramp -> mcast_support = FALSE;

        for (i = 0; i < paramp -> i_num_rules; i ++) {
            rp = paramp -> i_port_rules + i;

            code = CVY_RULE_CODE_GET (rp);

            CVY_RULE_CODE_SET (rp);

            if (code != CVY_RULE_CODE_GET (rp)) {
                rp -> code = code;
                TRACE_INFO("%!FUNC! (early exit) port rule %d transformed to current version from version 1", i);
                continue;
            }

            if (! rp -> valid) {
                TRACE_CRIT("%!FUNC! port rule %d (version 1 format) is not valid and will be skipped", i);
                continue;
            }

            /* set affinity according to current ScaleSingleClient setting */

            if (rp -> mode == CVY_MULTI)
                rp -> mode_data . multi . affinity = CVY_AFFINITY_SINGLE - paramp -> i_scale_client;

            CVY_RULE_CODE_SET (rp);
            TRACE_INFO("%!FUNC! port rule %d transformed to current version from version 1", i);
        }
    }

    /* upgrade max number of descriptor allocs */

    if (paramp -> i_parms_ver == 2) {
        TRACE_VERB("%!FUNC! upgrading descriptor settings from version 2 parameters to current");
        TraceMsg(L"#### ParamReadAnswerFile converting port rules from version 2\n");

        paramp -> i_parms_ver = CVY_PARAMS_VERSION;
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
        paramp -> dscr_per_alloc  = CVY_DEF_DSCR_PER_ALLOC;
    }

    paramp -> i_max_hosts        = CVY_MAX_HOSTS;
    paramp -> i_max_rules        = CVY_MAX_USABLE_RULES;

//    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);
    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    TRACE_VERB("<-%!FUNC!");
    return S_OK;

}

//+----------------------------------------------------------------------------
//
// Function:  RemoveAllPortRules
//
// Description:  Remove all port rules from PWLBS_REG_PARAMS
//
// Arguments: PWLBS_REG_PARAMS reg_data - 
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
void RemoveAllPortRules(PWLBS_REG_PARAMS reg_data) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"RemoveAllPortRules");

    reg_data -> i_num_rules = 0;

    ZeroMemory(reg_data -> i_port_rules, sizeof(reg_data -> i_port_rules));
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  GetAdapterFromGuid
//
// Description:  
//
// Arguments: INetCfg *pNetCfg - 
//            const GUID& NetCardGuid - 
//            OUT INetCfgComponent** ppNetCardComponent - 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    1/21/00
//
//+----------------------------------------------------------------------------
HRESULT GetAdapterFromGuid(INetCfg *pNetCfg, const GUID& NetCardGuid, OUT INetCfgComponent** ppNetCardComponent) {
    TRACE_VERB("->%!FUNC!");

    *ppNetCardComponent = NULL;
    HRESULT hr = S_OK;
    INetCfgClass *pNetCfgClass = NULL;
    BOOL fFoundMatch = FALSE;

    hr = pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET, IID_INetCfgClass, (void **)&pNetCfgClass);

    if (FAILED(hr)) {
        TraceError("INetCfg::QueryNetCfgClass failed", hr);
        TRACE_CRIT("%!FUNC! QueryNetCfgClass failed with %d", hr);
        return hr; 
    }

    /* Get an enumerator to list all network devices. */
    IEnumNetCfgComponent *pIEnumComponents = NULL;

    if (FAILED(hr = pNetCfgClass->EnumComponents(&pIEnumComponents))) {
        TraceError("INetCfg::EnumComponents failed", hr);
        TRACE_CRIT("%!FUNC! failed enumerating components with %d", hr);
        pNetCfgClass->Release();
        return hr;
    }

    /* Go through all the components and bind to the matching netcard. */
    while (pIEnumComponents->Next(1, ppNetCardComponent, NULL) == S_OK) {
        GUID guidInstance; 

        /* Retrieve the instance GUID of the component. */
        if (FAILED(hr = (*ppNetCardComponent)->GetInstanceGuid(&guidInstance))) {
            TraceError("GetInstanceGuid failed", hr);
            TRACE_CRIT("%!FUNC! getting instance guid from the net card failed with %d", hr);
            continue;
        }

        /* Check whether we found a match. */
        if (IsEqualGUID(NetCardGuid, guidInstance)) {
            fFoundMatch = TRUE; 
            TRACE_INFO("%!FUNC! netcard matched to component");
            break;
        }

        (*ppNetCardComponent)->Release();
        *ppNetCardComponent = NULL;
    }

    if (!fFoundMatch) {
        TraceMsg(L"Found no netcard\n");
        TRACE_CRIT("%!FUNC! no adapter found with the input GUID");
        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    if (pIEnumComponents) pIEnumComponents->Release();

    if (pNetCfgClass) pNetCfgClass->Release();

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteAdapterName
//
// Description:  
//
// Arguments: CWlbsConfig* pConfig - 
//            GUID& AdapterGuid - 
//
// Returns:   bool - 
//
// History: fengsun  Created Header    7/6/00
//
//+----------------------------------------------------------------------------
bool WriteAdapterName(CWlbsConfig* pConfig, GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");

    PWSTR pszPnpDevNodeId = NULL;
    HKEY key;
    DWORD status;
    HRESULT hr;

    INetCfgComponent* pAdapter = NULL;

    hr = GetAdapterFromGuid(pConfig->m_pNetCfg, AdapterGuid, &pAdapter);

    if (hr != S_OK) {
        TraceError("GetAdapterFromGuid failed at GetPnpDevNodeId", hr);
        TRACE_CRIT("%!FUNC! GetAdapterFromGuid failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId);

    pAdapter->Release();
    pAdapter = NULL;

    if (hr != S_OK) {
        TraceError("HrWriteAdapterName failed at GetPnpDevNodeId", hr);
        TRACE_CRIT("%!FUNC! GetPnpDevNodeId on adapter failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    key = pConfig->m_pWlbsApiFuncs->pfnRegOpenWlbsSetting(AdapterGuid, false);

    if (key == NULL) {
        status = GetLastError();
        TraceError("HrWriteAdapterName failed at RegOpenWlbsSetting", status);
        CoTaskMemFree(pszPnpDevNodeId);
        TRACE_CRIT("%!FUNC! RegOpenWlbsSetting failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    status = RegSetValueEx (key, CVY_NAME_CLUSTER_NIC, 0L, CVY_TYPE_CLUSTER_NIC, (LPBYTE) pszPnpDevNodeId, wcslen(pszPnpDevNodeId) * sizeof (WCHAR));

    CoTaskMemFree(pszPnpDevNodeId);

    RegCloseKey(key);

    if (status != ERROR_SUCCESS) {
        TraceError("HrWriteAdapterName failed at RegSetValueEx", status);
        TRACE_CRIT("%!FUNC! RegSetValueEx failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    TRACE_VERB("<-%!FUNC!");
    return true;
}

//+----------------------------------------------------------------------------
//
// Function:  ValidateVipInRule
//
// Description:  Parses pwszRuleString, looking for a valid VIP which must be
//               in the first token
//
// Arguments: PWCHAR pwszRuleString - tokenized string concatentating all
//                                    defined port rules
//            PWCHAR pwToken        - the token character that separates the fields
//            DWORD& dwVipLen       - if a token is found, this contains the size
//                                    of the string; 0 otherwise. The number of
//                                    characters returned is bound to <=
//                                    WLBS_MAX_CL_IP_ADDR
//
// NOTES:     A non-zero value for dwVipLen does NOT imply that the VIP is valid,
//            only that there was a non-zero length string in the expected
//            location. The user must check the return value to validate the VIP.
//
// Returns:   bool - true if the first field in the string has a valid IP address
//                   format; false otherwise.
//
// Assumptions: First token is the VIP element of a port rule
//
// History:   chrisdar  Created 01/05/15
//
//+----------------------------------------------------------------------------
bool ValidateVipInRule(const PWCHAR pwszRuleString, const WCHAR pwToken, DWORD& dwVipLen)
{
    TRACE_VERB("->%!FUNC!");
    ASSERT(NULL != pwszRuleString);

    bool ret = false;
    dwVipLen = 0;

    // Find the first occurence of the token string, which will denote the end of
    // the VIP part of the rule
    PWCHAR pwcAtSeparator = wcschr(pwszRuleString, pwToken);
    if (NULL == pwcAtSeparator) {
        TRACE_CRIT("%!FUNC! No token separator when one was expected");
        TRACE_VERB("<-%!FUNC!");
        return ret;
    }

    // Found the token string. Copy out the VIP and validate it.
    WCHAR wszIP[WLBS_MAX_CL_IP_ADDR + 1];
    DWORD dwStrLen = min((UINT)(pwcAtSeparator - pwszRuleString),
                         WLBS_MAX_CL_IP_ADDR);
    wcsncpy(wszIP, pwszRuleString, dwStrLen);
    wszIP[dwStrLen] = '\0';

    ASSERT(dwStrLen == wcslen(wszIP));

    dwVipLen = dwStrLen;

    // IpAddressFromAbcdWsz calls inet_addr to check the format of the IP address, but the
    // allowed formats are very flexible. For our port rule definition of a VIP we require
    // a rigid a.b.c.d format. To ensure that we only say the IP address is valid for IPs
    // specified in this manner, ensure that there are 3 and only 3 '.' in the string.
    DWORD dwTmpCount = 0;
    PWCHAR pwszTmp = pwszRuleString;
    while (pwszTmp < pwcAtSeparator)
    {
        if (*pwszTmp++ == L'.') { dwTmpCount++; }
    }
    if (dwTmpCount == 3 && INADDR_NONE != IpAddressFromAbcdWsz(wszIP)) {
        TRACE_INFO("%!FUNC! The IP address %ls is a valid IP of the form a.b.c.d", wszIP);
        ret = true;
    } else {
        TRACE_INFO("%!FUNC! The IP address %ls is NOT a valid IP of the form a.b.c.d", wszIP);
    }

    TRACE_VERB("<-%!FUNC!");
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\ports.cpp ===
/*++         
    
Copyright(c) 1998,99  Microsoft Corporation
    
Module Name:
    
ports.cpp
    
Abstract:
    
Windows Load Balancing Service (WLBS)
Notifier object UI - port rules config tab
    
Author:
    
kyrilf
shouse
    
--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"
#include "ports.h"
#include "utils.h"
#include <winsock.h>
#include "ports.tmh"

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

#define DIALOG_LIST_STRING_SIZE 80

/*
 * Method: CDialogPorts
 * Description: The class constructor.
 */
CDialogPorts::CDialogPorts (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::CDialogPorts\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rulesValid = FALSE;
    m_sort_column = WLBS_VIP_COLUMN;
    m_sort_order = WLBS_SORT_ASCENDING;
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: ~CDialogPorts
 * Description: The class destructor.
 */
CDialogPorts::~CDialogPorts () {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::~CDialogPorts\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the port rule properties dialog.
 */
LRESULT CDialogPorts::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnInitDialog\n");

    LV_COLUMN lvCol;
    RECT rect;

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* We are specifying the column format, text, and width. */
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;

    ::GetClientRect(GetDlgItem(IDC_LIST_PORT_RULE), &rect);
    int colWidth = (rect.right - 90)/(WLBS_NUM_COLUMNS - 2);

    /* Add all column headers to the port rule list box. */
    for (int index = 0; index < WLBS_NUM_COLUMNS; index++) {
        /* Set column configuration based on which column we're inserting. */
        switch (index) {
        case WLBS_VIP_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_VIP);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 100;
            break;
        case WLBS_PORT_START_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_START);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 43;
            break;
        case WLBS_PORT_END_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_END);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 43;
            break;
        case WLBS_PROTOCOL_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_PROT);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 51;
            break;
        case WLBS_MODE_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_MODE);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 53;
            break;
        case WLBS_PRIORITY_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_PRI);
            lvCol.fmt = LVCFMT_CENTER;
            lvCol.cx = 45;
            break;
        case WLBS_LOAD_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_LOAD);
            lvCol.fmt = LVCFMT_CENTER;
            lvCol.cx = 39;
            break;
        case WLBS_AFFINITY_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_AFF);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 47;
            break;
        }

        /* Insert the column into the listbox. */
        if (ListView_InsertColumn(GetDlgItem(IDC_LIST_PORT_RULE), index, &lvCol) != index) {
            TraceMsg(L"CDialogPorts::OnInitDialog Invalid item (%d) inserted into list view\n", index);
            TRACE_CRIT("%!FUNC! Invalid item (%d) inserted into list view", index);
            TRACE_VERB("<-%!FUNC!");
            return 0;
        }
    }

    /* Set the extended sytles: Full row selection (as opposed to the default of column one only)  */
    ListView_SetExtendedListViewStyleEx(GetDlgItem(IDC_LIST_PORT_RULE), LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogPorts::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogPorts::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the port rules tab becomes active (is clicked). 
 */
LRESULT CDialogPorts::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* If any port rules have been defined, "snap" the listbox to the first rule.
       If no rules currently exist, disable the MODIFY and DELETE buttons. */
    if (m_paramp->dwNumRules) {
        /* Select the first item in the port rule list. */
        ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    } else {
        /* Since there are no port rules defined, disable the Modify and Delete buttons. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);
        ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);
    }

    /* If the maximum number of port rules has already been defined, then disable the ADD button. */
    if (m_paramp->dwNumRules >= m_paramp->dwMaxRules)
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), FALSE);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the port rules tab.
 */
LRESULT CDialogPorts::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogPorts::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnApply\n");

    return 0;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogPorts::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnCancel\n");

    return 0;
}

/*
 * Method: OnColumnClick
 * Description: Called when the user clicks a column header in the listbox.
 */
LRESULT CDialogPorts::OnColumnClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnColumnClick\n");

    LPNMLISTVIEW lv;

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        /* Extract the column information. */
        lv = (LPNMLISTVIEW)pnmh;

        /* If we are sorting by the same column we were previously sorting by, 
           then we reverse the sort order. */
        if (m_sort_column == lv->iSubItem) {
            if (m_sort_order == WLBS_SORT_ASCENDING)
                m_sort_order = WLBS_SORT_DESCENDING;
            else if (m_sort_order == WLBS_SORT_DESCENDING)
                m_sort_order = WLBS_SORT_ASCENDING;
        }

        /* We sort by the column that was clicked. */
        m_sort_column = lv->iSubItem;

        /* Teardown the listbox and make sure our data matches the state of the UI. */
        UpdateInfo();

        /* Rebuild the listbox, with the new sort criteria. */
        SetInfo();

        /* Select the first item in the port rule list. */
        if (m_paramp->dwNumRules) ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnDoubleClick
 * Description: Called when the user double clicks an item in the listbox. 
 */
LRESULT CDialogPorts::OnDoubleClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnDoubleClick\n");

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        /* When an item is double-clicked, consider it an edit request. */
        OnButtonModify(BN_CLICKED, 0, 0, fHandled);
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnStateChange
 * Description: Called when the user selects a port rule from the list.
 */
LRESULT CDialogPorts::OnStateChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnStateChange\n");

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        LPNMLISTVIEW lv = (LPNMLISTVIEW)pnmh;
        int index;

        /* When the user selects a port rule, change the port rule description. */
        if (lv->uChanged & LVIF_STATE) FillPortRuleDescription();

        /* Find the index of the currently selected port rule. */
        if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) {
            /* If no port rule is selected, then disable the edit and delete buttons. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);
        } else {
            /* If one is selected, make sure the edit and delete buttons are enabled. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), TRUE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), TRUE);

            /* Give it the focus. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), index, LVIS_FOCUSED, LVIS_FOCUSED);
        }

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnDoubleClick
 * Description: Called when the user double clicks an item in the listbox. 
 */
void CDialogPorts::FillPortRuleDescription () {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::FillPortRuleDescription\n");

    VALID_PORT_RULE * rp = NULL;
    WCHAR description[512];
    LV_ITEM lvItem;
    int index;            
    
    /* Find the index of the currently selected port rule. */
    if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) {
        /* If there is no port rule selected, then display information about how traffic
           not covered by the port rule set is handled. */
        ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, SzLoadIds(IDS_PORT_RULE_DEFAULT));
        TRACE_INFO("%!FUNC! a port rule was no selected");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Fill in the information for this port rule. */
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.mask = LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    
    /* Get the information about this port rule. */
    if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
        TraceMsg(L"CDialogPorts::FillPortRuleDescription Unable to retrieve item %d from listbox\n", index);
        TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", index);
        TRACE_VERB("<-%!FUNC!");
        return;
    }
    
    /* Get the data pointer for this port rule. */
    if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
        TraceMsg(L"CDialogPorts::FillPortRuleDescription rule for item %d is bogus\n", index);
        TRACE_CRIT("%!FUNC! rule for item %d is bogus", index);
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* This code is terrible - for localization reasons, we require an essentially static string table entry
       for each possible port rule configuration.  So, we have to if/switch ourselves to death trying to 
       match this port rule with the correct string in the table - then we pop in stuff like port ranges. */
    switch (rp->protocol) {
    case CVY_TCP:
        if (rp->start_port == rp->end_port) {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORT_DISABLED), rp->start_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORT_SINGLE), rp->start_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORT_MULTIPLE_EQUAL), rp->start_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORT_MULTIPLE_UNEQUAL), rp->start_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        } else {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORTS_DISABLED), rp->start_port, rp->end_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORTS_SINGLE), rp->start_port, rp->end_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORTS_MULTIPLE_EQUAL), rp->start_port, rp->end_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_TCP_PORTS_MULTIPLE_UNEQUAL), rp->start_port, rp->end_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        }
        break;
    case CVY_UDP:
        if (rp->start_port == rp->end_port) {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORT_DISABLED), rp->start_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORT_SINGLE), rp->start_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORT_MULTIPLE_EQUAL), rp->start_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORT_MULTIPLE_UNEQUAL), rp->start_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        } else {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORTS_DISABLED), rp->start_port, rp->end_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORTS_SINGLE), rp->start_port, rp->end_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORTS_MULTIPLE_EQUAL), rp->start_port, rp->end_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_UDP_PORTS_MULTIPLE_UNEQUAL), rp->start_port, rp->end_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        }
        break;
    case CVY_TCP_UDP:
        if (rp->start_port == rp->end_port) {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORT_DISABLED), rp->start_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORT_SINGLE), rp->start_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORT_MULTIPLE_EQUAL), rp->start_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORT_MULTIPLE_UNEQUAL), rp->start_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        } else {
            switch (rp->mode) {
            case CVY_NEVER:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORTS_DISABLED), rp->start_port, rp->end_port);
                break;
            case CVY_SINGLE:
                wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORTS_SINGLE), rp->start_port, rp->end_port);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.equal_load)
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORTS_MULTIPLE_EQUAL), rp->start_port, rp->end_port);
                else
                    wsprintf(description, SzLoadIds(IDS_PORT_RULE_BOTH_PORTS_MULTIPLE_UNEQUAL), rp->start_port, rp->end_port);

                switch (rp->mode_data.multi.affinity) {
                case CVY_AFFINITY_NONE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                    break;
                case CVY_AFFINITY_SINGLE:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                    break;
                case CVY_AFFINITY_CLASSC:
                    lstrcat(description, SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                    break;
                }
                break;
            }
        }
        break;
    }

    /* Set the port rule description text. */
    ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, description);
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the ADD button.
 */
LRESULT CDialogPorts::OnButtonAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonAdd\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        CDialogPortRule * portRuleDialog = NULL;
        
        /* Create a port rule properties dialog box.  The invalid index tells the dialog that this
           operation is an ADD, so it populates the dialog box with default values. */
        if (!(portRuleDialog = new CDialogPortRule(this, m_adwHelpIDs, WLBS_INVALID_PORT_RULE_INDEX))) {
            TraceMsg(L"CDialogPorts::OnButtonAdd Unable to allocate for ADD dialog\n");
            TRACE_CRIT("%!FUNC! memory allocation failed when creating a port rule properties dialog box");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        /* Show the listbox.  If the user presses "OK", update the port rule list, otherwise ignore it. */
        if (portRuleDialog->DoModal() == IDOK)
            UpdateList(TRUE, FALSE, FALSE, &portRuleDialog->m_rule);
        
        /* Free the dialog box memory. */
        delete portRuleDialog;
        
        break;
    }
    
    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the DELETE button.
 */
LRESULT CDialogPorts::OnButtonDel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonDel\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Call UpdateList to DELETE a port rule. */
        UpdateList(FALSE, TRUE, FALSE, NULL);
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the EDIT button.
 */
LRESULT CDialogPorts::OnButtonModify (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonModify\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        CDialogPortRule * portRuleDialog = NULL;
        int index;            

        /* Find the index of the currently selected port rule. */
        if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) return 0;

        /* Create a port rule properties dialog box.  The index tells the dialog box which port rule
           is being modified, so the dialog can be populated with the configuration of that rule. */
        if (!(portRuleDialog = new CDialogPortRule(this, m_adwHelpIDs, index))) {
            TraceMsg(L"CDialogPorts::OnButtonModify Unable to allocate for MODIFY dialog\n");
            TRACE_CRIT("%!FUNC! memory allocation failed when creating a port rule properties dialog box");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        /* Show the listbox.  If the user presses "OK", update the port rule list, otherwise ignore it. */
        if (portRuleDialog->DoModal() == IDOK)
            UpdateList(FALSE, FALSE, TRUE, &portRuleDialog->m_rule);

        /* Free the dialog box memory. */
        delete portRuleDialog;

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: UpdateList
 * Description: Called when the user presses either ADD, MODIFY, or DELETE.  This function
 *              performs the appropriate function and error checking. 
 */
void CDialogPorts::UpdateList (BOOL add, BOOL del, BOOL modify, VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::UpdateList\n");

    VALID_PORT_RULE * rp;
    LV_ITEM lvItem;
    int i;

    /* Find a slot for this rule in the array of port rules. */
    if (modify) {
        /* For a MODIFY, we put the rule in place of the one the user modified. */
        if ((i = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1)
		{
            TRACE_CRIT("%!FUNC! failure while looking up a port rule for modify");
            TRACE_VERB("<-%!FUNC!");
			return;
		}

        /* Fill in the information for this port rule. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the information about this port rule. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateList MODIFY: Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox for modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this port rule. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateList rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus in modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }
        
        /* Delete the obsolete rule from the listbox. */
        if (!ListView_DeleteItem(GetDlgItem(IDC_LIST_PORT_RULE), i)) {
            TraceMsg(L"CDialogPorts::UpdateList MODIFY: Unable to delete item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to delete item %d from listbox for modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Now that the new rule has been validated, copy it into the array of port rules. */
        CopyMemory((PVOID)rp, (PVOID)rulep, sizeof(VALID_PORT_RULE));
    } else if (add) {
        /* For an ADD, we have to find an "empty" place for the rule in the array. */
        for (i = 0; i < WLBS_MAX_RULES; i ++)
            /* Loop and break when we find the first invalid rule. */
            if (!(rp = m_rules + i)->valid) break;
        
        /* Make sure that somehow we haven't allowed too many rules. */
        ASSERT(i < WLBS_MAX_RULES);

        /* Now that the new rule has been validated, copy it into the array of port rules. */
        CopyMemory((PVOID)rp, (PVOID)rulep, sizeof(VALID_PORT_RULE));
    } else if (del) {
        /* For a DELETE, get the currently selected rule from the listbox. */
        if ((i = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1)
		{
            TRACE_CRIT("%!FUNC! failure while looking up a port rule for delete");
            TRACE_VERB("<-%!FUNC!");
			return;
		}

        /* Fill in the information for this port rule. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the information about this port rule. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateList DEL: Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox for delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this rule and invalidate the rule. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateList rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus in delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }
        
        rp->valid = FALSE;
        
        /* Delete the obsolete rule from the listbox. */
        if (!ListView_DeleteItem(GetDlgItem(IDC_LIST_PORT_RULE), i)) {
            TraceMsg(L"CDialogPorts::UpdateList DEL: Unable to delete item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to delete item %d from listbox for delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        if (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) > i) {
            /* This was NOT the last (in order) port rule in the list, so highlight
               the port rule in the same position in the list box. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
        } else  if (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) > 0) {
            /* This was the last (in order) port rule in the list, so we highlight
               the rule "behind" us in the list - our position minus one. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), i - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
        } else {
            /* This was the last port rule (by count), so disable DELETE and MODIFY. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);            
        }

        /* Each time we DELETE a rule, we can enable the enable the ADD button, because we
           can be certain the room now exists for a new rule. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), TRUE);

        TRACE_INFO("%!FUNC! port rule deleted.");
        TRACE_VERB("<-%!FUNC!");
        return;
    } else
	{
        TRACE_CRIT("%!FUNC! unexpect action for port rule. Not an add, modify or delete.");
        TRACE_VERB("<-%!FUNC!");
		return;
	}

    /* Create the rule and select it in the listbox. */
    CreateRule(TRUE, rp); 

    /* Whenever we ADD a rule, check to see whether we have to disable the ADD button
       (when we have reached the maximum number of rules, we can no longer allow ADDs. */
    if (add && (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) >= (int)m_paramp->dwMaxRules))
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), FALSE);
    TRACE_VERB("<-%!FUNC!");
}


/*
 * Method: InsertRule
 * Description: Determines where to insert a new rule into the listbox.
 */
int CDialogPorts::InsertRule (VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::InsertRule\n");

    WCHAR buf[DIALOG_LIST_STRING_SIZE];
    WCHAR tmp[DIALOG_LIST_STRING_SIZE];
    int index;
    DWORD id, NewIpAddr;

    /* Determine sort field contents by column. */
    switch (m_sort_column) {
    case WLBS_VIP_COLUMN:
        /* Use the Vip */
        NewIpAddr = htonl(IpAddressFromAbcdWsz(rulep->virtual_ip_addr));
        break;

    case WLBS_PORT_START_COLUMN:
        /* Use the start port. */
        swprintf(tmp, L"%5d", rulep->start_port);
        
        break;
    case WLBS_PORT_END_COLUMN:
        /* Use the end port. */
        swprintf(tmp, L"%5d", rulep->end_port);

        break;
    case WLBS_PROTOCOL_COLUMN:
        /* Find the protocol for this port rule. */
        switch (rulep->protocol) {
        case CVY_TCP:
            id = IDS_LIST_TCP;
            break;
        case CVY_UDP:
            id = IDS_LIST_UDP;
            break;
        case CVY_TCP_UDP:
            id = IDS_LIST_BOTH;
            break;
        }
        
        /* Use the protocol. */
        swprintf(tmp, L"%ls", SzLoadIds(id));

        break;
    case WLBS_MODE_COLUMN:
        /* Find the mode for this port rule. */
        switch (rulep->mode) {
        case CVY_SINGLE:
            id = IDS_LIST_SINGLE;
            break;
        case CVY_MULTI:
            id = IDS_LIST_MULTIPLE;
            break;
        case CVY_NEVER:
            id = IDS_LIST_DISABLED;
            break;
        }            

        /* Use the mode. */
        swprintf(tmp, L"%ls", SzLoadIds(id));

        break;
    case WLBS_PRIORITY_COLUMN:
        /* In single host filtering, we use the priority.  If this rule does not use single host
           filtering, and therefore does not have a filtering priority, we insert at the end. */
        if (rulep->mode == CVY_SINGLE)
            swprintf(tmp, L"%2d", rulep->mode_data.single.priority);
        else 
		{
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
		}

        break;
    case WLBS_LOAD_COLUMN:
        /* In multiple host filtering, use the load, which can be "Equal" or an integer.  If this
           rule does not use multiple host filtering, and therefore does not have a load weight,
           we insert at the end. */
        if (rulep->mode == CVY_MULTI) {
            if (rulep->mode_data.multi.equal_load)
                swprintf(tmp, L"%ls", SzLoadIds(IDS_LIST_EQUAL));
            else
                swprintf(tmp, L"%3d", rulep->mode_data.multi.load);
        } else
		{
            TRACE_VERB("<-%!FUNC!");
			return (int)m_paramp->dwMaxRules;
		}

        break;
    case WLBS_AFFINITY_COLUMN:
        /* Find the affinity for this port rule.  Rules that do not use multiple host filtering
           will not have an affinity setting - that's fine.  Ignore this here. */
        switch (rulep->mode_data.multi.affinity) {
        case CVY_AFFINITY_NONE:
            id = IDS_LIST_ANONE;
            break;
        case CVY_AFFINITY_SINGLE:
            id = IDS_LIST_ASINGLE;
            break;
        case CVY_AFFINITY_CLASSC:
            id = IDS_LIST_ACLASSC;
            break;
        }

        /* In multiple host filtering, use the affinity.  If this port rule does not use multiple 
           host filtering, and therefore does not have an affinity, we insert at the end. */
        if (rulep->mode == CVY_MULTI)
            swprintf(tmp, L"%ls", SzLoadIds(id));
        else
		{
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
		}

        break;
    }

    /* Loop through the listbox to find the place to insert the new rule, in port range order. */
    for (index = 0; index < ::SendDlgItemMessage(m_hWnd, IDC_LIST_PORT_RULE, LVM_GETITEMCOUNT, 0, 0); index ++) {
        LV_ITEM lvItem;
        DWORD CurIpAddr;
    
        /* Fill in the information to retrieve the corresponding list entry for the column
           by which we are sorting. */
        lvItem.iItem = index;
        lvItem.iSubItem = m_sort_column;
        lvItem.mask = LVIF_TEXT;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = DIALOG_LIST_STRING_SIZE;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::InsertRule Unable to retrieve item %d from listbox\n", index);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", index);
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
        }

        // If the coolumn to sort on is VIP, get the vip in the list box
        if (m_sort_column == WLBS_VIP_COLUMN) {
            if (!wcscmp(lvItem.pszText, SzLoadIds(IDS_LIST_ALL_VIP)))
                CurIpAddr = htonl(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP));
            else
                CurIpAddr = htonl(IpAddressFromAbcdWsz(lvItem.pszText));
        }

        if (m_sort_order == WLBS_SORT_ASCENDING) {
            /* If the column subitem is empty, then we insert in front of it. */
            if (!wcscmp(lvItem.pszText, L"")) break;
            
            /* Compare IP Addresses as DWORDS for VIPs */
            /* If this rule is "greater" than the new rule, then this is where we insert. */
            if (m_sort_column == WLBS_VIP_COLUMN) 
            {
                if (CurIpAddr >= NewIpAddr) break;
            }
            else // Other columns
            {
                if (wcscmp(lvItem.pszText, tmp) >= 0) break;
            }
        } else if (m_sort_order == WLBS_SORT_DESCENDING) {
            /* Compare IP Addresses as DWORDS for VIPs */
            /* If this rule is "less" than the new rule, then this is where we insert. */
            if (m_sort_column == WLBS_VIP_COLUMN) 
            {
                if (CurIpAddr <= NewIpAddr) break;
            }
            else // Other columns
            {
                if (wcscmp(lvItem.pszText, tmp) <= 0) break;
            }
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return index;
}

/*
 * Method: CreateRule
 * Description: Adds a rule to the port rule list box.
 */
void CDialogPorts::CreateRule (BOOL select, VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::CreateRule\n");

    WCHAR buf[DIALOG_LIST_STRING_SIZE];
    WCHAR tmp[DIALOG_LIST_STRING_SIZE];
    LV_ITEM lvItem;
    DWORD id;
    int index;

    /* Find out at what index we are inserting into the listbox. */
    index = InsertRule(rulep);


    /* Insert the vip column, If Vip is "All Vip", insert the corresponding string, else insert the IP address */
    if (!lstrcmpi(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP))
    {
        swprintf(buf, L"%ls", SzLoadIds(IDS_LIST_ALL_VIP));
    }
    else
    {
        swprintf(buf, L"%ls", rulep->virtual_ip_addr);
    }


    /* Fill in the information to insert this item into the list and set
       the lParam to the pointer for this port rule.  This makes it trivial
       to retrieve the port rule structure from the listbox later. */
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = buf;
    lvItem.lParam = (LPARAM)rulep;
    
    /* Insert this item into the list. */
    if ((index = ListView_InsertItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) == -1) {
        TraceMsg(L"CDialogPorts::CreateRule Unable to insert item into listbox\n");
        TRACE_CRIT("%!FUNC! unable to insert item into listbox");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    swprintf(buf, L"%5d", rulep->start_port);

    /* Set the text associated with the start port subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PORT_START_COLUMN, buf);

    swprintf(buf, L"%5d", rulep->end_port);

    /* Set the text associated with the end port subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PORT_END_COLUMN, buf);

    /* Find the string table entry corresponding to the selected protocol. */
    switch (rulep->protocol) {
    case CVY_TCP:
        id = IDS_LIST_TCP;
        break;
    case CVY_UDP:
        id = IDS_LIST_UDP;
        break;
    case CVY_TCP_UDP:
        id = IDS_LIST_BOTH;
        break;
    }

    swprintf(buf, L"%ls", SzLoadIds(id));

    /* Set the text associated with the protocol subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PROTOCOL_COLUMN, buf);

    switch (rulep->mode) {
    case CVY_SINGLE:
        /* Single host filetering fills in only the mode and priority fields. */
        swprintf(buf, L"%ls", SzLoadIds(IDS_LIST_SINGLE));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);

        swprintf(buf, L"%2d", rulep->mode_data.single.priority);
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PRIORITY_COLUMN, buf);

        break;
    case CVY_MULTI:
        /* Find the appropriate string table entry for the affinity. */
        switch (rulep->mode_data.multi.affinity) {
        case CVY_AFFINITY_NONE:
            id = IDS_LIST_ANONE;
            break;
        case CVY_AFFINITY_SINGLE:
            id = IDS_LIST_ASINGLE;
            break;
        case CVY_AFFINITY_CLASSC:
            id = IDS_LIST_ACLASSC;
            break;
        }

        /* Multiple host filtering fills in the mode, load, and affinity fields. */
        swprintf(buf, L"%ls", SzLoadIds(IDS_LIST_MULTIPLE));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);
            
        if (rulep->mode_data.multi.equal_load) {
            swprintf(buf, L"%ls", SzLoadIds(IDS_LIST_EQUAL));
                
            /* Set the text associated with this subitem. */
            ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_LOAD_COLUMN, buf);
        } else {
            swprintf(buf, L"%3d", rulep->mode_data.multi.load);

            /* Set the text associated with this subitem. */
            ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_LOAD_COLUMN, buf);
        }

        swprintf(buf, L"%ls", SzLoadIds(id));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_AFFINITY_COLUMN, buf);

        break;
    case CVY_NEVER:
        /* Disabled filtering only fills in the mode field. */
        swprintf(buf, L"%ls", SzLoadIds(IDS_LIST_DISABLED));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);

        break;
    }

    if (select) {
        /* Select the first item in the port rule list. */
        ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        

        /* If we select a port rule in the list, we should enable the MODIFY and REMOVE buttons. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), TRUE);
        ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), TRUE);
    }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the port rule settings.
 */
void CDialogPorts::SetInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::SetInfo\n");

    VALID_PORT_RULE * rp;
    DWORD i;

    /* Empty the port rule memory. */
    memset(m_rules, 0, sizeof(m_rules));

    /* Get rid of all rules in the list box. */
    if (!ListView_DeleteAllItems(GetDlgItem(IDC_LIST_PORT_RULE))) {
        TraceMsg(L"CDialogPorts::SetInfo Unable to delete all items from listbox\n");
        TRACE_CRIT("%!FUNC! unable to delete all items from listbox");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Re-insert all port rules. */
    for (i = 0; i < m_paramp->dwNumRules; i ++) {
        *(NETCFG_WLBS_PORT_RULE *)&m_rules[i] = m_paramp->port_rules[i];

        /* Validate the port rule. */
        rp = m_rules + i;
        rp->valid = TRUE;

        /* Call CreateRule to insert the rule into the list. */
        CreateRule(FALSE, m_rules + i);
    }

    /* Mark the listbox rules as valid. */
    m_rulesValid = TRUE;
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the port rule configuration.
 */
void CDialogPorts::UpdateInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::UpdateInfo\n");

    VALID_PORT_RULE * rulep;
    DWORD i;

    /* If the rules are invalid, i.e. the listbox does not currently reflect the actual
       state of the port rules, then bail out. */
    if (!m_rulesValid)
	{
        TRACE_INFO("%!FUNC! rules are invalid and can't be processed");
        TRACE_VERB("<-%!FUNC!");
		return;
	}

    /* Empty the port rule memory. */
    memset(m_paramp->port_rules, 0, sizeof(m_paramp->port_rules));

    /* Set the number of port rules to the number of entries in the listbox. */
    m_paramp->dwNumRules = ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE));

    /* For each rule, retrieve the data pointer and store it. */
    for (i = 0; i < m_paramp->dwNumRules; i++) {
        LV_ITEM lvItem;

        /* Fill in the information necessary to retrive the port rule data pointer. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the listbox item information. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateInfo Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this port rule. */
        if (!(rulep = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateInfo rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rulep->valid) {
            TraceMsg(L"CDialogPorts::UpdateInfo Rule %d invalid\n", i);
            TRACE_CRIT("%!FUNC! invalid rule %d will be skipped", i);
            continue;
        }

        /* Store the valid port rule. */
        m_paramp->port_rules[i] = *(NETCFG_WLBS_PORT_RULE *)rulep;
    }

    /* Mark the listbox rules as invalid. */
    m_rulesValid = FALSE;
    TRACE_VERB("<-%!FUNC!");
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg(PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    vswprintf(szTempBufW, pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, 4096, NULL, NULL);
    
    /* Traced messages are now sent through the netcfg TraceTag routine so that 
       they can be turned on/off dynamically. */
    TraceTag(ttidWlbs, szTempBufA);

    va_end(arglist);
}
#endif

/*
 * Method: CDialogPortRule
 * Description: The class constructor.
 */
CDialogPortRule::CDialogPortRule (CDialogPorts * parent, const DWORD * adwHelpIDs, int index) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::CDialogPortRule\n");

    m_adwHelpIDs = adwHelpIDs;
    m_index = index;
    m_parent = parent;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: ~CDialogPortRule
 * Description: The class destructor.
 */
CDialogPortRule::~CDialogPortRule () {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPortRule::~CDialogPortRule\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the port rule properties dialog.
 */
LRESULT CDialogPortRule::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnInitDialog\n");

    RECT rect;

    /* Position this window with the upper-left corner matching the upper left corner
       of the port rule list box in the parent window.  Simply for consistency. */
    ::GetWindowRect(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &rect);
    SetWindowPos(NULL, rect.left, rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

    /* Limit the field ranges for the port rule properties. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_START, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_END, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_MULTI, EM_SETLIMITTEXT, 3, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_SINGLE, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_SINGLE, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, CVY_MAX_MAX_HOSTS);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_MULTI, UDM_SETRANGE32, CVY_MIN_LOAD, CVY_MAX_LOAD);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_START, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_END, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);

    /* Limit the zeroth field of the cluster IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* Invalidate the rule.  The validity will be checked upon clicking "OK". */
    m_rule.valid = FALSE;

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* Set the cursor to be the arrow.  For some reason, if we don't do this, then the cursor 
       will remain an hourglass until the mouse moves over any UI element.  Probably need to
       call CPropertPage constructor to fix this? */
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogPortRule::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogPortRule::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnOk
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogPortRule::OnOk (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnOk\n");

    BOOL fSuccess = FALSE;
    DWORD IPAddr;

    /* If "All" is Checked, then, initialize with CVY_ALL_VIP_STRING */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP) == BST_CHECKED) 
    {
        lstrcpy(m_rule.virtual_ip_addr, CVY_DEF_ALL_VIP); 
    }
    else // UnChecked
    {
        /* Check for Blank Virtual IP Address */
        if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_PORT_RULE_VIP), IPM_ISBLANK, 0, 0)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_VIP_BLANK, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            /* An error occurred. */
            TRACE_CRIT("%!FUNC! No virtual IP address provided for a port rule");
            TRACE_VERB("<-%!FUNC!");
            return PSNRET_INVALID;
        }

        /* Get the Virtual IP address as a string and DWORD. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)m_rule.virtual_ip_addr);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);

        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);

            /* Set the IP address and update our cluster IP address string. */
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            //::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)m_rule.virtual_ip_addr);
      
            /* Alert the user. */
            PrintIPRangeError(IDS_PARM_CL_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

            TRACE_CRIT("%!FUNC! invalid first octect value for IP address");
            TRACE_VERB("<-%!FUNC!");
            return PSNRET_INVALID;
        }
    }
    
    /* Find out which protocol has been selected. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_TCP))
        m_rule.protocol = CVY_TCP;
    else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_UDP))
        m_rule.protocol = CVY_UDP;
    else
        m_rule.protocol = CVY_TCP_UDP;
        
    /* Get the start port for this rule. */
    m_rule.start_port = ::GetDlgItemInt(m_hWnd, IDC_EDIT_START, &fSuccess, FALSE); 

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. */
    if (!fSuccess) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_BLANK, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_START));

        TRACE_CRIT("%!FUNC! no start port value provided");
        TRACE_VERB("<-%!FUNC!");
        return 0; 
    }

    /* Get the end port for this rule. */
    m_rule.end_port = ::GetDlgItemInt(m_hWnd, IDC_EDIT_END, &fSuccess, FALSE); 

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. */
    if (!fSuccess) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_BLANK, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        TRACE_CRIT("%!FUNC! no end port value provided");
        TRACE_VERB("<-%!FUNC!");
        return 0;                      
    }

    /* Make sure that the start port value falls within the valid range. */
    if (/* m_rule.start_port < CVY_MIN_PORT || */ m_rule.start_port > CVY_MAX_PORT) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_VAL, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Force the start port to fall into the range, effectively helping the user. */
        /* CVY_CHECK_MIN(m_rule.start_port, CVY_MIN_PORT); */
        CVY_CHECK_MAX(m_rule.start_port, CVY_MAX_PORT);

        /* Set the start port to the now valid entry. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, m_rule.start_port, FALSE);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_START));

        TRACE_CRIT("%!FUNC! invalid start port value");
        TRACE_VERB("<-%!FUNC!");
        return 0;
    }

    /* Make sure that the end port value falls within the valid range. */
    if (/* m_rule.end_port < CVY_MIN_PORT || */ m_rule.end_port > CVY_MAX_PORT) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_VAL, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Force the end port to fall into the range, effectively helping the user. */
        /* CVY_CHECK_MIN(m_rule.end_port, CVY_MIN_PORT); */
        CVY_CHECK_MAX(m_rule.end_port, CVY_MAX_PORT);

        /* Set the end port to the now valid entry. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, m_rule.end_port, FALSE);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        TRACE_CRIT("%!FUNC! invalid end port value");
        TRACE_VERB("<-%!FUNC!");
        return 0;
    }

    /* Retrieve the filtering mode settings. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_SINGLE)) {
        /* The user has selected single host filtering. */
        m_rule.mode = CVY_SINGLE;

        /* Get the handling priority. */
        m_rule.mode_data.single.priority = ::GetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, &fSuccess, FALSE); 

        /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
           string to an integer. This allows us to check for empty fields, assuming that because
           we otherwise limit the user input to digits, there will be no errors of any other type. */
        if (!fSuccess) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_HPRI_BLANK, CVY_MIN_PRIORITY, CVY_MAX_PRIORITY);

            /* Return the focus to the erred entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_SINGLE));

            TRACE_CRIT("%!FUNC! a handling priority is required but was not provided");
            TRACE_VERB("<-%!FUNC!");
            return 0;                          
        }

        /* Make sure that the handling priority falls within the valid range. */
        if (m_rule.mode_data.single.priority > CVY_MAX_PRIORITY || m_rule.mode_data.single.priority < CVY_MIN_PRIORITY) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_SINGLE, CVY_MIN_PRIORITY, CVY_MAX_PRIORITY);

            /* Force the handling priority to fall into the range, effectively helping the user. */
            CVY_CHECK_MIN(m_rule.mode_data.single.priority, CVY_MIN_PRIORITY);
            CVY_CHECK_MAX(m_rule.mode_data.single.priority, CVY_MAX_PRIORITY);

            /* Set the handling priority to the now valid entry. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, m_rule.mode_data.single.priority, FALSE);

            /* Return the focus to the erred entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_SINGLE));

            TRACE_CRIT("%!FUNC! an invalid handling priority was provided");
            TRACE_VERB("<-%!FUNC!");
            return 0;
        }
    } else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTIPLE)) {
        /* The user has selected multiple host filtering. */
        m_rule.mode = CVY_MULTI;

        if (::IsDlgButtonChecked (m_hWnd, IDC_CHECK_EQUAL)) {
            /* If the users has chosen equal load, then note this fact. */
            m_rule.mode_data.multi.equal_load = TRUE;
        } else {
            /* Otherwise, they have specified a specific load weight. */
            m_rule.mode_data.multi.equal_load = FALSE;

            /* Get the load weight. */
            m_rule.mode_data.multi.load = ::GetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, &fSuccess, FALSE); 

            /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
               string to an integer. This allows us to check for empty fields, assuming that because
               we otherwise limit the user input to digits, there will be no errors of any other type. */
            if (!fSuccess) {
                /* Alert the user. */
                PrintRangeError(IDS_PARM_LOAD_BLANK, CVY_MIN_LOAD, CVY_MAX_LOAD);

                /* Return the focus to the erred entry. */
                ::SetFocus(GetDlgItem(IDC_EDIT_MULTI));

                TRACE_CRIT("%!FUNC! a load weight is required but was not provided");
                TRACE_VERB("<-%!FUNC!");
                return 0;                    
            }

            /* Make sure that the load weight falls within the valid range. */
            if (/* m_rule.mode_data.multi.load < CVY_MIN_LOAD || */ m_rule.mode_data.multi.load > CVY_MAX_LOAD) {
                /* Alert the user. */
                PrintRangeError(IDS_PARM_LOAD, CVY_MIN_LOAD, CVY_MAX_LOAD);

                /* Force the load weight to fall into the range, effectively helping the user. */
                /* CVY_CHECK_MIN(m_rule.mode_data.multi.load, CVY_MIN_LOAD); */
                CVY_CHECK_MAX(m_rule.mode_data.multi.load, CVY_MAX_LOAD);

                /* Set the load weight to the now valid entry. */
                ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, m_rule.mode_data.multi.load, FALSE);

                /* Return the focus to the erred entry. */
                ::SetFocus(GetDlgItem(IDC_EDIT_MULTI));

                TRACE_CRIT("%!FUNC! an invalid load weight was provided");
                TRACE_VERB("<-%!FUNC!");
                return 0;
            }
        }

        /* Find out which affinity setting has been selected. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_AFF_CLASSC))
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_CLASSC;
        else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_AFF_SINGLE))
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_SINGLE;
        else
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_NONE;

    } else {
        /* The user has selected no filtering (disabled). */
        m_rule.mode = CVY_NEVER;
    }

    /* Validate the rule.  If it is invalid, just bail out. */
    if (!ValidateRule(&m_rule, (m_index != WLBS_INVALID_PORT_RULE_INDEX) ? FALSE : TRUE))
	{
        TRACE_CRIT("%!FUNC! rule validation failed");
        TRACE_VERB("<-%!FUNC!");
		return 0;
	}

    /* If we get here, then the rule is valid. */
    m_rule.valid = TRUE;

    /* Close the dialog and note that the user clicked "OK". */
    EndDialog(IDOK);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: ValidateRule
 * Description: Check a port rule for validity, including enforcing the non-overlap of port ranges.
 */
BOOL CDialogPortRule::ValidateRule (VALID_PORT_RULE * rulep, BOOL self_check) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::ValidateRule\n");

    VALID_PORT_RULE * rp;
    int i, index, count;

    /* Verify that the virtual ip address is not the same as the dip */
    if (IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(m_parent->m_paramp->ded_ip_addr)) 
    {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_VIP_CONFLICT_DIP, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* Return focus to the invalid entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_PORT_RULE_VIP));

        /* Invalidate the rule. */
        rulep->valid = FALSE;

        TRACE_CRIT("%!FUNC! virtual IP address and dedicated IP address are the same: %ls", rulep->virtual_ip_addr);
        TRACE_VERB("<-%!FUNC!");
        return FALSE;
    }

    /* Make sure that the end port is greater than or equal to the start port. */
    if (rulep->start_port > rulep->end_port) {
        TRACE_CRIT("%!FUNC! start port %d is greater than end port %d", rulep->start_port, rulep->end_port);
        /* If the end port is less than the start port, generate an error and set the 
           value of the erroneous end port to the value of the start port. */
        rulep->end_port = rulep->start_port;
        
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_RANGE,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* Populate the UI with the new (conforming) end port value. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, rulep->end_port, FALSE);
        
        /* Return focus to the invalid entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        /* Invalidate the rule. */
        rulep->valid = FALSE;

        TRACE_VERB("<-%!FUNC!");
        return FALSE;
    }

    /* Find out how many rules are currently in the listbox. */
    count = ListView_GetItemCount(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE));

    for (i = 0; i < count; i ++) {
        LV_ITEM lvItem;

        /* If this is a MODIFY operation, do not check against ourselves */
        if (!self_check && (i == m_index)) continue;

        /* Fill in the information necessary to retrieve the port rule data pointer. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPortRule::ValidateRule Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", i);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }

        /* Get the data pointer for the i'th port rule in the list. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPortRule::ValidateRule rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus", i);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rp->valid) {
            TraceMsg(L"CDialogPortRule::ValidateRule Rule %d invalid\n", i);
            TRACE_VERB("%!FUNC! rule %d invalid and will be skipped", i);
            continue;
        }

        /* Check for overlapping port ranges. */
        if ((IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(rp->virtual_ip_addr)) 
        && (((rulep->start_port < rp->start_port) && (rulep->end_port >= rp->start_port)) ||
            ((rulep->start_port >= rp->start_port) && (rulep->start_port <= rp->end_port)))) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_OVERLAP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* Set the listbox selection to be the conflicting rule. */
            ::SendDlgItemMessage(m_hWnd, IDC_LIST_PORT_RULE, LB_SETCURSEL, i, 0);
            
            /* Return focus to the invalid entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_START));

            /* Invalidate the rule. */
            rulep->valid = FALSE;

            TRACE_CRIT("%!FUNC! a port rule overlaps with the port range of another rule and will be rejected");
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return TRUE;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogPortRule::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCancel\n");

    /* Close the dialog and note that the user clicked "Cancel". */
    EndDialog(IDCANCEL);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in 
 *              an IP address octet.
 */
void CDialogPortRule::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::PrintIPRangeError\n");

    WCHAR szCurrent[10];
    WCHAR szLow[10];
    WCHAR szHigh[10];

    /* Fill in the allowed range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szCurrent, L"%d", value);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
    TRACE_CRIT("%!FUNC! an IP address octect with value %ls is out of range", szCurrent);
    TRACE_VERB("<-%!FUNC!");
}


/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogPortRule::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnIpFieldChange\n");

    LPNMIPADDRESS Ip;
    int low, high;

    Ip = (LPNMIPADDRESS)pnmh;
        
    switch(idCtrl) {
    case IDC_EDIT_PORT_RULE_VIP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
        else {
            low = WLBS_FIELD_LOW;
            high = WLBS_FIELD_HIGH;
        }
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = Ip->hdr.idFrom;
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;
            
            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError(IDS_PARM_CL_IP_FIELD, Ip->iValue, low, high);
                TRACE_CRIT("%!FUNC! IP address or subnet mask are not valid and will be rejected");
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}


/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CDialogPortRule::OnCheckPortRuleAllVip (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCheckPortRuleAllVip\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
         /* If the All Vip box is checked, grey out the IP control, Else brighten the IP control */
         if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP)) 
         {
             ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);
         }
         else
         {
             ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), TRUE);
         }
         break;
    }
    
    TRACE_VERB("<-%!FUNC!");
    return 0;
}



/*
 * Method: OnCheckEqual
 * Description: Called when the user checks/unchecks the equal load weight checkbox.
 */
LRESULT CDialogPortRule::OnCheckEqual (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCheckEqual\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If equal has been checked, then disable the load weight entry box and spin control.  */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_EQUAL)) {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        } else {
            /* Otherwise, enable them. */
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), TRUE);
        }

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnRadioMode
 * Description: Called when the user changes the radio button selection for the filtering mode.
 */
LRESULT CDialogPortRule::OnRadioMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnRadioMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Call ModeSwitch to enable/disable UI entities appropriately based on 
           the currently selected filtering mode. */
        ModeSwitch();
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: PrintRangeError
 * Description: Displays a message box warning the user of an out-of-range entry.
 */
void CDialogPortRule::PrintRangeError (unsigned int ids, int low, int high) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::PrintRangeError\n");

    WCHAR szLow[10];
    WCHAR szHigh[10];

    /* Fill in the allowed range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szLow, szHigh);
    TRACE_VERB("->%!FUNC!");
}

/*
 * Method: ModeSwitch
 * Description: Called when the user changes the filtering mode. 
 */
VOID CDialogPortRule::ModeSwitch () {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::ModeSwitch\n");

    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_SINGLE)) {
        /* If single host filtering was selected, then turn on all controls for 
           single host and turn off all controls for multiple host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), FALSE);
    } else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTIPLE)) {
        /* If multiple host filtering was selected, then turn on all controls for
           multiple host and turn off all controls for single host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), TRUE);

        /* Turn the load weight entry on/off depending on the value of the 
           equal load weight checkbox. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_EQUAL)) {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        } else {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), TRUE);
        }
    } else {
        /* Otherwise, if disabled was selected, then turn off all controls for
           both multiple host and single host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), FALSE);
    }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the port rule settings.
 */
void CDialogPortRule::SetInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::SetInfo\n");

    VALID_PORT_RULE * rulep = NULL;
    DWORD addr[4];

    if (m_index != WLBS_INVALID_PORT_RULE_INDEX) {
        LV_ITEM lvItem;

        /* Fill in the information necessary to retrieve the port rule data pointer. */
        lvItem.iItem = m_index;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPortRule::SetInfo Unable to retrieve item %d from listbox\n", m_index);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for the i'th port rule in the list. */
        if (!(rulep = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPortRule::SetInfo rule for item %d is bogus\n", m_index);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus\n", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rulep->valid) {
            TraceMsg(L"CDialogPortRule::SetInfo Rule %d invalid\n", m_index);
            TRACE_CRIT("%!FUNC! rule %d invalid\n", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }        

        /* If the cluster IP address is CVY_ALL_VIP_STRING, grey out the ip control and check the All Vip box, 
           Else, fill in the IP address in the IP control and uncheck the All Vip box  */

        if (!lstrcmpi(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
           /* Grey out IP Control */
           ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);

           /* Check the All Vip checkbox */
           ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);
        }
        else
        {
            /* Extract the IP address octects from the IP address string. */ 
            GetIPAddressOctets(rulep->virtual_ip_addr, addr);
            ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_PORT_RULE_VIP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));

            /* UnCheck the All Vip checkbox */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_UNCHECKED);
        }

        /* Set the start and end port values for this rule. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, rulep->start_port, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, rulep->end_port, FALSE);
        
        /* Check the protocol and filtering mode radio buttons appropriately. */
        ::CheckRadioButton(m_hWnd, IDC_RADIO_TCP, IDC_RADIO_BOTH,
                           IDC_RADIO_TCP + rulep->protocol - CVY_MIN_PROTOCOL);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_SINGLE, IDC_RADIO_DISABLED,
                           IDC_RADIO_SINGLE + rulep->mode - CVY_MIN_MODE);
        
        /* Set the default values for filtering mode parameters.  Below, we
           overwrite the ones for the specific filtering mode for this rule. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, CVY_DEF_PRIORITY, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, CVY_DEF_LOAD, FALSE);
        ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, CVY_DEF_EQUAL_LOAD);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                           IDC_RADIO_AFF_NONE + CVY_DEF_AFFINITY - CVY_MIN_AFFINITY);
        
        switch (rulep -> mode) {
        case CVY_SINGLE:
            /* In sinlge host filtering, the only user parameter is the priority for this host. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, rulep->mode_data.single.priority, FALSE);
        
        break;
        case CVY_MULTI:
            /* In multiple host filtering, we need to set the affinity and load weight. */
            ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                               IDC_RADIO_AFF_NONE + rulep->mode_data.multi.affinity);
        
        if (rulep->mode_data.multi.equal_load) {
            /* If this rule uses equal load, then check the equal checkbox. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, TRUE);
        } else {
            /* If this rule has a specific load weight, then uncheck the equal
               checkbox and set the load value. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, FALSE);
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, rulep->mode_data.multi.load, FALSE);
        }

        break;
        default:
            /* If the mode is DISABLED, then do nothing. */
            break;
        }
    } else {

        /* Grey out IP Control */
        ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);

        /* Check the All Vip checkbox */
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);

        /* Check the radio buttons with their default settings. */
        ::CheckRadioButton(m_hWnd, IDC_RADIO_TCP, IDC_RADIO_BOTH,
                           IDC_RADIO_TCP + CVY_DEF_PROTOCOL - CVY_MIN_PROTOCOL);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                           IDC_RADIO_AFF_NONE + CVY_DEF_AFFINITY - CVY_MIN_AFFINITY);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_SINGLE, IDC_RADIO_DISABLED,
                           IDC_RADIO_SINGLE + CVY_DEF_MODE - CVY_MIN_MODE);
        
        /* Check/uncheck the equal load checkbox. */
        ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, CVY_DEF_EQUAL_LOAD);
        
        /* Fill in the entry boxes with their default values. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, CVY_DEF_PORT_START, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, CVY_DEF_PORT_END, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, CVY_DEF_PRIORITY, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, CVY_DEF_LOAD, FALSE);
    }

    /* Call ModeSwitch to enable and disable UI entries as appropriate, based 
       the the filtering mode currently selected. */
    ModeSwitch();
    TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\resource.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - resource IDs

Author:

    kyrilf

--*/

//#include <ncres.h>

#pragma once

#define IDR_REG_WLBS                            40001

#define ID_CONTEXT_HELP                             8
#define ID_HELP                                     9

/* String table entries for configuration error messages or warnings. */
#define IDS_LIC_PRODUCT                           111
#define IDS_PARM_RULES                            201
#define IDS_PARM_RANGE                            202
#define IDS_PARM_OVERLAP                          203
#define IDS_PARM_PASSWORD                         204
#define IDS_PARM_IGMP_MCAST                       205
#define IDS_PARM_RCT_WARN                         206
#define IDS_PARM_IGMP_WARN                        207
#define IDS_PARM_WARN                             208
#define IDS_PARM_ERROR                            209
#define IDS_PARM_INFORMATION                      210
#define IDS_PARM_PORT_BLANK                       211
#define IDS_PARM_LOAD_BLANK                       212
#define IDS_PARM_HPRI_BLANK                       213
#define IDS_PARM_PRI_BLANK                        214
#define IDS_PARM_CL_IP_BLANK                      215
#define IDS_PARM_DED_IP_BLANK                     216
#define IDS_PARM_CL_NM_BLANK                      217
#define IDS_PARM_DED_NM_BLANK                     218
#define IDS_PARM_INVAL_CL_IP                      219
#define IDS_PARM_INVAL_DED_IP                     220
#define IDS_PARM_INVAL_CL_MASK                    221
#define IDS_PARM_INVAL_DED_MASK                   222
#define IDS_PARM_CL_IP_FIELD                      223
#define IDS_PARM_CL_NM_FIELD                      224
#define IDS_PARM_DED_IP_FIELD                     225
#define IDS_PARM_DED_NM_FIELD                     226
#define IDS_PARM_PRI                              227
#define IDS_PARM_PORT_VAL                         228
#define IDS_PARM_LOAD                             229
#define IDS_PARM_SINGLE                           230
#define IDS_PARM_IP_CONFLICT                      231
#define IDS_PARM_MULTINIC_IP_CONFLICT             232
#define IDS_PARM_INVAL_MAC                        233
#define IDS_PARM_TCPIP                            234
#define IDS_PARM_VIP_BLANK                        235
#define IDS_PARM_VIP_CONFLICT_DIP                 236
#define IDS_PARM_DIP_CONFLICT_VIP                 237
#define IDS_PARM_MSCS_INSTALLED                   238

/* String table entries for the port rule listbox. */
#define IDS_LIST_BOTH                             260
#define IDS_LIST_TCP                              261
#define IDS_LIST_UDP                              262
#define IDS_LIST_MULTIPLE                         263
#define IDS_LIST_SINGLE                           264
#define IDS_LIST_DISABLED                         265
#define IDS_LIST_EQUAL                            266
#define IDS_LIST_ANONE                            267
#define IDS_LIST_ASINGLE                          268
#define IDS_LIST_ACLASSC                          269
#define IDS_LIST_START                            270
#define IDS_LIST_END                              271
#define IDS_LIST_PROT                             272
#define IDS_LIST_MODE                             273
#define IDS_LIST_PRI                              274
#define IDS_LIST_LOAD                             275
#define IDS_LIST_AFF                              276
#define IDS_LIST_VIP                              277
#define IDS_LIST_ALL_VIP                          278

/* String table entries for the port rule descriptions. */
#define IDS_PORT_RULE_DEFAULT                     300
#define IDS_PORT_RULE_TCP_PORT_DISABLED           301
#define IDS_PORT_RULE_TCP_PORT_SINGLE             302
#define IDS_PORT_RULE_TCP_PORT_MULTIPLE_EQUAL     303
#define IDS_PORT_RULE_TCP_PORT_MULTIPLE_UNEQUAL   304
#define IDS_PORT_RULE_TCP_PORTS_DISABLED          305
#define IDS_PORT_RULE_TCP_PORTS_SINGLE            306
#define IDS_PORT_RULE_TCP_PORTS_MULTIPLE_EQUAL    307
#define IDS_PORT_RULE_TCP_PORTS_MULTIPLE_UNEQUAL  308
#define IDS_PORT_RULE_UDP_PORT_DISABLED           309
#define IDS_PORT_RULE_UDP_PORT_SINGLE             310
#define IDS_PORT_RULE_UDP_PORT_MULTIPLE_EQUAL     311
#define IDS_PORT_RULE_UDP_PORT_MULTIPLE_UNEQUAL   312
#define IDS_PORT_RULE_UDP_PORTS_DISABLED          313
#define IDS_PORT_RULE_UDP_PORTS_SINGLE            314
#define IDS_PORT_RULE_UDP_PORTS_MULTIPLE_EQUAL    315
#define IDS_PORT_RULE_UDP_PORTS_MULTIPLE_UNEQUAL  316
#define IDS_PORT_RULE_BOTH_PORT_DISABLED          317
#define IDS_PORT_RULE_BOTH_PORT_SINGLE            318
#define IDS_PORT_RULE_BOTH_PORT_MULTIPLE_EQUAL    319
#define IDS_PORT_RULE_BOTH_PORT_MULTIPLE_UNEQUAL  320
#define IDS_PORT_RULE_BOTH_PORTS_DISABLED         321
#define IDS_PORT_RULE_BOTH_PORTS_SINGLE           322
#define IDS_PORT_RULE_BOTH_PORTS_MULTIPLE_EQUAL   323
#define IDS_PORT_RULE_BOTH_PORTS_MULTIPLE_UNEQUAL 324
#define IDS_PORT_RULE_AFFINITY_NONE               325
#define IDS_PORT_RULE_AFFINITY_SINGLE             326
#define IDS_PORT_RULE_AFFINITY_CLASSC             327

/* The dialogs. */
#define IDD_DIALOG_CLUSTER                        533
#define IDD_DIALOG_HOST                           534
#define IDD_DIALOG_PORTS                          535
#define IDD_DIALOG_PORT_RULE_PROP                 536

/* Accelerators. */
#define IDR_ACCELERATOR                           700

/* The controls for the cluster properties page. */
#define IDC_GROUP_CL_IP                          1000
#define IDC_TEXT_CL_IP                           1001
#define IDC_EDIT_CL_IP                           1002
#define IDC_TEXT_CL_MASK                         1003
#define IDC_EDIT_CL_MASK                         1004
#define IDC_TEXT_DOMAIN                          1005
#define IDC_EDIT_DOMAIN                          1006
#define IDC_TEXT_ETH                             1007
#define IDC_EDIT_ETH                             1008
#define IDC_GROUP_CL_MODE                        1009
#define IDC_RADIO_UNICAST                        1010
#define IDC_RADIO_MULTICAST                      1011
#define IDC_CHECK_IGMP                           1012
#define IDC_GROUP_RCT                            1013
#define IDC_CHECK_RCT                            1014
#define IDC_TEXT_PASSW                           1015
#define IDC_EDIT_PASSW                           1016
#define IDC_TEXT_PASSW2                          1017
#define IDC_EDIT_PASSW2                          1018
#define IDC_BUTTON_HELP                          1019

/* The controls for the host properties page. */
#define IDC_TEXT_PRI                             2000
#define IDC_EDIT_PRI                             2001
#define IDC_SPIN_PRI                             2002
#define IDC_GROUP_DED_IP                         2003
#define IDC_TEXT_DED_IP                          2004
#define IDC_EDIT_DED_IP                          2005
#define IDC_TEXT_DED_MASK                        2006
#define IDC_EDIT_DED_MASK                        2007
#define IDC_CHECK_ACTIVE                         2008

/* The controls for the port rules page. */
#define IDC_TEXT_PORT_RULE                       3000
#define IDC_LIST_PORT_RULE                       3001
#define IDC_BUTTON_ADD                           3002
#define IDC_BUTTON_MODIFY                        3003
#define IDC_BUTTON_DEL                           3004
#define IDC_GROUP_PORT_RULE_DESCR                3005
#define IDC_TEXT_PORT_RULE_DESCR                 3006

/* The controls for the port rule properties page. */
#define IDC_GROUP_RANGE                          4000
#define IDC_EDIT_START                           4001
#define IDC_SPIN_START                           4002
#define IDC_EDIT_END                             4003
#define IDC_SPIN_END                             4004
#define IDC_GROUP_PROTOCOLS                      4005
#define IDC_RADIO_TCP                            4006
#define IDC_RADIO_UDP                            4007
#define IDC_RADIO_BOTH                           4008
#define IDC_GROUP_SINGLE                         4009
#define IDC_GROUP_MULTIPLE                       4010
#define IDC_GROUP_DISABLED                       4011
#define IDC_RADIO_SINGLE                         4012
#define IDC_RADIO_MULTIPLE                       4013
#define IDC_RADIO_DISABLED                       4014
#define IDC_TEXT_AFF                             4015
#define IDC_RADIO_AFF_NONE                       4016
#define IDC_RADIO_AFF_SINGLE                     4017
#define IDC_RADIO_AFF_CLASSC                     4018
#define IDC_TEXT_MULTI                           4019
#define IDC_EDIT_MULTI                           4020
#define IDC_SPIN_MULTI                           4021
#define IDC_CHECK_EQUAL                          4022
#define IDC_TEXT_SINGLE                          4023
#define IDC_EDIT_SINGLE                          4024
#define IDC_SPIN_SINGLE                          4025
#define IDC_TEXT_START                           4026
#define IDC_TEXT_END                             4027
#define IDC_PORT_RULE_VIP                        4028
#define IDC_EDIT_PORT_RULE_VIP                   4029
#define IDC_CHECK_PORT_RULE_ALL_VIP              4030
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\ports.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    ports.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - port rules tab

Author:

    kyrilf
    shouse

--*/


#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsconfig.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

#define WLBS_INVALID_PORT_RULE_INDEX -1

#define WLBS_NUM_COLUMNS        8
#define WLBS_VIP_COLUMN         0
#define WLBS_PORT_START_COLUMN  1
#define WLBS_PORT_END_COLUMN    2
#define WLBS_PROTOCOL_COLUMN    3
#define WLBS_MODE_COLUMN        4
#define WLBS_PRIORITY_COLUMN    5
#define WLBS_LOAD_COLUMN        6
#define WLBS_AFFINITY_COLUMN    7

struct VALID_PORT_RULE : public NETCFG_WLBS_PORT_RULE {
    BOOL valid;
};

class CDialogPorts : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogPorts)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (LVN_ITEMCHANGED, OnStateChange)
    NOTIFY_CODE_HANDLER (NM_DBLCLK, OnDoubleClick)
    NOTIFY_CODE_HANDLER (LVN_COLUMNCLICK, OnColumnClick)

    COMMAND_ID_HANDLER (IDC_BUTTON_ADD, OnButtonAdd)
    COMMAND_ID_HANDLER (IDC_BUTTON_DEL, OnButtonDel)
    COMMAND_ID_HANDLER (IDC_BUTTON_MODIFY, OnButtonModify)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogPorts (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogPorts ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnStateChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnDoubleClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnColumnClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
 
    LRESULT OnButtonAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonDel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonModify (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogHost;
    friend class CDialogCluster;
    friend class CDialogPortRule;

private:
    void SetInfo ();
    void UpdateInfo ();
    
    void CreateRule (BOOL select, VALID_PORT_RULE * rulep);
    void UpdateList (BOOL add, BOOL del, BOOL modify, VALID_PORT_RULE * rulep);
    int InsertRule (VALID_PORT_RULE * rulep);
    void FillPortRuleDescription ();

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rulesValid;

    int m_sort_column;
    enum { WLBS_SORT_ASCENDING = 0, WLBS_SORT_DESCENDING = 1 } m_sort_order;

    VALID_PORT_RULE m_rules[WLBS_MAX_RULES];
};

class CDialogPortRule : public CDialogImpl<CDialogPortRule> {
public:
    enum { IDD = IDD_DIALOG_PORT_RULE_PROP };

    BEGIN_MSG_MAP (CDialogPortRule)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDOK, OnOk);
    COMMAND_ID_HANDLER (IDCANCEL, OnCancel);
    COMMAND_ID_HANDLER (IDC_CHECK_PORT_RULE_ALL_VIP, OnCheckPortRuleAllVip);
    COMMAND_ID_HANDLER (IDC_CHECK_EQUAL, OnCheckEqual)
    COMMAND_ID_HANDLER (IDC_RADIO_MULTIPLE, OnRadioMode)
    COMMAND_ID_HANDLER (IDC_RADIO_SINGLE, OnRadioMode)
    COMMAND_ID_HANDLER (IDC_RADIO_DISABLED, OnRadioMode)

    END_MSG_MAP ()

    CDialogPortRule (CDialogPorts * parent, const DWORD * phelpIDs, int index);
    ~CDialogPortRule ();

public:
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnOk (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckPortRuleAllVip (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckEqual (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnRadioMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogPorts;

private:
    void PrintIPRangeError (unsigned int ids, int value, int low, int high);
    void PrintRangeError (unsigned int ids, int low, int high);

    void SetInfo ();
    void ModeSwitch ();

    BOOL ValidateRule (VALID_PORT_RULE * rulep, BOOL self_check);

    const DWORD * m_adwHelpIDs;

    CDialogPorts * m_parent;

    int m_index;

    VALID_PORT_RULE m_rule;
    struct {
      UINT IpControl;
      int Field;
      int Value;
      UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\tracelog.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <winbase.h>
#include <rtutils.h>

#define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
#define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
#define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
//    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
//    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

BOOL  TRACELogRegister(LPCTSTR szName);
void  TRACELogDeRegister();
void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);


#define LOG_ERROR(pszFmt)                    TRACELogPrint(TL_ERROR, pszFmt)
#define LOG_ERROR1(pszFmt, arg1)             TRACELogPrint(TL_ERROR, pszFmt, arg1)
#define LOG_ERROR2(pszFmt, arg1, arg2)       TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2)
#define LOG_ERROR3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2, arg3)

#define LOG_WARN(pszFmt)                    TRACELogPrint(TL_WARN, pszFmt)
#define LOG_WARN1(pszFmt, arg1)             TRACELogPrint(TL_WARN, pszFmt, arg1)
#define LOG_WARN2(pszFmt, arg1, arg2)       TRACELogPrint(TL_WARN, pszFmt, arg1, arg2)
#define LOG_WARN3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_WARN, pszFmt, arg1, arg2, arg3)

#define LOG_INFO(pszFmt)                    TRACELogPrint(TL_INFO, pszFmt)
#define LOG_INFO1(pszFmt, arg1)             TRACELogPrint(TL_INFO, pszFmt, arg1)
#define LOG_INFO2(pszFmt, arg1, arg2)       TRACELogPrint(TL_INFO, pszFmt, arg1, arg2)
#define LOG_INFO3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_INFO, pszFmt, arg1, arg2, arg3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\tracelog.cpp ===
#include "pch.h"
#pragma hdrstop
#include <stdio.h>
#include <stdarg.h>
#include "tracelog.h"

static DWORD  sg_dwTraceID = INVALID_TRACEID;
static char    sg_szTraceName[100];   // Used for OutputDebugString

DWORD   sg_dwTracingToDebugger = 0;  // call OutputDebugString
DWORD   sg_dwDebuggerMask      = 0;


inline const char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
//        case TL_TRACE: return "TRACE";
//        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}

BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "FileTracingMask";

    //
    // Register Tracing, this creates the registry entries 
    // (HKEY_LOCAL_MACHINE\Software\Microsoft\Tracing\"szName") 
    // (if they did not exist previously)
    //
    if ((sg_dwTraceID = TraceRegister(szName)) == INVALID_TRACEID) 
        return FALSE;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    return TRUE;
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{
    #define MAXDEBUGSTRINGLENGTH 1024
    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( dwDbgLevel & sg_dwDebuggerMask ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID && ( dwDbgLevel & sg_dwDebuggerMask ))
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\utils.h ===
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress);
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress);
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]);
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet);


BOOL IsContiguousSubnetMask (PCWSTR pszSubnet);

BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub);
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               OUT WCHAR * szMulticastIP, 
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\wlbs.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbs.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - main module implementing object

Author:

    kyrilf

--*/

#pragma once
#include "clusterdlg.h"
#include "host.h"
#include "wlbsparm.h"
#include "ports.h"
#include "resource.h"
#include "netcfgn.h"
#include "ncxclsid.h"
#include "wlbscfg.h"


class CWLBS :
    public CComObjectRoot,
    public CComCoClass<CWLBS, &CLSID_CWLBS>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
public:
    CWLBS(VOID);
    ~CWLBS(VOID);

    BEGIN_COM_MAP(CWLBS)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CWLBS)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_WLBS)

    // INetCfgComponentControl
    STDMETHOD (Initialize) (IN INetCfgComponent* pIComp, IN INetCfg* pINetCfg, IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (IN INetCfgPnpReconfigCallback * pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

    // INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile) (PCWSTR szAnswerFile, PCWSTR szAnswerSections);
    STDMETHOD (Upgrade) (DWORD, DWORD);
    STDMETHOD (Install) (DWORD);
    STDMETHOD (Removing) ();
    
    // INetCfgProperties
    STDMETHOD (QueryPropertyUi) (IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (IN OUT DWORD* pdwDefPages, OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate, IN HWND hwndParent, OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

private:
    class CDialogCluster * m_pClusterDlg;
    class CDialogHost * m_pHostDlg;
    class CDialogPorts * m_pPortsDlg;
    
    CWlbsConfig m_WlbsConfig;
    
    NETCFG_WLBS_CONFIG m_OriginalConfig;
    NETCFG_WLBS_CONFIG m_AdapterConfig;
    
    GUID m_AdapterGuid;

public:
    LRESULT OnInitDialog(IN HWND hWnd);
    LRESULT OnOk(IN HWND hWnd);
    LRESULT OnCancel(IN HWND hWnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\utils.cpp ===
#include "pch.h"
#pragma hdrstop

#include <winsock2.h>
#include "utils.h"

#define MAXIPSTRLEN 20

//+----------------------------------------------------------------------------
//
// Function:  IpAddressFromAbcdWsz
//
// Synopsis:Converts caller's a.b.c.d IP address string to a network byte order IP 
//          address. 0 if formatted incorrectly.    
//
// Arguments: IN const WCHAR*  wszIpAddress - ip address in a.b.c.d unicode string
//
// Returns:   DWORD - IPAddr, return INADDR_NONE on failure
//
// History:   fengsun Created Header    12/8/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress)
{   
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    DWORD  nboIpAddr;    

    ASSERT(lstrlen(wszIpAddress) < MAXIPSTRLEN);

    WideCharToMultiByte(CP_ACP, 0, wszIpAddress, -1, 
		    szIpAddress, sizeof(szIpAddress), NULL, NULL);

    nboIpAddr = inet_addr(szIpAddress);

    return(nboIpAddr);
}

//+----------------------------------------------------------------------------
//
// Function:  IpAddressToAbcdWsz
//
// Synopsis:  
//    Converts IpAddr to a string in the a.b.c.d form and returns same in 
//    caller's wszIpAddress buffer. The buffer should be at least 
//    MAXIPSTRLEN + 1 characters long.
//
// Arguments: IPAddr IpAddress - 
//            OUT WCHAR* wszIpAddress -  buffer at least MAXIPSTRLEN
//
// Returns:   void 
//
// History:   fengsun Created Header    12/21/98
//
//+----------------------------------------------------------------------------
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress)
{
    ASSERT(wszIpAddress);

    LPSTR AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    ASSERT(AnsiAddressString);

    if (AnsiAddressString == NULL)
    {
        lstrcpyW(wszIpAddress, L"");
        return ; 
    }


    MultiByteToWideChar(CP_ACP, 0, AnsiAddressString,  -1 , 
        wszIpAddress,  MAXIPSTRLEN + 1);
}

/*
 * Function: GetIPAddressOctets
 * Description: Turn an IP Address string into its 4 integer components.
 * Author: shouse 7.24.00
 */
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]) {
    DWORD dwIpAddr = IpAddressFromAbcdWsz(pszIpAddress);
    const BYTE * bp = (const BYTE *)&dwIpAddr;

    ardw[0] = (DWORD)bp[0];
    ardw[1] = (DWORD)bp[1];
    ardw[2] = (DWORD)bp[2];
    ardw[3] = (DWORD)bp[3];
}

/*
 * Function: IsValidIPAddressSubnetMaskPair
 * Description: Checks for valid IP address/netmask pairs.
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcperror.cpp
 */
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet) {
    BOOL fNoError = TRUE;
    DWORD ardwNetID[4];
    DWORD ardwHostID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetIPAddressOctets(szIp, ardwIp);
    GetIPAddressOctets(szSubnet, ardwMask);

    INT nFirstByte = ardwIp[0] & 0xFF;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 0.0.0.0
        ((ardwHostID[0] == 0) &&
         (ardwHostID[1] == 0) &&
         (ardwHostID[2] == 0) &&
         (ardwHostID[3] == 0)) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        fNoError = FALSE;
    }

    return fNoError;
}

/*
 * Function: IsContiguousSubnetMask
 * Description: Makes sure the netmask is contiguous
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcputil.cpp
 */
BOOL IsContiguousSubnetMask (PCWSTR pszSubnet) {
    DWORD ardwSubnet[4];

    GetIPAddressOctets(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
        + (ardwSubnet[2] << 8) + ardwSubnet[3];
    
    
    DWORD i, dwContiguousMask;
    
    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;

    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwContiguousMask |= 1 << i;
        
        if (dwContiguousMask & dwMask)
            break;
    }
    
    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  Params_ip2sub
//
// Description:  
//
// Arguments: WSTR          ip - 
//            PWSTR          sub - 
//
// Returns:   BOOL - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub) {
    DWORD               b [4];

    swscanf (ip, L"%d.%d.%d.%d", b, b+1, b+2, b+3);

    if ((b [0] >= 1) && (b [0] <= 126)) {
        b [0] = 255;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    } else if ((b [0] >= 128) && (b [0] <= 191)) {
        b [0] = 255;
        b [1] = 255;
        b [2] = 0;
        b [3] = 0;
    } else if ((b [0] >= 192) && (b [0] <= 223)) {
        b [0] = 255;
        b [1] = 255;
        b [2] = 255;
        b [3] = 0;
    } else {
        b [0] = 0;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    };

    swprintf (sub, L"%d.%d.%d.%d",
              b [0], b [1], b [2], b [3]);

    return((b[0] + b[1] + b[2] + b[3]) > 0);
}

/*
 * Function: ParamsGenerateMAC
 * Description: Calculate the generated field in the structure
 * History: fengsun Created 3.27.00
 *          shouse Modified 7.12.00 
 */
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               OUT WCHAR * szMulticastIP, 
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP) {
    DWORD dwIp;    
    const BYTE * bp;

    if (!fConvertMAC) return;

    /* Unicast mode. */
    if (!fMulticast) {
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        swprintf(szClusterMAC, L"02-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }

    /* Multicast without IGMP. */
    if (!fIGMP) {
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        swprintf(szClusterMAC, L"03-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }
    
    /* Multicast with IGMP. */
    if (fUseClusterIP) {
        /* 239.255.x.x */
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        dwIp = 239 + (255 << 8) + (dwIp & 0xFFFF0000);
        AbcdWszFromIpAddress(dwIp, szMulticastIP);
    }

    dwIp = IpAddressFromAbcdWsz(szMulticastIP);
    bp = (const BYTE*)&dwIp;
        
    swprintf(szClusterMAC, L"01-00-5e-%02x-%02x-%02x", (bp[1] & 0x7f), bp[2], bp[3]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\wlbscfg.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbscfg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - Provide the functionality of notifier object

Author:

    fengsun

--*/


#pragma once

#include <netcfgx.h>

#include "wlbsparm.h"

#define WLBS_MAX_PASSWORD 16

struct NETCFG_WLBS_PORT_RULE {
    TCHAR virtual_ip_addr [CVY_MAX_CL_IP_ADDR + 1]; // Virtual IP Address 
    DWORD start_port;             // Starting port number. 
    DWORD end_port;               // Ending port number. 
    DWORD mode;                   // Filtering mode. WLBS_PORT_RULE_XXXX 
    DWORD protocol;               // WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP 

    union {
        struct {
            DWORD priority;       // Mastership priority: 1..32 or 0 for not-specified. 
        } single;                 // Data for single server mode. 

        struct {
            WORD equal_load;      // TRUE - Even load distribution. 
            WORD affinity;        // WLBS_AFFINITY_XXX 
            DWORD load;           // Percentage of load to handle locally 0..100. 
        } multi;                  // Data for multi-server mode. 

    } mode_data;                  // Data for appropriate port group mode. 
};

struct NETCFG_WLBS_CONFIG {
    DWORD dwHostPriority;                             // Host priority ID.
    bool fRctEnabled;                                 // TRUE - remote control enabled. 
    bool fJoinClusterOnBoot;                          // TRUE - join cluster on boot.
    bool fMcastSupport;                               // TRUE - multicast mode, FALSE - unicast mode.
    bool fIGMPSupport;                                // TRUE - IGMP enabled.
    bool fIpToMCastIp;                                // TRUE - derive multicast IP from cluster IP.

    WCHAR szMCastIpAddress[CVY_MAX_CL_IP_ADDR + 1];   // The multicast IP address, if user-specified.
    TCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];      // Cluster MAC address.
    TCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];         // Cluster IP address.
    TCHAR cl_net_mask[CVY_MAX_CL_NET_MASK + 1];       // Netmask for cluster IP.
    TCHAR ded_ip_addr[CVY_MAX_DED_IP_ADDR + 1];       // Dedicated IP address or "" for none.
    TCHAR ded_net_mask[CVY_MAX_DED_NET_MASK + 1];     // Netmask for dedicated IP address or "" for none.
    TCHAR domain_name[CVY_MAX_DOMAIN_NAME + 1];       // Full Qualified Domain Name of the cluster. 

    bool fChangePassword;                             // Whether to change password, valid for SetAdapterConfig only.
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];           // Remote control password, valid for SetAdapterConfig only.

    bool fConvertMac;                                 // Whether the mac address is generated from IP.
    DWORD dwMaxHosts;                                 // Maximum # hosts allowed.
    DWORD dwMaxRules;                                 // Maximum # port group rules allowed.
    
    DWORD dwNumRules;                                 // # active port group rules 
    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];  // Port rules
};

class CNetcfgCluster;
struct WlbsApiFuncs;

//+----------------------------------------------------------------------------
//
// class CWlbsConfig
//
// Description: Provide the functionality for the notifier object.
//              It would be used by TCPIP notifier if WLBS UI merged with TCPIP
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------

class CWlbsConfig
{
public:
    CWlbsConfig(VOID);
    ~CWlbsConfig(VOID);

    STDMETHOD (Initialize) (IN INetCfg* pINetCfg, IN BOOL fInstalling);
    STDMETHOD (ReadAnswerFile) (PCWSTR szAnswerFile, PCWSTR szAnswerSections);
    STDMETHOD (Upgrade) (DWORD, DWORD);
    STDMETHOD (Install) (DWORD);
    STDMETHOD (Removing) ();
    STDMETHOD (QueryBindingPath) (DWORD dwChangeFlag, INetCfgComponent * pAdapter);
    STDMETHOD (NotifyBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath * pncbp);
    STDMETHOD (GetAdapterConfig) (const GUID & AdapterGuid, NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD (SetAdapterConfig) (const GUID & AdapterGuid, NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD_(void, SetDefaults) (NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) ();
    STDMETHOD (ValidateProperties) (HWND hwndSheet, GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig);
    STDMETHOD (CheckForDuplicateCLusterIPAddresses) (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig);

#ifdef DEBUG
    void AssertValid();
#endif

protected:
    CNetcfgCluster * GetCluster (const GUID& AdapterGuid);
    HRESULT LoadAllAdapterSettings (bool fUpgradeFromWin2k);

    vector<CNetcfgCluster*> m_vtrCluster; // List of clusters.
    HANDLE m_hDeviceWlbs;                 // Handle to the WLBS device object.

    enum ENUM_WLBS_SERVICE {
        WLBS_SERVICE_NONE, 
        WLBS_SERVICE_INSTALL, 
        WLBS_SERVICE_REMOVE,
        WLBS_SERVICE_UPGRADE
    };

    ENUM_WLBS_SERVICE m_ServiceOperation; // Operations to be applied
    INetCfgComponent * m_pWlbsComponent;  // Wlbs Component.

public:
    HRESULT IsBoundTo (INetCfgComponent* pAdapter);

    //
    // To avoid link with wlbsctrl.dll, which only shiped in adavanced server
    // Can not put them as global variables, because multiple instance of this
    // object could exist
    //
    INetCfg * m_pNetCfg;        
    HINSTANCE m_hdllWlbsCtrl;
    WlbsApiFuncs * m_pWlbsApiFuncs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\wlbs.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbs.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - main module implementing object

Author:

    kyrilf

--*/

#include "pch.h"
#pragma hdrstop
#include "netcon.h"
#include "ncatlui.h"
#include "ndispnp.h"
#include "ncsetup.h"
#include "wlbs.h"
#include "help.h"
#include "tracelog.h"
#include "wlbs.tmh" // for event tracing

// ----------------------------------------------------------------------
//
// Function:  CWLBS::CWLBS
//
// Purpose:   constructor for class CWLBS
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWLBS::CWLBS(VOID) {
    
    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));
    ZeroMemory(&m_OriginalConfig, sizeof(m_OriginalConfig));
    ZeroMemory(&m_AdapterConfig, sizeof(m_AdapterConfig));

    //
    // Register tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB");
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::~CWLBS
//
// Purpose:   destructor for class CWLBS
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWLBS::~CWLBS(VOID) {

    if (m_pClusterDlg != NULL) delete m_pClusterDlg;
    if (m_pHostDlg != NULL) delete m_pHostDlg;
    if (m_pPortsDlg != NULL) delete m_pPortsDlg;

    //
    // DeRegister tracing
    //
    WPP_CLEANUP();;
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CWLBS::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Initialize(INetCfgComponent* pnccItem, INetCfg* pINetCfg, BOOL fInstalling) {
    TRACE_VERB("<->%!FUNC!");    
    return m_WlbsConfig.Initialize(pINetCfg, fInstalling);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure WLBS
//
// Arguments:
//    pszAnswerFile     [in]  name of AnswerFile
//    pszAnswerSection  [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ReadAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ReadAnswerFile(pszAnswerFile, pszAnswerSection);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Install(DWORD dw) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Install(dw);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Upgrade
//
// Purpose:   Do operations necessary for upgrade.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Upgrade(DWORD dw1, DWORD dw2) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Upgrade(dw1, dw2);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Removing(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Removing();
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Validate
//
// Purpose:   Do necessary parameter validation
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Validate() {
    TRACE_VERB("<->%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Cancel
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::CancelChanges(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyRegistryChanges(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ApplyRegistryChanges();
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Propagate changes to the driver.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyPnpChanges(INetCfgPnpReconfigCallback* pICallback) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ApplyPnpChanges();
}

// =================================================================
// INetCfgBindNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CWLBS::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::QueryBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");

    INetCfgComponent* pAdapter = NULL;

    HRESULT hr = HrGetLastComponentAndInterface (pncbp, &pAdapter, NULL);
    
    if (SUCCEEDED(hr) && pAdapter) {
        TRACE_INFO("%!FUNC! get last component succeeded");
        hr = m_WlbsConfig.QueryBindingPath(dwChangeFlag, pAdapter);
        pAdapter->Release();
		if (FAILED(hr))
		{
            TRACE_CRIT("%!FUNC! failed to query binding path with %d", hr);
		}
		else
		{
            TRACE_INFO("%!FUNC! query binding path succeeded");
		}
    }
	else {
        TRACE_CRIT("%!FUNC! failed on get last component with %d", hr);
	}

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::NotifyBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.NotifyBindingPath(dwChangeFlag, pncbp);
}

// =================================================================
// INetCfgProperties
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CWLBS::SetContext
//
// Purpose:   
//
// Arguments:
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::SetContext(IUnknown * pUnk) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;

    if (pUnk) { 
        INetLanConnectionUiInfo * pLanConnUiInfo;

        /* Set the new context.  Here we assume that we are going to be called only for
           a LAN connection since the sample IM works only with LAN devices. */
        hr = pUnk->QueryInterface(IID_INetLanConnectionUiInfo, reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        if (SUCCEEDED(hr)) {
            hr = pLanConnUiInfo->GetDeviceGuid(&m_AdapterGuid);
            ReleaseObj(pLanConnUiInfo);
            TRACE_INFO("%!FUNC! query interface succeeded");
        } else {
            TraceError("CWLBS::SetContext called for non-lan connection", hr);
            TRACE_INFO("%!FUNC! query interface failed with %d", hr);
            return hr;
        }
    } else {
        /* Clear context. */
        ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));
        TRACE_INFO("%!FUNC! clearing context");
    }

    /* If S_OK is not returned, the property page will not be displayed. */
    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::MergePropPages
//
// Purpose:   Supply our property page to system
//
// Arguments:
//    pdwDefPages   [out]  pointer to num default pages
//    pahpspPrivate [out]  pointer to array of pages
//    pcPages       [out]  pointer to num pages
//    hwndParent    [in]   handle of parent window
//    szStartPage   [in]   pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::MergePropPages(DWORD* pdwDefPages, LPBYTE* pahpspPrivate, UINT* pcPages, HWND hwndParent, PCWSTR* pszStartPage) {
    TRACE_VERB("->%!FUNC!");
    HPROPSHEETPAGE * ahpsp = NULL;
    HRESULT hr = S_OK;;

    /* We don't want any default pages to be shown. */
    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc(3 * sizeof(HPROPSHEETPAGE));

    if (m_pClusterDlg != NULL) {
        delete m_pClusterDlg;
        m_pClusterDlg = NULL;
    }

    if (m_pHostDlg != NULL) {
        delete m_pHostDlg;
        m_pHostDlg = NULL;
    }

    if (m_pPortsDlg != NULL) {
        delete m_pPortsDlg;
        m_pPortsDlg = NULL;
    }

    if (ahpsp) {
        /* Get the cached configuration. */
        if (FAILED (hr = m_WlbsConfig.GetAdapterConfig(m_AdapterGuid, &m_OriginalConfig))) {
            TraceError("CWLBS::MergePropPages failed to query cluster config", hr);
            m_WlbsConfig.SetDefaults(&m_OriginalConfig);
            TRACE_CRIT("%!FUNC! failed in query to cluster configuration with %d", hr);
        }
		else
		{
            TRACE_INFO("%!FUNC! successfully retrieved the cached configuration");
		}

        /* Copy the configuration into the "current" config. */
        CopyMemory(&m_AdapterConfig, &m_OriginalConfig, sizeof(m_OriginalConfig));

        m_pClusterDlg = new CDialogCluster(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_CLUSTER);
		if (NULL == m_pClusterDlg)
		{
            TRACE_CRIT("%!FUNC! memory allocation failure for cluster page dialog");
		}
        ahpsp[0] = m_pClusterDlg->CreatePage(IDD_DIALOG_CLUSTER, 0);

        m_pHostDlg = new CDialogHost(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_HOST);
		if (NULL == m_pHostDlg)
		{
            TRACE_CRIT("%!FUNC! memory allocation failure for host page dialog");
		}
        ahpsp[1] = m_pHostDlg->CreatePage(IDD_DIALOG_HOST, 0);

        m_pPortsDlg = new CDialogPorts(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_PORTS);
		if (NULL == m_pPortsDlg)
		{
            TRACE_CRIT("%!FUNC! memory allocation failure for ports page dialog");
		}
        ahpsp[2] = m_pPortsDlg->CreatePage(IDD_DIALOG_PORTS, 0);

        *pcPages = 3;
        *pahpspPrivate = (LPBYTE)ahpsp;
    }
	else
	{
        TRACE_CRIT("%!FUNC! CoTaskMemAlloc failed");
	}

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ValidateProperties
//
// Purpose:   Validate changes to property page
//
// Arguments:
//    hwndSheet [in]  window handle of property sheet
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ValidateProperties(HWND hwndSheet) {
    TRACE_VERB("->%!FUNC!");
    NETCFG_WLBS_CONFIG adapterConfig;

    /* Make a copy of our config.  It is voodoo to pass a pointer to 
       a private date member, so we make a copy instead. */
    CopyMemory(&adapterConfig, &m_AdapterConfig, sizeof(m_AdapterConfig));

    TRACE_VERB("<-%!FUNC!");
    return m_WlbsConfig.ValidateProperties(hwndSheet, m_AdapterGuid, &adapterConfig);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::CancelProperties
//
// Purpose:   Cancel changes to property page
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::CancelProperties(VOID) {
    TRACE_VERB("->%!FUNC!");

    delete m_pClusterDlg;
    delete m_pHostDlg;
    delete m_pPortsDlg;

    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyProperties
//
// Purpose:   Apply value of controls on property page
//            to internal memory structure
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We do this work in OnOk so no need to do it here again.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyProperties(VOID) {
    TRACE_VERB("->%!FUNC!");

    /* If the cluster IP address / subnet mask or the dedicated IP address / subnet mask has changed in this 
       configuration session, remind the user that they have to enter this address in TCP/IP properties as well. */
    if (wcscmp(m_OriginalConfig.cl_ip_addr, m_AdapterConfig.cl_ip_addr) || 
        wcscmp(m_OriginalConfig.cl_net_mask, m_AdapterConfig.cl_net_mask) ||
        wcscmp(m_OriginalConfig.ded_ip_addr, m_AdapterConfig.ded_ip_addr) || 
        wcscmp(m_OriginalConfig.ded_net_mask, m_AdapterConfig.ded_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_INFORMATION, IDS_PARM_TCPIP, MB_APPLMODAL | MB_ICONINFORMATION | MB_OK);
        TRACE_INFO("%!FUNC! vip and/or dip ip settings were modified");
    }

    /* Commit the configuration. */
    DWORD dwStatus = m_WlbsConfig.SetAdapterConfig(m_AdapterGuid, &m_AdapterConfig);
	if (S_OK != dwStatus)
	{
        TRACE_CRIT("%!FUNC! call to set the adapter configuration failed with %d", dwStatus);
	}
	else
	{
        TRACE_INFO("%!FUNC! call to set the adapter configuration succeeded");
	}

    delete m_pClusterDlg;
    delete m_pHostDlg;
    delete m_pPortsDlg;

    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\cmsabcon.h ===
#pragma once

#include "nmbase.h"

class ATL_NO_VTABLE CSharedAccessBeacon :
    public CComObjectRootEx <CComMultiThreadModel>,
    public ISharedAccessBeacon
{

public:
    BEGIN_COM_MAP(CSharedAccessBeacon)
        COM_INTERFACE_ENTRY(ISharedAccessBeacon)
    END_COM_MAP()
    
    CSharedAccessBeacon();
    
    // ISharedAccessBeacon
    STDMETHODIMP GetMediaType(NETCON_MEDIATYPE* pMediaType);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService**);
    STDMETHODIMP GetUniqueDeviceName(BSTR* pUniqueDeviceName);

    HRESULT SetMediaType(NETCON_MEDIATYPE MediaType);
    HRESULT SetLocalAdapterGUID(GUID* pGuid);
    HRESULT SetService(ULONG ulService, IUPnPService* pService);
    HRESULT SetUniqueDeviceName(BSTR UniqueDeviceName);
    HRESULT FinalRelease();
private:
    
    NETCON_MEDIATYPE m_MediaType;
    GUID m_LocalAdapterGUID;
    IUPnPService* m_Services[SAHOST_SERVICE_MAX];
    BSTR m_UniqueDeviceName;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\cmsaclbk.cpp ===
#include "pch.h"
#pragma hdrstop
#include "cmsaclbk.h"
#include "cmsabcon.h"
#include "saconob.h"
#include "ncnetcon.h"

static const LPWSTR g_szWANIPConnectionService = L"urn:schemas-upnp-org:service:WANIPConnection:1";
static const LPWSTR g_szWANPPPConnectionService = L"urn:schemas-upnp-org:service:WANPPPConnection:1";

CSharedAccessDeviceFinderCallback::CSharedAccessDeviceFinderCallback()
{
    m_pSharedAccessBeacon = NULL;
}

HRESULT CSharedAccessDeviceFinderCallback::FinalRelease()
{
    if(NULL != m_pSharedAccessBeacon)
    {
        m_pSharedAccessBeacon->Release();
    }

    return S_OK;
}

HRESULT CSharedAccessDeviceFinderCallback::GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;
    
    Lock();
    
    if(NULL != m_pSharedAccessBeacon)
    {
        *ppSharedAccessBeacon = m_pSharedAccessBeacon;
        m_pSharedAccessBeacon->AddRef();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    Unlock();

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::DeviceAdded(LONG lFindData, IUPnPDevice* pDevice)
{
    return E_UNEXPECTED;
}

#include <wininet.h>
#include <iphlpapi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
void GetGUIDFromString (char * szAdapterName, GUID * pGuid)
{
    USES_CONVERSION;
    CLSIDFromString (A2OLE(szAdapterName), (CLSID*)pGuid);
}
static BOOL IsIPAddress (LPWSTR szAddress)
{
    USES_CONVERSION;
    return INADDR_NONE != inet_addr (W2A (szAddress));
}
static BOOL IsIPAddressDefaultGateway (IP_ADDRESS_STRING * pIPAddress, GUID* pguidInterface)
{   // return TRUE iff the IP address matches the specified NIC's GW.

    BOOL b = FALSE;

    // run through adapters 
    ULONG ulSize = 0;
    DWORD dwErr = GetAdaptersInfo ((PIP_ADAPTER_INFO)&ulSize, &ulSize);
    if (dwErr == ERROR_BUFFER_OVERFLOW) {
        BYTE * pb = new BYTE[ulSize];
        if (pb) {
            PIP_ADAPTER_INFO pai = (PIP_ADAPTER_INFO)pb;
            dwErr = GetAdaptersInfo (pai, &ulSize);
            if (dwErr == NO_ERROR) {
                do {
                    GUID guid = {0};
                    GetGUIDFromString (pai->AdapterName, &guid);
                    if (IsEqualGUID(*pguidInterface, guid)) {
                        // found our adapter.

                        // let's see if the default gateways match our IP address
                        IP_ADDR_STRING* pDG = &pai->GatewayList;
                        if (pDG) {
                            do {
                                if (!strcmp (pDG->IpAddress.String, pIPAddress->String)) {
                                    b = TRUE;
                                    break;
                                }
                            } while (pDG = pDG->Next);
                        }
                        break;
                    }
                } while (pai = pai->Next);
            }
            delete[] pb;
        }
    }
    return b;
}
static HRESULT CheckDeviceDocumentAgainstDefaultGateway (IUPnPDevice* pDevice, GUID* pguidInterface)
{
    // bug 561076
    // [Ravi Rao] On XP, you can use IUPnPDeviceDocumentAccess to get the
    // documentURL from the IGD device object. Crack this URL to get the
    // IP address or name. Check if the IP address matches the plumbed
    // gateway, or if there is a name, resolve the name and check if the
    // one of the resolved addresses matches.

//  DebugBreak();

    CComPtr<IUPnPDeviceDocumentAccess> spDDA = NULL;
    HRESULT hr = pDevice->QueryInterface (__uuidof(IUPnPDeviceDocumentAccess), (void**)&spDDA);
    if (spDDA) {

        // get the description doc's URL
        CComBSTR cbDocumentURL;
        hr = spDDA->GetDocumentURL (&cbDocumentURL);
        if (SUCCEEDED(hr)) {

            // crack the URL
            WCHAR szAddress[INTERNET_MAX_HOST_NAME_LENGTH+1] = {0};

            URL_COMPONENTS uc   = {0};
            uc.dwStructSize     = sizeof(uc);
            uc.lpszHostName     = szAddress;
            uc.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

            BOOL b = InternetCrackUrlW(cbDocumentURL,
                                       wcslen (cbDocumentURL),
                                       0,
                                       &uc);
            if (b == FALSE)
                hr = E_FAIL;
            else {
                USES_CONVERSION;

                // convert to IP_ADDRESS_STRING
                IP_ADDRESS_STRING IPAddress = {0};
                if (IsIPAddress (szAddress) == TRUE) {
                    // we have an IP address
                    strncpy (IPAddress.String, W2A (szAddress), sizeof(IPAddress.String));

                    // test it against this NIC's default gateway(s)
                    if (FALSE == IsIPAddressDefaultGateway (&IPAddress, pguidInterface))
                        hr = E_FAIL;
                } else {
                    hr = E_FAIL;    // default is failure

                    // we have a DNS name:  convert to IP address(es)
                    struct addrinfo * pai = NULL;
                    if (0 == getaddrinfo (W2A (szAddress), NULL, NULL, &pai)) {

                        // could have > 1 ip addresses;  unlikely, but try them all.
                        addrinfo * pai2 = pai;
                        do {
                            if (pai2->ai_addr && pai2->ai_addrlen) {
                                IPAddress.String[0] = 0;
                                getnameinfo (pai2->ai_addr,
                                             pai2->ai_addrlen,
                                             (char*)&IPAddress.String,
                                             sizeof(IPAddress.String)/sizeof(IPAddress.String[0]),
                                             NULL,
                                             0,
                                             NI_NUMERICHOST);
                                if (IPAddress.String[0]) {
                                    // try this one
                                    if (TRUE == IsIPAddressDefaultGateway (&IPAddress, pguidInterface)) {
                                        hr = S_OK;
                                        break;
                                    }
                                }
                            }
                        } while (pai2 = pai2->ai_next);
                        freeaddrinfo (pai);
                    }
                }
            }
        }
    }
    return hr;
}
HRESULT CSharedAccessDeviceFinderCallback::DeviceAddedWithInterface(LONG lFindData, IUPnPDevice* pDevice, GUID* pguidInterface)
{
    HRESULT hr = S_OK;

    if(IsEqualGUID(*pguidInterface, IID_NULL))
    {
#ifndef SHOW_SELF
        hr = E_FAIL;
#endif
    }

    // bug 561076
    if (SUCCEEDED(hr))
        hr = CheckDeviceDocumentAgainstDefaultGateway (pDevice, pguidInterface);

    if(SUCCEEDED(hr))
    {
        ISharedAccessBeacon* pSharedAccessBeacon;
        hr = GetServices(pDevice, pguidInterface, &pSharedAccessBeacon);
        if(SUCCEEDED(hr))
        {
            CComObject<CSharedAccessConnectionEventSink>* pSplitEventSink;
            hr = CComObject<CSharedAccessConnectionEventSink>::CreateInstance(&pSplitEventSink);
            if(SUCCEEDED(hr))
            {
                pSplitEventSink->AddRef();

                NETCON_MEDIATYPE MediaType;
                hr = pSharedAccessBeacon->GetMediaType(&MediaType);
                if(SUCCEEDED(hr))
                {
                    IUPnPService* pWANConnection;
                    hr = pSharedAccessBeacon->GetService(NCM_SHAREDACCESSHOST_LAN == MediaType ? SAHOST_SERVICE_WANIPCONNECTION : SAHOST_SERVICE_WANPPPCONNECTION, &pWANConnection);
                    if(SUCCEEDED(hr))
                    {
                        hr = pWANConnection->AddCallback(pSplitEventSink);
                        pWANConnection->Release();
                    }
                }
                pSplitEventSink->Release();
            }

            if(SUCCEEDED(hr))
            {

                ISharedAccessBeacon* pSharedAccessBeaconToRelease;
                
                Lock();
                
                pSharedAccessBeaconToRelease = m_pSharedAccessBeacon;
                m_pSharedAccessBeacon = pSharedAccessBeacon;
                m_pSharedAccessBeacon->AddRef();
                
                Unlock();

                if(NULL != pSharedAccessBeaconToRelease)
                {
                    pSharedAccessBeaconToRelease->Release();
                }
                
                CComObject<CSharedAccessConnection>* pSharedAccessConnection; // does this need to be under the lock?
                hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
                if(SUCCEEDED(hr))
                {
                    pSharedAccessConnection->AddRef();
                    
                    INetConnectionRefresh* pNetConnectionRefresh;
                    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                    if(SUCCEEDED(hr))
                    {
                        pNetConnectionRefresh->ConnectionDeleted(&CLSID_SharedAccessConnection);
                        pNetConnectionRefresh->ConnectionAdded(pSharedAccessConnection);
                        pNetConnectionRefresh->Release();
                    }
                    
                    pSharedAccessConnection->Release();
                }
            }

            pSharedAccessBeacon->Release();
        }
    }

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::DeviceRemoved(LONG lFindData, BSTR bstrUDN)
{
    HRESULT hr = S_OK;

    ISharedAccessBeacon* pSharedAccessBeaconToRelease = NULL;
    
    Lock();
    
    if(NULL != m_pSharedAccessBeacon)
    {
        BSTR UniqueDeviceName;
        hr = m_pSharedAccessBeacon->GetUniqueDeviceName(&UniqueDeviceName); // only remove the deivce if it matches
        if(SUCCEEDED(hr))
        {
            if(NULL == bstrUDN || 0 == lstrcmp(UniqueDeviceName, bstrUDN))
            {
                pSharedAccessBeaconToRelease = m_pSharedAccessBeacon;
                m_pSharedAccessBeacon = NULL;
            }
            SysFreeString(UniqueDeviceName);
        }
    }
    
    Unlock();

    if(NULL != pSharedAccessBeaconToRelease)
    {
        pSharedAccessBeaconToRelease->Release();
        INetConnectionRefresh* pNetConnectionRefresh;
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        if(SUCCEEDED(hr))
        {
            pNetConnectionRefresh->ConnectionDeleted(&CLSID_SharedAccessConnection);
            pNetConnectionRefresh->Release();
        }
    }
    

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::SearchComplete(LONG lFindData)
{
    HRESULT hr = S_OK;

    // don't care

    return hr;
}



HRESULT CSharedAccessDeviceFinderCallback::FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindDevice(pDevices, pszDeviceType, ppChildDevice);
        pDevices->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindChildDevice");

    return hr;
}


HRESULT CSharedAccessDeviceFinderCallback::FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    *ppChildDevice = NULL;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);

    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;

            VariantInit(&DeviceVariant);

            pVariantEnumerator->Reset();

            // Traverse the collection.

            while (NULL == *ppChildDevice && S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;

                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    BSTR Type;
                    hr = pDevice->get_Type(&Type);
                    if(SUCCEEDED(hr))
                    {
                        if(0 == lstrcmp(Type, pszDeviceType))
                        {
                            *ppChildDevice = pDevice;
                            pDevice->AddRef();

                        }
                        SysFreeString(Type);
                    }
                    pDevice->Release();
                }
                VariantClear(&DeviceVariant);
            };

            if(NULL == *ppChildDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindDevice");

    return hr;


}

HRESULT CSharedAccessDeviceFinderCallback::FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;

    *ppICSService = NULL;

    IUPnPServices* pServices;
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
        IUnknown* pEnumerator;
        hr = pServices->get__NewEnum(&pEnumerator);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT* pVariantEnumerator;
            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
            if (SUCCEEDED(hr))
            {
                VARIANT ServiceVariant;

                VariantInit(&ServiceVariant);

                while (NULL == *ppICSService && S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
                {
                    IDispatch   * pServiceDispatch = NULL;
                    IUPnPService * pService = NULL;

                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
                    if (SUCCEEDED(hr))
                    {
                        BOOL bMatch;
                        hr = IsServiceMatch(pService, pszServiceName, &bMatch);
                        if(SUCCEEDED(hr) && TRUE == bMatch)
                        {
                            *ppICSService = pService;
                            pService->AddRef();
                        }
                        pService->Release();
                    }
                    VariantClear(&ServiceVariant);
                }
                if(NULL == *ppICSService)
                {
                    hr = E_FAIL;
                }
                pVariantEnumerator->Release();
            }
            pEnumerator->Release();
        }
        pServices->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindService");

    return hr;
}


HRESULT CSharedAccessDeviceFinderCallback::GetServices(IUPnPDevice* pDevice, GUID* pInterfaceGUID, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;

    CComObject<CSharedAccessBeacon>* pSharedAccessBeacon;
    hr = CComObject<CSharedAccessBeacon>::CreateInstance(&pSharedAccessBeacon);
    if(SUCCEEDED(hr))
    {
        pSharedAccessBeacon->AddRef();

        BSTR pUniqueDeviceName;
        hr = pDevice->get_UniqueDeviceName(&pUniqueDeviceName);
        if(SUCCEEDED(hr))
        {
            hr = pSharedAccessBeacon->SetUniqueDeviceName(pUniqueDeviceName);
            SysFreeString(pUniqueDeviceName);
        }
        
        if(SUCCEEDED(hr))
        {
        
            pSharedAccessBeacon->SetLocalAdapterGUID(pInterfaceGUID);
            
            IUPnPService* pOSInfoService;
            hr = FindService(pDevice, L"urn:schemas-microsoft-com:service:OSInfo:1", &pOSInfoService); // this service is not required
            if(SUCCEEDED(hr))
            {
                pSharedAccessBeacon->SetService(SAHOST_SERVICE_OSINFO, pOSInfoService);
                pOSInfoService->Release();
            }
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pDevice, L"urn:schemas-upnp-org:device:WANDevice:1", &pWANDevice);
            if(SUCCEEDED(hr))
            {
                
                IUPnPService* pWANCommonInterfaceConfigService;
                hr = FindService(pWANDevice, L"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1", &pWANCommonInterfaceConfigService);
                if(SUCCEEDED(hr))
                {
                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, pWANCommonInterfaceConfigService);
                    
                    IUPnPDevice* pWANCommonDevice;
                    hr = FindChildDevice(pWANDevice, L"urn:schemas-upnp-org:device:WANConnectionDevice:1", &pWANCommonDevice);
                    if(SUCCEEDED(hr))
                    {
                        IUPnPService* pWANConnectionService;
                        hr = FindService(pWANCommonDevice, NULL, &pWANConnectionService);
                        if(SUCCEEDED(hr))
                        {
                            BSTR ServiceType;
                            hr = pWANConnectionService->get_ServiceTypeIdentifier(&ServiceType);
                            if(SUCCEEDED(hr))
                            {
                                if(0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
                                {
                                    pSharedAccessBeacon->SetMediaType(NCM_SHAREDACCESSHOST_RAS);
                                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANPPPCONNECTION, pWANConnectionService);
                                }
                                else // we can assume this is WANIPConnectionService
                                {
                                    pSharedAccessBeacon->SetMediaType(NCM_SHAREDACCESSHOST_LAN);
                                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANIPCONNECTION, pWANConnectionService);
                                }
                                
                                SysFreeString(ServiceType);
                            }
                            pWANConnectionService->Release();
                        }
                        pWANCommonDevice->Release();
                    }
                    pWANCommonInterfaceConfigService->Release();
                }
                pWANDevice->Release();
            }
        }
        if(SUCCEEDED(hr))
        {
            *ppSharedAccessBeacon = static_cast<ISharedAccessBeacon*>(pSharedAccessBeacon);
            (*ppSharedAccessBeacon)->AddRef();
        }
        pSharedAccessBeacon->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::GetServices");

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch)
{
    HRESULT hr = S_OK;

    *pbMatch = FALSE;
    
    BSTR ServiceType;
    hr = pService->get_ServiceTypeIdentifier(&ServiceType);
    if(SUCCEEDED(hr))
    {
        if(NULL != SearchCriteria) // if the caller provides a name then we search for it
        {
            if(0 == wcscmp(ServiceType, SearchCriteria))
            {
                *pbMatch = TRUE;
            }                            
        }
        else // otherwise we enter the special search case
        {
            if(0 == wcscmp(ServiceType, g_szWANIPConnectionService) || 0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
            {
                VARIANT OutArgsGetConnectionTypeInfo;
                hr = InvokeVoidAction(pService, L"GetConnectionTypeInfo", &OutArgsGetConnectionTypeInfo);
                if(SUCCEEDED(hr))
                {
                    VARIANT ConnectionType;
                    LONG lIndex = 0;
                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetConnectionTypeInfo), &lIndex, &ConnectionType);
                    if(SUCCEEDED(hr))
                    {
                        if(V_VT(&ConnectionType) == VT_BSTR)
                        {
                            if(0 == wcscmp(V_BSTR(&ConnectionType), L"IP_Routed"))
                            {
                                VARIANT OutArgsGetNATRSIPStatus;
                                hr = InvokeVoidAction(pService, L"GetNATRSIPStatus", &OutArgsGetNATRSIPStatus);
                                if(SUCCEEDED(hr))
                                {
                                    VARIANT NATEnabled;
                                    lIndex = 1;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetNATRSIPStatus), &lIndex, &NATEnabled);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&NATEnabled) == VT_BOOL)
                                        {
                                            if(VARIANT_TRUE == V_BOOL(&NATEnabled))
                                            {
                                                *pbMatch = TRUE;
                                            }
                                        }
                                        VariantClear(&NATEnabled);
                                    }
                                    VariantClear(&OutArgsGetNATRSIPStatus);
                                }
                            }
                        }
                        VariantClear(&ConnectionType);
                    }
                    VariantClear(&OutArgsGetConnectionTypeInfo);
                }
            }
        }
        SysFreeString(ServiceType);
    }

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;

    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName;
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }

        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnection::GetStringStateVariable");
    return hr;

}

HRESULT CSharedAccessConnectionEventSink::StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{

    HRESULT hr = S_OK;

    if(0 == lstrcmp(pcwszStateVarName, L"ConnectionStatus"))
    {
        CComObject<CSharedAccessConnection>* pSharedAccessConnection;
        hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
        if(SUCCEEDED(hr))
        {
            pSharedAccessConnection->AddRef();

            NETCON_PROPERTIES* pProperties;
            hr = pSharedAccessConnection->GetProperties(&pProperties);
            if(SUCCEEDED(hr))
            {
                INetConnectionRefresh* pNetConnectionRefresh;
                hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                if(SUCCEEDED(hr))
                {
                    pNetConnectionRefresh->ConnectionStatusChanged(&CLSID_SharedAccessConnection, pProperties->Status);
                    pNetConnectionRefresh->Release();
                }
                FreeNetconProperties(pProperties);    
            }
            pSharedAccessConnection->Release();
        }
    }
    else if(0 == lstrcmp(pcwszStateVarName, L"X_Name"))
    {
        CComObject<CSharedAccessConnection>* pSharedAccessConnection;
        hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
        if(SUCCEEDED(hr))
        {
            pSharedAccessConnection->AddRef();

            INetConnectionRefresh* pNetConnectionRefresh;
            hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
            if(SUCCEEDED(hr))
            {
                pNetConnectionRefresh->ConnectionRenamed(pSharedAccessConnection);
                pNetConnectionRefresh->Release();
            }
            
            pSharedAccessConnection->Release();
        }
    }

    return hr;
}

HRESULT CSharedAccessConnectionEventSink::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\cmsabcon.cpp ===
#include "pch.h"
#pragma hdrstop
#include "cmsabcon.h"

CSharedAccessBeacon::CSharedAccessBeacon()
{
    m_MediaType = NCM_NONE;
    ZeroMemory(&m_LocalAdapterGUID, sizeof(m_LocalAdapterGUID));
    ZeroMemory(&m_Services, sizeof(m_Services));
    m_UniqueDeviceName = NULL;
}

HRESULT CSharedAccessBeacon::FinalRelease()
{
    for(int i = 0; i < SAHOST_SERVICE_MAX; i++)
    {
        if(NULL != m_Services[i])
        {
            ReleaseObj(m_Services[i]);
        }
    }

    SysFreeString(m_UniqueDeviceName);

    return S_OK;
}

HRESULT CSharedAccessBeacon::SetMediaType(NETCON_MEDIATYPE MediaType)
{
    m_MediaType = MediaType;
    return S_OK;
}

HRESULT CSharedAccessBeacon::SetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(&m_LocalAdapterGUID, pGuid, sizeof(GUID));
    return S_OK;
}

HRESULT CSharedAccessBeacon::SetService(ULONG ulService, IUPnPService* pService)
{
    HRESULT hr = S_OK;
    if(SAHOST_SERVICE_MAX > ulService && NULL == m_Services[ulService])
    {
        m_Services[ulService] = pService;
        pService->AddRef();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSharedAccessBeacon::SetUniqueDeviceName(BSTR UniqueDeviceName)
{
    HRESULT hr = S_OK;

    m_UniqueDeviceName = SysAllocString(UniqueDeviceName);
    if(NULL == m_UniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSharedAccessBeacon::GetMediaType(NETCON_MEDIATYPE* pMediaType)
{
    *pMediaType = m_MediaType;
    return S_OK;
}

HRESULT CSharedAccessBeacon::GetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(pGuid, &m_LocalAdapterGUID, sizeof(GUID));
    return S_OK;
}

HRESULT CSharedAccessBeacon::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    HRESULT hr = S_OK;

    *ppService = NULL;

    if(SAHOST_SERVICE_MAX > ulService)
    {
        *ppService = m_Services[ulService];
        if(NULL != *ppService)
        {
            (*ppService)->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CSharedAccessBeacon::GetUniqueDeviceName(BSTR* pUniqueDeviceName)
{
    HRESULT hr = S_OK;

    *pUniqueDeviceName = SysAllocString(m_UniqueDeviceName);
    if(NULL == *pUniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conman.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       C O N M A N . C P P
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <dbt.h>
#include <ndisguid.h>
#include "conman.h"
#include "dialup.h"
#include "enum.h"
#include "enumw.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "nminit.h"
#if DBG
#include "ncras.h"
#endif // DBG
#include <wmium.h>
#include "cmutil.h"
#include <shlwapi.h>
#include <shfolder.h>
#include "cobase.h"
#define SECURITY_WIN32
#include <security.h>
#include <wzcsvc.h>

bool operator < (const GUID& rguid1, const GUID& rguid2)
{
    return memcmp(&rguid1, &rguid2, sizeof(GUID)) < 0;
}

static const WCHAR c_szRegKeyClassManagers [] = L"System\\CurrentControlSet\\Control\\Network\\Connections";
static const WCHAR c_szRegValClassManagers [] = L"ClassManagers";

volatile CConnectionManager* CConnectionManager::g_pConMan = NULL;
volatile BOOL                CConnectionManager::g_fInUse  = FALSE;

bool operator == (const NETCON_PROPERTIES& rProps1, const NETCON_PROPERTIES& rProps2)
{
    return (IsEqualGUID(rProps1.clsidThisObject, rProps2.clsidThisObject) &&
            IsEqualGUID(rProps1.clsidUiObject, rProps2.clsidUiObject) &&
            (rProps1.dwCharacter == rProps2.dwCharacter) &&
            IsEqualGUID(rProps1.guidId, rProps2.guidId) &&
            (rProps1.MediaType == rProps2.MediaType) &&
            (rProps1.pszwDeviceName == rProps2.pszwDeviceName) &&
            (rProps1.pszwName == rProps2.pszwName) &&
            (rProps1.Status == rProps2.Status));
}

const DWORD MAX_DISABLE_EVENT_TIMEOUT = 0xFFFF;

//static
BOOL
CConnectionManager::FHasActiveConnectionPoints ()
{
    BOOL fRet = FALSE;

    // Note our intent to use g_pConMan.  We may find out that it is not
    // available for use, but setting g_fInUse to TRUE prevents FinalRelease
    // from allowing the object to be destroyed while we are using it.
    //
    g_fInUse = TRUE;

    // Save g_pConMan into a local variable since we have to test and use
    // it atomically.  If we tested g_pConMan directly and then used it
    // directly, it may have been set to NULL by FinalRelease in between
    // our test and use.  (Uh, which would be bad.)
    //
    // The const_cast is because g_pConMan is declared volatile.
    //
    CConnectionManager* pConMan = const_cast<CConnectionManager*>(g_pConMan);
    if (pConMan)
    {
        pConMan->Lock();

        IUnknown** ppUnk;
        for (ppUnk = pConMan->m_vec.begin();
             ppUnk < pConMan->m_vec.end();
             ppUnk++)
        {
            if (ppUnk && *ppUnk)
            {
                fRet = TRUE;
                break;
            }
        }

        pConMan->Unlock();
    }

    // Now that we are finished using the object, indicate so.  FinalRelease
    // may be waiting for this condition in which case the object will soon
    // be destroyed.
    //
    g_fInUse = FALSE;

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::FinalRelease
//
//  Purpose:    COM destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
VOID
CConnectionManager::FinalRelease ()
{
    TraceFileFunc(ttidConman);

    if (m_hRegClassManagerKey)
    {
        RegCloseKey(m_hRegClassManagerKey);
        m_hRegClassManagerKey = NULL;
    }

    NTSTATUS Status = RtlDeregisterWait(m_hRegNotifyWait);
    if (!NT_SUCCESS(Status))
    {
        TraceError("Could not deregister Registry Change Notification", HrFromLastWin32Error());
    }
    m_hRegNotifyWait = NULL;

    if (m_hRegNotify)
    {
        CloseHandle(m_hRegNotify);
        m_hRegNotify = NULL;
    }

    // Unregister for PnP device events if we successfully registered for
    // them.
    //
    if (m_hDevNotify)
    {
        TraceTag (ttidConman, "Calling UnregisterDeviceNotification...");

        if (!UnregisterDeviceNotification (m_hDevNotify))
        {
            TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
                "UnregisterDeviceNotification");
        }
    }

    (VOID) HrEnsureRegisteredOrDeregisteredWithWmi (FALSE);

    // Revoke the global connection manager pointer so that subsequent calls
    // to NotifyClientsOfEvent on other threads will do nothing.
    //
    g_pConMan = NULL;

    // Wait for g_fInUse to become FALSE.  NotifyClientsOfEvent will set
    // this to TRUE while it is using us.
    // Keep track of the number of times we sleep and trace it for
    // informational purposes.  If we see that we are waiting quite a few
    // number of times, increase the wait period.
    //
#ifdef ENABLETRACE
    if (g_fInUse)
    {
        TraceTag (ttidConman, "CConnectionManager::FinalRelease is waiting "
            "for NotifyClientsOfEvent to finish...");
    }
#endif

    ULONG cSleeps = 0;
    const DWORD nMilliseconds = 0;
    while (g_fInUse)
    {
        cSleeps++;
        Sleep (nMilliseconds);
    }

#ifdef ENABLETRACE
    if (cSleeps)
    {
        TraceTag (ttidConman, "CConnectionManager::FinalRelease slept %d "
            "times.  (%d ms each time.)",
            cSleeps, nMilliseconds);
    }
#endif

    // Release our class managers.
    //
    for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
    {
        ReleaseObj (iter->second);
    }

    TraceTag (ttidConman, "Connection manager being destroyed");
}

inline
LPVOID OffsetToPointer(LPVOID pStart, DWORD dwNumBytes)
{
    DWORD_PTR dwPtr;

    dwPtr = reinterpret_cast<DWORD_PTR>(pStart);

    dwPtr += dwNumBytes;

    return reinterpret_cast<LPVOID>(dwPtr);
}

//
// Must match type of NOTIFICATIONCALLBACK
//
VOID
WINAPI
WmiEventCallback (
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext)
{
    TraceTag (ttidConman,
        "WmiEventCallback called...");

    TraceTag(ttidEvents, "Flags: %d", Wnode->Flags);

    if (WNODE_FLAG_SINGLE_INSTANCE == (WNODE_FLAG_SINGLE_INSTANCE & Wnode->Flags))
    {
        PWNODE_SINGLE_INSTANCE pInstance = reinterpret_cast<PWNODE_SINGLE_INSTANCE>(Wnode);
        LPCWSTR lpszDevice = NULL;
        LPWSTR lpszGuid;
        GUID guidAdapter;

        lpszDevice = reinterpret_cast<LPCWSTR>(OffsetToPointer(pInstance, pInstance->DataBlockOffset));

        lpszGuid = wcsrchr(lpszDevice, L'{');

        TraceTag(ttidEvents, "Adapter Guid From NDIS for Media Status Change Event: %S", lpszGuid);
        if (SUCCEEDED(CLSIDFromString(lpszGuid, &guidAdapter)))
        {
            CONMAN_EVENT* pEvent;

            pEvent = new CONMAN_EVENT;

            if(pEvent)
            {
                pEvent->ConnectionManager = CONMAN_LAN;
                pEvent->guidId = guidAdapter;
                pEvent->Type = CONNECTION_STATUS_CHANGE;

                if (IsEqualGUID(Wnode->Guid, GUID_NDIS_STATUS_MEDIA_CONNECT))
                {
                    pEvent->Status = NCS_CONNECTED;
                }
                else if (IsEqualGUID(Wnode->Guid, GUID_NDIS_STATUS_MEDIA_DISCONNECT))
                {
                    pEvent->Status = NCS_MEDIA_DISCONNECTED;
                }
                else
                {
                    AssertSz(FALSE, "We never registered for this event ... WMI may be having internal issues.");
                    MemFree(pEvent);
                    return;
                }
                if (!QueueUserWorkItemInThread(LanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
                {
                    FreeConmanEvent(pEvent);
                }
            }
        }
    }
    else
    {
        LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
    }
}

HRESULT
CConnectionManager::HrEnsureRegisteredOrDeregisteredWithWmi (
    BOOL fRegister)
{
        // Already registered or deregistered?
    //
    if (!!m_fRegisteredWithWmi == !!fRegister)
    {
        return S_OK;
    }

    m_fRegisteredWithWmi = !!fRegister;

    HRESULT     hr = S_OK;
    DWORD       dwErr;
    INT         i;
    const GUID* apguid [] =
    {
        &GUID_NDIS_STATUS_MEDIA_CONNECT,
        &GUID_NDIS_STATUS_MEDIA_DISCONNECT,
    };

    TraceTag (ttidConman,
        "Calling WmiNotificationRegistration to %s for NDIS media events...",
        (fRegister) ? "register" : "unregister");

    for (i = 0; i < celems(apguid); i++)
    {
        dwErr = WmiNotificationRegistration (
                    const_cast<GUID*>(apguid[i]),
                    !!fRegister,    // !! for BOOL to BOOLEAN
                    WmiEventCallback,
                    0,
                    NOTIFICATION_CALLBACK_DIRECT);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceHr (ttidError, FAL, hr, FALSE, "WmiNotificationRegistration");
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrEnsureRegisteredOrDeregisteredWithWmi");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::NotifyClientsOfEvent
//
//  Purpose:    Notify our connection points that this object has changed
//              state in some way and that a re-enumeration is needed.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   20 Mar 1998
//
//  Notes:      This is a static function.  No this pointer is passed.
//
// static
VOID CConnectionManager::NotifyClientsOfEvent (
    CONMAN_EVENT* pEvent)
{
    HRESULT     hr;
    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // Note our intent to use g_pConMan.  We may find out that it is not
    // available for use, but setting g_fInUse to TRUE prevents FinalRelease
    // from allowing the object to be destroyed while we are using it.
    //
    g_fInUse = TRUE;

    // Save g_pConMan into a local variable since we have to test and use
    // it atomically.  If we tested g_pConMan directly and then used it
    // directly, it may have been set to NULL by FinalRelease in between
    // our test and use.  (Uh, which would be bad.)
    //
    // The const_cast is because g_pConMan is declared volatile.
    //
    CConnectionManager* pConMan = const_cast<CConnectionManager*>(g_pConMan);
    if (pConMan)
    {
        ULONG       cpUnk;
        IUnknown**  apUnk;

        hr = HrCopyIUnknownArrayWhileLocked (
                pConMan,
                &pConMan->m_vec,
                &cpUnk,
                &apUnk);

        if (SUCCEEDED(hr) && cpUnk && apUnk)
        {
#ifdef DBG
            CHAR szClientList[MAX_PATH];
            ZeroMemory(szClientList, MAX_PATH);
            LPSTR pszClientList = szClientList;

            ITERUSERNOTIFYMAP iter;
            for (iter = pConMan->m_mapNotify.begin(); iter != pConMan->m_mapNotify.end(); iter++)
            {
                pszClientList += sprintf(pszClientList, "%d ", iter->second->dwCookie);
                if (pszClientList > (szClientList + MAX_PATH-50) )
                {
                    break;
                }
            }

            if (iter != pConMan->m_mapNotify.end())
            {
                pszClientList += sprintf(pszClientList, "(more)");
            }

            TraceTag (ttidConman,
                "NotifyClientsOfEvent: Notifying %d clients. Cookies: %s)",
                cpUnk, szClientList);
#endif
            for (ULONG i = 0; i < cpUnk; i++)
            {
                INetConnectionNotifySink* pSink = NULL;
                BOOL                fFireEventOnSink = FALSE;

                hr = apUnk[i]->QueryInterface(IID_INetConnectionNotifySink, reinterpret_cast<LPVOID*>(&pSink));

                ReleaseObj(apUnk[i]);

                if (SUCCEEDED(hr))
                {
                    hr = CoSetProxyBlanket (
                        pSink,
                        RPC_C_AUTHN_WINNT,      // use NT default security
                        RPC_C_AUTHZ_NONE,       // use NT default authentication
                        NULL,                   // must be null if default
                        RPC_C_AUTHN_LEVEL_CALL, // call
                        RPC_C_IMP_LEVEL_IDENTIFY,
                        NULL,                   // use process token
                        EOAC_DEFAULT);

                    switch (pEvent->Type)
                    {
                        case CONNECTION_ADDED:

                            Assert (pEvent);
                            Assert (pEvent->pPropsEx);

                            TraceTag(ttidEvents, "Characteristics: %s", DbgNccf(pEvent->pPropsEx->dwCharacter));

                            if (!(NCCF_ALL_USERS == (pEvent->pPropsEx->dwCharacter & NCCF_ALL_USERS)))
                            {
                                const WCHAR* pchw = reinterpret_cast<const WCHAR*>(pEvent->pPropsEx->bstrPersistData);
                                const WCHAR* pchwMax;
                                PCWSTR       pszwPhonebook;
                                WCHAR LeadWord = PersistDataLead;
                                WCHAR TrailWord = PersistDataTrail;
                                IUnknown* pUnkSink = NULL;

                                hr = pSink->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnkSink));
                                AssertSz(SUCCEEDED(hr), "Please explain how this happened...");
                                if (SUCCEEDED(hr))
                                {
                                    // The last valid pointer for the embedded strings.
                                    //
                                    pchwMax = reinterpret_cast<const WCHAR*>(pEvent->pbPersistData + pEvent->cbPersistData
                                        - (sizeof (GUID) +
                                        sizeof (BOOL) +
                                        sizeof (TrailWord)));

                                    if (pchw && (LeadWord == *pchw))
                                    {
                                        TraceTag(ttidEvents, "Found Correct Lead Character.");
                                        // Skip past our lead byte.
                                        //
                                        pchw++;

                                        // Get PhoneBook path.  Search for the terminating null and make sure
                                        // we find it before the end of the buffer.  Using lstrlen to skip
                                        // the string can result in an an AV in the event the string is
                                        // not actually null-terminated.
                                        //
                                        for (pszwPhonebook = pchw; *pchw != L'\0' ; pchw++)
                                        {
                                            if (pchw >= pchwMax)
                                            {
                                                pszwPhonebook = NULL;
                                                break;
                                            }
                                        }

                                        TraceTag(ttidEvents, "Found Valid Phonebook: %S", (pszwPhonebook) ? L"TRUE" : L"FALSE");

                                        if (pszwPhonebook)
                                        {
                                            ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.find(pUnkSink);
                                            if (iter != pConMan->m_mapNotify.end())
                                            {
                                                tstring& strUserDataPath = iter->second->szUserProfilesPath;
                                                TraceTag(ttidEvents, "Comparing stored Path: %S to Phonebook Path: %S",
                                                         strUserDataPath.c_str(), pszwPhonebook);
                                                if (_wcsnicmp(pszwPhonebook, strUserDataPath.c_str(), strUserDataPath.length()) == 0)
                                                {
                                                    fFireEventOnSink = TRUE;
                                                }
                                            }
                                            else
                                            {
                                                TraceTag(ttidError, "Could not find Path for NotifySink: 0x%08x", pUnkSink);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Some other devices do not use this Format, but need to be sent events.
                                        fFireEventOnSink = TRUE;
                                    }

                                    ReleaseObj(pUnkSink);
                                }
                            }
                            else
                            {
                                TraceTag(ttidEvents, "All User Connection");
                                fFireEventOnSink = TRUE;
                            }

                            if (fFireEventOnSink)
                            {
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionAdded... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ConnectionAdded (
                                        pEvent->pPropsEx);
                            }

                            break;

                        case CONNECTION_BANDWIDTH_CHANGE:
                            TraceTag (ttidEvents,
                                "Notifying ConnectionBandWidthChange... (pSink=0x%p)",
                                pSink);

                            hr = pSink->ConnectionBandWidthChange (&pEvent->guidId);
                            break;

                        case CONNECTION_DELETED:
                            TraceTag (ttidEvents,
                                "Notifying ConnectionDeleted... (pSink=0x%p)",
                                pSink);

                            hr = pSink->ConnectionDeleted (&pEvent->guidId);
                            break;

                        case CONNECTION_MODIFIED:
                            Assert (pEvent->pPropsEx);

                            TraceTag (ttidEvents,
                                "Notifying ConnectionModified... (pSink=0x%p)",
                                pSink);

                            hr = pSink->ConnectionModified (pEvent->pPropsEx);

                            break;

                        case CONNECTION_RENAMED:
                            TraceTag (ttidEvents,
                                "Notifying ConnectionRenamed... (pSink=0x%p)",
                                pSink);

                            hr = pSink->ConnectionRenamed (&pEvent->guidId,
                                    pEvent->szNewName);
                        break;

                        case CONNECTION_STATUS_CHANGE:
                            TraceTag (ttidEvents,
                                "Notifying ConnectionStatusChange... (pSink=0x%p)",
                                pSink);

                            TraceTag(ttidEvents, "Status changed to: %s", DbgNcs(pEvent->Status));

                            hr = pSink->ConnectionStatusChange (&pEvent->guidId,
                                        pEvent->Status);
                            break;

                        case REFRESH_ALL:
                            TraceTag (ttidEvents,
                                "Notifying RefreshAll... (pSink=0x%p)",
                                pSink);

                            hr = pSink->RefreshAll ();
                            break;

                        case CONNECTION_ADDRESS_CHANGE:
                             TraceTag (ttidEvents,
                                "Notifying ConnectionAddressChange... (pSink=0x%p)",
                                pSink);

                             hr = pSink->ConnectionAddressChange(&pEvent->guidId);
                             break;

                        case CONNECTION_BALLOON_POPUP:
                            TraceTag (ttidEvents,
                                "Notifying ConnectionStatusChange... (pSink=0x%p)",
                                pSink);

                            hr = pSink->ShowBalloon(&pEvent->guidId, pEvent->szCookie, pEvent->szBalloonText);
                            break;

                        case DISABLE_EVENTS:
                            TraceTag (ttidEvents,
                                "Notifying DisableEvents... (pSink=0x%p)",
                                pSink);

                            hr = pSink->DisableEvents(pEvent->fDisable, pEvent->ulDisableTimeout);
                            break;

                        default:
                            TraceTag(ttidEvents, "Event Type Passed: %d", pEvent->Type);
                            AssertSz (FALSE, "Invalid Type specified in pEvent");
                            break;
                    }
                    TraceErrorOptional("pSink call failed: ", hr, (S_FALSE == hr) );

                    if ( (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)  ||
                         (HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE) == hr)  ||
                         (RPC_E_SERVER_DIED  == hr) ||
                         (RPC_E_DISCONNECTED == hr) ||
                         (HRESULT_FROM_WIN32(RPC_S_CALL_FAILED) == hr) )
                    {
                        IUnknown* pUnkSink = NULL;
                        HRESULT hrT = pSink->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnkSink));
                        if (SUCCEEDED(hrT))
                        {
                            ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.find(pUnkSink);
                            if (iter != pConMan->m_mapNotify.end())
                            {
                                TraceTag(ttidError, "Dead client detected. Removing notify advise for: %S", iter->second->szUserName.c_str());

                                hrT = pConMan->Unadvise(iter->second->dwCookie);
                            }
                            ReleaseObj(pUnkSink);
                        }
                        TraceHr (ttidError, FAL, hrT, S_FALSE == hrT, "Error removing notify advise.");
                    }

                    ReleaseObj(pSink);
                }
            }
            MemFree (apUnk);
        }
    }


    // Now that we are finished using the object, indicate so.  FinalRelease
    // may be waiting for this condition in which case the object will soon
    // be destroyed.
    //

    g_fInUse = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::HrEnsureClassManagersLoaded
//
//  Purpose:    Loads the class managers if they have not been loaded yet.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   10 Dec 1997
//
//  Notes:
//
HRESULT
CConnectionManager::HrEnsureClassManagersLoaded ()
{
    HRESULT hr = S_OK;

    // Need to protect m_mapClassManagers for the case that two clients
    // get our object simultaneously and call a method which invokes
    // this method.  Need to transition m_mapClassManagers from being
    // empty to being full in one atomic operation.
    //
    CExceptionSafeComObjectLock EsLock (this);

    // If our vector of class managers is emtpy, try to load them.
    // This will certainly be the case if we haven't tried to load them yet.
    // If will also be the case when no class managers are registered.
    // This isn't likely because we register them in hivesys.inf, but it
    // shouldn't hurt to keep trying if they're really are none registered.
    //
    if (m_mapClassManagers.empty())
    {
        TraceTag (ttidConman, "Loading class managers...");

        // Load the registered class managers.
        //

        // Open the registry key where the class managers are registered.
        //
        HKEY hkey;
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                        c_szRegKeyClassManagers, KEY_READ, &hkey);
        if (SUCCEEDED(hr))
        {
            // Read the multi-sz of class manager CLSIDs.
            //
            PWSTR pmsz;
            hr = HrRegQueryMultiSzWithAlloc (hkey, c_szRegValClassManagers,
                    &pmsz);
            if (S_OK == hr)
            {
                (VOID) HrNmWaitForClassObjectsToBeRegistered ();

                // For each CLSID, create the object and request its
                // INetConnectionManager interface.
                //
                for (PCWSTR pszClsid = pmsz;
                     *pszClsid;
                     pszClsid += wcslen (pszClsid) + 1)
                {
                    // Convert the string to a CLSID.  If it fails, skip it.
                    //
                    CLSID clsid;
                    if (FAILED(CLSIDFromString ((LPOLESTR)pszClsid, &clsid)))
                    {
                        TraceTag (ttidConman, "Skipping bogus CLSID (%S)",
                            pszClsid);
                        continue;
                    }

                    // Create the class manager and add it to our list.
                    //
                    INetConnectionManager* pConMan;

                    hr = CoCreateInstance (
                            clsid, NULL,
                            CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                            IID_INetConnectionManager,
                            reinterpret_cast<VOID**>(&pConMan));

                    TraceHr (ttidError, FAL, hr, FALSE,
                        "CConnectionManager::HrEnsureClassManagersLoaded: "
                        "CoCreateInstance failed for class manager %S.",
                        pszClsid);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag (ttidConman, "Loaded class manager %S",
                            pszClsid);

                        Assert (pConMan);

                        if (m_mapClassManagers.find(clsid) != m_mapClassManagers.end())
                        {
                            AssertSz(FALSE, "Attempting to insert the same class manager twice!");
                        }
                        else
                        {
                            m_mapClassManagers[clsid] = pConMan;
                        }
                    }

/*
// If CoCreateInstance starts failing again on retail builds, this can
// be helpful.
                    else
                    {
                        CHAR psznBuf [512];
                        wsprintfA (psznBuf, "NETCFG: CoCreateInstance failed "
                            "(0x%08x) on class manager %i.\n",
                            hr, m_mapClassManagers.size ());
                        OutputDebugStringA (psznBuf);
                    }
*/
                }

                MemFree (pmsz);
            }

            RegCloseKey (hkey);
        }

        TraceTag (ttidConman, "Loaded %i class managers",
            m_mapClassManagers.size ());
    }

    TraceErrorOptional ("CConnectionManager::HrEnsureClassManagersLoaded", hr, (S_FALSE == hr));
    return hr;
}

VOID NTAPI CConnectionManager::RegChangeNotifyHandler(IN LPVOID pContext, IN BOOLEAN fTimerFired)
{
    TraceTag(ttidConman, "CConnectionManager::RegChangeNotifyHandler (%d)", fTimerFired);

    CConnectionManager *pThis = reinterpret_cast<CConnectionManager *>(pContext);
    CExceptionSafeComObjectLock EsLock (pThis);

    list<GUID> lstRegisteredGuids;

    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyClassManagers, KEY_READ, &hkey);
    if (SUCCEEDED(hr))
    {
        // Read the multi-sz of class manager CLSIDs.
        //
        PWSTR pmsz;
        hr = HrRegQueryMultiSzWithAlloc (hkey, c_szRegValClassManagers,
                &pmsz);
        if (S_OK == hr)
        {
            for (PCWSTR pszClsid = pmsz;
                 *pszClsid;
                 pszClsid += wcslen (pszClsid) + 1)
            {
                CLSID clsid;
                if (FAILED(CLSIDFromString ((LPOLESTR)pszClsid, &clsid)))
                {
                    TraceTag (ttidConman, "Skipping bogus CLSID (%S)", pszClsid);
                    continue;
                }
                lstRegisteredGuids.push_back(clsid);
            }
        }
        RegCloseKey(hkey);


        BOOL bFound;
        do
        {
            bFound = FALSE;

            CLASSMANAGERMAP::iterator iterClassMgr;

            for (iterClassMgr = pThis->m_mapClassManagers.begin();  iterClassMgr != pThis->m_mapClassManagers.end(); iterClassMgr++)
            {
                if (find(lstRegisteredGuids.begin(), lstRegisteredGuids.end(), iterClassMgr->first) == lstRegisteredGuids.end())
                {
                    // Class manager key has been removed
                    TraceTag(ttidConman, "Removing class manager");
                    bFound = TRUE;
                    break;
                }
            }

            if (bFound)
            {
                ULONG uRefCount = iterClassMgr->second->Release();
                TraceTag(ttidConman, "Releasing class manager - Refcount = %d", uRefCount);
                pThis->m_mapClassManagers.erase(iterClassMgr);
            }
        } while (bFound);

        for (list<GUID>::iterator iter = lstRegisteredGuids.begin(); iter != lstRegisteredGuids.end(); iter++)
        {
            if (pThis->m_mapClassManagers.find(*iter) == pThis->m_mapClassManagers.end())
            {
                // Class manager key has been added
                TraceTag(ttidConman, "Adding class manager");

                INetConnectionManager* pConMan;
                hr = CoCreateInstance (
                        *iter,
                        NULL,
                        CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                        IID_INetConnectionManager,
                        reinterpret_cast<VOID**>(&pConMan));

                TraceHr (ttidError, FAL, hr, FALSE,
                    "CConnectionManager::RegChangeNotifyHandler: CoCreateInstance failed for class manager.");

                if (SUCCEEDED(hr))
                {
                    TraceTag (ttidConman, "Loaded class manager");
                    Assert (pConMan);

                    if (pThis->m_mapClassManagers.find(*iter) != pThis->m_mapClassManagers.end())
                    {
                        AssertSz(FALSE, "Attempting to insert the same class manager twice!");
                    }
                    else
                    {
                        pThis->m_mapClassManagers[*iter] = pConMan;
                    }
                }
            }
        }
    }
    else
    {
        TraceError("Could not open registry key", HrFromLastWin32Error());
    }

    TraceError("RegChangeNotifyHandler", hr);

    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);

    RegNotifyChangeKeyValue(pThis->m_hRegClassManagerKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET, pThis->m_hRegNotify, TRUE);
}

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::EnumConnections (
        NETCONMGR_ENUM_FLAGS    Flags,
        IEnumNetConnection**    ppEnum)
{
    HRESULT hr = S_OK;
    {
        CExceptionSafeComObjectLock EsLock (this);

        Assert(FImplies(m_hRegNotify, m_hRegClassManagerKey));
        if (!m_hRegNotify)
        {
            m_hRegNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hRegNotify)
            {
                NTSTATUS Status = RtlRegisterWait(&m_hRegNotifyWait, m_hRegNotify, &CConnectionManager::RegChangeNotifyHandler, this, INFINITE, WT_EXECUTEDEFAULT);
                if (!NT_SUCCESS(Status))
                {
                    hr = HRESULT_FROM_NT(Status);
                }
                else
                {
                    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyClassManagers, KEY_READ, &m_hRegClassManagerKey);
                    if (SUCCEEDED(hr))
                    {
                        hr = RegNotifyChangeKeyValue(m_hRegClassManagerKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegNotify, TRUE);
                        if (FAILED(hr))
                        {
                            RegCloseKey(m_hRegClassManagerKey);
                            m_hRegClassManagerKey = NULL;
                        }
                    }

                    if (FAILED(hr))
                    {
                        Status = RtlDeregisterWait(m_hRegNotifyWait);
                        if (!NT_SUCCESS(Status))
                        {
                            hr = HRESULT_FROM_NT(Status);
                        }
                        m_hRegNotifyWait = NULL;
                    }
                }

                if (FAILED(hr))
                {
                    CloseHandle(m_hRegNotify);
                    m_hRegNotify = NULL;
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }

        if (SUCCEEDED(hr))
        {

            // Create and return the enumerator.
            //
            hr = HrEnsureClassManagersLoaded ();
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CConnectionManagerEnumConnection::CreateInstance (
                    Flags,
                    m_mapClassManagers,
                    IID_IEnumNetConnection,
                    reinterpret_cast<VOID**>(ppEnum));
    }
    TraceErrorOptional ("CConnectionManager::EnumConnections", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionRefresh
//
STDMETHODIMP
CConnectionManager::RefreshAll()
{
    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionAdded
//
//  Purpose:    Notifies event sinks that a new connection has been added.
//
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionAdded(
    IN INetConnection* pConnection)
{
    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_ADDED;

        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionDeleted
//
//  Purpose:    Sends an event to notify of a connection being deleted.
//
//  Arguments:
//      pguidId   [in] GUID of the  connectoid
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   18 Apr 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionDeleted(
    IN const GUID* pguidId)
{
    HRESULT hr = S_OK;

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_DELETED;
        pEvent->guidId = *pguidId;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionRenamed
//
//  Purpose:    Notifies the event sinks of a connection being renamed.
//
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 Apr 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionRenamed(
    IN INetConnection* pConnection)
{
    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_RENAMED;

        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            lstrcpynW (pEvent->szNewName, pEvent->pPropsEx->bstrName, celems(pEvent->szNewName) );
            pEvent->guidId = pEvent->pPropsEx->guidId;

            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionModified
//
//  Purpose:    Sends an event to notify clients that the connection has been
//              Modified.
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionModified(INetConnection* pConnection)
{
    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_MODIFIED;

        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionStatusChanged
//
//  Purpose:    Sends the ShowBalloon event to each applicable netshell
//
//  Arguments:
//      pguidId   [in] GUID of the  connectoid
//      ncs       [in] New status of the connectoid
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionStatusChanged(
                     IN const GUID* pguidId,
                     IN const NETCON_STATUS  ncs)
{
    HRESULT hr = S_OK;

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_STATUS_CHANGE;
        pEvent->guidId = *pguidId;
        pEvent->Status = ncs;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            FreeConmanEvent(pEvent);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ShowBalloon
//
//  Purpose:    Sends the ShowBalloon event to each applicable netshell
//
//  Arguments:
//      pguidId       [in] GUID of the  connectoid
//      szCookie      [in] A specified cookie that will end up at netshell
//      szBalloonText [in] The balloon text
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ShowBalloon(
                     IN const GUID *pguidId,
                     IN const BSTR szCookie,
                     IN const BSTR szBalloonText)
{
    HRESULT hr = S_OK;

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_BALLOON_POPUP;
        pEvent->guidId        = *pguidId;
        pEvent->szCookie      = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));
        pEvent->szBalloonText = SysAllocString(szBalloonText);

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::DisableEvents
//
//  Purpose:    Disable netshell processing of events for x milliseconds
//
//  Arguments:
//      fDisable         [in] TRUE to disable EVENT processing, FALSE to renable
//      ulDisableTimeout [in] Number of milliseconds to disable event processing for
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   10 April 2001
//
//  Notes:
//
STDMETHODIMP CConnectionManager::DisableEvents(IN const BOOL fDisable, IN const ULONG ulDisableTimeout)
{
    HRESULT hr = S_OK;

    if (ulDisableTimeout > MAX_DISABLE_EVENT_TIMEOUT)
    {
        return E_INVALIDARG;
    }

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = DISABLE_EVENTS;
        pEvent->fDisable         = fDisable;
        // We set the high bit to let netshell know that this is coming from our private interface.
        pEvent->ulDisableTimeout = 0x80000000 | ulDisableTimeout;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::RefreshConnections
//
//  Purpose:    Refreshes the connections in the connections folder
//
//  Arguments:
//      None.
//
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to
//              allow other components/companies to have some control over
//              the Connections Folder.
STDMETHODIMP CConnectionManager::RefreshConnections()
{
    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = REFRESH_ALL;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::Enable
//
//  Purpose:    Enables events to be fired once more in the connections folder
//
//  Arguments:
//      None.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to
//              allow other components/companies to have some control over
//              the Connections Folder.
//              Since this is a public interface, we are only allowing the
//              INVALID_ADDRESS notification to be disabled
//              (this will take place in netshell.dll).
//
STDMETHODIMP CConnectionManager::Enable()
{
    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = DISABLE_EVENTS;
        pEvent->fDisable = FALSE;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::Disable
//
//  Purpose:    Disable netshell processing of events for x milliseconds
//
//  Arguments:
//      ulDisableTimeout [in] Number of milliseconds to disable event
//                            processing for.  Max is 60000 (1 minute)
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to
//              allow other components/companies to have some control over
//              the Connections Folder.
//              Since this is a public interface, we are only allowing the
//              INVALID_ADDRESS notification to be disabled
//              (this will take place in netshell.dll).
//
STDMETHODIMP CConnectionManager::Disable(IN const ULONG ulDisableTimeout)
{
    HRESULT hr = S_OK;

    if (ulDisableTimeout > MAX_DISABLE_EVENT_TIMEOUT)
    {
        return E_INVALIDARG;
    }

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;

    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type             = DISABLE_EVENTS;
        pEvent->fDisable         = TRUE;
        pEvent->ulDisableTimeout = ulDisableTimeout;

        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionCMUtil
//
//+---------------------------------------------------------------------------
//
//  Function:   MapCMHiddenConnectionToOwner
//
//  Purpose:    Maps a child connection to its parent connection.
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both
//              the parent and child connectoid have the same name. When
//              the status of the hidden connectiod is updated the folder
//              recives the guid of the hidden connectoid and maps the
//              connectiod to it parent (Connection Manager) by searching
//              netmans cache for the name of the hidden connectoid. Then it
//              searches the connections in the folder for that name and thus
//              gets the guid of the parent connectoid.
//
//              When the folder gets a notify message from netman for the hidden
//              connection it uses this function to find the parent and update the
//              parent's status. The hidden connection is not displayed.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- Found hidden connection
//              else not found
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::MapCMHiddenConnectionToOwner (
    /*[in]*/  REFGUID guidHidden,
    /*[out]*/ GUID * pguidOwner)
{

    HRESULT hr = S_OK;
    bool bFound = false;

    hr = HrEnsureClassManagersLoaded ();
    if (SUCCEEDED(hr))
    {
        // Impersonate the user so that we see all of the connections displayed in the folder
        //
        hr = CoImpersonateClient();
        if (SUCCEEDED(hr))
        {

            // Find the hidden connection with this guid
            //
            CMEntry cm;

            hr = CCMUtil::Instance().HrGetEntry(guidHidden, cm);
            // Did we find the hidden connection?
            if( S_OK == hr )
            {
                // Enumerate through all of the connections and find connection with the same name as the
                // hidden connection
                //
                IEnumNetConnection * pEnum = NULL;

                hr = CWanConnectionManagerEnumConnection::CreateInstance(NCME_DEFAULT, IID_IEnumNetConnection, reinterpret_cast<LPVOID *>(&pEnum));

                if (SUCCEEDED(hr))
                {
                    INetConnection * pNetCon;
                    NETCON_PROPERTIES * pProps;
                    while(!bFound)
                    {
                        // Get the nect connection
                        //
                        hr = pEnum->Next(1, &pNetCon, NULL);
                        if(S_OK != hr)
                        {
                            // Ooops encountered some error, stop searching
                            //
                            break;
                        }

                        // Get the properties of the connection
                        //
                        hr = pNetCon->GetProperties(&pProps);
                        if(SUCCEEDED(hr))
                        {
                            if(lstrcmp(cm.m_szEntryName, pProps->pszwName) == 0)
                            {
                                // Found the connection that has the same name a the hidden connection
                                // Stop searching!!
                                *pguidOwner = pProps->guidId;
                                bFound = true;
                            }
                            FreeNetconProperties(pProps);
                        }
                        ReleaseObj(pNetCon);
                    }
                    ReleaseObj(pEnum);
                }
            }
            // Stop Impersonating the user
            //
            CoRevertToSelf();
        }
    }

    return bFound ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// IConnectionPoint overrides  netman!CConnectionManager__Advise
//
STDMETHODIMP
CConnectionManager::Advise (
    IUnknown* pUnkSink,
    DWORD* pdwCookie)
{
    HRESULT hr = S_OK;

    TraceFileFunc(ttidConman);

    Assert(!FBadInPtr(pUnkSink));

    // Set our cloaked identity to be used when we call back on this
    // advise interface.  It's important to do this for security.  Since
    // we run as LocalSystem, if we were to call back without identify
    // impersonation only, the client could impersonate us and get a free
    // LocalSystem context which could be used for malicious purposes.
    //
    //
    CoSetProxyBlanket (
            pUnkSink,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IDENTIFY,
            NULL,                   // use process token
            EOAC_DEFAULT);
    TraceHr(ttidError, FAL, hr, FALSE, "CoSetProxyBlanket");

    if (S_OK == hr)
    {
        // Initialize our event handler if it has not already been done.
        hr = HrEnsureEventHandlerInitialized();
        if (SUCCEEDED(hr))
        {
            // We still work for other events if this fails.
            hr = HrEnsureRegisteredWithNla();
            TraceErrorOptional("Could not register with Nla", hr, (S_FALSE == hr));

            // Call the underlying ATL implementation of Advise.
            //
            hr = IConnectionPointImpl<
                    CConnectionManager,
                    &IID_INetConnectionNotifySink>::Advise(pUnkSink, pdwCookie);

            TraceTag (ttidConman,
                "CConnectionManager::Advise called... pUnkSink=0x%p, cookie=%d",
                pUnkSink,
                *pdwCookie);

            TraceHr (ttidError, FAL, hr, FALSE, "IConnectionPointImpl::Advise");

            if (SUCCEEDED(hr))
            {
                WCHAR szUserAppData[MAX_PATH];
                HRESULT hrT = S_OK;
                HRESULT hrImpersonate = S_OK;

                if (SUCCEEDED(hrT))
                {
                    // We ignore this HRESULT because we can be called inproc and that would definitely fail.
                    // Instead we just make sure that it succeeded when befor call CoRevertToSelf.  This is
                    // fine because we'll still get a valid User App data path, it will just be something like
                    // LocalService or LocalSystem and we can still determine which sinks to send events to.

                    BOOLEAN     fNotifyWZC = FALSE;
                    WCHAR       szUserName[MAX_PATH];

                    CNotifySourceInfo* pNotifySourceInfo = new CNotifySourceInfo();
                    if (!pNotifySourceInfo)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        pNotifySourceInfo->dwCookie = *pdwCookie;

                        hrImpersonate = CoImpersonateClient();
                        if (SUCCEEDED(hrImpersonate) || (RPC_E_CALL_COMPLETE == hrImpersonate))
                        {
                            hrT = SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szUserAppData);
                            if (SUCCEEDED(hrT))
                            {
                                pNotifySourceInfo->szUserProfilesPath = szUserAppData;
                                TraceTag(ttidEvents, "Adding IUnknown for Sink to Map: 0x%08x.  Path: %S", reinterpret_cast<DWORD_PTR>(pUnkSink), szUserAppData);
                                TraceTag(ttidEvents, "Number of Items in Map: %d", m_mapNotify.size());
                            }
                            else
                            {
                                TraceError("Unable to get Folder Path", hrT);
                            }

                            ZeroMemory(szUserName, celems(szUserName));

                            ULONG nSize = celems(szUserName);
                            if (GetUserNameEx(NameSamCompatible, szUserName, &nSize) && *szUserName)
                            {
                                pNotifySourceInfo->szUserName = szUserName;
                                fNotifyWZC = TRUE;
                            }
                            else
                            {
                                pNotifySourceInfo->szUserName = L"System";
                                TraceError("Unable to get the user name", HrFromLastWin32Error());
                            }
                        }
                        Lock();
                        m_mapNotify[pUnkSink] = pNotifySourceInfo;
                        Unlock();

#ifdef DBG
                        LPWSTR* ppszAdviseUsers;
                        DWORD   dwCount;
                        HRESULT hrT = GetClientAdvises(&ppszAdviseUsers, &dwCount);
                        if (SUCCEEDED(hrT))
                        {
                            Assert(dwCount);

                            TraceTag(ttidConman, "Advise client list after ::Advise:");
                            for (DWORD x = 0; x < dwCount; x++)
                            {
                                LPWSTR szUserName = ppszAdviseUsers[x];
                                TraceTag(ttidConman, "%x: %S", x, szUserName);
                            }

                            CoTaskMemFree(ppszAdviseUsers);
                        }
#endif
                    }

                    if (SUCCEEDED(hrImpersonate))
                    {
                        CoRevertToSelf();
                    }

                    if (fNotifyWZC)
                    {
                        WZCTrayIconReady(szUserName);
                    }
                }

                if (!m_lRegisteredOneTime)
                {
                    // Do an explicit interlocked exchange to only let one thread
                    // through to do the registration.
                    //
                    if (0 == InterlockedExchange (&m_lRegisteredOneTime, 1))
                    {
                        // Register for device notifications.  Specifically, we're
                        // interested in network adapters coming and going.  If this
                        // fails, we proceed anyway.
                        //
                        TraceTag (ttidConman, "Calling RegisterDeviceNotification...");

                        DEV_BROADCAST_DEVICEINTERFACE PnpFilter;
                        ZeroMemory (&PnpFilter, sizeof(PnpFilter));
                        PnpFilter.dbcc_size         = sizeof(PnpFilter);
                        PnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
                        PnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

                        m_hDevNotify = RegisterDeviceNotification (
                                            (HANDLE)_Module.m_hStatus,
                                            &PnpFilter,
                                            DEVICE_NOTIFY_SERVICE_HANDLE);
                        if (!m_hDevNotify)
                        {
                            TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
                                "RegisterDeviceNotification");
                        }

                        (VOID) HrEnsureRegisteredOrDeregisteredWithWmi (TRUE);
                    }
                }
            }
        }
    }

    TraceErrorOptional ("CConnectionManager::Advise", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManager::Unadvise(DWORD dwCookie)
{
    HRESULT hr = S_OK;
    TraceFileFunc(ttidConman);

    hr = IConnectionPointImpl<CConnectionManager, &IID_INetConnectionNotifySink>::Unadvise(dwCookie);

    Lock();
    BOOL fFound = FALSE;
    for (ITERUSERNOTIFYMAP iter = m_mapNotify.begin(); iter != m_mapNotify.end(); iter++)
    {
        if (iter->second->dwCookie == dwCookie)
        {
            fFound = TRUE;
            delete iter->second;
            m_mapNotify.erase(iter);
            break;
        }
    }
    Unlock();

    if (!fFound)
    {
        TraceTag(ttidError, "Unadvise cannot find advise for cookie 0x%08x in notify map", dwCookie);
    }

#ifdef DBG
    LPWSTR* ppszAdviseUsers;
    DWORD   dwCount;
    HRESULT hrT = GetClientAdvises(&ppszAdviseUsers, &dwCount);
    if (SUCCEEDED(hrT))
    {
        if (!dwCount)
        {
            TraceTag(ttidConman, "Unadvise removed the last advise client");
        }
        else
        {
            TraceTag(ttidConman, "Advise client list after ::Unadvise:");
        }

        for (DWORD x = 0; x < dwCount; x++)
        {
            LPWSTR szUserName = ppszAdviseUsers[x];
            TraceTag(ttidConman, "%x: %S", x, szUserName);
        }

        CoTaskMemFree(ppszAdviseUsers);
    }
#endif
    return hr;
}

#if DBG

//+---------------------------------------------------------------------------
// INetConnectionManagerDebug
//

DWORD
WINAPI
ConmanNotifyTest (
    PVOID   pvContext
    )
{
    HRESULT hr;

    RASENUMENTRYDETAILS*    pDetails;
    DWORD                   cDetails;
    hr = HrRasEnumAllEntriesWithDetails (NULL,
            &pDetails, &cDetails);
    if (SUCCEEDED(hr))
    {
        RASEVENT Event;

        for (DWORD i = 0; i < cDetails; i++)
        {
            Event.Type = ENTRY_ADDED;
            Event.Details = pDetails[i];
            RasEventNotify (&Event);

            Event.Type = ENTRY_MODIFIED;
            RasEventNotify (&Event);

            Event.Type = ENTRY_CONNECTED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);

            Event.Type = ENTRY_DISCONNECTED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);

            Event.Type = ENTRY_RENAMED;
            lstrcpyW (Event.pszwNewName, L"foobar");
            RasEventNotify (&Event);

            Event.Type = ENTRY_DELETED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);
        }

        MemFree (pDetails);
    }

    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);

    TraceErrorOptional ("ConmanNotifyTest", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManager::NotifyTestStart ()
{
    HRESULT hr = S_OK;

    if (!QueueUserWorkItem (ConmanNotifyTest, NULL, WT_EXECUTEDEFAULT))
    {
        hr = HrFromLastWin32Error ();
    }

    TraceErrorOptional ("CConnectionManager::NotifyTestStart", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManager::NotifyTestStop ()
{
    return S_OK;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\cmsaclbk.h ===
#pragma once

#include "nmbase.h"
#include "upnpp.h"

class ATL_NO_VTABLE CSharedAccessDeviceFinderCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPDeviceFinderCallback,
    public IUPnPDeviceFinderAddCallbackWithInterface
{

public:
    BEGIN_COM_MAP(CSharedAccessDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderAddCallbackWithInterface)
    END_COM_MAP()
    
    CSharedAccessDeviceFinderCallback();
    
    // IUPnPDeviceFinderCallback
    STDMETHOD (DeviceAdded)(LONG lFindData, IUPnPDevice* pDevice); 
    STDMETHOD (DeviceRemoved)(LONG lFindData, BSTR bstrUDN); 
    STDMETHOD (SearchComplete)(LONG lFindData); 

    // IUPnPDeviceFinderCallbackWithInterface
    STDMETHODIMP DeviceAddedWithInterface(LONG lFindData, IUPnPDevice* pDevice, GUID* pguidInterface);

    HRESULT GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon);
    HRESULT FinalRelease();

private:

    HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService);
    HRESULT FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT GetServices(IUPnPDevice* pDevice, GUID* pInterfaceGUID, ISharedAccessBeacon** ppSharedAccessBeacon);
    HRESULT IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch);

    
    HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);
    ISharedAccessBeacon* m_pSharedAccessBeacon;
    
};

class ATL_NO_VTABLE CSharedAccessConnectionEventSink :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{

public:
    BEGIN_COM_MAP(CSharedAccessConnectionEventSink)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()
    
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);
private:
    IUPnPServiceCallback* m_pSink;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conman2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N 2 . H
//
//  Contents:   Connection manager 2.
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "ncstl.h"
#include "stllist.h"

typedef list<NETCON_PROPERTIES_EX*> LISTNETCONPROPEX;
typedef LISTNETCONPROPEX::iterator ITERNETCONPROPEX;

class ATL_NO_VTABLE CConnectionManager2 :
public CComObjectRootEx <CComMultiThreadModel>,
public CComCoClass <CConnectionManager2, &CLSID_ConnectionManager2>,
public INetConnectionManager2
{
public:
    CConnectionManager2(){};
    
    ~CConnectionManager2(){};

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CConnectionManager2)
    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN2);

    BEGIN_COM_MAP(CConnectionManager2)
    COM_INTERFACE_ENTRY(INetConnectionManager2)
    END_COM_MAP()

    // INetConnectionManager2
    STDMETHOD (EnumConnectionProperties)(
        OUT SAFEARRAY** ppsaConnectionProperties);
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conman.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N . H
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>
#include "cmevent.h"
#include "ncstl.h"
#include "stlmap.h"

// typedef map<IUnknown*, tstring> USERNOTIFYMAP;

class CNotifySourceInfo
{
public:
    tstring szUserName;
    tstring szUserProfilesPath;
    DWORD   dwCookie;
};

typedef map<IUnknown*, CNotifySourceInfo *> USERNOTIFYMAP;
typedef USERNOTIFYMAP::iterator ITERUSERNOTIFYMAP;

class ATL_NO_VTABLE CConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CConnectionManager, &CLSID_ConnectionManager>,
    public IConnectionPointContainerImpl <CConnectionManager>,
    public IConnectionPointImpl<CConnectionManager, &IID_INetConnectionNotifySink>,
#if DBG
    public INetConnectionManagerDebug,
#endif
    public INetConnectionManager,
    public INetConnectionRefresh,
    public INetConnectionCMUtil,
    public INetConnectionManagerEvents
{
private:
    // These static members are used by NotifyClientsOfEvent and
    // FinalRelease.  Since NotifyClientsOfEvent occurs asynchrounously
    // on a different thread, we need to ensure that the instance of this
    // object remains around for the lifetime of that call.  Therefore,
    // FinalRelease will wait until g_fInUse is FALSE.  NotifyClientsOfEvent
    // sets g_fInUse to TRUE before using g_pConMan.  FinalRelease sets
    // g_pConMan to NULL before waiting for g_fInUse to become FALSE.
    //
    // Note: using this method as opposed to AddRefing g_pConMan avoids the
    // circular refcount that would keep the service always running because
    // it AddRef'd its own object.
    //
    volatile static CConnectionManager* g_pConMan;
    volatile static BOOL                g_fInUse;

    // m_ClassManagers is an array (STL vector) of pointers to the
    // INetConnectionManager interfaces implemented by our registered
    // class managers.
    //
    CLASSMANAGERMAP                     m_mapClassManagers;

    USERNOTIFYMAP                       m_mapNotify;

    LONG                                m_lRegisteredOneTime;
    HDEVNOTIFY                          m_hDevNotify;
    BOOL                                m_fRegisteredWithWmi;

    HANDLE                              m_hRegNotify;
    HANDLE                              m_hRegNotifyWait;
    HKEY                                m_hRegClassManagerKey;

    HRESULT HrEnsureRegisteredOrDeregisteredWithWmi (
        BOOL fRegister);
    HRESULT HrEnsureClassManagersLoaded ();

public:
    CConnectionManager()
    {
        TraceTag (ttidConman, "New connection manager being created");
        AssertH (!g_pConMan);
        g_pConMan = this;
        m_lRegisteredOneTime = FALSE;
        m_hDevNotify = NULL;
        m_hRegNotify = NULL;
        m_hRegNotifyWait = NULL;
        m_hRegClassManagerKey = NULL;
        m_fRegisteredWithWmi = FALSE;
    }
    VOID FinalRelease ();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN)

    BEGIN_COM_MAP(CConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionRefresh)
        COM_INTERFACE_ENTRY(INetConnectionCMUtil)
        COM_INTERFACE_ENTRY(INetConnectionManagerEvents)
#if DBG
        COM_INTERFACE_ENTRY(INetConnectionManagerDebug)
#endif
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConnectionManager)
        CONNECTION_POINT_ENTRY(IID_INetConnectionNotifySink)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        NETCONMGR_ENUM_FLAGS    Flags,
        IEnumNetConnection**    ppEnum);

    // INetConnectionRefresh
    STDMETHOD (RefreshAll) ();
    STDMETHOD (ConnectionAdded) (INetConnection* pConnection);
    STDMETHOD (ConnectionDeleted) (const GUID* pguidId);
    STDMETHOD (ConnectionModified) (INetConnection* pConnection);
    STDMETHOD (ConnectionRenamed) (INetConnection* pConnection);
    STDMETHOD (ConnectionStatusChanged) (IN const GUID* pguidId, IN const NETCON_STATUS  ncs );
    STDMETHOD (ShowBalloon) (IN const GUID *pguidId, IN const BSTR szCookie, IN const BSTR szBalloonText);
    STDMETHOD (DisableEvents) (IN const BOOL fDisable, IN const ULONG ulDisableTimeout);

    // INetConnectionManagerEvents
    STDMETHOD (RefreshConnections) ();
    STDMETHOD (Enable) ();
    STDMETHOD (Disable) (IN ULONG ulDisableTimeout);

    // INetConnectionCMUtil
    STDMETHOD (MapCMHiddenConnectionToOwner) (
        /*[in]*/  REFGUID guidHidden,
        /*[out]*/ GUID * pguidOwner);

#if DBG
    // INetConnectionManagerDebug
    STDMETHOD (NotifyTestStart) ();
    STDMETHOD (NotifyTestStop) ();
#endif

    // Override Advise so we know when to register for LAN device
    // notifications.
    //
    STDMETHOD (Advise) (
        IUnknown* pUnkSink,
        DWORD* pdwCookie);

    STDMETHOD (Unadvise) (
        DWORD dwCookie);

public:
    static
    BOOL FHasActiveConnectionPoints ();

    static
    VOID NotifyClientsOfEvent (
        CONMAN_EVENT* pEvent);

private:
    friend HRESULT GetClientAdvises(LPWSTR** pppszAdviseUsers, LPDWORD pdwCount);
    static VOID NTAPI RegChangeNotifyHandler(IN LPVOID pContext, IN BOOLEAN fTimerFired);
};

VOID FreeConmanEvent (CONMAN_EVENT* pEvent);

HRESULT HrGetRasConnectionProperties(
    IN  const RASENUMENTRYDETAILS*      pDetails,
    OUT NETCON_PROPERTIES_EX**          ppPropsEx);

HRESULT HrGetIncomingConnectionPropertiesEx(
    IN  const HANDLE                    hRasConn,
    IN  const GUID*                     pguidId,
    IN  const DWORD                     dwType,
    OUT NETCON_PROPERTIES_EX**          ppPropsEx);

HRESULT
GetClientAdvises(LPWSTR** pppszAdviseUsers, LPDWORD pdwCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\cmutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M U T I L . C P P
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     omiller   1 Jun 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cmutil.h"
#include <objbase.h>
#include <ncmisc.h>

// Create an instance of CMUTIL so that we can be global
//
CCMUtil CCMUtil::s_instance;

CCMUtil::CCMUtil()
{
    InitializeCriticalSection( &m_CriticalSection );
}

CCMUtil::~CCMUtil()
{
    DeleteCriticalSection( &m_CriticalSection );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetIteratorFromGuid
//
//  Purpose:    Retrive the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid   [in]   GUID of the hidden connectiod to search for
//      cm     [out]  A pointer to the hidden entry
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
CCMUtil::CMEntryTable::iterator CCMUtil::GetIteratorFromGuid(const GUID & guid)
{
    CMEntryTable::iterator iter;

    // Search through the list of hidden connections
    //
    for (iter = m_Table.begin(); iter != m_Table.end(); iter++)
    {
        if( iter->m_guid == guid )
        {
            // Found the hidden connection that maps to this guid
            //
            return iter;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntry
//
//  Purpose:    Retrive the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid   [in]   GUID of the hidden connectiod to search for
//      cm     [out]  A copy to the hidden entry
//
//  Returns:    TRUE -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CCMUtil::HrGetEntry(const GUID & guid, CMEntry & cm)
{
    CMEntryTable::iterator iter;
    HRESULT hr = S_FALSE;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        cm = *iter;
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntry
//
//  Purpose:    Retrive the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      szEntryName   [in]   Name of the connection to look for
//      cm            [out]  A copy to the hidden entry
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CCMUtil::HrGetEntry(const WCHAR * szEntryName, CMEntry & cm)
{
    CMEntryTable::iterator iter;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    for (iter = m_Table.begin(); iter != m_Table.end(); iter++)
    {
        if( lstrcmp(iter->m_szEntryName,szEntryName) == 0 )
        {
            // Found the Hidden connectoid that maps to that name
            //
            cm = *iter;
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetEntry
//
//  Purpose:    Stores or Updates the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid          [in]   Guid of the Hidden connectiod
//      szEntryName   [in]   Name of the Hidden connectiod
//      ncs           [in]   Status of the hidden connectiod
//
//  Returns:    nothing
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
void CCMUtil::SetEntry(const GUID & guid, const WCHAR * szEntryName, const NETCON_STATUS ncs)
{
    CMEntryTable::iterator iter;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        iter->Set(guid,szEntryName,ncs);
    }
    else
    {
        m_Table.push_back( CMEntry(guid,szEntryName,ncs) );
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveEntry
//
//  Purpose:    Removes a hidden connectiod from the list
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid          [in]   Guid of the Hidden connectiod
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
void CCMUtil::RemoveEntry(const GUID & guid)
{
/*
    CMEntryTable::iterator iter;

    EnterCriticalSection(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        m_Table.erase(iter);
    }
    
    LeaveCriticalSection(&m_CriticalSection);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmani.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N I . C P P
//
//  Contents:   Class manager for Inbound connections.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmani.h"
#include "enumi.h"
#include "ncbase.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
STDMETHODIMP
CInboundConnectionManager::EnumConnections (
    NETCONMGR_ENUM_FLAGS    Flags,
    IEnumNetConnection**    ppEnum)
{
    HRESULT hr = CInboundConnectionManagerEnumConnection::CreateInstance (
                    Flags,
                    IID_IEnumNetConnection,
                    reinterpret_cast<void**>(ppEnum));

    TraceError ("CInboundConnectionManager::EnumConnections", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmani.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N I . H
//
//  Contents:   Class manager for Inbound connections.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CInboundConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnectionManager,
                        &CLSID_WanConnectionManager>,
    public IConnectionPointContainerImpl <CInboundConnectionManager>,
    public INetConnectionManager
{
public:
    CInboundConnectionManager()
    {
    }

    DECLARE_CLASSFACTORY_SINGLETON(CInboundConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONMAN)

    BEGIN_COM_MAP(CInboundConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CInboundConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        NETCONMGR_ENUM_FLAGS    Flags,
        IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conman2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N 2 . C P P
//
//  Contents:   Connection manager 2.
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <atlbase.h>
#include "cobase.h"
#include "conman.h"
#include "conman2.h"
#include "dialup.h"
#include "ncnetcon.h"

HRESULT CConnectionManager2::EnumConnectionProperties(OUT SAFEARRAY** ppsaConnectionProperties)
{
    CComPtr<INetConnectionManager> pConMan;
    NETCON_PROPERTIES_EX* pPropsEx;
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_INPROC, IID_INetConnectionManager, reinterpret_cast<void**>(&pConMan));

    if (SUCCEEDED(hr))
    {
        CComPtr<IEnumNetConnection> pNetConnection;
        hr = pConMan->EnumConnections(NCME_DEFAULT, &pNetConnection);
        if (SUCCEEDED(hr))
        {   
            INetConnection* pConn;
            ULONG ulFetched;
            LISTNETCONPROPEX listNCProperties;
            ITERNETCONPROPEX iterProps;
        
            HRESULT hrFetched = S_OK;
            do
            {
                hrFetched = pNetConnection->Next(1, &pConn, &ulFetched);
                if ( (S_OK == hr) && (ulFetched) )
                {
                    CComPtr<INetConnection2> pConn2;
                    
                    hr = pConn->QueryInterface(IID_INetConnection2, reinterpret_cast<void**>(&pConn2));
                    if (SUCCEEDED(hr))
                    {
                        hr = pConn2->GetPropertiesEx(&pPropsEx);
                    }
                    else
                    {
                        NETCON_PROPERTIES* pProps;
                        hr = pConn->GetProperties(&pProps);
                        if (SUCCEEDED(hr))
                        {
                            pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));
                            
                            if (pPropsEx)
                            {
                                CComPtr<IPersistNetConnection> pPersistNetConnection;
                                hr = pConn->QueryInterface(IID_IPersistNetConnection, reinterpret_cast<LPVOID *>(&pPersistNetConnection));
                                if (SUCCEEDED(hr))
                                {
                                    ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));
                                    hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, pPersistNetConnection);
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            FreeNetconProperties(pProps);
                        }
                    }

                    if (S_OK == hr)
                    {
                        listNCProperties.insert(listNCProperties.end(), pPropsEx);
                    }
                    else
                    {
                        TraceTag(ttidError, "Failed to retrieve connection information for connection. Connection will be ommitted from Connections Folder.");
                    }

                    ReleaseObj(pConn);
                }
            } while ( (S_OK == hrFetched) && (ulFetched) );

            if (listNCProperties.size())
            {
                hr = S_OK;
                
                if (listNCProperties.size() != 0)
                {
                    SAFEARRAYBOUND rgsaBound[1];
                    LONG lIndex;
                    rgsaBound[0].cElements = listNCProperties.size();
                    rgsaBound[0].lLbound = 0;
                    lIndex = rgsaBound[0].lLbound;
                    *ppsaConnectionProperties = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
                    for (ITERNETCONPROPEX iter = listNCProperties.begin(); iter != listNCProperties.end(); iter++)
                    {
                        HRESULT hrT = S_OK;
                        VARIANT varElement;
                        SAFEARRAY* psaPropertiesEx = NULL;

                        pPropsEx = *iter;

                        hrT = HrSafeArrayFromNetConPropertiesEx(pPropsEx, &psaPropertiesEx);

                        if (SUCCEEDED(hrT))
                        {
                            VariantInit(&varElement);
                            varElement.vt = VT_VARIANT | VT_ARRAY;
                            varElement.parray = psaPropertiesEx;

                            hrT = SafeArrayPutElement(*ppsaConnectionProperties, &lIndex, &varElement);
                            VariantClear(&varElement);
                        }

                        if (FAILED(hrT))
                        {
                            hr = hrT;
                            break;
                        }

                        lIndex++;
                    }
                }
            }

            for (ITERNETCONPROPEX iter = listNCProperties.begin(); iter != listNCProperties.end(); iter++)
            {   
                HrFreeNetConProperties2(*iter);
            }
        }
    }

    if (SUCCEEDED(hr) && !(*ppsaConnectionProperties) )
    {
        hr = S_FALSE;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CConnectionManager2::EnumConnectionProperties");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmanl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N . C P P
//
//  Contents:   Implementation of LAN connection class manager
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmanl.h"
#include "enuml.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManager::EnumConnections
//
//  Purpose:    Returns an enumerator object for LAN connections
//
//  Arguments:
//      Flags        [in]       Must be NCF_ALL_USERS
//      ppEnum       [out]      Returns enumerator object
//
//  Returns:    S_OK if succeeded, OLE or Win32 error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManager::EnumConnections(NETCONMGR_ENUM_FLAGS Flags,
                                                    IEnumNetConnection** ppEnum)
{
    HRESULT hr = CLanConnectionManagerEnumConnection::CreateInstance(Flags,
                                        IID_IEnumNetConnection,
                                        reinterpret_cast<LPVOID*>(ppEnum));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmansa.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "upnp.h"
#include "upnpp.h"
#include "cmsaclbk.h"

#include "hnetbcon.h"
#include "winsock2.h"

class ATL_NO_VTABLE CSharedAccessConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnectionManager,
                        &CLSID_SharedAccessConnectionManager>,
    public IConnectionPointContainerImpl <CSharedAccessConnectionManager>,
    public INetConnectionManager,
    public ISharedAccessBeaconFinder
{
public:
    CSharedAccessConnectionManager();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CSharedAccessConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONMAN)

    BEGIN_COM_MAP(CSharedAccessConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(ISharedAccessBeaconFinder)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CSharedAccessConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHODIMP EnumConnections(NETCONMGR_ENUM_FLAGS Flags, IEnumNetConnection** ppEnum);

    // IBeaconFinder
    STDMETHODIMP GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:

    VOID static CALLBACK AsyncStartSearching(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
    HRESULT StartSearch(void);

    LONG m_lSearchCookie;
    IUPnPDeviceFinder* m_pDeviceFinder;
    CComObject<CSharedAccessDeviceFinderCallback>* m_pDeviceFinderCallback;
    WSAEVENT m_SocketEvent;
    HANDLE m_hSocketNotificationWait;
    SOCKET m_DummySocket;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmanl.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CLanConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnectionManager,
                        &CLSID_LanConnectionManager>,
    public IConnectionPointContainerImpl <CLanConnectionManager>,
    public INetConnectionManager
{
public:
    CLanConnectionManager()
    {
    }

    DECLARE_CLASSFACTORY_SINGLETON(CLanConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONMAN)

    BEGIN_COM_MAP(CLanConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CLanConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        NETCONMGR_ENUM_FLAGS    Flags,
        IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmanw.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N W . C P P
//
//  Contents:   Class manager for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmanw.h"
#include "enumw.h"
#include "ncbase.h"
#include <ras.h>

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CWanConnectionManager::EnumConnections (
    NETCONMGR_ENUM_FLAGS    Flags,
    IEnumNetConnection**    ppEnum)
{
    HRESULT hr = CWanConnectionManagerEnumConnection::CreateInstance (
                    Flags,
                    IID_IEnumNetConnection,
                    reinterpret_cast<void**>(ppEnum));

    TraceError ("CWanConnectionManager::EnumConnections", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmansa.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N M A N S A. C P P
//
//  Contents:   Implementation of ICS connection class manager
//
//  Notes:
//
//  Author:     kenwic   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmansa.h"
#include "enumsa.h"
#include "cmsabcon.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//
CSharedAccessConnectionManager::CSharedAccessConnectionManager()
{
    m_lSearchCookie = 0;
    m_pDeviceFinder = NULL;
    m_pDeviceFinderCallback = NULL;
    m_SocketEvent = WSA_INVALID_EVENT; 
    m_hSocketNotificationWait = INVALID_HANDLE_VALUE;
    m_DummySocket = INVALID_SOCKET;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManager::EnumConnections
//
//  Purpose:    Returns an enumerator object for ICS connections
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]      Returns enumerator object
//
//  Returns:    S_OK if succeeded, OLE or Win32 error code otherwise
//
//  Author:     kenwic   17 Jul 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManager::EnumConnections(NETCONMGR_ENUM_FLAGS Flags,
                                                    IEnumNetConnection** ppEnum)
{
    *ppEnum = NULL;

    CComObject<CSharedAccessConnectionManagerEnumConnection>* pEnum;
    HRESULT hr = CComObject<CSharedAccessConnectionManagerEnumConnection>::CreateInstance(&pEnum);
    if(SUCCEEDED(hr))
    {
        *ppEnum = static_cast<IEnumNetConnection*>(pEnum);
        pEnum->AddRef();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::EnumConnections");
    return hr;
}

HRESULT CSharedAccessConnectionManager::FinalConstruct(void)
{
    HRESULT hr = S_OK;
    
    m_DummySocket = socket(AF_INET, SOCK_DGRAM, 0);
    if(INVALID_SOCKET != m_DummySocket)
    {
        m_SocketEvent = CreateEvent(NULL, FALSE, TRUE, NULL);  
        if(NULL != m_SocketEvent)
        {
            if(0 != WSAEventSelect(m_DummySocket, m_SocketEvent, FD_ADDRESS_LIST_CHANGE))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr)) // start up the first search on a background thread, this shoud fire immediately
    {
        // note that there is no addref here because it would keep the object alive forever.  In FinalRelease we will make sure we won't get called back
        if(0 == RegisterWaitForSingleObject(&m_hSocketNotificationWait, m_SocketEvent, AsyncStartSearching, this, INFINITE, WT_EXECUTEDEFAULT))
        {
            m_hSocketNotificationWait = INVALID_HANDLE_VALUE;
        }

    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::FinalConstruct");
    
    return hr;
}

HRESULT CSharedAccessConnectionManager::FinalRelease(void)
{
    HRESULT hr = S_OK;

    if(INVALID_HANDLE_VALUE != m_hSocketNotificationWait)
    {
        UnregisterWaitEx(m_hSocketNotificationWait, INVALID_HANDLE_VALUE); // we must block here since we are not addrefed
    }

    if(INVALID_SOCKET != m_DummySocket) // the event wait must be unregistered first
    {
        closesocket(m_DummySocket);
    }

    if(WSA_INVALID_EVENT != m_SocketEvent) // the socket must be closed first
    {
        CloseHandle(m_SocketEvent);
    }

    // After the other thread is shut down, the device finder and callback won't change any more so we don't need a lock.  

    if(NULL != m_pDeviceFinder)
    {
        hr = m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie);
        m_pDeviceFinder->Release();
    }

    if(NULL != m_pDeviceFinderCallback) 
    {
        m_pDeviceFinderCallback->Release();
    }


    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::FinalRelease");

    return hr;
}

HRESULT CSharedAccessConnectionManager::StartSearch(void)
{
    HRESULT hr = S_OK;

    CComObject<CSharedAccessDeviceFinderCallback>* pDeviceFinderCallback;
    hr = CComObject<CSharedAccessDeviceFinderCallback>::CreateInstance(&pDeviceFinderCallback);
    if(SUCCEEDED(hr))
    {
        pDeviceFinderCallback->AddRef();
        
        IUPnPDeviceFinder* pDeviceFinder;
        hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&pDeviceFinder));
        if(SUCCEEDED(hr))
        {
            
            BSTR bstrTypeURI;
            bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:1");
            if (NULL != bstrTypeURI)
            {
                LONG lSearchCookie;
                hr = pDeviceFinder->CreateAsyncFind(bstrTypeURI, 0, static_cast<IUPnPDeviceFinderCallback*>(pDeviceFinderCallback), &lSearchCookie);
                if(SUCCEEDED(hr))
                {
                    LONG lOldSearchCookie;
                    IUPnPDeviceFinder* pOldDeviceFinder;
                    CComObject<CSharedAccessDeviceFinderCallback>* pOldDeviceFinderCallback;

                    
                    Lock(); // swap in the new finder and callback
                    
                    lOldSearchCookie = m_lSearchCookie;
                    m_lSearchCookie = lSearchCookie;

                    pOldDeviceFinder = m_pDeviceFinder;
                    m_pDeviceFinder = pDeviceFinder;
                    pDeviceFinder->AddRef();
                    
                    pOldDeviceFinderCallback = m_pDeviceFinderCallback;
                    m_pDeviceFinderCallback = pDeviceFinderCallback;
                    pDeviceFinderCallback->AddRef();
                    
                    Unlock();
                    
                    if(NULL != pOldDeviceFinder) 

                    {
                        pOldDeviceFinder->CancelAsyncFind(lOldSearchCookie);
                        pOldDeviceFinder->Release();
                    }
                    
                    if(NULL != pOldDeviceFinderCallback)
                    {
                        pOldDeviceFinderCallback->DeviceRemoved(NULL, NULL); // clear out the old callback, so netshell gets cleaned up
                        pOldDeviceFinderCallback->Release();
                    }
                    
                    hr = pDeviceFinder->StartAsyncFind(lSearchCookie); // don't start the search until the new callback is in place

                }
                SysFreeString(bstrTypeURI);
            }
            pDeviceFinder->Release();
        }
        
        pDeviceFinderCallback->Release();
    }

    DWORD dwBytesReturned;
    if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
    {
        hr = E_FAIL;
    }
    

    WSANETWORKEVENTS NetworkEvents;
    ZeroMemory(&NetworkEvents, sizeof(NetworkEvents));
    WSAEnumNetworkEvents(m_DummySocket, NULL, &NetworkEvents);

    return hr;
}

void CSharedAccessConnectionManager::AsyncStartSearching(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    if(FALSE == TimerOrWaitFired)
    {
        CSharedAccessConnectionManager* pThis = reinterpret_cast<CSharedAccessConnectionManager*>(lpParameter);
        
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if(SUCCEEDED(hr))
        {
            hr = pThis->StartSearch();
            CoUninitialize();
        }
    }
    return;
}



HRESULT CSharedAccessConnectionManager::GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;
    
    CComObject<CSharedAccessDeviceFinderCallback>* pDeviceFinderCallback;
    
    Lock();
    
    pDeviceFinderCallback = m_pDeviceFinderCallback;
    
    if(NULL != pDeviceFinderCallback)
    {
        pDeviceFinderCallback->AddRef();
    }
    
    Unlock();

    if(NULL != pDeviceFinderCallback)
    {
        hr = pDeviceFinderCallback->GetSharedAccessBeacon(DeviceId, ppSharedAccessBeacon);
        pDeviceFinderCallback->Release();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\conmanw.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N W . H
//
//  Contents:   Class manager for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CWanConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CWanConnectionManager,
                        &CLSID_WanConnectionManager>,
    public IConnectionPointContainerImpl <CWanConnectionManager>,
    public INetConnectionManager
{
public:
    CWanConnectionManager()
    {
    }

    DECLARE_CLASSFACTORY_SINGLETON(CWanConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_WAN_CONMAN)

    BEGIN_COM_MAP(CWanConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CWanConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        NETCONMGR_ENUM_FLAGS    Flags,
        IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\deadcode1.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A I C . C P P
//
//  Contents:   Notification support for active inbound ras connections.
//
//  Notes:
//
//  Author:     shaunco   24 Feb 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "aic.h"
#include "conman.h"
#include "mprapi.h"
#include "ncmisc.h"
#include "nmbase.h"
#include <raserror.h>

ASSERTDATA;


// This is the global data representing active inbound ras connections.
//
struct ACTIVE_INBOUND_RAS_CONNECTIONS
{
    // This is set after calling AicInitialize.
    //
    BOOL                fInitialized;

    // This critical section protects reading and writing to members of
    // this structure.
    //
    CRITICAL_SECTION    critsec;

    // This is the array and count of active ras connections.
    //
// Note: (shaunco) 28 Apr 1998: RASSRVCONN is too big to keep an
// array off.  We'll have to roll our own structure and keep what's
// important.
//    RASSRVCONN*         aRasConn;
//    DWORD               cRasConn;

    // This is the event handle that is signled when a connection is
    // connected or disconnected.
    //
    HANDLE              hEvent;

    // This is the wait handle returned from RtlRegisterWait.
    //
    HANDLE              hWait;

    // This is set after the first call to HrAicEnsureCachedAndListening.
    //
    BOOL                fCachedAndListening;
};

ACTIVE_INBOUND_RAS_CONNECTIONS g_Aic = { 0 };

//+---------------------------------------------------------------------------
//
//  Function:   AicInitialize
//
//  Purpose:    Initialize this module for use.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Feb 1998
//
//  Notes:      This can only be called once.  It must be called before
//              any other Aic* API can be called.
//
VOID
AicInitialize ()
{
    Assert (!g_Aic.fInitialized);

    InitializeCriticalSection (&g_Aic.critsec);
    g_Aic.fInitialized = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AicUninitialize
//
//  Purpose:    Uninitialize this module.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Feb 1998
//
//  Notes:      This can only be called once.  It must be called after the
//              last call to any other Aic* API.
//
VOID
AicUninitialize ()
{
    Assert (g_Aic.fInitialized);

    if (g_Aic.fCachedAndListening)
    {
        CExceptionSafeLock EsLock (&g_Aic.critsec);

        if (g_Aic.hWait)
        {
            TraceTag (ttidWanCon, "AicUninitialize: calling RtlDeregisterWait");

            RtlDeregisterWait (g_Aic.hWait);
            g_Aic.hWait = NULL;
        }

        TraceTag (ttidWanCon, "AicUninitialize: closing event handle");

        CloseHandle (g_Aic.hEvent);
        g_Aic.hEvent = NULL;

//        MemFree (g_Aic.aRasConn);
//        g_Aic.aRasConn = NULL;
//        g_Aic.cRasConn = 0;


        g_Aic.fCachedAndListening = FALSE;
    }

    // We can't delete the critical section unless we can guarantee
    // that no other API (like HrAicFindRasConnFromGuidId)
    // will be called.  (This is assumed.)
    //
    DeleteCriticalSection (&g_Aic.critsec);
    g_Aic.fInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AicWaitCallback
//
//  Purpose:    Called by the RTL thread pool for this process when
//              g_Aic.hEvent is signaled.  This event will be signaled by
//              the RemoteAccess service when the state of an incoming
//              connection changes.
//
//  Arguments:
//      pvContext [in]  Our user data.  (Not used here.)
//      fTimeout  [in]  TRUE if we were called because of a timeout.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Feb 1998
//
//  Notes:      Be quick about this.  We're being called on a thread provided
//              by the system.
//
VOID
NTAPI
AicWaitCallback (
    PVOID   pvContext,
    BOOLEAN fTimeout)
{
    Assert (g_Aic.fInitialized);
    Assert (g_Aic.fCachedAndListening);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        TraceTag (ttidWanCon, "AicWaitCallback called while service is not "
            "in SERVICE_RUNNING state.  Ignoring.");
        return;
    }

    TraceTag (ttidWanCon, "AicWaitCallback called");

    HRESULT hr = S_OK;

    // Lock scope
    {
        // Prevent other threads from reading the data we are about to update.
        //
/*
        DWORD cRasConnOld = g_Arc.cRasConn;

        MemFree (g_Arc.aRasConn);
        hr = HrRasEnumAllActiveConnections (&g_Arc.aRasConn, &g_Arc.cRasConn);

        TraceTag (ttidWanCon,
            "ArcWaitCallback called: connection count: %u -> %u",
            cRasConnOld,
            g_Arc.cRasConn);
*/
    }


    // Tell the connection manager to advise it's clients that a change
    // occured and re-enumeration is neccessary.
    //
    CConnectionManager::NotifyClientsOfChange ();

    TraceHr (ttidError, FAL, hr, FALSE, "AicWaitCallback");
}

HRESULT
HrAicEnsureCachedAndListening ()
{
    Assert (g_Aic.fInitialized);

    if (g_Aic.fCachedAndListening)
    {
        return S_OK;
    }

    g_Aic.fCachedAndListening = TRUE;
    TraceTag (ttidWanCon, "Initializing active incoming ras "
            "connections cache...");

    HRESULT hr = E_FAIL;

    CExceptionSafeLock EsLock (&g_Aic.critsec);

    // Create a auto-reset event and register it with
    // MprAdminConnectionNotification.
    //
    g_Aic.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (g_Aic.hEvent)
    {
        HANDLE hMprAdmin;
        DWORD dwErr = MprAdminServerConnect (NULL, &hMprAdmin);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceHr (ttidError, FAL, hr, FALSE, "MprAdminServerConnect", hr);

        if (SUCCEEDED(hr))
        {
            dwErr = MprAdminRegisterConnectionNotification (
                            hMprAdmin, g_Aic.hEvent);

            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceHr (ttidError, FAL, hr, FALSE,
                    "MprAdminRegisterConnectionNotification", hr);

            if (SUCCEEDED(hr))
            {
                NTSTATUS status;
                status = RtlRegisterWait (&g_Aic.hWait, g_Aic.hEvent,
                            AicWaitCallback, NULL, INFINITE, WT_EXECUTEDEFAULT);

                if (!NT_SUCCESS(status))
                {
                    hr = HRESULT_FROM_NT (status);
                    TraceHr (ttidError, FAL, hr, FALSE,
                            "RtlRegisterWait", hr);
                }
                else
                {
                    TraceTag (ttidWanCon, "Cached and listening for "
                        "incoming ras connection state changes...");
                    hr = S_OK;
                }

                if (FAILED(hr))
                {
                    MprAdminDeregisterConnectionNotification (hMprAdmin,
                        g_Aic.hEvent);
                }
            }

            MprAdminServerDisconnect (hMprAdmin);
        }

        if (FAILED(hr))
        {
            CloseHandle (g_Aic.hEvent);
            g_Aic.hEvent = NULL;
        }
    }
    else
    {
        hr = HrFromLastWin32Error ();
        TraceHr (ttidError, FAL, hr, FALSE, "CreateEvent", hr);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrAicEnsureCachedAndListening");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . H
//
//  Contents:   Enumerator for connection objects.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CConnectionManagerEnumConnection,
                        &CLSID_ConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;

    // m_ClassManagers is a binary tree (STL map) of pointers to the
    // INetConnectionManager interfaces implemented by our registered
    // class managers, indexed by the GUIDs of the class manager.
    //
    CLASSMANAGERMAP                     m_mapClassManagers;

    // m_iCurClassMgr is the iterator into the above map for the current
    // class manager involved in the enumeration.
    //
    CLASSMANAGERMAP::iterator           m_iterCurClassMgr;

    // m_penumCurClassMgr is the enumerator corresponding to the current
    // class manager.
    IEnumNetConnection*                 m_penumCurClassMgr;

private:
    VOID ReleaseCurrentClassEnumerator ()
    {
        ReleaseObj (m_penumCurClassMgr);
        m_penumCurClassMgr = NULL;
    }

public:
    CConnectionManagerEnumConnection ()
    {
        m_EnumFlags         = NCME_DEFAULT;
        m_penumCurClassMgr  = NULL;
        m_iterCurClassMgr   = m_mapClassManagers.begin();
    }
    VOID FinalRelease ();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN_ENUM)

    BEGIN_COM_MAP(CConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        NETCONMGR_ENUM_FLAGS                Flags,
        CLASSMANAGERMAP&                    mapClassManagers,
        REFIID                              riid,
        VOID**                              ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\deadcode2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R C . C P P
//
//  Contents:   Notification support for active ras connections.
//
//  Notes:      This module maintains a global array of active RAS connections.
//              This array is initialized with a call to
//              HrArcEnsureCachedAndListening.  A thread waits for
//              notifications that a RAS connection has either been connected
//              or disconnected.  When this happens, the thread calls
//              ArcWaitCallback which updates the
//              global array.  The thread gets its handle to wait on from
//              HrArcEnsureCachedAndListening.  The thread is not implemented
//              here but rather a sytem-provide thread pool is used.
//
//  Author:     shaunco   7 Feb 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arc.h"
#include "conman.h"
#include "ncmisc.h"
#include "ncras.h"
#include "nmbase.h"
#include <raserror.h>

ASSERTDATA;


// This is the global data representing active ras connections.
//
struct ACTIVE_RAS_CONNECTIONS
{
    // This is set after calling ArcInitialize.
    //
    BOOL                fInitialized;

    // This critical section protects reading and writing to members of
    // this structure.
    //
    CRITICAL_SECTION    critsec;

    // This is the array and count of active ras connections.
    //
    RASCONN*            aRasConn;
    DWORD               cRasConn;

    // This is the event handle that is signled when a connection is
    // connected or disconnected.
    //
    HANDLE              hEvent;

    // This is the wait handle returned from RtlRegisterWait.
    //
    HANDLE              hWait;

    // This is set after the first call to HrArcEnsureCachedAndListening.
    //
    BOOL                fCachedAndListening;
};

ACTIVE_RAS_CONNECTIONS  g_Arc = { 0 };


//+---------------------------------------------------------------------------
//
//  Function:   ArcInitialize
//
//  Purpose:    Initialize this module for use.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Feb 1998
//
//  Notes:      This can only be called once.  It must be called before
//              any other Arc* API can be called.
//
VOID
ArcInitialize ()
{
    Assert (!g_Arc.fInitialized);

    InitializeCriticalSection (&g_Arc.critsec);
    g_Arc.fInitialized = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ArcUninitialize
//
//  Purpose:    Uninitialize this module.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Feb 1998
//
//  Notes:      This can only be called once.  It must be called after the
//              last call to any other Arc* API.
//
VOID
ArcUninitialize ()
{
    Assert (g_Arc.fInitialized);

    if (g_Arc.fCachedAndListening)
    {
        CExceptionSafeLock EsLock (&g_Arc.critsec);

        if (g_Arc.hWait)
        {
            TraceTag (ttidWanCon, "ArcUninitialize: calling RtlDeregisterWait");

            RtlDeregisterWait (g_Arc.hWait);
            g_Arc.hWait = NULL;
        }

        TraceTag (ttidWanCon, "ArcUninitialize: closing event handle");
        CloseHandle (g_Arc.hEvent);
        g_Arc.hEvent = NULL;

        MemFree (g_Arc.aRasConn);
        g_Arc.aRasConn = NULL;
        g_Arc.cRasConn = 0;

        g_Arc.fCachedAndListening = FALSE;
    }

    // We can't delete the critical section unless we can guarantee
    // that no other API (like HrArcFindRasConnFromGuidId)
    // will be called.  (This is assumed.)
    //
    DeleteCriticalSection (&g_Arc.critsec);
    g_Arc.fInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ArcWaitCallback
//
//  Purpose:    Called by the RTL thread pool for this process when
//              g_Arc.hEvent is signaled.  This event will be signaled by
//              the Rasman service when the state of an outgoing
//              connection changes.
//
//  Arguments:
//      pvContext [in]  Our user data.  (Not used here.)
//      fTimeout  [in]  TRUE if we were called because of a timeout.
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Feb 1998
//
//  Notes:      Be quick about this.  We're being called on a thread provided
//              by the system.
//
VOID
NTAPI
ArcWaitCallback (
    PVOID   pvContext,
    BOOLEAN fTimeout)
{
    Assert (g_Arc.fInitialized);
    Assert (g_Arc.fCachedAndListening);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        TraceTag (ttidWanCon, "ArcWaitCallback called while service is not "
            "in SERVICE_RUNNING state.  Ignoring.");
        return;
    }

    HRESULT hr = S_OK;

    // Lock scope
    {
        // Prevent other threads from reading the data we are about to update.
        //
        CExceptionSafeLock EsLock (&g_Arc.critsec);

        DWORD cRasConnOld = g_Arc.cRasConn;

        MemFree (g_Arc.aRasConn);
        hr = HrRasEnumAllActiveConnections (&g_Arc.aRasConn, &g_Arc.cRasConn);

        TraceTag (ttidWanCon,
            "ArcWaitCallback called: connection count: %u -> %u",
            cRasConnOld,
            g_Arc.cRasConn);
    }

    // Tell the connection manager to advise it's clients that a change
    // occured and re-enumeration is neccessary.
    //
    CConnectionManager::NotifyClientsOfChange ();

    TraceHr (ttidError, FAL, hr, FALSE, "ArcWaitCallback");
}

HRESULT
HrArcEnsureCachedAndListening ()
{
    Assert (g_Arc.fInitialized);

    if (g_Arc.fCachedAndListening)
    {
        return S_OK;
    }

    g_Arc.fCachedAndListening = TRUE;
    TraceTag (ttidWanCon, "Initializing active ras "
            "connections cache...");

    HRESULT hr = E_FAIL;

    // Prevent other threads from reading the data we are about to update.
    //
    CExceptionSafeLock EsLock (&g_Arc.critsec);

    // Create an auto-reset event and register it with
    // RasConnectionNotification.
    //
    g_Arc.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (g_Arc.hEvent)
    {
        // We want to register for state changes to all connection objects
        // so we pass INVALID_HANDLE_VALUE for the first parameter.
        //
        DWORD dwErr = RasConnectionNotification (
                        reinterpret_cast<HRASCONN>(INVALID_HANDLE_VALUE),
                        g_Arc.hEvent,
                        RASCN_Connection | RASCN_Disconnection |
                        RASCN_BandwidthAdded | RASCN_BandwidthRemoved);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceHr (ttidError, FAL, hr, FALSE, "RasConnectionNotification", hr);

        if (SUCCEEDED(hr))
        {
            // Initialize the array of active RAS connections before
            // registering for a wait callack on the event.
            //
            MemFree (g_Arc.aRasConn);
            hr = HrRasEnumAllActiveConnections (&g_Arc.aRasConn,
                    &g_Arc.cRasConn);
            if (SUCCEEDED(hr))
            {
                NTSTATUS status;
                status = RtlRegisterWait (&g_Arc.hWait, g_Arc.hEvent,
                            ArcWaitCallback, NULL, INFINITE, WT_EXECUTEDEFAULT);

                if (!NT_SUCCESS(status))
                {
                    hr = HRESULT_FROM_NT (status);
                    TraceHr (ttidError, FAL, hr, FALSE,
                            "RtlRegisterWait", hr);
                }
                else
                {
                    TraceTag (ttidWanCon, "Cached and listening for "
                        "ras connection state changes...");

                    hr = S_OK;
                }

                if (FAILED(hr))
                {
                    MemFree (g_Arc.aRasConn);
                    g_Arc.aRasConn = NULL;
                }
            }
        }

        if (FAILED(hr))
        {
            CloseHandle (g_Arc.hEvent);
            g_Arc.hEvent = NULL;
        }
    }
    else
    {
        hr = HrFromLastWin32Error ();
        TraceHr (ttidError, FAL, hr, FALSE, "CreateEvent", hr);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrArcEnsureCachedAndListening");
    return hr;
}

HRESULT
HrArcFindRasConnFromGuidId (
    const GUID* pguidId,
    HRASCONN*   phRasConn)
{
    Assert (g_Arc.fInitialized);
    Assert (pguidId);
    Assert (phRasConn);

    // Initialize the output parameter.
    //
    *phRasConn = NULL;

    HRESULT hr = S_FALSE;

    // Prevent the update thread from updating the data
    // until we are done reading it.
    //
    CExceptionSafeLock EsLock (&g_Arc.critsec);

    for (DWORD dwIndex = 0; dwIndex < g_Arc.cRasConn; dwIndex++)
    {
        if (*pguidId == g_Arc.aRasConn[dwIndex].guidEntry)
        {
            *phRasConn = g_Arc.aRasConn[dwIndex].hrasconn;
            hr = S_OK;
            break;
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "HrArcFindRasConnFromGuidId");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M I . H
//
//  Contents:   Enumerator for Inbound connection objects.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasuip.h>


class ATL_NO_VTABLE CInboundConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnectionManagerEnumConnection,
                        &CLSID_WanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;
    RASSRVCONN*             m_aRasSrvConn;
    ULONG                   m_cRasSrvConn;
    ULONG                   m_iNextRasSrvConn;
    BOOL                    m_fFirstTime;
    BOOL                    m_fDone;
    BOOL                    m_fReturnedConfig;

private:
    HRESULT
    HrCreateConfigOrCurrentEnumeratedConnection (
        BOOL                fIsConfigConnection,
        INetConnection**    ppCon);

    HRESULT
    HrNextOrSkip (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

public:
    CInboundConnectionManagerEnumConnection ();
    ~CInboundConnectionManagerEnumConnection ();

    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONMAN_ENUM)

    BEGIN_COM_MAP(CInboundConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        NETCONMGR_ENUM_FLAGS    Flags,
        REFIID                  riid,
        VOID**                  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enum.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . C P P
//
//  Contents:   Enumerator for connection objects.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enum.h"
#include "nccom.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the connection manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags            [in]
//      vecClassManagers [in]
//      riid             [in]
//      ppv              [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   22 Sep 1997
//
//  Notes:
//
HRESULT
CConnectionManagerEnumConnection::CreateInstance (
    NETCONMGR_ENUM_FLAGS                Flags,
    CLASSMANAGERMAP&                    mapClassManagers,
    REFIID                              riid,
    void**                              ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags   = Flags;

        // Copy the array of class managers and AddRef them since
        // we will be holding on to them.
        //

        pObj->m_mapClassManagers = mapClassManagers;
        for (CLASSMANAGERMAP::iterator iter = pObj->m_mapClassManagers.begin(); iter != pObj->m_mapClassManagers.end(); iter++)
        {
            AddRefObj (iter->second);
        }
        pObj->m_iterCurClassMgr   = pObj->m_mapClassManagers.begin();

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManagerEnumConnection::FinalRelease
//
//  Purpose:    COM Destructor.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   22 Sep 1997
//
//  Notes:
//
void
CConnectionManagerEnumConnection::FinalRelease ()
{
    // Release the current enumerator if we have one.
    //
    ReleaseObj (m_penumCurClassMgr);

    // Release our class managers.
    //
    for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
    {
        ReleaseObj (iter->second);
    }
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//
// See documentation in MSDN for any IEnumXXX interface.
//

STDMETHODIMP
CConnectionManagerEnumConnection::Next (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    HRESULT hr;
    ULONG   celtFetched;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto finished;
    }

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    ZeroMemory (rgelt, sizeof (*rgelt) * celt);

    // Ask the current class manager to fulfill the request.  If he only
    // partially does, move to the next class manager.  Do this until
    // the request is fulfilled, or we run out of class managers.
    //
    celtFetched = 0;
    hr = S_FALSE;

    { // begin lock scope
    CExceptionSafeComObjectLock EsLock (this);

        while ((S_FALSE == hr) && (celtFetched < celt) &&
               (m_iterCurClassMgr != m_mapClassManagers.end()))
        {
            // Get the connection enumerator from the current class manager
            // if neccesary.
            //
            if (!m_penumCurClassMgr)
            {
                INetConnectionManager* pConMan = m_iterCurClassMgr->second;

                Assert (pConMan);

                hr = pConMan->EnumConnections (m_EnumFlags,
                            &m_penumCurClassMgr);
            }
            if (SUCCEEDED(hr))
            {
                Assert (m_penumCurClassMgr);

                // Each class manager should request only what was reqeuested
                // less what has already been fetched.
                //
                ULONG celtT;
                hr = m_penumCurClassMgr->Next (celt - celtFetched,
                        rgelt + celtFetched, &celtT);

                if (SUCCEEDED(hr))
                {
                    celtFetched += celtT;

                    // If the current class manager couldn't fill the entire
                    // request, go to the next one.
                    //
                    if (S_FALSE == hr)
                    {
                        ReleaseCurrentClassEnumerator ();
                        Assert (!m_penumCurClassMgr);
                        m_iterCurClassMgr++;
                    }
                }
            }
        }
        Assert (FImplies (S_OK == hr, (celtFetched == celt)));
    } // end lock scope

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidConman, "Enumerated %d total connections", celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
        {
            ReleaseObj (rgelt[ulIndex]);
            rgelt[ulIndex] = NULL;
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

finished:
    TraceErrorOptional ("CConnectionManagerEnumConnection::Next", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Skip (
    ULONG   celt)
{
    // Unfortunately, this method doesn't return the number of objects
    // actually skipped.  To implement this correctly across the multiple
    // class managers, we'd need to know how many they skipped similiar
    // to the way we implement Next.
    //
    // So, we'll cheese out and implement this by actually calling
    // Next for the reqested number of elements and just releasing what
    // we get back.
    //
    HRESULT hr = S_OK;
    if (celt)
    {
        INetConnection** rgelt;

        CExceptionSafeComObjectLock EsLock (this);

        hr = E_OUTOFMEMORY;
        rgelt = (INetConnection**)MemAlloc(celt * sizeof(INetConnection*));
        if (rgelt)
        {
            ULONG celtFetched;

            hr = Next (celt, rgelt, &celtFetched);

            if (SUCCEEDED(hr))
            {
                ReleaseIUnknownArray (celtFetched, (IUnknown**)rgelt);
            }

            MemFree (rgelt);
        }
    }
    TraceErrorOptional ("CConnectionManagerEnumConnection::Skip", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Reset ()
{
    CExceptionSafeComObjectLock EsLock (this);

    ReleaseCurrentClassEnumerator ();
    m_iterCurClassMgr = m_mapClassManagers.begin();
    return S_OK;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Clone (
    IEnumNetConnection**    ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Initialize our members.
            //
            pObj->m_EnumFlags   = m_EnumFlags;

            // Copy the array of class managers and AddRef them since
            // we will be holding on to them.
            //
            pObj->m_mapClassManagers = m_mapClassManagers;
            for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
            {
                AddRefObj (iter->second);
            }

            // The current class manager index need to be copied.
            //
            pObj->m_iterCurClassMgr = pObj->m_mapClassManagers.find(m_iterCurClassMgr->first);

            // Important to clone (not copy) the current class enumerator
            // if we have one.
            //
            if (m_penumCurClassMgr)
            {
                hr = m_penumCurClassMgr->Clone (&pObj->m_penumCurClassMgr);
            }

            if (SUCCEEDED(hr))
            {
                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
    }
    TraceErrorOptional ("CConnectionManagerEnumConnection::Clone", hr, (S_FALSE == hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumsa.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M S A. C P P
//
//  Contents:   Implementation of Shared Access connection enumerator object
//
//  Notes:
//
//  Author:     kenwic   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumsa.h"
#include "saconob.h"

LONG g_CountSharedAccessConnectionEnumerators;

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::~CSharedAccessConnectionManagerEnumConnection
//
//  Purpose:    Called when the enumeration object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//

CSharedAccessConnectionManagerEnumConnection::~CSharedAccessConnectionManagerEnumConnection()
{
    InterlockedDecrement(&g_CountSharedAccessConnectionEnumerators);
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Next
//
//  Purpose:    Retrieves the next celt SharedAccess connection objects
//
//  Arguments:
//      celt         [in]       Number to retrieve
//      rgelt        [out]      Array of INetConnection objects retrieved
//      pceltFetched [out]      Returns Number in array
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Next(ULONG celt,
                                                       INetConnection **rgelt,
                                                       ULONG *pceltFetched)
{
    HRESULT     hr = S_FALSE;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto done;
    }

    // Initialize output parameters.
    //
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    ZeroMemory(rgelt, sizeof (*rgelt) * celt);


    if(FALSE == m_bEnumerated)
    {
        m_bEnumerated = TRUE; 
        

        INetConnectionUiUtilities* pNetConnUiUtil;  // check group policy
        hr = CoCreateInstance(CLSID_NetConnectionUiUtilities, NULL, CLSCTX_INPROC, IID_INetConnectionUiUtilities, reinterpret_cast<void **>(&pNetConnUiUtil));
        if (SUCCEEDED(hr))
        {
            if (pNetConnUiUtil->UserHasPermission(NCPERM_ICSClientApp))
            {
                CComObject<CSharedAccessConnection>* pConnection;
                hr = CComObject<CSharedAccessConnection>::CreateInstance(&pConnection);
                if(SUCCEEDED(hr))
                {
                    pConnection->AddRef();
                    hr = pConnection->QueryInterface(IID_INetConnection, reinterpret_cast<void **>(rgelt));
                    if(SUCCEEDED(hr))
                    {
                        if(NULL != pceltFetched)
                        {
                            *pceltFetched = 1;
                        }
                    }
                    pConnection->Release();
                }
                else
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = S_FALSE;
            }
            pNetConnUiUtil->Release();
        }

        if(SUCCEEDED(hr))
        {
            if(1 != celt)
            {
                hr = S_FALSE;
            }
        }
    }

done:
    Assert (FImplies (S_OK == hr, (*pceltFetched == celt)));

    TraceError("CSharedAccessConnectionManagerEnumConnection::Next",
               (hr == S_FALSE || hr == HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED)) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Skip
//
//  Purpose:    Skips over celt number of connections
//
//  Arguments:
//      celt [in]   Number of connections to skip
//
//  Returns:    S_OK if successful, otherwise Win32 error
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    
    if(0 != celt)
    {
        m_bEnumerated = TRUE;
    }


    TraceError("CSharedAccessConnectionManagerEnumConnection::Skip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Reset
//
//  Purpose:    Resets the enumerator to the beginning
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Reset()
{
    HRESULT hr = S_OK;
    
    m_bEnumerated = FALSE;

    TraceError("CSharedAccessConnectionManagerEnumConnection::Reset", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Clone
//
//  Purpose:    Creates a new enumeration object pointing at the same location
//              as this object
//
//  Arguments:
//      ppenum [out]    New enumeration object
//
//  Returns:    S_OK if successful, otherwise OLE or Win32 error
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Clone(IEnumNetConnection **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        CSharedAccessConnectionManagerEnumConnection *   pObj;

        // Initialize output parameter.
        //
        *ppenum = NULL;

        pObj = new CComObject <CSharedAccessConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_bEnumerated = m_bEnumerated;

            // Return the object with a ref count of 1 on this
            // interface.
            pObj->m_dwRef = 1;
            *ppenum = pObj;
        }
    }

    TraceError ("CSharedAccessConnectionManagerEnumConnection::Clone", hr);
    return hr;
}


HRESULT CSharedAccessConnectionManagerEnumConnection::FinalRelease(void)
{
    HRESULT hr = S_OK;


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enuml.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"


extern LONG g_CountLanConnectionEnumerators;


class ATL_NO_VTABLE CLanConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnectionManagerEnumConnection,
                        &CLSID_LanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    HDEVINFO    m_hdi;
    DWORD       m_dwIndex;

public:
    CLanConnectionManagerEnumConnection()
    {
        m_hdi = NULL;
        m_dwIndex = 0;
        InterlockedIncrement(&g_CountLanConnectionEnumerators);
    }

    ~CLanConnectionManagerEnumConnection();

    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONMAN_ENUM)

    BEGIN_COM_MAP(CLanConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD(Next)(ULONG celt, INetConnection **rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumNetConnection **ppenum);

private:
    //
    // Private functions
    //

    HRESULT HrNextOrSkip(ULONG celt, INetConnection **rgelt,
                         ULONG *pceltFetched);
    HRESULT HrCreateLanConnectionInstance(SP_DEVINFO_DATA &deid,
                                          INetConnection **rgelt,
                                          ULONG ulEntry);
public:
    static HRESULT CreateInstance(NETCONMGR_ENUM_FLAGS Flags,
                                  REFIID riid,
                                  LPVOID *ppv);
};

//
// Helper functions
//

BOOL FIsValidNetCfgDevice(HKEY hkey);
HRESULT HrIsLanCapableAdapterFromHkey(HKEY hkey);
BOOL FIsFunctioning(SP_DEVINFO_DATA * pdeid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M I . C P P
//
//  Contents:   Enumerator for Inbound connection objects.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumi.h"
#include "inbound.h"
#include "ncras.h"
#include "ncsvc.h"


LONG g_CountIncomingConnectionEnumerators;


extern const WCHAR c_szSvcRemoteAccess[];
extern const GUID GUID_InboundConfigConnectionId;

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the Inbound class manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags        [in]
//      riid         [in]
//      ppv          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::CreateInstance (
    NETCONMGR_ENUM_FLAGS    Flags,
    REFIID                  riid,
    VOID**                  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CInboundConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CInboundConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags = Flags;

        pObj->m_fReturnedConfig = FALSE;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CInboundConnectionManagerEnumConnection::CInboundConnectionManagerEnumConnection ()
{
    InterlockedIncrement (&g_CountIncomingConnectionEnumerators);

    m_EnumFlags         = NCME_DEFAULT;
    m_aRasSrvConn       = NULL;
    m_cRasSrvConn       = 0;
    m_iNextRasSrvConn   = 0;
    m_fFirstTime        = TRUE;
    m_fDone             = FALSE;
}

CInboundConnectionManagerEnumConnection::~CInboundConnectionManagerEnumConnection ()
{
    MemFree (m_aRasSrvConn);

    InterlockedDecrement (&g_CountIncomingConnectionEnumerators);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateConfigOrCurrentEnumeratedConnection
//
//  Purpose:    Parameterize the call to CInboundConnection::CreateInstance
//              based on whether we are returning the configuration
//              connection or the currently enumerated one.
//
//  Arguments:
//      fIsConfigConnection [in]
//      ppCon               [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   16 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::
HrCreateConfigOrCurrentEnumeratedConnection (
    BOOL                fIsConfigConnection,
    INetConnection**    ppCon)
{
    // Parameterize the call to
    // CInboundConnection::CreateInstance based on whether
    // we are returning the configuration connection or the currently
    // enumerated one.
    //
    HRASSRVCONN hRasSrvConn;
    PCWSTR      pszName;
    PCWSTR      pszDeviceName;
    DWORD       dwType;
    const GUID* pguidId;

    if (fIsConfigConnection)
    {
        hRasSrvConn     = 0;
        pszName        = NULL;
        pszDeviceName  = NULL;
        dwType          = 0;
        pguidId         = &GUID_InboundConfigConnectionId;
        m_fReturnedConfig = TRUE;        
    }
    else
    {
        hRasSrvConn     = m_aRasSrvConn[m_iNextRasSrvConn].hRasSrvConn;
        pszName         = m_aRasSrvConn[m_iNextRasSrvConn].szEntryName;
        pszDeviceName   = m_aRasSrvConn[m_iNextRasSrvConn].szDeviceName;
        dwType          = m_aRasSrvConn[m_iNextRasSrvConn].dwType;
        pguidId         = &m_aRasSrvConn[m_iNextRasSrvConn].Guid;

        m_iNextRasSrvConn++;
    }

    HRESULT hr = CInboundConnection::CreateInstance (
                        fIsConfigConnection,
                        hRasSrvConn,
                        pszName,
                        pszDeviceName,
                        dwType,
                        pguidId,
                        IID_INetConnection,
                        reinterpret_cast<VOID**>(ppCon));

    TraceError ("CInboundConnectionManagerEnumConnection::"
                "HrCreateConfigOrCurrentEnumeratedConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Common implementation of Next and Skip.  rgelt and
//              pceltFetched are optional.  If provided, the output
//              objects are returned (for Next).  If not provided, the output
//              objects are not returned (for Skip).
//
//  Arguments:
//      celt         [in]   Count of elements to fetch or skip.
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::HrNextOrSkip (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    CExceptionSafeComObjectLock EsLock (this);

    // Enumerate the requested number of elements or stop short
    // if we don't have that many left to enumerate.  We don't enumerate
    // anything specific to the current user.  All elements are for all
    // users.
    //
    HRESULT hr = S_OK;
    ULONG   celtFetched = 0;
    if ((celtFetched < celt) && !m_fDone)
    {
        // This gets set to TRUE if we are to return the configuration
        // connection.  This only happens when RAS is running and no
        // active connections exist.
        //
        BOOL fReturnConfigCon = FALSE;

        // If this is our first time through, we need to check if the server
        // is running and possibly fill up m_aRasSrvConn.  This is our
        // array of RASSRVCONN handles enumerted from RAS.  We need
        // to keep this array across calls because RAS doesn't allow us to
        // pickup from a previous enumeration.  So, we enumerate everything
        // in one shot from RAS and hand it out to the caller however they
        // they want it.
        //
        if (m_fFirstTime)
        {
            m_fFirstTime = FALSE;

            // Assert is so that we don't set m_fDone back to FALSE
            // in the case where the service is suddenly running again.
            // The enumerator is static.  Once done, always done.
            //
            AssertSz (!m_fDone, "How'd we get here if we're done?");

            // Use HrSvcQueryStatus instead of RasSrvIsServiceRunning since
            // calling the latter could page in all of the RAS DLLs.  If
            // the service isn't running, we have nothing to enumerate anyway
            // so if we were to page in the RAS DLLs only to find that we
            // have no further work to do.
            //
            DWORD dwState;
            HRESULT hrT = HrSvcQueryStatus (c_szSvcRemoteAccess, &dwState);
            m_fDone = FAILED(hrT) || (SERVICE_RUNNING != dwState);

            if (!m_fDone)
            {
                hr = HrRasEnumAllActiveServerConnections (&m_aRasSrvConn,
                            &m_cRasSrvConn);

                // If no active connections returned, we need to return
                // the configuration connection.
                //
                if (SUCCEEDED(hr) && (!m_aRasSrvConn || !m_cRasSrvConn || !m_fReturnedConfig))
                {
                    // See if RAS allows us to configure incoming
                    // connections.
                    //
                    BOOL fAllowConfig;
                    DWORD dwErr = RasSrvAllowConnectionsConfig (&fAllowConfig);
                    TraceError ("RasSrvAllowConnectionsConfig",
                            HRESULT_FROM_WIN32 (dwErr));

                    fReturnConfigCon = ((ERROR_SUCCESS == dwErr) &&
                                            fAllowConfig);

                    // We're done if we're not returning the config connection.
                    //
                    m_fDone = !fReturnConfigCon;
                }
                else if (FAILED(hr))
                {
                    // Return an empty enumeration on any failures.
                    //
                    Assert (!m_aRasSrvConn);
                    Assert (!m_cRasSrvConn);

                    m_fDone = TRUE;
                    hr = S_OK;
                }
            }
        }

        // If we're not done, and we need to return something, do it.
        //
        if (SUCCEEDED(hr) && !m_fDone && (m_cRasSrvConn || fReturnConfigCon))
        {
            // If we're not returning the configuration connection, it means
            // we must be returning an active connection.
            //
            Assert (FImplies (!fReturnConfigCon, m_aRasSrvConn));
            Assert (FImplies (!fReturnConfigCon,
                                m_iNextRasSrvConn < m_cRasSrvConn));

            // For each entry returned, create the inbound connection object.
            //
            while (SUCCEEDED(hr) && (celtFetched < celt) &&
                   (fReturnConfigCon || (m_iNextRasSrvConn < m_cRasSrvConn)))
            {
                // Its important that this check for rgelt come inside the
                // loop because we still need to loop to update our state
                // for the Skip case.
                //
                if (rgelt)
                {
                    hr = HrCreateConfigOrCurrentEnumeratedConnection (
                            fReturnConfigCon,
                            rgelt + celtFetched);
                }

                if (fReturnConfigCon)
                {
                    // Only return one of these, so set it back to false.
                    // This let's the loop complete above.
                    //
                    fReturnConfigCon = FALSE;
//                    m_fDone = TRUE;
                }

                celtFetched++;
            }

            if (m_iNextRasSrvConn >= m_cRasSrvConn)
            {
                Assert (S_OK == hr);
                m_fDone = TRUE;
                MemFree (m_aRasSrvConn);
                m_aRasSrvConn = NULL;
                m_cRasSrvConn = 0;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidWanCon, "Enumerated %d incoming connections",
            celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError ("CInboundConnectionManagerEnumConnection::HrNextOrSkip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Next (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceError ("CInboundConnectionManagerEnumConnection::Next",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Skip (
    ULONG   celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceError ("CInboundConnectionManagerEnumConnection::Skip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Reset ()
{
    CExceptionSafeComObjectLock EsLock (this);

    MemFree (m_aRasSrvConn);
    m_aRasSrvConn     = NULL;

    m_cRasSrvConn     = 0;
    m_iNextRasSrvConn = 0;
    m_fFirstTime      = TRUE;
    m_fDone           = FALSE;

    return S_OK;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Clone (
    IEnumNetConnection**    ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CInboundConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CInboundConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_EnumFlags = m_EnumFlags;

            ULONG cbBuf = m_cRasSrvConn * sizeof (RASSRVCONN);

            hr = HrMalloc (cbBuf, (PVOID*)&pObj->m_aRasSrvConn);
            if (SUCCEEDED(hr))
            {
                CopyMemory (pObj->m_aRasSrvConn, m_aRasSrvConn, cbBuf);
                pObj->m_cRasSrvConn     = m_cRasSrvConn;

                pObj->m_iNextRasSrvConn = m_iNextRasSrvConn;
                pObj->m_fFirstTime      = m_fFirstTime;
                pObj->m_fDone           = m_fDone;

                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
    }
    TraceError ("CInboundConnectionManagerEnumConnection::Clone", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumsa.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "conmansa.h"


extern LONG g_CountSharedAccessConnectionEnumerators;


class ATL_NO_VTABLE CSharedAccessConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnectionManagerEnumConnection,
                        &CLSID_LanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    BOOL m_bEnumerated;

public:
    CSharedAccessConnectionManagerEnumConnection()
    {
        m_bEnumerated = FALSE;

        InterlockedIncrement(&g_CountSharedAccessConnectionEnumerators);
    }


    ~CSharedAccessConnectionManagerEnumConnection();

    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONMAN_ENUM)

    BEGIN_COM_MAP(CSharedAccessConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD(Next)(ULONG celt, INetConnection **rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumNetConnection **ppenum);

    HRESULT FinalRelease(void);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enuml.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . C P P
//
//  Contents:   Implementation of LAN connection enumerator object
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enuml.h"
#include "lan.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncsetup.h"

LONG g_CountLanConnectionEnumerators;

HRESULT CLanConnectionManagerEnumConnection::CreateInstance(
                                          NETCONMGR_ENUM_FLAGS Flags,
                                          REFIID riid,
                                          LPVOID *ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CLanConnectionManagerEnumConnection* pObj;

    Assert(ppv);
    *ppv = NULL;

    pObj = new CComObject<CLanConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid(NULL);
        pObj->InternalFinalConstructAddRef();
        hr = pObj->FinalConstruct();
        pObj->InternalFinalConstructRelease();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface(riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::CreateInstance", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::~CLanConnectionManagerEnumConnection
//
//  Purpose:    Called when the enumeration object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
CLanConnectionManagerEnumConnection::~CLanConnectionManagerEnumConnection()
{
    SetupDiDestroyDeviceInfoListSafe(m_hdi);
    InterlockedDecrement(&g_CountLanConnectionEnumerators);
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Next
//
//  Purpose:    Retrieves the next celt LAN connection objects
//
//  Arguments:
//      celt         [in]       Number to retrieve
//      rgelt        [out]      Array of INetConnection objects retrieved
//      pceltFetched [out]      Returns Number in array
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Next(ULONG celt,
                                                       INetConnection **rgelt,
                                                       ULONG *pceltFetched)
{
    HRESULT     hr = S_OK;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto done;
    }

    // Initialize output parameters.
    //
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    // Handle the request for zero elements. Also do nothing if the enumerator
    // was created without valid parameters.
    //
    if (0 == celt || FIsDebugFlagSet(dfidSkipLanEnum))
    {
        hr = S_FALSE;
        goto done;
    }

    hr = HrNextOrSkip(celt, rgelt, pceltFetched);

done:
    TraceError("CLanConnectionManagerEnumConnection::Next",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Skip
//
//  Purpose:    Skips over celt number of connections
//
//  Arguments:
//      celt [in]   Number of connections to skip
//
//  Returns:    S_OK if successful, otherwise Win32 error
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Skip(ULONG celt)
{
    HRESULT     hr = S_OK;

    hr = HrNextOrSkip(celt, NULL, NULL);

    TraceError("CLanConnectionManagerEnumConnection::Skip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Reset
//
//  Purpose:    Resets the enumerator to the beginning
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Reset()
{
    HRESULT hr;

    m_dwIndex = 0;

    // refresh so that we have a new view of what adapters are installed
    // each time reset is called
    //
    SetupDiDestroyDeviceInfoListSafe(m_hdi);

    hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                               DIGCF_PRESENT, &m_hdi);

    TraceError("CLanConnectionManagerEnumConnection::Reset", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Clone
//
//  Purpose:    Creates a new enumeration object pointing at the same location
//              as this object
//
//  Arguments:
//      ppenum [out]    New enumeration object
//
//  Returns:    S_OK if successful, otherwise OLE or Win32 error
//
//  Author:     danielwe   19 Mar 1998
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Clone(IEnumNetConnection **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        CLanConnectionManagerEnumConnection *   pObj;

        // Initialize output parameter.
        //
        *ppenum = NULL;

        pObj = new CComObject <CLanConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_dwIndex = m_dwIndex;

            // Return the object with a ref count of 1 on this
            // interface.
            pObj->m_dwRef = 1;
            *ppenum = pObj;
        }
    }

    TraceError ("CLanConnectionManagerEnumConnection::Clone", hr);
    return hr;
}

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::HrCreateLanConnectionInstance
//
//  Purpose:    Helper function to create a LAN connection object instance
//
//  Arguments:
//      deid   [in]     Device info data
//      rgelt  [in]     Array of connection objects
//      ulEntry [in]     Index of connection object
//
//  Returns:    S_OK if success, Win32 or OLE error otherwise
//
//  Author:     danielwe   8 Jan 1998
//
//  Notes:
//
HRESULT CLanConnectionManagerEnumConnection::HrCreateLanConnectionInstance(
              SP_DEVINFO_DATA &deid,
              INetConnection **rgelt,
              ULONG ulEntry)
{
    HRESULT hr;
    WCHAR szPnpId[MAX_DEVICE_ID_LEN];

    hr = HrSetupDiGetDeviceInstanceId(m_hdi, &deid, szPnpId,
                MAX_DEVICE_ID_LEN, NULL);
    if (S_OK == hr)
    {
        HDEVINFO hdiCopy;
        SP_DEVINFO_DATA deidCopy;

        hr = HrSetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET,
                NULL, &hdiCopy);
        if (S_OK == hr)
        {
            BOOL fDestroyCopy = TRUE;

            hr = HrSetupDiOpenDeviceInfo(hdiCopy, szPnpId,
                        NULL, DIOD_INHERIT_CLASSDRVS, &deidCopy);
            if (S_OK == hr)
            {
                fDestroyCopy = FALSE;

                hr = CLanConnection::CreateInstance(hdiCopy,
                                                    deidCopy,
                                                    szPnpId,
                                                    IID_INetConnection,
                                                    reinterpret_cast<LPVOID *>
                                                    (rgelt + ulEntry));
            }

            // CLanConnection::CreateInstance() will hand off the hdiCopy. So
            // even if that fails, we don't want to destroy hdiCopy anymore.
            //
            if (fDestroyCopy)
            {
                // If we fail to continue, free the copy we just made
                //
                (VOID) SetupDiDestroyDeviceInfoList(hdiCopy);
            }
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::"
               "HrCreateLanConnectionInstance", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHidden
//
//  Purpose:    Returns TRUE if the given hkey references the device instance
//              of a hidden adapter (virtual or otherwise)
//
//  Arguments:
//      hkey [in]   HKEY of device instance for adapter (i.e. {GUID}\0000)
//
//  Returns:    TRUE if it is hidden, FALSE if not
//
//  Author:     danielwe   17 Apr 1998
//
//  Notes:
//
BOOL FIsHidden(HKEY hkey)
{
    DWORD dwCharacter;

    if (S_OK == HrRegQueryDword(hkey, L"Characteristics", &dwCharacter))
    {
        return !!(dwCharacter & NCF_HIDDEN);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHiddenElan
//
//  Purpose:    Returns TRUE if the given hkey references the device instance
//              of a hidden ELAN adapter (when the physical ATM adapter is not
//              available)
//
//  Arguments:
//      hdi  [in]   HDEVINFO structure for this adapter
//      hkey [in]   HKEY of device instance for adapter (i.e. {GUID}\0000)
//
//
//  Returns:    TRUE if it is hidden, FALSE if not
//
//  Author:     tongl 9/10/98
//
//  Notes:
//
BOOL FIsHiddenElan(HDEVINFO hdi, HKEY hkey)
{
    BOOL fRet = FALSE;
    HRESULT hr;

    PWSTR pszAtmAdapterPnpId;
    hr = HrRegQuerySzWithAlloc(hkey, L"AtmAdapterPnpId", &pszAtmAdapterPnpId);
    if (S_OK == hr)
    {
        SP_DEVINFO_DATA deid;

        hr = HrSetupDiOpenDeviceInfo(hdi, pszAtmAdapterPnpId, NULL, 0, &deid);
        if (S_OK == hr)
        {
            // Elan should be hidden if the physical adapter is not functioning
            // and is hidden in the folder
            fRet = !FIsFunctioning(&deid);
        }

        MemFree(pszAtmAdapterPnpId);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Helper function to handle the ::Next or ::Skip method
//              implementation
//
//  Arguments:
//      celt         [in]   Number of items to advance
//      rgelt        [in]   Array in which to place connection objects
//      pceltFetched [out]  Returns number of items fetched
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   8 Jan 1998
//
//  Notes:
//
HRESULT CLanConnectionManagerEnumConnection::HrNextOrSkip(
    ULONG celt,
    INetConnection **rgelt,
    ULONG *pceltFetched)
{
    HRESULT             hr = S_OK;
    SP_DEVINFO_DATA     deid = {0};
    ULONG               ulEntry = 0;

    if (rgelt)
    {
        // Important to initialize rgelt so that in case we fail, we can
        // release only what we put in rgelt.
        //
        ZeroMemory(rgelt, sizeof (*rgelt) * celt);
    }

    Assert(celt > 0);

    if (!m_hdi)
    {
        hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                                   DIGCF_PRESENT, &m_hdi);
    }

    while (celt &&
           SUCCEEDED(hr) &&
           SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(m_hdi,m_dwIndex, &deid)))
    {
        HKEY hkey;

        m_dwIndex++;

        hr = HrSetupDiOpenDevRegKey(m_hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                    DIREG_DRV, KEY_READ, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = HrIsLanCapableAdapterFromHkey(hkey);
            if (S_OK == hr)
            {
                if (FIsFunctioning(&deid) && FIsValidNetCfgDevice(hkey) &&
                    !FIsHidden(hkey) && !FIsHiddenElan(m_hdi, hkey))
                {
                    // On Skip, don't create an instance
                    //
                    if (rgelt)
                    {
                        hr = HrCreateLanConnectionInstance(deid, rgelt,
                                                           ulEntry);
                    }

                    ulEntry++;
                    celt--;
                }
            }

            RegCloseKey(hkey);
        }
        else
        {
            // skip device entirely if error trying to open it
            hr = S_OK;
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidLanCon, "Enumerated %lu LAN connections", ulEntry);

        if (pceltFetched)
        {
            *pceltFetched = ulEntry;
        }

        // If celt is positive then we couldn't satisfy the request completely
        hr = (celt > 0) ? S_FALSE : S_OK;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < ulEntry; ulIndex++)
            {
                ReleaseObj(rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }

        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::HrNextOrSkip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//
// Private helper functions
//

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueUpperRange[];
extern const WCHAR c_szRegValueLowerRange[];
static const WCHAR c_chComma = L',';
extern const WCHAR c_szBiNdis4[];
extern const WCHAR c_szBiNdis5[];
extern const WCHAR c_szBiNdis5Ip[];
extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szBiNdis1394[];
extern const WCHAR c_szBiNdisBda[];
extern const WCHAR c_szBiLocalTalk[];

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableAdapterFromHkey
//
//  Purpose:    Determines if the given HKEY describes a LAN capable adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is LAN capable, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT HrIsLanCapableAdapterFromHkey(HKEY hkey)
{
    HRESULT                     hr = S_OK;
    WCHAR                       szBuf[256];
    DWORD                       cbBuf = sizeof(szBuf);
    list<tstring *>             lstr;
    list<tstring *>::iterator   lstrIter;
    BOOL                        fMatch = FALSE;
    HKEY                        hkeyInterfaces;

    hr = HrRegOpenKeyEx(hkey, c_szRegKeyInterfacesFromInstance,
                        KEY_READ, &hkeyInterfaces);
    if (SUCCEEDED(hr))
    {
        hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueUpperRange,
                                szBuf, &cbBuf);
        if (SUCCEEDED(hr))
        {
            ConvertStringToColString(szBuf, c_chComma, lstr);

            for (lstrIter = lstr.begin(); lstrIter != lstr.end(); lstrIter++)
            {
                // See if it matches one of these
                if (!lstrcmpiW((*lstrIter)->c_str(), c_szBiNdis4) ||
                    !lstrcmpiW((*lstrIter)->c_str(), c_szBiNdis5) ||
                    !lstrcmpiW((*lstrIter)->c_str(), c_szBiNdis5Ip) ||
                    !lstrcmpiW((*lstrIter)->c_str(), c_szBiNdisAtm) ||
                    !lstrcmpiW((*lstrIter)->c_str(), c_szBiNdis1394) ||
                    !lstrcmpiW((*lstrIter)->c_str(), c_szBiNdisBda))
                {
                    fMatch = TRUE;
                    break;
                }
            }

            DeleteColString(&lstr);
        }

        if (!fMatch)
        {
            cbBuf = sizeof(szBuf);
            hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueLowerRange,
                                    szBuf, &cbBuf);
            if (SUCCEEDED(hr))
            {
                ConvertStringToColString(szBuf, c_chComma, lstr);

                for (lstrIter = lstr.begin(); lstrIter != lstr.end(); lstrIter++)
                {
                    // See if it matches one of these

                    if (!lstrcmpiW((*lstrIter)->c_str(), c_szBiLocalTalk))
                    {
                        fMatch = TRUE;
                        break;
                    }
                }

                DeleteColString(&lstr);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (fMatch)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrIsLanCapableAdapterFromHkey");
    return hr;
}

static const WCHAR c_szKeyFmt[] = L"%s\\%s\\%s";
extern const WCHAR c_szRegValueNetCfgInstanceId[];
extern const WCHAR c_szRegKeyComponentClasses[];
extern const WCHAR c_szRegValueInstallerAction[];

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidNetCfgDevice
//
//  Purpose:    Determines if the given HKEY is that of a valid NetCfg adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    TRUE if valid, FALSE otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
BOOL FIsValidNetCfgDevice(HKEY hkey)
{
    HRESULT hr;
    WCHAR   szGuid[c_cchGuidWithTerm + 1];
    DWORD   cbBuf = sizeof(szGuid);

    hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                            szGuid, &cbBuf);

    return (S_OK == hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsFunctioning
//
//  Purpose:    Determines if the given dev node is a functioning device
//
//  Arguments:
//      pdeid [in]  Dev info data for device
//
//  Returns:    TRUE if device is functioning, FALSE if not
//
//  Author:     danielwe   2 Sep 1998
//
//  Notes:      "Functioning" means the device is enabled and started with
//              no problem codes, or it is disabled and stopped with no
//              problem codes.
//
BOOL FIsFunctioning(SP_DEVINFO_DATA * pdeid)
{
    ULONG       ulStatus;
    ULONG       ulProblem;
    CONFIGRET   cfgRet;

    cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem, pdeid->DevInst,
                                      0, NULL);

    if (CR_SUCCESS == cfgRet)
    {
        TraceTag(ttidLanCon, "CM_Get_DevNode_Status_Ex (enum): ulProblem "
                 "= 0x%08X, ulStatus = 0x%08X.",
                 ulProblem, ulStatus);

        return FIsDeviceFunctioning(ulProblem);
    }

    // By default return FALSE

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumw.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M W . H
//
//  Contents:   Enumerator for RAS connections objects.
//
//  Notes:
//
//  Author:     shaunco   2 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>


class ATL_NO_VTABLE CWanConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CWanConnectionManagerEnumConnection,
                        &CLSID_WanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;
    RASENUMENTRYDETAILS*    m_aRasEntryName;
    ULONG                   m_cRasEntryName;
    ULONG                   m_iNextRasEntryName;
    BOOL                    m_fDone;

private:
    HRESULT
    HrNextOrSkip (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

public:
    CWanConnectionManagerEnumConnection ();
    ~CWanConnectionManagerEnumConnection ();

    DECLARE_REGISTRY_RESOURCEID(IDR_WAN_CONMAN_ENUM)

    BEGIN_COM_MAP(CWanConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        NETCONMGR_ENUM_FLAGS    Flags,
        REFIID                  riid,
        void**                  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\enumw.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M W . C P P
//
//  Contents:   Enumerator for RAS connection objects.
//
//  Notes:
//
//  Author:     shaunco   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumw.h"
#include "dialup.h"
#include "ncras.h"

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the WAN class manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags        [in]
//      riid         [in]
//      ppv          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
HRESULT
CWanConnectionManagerEnumConnection::CreateInstance (
    NETCONMGR_ENUM_FLAGS    Flags,
    REFIID                  riid,
    VOID**                  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CWanConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CWanConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags = Flags;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::CWanConnectionManagerEnumConnection
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   5 Oct 1997
//
//  Notes:
//
CWanConnectionManagerEnumConnection::CWanConnectionManagerEnumConnection ()
{
    m_EnumFlags         = NCME_DEFAULT;
    m_aRasEntryName     = NULL;
    m_cRasEntryName     = 0;
    m_iNextRasEntryName = 0;
    m_fDone             = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::~CWanConnectionManagerEnumConnection
//
//  Purpose:    Destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   2 Oct 1997
//
//  Notes:
//
CWanConnectionManagerEnumConnection::~CWanConnectionManagerEnumConnection ()
{
    MemFree (m_aRasEntryName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Common implementation of Next and Skip.  rgelt and
//              pceltFetched are optional.  If provided, the output
//              objects are returned (for Next).  If not provided, the output
//              objects are not returned (for Skip).
//
//  Arguments:
//      celt         [in]   Count of elements to fetch or skip.
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:
//
//  Author:     shaunco   15 Oct 1997
//
//  Notes:
//
HRESULT
CWanConnectionManagerEnumConnection::HrNextOrSkip (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    CExceptionSafeComObjectLock EsLock (this);

    // Enumerate the requested number of elements or stop short
    // if we don't have that many left to enumerate.
    //
    HRESULT hr = S_OK;
    ULONG   celtFetched = 0;
    while (SUCCEEDED(hr) && (celtFetched < celt) && !m_fDone)
    {
        // See if we need to fill m_aRasEntryName.  This is our
        // array of RASENTRYNAME structures enumerted from RAS.  We need
        // to keep this array across calls because RAS doesn't allow us to
        // pickup from a previous enumeration.  So, we enumerate everything
        // in one shot from RAS and hand it out to the caller however they
        // they want it.
        //
        if (!m_aRasEntryName)
        {
            // Because RasEnumEntries also enumerates per-user entries
            // we need to impersonate the client to allow the correct
            // per-user entries to be enumerated.
            //

            // Impersonate the client.
            //
            HRESULT hrT = CoImpersonateClient ();
            TraceHr (ttidError, FAL, hrT, FALSE, "CoImpersonateClient");

            // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
            if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
            {
                hr = HrRasEnumAllEntriesWithDetails (NULL,
                    &m_aRasEntryName, &m_cRasEntryName);
            }

            if (SUCCEEDED(hrT))
            {
                hrT = CoRevertToSelf ();
                TraceHr (ttidError, FAL, hrT, FALSE, "CoRevertToSelf");
            }

            if (!m_cRasEntryName || FAILED(hr))
            {
                // RAS may not be installed or may otherwise have a problem.
                // We catch this here and return an empty enumeration.
                //
                Assert (!m_aRasEntryName);
                Assert (!m_cRasEntryName);

                m_fDone = TRUE;
                hr = S_OK;
            }
        }

        // Now that we have m_aRasEntryName and m_iNextRasEntryName,
        // use them to fill up the output array if we have an output
        // array to fill up.
        //
        if (SUCCEEDED(hr) && !m_fDone)
        {
            Assert (m_aRasEntryName);
            Assert (m_cRasEntryName);
            Assert (m_iNextRasEntryName < m_cRasEntryName);

            // Create the RAS connection objects.
            //
            while (SUCCEEDED(hr) && (celtFetched < celt) &&
                   (m_iNextRasEntryName < m_cRasEntryName))
            {
                // Its important that this check for rgelt come inside the
                // loop because we still need to loop to update our state
                // for the Skip case.
                //
                if (rgelt)
                {
                    hr = CDialupConnection::CreateInstanceFromDetails (
                            m_aRasEntryName + m_iNextRasEntryName,
                            IID_INetConnection,
                            reinterpret_cast<VOID**>(rgelt + celtFetched));
                }

                celtFetched++;
                m_iNextRasEntryName++;
            }

            if (m_iNextRasEntryName >= m_cRasEntryName)
            {
                Assert (S_OK == hr);
                m_fDone = TRUE;
                MemFree (m_aRasEntryName);
                m_aRasEntryName = NULL;
                m_cRasEntryName = 0;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidWanCon, "Enumerated %d RAS connections", celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError ("CWanConnectionManagerEnumConnection::HrNextOrSkip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

STDMETHODIMP
CWanConnectionManagerEnumConnection::Next (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceError ("CWanConnectionManagerEnumConnection::Next",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Skip (
    ULONG   celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceError ("CWanConnectionManagerEnumConnection::Skip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Reset ()
{
    CExceptionSafeComObjectLock EsLock (this);

    MemFree (m_aRasEntryName);
    m_aRasEntryName     = NULL;
    m_cRasEntryName     = 0;
    m_iNextRasEntryName = 0;
    m_fDone             = FALSE;

    return S_OK;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Clone (
    IEnumNetConnection**    ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CWanConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CWanConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_EnumFlags           = m_EnumFlags;

            ULONG cbBuf = m_cRasEntryName * sizeof (RASENUMENTRYDETAILS);
            if (cbBuf && m_aRasEntryName)
            {
                hr = E_OUTOFMEMORY;
                pObj->m_aRasEntryName = (RASENUMENTRYDETAILS*)(MemAlloc (cbBuf));
                if (pObj->m_aRasEntryName)
                {
                    hr = S_OK;
                    CopyMemory (pObj->m_aRasEntryName, m_aRasEntryName, cbBuf);
                    pObj->m_cRasEntryName = m_cRasEntryName;
                }
            }

            if (S_OK == hr)
            {
                pObj->m_iNextRasEntryName   = m_iNextRasEntryName;
                pObj->m_fDone               = m_fDone;

                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }
            else
            {
                delete pObj;
            }
        }
    }
    TraceError ("CWanConnectionManagerEnumConnection::Clone", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\event.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       E V E N T . C P P
//
//  Contents:   Interface between external events that effect connections.
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <winsock2.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "nmbase.h"
#include "ncnetcon.h"
#include "conman.h"
#include <cmdefs.h>
#include "cmutil.h"
#include "eventq.h"
#include <userenv.h>
#include <userenvp.h>
#include "ncperms.h"
#include <ras.h>
#include <raserror.h>
#include <ncstl.h>
#include <ncstlstr.h>
#include <stlalgor.h>
#include <enuml.h>
#include <lancmn.h>
#include <ncreg.h>
#include "dialup.h"
#include "gpnla.h"
#include "cobase.h"
#include "inbound.h"
#include <mprapi.h>
#include <rasapip.h>
#include "ncras.h"
#include "wzcsvc.h"

// This LONG is incremented every time we get a notification that
// a RAS phonebook entry has been modified.  It is reset to zero
// when the service is started.  Wrap-around does not matter.  It's
// purpose is to let a RAS connection object know if it's cache should
// be re-populated with current information.
//
LONG g_lRasEntryModifiedVersionEra;

LONG g_cInRefreshAll;
const LONG MAX_IN_REFRESH_ALL = 5;

CEventQueue*    g_pEventQueue = NULL;
BOOL            g_fDispatchEvents = FALSE;
HANDLE          g_hEventWait = NULL;
HANDLE          g_hEventThread = NULL;
HANDLE          g_hQuery = NULL;
BOOL            g_fHandleIncomingEvents = FALSE;

CGroupPolicyNetworkLocationAwareness* g_pGPNLA = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   FreeConmanEvent
//
//  Purpose:    Free the memory associated with a CONMAN_EVENT structure.
//
//  Arguments:
//      pEvent [in] The structure to free.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:
//
inline
VOID
FreeConmanEvent (
    CONMAN_EVENT* pEvent)
{
    if (pEvent)
    {
        if (((CONNECTION_ADDED == pEvent->Type) ||
             (CONNECTION_MODIFIED == pEvent->Type)))
        {
            HrFreeNetConProperties2(pEvent->pPropsEx);
        }

        if (CONNECTION_BALLOON_POPUP == pEvent->Type)
        {
            SysFreeString(pEvent->szCookie);
            SysFreeString(pEvent->szBalloonText);
        }

        MemFree(pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RasEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     sjkhan   21 Mar 2001
//
//  Notes:      This function calls Ras on a different thread than where the
//              event came from so as not to cause a deadlock in Ras.
//              This call owns pvContext and frees it.
//
DWORD
WINAPI
RasEventWorkItem (
                PVOID   pvContext
                )
{
    BOOL fNotify;
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)pvContext;
    Assert (pEvent);

    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fNotify = TRUE;

        if (fNotify)
        {
            HRESULT hr = S_OK;
            RASENUMENTRYDETAILS Details;

            if (CONNECTION_ADDED == pEvent->Type || CONNECTION_MODIFIED == pEvent->Type)
            {
                // Clear out the details passed in from RAS and query RAS for the latest info.
                Details = pEvent->Details;
                ZeroMemory(&pEvent->Details, sizeof(RASENUMENTRYDETAILS));

                if (CONNECTION_ADDED == pEvent->Type)
                {
                    hr = HrGetRasConnectionProperties(&Details, &(pEvent->pPropsEx));
                }
                else if (CONNECTION_MODIFIED == pEvent->Type)
                {
                    hr = HrGetRasConnectionProperties(&Details, &(pEvent->pPropsEx));
                    TraceTag(ttidEvents, "Is Default Connection: %s", (NCCF_DEFAULT == (pEvent->pPropsEx->dwCharacter & NCCF_DEFAULT)) ? "Yes" : "No");
                    TraceTag(ttidEvents, "Should be Default Connection: %s", (Details.dwFlagsPriv & REED_F_Default) ? "Yes" : "No");
                }
            }
            if (SUCCEEDED(hr))
            {
                CConnectionManager::NotifyClientsOfEvent (pEvent);
            }
        }
    }

    FreeConmanEvent(pEvent);

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   LanEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     deonb   15 May 2001
//
//  Notes:      This function retreives a more up to do status from the NIC
//              and sends it to netshell
//
DWORD
WINAPI
LanEventWorkItem (
                PVOID   pvContext
                )
{
    BOOL fNotify;
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)pvContext;
    Assert (pEvent);
    Assert(CONMAN_LAN== pEvent->ConnectionManager);

    HRESULT hr = S_OK;
    RASENUMENTRYDETAILS Details;

    TraceTag(ttidEvents, "Refreshing connection status");

    GUID gdLanGuid = GUID_NULL;

    if ((CONNECTION_ADDED == pEvent->Type) || (CONNECTION_MODIFIED == pEvent->Type))
    {
        gdLanGuid = pEvent->pPropsEx->guidId;
    }

    if ((CONNECTION_STATUS_CHANGE == pEvent->Type) || (CONNECTION_ADDRESS_CHANGE == pEvent->Type) || (CONNECTION_DELETED == pEvent->Type))
    {
        gdLanGuid = pEvent->guidId;
    }


    Assert(GUID_NULL != gdLanGuid);
    if (GUID_NULL == gdLanGuid)
    {
        return E_INVALIDARG;
    }

#ifdef DBG
    NETCON_STATUS ncsPrior;
#endif
    NETCON_STATUS ncs;
    hr = HrGetPnpDeviceStatus(&gdLanGuid, &ncs);
    if (SUCCEEDED(hr))
    {
        // Get additional Status information from 802.1X
        //
        if ((NCS_CONNECTED == ncs)
            || (NCS_INVALID_ADDRESS == ncs)
            || (NCS_MEDIA_DISCONNECTED == ncs))
        {
            NETCON_STATUS ncsWZC = ncs;
            HRESULT hrT = WZCQueryGUIDNCSState(&gdLanGuid, &ncsWZC);
            if (S_OK == hrT)
            {
                ncs = ncsWZC;
            }

            TraceHr(ttidError, FAL, hrT, (S_FALSE == hrT), "LanEventWorkItem error in WZCQueryGUIDNCSState");
        }

        if ( (CONNECTION_ADDED == pEvent->Type) || (CONNECTION_MODIFIED == pEvent->Type))
        {
#ifdef DBG
            ncsPrior = pEvent->pPropsEx->ncStatus;
#endif
            pEvent->pPropsEx->ncStatus = ncs;
        }

        if (CONNECTION_STATUS_CHANGE == pEvent->Type)
        {
#ifdef DBG
            ncsPrior = pEvent->Status;
#endif
            if ( (NCS_HARDWARE_NOT_PRESENT == ncs) ||
                 (NCS_HARDWARE_MALFUNCTION == ncs) )
            {
                pEvent->Type = CONNECTION_DELETED;
                TraceTag(ttidEvents, "LanEventWorkItem changed EventType to CONNECTION_DELETED");
            }
            else
            {
                pEvent->Status = ncs;
            }
        }
    }

#ifdef DBG
    if (ncsPrior != ncs)
    {
        TraceTag(ttidEvents, "LanEventWorkItem overruled status: %s to %s", DbgNcs(ncsPrior), DbgNcs(ncs));
    }
#endif

    CConnectionManager::NotifyClientsOfEvent (pEvent);
    FreeConmanEvent(pEvent);

    TraceHr(ttidError, FAL, hr, FALSE, "LanEventWorkItem");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IncomingEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     sjkhan   21 Mar 2001
//
//  Notes:      This function calls Ras on a different thread than where the
//              event came from so as not to cause a deadlock in Ras.
//              This call owns pvContext and frees it.
//
DWORD
WINAPI
IncomingEventWorkItem (
                  PVOID   pvContext
                  )
{
    BOOL fNotify;
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)pvContext;

    Assert (pEvent);

    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fNotify = TRUE;

        if (fNotify)
        {
            HRESULT hr = S_OK;

            if (CONNECTION_ADDED == pEvent->Type)
            {
                GUID guidId;
                guidId = pEvent->guidId;     // We need to store this because CONMAN_EVENT is a union and pProps occupies the same space as guidId.
                pEvent->guidId = GUID_NULL;  // We don't need this anymore so it's a good idea to clean it up, as pEvent is a union.
                hr = HrGetIncomingConnectionPropertiesEx(pEvent->hConnection, &guidId, pEvent->dwConnectionType, &pEvent->pPropsEx);
            }
            if (SUCCEEDED(hr))
            {
                CConnectionManager::NotifyClientsOfEvent (pEvent);
            }
        }
    }

    FreeConmanEvent(pEvent);

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   ConmanEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:      Ownership of the CONMAN_EVENT structure is given to this
//              function.  i.e. the structure is freed here.
//
DWORD
WINAPI
ConmanEventWorkItem (
    PVOID   pvContext
    )
{
    BOOL fIsRefreshAll;
    BOOL fNotify;
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)pvContext;
    Assert (pEvent);

    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fIsRefreshAll = (REFRESH_ALL == pEvent->Type);
        fNotify = TRUE;

        if (fIsRefreshAll)
        {
            // We'll deliver this refresh-all notification only if another
            // thread is not already delivering one.
            //
            fNotify = (InterlockedIncrement (&g_cInRefreshAll) < MAX_IN_REFRESH_ALL);
        }

        if (fNotify)
        {
            CConnectionManager::NotifyClientsOfEvent (pEvent);
        }

        // Reset our global flag if we were the single thread allowed to
        // deliver a refresh-all notification.
        //
        if (fIsRefreshAll)
        {
            if (InterlockedDecrement (&g_cInRefreshAll) < 0)
            {
                AssertSz (FALSE, "Mismatched Interlocked Increment/Decrement?");
                g_cInRefreshAll = 0;
            }
        }
    }

    FreeConmanEvent (pEvent);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   LanEventNotify
//
//  Purpose:    To be called when a LAN adapter is added or removed.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   2 Sep 1998
//
//  Notes:      The easy thing is done a full refresh is queued for the
//              connection manager to notify its clients of.
//
VOID
LanEventNotify (
    CONMAN_EVENTTYPE    EventType,
    INetConnection*     pConn,
    PCWSTR              pszNewName,
    const GUID *        pguidConn)
{
    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    if ((REFRESH_ALL == EventType) && (g_cInRefreshAll >= MAX_IN_REFRESH_ALL))
    {
        return;
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // RASEVENT information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in LanEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_LAN;
    pEvent->Type = EventType;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    if (pConn)
    {
        // pEvent->pProps is only valid for added and modified events.
        // So, we don't want to be getting properties for any other event.
        //
        AssertSz (
            (CONNECTION_ADDED == EventType) ||
            (CONNECTION_MODIFIED == EventType),
            "Why is pConn being passed for this event type?");

        hr = HrGetPropertiesExFromINetConnection(pConn, &pEvent->pPropsEx);
    }

    AssertSz(FImplies(EventType == CONNECTION_RENAMED, FIff(pszNewName,
                                                            !pConn)),
                      "szwNewName && pConn cannot be NULL or non-NULL at "
                      "the same time!");
    AssertSz(FIff(pszNewName, pguidConn), "szwNewName & pguidConn must both "
             "be NULL or non-NULL");

    if (EventType == CONNECTION_RENAMED)
    {
        AssertSz(pszNewName, "Rename event requires szwNewName to be "
                 "non-NULL");
        AssertSz(pguidConn, "Rename event requires pguidConn to be "
                 "non-NULL");

        // Copy in the right info into the event struct
        //
        pEvent->guidId = *pguidConn;
        lstrcpynW(pEvent->szNewName, pszNewName, celems(pEvent->szNewName));
    }

    if (S_OK == hr)
    {
        TraceTag (ttidEvents,
            "LanEventNotify: Queuing ConmanEventWorkItem (Type=%s)...",
            DbgEvents(pEvent->Type));

        // Queue a worker to deliver the event to the clients of the
        // connection manager with registered connection points.
        // We pass ownership of the structure to the worker thread which
        // will free it.  (Therefore, we don't want to free it.)
        //
        if (QueueUserWorkItemInThread (ConmanEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
        {
            fFreeEvent = FALSE;
        }
        else
        {
            TraceTag (ttidEvents,
                "QueueUserWorkItem failed with error %d in LanEventNotify.",
                GetLastError ());
        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsIgnorableCMEvent
//
//  Purpose:    Determine whether an event is an ignorable CM event, such
//              as those that are adds/removes from a temporary CM connection
//              (used by CM VPN connections to double-dial). We don't want
//              clients to react to these events.
//
//  Arguments:
//      pRasEvent [in] pointer to a RASEVENT structure describing the event.
//
//  Returns:
//
//  Author:     jeffspr   15 Jan 1999
//
//  Notes:
//
BOOL FIsIgnorableCMEvent(const RASEVENT* pRasEvent)
{
    BOOL    fReturn = FALSE;
    WCHAR   szFileName[MAX_PATH];

    Assert(pRasEvent);

    // Split the filename out of the path
    //
    _wsplitpath(pRasEvent->Details.szPhonebookPath, NULL, NULL,
                szFileName, NULL);

    // Compare that file name with the filter prefix to see if we
    // should throw this event away
    //
    if (_wcsnicmp(CM_PBK_FILTER_PREFIX, szFileName,
                   wcslen(CM_PBK_FILTER_PREFIX)) == 0)
    {
        fReturn = TRUE;
    }

    return fReturn;
}

HRESULT HrGetRasConnectionProperties(
        const RASENUMENTRYDETAILS*  pDetails,
        NETCON_PROPERTIES_EX**      ppPropsEx)
{
    HRESULT hr = S_OK;
    INetConnection* pConn;

    Assert(ppPropsEx);

    hr = CDialupConnection::CreateInstanceFromDetails (
            pDetails,
            IID_INetConnection,
            reinterpret_cast<VOID**>(&pConn));

    if (SUCCEEDED(hr))
    {
        hr = HrGetPropertiesExFromINetConnection(pConn, ppPropsEx);

        ReleaseObj (pConn);
    }

    return hr;
}

HRESULT HrGetIncomingConnectionPropertiesEx(
    IN const HANDLE              hRasConn,
    IN const GUID*               pguidId,
    IN const DWORD               dwType,
    OUT NETCON_PROPERTIES_EX**   ppPropsEx)
{
    HRESULT hr = S_OK;
    DWORD dwResult = 0;
    RAS_SERVER_HANDLE hRasServer = NULL;
    RAS_CONNECTION_2* pRasConnection = NULL;

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }
    if (!ppPropsEx)
    {
        return E_POINTER;
    }

    *ppPropsEx = NULL;

    dwResult = MprAdminServerConnect(NULL, &hRasServer);

    if (NO_ERROR == dwResult)
    {
        dwResult = MprAdminConnectionGetInfo(hRasServer, 2, hRasConn, reinterpret_cast<LPBYTE*>(&pRasConnection));

        if (NO_ERROR == dwResult)
        {
            DWORD dwRead = 0;
            DWORD dwTot = 0;
            RAS_PORT_0* pPort = NULL;

            dwResult = MprAdminPortEnum(hRasServer,
                                        0,
                                        hRasConn,
                                        (LPBYTE*)&pPort,
                                        sizeof(RAS_PORT_0) * 2,
                                        &dwRead,
                                        &dwTot,
                                        NULL);

            if (NO_ERROR == dwResult)
            {
                CComPtr<INetConnection> pConn;

                hr = CInboundConnection::CreateInstance(FALSE,
                                                        hRasConn,
                                                        pRasConnection->wszUserName,
                                                        pPort->wszDeviceName,
                                                        dwType,
                                                        pguidId,
                                                        IID_INetConnection,
                                                        reinterpret_cast<LPVOID*>(&pConn));
                if (SUCCEEDED(hr))
                {
                    hr = HrGetPropertiesExFromINetConnection(pConn, ppPropsEx);
                    (*ppPropsEx)->ncStatus = NCS_CONNECTED;
                }
                MprAdminBufferFree(reinterpret_cast<LPVOID>(pPort));
            }
            MprAdminBufferFree(pRasConnection);
        }
        MprAdminServerDisconnect(hRasServer);
    }

    if (NO_ERROR != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasEventNotify
//
//  Purpose:    Private export used by Rasman service to notify the
//              Netman service of RAS events which may effect connections.
//
//  Arguments:
//      pRasEvent [in] pointer to a RASEVENT structure describing the event.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:
//
VOID
APIENTRY
RasEventNotify (
    const RASEVENT* pRasEvent)
{
    NETCON_STATUS ncs;
    BOOL fMatchedStatus = TRUE;

    Assert (pRasEvent);

    TraceTag (ttidEvents,
        "RasEventNotify: Recieved RAS event (Type=%d)...",
        pRasEvent->Type);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // Map the ras type to the conman type
    //
    switch(pRasEvent->Type)
    {
    case ENTRY_CONNECTED:
        ncs = NCS_CONNECTED;
        break;

    case ENTRY_CONNECTING:
        ncs = NCS_CONNECTING;
        break;

    case ENTRY_DISCONNECTING:
        ncs = NCS_DISCONNECTING;
        break;

    case ENTRY_DISCONNECTED:
        ncs = NCS_DISCONNECTED;
        break;

    default:
        fMatchedStatus = FALSE;
    }

    // Remember any Connection Manager connectoids and ras events
    // For Ras Connecting is Disconnected so we have to memorize the
    // real state of the connectoid. /*&& FIsIgnorableCMEvent(pRasEvent)*/
    //
    if( fMatchedStatus )
    {
        // Save the connection in a list
        //
        CCMUtil::Instance().SetEntry(pRasEvent->Details.guidId, pRasEvent->Details.szEntryName,ncs);
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    //  Windows XP Bug 336787.
    //  sjkhan
    //  We're checking to see if we should be firing events when the RemoteAccess Service
    //  starts.  We call the same API that we do when checking whether or not to show the
    //  config connection, and we're then able to determine whether or not we should fire
    //  the incoming events.  Since we get notified of the service stopping and starting,
    //  we'll always know when we should or should not fire IncomingEvents.  This reduces
    //  the call overhead to O(1), and since  we exit here if  we're not supposed to fire
    //  events, we don't even have to allocate and then free the pEvent memory.
    //
    if (((INCOMING_CONNECTED == pRasEvent->Type) ||
        (INCOMING_DISCONNECTED == pRasEvent->Type)) &&
        !g_fHandleIncomingEvents)
    {
        return;
    }

    if ((ENTRY_ADDED == pRasEvent->Type) ||
        (ENTRY_DELETED == pRasEvent->Type))
    {
        // Filter out CM temporary phonebook events
        //
        if (FIsIgnorableCMEvent(pRasEvent))
        {
            TraceTag(ttidEvents, "Filtering ignorable CM event in RasEventNotify");
            return;
        }
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // RASEVENT information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in RasEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_RAS;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    switch (pRasEvent->Type)
    {
        case ENTRY_ADDED:
            pEvent->Type = CONNECTION_ADDED;
            pEvent->Details = pRasEvent->Details;
            TraceTag(ttidEvents, "Path: %S", pRasEvent->Details.szPhonebookPath);
            break;

        case ENTRY_DELETED:
            pEvent->Type = CONNECTION_DELETED;
            pEvent->guidId = pRasEvent->guidId;
            break;

        case ENTRY_MODIFIED:
            pEvent->Type = CONNECTION_MODIFIED;
            pEvent->Details = pRasEvent->Details;
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_RENAMED:
            pEvent->Type = CONNECTION_RENAMED;
            pEvent->guidId = pRasEvent->guidId;
            lstrcpynW (
                pEvent->szNewName,
                pRasEvent->pszwNewName,
                celems(pEvent->szNewName) );
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_AUTODIAL:
            pEvent->Type = CONNECTION_MODIFIED;
            pEvent->Details = pRasEvent->Details;
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_CONNECTED:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_CONNECTED;
            break;

        case ENTRY_CONNECTING:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_CONNECTING;
            break;

        case ENTRY_DISCONNECTING:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_DISCONNECTING;
            break;

        case ENTRY_DISCONNECTED:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_DISCONNECTED;
            break;

        case INCOMING_CONNECTED:
            pEvent->ConnectionManager = CONMAN_INCOMING;
            pEvent->hConnection = pRasEvent->hConnection;
            pEvent->guidId = pRasEvent->guidId;
            pEvent->dwConnectionType = RasSrvTypeFromRasDeviceType(pRasEvent->rDeviceType);
            pEvent->Type = CONNECTION_ADDED;
            break;

        case INCOMING_DISCONNECTED:
            pEvent->ConnectionManager = CONMAN_INCOMING;
            pEvent->guidId = pRasEvent->guidId;
            pEvent->Type = CONNECTION_DELETED;
            break;

        case SERVICE_EVENT:
            if (REMOTEACCESS == pRasEvent->Service)
            {
                DWORD dwErr;
                pEvent->ConnectionManager = CONMAN_INCOMING;
                pEvent->Type = REFRESH_ALL;
                //  Check to see if we should handle incoming events.
                dwErr = RasSrvAllowConnectionsConfig(&g_fHandleIncomingEvents);
                TraceError ("RasSrvIsConnectionConnected", HRESULT_FROM_WIN32(dwErr));
            }
            else if (RAS_SERVICE_STARTED == pRasEvent->Event)
            {
                _Module.ReferenceRasman(REF_REFERENCE);
                hr = S_FALSE;
            }
            else
            {
                // skip queueing the workitem
                hr = S_FALSE;
            }
            break;

        case ENTRY_BANDWIDTH_ADDED:
        case ENTRY_BANDWIDTH_REMOVED:
            pEvent->Type = CONNECTION_BANDWIDTH_CHANGE;
            pEvent->guidId = pRasEvent->guidId;
            break;

        case DEVICE_ADDED:
        case DEVICE_REMOVED:
            pEvent->Type = REFRESH_ALL;
            break;

        default:
            // skip queueing the workitem
            AssertSz (FALSE, "Invalid Type specified in pRasEvent");
            hr = S_FALSE;
            break;
    }

    if (S_OK == hr)
    {
        if (CONMAN_RAS == pEvent->ConnectionManager)
        {
           TraceTag (ttidEvents,
                "RasEventNotify: Queueing RasEventWorkItem (Type=%s)...",
                DbgEvents(pEvent->Type));

            // Queue the event to be delivered the event to the clients of the
            // connection manager with registered connection points.
            // We pass ownership of the structure to the worker thread which
            // will free it.  (Therefore, we don't want to free it.)
            //
            if (QueueUserWorkItemInThread (RasEventWorkItem,
                    pEvent, EVENTMGR_CONMAN))
            {
                fFreeEvent = FALSE;
            }
            else
            {
                TraceTag (ttidEvents,
                    "QueueUserWorkItem failed with error %d in RasEventNotify.",
                    GetLastError ());
            }
        }
        else if (CONMAN_INCOMING == pEvent->ConnectionManager)
        {
            TraceTag (ttidEvents,
                "RasEventNotify: Queueing IncomingEventWorkItem (Type=%s)...",
                DbgEvents(pEvent->Type));

            // Queue the event to be delivered the event to the clients of the
            // connection manager with registered connection points.
            // We pass ownership of the structure to the worker thread which
            // will free it.  (Therefore, we don't want to free it.)
            //
            if (QueueUserWorkItemInThread (IncomingEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
            {
                fFreeEvent = FALSE;
            }
            else
            {
                TraceTag (ttidEvents,
                    "QueueUserWorkItem failed with error %d in RasEventNotify.",
                    GetLastError ());
            }

        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IncomingEventNotify
//
//  Purpose:    To be called when something changes on an Incoming Connection
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     sjkhan   17 Oct 2000
//
//  Notes:      The easy thing is done a full refresh is queued for the
//              connection manager to notify its clients of.
//
VOID
IncomingEventNotify (
    CONMAN_EVENTTYPE    EventType,
    INetConnection*     pConn,
    PCWSTR              pszNewName,
    const GUID *        pguidConn)
{
    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    if ((REFRESH_ALL == EventType) && (g_cInRefreshAll >= MAX_IN_REFRESH_ALL))
    {
        return;
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // INCOMING information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in IncomingEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_INCOMING;
    pEvent->Type = EventType;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    if (pConn)
    {
        // pEvent->pProps is valid for modified events and added events, but we only support modified for incoming.
        // So, we don't want to be getting properties for any other event.
        //
        AssertSz (
            (CONNECTION_MODIFIED == EventType),
            "Why is pConn being passed for this event type?");

        hr = HrGetPropertiesExFromINetConnection(pConn, &pEvent->pPropsEx);
    }

    if (EventType == CONNECTION_RENAMED)
    {
        AssertSz(pszNewName, "Rename event requires szwNewName to be "
                 "non-NULL");
        AssertSz(pguidConn, "Rename event requires pguidConn to be "
                 "non-NULL");

        // Copy in the right info into the event struct
        //
        pEvent->guidId = *pguidConn;
        lstrcpynW(pEvent->szNewName, pszNewName, celems(pEvent->szNewName));
    }

    if (S_OK == hr)
    {
        TraceTag (ttidEvents,
            "IncomingEventNotify: Queuing ConmanEventWorkItem (Type=%s)...",
            DbgEvents(pEvent->Type));

        // Queue a worker to deliver the event to the clients of the
        // connection manager with registered connection points.
        // We pass ownership of the structure to the worker thread which
        // will free it.  (Therefore, we don't want to free it.)
        //
        if (QueueUserWorkItemInThread (ConmanEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
        {
            fFreeEvent = FALSE;
        }
        else
        {
            TraceTag (ttidEvents,
                "QueueUserWorkItem failed with error %d in IncomingEventNotify.",
                GetLastError ());
        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispatchEvents
//
//  Purpose:    Thread function for Dispatching events
//
//  Arguments:
//      LPVOID  pContext  (unused)
//
//  Returns:    nothing
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:      Is called when something is added to the queue and and an event
//              is set, then dispatches all events until the queue is empty
//              and then exits.
//
//
VOID NTAPI DispatchEvents(IN LPVOID pContext, BOOLEAN fTimerFired)
{
    HRESULT hr = S_OK;
    TraceTag(ttidEvents, "Event Dispatching Thread Started.");

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        if (fTimerFired == FALSE /* We were signaled */)
        {
            while (g_pEventQueue->AtomCheckSizeAndResetEvent(g_fDispatchEvents))
            {
                LPTHREAD_START_ROUTINE pfnEvent = NULL;
                PVOID pEvent = NULL;
                EVENT_MANAGER EventMgr;
                HRESULT hr;

                TraceTag(ttidEvents, "Number of events in Queue: %d", g_pEventQueue->size());

                hr = g_pEventQueue->DequeueEvent(pfnEvent, pEvent, EventMgr);
                if (SUCCEEDED(hr) && pfnEvent)
                {
                    pfnEvent(pEvent);
                }
            }
        }

        CoUninitialize();
    }
    else
    {
        TraceError("Error calling CoInitialize.", hr);
    }

    TraceTag(ttidEvents, "Event Dispatching Thread Stopping.");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureEventHandlerInitialized
//
//  Purpose:    Thread function for Dispatching events
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:
//
//
HRESULT HrEnsureEventHandlerInitialized()
{
    DWORD dwThreadId;
    NTSTATUS Status;
    HANDLE hEventExit;
    HRESULT hr = S_FALSE;  // Events are already initialized.

    TraceTag(ttidEvents, "Entering HrEnsureEventHandlerInitialized");

    if (!g_pEventQueue)
    {
        hEventExit = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hEventExit)
        {
            try
            {
                g_pEventQueue = new CEventQueue(hEventExit);
                if (!g_pEventQueue)
                {
                    throw E_OUTOFMEMORY;
                }

                //  Check to see if we should handle incoming events.
                DWORD dwErr = RasSrvAllowConnectionsConfig(&g_fHandleIncomingEvents);
                TraceError ("RasSrvIsConnectionConnected", HRESULT_FROM_WIN32(dwErr));

                g_fDispatchEvents = TRUE;
            }
            catch (HRESULT hrThrown)
            {
                hr = hrThrown;
            }
            catch (...)
            {
                hr = E_FAIL;
            }
            CloseHandle(hEventExit);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("Error in HrEnsureEventHandlerInitialized", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeEventHandler
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:
//
//
HRESULT UninitializeEventHandler()
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    NTSTATUS Status;

    TraceTag(ttidEvents, "Entering UninitializeEventHandler");

    if (g_fDispatchEvents)
    {
        g_fDispatchEvents = FALSE;

        if (g_pEventQueue && (0 != g_pEventQueue->size()))
        {
            dwStatus = g_pEventQueue->WaitForExit();
        }

        TraceTag(ttidEvents, "Deregistering Event Wait");

        if (g_hEventWait)
        {
            Status = RtlDeregisterWaitEx(g_hEventWait, INVALID_HANDLE_VALUE);
            g_hEventWait = NULL;
        }

        if (g_pEventQueue)
        {
            delete g_pEventQueue;
            g_pEventQueue = NULL;
        }
    }

    CGroupPolicyNetworkLocationAwareness* pGPNLA =
        reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(InterlockedExchangePointer( (PVOID volatile *) &g_pGPNLA, NULL));

    if (pGPNLA)
    {
        TraceTag(ttidEvents, "Calling Group Policy Uninitialize");
        hr = pGPNLA->Uninitialize();

        delete pGPNLA;
    }

    TraceError("UninitializeEventHandler", hr);

    TraceTag(ttidEvents, "Exiting UninitializeEventHandler");

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueueUserWorkItemInThread
//
//  Purpose:    Places events and their workitems into the event queue for
//              scheduling.
//  Arguments:
//      IN LPTHREAD_START_ROUTINE Function  -  worker function to call
//      IN PVOID Context                    -  event data
//      IN EVENT_MANAGER EventMgr           -  CONMAN or EAPOLMAN
//
//
//  Returns:    BOOL
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:
//
//
BOOL QueueUserWorkItemInThread(IN LPTHREAD_START_ROUTINE Function, IN PVOID Context, IN EVENT_MANAGER EventMgr)
{
    HRESULT hr = S_OK;

    TraceTag(ttidEvents, "Entering QueueUserWorkItemInThread");

    if (g_fDispatchEvents)  // if we're shutting down then this will be FALSE and we won't be scheduling events.
    {

        hr = g_pEventQueue->EnqueueEvent(Function, Context, EventMgr);
        // The queue should contain only one item at this point unless someone else has added something
        // but either way, only one thread will be handling events (as the other call would have received S_OK
        // as a return value), as we synchronize this in EnqueueEvent.

        TraceTag(ttidEvents, "Number of Items in Queue: %d", g_pEventQueue->size());

    }

    TraceTag(ttidEvents, "Exiting QueueUserWorkItemInThread");

    if (FAILED(hr))
    {
        TraceError("Error in QueueUserWorkItemInThread", hr);
    }

    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidEventType
//
//  Purpose:    Validate Event parameters.
//
//  Arguments:
//      EventMgr    - type of event manager
//      EventType   - type of event
//
//  Returns:    HRESULT indicating success of failure
//
//  Author:     sjkhan   09 Dec 2000
//
//  Notes:
//
//
//
//
BOOL IsValidEventType(EVENT_MANAGER EventMgr, int EventType)
{
    BOOL fIsValid = FALSE;

    Assert(EventMgr);
    TraceTag(ttidEvents, "IsValidEventType received: %d", EventType);

    if (EventMgr == EVENTMGR_CONMAN)
    {
        if (EventType == INVALID_TYPE)
        {
            fIsValid = FALSE;
        }
        else if (EventType <= DISABLE_EVENTS)
        {
            fIsValid = TRUE;
        }
    }
    else
    {
        AssertSz(FALSE, "Invalid Event Manager");
    }

    return fIsValid;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureRegisteredWithNla
//
//  Purpose:    Initialize our Nla Event class, if not already done.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success of failure
//
//  Author:     sjkhan   21 Apr 2001
//
//  Notes:
//
//
//
HRESULT HrEnsureRegisteredWithNla()
{
    HRESULT hr = S_FALSE;  // We're already registered, no need to do so again.

    if (!g_pGPNLA)
    {
        try
        {
            g_pGPNLA = new CGroupPolicyNetworkLocationAwareness();
            if (g_pGPNLA)
            {
                hr = g_pGPNLA->Initialize();
                if (FAILED(hr))
                {
                    TraceError("Error in HrEnsureRegisteredWithNla", hr);

                    g_pGPNLA->Uninitialize();

                    delete g_pGPNLA;
                    g_pGPNLA = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        catch (HRESULT hrThrown)
        {
            hr = hrThrown;
        }
        catch (...)
        {
            hr = E_FAIL;
        }
    }

    TraceTag(ttidEvents, "Exiting HrEnsureRegisteredWithNla");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\eventq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T Q  . C P P
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncmisc.h"
#include "eventq.h"
#include "conman.h"

//+---------------------------------------------------------------------------
//
//  Function:   Constructor for CEventQueue
//
//  Purpose:    Creates the various synchronization objects required for the
//              Queue
//  Arguments:
//      HANDLE hServiceShutdown [in] 
//                 Event to set when shutting down queue.
//
//
//  Returns:    nothing.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//
//
//
CEventQueue::CEventQueue(HANDLE hServiceShutdown) : m_hServiceShutdown(0), m_pFireEvents(NULL), m_hWait(0), m_fRefreshAllInQueue(FALSE)
{
    TraceFileFunc(ttidEvents);
    NTSTATUS Status;

    try
    {
        if (!DuplicateHandle(GetCurrentProcess(), hServiceShutdown, GetCurrentProcess(), &m_hServiceShutdown, NULL, FALSE, DUPLICATE_SAME_ACCESS))
        {
            TraceTag(ttidEvents, "Couldn't Duplicate handle!");
            throw E_OUTOFMEMORY;
        }
    
        HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pFireEvents = new CEvent(hEvent);

        Status = RtlRegisterWait(&m_hWait, hEvent, (WAITORTIMERCALLBACKFUNC) DispatchEvents, NULL, INFINITE, WT_EXECUTEDEFAULT);
        if (!NT_SUCCESS(Status))
        {
            throw E_OUTOFMEMORY;
        }

        TraceTag(ttidEvents, "RtlRegisterWait Succeeded");
        InitializeCriticalSection(&m_csQueue);
    }
    catch (...)
    {
        if (m_hWait && NT_SUCCESS(Status))
        {
            RtlDeregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);
        }
        // ISSUE: If CreateEvent succeeds and new CEvent fails, we're not freeing the hEvent.
        if (m_pFireEvents)
        {
            delete m_pFireEvents;
        }
        if (m_hServiceShutdown)
        {
            CloseHandle(m_hServiceShutdown);
        }
        throw;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Destructor for CEventQueue
//
//  Purpose:    Empties the queue and frees all existing items in the queue.
//
//  Arguments:
//      
//      
//
//
//  Returns:    nothing.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//
//
//
CEventQueue::~CEventQueue()
{
    NTSTATUS Status;

    while(!m_eqWorkItems.empty())
    {
        USERWORKITEM UserWorkItem;

        UserWorkItem = m_eqWorkItems.front();
        m_eqWorkItems.pop_front();

        if (UserWorkItem.EventMgr == EVENTMGR_CONMAN)
        {
            CONMAN_EVENT* pConmanEvent = reinterpret_cast<CONMAN_EVENT*>(UserWorkItem.Event);
            FreeConmanEvent(pConmanEvent);
        }
    }
    DeleteCriticalSection(&m_csQueue);
    Status = RtlDeregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);
    delete m_pFireEvents;
    CloseHandle(m_hServiceShutdown);
}

//+---------------------------------------------------------------------------
//
//  Function:   EnqueueEvent
//
//  Purpose:    Stores the new event in the Event Queue
//
//  Arguments:
//      Function - The pointer to the function to be called when firing the 
//                 event
//      Event    - The Event information
//      Flags    - Unused, just for compatibility with QueueUserWorkItem calls
//
//  Returns:    HRESULT
//              S_OK            -   Event has been added and Event code is
//                                  already dispatching events
//              S_FALSE         -   Event has been added to Queue, but a 
//                                  thread needs to be scheduled to fire 
//                                  the events
//              E_OUTOFMEMORY   -   Unable to add the event to the Queue.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      Locks and Unlocks the critical section only while working 
//              with the queue
//              
//
HRESULT CEventQueue::EnqueueEvent(IN LPTHREAD_START_ROUTINE Function, IN PVOID pEvent, IN const EVENT_MANAGER EventMgr)
{
    TraceFileFunc(ttidEvents);

    CExceptionSafeLock esLock(&m_csQueue);
    USERWORKITEM UserWorkItem;
    HRESULT hr = S_OK;

    if (!Function)
    {
        return E_POINTER;
    }

    if (!pEvent)
    {
        return E_POINTER;
    }

    UserWorkItem.Function = Function;
    UserWorkItem.Event = pEvent;
    UserWorkItem.EventMgr = EventMgr;

    if (EVENTMGR_CONMAN == EventMgr)
    {
        CONMAN_EVENT* pConmanEvent = reinterpret_cast<CONMAN_EVENT*>(pEvent);
        if (REFRESH_ALL == pConmanEvent->Type)
        {
            if (!m_fRefreshAllInQueue)
            {
                m_fRefreshAllInQueue = TRUE;
            }
            else
            {
                FreeConmanEvent(pConmanEvent);
                return S_OK;
            }
        }
    } 

#ifdef DBG
    char pchErrorText[MAX_PATH];

    Assert(UserWorkItem.EventMgr);

    if (EVENTMGR_CONMAN == UserWorkItem.EventMgr)
    {
        CONMAN_EVENT* pConmanEvent = reinterpret_cast<CONMAN_EVENT*>(pEvent);

        TraceTag(ttidEvents, "EnqueueEvent received Event: %s (currently %d in queue). Event Manager: CONMAN", DbgEvents(pConmanEvent->Type), m_eqWorkItems.size());

        sprintf(pchErrorText, "Invalid Type %d specified in Event structure\r\n", pConmanEvent->Type);

        AssertSz(IsValidEventType(UserWorkItem.EventMgr, pConmanEvent->Type), pchErrorText);
    }
    else
    {
        sprintf(pchErrorText, "Invalid Event Manager %d specified in Event structure\r\n", EventMgr);
        AssertSz(FALSE, pchErrorText);
    }

#endif

    try
    {
        m_eqWorkItems.push_back(UserWorkItem);
        m_pFireEvents->SetEvent();
    }
    catch (...)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DequeueEvent
//
//  Purpose:    Retrieves the next event in the Event Queue
//
//  Arguments:
//      Function - The pointer to the function to be called when firing the 
//                 event
//      Event    - The Event information
//      Flags    - Unused, just for compatibility with QueueUserWorkItem calls
//
//  Returns:    HRESULT
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      Locks and Unlocks the critical section only while working 
//              with the queue
//
//
HRESULT CEventQueue::DequeueEvent(OUT LPTHREAD_START_ROUTINE& Function, OUT PVOID& pEvent, OUT EVENT_MANAGER& EventMgr)
{
    TraceFileFunc(ttidEvents);
    
    CExceptionSafeLock esLock(&m_csQueue);
    USERWORKITEM UserWorkItem;
    DWORD dwSize = m_eqWorkItems.size();

    if (!dwSize)
    {
        AssertSz(FALSE, "Calling DequeueEvent with 0 items in Queue!!!");
        return E_UNEXPECTED;
    }

    UserWorkItem = m_eqWorkItems.front();
    m_eqWorkItems.pop_front();

    Function = UserWorkItem.Function;
    pEvent = UserWorkItem.Event;
    EventMgr = UserWorkItem.EventMgr;

    if (EVENTMGR_CONMAN == EventMgr)
    {
        CONMAN_EVENT* pConmanEvent = reinterpret_cast<CONMAN_EVENT*>(pEvent);
        if (REFRESH_ALL == pConmanEvent->Type)
        {
            m_fRefreshAllInQueue = FALSE;
        }
    } 


#ifdef DBG
    char pchErrorText[MAX_PATH];

    Assert(EventMgr);

    if (EVENTMGR_CONMAN == EventMgr)
    {
        CONMAN_EVENT* pConmanEvent = reinterpret_cast<CONMAN_EVENT*>(pEvent);

        TraceTag(ttidEvents, "DequeueEvent retrieved Event: %s (%d left in queue). Event Manager: CONMAN", DbgEvents(pConmanEvent->Type), m_eqWorkItems.size());

        sprintf(pchErrorText, "Invalid Type %d specified in Event structure\r\nItems in Queue: %d\r\n", pConmanEvent->Type, dwSize);

        AssertSz(IsValidEventType(EventMgr, pConmanEvent->Type), pchErrorText);
    }
    else
    {
        sprintf(pchErrorText, "Invalid Event Manager %d specified in Event structure\r\n", EventMgr);
        AssertSz(FALSE, pchErrorText);
    }
#endif


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForExit
//
//  Purpose:    Waits for the queue to exit.
//
//  Arguments:
//      (none)
//
//  Returns:    WAIT_OBJECT_0 or failure code.
//
//  Author:     ckotze   28 Apr 2001
//
//  Notes:      
//              
//
DWORD CEventQueue::WaitForExit()
{
    return WaitForSingleObject(m_hServiceShutdown, INFINITE);
}

//+---------------------------------------------------------------------------
//
//  Function:   size
//
//  Purpose:    Returns the Number of items in the queue
//
//  Arguments:
//      (none)
//
//  Returns:    Number of items in the queue
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//              
//
size_t CEventQueue::size()
{
    CExceptionSafeLock esLock(&m_csQueue);
    TraceFileFunc(ttidEvents);
    size_t tempsize;

    tempsize = m_eqWorkItems.size();

    return tempsize;
}

//+---------------------------------------------------------------------------
//
//  Function:   AtomCheckSizeAndResetEvent
//
//  Purpose:    Make sure we know when we're supposed to exit, lock during the
//              operation.
//  Arguments:
//      (none)
//
//  Returns:    TRUE if should exit thread.  FALSE if more events in queue, or
//              service is not shutting down.
//  Author:     ckotze   04 March 2001
//
//  Notes:      
//              
//
BOOL CEventQueue::AtomCheckSizeAndResetEvent(const BOOL fDispatchEvents)
{
    CExceptionSafeLock esLock(&m_csQueue);
    BOOL fRet = TRUE;

    TraceTag(ttidEvents, "Checking for Exit Conditions, Events in queue: %d, Service Shutting Down: %s", size(), (fDispatchEvents) ? "FALSE" : "TRUE");

    if (m_eqWorkItems.empty() || !fDispatchEvents)
    {
        fRet = FALSE;
        if (fDispatchEvents)
        {
            m_pFireEvents->ResetEvent();
        }
        else
        {
            SetEvent(m_hServiceShutdown);
        }
    }
    return fRet;
}

//  CEvent is a Hybrid between Automatic and Manual reset events.
//  It is automatically reset, but we control when it is set so it
//  doesn't spawn threads while set, except for the first one.

CEvent::CEvent(HANDLE hEvent)
{
    m_hEvent = hEvent;
    m_bSignaled = FALSE;
}

CEvent::~CEvent()
{
    CloseHandle(m_hEvent);
}

HRESULT CEvent::SetEvent()
{
    HRESULT hr = S_OK;

    if (!m_bSignaled)
    {
        if (!::SetEvent(m_hEvent))
        {
            hr = HrFromLastWin32Error();
        }
        else
        {
            m_bSignaled = TRUE;
        }
    }
    return hr;
}

HRESULT CEvent::ResetEvent()
{
    HRESULT hr = S_OK;

    Assert(m_bSignaled);

    m_bSignaled = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\nmdiagp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M D I A G P . C P P
//
//  Contents:   Diagnostics for the netman process
//
//  Notes:
//
//  Author:     danielwe   23 Mar 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enuml.h"
#include "diag.h"
#include "kkenet.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "netcon.h"
#include "ntddndis.h"

struct LAN_CONNECTION
{
    GUID            guidId;
    tstring         strName;
    NETCON_STATUS   Status;
    tstring         strDeviceName;
    DWORD           dwMediaState;
    ULONG           ulDevNodeStatus;
    ULONG           ulDevNodeProblem;
    tstring         strPnpName;
};

typedef list<LAN_CONNECTION *>              LAN_CONNECTION_LIST;
typedef list<LAN_CONNECTION *>::iterator    LAN_CONNECTION_LIST_ITERATOR;

HRESULT HrInitializeConMan(INetConnectionManager **ppConMan)
{
    HRESULT hr;

    hr = CoCreateInstance(CLSID_LanConnectionManager, NULL,
                          CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                          IID_INetConnectionManager,
                          reinterpret_cast<LPVOID *>(ppConMan));

    return hr;
}

HRESULT HrUninitializeConMan(INetConnectionManager *pConMan)
{
    ReleaseObj(pConMan);

    return S_OK;
}

HRESULT HrEnumerateLanConnections(INetConnectionManager *pConMan,
                                  LAN_CONNECTION_LIST &listCon)
{
    HRESULT     hr = S_OK;

    CIterNetCon         ncIter(pConMan, NCME_DEFAULT);
    INetConnection *    pconn;

    while (SUCCEEDED(hr) &&
           (S_OK == (ncIter.HrNext(&pconn))))
    {
        NETCON_PROPERTIES * pProps;

        hr = pconn->GetProperties(&pProps);
        if (SUCCEEDED(hr))
        {
            LAN_CONNECTION *    pLanCon;
            BOOL                fMediaConnected;
            WCHAR               szwInstance[_MAX_PATH];

            pLanCon = new LAN_CONNECTION;
            if (pLanCon)
            {
                pLanCon->guidId = pProps->guidId;
                pLanCon->strName = pProps->pszwName;
                pLanCon->Status = pProps->Status;
                pLanCon->strDeviceName = pProps->pszwDeviceName;

                if (SUCCEEDED(hr = HrQueryLanMediaState(&pProps->guidId,
                                                        &fMediaConnected)))
                {
                    pLanCon->dwMediaState = fMediaConnected ?
                        NdisMediaStateConnected : NdisMediaStateDisconnected;
                }
                else
                {
                    pLanCon->dwMediaState = hr;
                }

                hr = HrPnpInstanceIdFromGuid(&pProps->guidId, szwInstance,
                                             celems(szwInstance));
                if (SUCCEEDED(hr))
                {
                    DEVINST     devinst;
                    pLanCon->strPnpName = szwInstance;

                    if (CR_SUCCESS == CM_Locate_DevNode(&devinst,
                                                        szwInstance,
                                                        CM_LOCATE_DEVNODE_NORMAL))
                    {
                        ULONG       ulStatus;
                        ULONG       ulProblem;
                        CONFIGRET   cfgRet;

                        cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                                          devinst, 0, NULL);
                        if (CR_SUCCESS == cfgRet)
                        {
                            pLanCon->ulDevNodeProblem = ulProblem;
                            pLanCon->ulDevNodeStatus = ulStatus;
                        }
                    }
                }

                listCon.push_back(pLanCon);
            }

            FreeNetconProperties(pProps);
        }

        ReleaseObj(pconn);
    }

    return hr;
}

HRESULT HrFindLanConnection(INetConnectionManager *pConMan,
                            PCWSTR szLanConnection,
                            INetConnection **ppcon)
{
    HRESULT     hr = S_OK;

    CIterNetCon         ncIter(pConMan, NCME_DEFAULT);
    INetConnection *    pconn;

    *ppcon = NULL;

    while (SUCCEEDED(hr) &&
           (S_OK == (ncIter.HrNext(&pconn))))
    {
        NETCON_PROPERTIES * pProps;

        hr = pconn->GetProperties(&pProps);
        if (SUCCEEDED(hr))
        {
            if (!lstrcmpiW(pProps->pszwName, szLanConnection))
            {
                *ppcon = pconn;
                break;
            }
            else
            {
                ReleaseObj(pconn);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (*ppcon == NULL)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

extern const WCHAR c_szRegValueNetCfgInstanceId[];

VOID CmdShowAllDevices(DIAG_OPTIONS *pOptions, INetConnectionManager *pConMan)
{
    HRESULT             hr;
    DWORD               dwIndex = 0;
    SP_DEVINFO_DATA     deid = {0};
    HDEVINFO            hdi = NULL;
    WCHAR               szBuffer [MAX_PATH];

    hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                               DIGCF_PRESENT, &hdi);

    while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(hdi,
                                                  dwIndex,
                                                  &deid)))
    {
        HKEY hkey;

        dwIndex++;

        hr = HrSetupDiOpenDevRegKey(hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                    DIREG_DRV, KEY_READ, &hkey);
        if (SUCCEEDED(hr))
        {
            ULONG   ulProblem;
            ULONG   ulStatus;
            PWSTR   pszName;

            hr = HrSetupDiGetDeviceName(hdi, &deid, &pszName);
            if (SUCCEEDED(hr))
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Device name:            %S\n", pszName);
                delete [] reinterpret_cast<BYTE*>(pszName);
            }

            (VOID) CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                            deid.DevInst, 0, NULL);

            tstring     strStatus;

            SzFromCmStatus(ulStatus, &strStatus);

            g_pDiagCtx->Printf(ttidNcDiag, "Device CM Status:       (0x%08X) %S\n", ulStatus,
                   strStatus.c_str());
            g_pDiagCtx->Printf(ttidNcDiag, "Device CM Problem:      (0x%08X) %S\n", ulProblem,
                   SzFromCmProb(ulProblem));

            g_pDiagCtx->Printf(ttidNcDiag, "Lan capable:            ");
            if (S_OK == HrIsLanCapableAdapterFromHkey(hkey))
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Yes\n");
            }
            else
            {
                g_pDiagCtx->Printf(ttidNcDiag, "No\n");
            }

            HRESULT hr = S_OK;
            WCHAR   szGuid[c_cchGuidWithTerm] = {0};
            DWORD   cbBuf = sizeof(szGuid);

            hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                                    szGuid, &cbBuf);

            g_pDiagCtx->Printf(ttidNcDiag, "Valid NetCfg device:    ");
            if (S_OK == hr)
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Yes\n");
            }
            else
            {
                g_pDiagCtx->Printf(ttidNcDiag, "No\n");
            }

            g_pDiagCtx->Printf(ttidNcDiag, "NetCfg instance ID:     %S\n", szGuid);

            hr = HrSetupDiGetDeviceInstanceId(hdi, &deid, szBuffer,
                                              sizeof(szBuffer), NULL);
            if (SUCCEEDED(hr))
            {
                g_pDiagCtx->Printf(ttidNcDiag, "PnP instance ID:        %S\n", szBuffer);
            }

            DWORD   dwChars;
            tstring strChars;

            if (SUCCEEDED(HrRegQueryDword(hkey, L"Characteristics", &dwChars)))
            {
                SzFromCharacteristics(dwChars, &strChars);
                g_pDiagCtx->Printf(ttidNcDiag, "Characteristics:        (0x%08X) %S\n", dwChars,
                       strChars.c_str());
            }

            hr = HrSetupDiGetDeviceRegistryProperty (hdi, &deid,
                    SPDRP_LOCATION_INFORMATION, NULL, (BYTE*)szBuffer,
                    sizeof (szBuffer), NULL);

            if (S_OK == hr)
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Location:               %S\n", szBuffer);
            }

            if ((NCF_PHYSICAL & dwChars) && *szGuid)
            {
                ULONGLONG MacAddr;
                hr = HrGetNetCardAddr (szGuid, &MacAddr);
                if (S_OK == hr)
                {
                    g_pDiagCtx->Printf(ttidNcDiag, "Mac Address:            0x%012.12I64X\n", MacAddr);
                }
            }

            GUID    guid;
            BOOL    fMediaConnected;
            DWORD   dwMediaState;

            IIDFromString(szGuid, &guid);
            if (SUCCEEDED(hr = HrQueryLanMediaState(&guid,
                                                    &fMediaConnected)))
            {
                dwMediaState = fMediaConnected ?
                    NdisMediaStateConnected : NdisMediaStateDisconnected;
            }
            else
            {
                dwMediaState = hr;
            }

            g_pDiagCtx->Printf(ttidNcDiag, "NDIS media status:      ");
            switch (dwMediaState)
            {
            case NdisMediaStateConnected:
                g_pDiagCtx->Printf(ttidNcDiag, "Connected\n");
                break;

            case NdisMediaStateDisconnected:
                g_pDiagCtx->Printf(ttidNcDiag, "Disconnected\n");
                break;

            default:
                g_pDiagCtx->Printf(ttidNcDiag, "Error 0x%08X\n", dwMediaState);
                break;
            }

            RegCloseKey(hkey);
        }

        g_pDiagCtx->Printf(ttidNcDiag, "------------------------------------------------------------------------------------\n");
    }

    SetupDiDestroyDeviceInfoListSafe(hdi);
}

VOID CmdShowLanConnections(DIAG_OPTIONS *pOptions, INetConnectionManager *pConMan)
{
    HRESULT                         hr = S_OK;
    LAN_CONNECTION_LIST             listCon;
    LAN_CONNECTION_LIST_ITERATOR    iterListCon;

    hr = HrEnumerateLanConnections(pConMan, listCon);
    if (SUCCEEDED(hr))
    {
        g_pDiagCtx->Printf(ttidNcDiag, "Current LAN connections\n\n");
        g_pDiagCtx->Printf(ttidNcDiag, "%-20S%-50S%-20S%\n", L"Connection Name", L"Device Name", L"Status");
        g_pDiagCtx->Printf(ttidNcDiag, "----------------------------------------------------------------------------------------\n");

        for (iterListCon = listCon.begin(); iterListCon != listCon.end(); iterListCon++)
        {
            LAN_CONNECTION * pLanCon;

            pLanCon = *iterListCon;

            g_pDiagCtx->Printf(ttidNcDiag, "%-20S%-50S%-20S%\n",
                               pLanCon->strName.c_str(),
                               pLanCon->strDeviceName.c_str(),
                               SzFromNetconStatus(pLanCon->Status));
        }
    }
}

VOID CmdShowLanDetails(DIAG_OPTIONS *pOptions, INetConnectionManager *pConMan)
{
    HRESULT                         hr = S_OK;
    LAN_CONNECTION_LIST             listCon;
    LAN_CONNECTION_LIST_ITERATOR    iterListCon;
    BOOL                            fFound = FALSE;

    hr = HrEnumerateLanConnections(pConMan, listCon);
    if (SUCCEEDED(hr))
    {
        for (iterListCon = listCon.begin(); iterListCon != listCon.end(); iterListCon++)
        {
            LAN_CONNECTION * pLanCon;

            pLanCon = *iterListCon;
            if (!lstrcmpiW(pLanCon->strName.c_str(), pOptions->szLanConnection))
            {
                WCHAR       szwGuid[c_cchGuidWithTerm];

                StringFromGUID2(pLanCon->guidId, szwGuid, c_cchGuidWithTerm);

                g_pDiagCtx->Printf(ttidNcDiag, "Details for %S:\n", pOptions->szLanConnection);
                g_pDiagCtx->Printf(ttidNcDiag, "------------------------------------------\n\n");
                g_pDiagCtx->Printf(ttidNcDiag, "Device name:        %S\n", pLanCon->strDeviceName.c_str());
                g_pDiagCtx->Printf(ttidNcDiag, "Device GUID:        %S\n", szwGuid);
                g_pDiagCtx->Printf(ttidNcDiag, "PnP Instance ID:    %S\n", pLanCon->strPnpName.c_str());
                g_pDiagCtx->Printf(ttidNcDiag, "Netman Status:      %S\n", SzFromNetconStatus(pLanCon->Status));

                g_pDiagCtx->Printf(ttidNcDiag, "NDIS media status:  ");
                switch (pLanCon->dwMediaState)
                {
                case NdisMediaStateConnected:
                    g_pDiagCtx->Printf(ttidNcDiag, "Connected\n");
                    break;

                case NdisMediaStateDisconnected:
                    g_pDiagCtx->Printf(ttidNcDiag, "Disconnected\n");
                    break;

                default:
                    g_pDiagCtx->Printf(ttidNcDiag, "Error 0x%08X\n", pLanCon->dwMediaState);
                    break;
                }

                tstring     strStatus;

                SzFromCmStatus(pLanCon->ulDevNodeStatus, &strStatus);

                g_pDiagCtx->Printf(ttidNcDiag, "CM DevNode Status:  (0x%08X) %S\n",
                       pLanCon->ulDevNodeStatus, strStatus.c_str());
                g_pDiagCtx->Printf(ttidNcDiag, "CM DevNode Problem: (0x%08X) %S\n",
                       pLanCon->ulDevNodeProblem,
                       SzFromCmProb(pLanCon->ulDevNodeProblem));

                fFound = TRUE;

                // No need to keep looping
                break;
            }
        }
    }

    if (!fFound)
    {
        g_pDiagCtx->Printf(ttidNcDiag, "Could not find match for connection name: %S\n",
               pOptions->szLanConnection);
    }
}

VOID CmdLanChangeState(DIAG_OPTIONS *pOptions, INetConnectionManager *pConMan)
{
    HRESULT                         hr = S_OK;
    INetConnection *                pcon = NULL;

    hr = HrFindLanConnection(pConMan, pOptions->szLanConnection, &pcon);
    if (S_OK == hr)
    {
        NETCON_PROPERTIES * pProps;

        hr = pcon->GetProperties(&pProps);
        if (SUCCEEDED(hr))
        {
            if (pOptions->fConnect)
            {
                if (pProps->Status != NCS_CONNECTED)
                {
                    pcon->Connect();
                }
                else
                {
                    g_pDiagCtx->Printf(ttidNcDiag, "%S is already connected.\n",
                           pOptions->szLanConnection);
                }
            }
            else
            {
                if (pProps->Status != NCS_DISCONNECTED)
                {
                    pcon->Disconnect();
                }
                else
                {
                    g_pDiagCtx->Printf(ttidNcDiag, "%S is already disconnected.\n",
                           pOptions->szLanConnection);
                }
            }

            FreeNetconProperties(pProps);
        }
    }
    else if (S_FALSE == hr)
    {
        g_pDiagCtx->Printf(ttidNcDiag, "Could not find match for connection name: %S\n",
               pOptions->szLanConnection);
    }
}

EXTERN_C
VOID
WINAPI
NetManDiagFromCommandArgs (DIAG_OPTIONS *pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    INetConnectionManager * pConMan;

    HrInitializeConMan(&pConMan);

    switch (pOptions->Command)
    {
    case CMD_SHOW_LAN_CONNECTIONS:
        CmdShowLanConnections(pOptions, pConMan);
        break;

    case CMD_SHOW_ALL_DEVICES:
        CmdShowAllDevices(pOptions, pConMan);
        break;

    case CMD_SHOW_LAN_DETAILS:
        CmdShowLanDetails(pOptions, pConMan);
        break;

    case CMD_LAN_CHANGE_STATE:
        CmdLanChangeState(pOptions, pConMan);
        break;

    default:
        break;
    }

    HrUninitializeConMan(pConMan);

    g_pDiagCtx = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\nmhnet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       N M H N E T . C P P
//
//  Contents:   Home networking support routines
//
//  Notes:
//
//  Author:     jonburs     15 August 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "nmbase.h"
#include "nmhnet.h"

//
// Exported globals
//

IHNetCfgMgr *g_pHNetCfgMgr;
LONG g_lHNetModifiedEra;

//
// Private globals
//

CRITICAL_SECTION g_csHNetCfgMgr;
BOOLEAN g_fCreatingHNetCfgMgr;

VOID
InitializeHNetSupport(
    VOID
    )

{
    g_pHNetCfgMgr = NULL;
    g_lHNetModifiedEra = 0;
    g_fCreatingHNetCfgMgr = FALSE;

    __try
    {
        InitializeCriticalSection(&g_csHNetCfgMgr);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(FALSE, "InitializeHNetSupport: exception during InitializeCriticalSection");
    }
}

VOID
CleanupHNetSupport(
    VOID
    )

{
    ReleaseObj(g_pHNetCfgMgr);
    DeleteCriticalSection(&g_csHNetCfgMgr);
}

HRESULT
HrGetHNetCfgMgr(
    IHNetCfgMgr **ppHNetCfgMgr
    )

{
    HRESULT hr = S_OK;

    Assert(ppHNetCfgMgr);

    *ppHNetCfgMgr = NULL;

    //
    // Make sure that the service is in the correct state.
    //

    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        if (NULL == g_pHNetCfgMgr)
        {
            EnterCriticalSection(&g_csHNetCfgMgr);

            if (!g_fCreatingHNetCfgMgr && NULL == g_pHNetCfgMgr)
            {
                IHNetCfgMgr *pHNetCfgMgr;
                
                g_fCreatingHNetCfgMgr = TRUE;
                
                LeaveCriticalSection(&g_csHNetCfgMgr);
                hr = HrCreateInstance(
                        CLSID_HNetCfgMgr,
                        CLSCTX_INPROC_SERVER,
                        &pHNetCfgMgr
                        );
                EnterCriticalSection(&g_csHNetCfgMgr);
                
                Assert(NULL == g_pHNetCfgMgr);
                g_fCreatingHNetCfgMgr = FALSE;
                g_pHNetCfgMgr = pHNetCfgMgr;
            }
            else if (NULL == g_pHNetCfgMgr)
            {
                //
                // Another thread is already trying to create the
                // object. (Spin for a small amount of time to see
                // if that thread succeeds?)
                //

                hr = HRESULT_FROM_WIN32(ERROR_BUSY);

            }

            LeaveCriticalSection(&g_csHNetCfgMgr);
        }

        Assert(g_pHNetCfgMgr || FAILED(hr));

        if (SUCCEEDED(hr))
        {
            *ppHNetCfgMgr = g_pHNetCfgMgr;
            AddRefObj(*ppHNetCfgMgr);
        }
    }

    return hr;
}

//
// CNetConnectionHNetUtil implementation -- INetConnectionHNetUtil routines
//

STDMETHODIMP
CNetConnectionHNetUtil::NotifyUpdate(
    VOID
    )

{
    InterlockedIncrement(&g_lHNetModifiedEra);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\nmpolicy.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       E V E N T Q  . C P P
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmpolicy.h"
#include "ncperms.h"

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

CNetMachinePolicies::CNetMachinePolicies() : m_pGroupPolicyNLA(0)
{
    HRESULT hr;
    hr = HrEnsureRegisteredWithNla();
    if (SUCCEEDED(hr))
    {
        m_pGroupPolicyNLA = g_pGPNLA;
    }
    TraceHr(ttidGPNLA, FAL, hr, (S_FALSE==hr), "CNetMachinePolicies::CNetMachinePolicies()");
}

CNetMachinePolicies::~CNetMachinePolicies()
{
}

HRESULT CNetMachinePolicies::VerifyPermission(IN DWORD ulPerm, OUT BOOL* pfPermission)
{
    Assert(ulPerm == NCPERM_ShowSharedAccessUi || ulPerm == NCPERM_PersonalFirewallConfig || 
           ulPerm == NCPERM_ICSClientApp || ulPerm == NCPERM_AllowNetBridge_NLA);

    if (ulPerm != NCPERM_ShowSharedAccessUi && ulPerm != NCPERM_PersonalFirewallConfig  &&
        ulPerm != NCPERM_ICSClientApp && ulPerm != NCPERM_AllowNetBridge_NLA)
    {
        return E_INVALIDARG;
    }
    if (!pfPermission)
    {
        return E_POINTER;
    }

    // If for some reason m_pGroupPolicyNLA is NULL, then FHasPermission will return TRUE,
    // We assume that we're on a different network from which the policy came, rather than
    // enforce the policies and cause the firewall not to start when connected to a public
    // network.

    *pfPermission = FHasPermission(ulPerm, dynamic_cast<CGroupPolicyBase*>(m_pGroupPolicyNLA));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\cobase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O B A S E . C P P
//
//  Contents:   Connection Objects Shared code
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cobase.h"
#include "netconp.h"
#include "ncnetcon.h"

HRESULT HrSysAllocString(BSTR *bstrDestination, const BSTR bstrSource)
{
    HRESULT hr = S_OK;
    if (bstrSource)
    {
        *bstrDestination = SysAllocString(bstrSource);
        if (!*bstrDestination)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *bstrDestination = SysAllocString(NULL);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetDefault
//
//  Purpose:    Get the default RAS connection
//
//  Arguments:  pbDefault - Is this the default connection
//
//  Returns:    S_OK or an error code
//
HRESULT
HrBuildPropertiesExFromProperties(NETCON_PROPERTIES* pProps, NETCON_PROPERTIES_EX* pPropsEx, IPersistNetConnection* pPersistNetConnection)
{
    HRESULT hr = S_OK;

    Assert(pProps);
    Assert(pPropsEx);

    BYTE* pbData;
    DWORD cbData;

    hr = pPersistNetConnection->GetSizeMax(&cbData);

    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        pbData = new BYTE[cbData];
        if (pbData)
        {
            hr = pPersistNetConnection->Save (pbData, cbData);

            if (FAILED(hr))
            {
                delete [] pbData;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;

        pPropsEx->bstrPersistData = NULL;
        pPropsEx->bstrName        = NULL;
        pPropsEx->bstrDeviceName  = NULL;

        if ( (pPropsEx->bstrPersistData = SysAllocStringByteLen(reinterpret_cast<LPSTR>(pbData), cbData)) &&
             (SUCCEEDED(HrSysAllocString(&(pPropsEx->bstrName),       pProps->pszwName))) && 
             (SUCCEEDED(HrSysAllocString(&(pPropsEx->bstrDeviceName), pProps->pszwDeviceName))) )
        {
            hr = S_OK;

            pPropsEx->guidId = pProps->guidId;
            pPropsEx->ncStatus = pProps->Status;
            pPropsEx->ncMediaType = pProps->MediaType;
            pPropsEx->dwCharacter = pProps->dwCharacter;
            pPropsEx->clsidThisObject = pProps->clsidThisObject;
            pPropsEx->clsidUiObject = pProps->clsidUiObject;
            pPropsEx->bstrPhoneOrHostAddress = SysAllocString(NULL);
        }
        else
        {
            SysFreeString(pPropsEx->bstrPersistData);
            SysFreeString(pPropsEx->bstrName);
            SysFreeString(pPropsEx->bstrDeviceName);
        }
        
        delete[] pbData;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrBuildPropertiesExFromProperties");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPropertiesExFromINetConnection
//
//  Purpose:    Get the extended properties from INetConnection2, or get the 
//              properties and build the extended properties
//              
//
//  Arguments:
//      pPropsEx        [in]  Properties to use to build the safe array.
//      ppsaProperties  [out] Safe array in which to store data.
//
//  Returns:    HRESULT
//
//  Author:     ckotze 05 Apr 2001
//
//  Notes:      Caller must free array and contents.
//              
//
HRESULT HrGetPropertiesExFromINetConnection(INetConnection* pConn, NETCON_PROPERTIES_EX** ppPropsEx)
{
    HRESULT hr = S_OK;
    CComPtr <INetConnection2> pConn2;
    
    Assert(ppPropsEx);
    
    *ppPropsEx = NULL;
    
    hr = pConn->QueryInterface(IID_INetConnection2, reinterpret_cast<LPVOID*>(&pConn2));
    if (SUCCEEDED(hr))
    {
        hr = pConn2->GetPropertiesEx(ppPropsEx);
    }
    else
    {
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));   
        if (pPropsEx)
        {
            NETCON_PROPERTIES* pProps;
            
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));
            
            hr = pConn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                CComPtr<IPersistNetConnection> pPersistNet;
                
                hr = pConn->QueryInterface(IID_IPersistNetConnection, reinterpret_cast<LPVOID*>(&pPersistNet));
                if (SUCCEEDED(hr))
                {
                    hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, pPersistNet);
                    if (SUCCEEDED(hr))
                    {
                        *ppPropsEx = pPropsEx;
                    }
                    else
                    {
                        HrFreeNetConProperties2(pPropsEx);
                        pPropsEx = NULL;
                    }
                }
                FreeNetconProperties(pProps);
            }

            if (FAILED(hr) && (pPropsEx))
            {
                CoTaskMemFree(pPropsEx);
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conman\gpnla.cpp ===
//+---------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //  Copyright (C) Microsoft Corporation, 2001.
    //
    //  File:       G P N L A . C P P
    //
    //  Contents:   Class for Handling NLA Changes that affect Group Policies
    //
    //  Notes:
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //----------------------------------------------------------------------------

    #include "pch.h"
    #pragma hdrstop
    #include "trace.h"
    #include "gpnla.h"
    #include <winsock2.h>
    #include <mswsock.h>
    #include "nmbase.h"
    #include <userenv.h>
    #include <userenvp.h>
    #include <ncstl.h>
    #include <ncstlstr.h>
    #include <stlalgor.h>
    #include <lancmn.h>
    #include <lm.h>
    #include <ipnathlp.h>
    #include "ncmisc.h"
    #include "ipifcons.h"
    #include "ncexcept.h"
    #include "conman.h"

    GUID g_WsMobilityServiceClassGuid = NLA_SERVICE_CLASS_GUID;

    extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

    bool operator == (const GPNLAPAIR& rpair1, const GPNLAPAIR& rpair2)
    {
        return IsEqualGUID(rpair1.first, rpair2.first) == TRUE;
    }

    LONG CGroupPolicyNetworkLocationAwareness::m_lBusyWithReconfigure = 0;

    CGroupPolicyNetworkLocationAwareness::CGroupPolicyNetworkLocationAwareness()
    {
        m_fSameNetwork = FALSE;
        m_fShutdown = FALSE;
        m_lRefCount = 0;
        m_fErrorShutdown = FALSE;
        m_hGPWait = INVALID_HANDLE_VALUE;
        m_hNLAWait = INVALID_HANDLE_VALUE;
        m_lBusyWithReconfigure = 0;
    }

    CGroupPolicyNetworkLocationAwareness::~CGroupPolicyNetworkLocationAwareness()
    {
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::Initialize
    //
    //  Purpose:    To initialize the different components required for detecting
    //              changes to the network and creating the different
    //              synchronization objects required.
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating SUCCESS or FAILURE
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::Initialize()
    {
        HRESULT hr;

        TraceTag(ttidGPNLA, "Initializing Group Policy Handler");

        InitializeCriticalSection(&m_csList);

        // Init Winsock
        if (ERROR_SUCCESS == WSAStartup(MAKEWORD(2, 2), &m_wsaData))
        {
            m_hEventNLA = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hEventNLA)
            {
                m_hEventExit = CreateEvent(NULL, FALSE, FALSE, NULL);
                if (m_hEventExit)
                {
                    m_hEventGP = CreateEvent(NULL, FALSE, FALSE, NULL);
                    if (m_hEventGP)
                    {
                        hr = RegisterWait();
                        if (SUCCEEDED(hr))
                        {
                            if (RegisterGPNotification(m_hEventGP, TRUE))
                            {
                                ZeroMemory(&m_wsaCompletion,sizeof(m_wsaCompletion));
                                ZeroMemory(&m_wsaOverlapped,sizeof(m_wsaOverlapped));

                                m_wsaOverlapped.hEvent = m_hEventNLA;

                                m_wsaCompletion.Type = NSP_NOTIFY_EVENT;
                                m_wsaCompletion.Parameters.Event.lpOverlapped = &m_wsaOverlapped;

                                ZeroMemory(&m_wqsRestrictions, sizeof(m_wqsRestrictions));
                                m_wqsRestrictions.dwSize = sizeof(m_wqsRestrictions);
                                m_wqsRestrictions.lpServiceClassId = &g_WsMobilityServiceClassGuid;
                                m_wqsRestrictions.dwNameSpace = NS_NLA;

                                hr = LookupServiceBegin(LUP_NOCONTAINERS);

                                if (SUCCEEDED(hr))
                                {
                                    // Loop through once and get all the data to begin with.
                                    hr = EnumChanges();
                                }
                                return hr;
                            }
                            else
                            {
                                hr = HrFromLastWin32Error();
                                DeregisterWait();
                            }
                        }
                        CloseHandle(m_hEventGP);
                    }
                    else
                    {
                        hr = HrFromLastWin32Error();
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error();
                }
                CloseHandle(m_hEventExit);
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
            CloseHandle(m_hEventNLA);
        }
        else
        {
            int nError;

            nError  = WSAGetLastError();

            hr = HRESULT_FROM_WIN32(nError);
        }

        TraceError("CGroupPolicyNetworkLocationAwareness::Initialize failed", hr);

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::Uninitialize
    //
    //  Purpose:    This is used to ensure that no threads are currently running
    //              when they should be stopped.  If the refcount is >0 then it
    //              waits for the last busy thread to terminate and set the event
    //              marking its termination so that shutdown can proceed.
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::Uninitialize()
    {
        HRESULT hr = S_OK;
        DWORD dwRet = WAIT_OBJECT_0;
        int nCount = 0;

        TraceTag(ttidGPNLA, "Unitializing Group Policy Handler");

        m_fShutdown = TRUE;

        Unreference();

        // LookupServiceEnd should cause an event to fire which will make us exit (unless NLA was already stopped).
        hr = LookupServiceEnd();

        if ((0 != m_lRefCount) && SUCCEEDED(hr) && !m_fErrorShutdown)
        {
            dwRet = WaitForSingleObject(m_hEventExit, 30000L);
        }

        do
        {
            hr = DeregisterWait();
            if (SUCCEEDED(hr))
            {
                break;
            }
        } while ((nCount++ < 3) && FAILED(hr));

        TraceError("DeregisterWait returned", hr);

        if (SUCCEEDED(hr))
        {
            CloseHandle(m_hEventExit);
            CloseHandle(m_hEventNLA);

            DeleteCriticalSection(&m_csList);

            WSACleanup();
        }

        TraceTag(ttidGPNLA, "NLA was uninitialized");

         return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::RegisterWait
    //
    //  Purpose:    Registers the Wait Object so that we don't require any threads
    //              of our own.
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::RegisterWait()
    {
        TraceFileFunc(ttidGPNLA);

        HRESULT hr = S_OK;
        NTSTATUS Status;

        Reference();  // Make sure that we're referenced so that we don't accidentally kill the service while it's still busy.

        Status = RtlRegisterWait(&m_hNLAWait, m_hEventNLA, &CGroupPolicyNetworkLocationAwareness::EventHandler, this, INFINITE, WT_EXECUTEINLONGTHREAD);

        if (!NT_SUCCESS(Status))
        {
            m_hNLAWait = INVALID_HANDLE_VALUE;
            hr = HRESULT_FROM_NT(Status);
        }
        else
        {
            Status = RtlRegisterWait(&m_hGPWait, m_hEventGP, &CGroupPolicyNetworkLocationAwareness::GroupPolicyChange, this, INFINITE, WT_EXECUTEINLONGTHREAD);
            if (!NT_SUCCESS(Status))
            {
                hr = HRESULT_FROM_NT(Status);
                RtlDeregisterWaitEx(m_hNLAWait, INVALID_HANDLE_VALUE);
                m_hGPWait = INVALID_HANDLE_VALUE;
                m_hNLAWait = INVALID_HANDLE_VALUE;
            }
        }

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::DeregisterWait
    //
    //  Purpose:    Deregisters the wait so that we can shutdown and not have
    //              any new threads spawned.
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::DeregisterWait()
    {
        TraceFileFunc(ttidGPNLA);

        HRESULT hr,hr1,hr2 = S_OK;
        NTSTATUS Status1, Status2;

        if (INVALID_HANDLE_VALUE != m_hNLAWait)
        {
            Status1 = RtlDeregisterWaitEx(m_hNLAWait, INVALID_HANDLE_VALUE);

            if (!NT_SUCCESS(Status1))
            {
                hr1 = HRESULT_FROM_NT(Status1);
            }

            if (INVALID_HANDLE_VALUE != m_hGPWait)
            {
                Status2 = RtlDeregisterWaitEx(m_hGPWait, INVALID_HANDLE_VALUE);
                if (!NT_SUCCESS(Status2))
                {
                    hr2 = HRESULT_FROM_NT(Status2);
                }
            }

            if (FAILED(hr1))
            {
                hr = hr1;
            }
            else if (FAILED(hr2))
            {
                hr = hr2;
            }
        }
        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::IsJoinedToDomain
    //
    //  Purpose:    Checks to see if this machine belongs to an NT Domain
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    BOOL.  TRUE = Joined to a Domain, FALSE = not...
    //
    //  Author:     sjkhan   29 Jan 2002
    //
    //  Notes:
    //
    BOOL CGroupPolicyNetworkLocationAwareness::IsJoinedToDomain()
    {
        static DWORD dwDomainMember = 0xffffffff; // Unconfigured

        TraceTag(ttidGPNLA, "Entering IsJoinedToDomain");

        if (0xffffffff == dwDomainMember)
        {
            dwDomainMember = FALSE;

            LPWSTR pszDomain;
            NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
            if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
            {
                NetApiBufferFree(pszDomain);
                if (NetSetupDomainName == njs)
                {
                    dwDomainMember = TRUE;
                    TraceTag(ttidGPNLA, "We're  on a domain (NLA policies apply)");
                }
                else
                {
                    TraceTag(ttidGPNLA, "We're not on a domain (No NLA policies will apply)");
                }
            }
            else
            {
                TraceTag(ttidGPNLA, "We're not on a domain (No NLA policies will apply)");
            }
        }
        else
        {
            TraceTag(ttidGPNLA, "IsJoinedToDomain: We're already configured...");
        }

        TraceTag(ttidGPNLA, "Leaving IsJoinedToDomain");

        return static_cast<BOOL>(dwDomainMember);
    }



    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::IsSameNetworkAsGroupPolicies
    //
    //  Purpose:    Used to determine our current network location with respect to
    //              the network from which the Group Policies came from.
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    BOOL.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    BOOL CGroupPolicyNetworkLocationAwareness::IsSameNetworkAsGroupPolicies()
    {
        BOOL fNetworkMatch = FALSE;  // Assume we are on a different network.
        WCHAR pszName[256] = {0};
        DWORD dwSize = 256;
        DWORD dwErr;

        TraceTag(ttidGPNLA, "Entering IsSameNetworkAsGroupPolicies");

        // Get the network Name.
        dwErr = GetGroupPolicyNetworkName(pszName, &dwSize);

        TraceTag(ttidGPNLA, "NetworkName: %S", pszName);

        if (ERROR_SUCCESS == dwErr)
        {
            if (IsJoinedToDomain())
            {
                CExceptionSafeLock esLock(&m_csList);  // Protecting list
                GPNLAPAIR nlapair;

                // We need to look at all of the adapters to check that at least 1
                // is on the same network from which the Group Policies came.
                for (GPNLAITER iter = m_listAdapters.begin(); iter != m_listAdapters.end(); iter++)
                {
                    LPCSTR pStr = NULL;
                    nlapair = *iter;

                    TraceTag(ttidGPNLA,  "Network Name: %S", nlapair.second.strNetworkName);
                    TraceTag(ttidGPNLA,  "Network Status: %s", DbgNcs(nlapair.second.ncsStatus));

                    if (
                            (nlapair.second.strNetworkName == pszName)
                            &&
                            (
                                (NCS_CONNECTED == nlapair.second.ncsStatus) ||
                                (NCS_AUTHENTICATING == nlapair.second.ncsStatus) ||
                                (NCS_AUTHENTICATION_SUCCEEDED == nlapair.second.ncsStatus) ||
                                (NCS_AUTHENTICATION_FAILED == nlapair.second.ncsStatus) ||
                                (NCS_CREDENTIALS_REQUIRED == nlapair.second.ncsStatus)
                            )
                        )
                    {
                        // Yes, we're still on the network so we need to enforce group policies.
                        fNetworkMatch = TRUE;
                    }
                }
            }
            else
            {
                TraceTag(ttidGPNLA, "We're not on a domain, exiting...");
            }

            if (fNetworkMatch != m_fSameNetwork)
            {
                LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
                m_fSameNetwork = fNetworkMatch;
                ReconfigureHomeNet();
            }
        }

        return fNetworkMatch;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::Reference
    //
    //  Purpose:    Increments our reference count.
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    The current Refcount (note this may not be 100% accurate,
    //              but will never be 0 unless we're really shutting down).
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    LONG CGroupPolicyNetworkLocationAwareness::Reference()
    {
        InterlockedIncrement(&m_lRefCount);

        TraceTag(ttidGPNLA, "Reference() - Count: %d", m_lRefCount);

        return m_lRefCount;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::Unreference
    //
    //  Purpose:    Decrements our reference countand sets and event if it reaches
    //              zero and we're shutting down.
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    The current Refcount (note this may not be 100% accurate,
    //              but will never be 0 unless we're really shutting down).
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    LONG CGroupPolicyNetworkLocationAwareness::Unreference()
    {
        if ((0 == InterlockedDecrement(&m_lRefCount)) && m_fShutdown)
        {
            SetEvent(m_hEventExit);
        }

        TraceTag(ttidGPNLA, "Unreference() - Count: %d", m_lRefCount);

        return m_lRefCount;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceBegin
    //
    //  Purpose:    Wraps the WSA function using our class members.
    //
    //  Arguments:
    //      DWORD dwControlFlags - WSA Control Flags
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceBegin(DWORD dwControlFlags)
    {
        HRESULT hr = S_OK;

        if (SOCKET_ERROR == WSALookupServiceBegin(&m_wqsRestrictions, dwControlFlags, &m_hQuery))
        {
            int nError;

            nError = WSAGetLastError();

            hr = HRESULT_FROM_WIN32(nError);

            TraceError("WSALookupServiceBegin() failed", hr);

            m_hQuery = NULL;
        }

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceNext
    //
    //  Purpose:    Wraps the WSA function using our class members.
    //
    //  Arguments:
    //      DWORD dwControlFlags [in]           - WSA Control Flags
    //      LPDWORD lpdwBufferLength [in/out]   - Buffer Length sent/required.
    //      LPWSAQUERYSET lpqsResults [out]     - Actual Query Results.
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceNext(DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults)
    {
        HRESULT hr = S_OK;
        int nError;

        INT nRet = WSALookupServiceNext(m_hQuery, dwControlFlags, lpdwBufferLength, lpqsResults);
        if (SOCKET_ERROR == nRet)
        {
            BOOL fTraceError;

            nError = WSAGetLastError();
            hr = HRESULT_FROM_WIN32(nError);

            fTraceError = (!lpqsResults || (hr == HRESULT_FROM_WIN32(WSA_E_NO_MORE))) ? TRUE : FALSE;

            TraceErrorOptional("LookupServiceNext", hr, fTraceError);
        }

        TraceTag(ttidGPNLA, "LookupServiceNext terminated with %x", nRet);

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceEnd
    //
    //  Purpose:    Wraps the WSA function using our class members.
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating success/failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceEnd()
    {
        HRESULT hr = S_OK;
        int nError;

        if (SOCKET_ERROR == WSALookupServiceEnd(m_hQuery))
        {
            nError = WSAGetLastError();
            hr = HRESULT_FROM_WIN32(nError);
        }

        m_hQuery = NULL;

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::QueueEvent
    //
    //  Purpose:    Queue's an event to notify netshell of a change.
    //
    //  Arguments:
    //      CONMAN_EVENTTYPE cmEventType [in]   - Type of Event.
    //      LPGUID pguidAdapter [in]            - Guid for the adapter.
    //      NETCON_STATUS ncsStatus [in]        - Status for Connection.
    //
    //  Returns:    HRESULT.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::QueueEvent(CONMAN_EVENTTYPE cmEventType, LPGUID pguidAdapter, NETCON_STATUS ncsStatus)
    {
        HRESULT hr = S_OK;

        if ( (CONNECTION_STATUS_CHANGE == cmEventType) ||
             (CONNECTION_ADDRESS_CHANGE == cmEventType) )
        {
            CONMAN_EVENT* pEvent = new CONMAN_EVENT;

            if (pEvent)
            {
                ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
                pEvent->Type = cmEventType;
                pEvent->guidId = *pguidAdapter;
                pEvent->Status = ncsStatus;
                pEvent->ConnectionManager = CONMAN_LAN;

                if (NCS_HARDWARE_NOT_PRESENT == ncsStatus) // Not too useful for LAN connections. We can delete the device instead.
                {
                    // This will happen during PnP undock.
                    TraceTag(ttidGPNLA, "Sending delete for NCS_HARDWARE_NOT_PRESENT instead");
                    pEvent->Type = CONNECTION_DELETED;
                }

                if (!QueueUserWorkItemInThread(LanEventWorkItem, reinterpret_cast<PVOID>(pEvent), EVENTMGR_CONMAN))
                {
                    FreeConmanEvent(pEvent);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        TraceHr(ttidError, FAL, hr, FALSE, "CGroupPolicyNetworkLocationAwareness::QueueEvent");

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::EnumChanges
    //
    //  Purpose:    Enumerates all the changes that have occurred to the network.
    //
    //  Arguments:
    //      (none)
    //
    //  Returns:    HRESULT indicating success or failure.
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:      This will re-increment the reference count if m_fShutdown is not set.
    //              Doesn't allow it to go to Zero though.
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::EnumChanges()
    {
        HRESULT hr = S_OK;
        BOOL fRet = FALSE;
        BOOL fNoNetwork = TRUE;
        BOOL fNetworkMatch = FALSE;
        PWSAQUERYSET wqsResult = NULL;
        DWORD dwLen;
        WCHAR pszName[256] = {0};
        DWORD dwSize = 256;

        TraceTag(ttidGPNLA, "Entering EnumChanges");

        BOOL bDomainMember = IsJoinedToDomain();

        if (!m_hQuery)
        {
            // For some reason we didn't get this ealier.
            // Possibly TCP/IP wasn't installed.  We can add this now and
            // it will have the desired effect.
            LookupServiceBegin(LUP_NOCONTAINERS);
        }

        if (!m_hQuery)
        {
            return E_UNEXPECTED;
        }

        while (fRet == FALSE)
        {
            dwLen = 0;
            // Do call twice, first to get dwSize of buffer for second call
            hr = LookupServiceNext(0, &dwLen, NULL);
            if (FAILED(hr) && hr != HRESULT_FROM_WIN32(WSA_E_NO_MORE) && hr != HRESULT_FROM_WIN32(WSAEFAULT))
            {
                TraceError("LookupServiceNext", hr);
                fRet = FALSE;
                break;
            }

            wqsResult = reinterpret_cast<PWSAQUERYSET>(new BYTE[dwLen]);

            if (!wqsResult)
            {
                hr = HrFromLastWin32Error();
                TraceError("Error: malloc() failed", hr);
                fRet = TRUE;
                break;
            }

            if (S_OK == (hr = LookupServiceNext(0, &dwLen, wqsResult)))
            {
                fNoNetwork = FALSE;
                if (wqsResult->lpBlob != NULL)
                {
                    NLA_BLOB *blob = reinterpret_cast<NLA_BLOB *>(wqsResult->lpBlob->pBlobData);
                    int next;
                    do
                    {
                        // We are looking for the blob containing the network GUID
                        if (blob->header.type == NLA_INTERFACE)
                        {
                            WCHAR strAdapter[MAX_PATH];
                            DWORD dwErr;

                            ZeroMemory(strAdapter, MAX_PATH * sizeof(WCHAR));

                            wcscpy(strAdapter, wqsResult->lpszServiceInstanceName);

                            // Get the network Name. We ignore failure since we still need to know other details.
                            dwErr = GetGroupPolicyNetworkName(pszName, &dwSize);

                            // matching pszName and interface type is ATM/LAN etc, but not RAS
                            if(blob->data.interfaceData.dwType != IF_TYPE_PPP && blob->data.interfaceData.dwType != IF_TYPE_SLIP)
                            {
                                CExceptionSafeLock esLock(&m_csList);   // Protecting list
                                GUID guidAdapter;
                                WCHAR strAdapterGuid[39];
                                GPNLAPAIR nlapair;
                                GPNLAITER iter;
                                NETCON_STATUS ncsStatus;

                                ZeroMemory(strAdapterGuid, 39 * sizeof(WCHAR));

                                TraceTag(ttidGPNLA, "AdapterName: %s", blob->data.interfaceData.adapterName);

                                mbstowcs(strAdapterGuid, blob->data.interfaceData.adapterName, 39);

                                CLSIDFromString(strAdapterGuid, &guidAdapter);

                                nlapair.first = guidAdapter;

                                iter = find(m_listAdapters.begin(), m_listAdapters.end(), nlapair);

                                if (iter == m_listAdapters.end())
                                {
                                    // We didn't find the adapter in the list that we currently have.
                                    // So we need to add it to the list.
                                    hr = HrGetPnpDeviceStatus(&guidAdapter, &ncsStatus);

                                    nlapair.second.strNetworkName = strAdapter;
                                    nlapair.second.ncsStatus = ncsStatus;

                                    if (SUCCEEDED(hr))
                                    {
                                        // If we got a valid status, we go ahead and add the adapter to
                                        // the list.
                                        m_listAdapters.insert(m_listAdapters.begin(), nlapair);
                                    }

                                    // Send the initial address status info:
                                    QueueEvent(CONNECTION_STATUS_CHANGE,  &guidAdapter, ncsStatus);
                                    QueueEvent(CONNECTION_ADDRESS_CHANGE, &guidAdapter, ncsStatus);
                                }
                                else
                                {
                                    // We found the adapter, so update its status.
                                    GPNLAPAIR& rnlapair = *iter;

                                    if (rnlapair.second.strNetworkName != strAdapter)
                                    {
                                        rnlapair.second.strNetworkName = strAdapter;
                                    }

                                    hr = HrGetPnpDeviceStatus(&guidAdapter, &ncsStatus);

                                    if (SUCCEEDED(hr))
                                    {
                                        if (ncsStatus != rnlapair.second.ncsStatus)
                                        {
                                            // The status is different so we need to send an event to the connections folder.
                                            rnlapair.second.ncsStatus = ncsStatus;
                                        }

                                        // [Deon] We need to always send this as we don't really know what the current
                                        // status of the adapter is. We only know the NLA part.
                                        //
                                        // If we make the above check it could happen somebody else moves the address over
                                        // to NCS_INVALID_ADDRESS and then we don't send the NCS_CONNECTED once it changes.
                                        QueueEvent(CONNECTION_STATUS_CHANGE,  &guidAdapter, ncsStatus);
                                        QueueEvent(CONNECTION_ADDRESS_CHANGE, &guidAdapter, ncsStatus);
                                    }
                                }

                                if (strAdapter != pszName)
                                {
                                    // If this adapter is not on the same network, then we need to look at all others and
                                    // ensure that at least 1 is on the same network from which the Group Policies came.
                                    for (GPNLAITER iter = m_listAdapters.begin(); iter != m_listAdapters.end(); iter++)
                                    {
                                        LPCSTR pStr = NULL;
                                        nlapair = *iter;

                                        TraceTag(ttidGPNLA,  "Network Name: %S", nlapair.second.strNetworkName);
                                        TraceTag(ttidGPNLA,  "Network Status: %s", DbgNcs(nlapair.second.ncsStatus));

                                        if (nlapair.second.strNetworkName == pszName)
                                        {
                                            // Yes, we're still on the network so we need to enforce group policies.
                                            fNetworkMatch = TRUE;
                                        }
                                    }
                                }

                                if (fNetworkMatch)
                                {
                                    break;
                                }
                            }
                        }
                        // There may be multiple blobs for each interface so make sure we find them all
                        next = blob->header.nextOffset;
                        blob = (NLA_BLOB *)(((char *)blob) + next);
                    } while(next != 0);
                }
                else
                {
                    TraceTag(ttidGPNLA, "Blob is NULL");
                    fRet = TRUE;
                }

                free(wqsResult);
                wqsResult = NULL;
            }
            else
            {
                if (hr != HRESULT_FROM_WIN32(WSA_E_NO_MORE))
                {
                    TraceError("LookupServiceNext failed\n", hr);
                    fRet = FALSE;
                }
                free(wqsResult);
                break;
            }
        }

        BOOL fFireRefreshAll = FALSE;

        if (bDomainMember)
        {
            if (!fNoNetwork)
            {   // We have a Network
                if (fNetworkMatch)
                {
                    // Enforce Policies.
                    if (!m_fSameNetwork)
                    {
                        // We are changing the network - we need to refresh all the connectoids in the folder to
                        // update their icons to reflect policy.
                        fFireRefreshAll = TRUE;
                        m_fSameNetwork  = TRUE;
                    }

                    TraceTag(ttidGPNLA, "Network Match");
                }
                else
                {
                    // Removed Policy Enforcement.
                    if (m_fSameNetwork)
                    {
                        // We are changing the network - we need to refresh all the connectoids in the folder to
                        // update their icons to reflect policy.
                        fFireRefreshAll = TRUE;
                        m_fSameNetwork  = FALSE;
                    }

                    TraceTag(ttidGPNLA, "Network does not Match");
                }
                ReconfigureHomeNet();
            }
            else
            {
                // No Networks so don't do anything.
            }
        }
        else // Member of a workgroup
        {
            m_fSameNetwork = FALSE;
            ReconfigureHomeNet();
        }

        if (HRESULT_FROM_WIN32(WSA_E_NO_MORE) == hr)
        {
            hr = S_OK;
        }

        DWORD cbOutBuffer;

        if (!m_fShutdown)
        {
            Reference();

            // Wait for Network Change
            WSANSPIoctl(m_hQuery, SIO_NSP_NOTIFY_CHANGE,
                        NULL, 0, NULL, 0, &cbOutBuffer,
                        &m_wsaCompletion);

            if (fFireRefreshAll)
            {
                LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
            }
        }

        TraceTag(ttidGPNLA, "Exiting EnumChanges");

        return hr;
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::EventHandler
    //
    //  Purpose:    Called when NLA changes occur.
    //
    //  Arguments:
    //      LPVOID  pContext    - generally the "this" pointer.
    //      BOOLEAN fTimerFired - if this happened because of a timer or the event
    //                            getting set.  Since we specify INFINITE, this is
    //                            not going to get fired by the timer.
    //  Returns:    nothing
    //
    //  Author:     sjkhan   20 Feb 2001
    //
    //  Notes:
    //
    VOID NTAPI CGroupPolicyNetworkLocationAwareness::EventHandler(IN LPVOID pContext, IN BOOLEAN fTimerFired)
    {
        CGroupPolicyNetworkLocationAwareness* pGPNLA = reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(pContext);

        DWORD dwBytes;

        BOOL bSucceeded = GetOverlappedResult(pGPNLA->m_hQuery, &pGPNLA->m_wsaOverlapped, &dwBytes, FALSE);

        if (!bSucceeded)
        {
            TraceError("GetOverlappedResult failed", HrFromLastWin32Error());
        }

        if (FALSE == fTimerFired && !pGPNLA->m_fShutdown && bSucceeded)
        {
            pGPNLA->EnumChanges();
        }

        pGPNLA->Unreference();

        if (!bSucceeded)
        {
            pGPNLA->m_fErrorShutdown = TRUE;

            QueueUserWorkItem(ShutdownNlaHandler, pContext, WT_EXECUTEINLONGTHREAD);
        }
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::GroupPolicyChange
    //
    //  Purpose:    Called when Machine Group Policy changes occur.
    //
    //  Arguments:
    //      LPVOID  pContext    - generally the "this" pointer.
    //      BOOLEAN fTimerFired - if this happened because of a timer or the event
    //                            getting set.  Since we specify INFINITE, this is
    //                            not going to get fired by the timer.
    //  Returns:    nothing
    //
    //  Author:     sjkhan   05 Feb 2002
    //
    //  Notes:
    //
    VOID NTAPI CGroupPolicyNetworkLocationAwareness::GroupPolicyChange(IN LPVOID pContext, IN BOOLEAN fTimerFired)
    {
        TraceTag(ttidGPNLA, "GroupPolicyChange called");
        ReconfigureHomeNet(TRUE);
        LanEventNotify(REFRESH_ALL, NULL, NULL, NULL);
    }

    //+---------------------------------------------------------------------------
    //
    //  Member:     CGroupPolicyNetworkLocationAwareness::ShutdownNlaHandler
    //
    //  Purpose:    Shutdown Nla handler, because Nla service is toast.
    //
    //  Arguments:
    //
    //
    //  Returns:    nothing
    //
    //  Author:     sjkhan   05 Feb 2002
    //
    //  Notes:
    //
    DWORD WINAPI CGroupPolicyNetworkLocationAwareness::ShutdownNlaHandler(PVOID pThis)
    {
        TraceFileFunc(ttidGPNLA);

        CGroupPolicyNetworkLocationAwareness* pGPNLA =
            reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(InterlockedExchangePointer( (PVOID volatile *) &g_pGPNLA, NULL));

        if (pGPNLA)
        {
            Assert(pGPNLA == pThis); // Making the assumption that the context is always g_pGPNLA, since I'm clearing g_pGPNLA.

            pGPNLA->Uninitialize();
            delete pGPNLA;
        }

        return 0;
    }

    //+---------------------------------------------------------------------------
    //
    //  Function:   ReconfigureHomeNet
    //
    //  Purpose:    Change Homenet Configuration
    //
    //  Arguments:
    //              fWaitUntilRunningOrStopped - if the caller should wait for the
    //                                          service to start, or to fail starting
    //                                          and stop.
    //
    //  Returns:    HRESULT indicating success of failure
    //
    //  Author:     sjkhan   09 Dec 2000
    //
    //  Notes:
    //
    //
    //
    //
    HRESULT CGroupPolicyNetworkLocationAwareness::ReconfigureHomeNet(BOOL fWaitUntilRunningOrStopped)
    {
        SC_HANDLE hscManager;
        SC_HANDLE hService;
        SERVICE_STATUS ServiceStatus;

        if (0 != InterlockedExchange(&m_lBusyWithReconfigure, 1L))
        {
            return S_FALSE;
        }

        TraceTag(ttidGPNLA, "Entering ReconfigureHomeNet");
        hscManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

        if (hscManager)
        {
            TraceTag(ttidGPNLA, "Attempting to open service");
            hService = OpenService(hscManager, L"SharedAccess", SERVICE_QUERY_STATUS | SERVICE_USER_DEFINED_CONTROL);
            if (hService)
            {
                DWORD dwCount = 0;
                SERVICE_STATUS SvcStatus = {0};
                BOOL fRet;

                if (fWaitUntilRunningOrStopped)
                {
                    do
                    {
                        if (!QueryServiceStatus(hService, &SvcStatus))
                        {
                            break;
                        }
                        if (SERVICE_START_PENDING == SvcStatus.dwCurrentState)
                        {
                            TraceTag(ttidGPNLA, "Service is still starting.  Waiting 5 seconds.");
                            Sleep(5000);  // Sleep 5 seconds;
                        }
                    } while ((SERVICE_START_PENDING == SvcStatus.dwCurrentState) && ++dwCount <= 6);
                }
                if (!fWaitUntilRunningOrStopped || (SERVICE_RUNNING == SvcStatus.dwCurrentState))
                {
                    fRet = ControlService(hService, IPNATHLP_CONTROL_UPDATE_CONNECTION, &ServiceStatus);
                    if (!fRet)
                    {
                        DWORD dwErr = GetLastError();
                        TraceError("Control Service returned: 0x%x", HRESULT_FROM_WIN32(dwErr));
                    }
                    else
                    {
                        TraceTag(ttidGPNLA, "Requested Reconfiguration check from ICF/ICS");
                    }
                }
                CloseServiceHandle(hService);
            }
            else
            {
                TraceTag(ttidGPNLA, "Could not open service");
            }

            CloseServiceHandle(hscManager);
        }

        TraceTag(ttidGPNLA, "Leaving ReconfigureHomeNet");

        InterlockedExchange(&m_lBusyWithReconfigure, 0L);

        return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\dialup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P . C P P
//
//  Contents:   Implements the dial up connection object.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "dialup.h"
#include "nccom.h"
#include "ncnetcon.h"
#include "ncras.h"
#include "ncreg.h"
#include "userenv.h"
#include "cmutil.h"
#include "cobase.h"

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceUninitialized
//
//  Purpose:    Create an uninitialized instance of
//              CComObject <CDialupConnection> and return an interface
//              pointer as well as a pointer to the CDialupConnection.
//
//  Arguments:
//      riid  [in]  IID of desired interface.
//      ppv   [out] Returned interface pointer.
//      ppObj [out] Returned object pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Apr 1998
//
//  Notes:
//
//static
HRESULT
CDialupConnection::CreateInstanceUninitialized (
    REFIID              riid,
    VOID**              ppv,
    CDialupConnection** ppObj)
{
    Assert (ppObj);
    Assert (ppv);

    *ppv = NULL;
    *ppObj = NULL;

    HRESULT hr = E_OUTOFMEMORY;

    CDialupConnection* pObj;
    pObj = new CComObject <CDialupConnection>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            INetConnection* pCon = static_cast<INetConnection*>(pObj);
            hr = pCon->QueryInterface (riid, ppv);
            if (SUCCEEDED(hr))
            {
                *ppObj = pObj;
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    TraceError ("CDialupConnection::CreateInstanceFromDetails", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceFromDetails
//
//  Purpose:    Create an initialized instance of
//              CComObject <CDialupConnection> given RASENUMENTRYDETAILS and
//              return an interface pointer on that object.
//
//  Arguments:
//      pszwPbkFile     [in]  Path to the phonebook file.
//      pszwEntryName   [in]  Name of the entry in the phonebook.
//      fForAllUsers    [in]  TRUE if this entry is for all users.
//      riid            [in]  IID of desired interface.
//      ppv             [out] Returned interface pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
// static
HRESULT
CDialupConnection::CreateInstanceFromDetails (
    const RASENUMENTRYDETAILS*  pEntryDetails,
    REFIID                      riid,
    VOID**                      ppv)
{
    Assert(pEntryDetails);
    Assert(pEntryDetails->szPhonebookPath);

    CDialupConnection* pObj;
    HRESULT hr = CreateInstanceUninitialized (riid, ppv, &pObj);
    if (SUCCEEDED(hr))
    {
        pObj->SetPbkFile (pEntryDetails->szPhonebookPath);

        pObj->CacheProperties (pEntryDetails);

        // We are now a full-fledged object.
        //
        pObj->m_fInitialized = TRUE;
    }
    TraceError ("CDialupConnection::CreateInstanceFromDetails", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceFromPbkFileAndEntryName
//
//  Purpose:    Create an initialized instance of
//              CComObject <CDialupConnection> given only a phonebook path,
//              entry name, and weather it is for all users or not and
//              return an interface pointer on that object.
//
//  Arguments:
//      pszPbkFile   [in]  Phonebook path.
//      pszEntryName [in]  Entry name.
//      riid          [in]  IID of desired interface.
//      ppv           [out] Returned interface pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Apr 1998
//
//  Notes:      This is called from Duplicate.
//
//static
HRESULT
CDialupConnection::CreateInstanceFromPbkFileAndEntryName (
    PCWSTR pszPbkFile,
    PCWSTR pszEntryName,
    REFIID  riid,
    VOID**  ppv)
{
    TraceTag (ttidWanCon,
        "CDialupConnection::CreateInstanceFromPbkFileAndEntryName called");

    CDialupConnection* pObj;
    HRESULT hr = CreateInstanceUninitialized (riid, ppv, &pObj);
    if (SUCCEEDED(hr))
    {
        pObj->SetPbkFile (pszPbkFile);
        pObj->SetEntryName (pszEntryName);
        pObj->m_guidId = GUID_NULL;

        // We are now a full-fledged object.
        //
        pObj->m_fInitialized = TRUE;
    }
    TraceError ("CDialupConnection::CreateInstanceFromPbkFileAndEntryName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnection
//

STDMETHODIMP
CDialupConnection::GetUiObjectClassId (
    CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        static const CLSID CLSID_DialupConnectionUi =
                {0x7007ACC1,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_DirectConnectionUi =
                {0x7007ACC2,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_VpnConnectionUi =
                {0x7007ACC6,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_PPPoEUi = 
                {0x7007ACD4,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};     

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            switch (MediaType ())
            {
                case NCM_DIRECT:
                    *pclsid = CLSID_DirectConnectionUi;
                    break;

                case NCM_ISDN:
                case NCM_PHONE:
                    *pclsid = CLSID_DialupConnectionUi;
                    break;

                case NCM_TUNNEL:
                    *pclsid = CLSID_VpnConnectionUi;
                    break;

                case NCM_PPPOE:
                    *pclsid = CLSID_PPPoEUi;
                    break;

                default:
                    *pclsid = CLSID_DialupConnectionUi;
                    TraceTag (ttidWanCon, "GetUiObjectClassId: Unknown media type "
                        "(%d) treating as CLSID_DialupConnectionUi", MediaType());
            }
        }
    }
    TraceError ("CDialupConnection::GetUiObjectClassId", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Connect ()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDialupConnection::Disconnect ()
{
    HRESULT hr;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        HRASCONN hRasConn;

        hr = HrFindRasConn (&hRasConn, NULL);
        if (S_OK == hr)
        {
            // Because RasHangup could call RasCustomHangup
            // we need to impersonate the client to allow the correct
            // per-user information to be used.
            //

            // Impersonate the client.
            //
            HRESULT hrT = CoImpersonateClient ();
            TraceErrorOptional ("CDialupConnection::Disconnect -- CoImpersonateClient", hrT, RPC_E_CALL_COMPLETE == hrT);

            // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
            if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
            {
                hr = HrRasHangupUntilDisconnected (hRasConn);
            }
            
            if (SUCCEEDED(hrT))
            {
                hrT = CoRevertToSelf ();
                TraceError ("CDialupConnection::Disconnect -- CoRevertToSelf", hrT);
            }
        }
        else if (S_FALSE == hr)
        {
            hr = S_OK;
        }
    }
    TraceError ("CDialupConnection::Disconnect", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Delete ()
{
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // If we allow removal (a decision which is based on the
            // whether the user is an admin, whether the connection is
            // 'for all users', and the connection's current state) then
            // proceed.  If FAllowRemoval fails, it's output parameter
            // is the "reason" in the form of an HRESULT.  We can use
            // this as our return value in that case.
            //
            HRESULT hrReason;
            if (FAllowRemoval (&hrReason))
            {
                // If we're active in any way, we can't be removed.
                //
                NETCON_STATUS status;

                hr = HrGetStatus(&status);
                if (SUCCEEDED(hr) &&
                    ((NCS_CONNECTING    != status) &&
                     (NCS_CONNECTED     != status) &&
                     (NCS_DISCONNECTING != status)))
                {

                    // We do an impersonation here in case the connection has a RAS custom delete notification
                    // setup (CM connections do, for instance).  This allows the RasCustomDeleteEntryNotify
                    // function to interact with the system as the user.
                    //
                    HRESULT hrT = CoImpersonateClient ();
                    TraceError ("HrRemoveCmProfile -- CoImpersonateClient", hrT);

                    // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
                    if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
                    {
                        //  Delete the RAS entry, note that for branded connections, RAS
                        //  will call RasCustomDeleteEntryNotify after deletion.
                        //
                        DWORD dwErr = RasDeleteEntry (PszwPbkFile (), PszwEntryName ());

                        hr = HRESULT_FROM_WIN32 (dwErr);
                        TraceError ("RasDeleteEntry", hr);
                    }
                    
                    //  Revert to ourselves
                    //
                    if (SUCCEEDED(hrT))
                    {
                        CoRevertToSelf ();
                    }

                }
                else
                {
                    // Don't allow deletion unless disconnected
                    //
                    TraceTag (ttidWanCon, "Disallowing delete while in connected or"
                        "partially connected state");
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                hr = hrReason;
            }
        }
    }

    TraceError ("CDialupConnection::Delete", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Duplicate (
    PCWSTR              pszDuplicateName,
    INetConnection**    ppCon)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pszDuplicateName || !ppCon)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *ppCon = NULL;

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // Make sure the name is valid in the same phone book.
            //
            DWORD dwErr = RasValidateEntryName (
                            PszwPbkFile (), pszDuplicateName);

            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceError ("RasValidateEntryName", hr);

            if (SUCCEEDED(hr))
            {
                dwErr = DwCloneEntry (
                            PszwPbkFile(),
                            PszwEntryName(),
                            pszDuplicateName);

                hr = HRESULT_FROM_WIN32 (dwErr);
                TraceError ("DwCloneEntry", hr);

                if (SUCCEEDED(hr))
                {
                    hr = CreateInstanceFromPbkFileAndEntryName (
                            PszwPbkFile (),
                            pszDuplicateName,
                            IID_INetConnection, (VOID**)ppCon);
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = HrEnsureHNetPropertiesCached();
                    }
                    
                    if (SUCCEEDED(hr))
                    {
                        if (m_HNetProperties.fFirewalled || m_HNetProperties.fIcsPublic) // lazy eval the hnetcfg stuff
                        {
                            IHNetCfgMgr* pHomenetConfigManager;
                            hr = HrGetHNetCfgMgr(&pHomenetConfigManager);
                            if(SUCCEEDED(hr))
                            {
                                IHNetConnection* pNewHomenetConnection;
                                hr = pHomenetConfigManager->GetIHNetConnectionForINetConnection(*ppCon, &pNewHomenetConnection);
                                if(SUCCEEDED(hr))
                                {
                                    IHNetConnection* pHomenetConnection;
                                    hr = HrGetIHNetConnection(&pHomenetConnection);
                                    if(SUCCEEDED(hr))
                                    {
                                        // copy port bindings
                                        // REVIEW if somethings fails here to we need to nuke the new connection?
                                        IEnumHNetPortMappingBindings* pEnumPortMappingBindings;
                                        hr = pNewHomenetConnection->EnumPortMappings(FALSE, &pEnumPortMappingBindings);
                                        if(SUCCEEDED(hr))
                                        {
                                            ULONG ulFetched;
                                            IHNetPortMappingBinding* pNewPortMappingBinding;
                                            while(S_OK == pEnumPortMappingBindings->Next(1, &pNewPortMappingBinding, &ulFetched)) 
                                            {
                                                Assert(1 == ulFetched);
                                                IHNetPortMappingProtocol* pPortMappingProtocol;
                                                hr = pNewPortMappingBinding->GetProtocol(&pPortMappingProtocol);
                                                if(SUCCEEDED(hr))
                                                {
                                                    // find the original binding by using the protocol field
                                                    IHNetPortMappingBinding* pPortMappingBinding;
                                                    hr = pHomenetConnection->GetBindingForPortMappingProtocol(pPortMappingProtocol, &pPortMappingBinding);
                                                    if(SUCCEEDED(hr))
                                                    {
                                                        BOOLEAN bEnabled;
                                                        hr = pPortMappingBinding->GetEnabled(&bEnabled);
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            if(TRUE == bEnabled)
                                                            {
                                                                hr = pNewPortMappingBinding->SetEnabled(bEnabled);
                                                            }
                                                        }
                                                        
                                                        // always set the computer address
                                                        
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            ULONG ulAddress;
                                                            hr = pPortMappingBinding->GetTargetComputerAddress(&ulAddress);
                                                            if(SUCCEEDED(hr))
                                                            {
                                                                if(0 != ulAddress)
                                                                {
                                                                    hr = pNewPortMappingBinding->SetTargetComputerAddress(ulAddress);
                                                                }
                                                            }
                                                        }
                                                        
                                                        // only set the computer name if it is used
                                                        
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            BOOLEAN bUseName;
                                                            hr = pPortMappingBinding->GetCurrentMethod(&bUseName);
                                                            if(SUCCEEDED(hr) && TRUE == bUseName)
                                                            {
                                                                OLECHAR* pszTargetComputerName;
                                                                hr = pPortMappingBinding->GetTargetComputerName(&pszTargetComputerName);
                                                                if(SUCCEEDED(hr))
                                                                {
                                                                    if(L'\0' != *pszTargetComputerName)
                                                                    {
                                                                        hr = pNewPortMappingBinding->SetTargetComputerName(pszTargetComputerName);
                                                                    }
                                                                    CoTaskMemFree(pszTargetComputerName);
                                                                }
                                                            }
                                                        }
                                                        ReleaseObj(pPortMappingBinding);    
                                                    }
                                                    ReleaseObj(pPortMappingProtocol);
                                                }
                                                ReleaseObj(pNewPortMappingBinding);
                                            }
                                            ReleaseObj(pEnumPortMappingBindings);
                                        }
                                        
                                        if(m_HNetProperties.fFirewalled) // copy firewall yes/no and ICMP settings
                                        {
                                            IHNetFirewalledConnection* pFirewalledConnection;
                                            hr = pNewHomenetConnection->Firewall(&pFirewalledConnection);
                                            if(SUCCEEDED(hr))
                                            {
                                                HNET_FW_ICMP_SETTINGS* pICMPSettings;
                                                hr = pHomenetConnection->GetIcmpSettings(&pICMPSettings);
                                                if(SUCCEEDED(hr))
                                                {
                                                    hr = pNewHomenetConnection->SetIcmpSettings(pICMPSettings);
                                                    CoTaskMemFree(pICMPSettings);
                                                }
                                                ReleaseObj(pFirewalledConnection);
                                            }
                                        }
                                        ReleaseObj(pHomenetConnection);
                                    }
                                    ReleaseObj(pNewHomenetConnection);
                                }
                                ReleaseObj(pHomenetConfigManager);
                            }
                        }
                    }
                }
            }
        }
    }
    TraceError ("CDialupConnection::Duplicate", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetProperties (
    NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;
    HRESULT hrHiddenCM = S_OK;
    CMEntry cm;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            NETCON_PROPERTIES* pProps;
            hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                    reinterpret_cast<VOID**>(&pProps));
            if (SUCCEEDED(hr))
            {
                HRESULT hrT;

                ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

                // guidId
                //
                pProps->guidId = GuidId ();

                // pszwName
                //
                hrT = HrCoTaskMemAllocAndDupSz (
                            PszwEntryName(),
                            &pProps->pszwName);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                hrT = HrCoTaskMemAllocAndDupSz (
                            PszwDeviceName(),
                            &pProps->pszwDeviceName);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Status
                //
                hrT = HrGetStatus (&pProps->Status);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Verify that the status return is accurate. HrGetStatus returns NCS_DISCONNECTED
                // if the connectoid is NCS_CONNECTING, which is wrong!!!!.
                //
                if( pProps->Status == NCS_DISCONNECTED )
                {
                    // CMUtil remebers the Hidden connection (Connection Manager) and the status of
                    // any ras events (i.e. Connecting, Disconnecting etc). The Data is filled in 
                    // in function RasEventNotify.
                    //
                    hrHiddenCM = CCMUtil::Instance().HrGetEntry(pProps->guidId,cm);
                    if ( S_OK == hrHiddenCM )
                    {
                        // Use CCMUtil's status, its more accurate.
                        //
                        pProps->Status = cm.m_ncs;
                    }
                }

                // Check if this connection has a child connection
                //
               
                hrHiddenCM = CCMUtil::Instance().HrGetEntry(PszwEntryName(),cm);        
                if( hrHiddenCM == S_OK )
                {
                    // It has a child connectoid
                    // Now we have to determine which one describes the overall status of the connection
                    //
                    if( cm.m_ncs == NCS_CONNECTING || cm.m_ncs == NCS_DISCONNECTING ||
                        cm.m_ncs == NCS_CONNECTED)
                    {
                        if( pProps->Status == NCS_DISCONNECTING )
                        {
                            // This case happens if the parent is disconnecting
                            // The parent is disconnecting, so the child will be disconnecting.
                            // Change the status of the child to disconnecting so that we do not
                            // get confused later on when the child is connected at the parent is
                            // disconnected. i.e. are we overall connecting or disconnecting!!!!
                            //
                            CCMUtil::Instance().SetEntry(GuidId (), PszwEntryName(),pProps->Status);        
                        }
                        else
                        if( cm.m_ncs == NCS_CONNECTED && pProps->Status == NCS_DISCONNECTED )
                        {
                            // This case will only happen if the child is connected and the parent is still
                            // disconnected.
                            //
                            pProps->Status = NCS_CONNECTING;
                        }
                        else if (!IsEqualGUID(pProps->guidId, cm.m_guid))
                        {
                            TraceTag(ttidWanCon, "Overwriting parent connection status: %s with child status: %s", DbgNcs(pProps->Status), DbgNcs(cm.m_ncs));

                            // When in doubt and the GUID's are different (ie. not a BAP/Multilink connection) take the childs status =)
                            //
                            pProps->Status = cm.m_ncs;
                        }
                    }

                }


                // Type
                //
                pProps->MediaType = MediaType ();

                // dwCharacter
                //
                hrT = HrGetCharacteristics (&pProps->dwCharacter);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // clsidThisObject
                //
                pProps->clsidThisObject = CLSID_DialupConnection;

                // clsidUiObject
                //
                hrT = GetUiObjectClassId (&pProps->clsidUiObject);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Assign the output parameter or cleanup if we had any failures.
                //
                if (SUCCEEDED(hr))
                {
                    *ppProps = pProps;
                }
                else
                {
                    Assert (NULL == *ppProps);
                    FreeNetconProperties (pProps);
                }
            }
        }
    }
    TraceError ("CDialupConnection::GetProperties", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Rename (
    PCWSTR pszNewName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pszNewName)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrLockAndRenameEntry (pszNewName, this);
    }
    TraceError ("CDialupConnection::Rename", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetRasConnection
//
STDMETHODIMP
CDialupConnection::GetRasConnectionInfo (
    RASCON_INFO* pRasConInfo)
{
    HRESULT hr = HrGetRasConnectionInfo (pRasConInfo);

    TraceError ("CDialupConnection::GetRasConnectionInfo", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::SetRasConnectionInfo (
    const RASCON_INFO* pRasConInfo)
{
    HRESULT hr = HrSetRasConnectionInfo (pRasConInfo);

    TraceError ("CDialupConnection::SetRasConnectionInfo", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetRasConnectionHandle (
    ULONG_PTR* phRasConn)
{
    HRESULT hr = HrGetRasConnectionHandle (
                    reinterpret_cast<HRASCONN*>(phRasConn));

    TraceError ("CDialupConnection::GetRasConnectionHandle",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
// IPersistNetConnection
//
STDMETHODIMP
CDialupConnection::GetClassID (
    CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_DialupConnection;
    }
    TraceError ("CDialupConnection::GetClassID", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetSizeMax (
    ULONG*  pcbSize)
{
    HRESULT hr = HrPersistGetSizeMax (pcbSize);
    TraceError ("CDialupConnection::GetSizeMax", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Load (
    const BYTE* pbBuf,
    ULONG       cbSize)
{
    HRESULT hr = HrPersistLoad (pbBuf, cbSize);
    TraceError ("CDialupConnection::Load", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Save (
    BYTE*   pbBuf,
    ULONG   cbSize)
{
    HRESULT hr = HrPersistSave (pbBuf, cbSize);
    TraceError ("CDialupConnection::Save", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionBrandingInfo
//

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetBrandingIconPaths
//
//  Purpose:    Returns the full paths to three icons.
//
//  Arguments:  pConBrandInfo - pointer to an Icon branding structure
//
//  Returns:   S_OK or an error code
//
STDMETHODIMP
CDialupConnection::GetBrandingIconPaths(
    CON_BRANDING_INFO ** ppConBrandInfo)
{
    HRESULT hr = HrEnsureEntryPropertiesCached ();
    CON_BRANDING_INFO * pConBrandInfo   = NULL;

    Assert(ppConBrandInfo);

    if (SUCCEEDED(hr))
    {
        if (!FIsBranded ())
        {
            hr = E_NOTIMPL;
        }
        else
        {
            WCHAR szTemp[MAX_PATH+1];
            WCHAR szIconName[MAX_PATH+1];
            const WCHAR* const CMSECTION = L"Connection Manager";
            HICON hIcon;

            hr = HrCoTaskMemAlloc(sizeof(CON_BRANDING_INFO), (LPVOID*)&pConBrandInfo);
            if (SUCCEEDED(hr))
            {
                ZeroMemory(pConBrandInfo, sizeof(CON_BRANDING_INFO));

                // Get the path to the cms file to get the Icon entries from.
                //
                hr = HrEnsureCmStringsLoaded();

                if (SUCCEEDED(hr))
                {
                    //  Get the Large Icon path
                    //
                    if (0 != GetPrivateProfileStringW(CMSECTION, L"Icon", L"",
                                szIconName, celems(szIconName), PszwCmsFile ()))
                    {
                        lstrcpynW(szTemp, PszwCmDir (), celems(szTemp));
                        lstrcatW(szTemp, szIconName);

                        if (NULL != (hIcon = (HICON)LoadImage(NULL, szTemp, IMAGE_ICON, 32, 32, LR_LOADFROMFILE)))
                        {
                            DestroyIcon(hIcon);
                            hr = HrCoTaskMemAllocAndDupSz (szTemp, &(pConBrandInfo->szwLargeIconPath));
                        }
                    }

                    // See if the CM icon is hidden
                    WCHAR szHideTrayIcon[MAX_PATH+1];
                    DWORD dwHideTrayIcon = 1; // default is to hide the CM icon
                    if (SUCCEEDED(hr) &&
                        (0 != GetPrivateProfileStringW(CMSECTION, L"HideTrayIcon", L"1",
                                szHideTrayIcon, celems(szHideTrayIcon), PszwCmsFile ())))
                    {
                        dwHideTrayIcon = _ttoi(szHideTrayIcon);
                    }

                    if (dwHideTrayIcon) // If the CM icon is not hidden, we don't want another branded icon. We'll use blinky lights instead
                    {
                        //  Get the Tray Icon path
                        //
                        if (SUCCEEDED(hr) &&
                            (0 != GetPrivateProfileStringW(CMSECTION, L"TrayIcon", L"",
                                    szIconName, celems(szIconName), PszwCmsFile ())))
                        {
                            lstrcpynW(szTemp, PszwCmDir (), celems(szTemp));
                            lstrcatW(szTemp, szIconName);

                            if (NULL != (hIcon = (HICON)LoadImage(NULL, szTemp, IMAGE_ICON, 16, 16, LR_LOADFROMFILE)))
                            {
                                DestroyIcon(hIcon);
                                hr = HrCoTaskMemAllocAndDupSz (szTemp, &(pConBrandInfo->szwTrayIconPath));
                            }
                        }
                    }
                }
            }
        }
    }

    // Fill in the out param struct if we succeeded, otherwise leave it alone so it will still
    // marshall.
    //
    if (SUCCEEDED(hr))
    {
        *ppConBrandInfo = pConBrandInfo;
    }

    TraceError ("CDialupConnection::GetBrandingIconPaths", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetTrayMenuEntries
//
//  Purpose:    Returns any branded menu items to be added to the tray menu.
//
//  Arguments:  pMenuData -- Pointer to a Tray Menu Data struct
//
//  Returns:   S_OK or an error code
//
STDMETHODIMP
CDialupConnection::GetTrayMenuEntries(
    CON_TRAY_MENU_DATA** ppMenuData)
{
    // initialize output
    Assert(ppMenuData);
    *ppMenuData = NULL;

    CON_TRAY_MENU_DATA * pMenuData = NULL;
    HRESULT hr = HrEnsureEntryPropertiesCached ();

    if (SUCCEEDED(hr))
    {
        if (!FIsBranded ())
        {
            hr = E_NOTIMPL;
        }
        else
        {
            hr = HrEnsureCmStringsLoaded();
            if (SUCCEEDED(hr))
            {
                //
                //  Get the menu item section
                //
                WCHAR* pszMenuItemsSection = NULL;
                int nSize;

                hr = HrGetPrivateProfileSectionWithAlloc(&pszMenuItemsSection, &nSize);

                //  Process the menu items
                //
                if (SUCCEEDED(hr) && (nSize>0))
                {
                    //  We have menu items to process.  First make a copy of the data
                    //  and figure out a line count.
                    //
                    hr = HrCoTaskMemAlloc(sizeof(CON_TRAY_MENU_DATA), (LPVOID*)&pMenuData);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwCount = 0;
                        WCHAR*pszLine = NULL;
                        WCHAR szName[MAX_PATH+1];
                        WCHAR szCmdLine[MAX_PATH+1];
                        WCHAR szParams[MAX_PATH+1];

                        pszLine = pszMenuItemsSection;

                        while ((NULL != pszLine) && (0 != *pszLine))
                        {
                            if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine, szName,
                                    szCmdLine, szParams)))
                            {
                                dwCount++;
                            }
                            pszLine = pszLine + lstrlenW(pszLine) + 1;
                        }

                        ASSERT(0 != dwCount);

                        // Now that we have an accurate count, lets
                        // allocate the memory for the marshalling and
                        // reparse the items.
                        //
                        hr = HrCoTaskMemAlloc(dwCount*sizeof(CON_TRAY_MENU_ENTRY),
                                              (LPVOID*)&pMenuData->pctme);

                        if (SUCCEEDED(hr))
                        {
                            pMenuData->dwCount = dwCount;

                            DWORD dwNumAdded = 0;
                            pszLine = pszMenuItemsSection;
                            while ((NULL != pszLine) && (0 != *pszLine) && SUCCEEDED(hr))
                            {
                                if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine,
                                    szName, szCmdLine, szParams)) && (dwNumAdded <= dwCount))
                                {
                                    hr = HrFillInConTrayMenuEntry(szName, szCmdLine, szParams,
                                        &(pMenuData->pctme[dwNumAdded]));

                                    if (FAILED(hr))
                                    {
                                        CoTaskMemFree(&pMenuData->pctme);
                                    }

                                    dwNumAdded++;
                                }
                                pszLine = pszLine + lstrlenW(pszLine) + 1;
                            }
                        }
                        else
                        {
                            delete pMenuData;
                        }
                    }
                    delete (pszMenuItemsSection);
                }
            }
        }
    }

    // Fill in the out param struct if we succeeded, otherwise leave it alone so it will still
    // marshall.
    //
    if (SUCCEEDED(hr))
    {
        *ppMenuData = pMenuData;
    }

    TraceError ("CDialupConnection::GetTrayMenuEntries", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetPrivateProfileSectionWithAlloc
//
//  Purpose:    This function ensures that the CM specific member vars for dialup
//              are loaded and usable by CM specific functions.
//
//  Arguments: none
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetPrivateProfileSectionWithAlloc (
    WCHAR** pszSection,
    int*    pnSize)
{

    Assert(pszSection);
    Assert(pnSize);

    HRESULT hr = HrEnsureCmStringsLoaded();

    if (!pszSection)
    {
        return E_POINTER;
    }
    if (!pnSize)
    {
        return E_POINTER;
    }


    if (SUCCEEDED(hr))
    {
        const int c_64K= 64*1024;
        int nAllocated = 1024;
        *pnSize = nAllocated - 2;

        while ((nAllocated <= c_64K) && ((*pnSize) == (nAllocated - 2)))
        {
            //      Should never need more than the 4-5 lines we already allocated
            //      but someone might want lots of menu options.
            //
            if (NULL != *pszSection)
            {
                delete (*pszSection);
            }

            *pszSection = new WCHAR[nAllocated];

            if (*pszSection)
            {
                *pnSize = GetPrivateProfileSectionW(L"Menu Options",
                            *pszSection, nAllocated,
                            PszwCmsFile ());
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            nAllocated = 2*nAllocated;
        }

        if (nAllocated > c_64K)
        {
            hr = E_UNEXPECTED;
        }
        if (nAllocated > c_64K || 0 == *pnSize)
        {
            // We need to free this in both cases, because if the size is 0, then the callers don't free this.
            delete *pszSection;
        }
    }

    TraceError ("CDialupConnection::HrGetPrivateProfileSectionWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetMenuNameAndCmdLine
//
//  Purpose:    Given a menu item line from a CMS file parses out the Menu item name,
//                              Menu executable, and Menu item parameters.
//
//  Arguments:  pMenuData -- Pointer to a Tray Menu Data struct
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetMenuNameAndCmdLine(
    PWSTR pszString,
    PWSTR szName,
    PWSTR szProgram,
    PWSTR szParams)
{
    WCHAR*      pszPtr1;
    WCHAR*      pszPtr2;
    WCHAR       szLine[MAX_PATH+1];
    BOOL fLong = FALSE;
    HRESULT hr;

    Assert(NULL != pszString);
    Assert(NULL != szName);
    Assert(NULL != szProgram);
    Assert(NULL != szParams);

    ZeroMemory(szName, celems(szName));
    ZeroMemory(szProgram, celems(szProgram));
    ZeroMemory(szParams, celems(szParams));

    lstrcpynW(szLine, pszString, celems(szLine));

    // Process the first portion, the "Name=" part
    //
    pszPtr1 = wcsstr(szLine, L"=");

    if (pszPtr1)
    {
        *pszPtr1 = 0;
        lstrcpynW(szName, szLine, MAX_PATH);

        // Process next portion, the program name
        //
        pszPtr1++;

        if (pszPtr1)
        {
            // Look for "+" or " " marking end of program portion
            //
            if (*pszPtr1 == L'+')
            {
                pszPtr1++;
                pszPtr2 = wcsstr(pszPtr1, L"+");
                fLong = TRUE;
            }
            else
            {
                // If not a long filename then we have two choices,
                // either a short program name and params or just a
                // short program name.
                //
                pszPtr2 = wcsstr(pszPtr1, L" ");
                fLong = FALSE;
            }

            // Terminate program name and copy
            //
            if (pszPtr2)
            {
                if (*pszPtr2 != 0)
                {
                    *pszPtr2 = 0;
                    pszPtr2++;
                }

                lstrcpynW(szProgram, pszPtr1, MAX_PATH);

                // Process final portion, the params
                //
                if (fLong)
                {
                    pszPtr2++; // skip blank
                }

                // Now we are have the param string
                //
                if (pszPtr2)
                {
                    lstrcpynW(szParams, pszPtr2, MAX_PATH);
                }
            }
            else
            {
                // Just a program with no params and no space seperator
                // (this happens on memphis)
                //
                lstrcpynW(szProgram, pszPtr1, MAX_PATH);
            }
        }
        hr = S_OK;
    }
    else
    {
        //  No entries
        //
        hr =  E_UNEXPECTED;
    }

    TraceError ("CDialupConnection::HrGetMenuNameAndCmdLine", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrFillInConTrayMenuEntry
//
//  Purpose:    Given the elements of a ConTrayMenuEntry struct, the function
//              allocs the memory necessary and copies of the given elements.
//
//  Arguments:  szwName - Display name of the command to show in the tray context menu
//              szwCmdLine - actual command to run for this menu entry
//              szwParams - command params for this command
//              pMenuEntry - pointer to the struct to fill in and execute
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrFillInConTrayMenuEntry (
    PCWSTR szName,
    PCWSTR szCmdLine,
    PCWSTR szParams,
    CON_TRAY_MENU_ENTRY* pMenuEntry)
{
    HRESULT hr;
    ZeroMemory(pMenuEntry, sizeof(CON_TRAY_MENU_ENTRY));

    hr = HrCoTaskMemAlloc ((lstrlenW(szName)+1)*sizeof(WCHAR),
                               (LPVOID*)&(pMenuEntry->szwMenuText));
    if (SUCCEEDED(hr))
    {
        lstrcpyW(pMenuEntry->szwMenuText, szName);
        hr = HrCoTaskMemAlloc ((lstrlenW(szParams)+1)*sizeof(WCHAR),
                                                   (LPVOID*)&(pMenuEntry->szwMenuParams));
        if (S_OK == hr)
        {
            lstrcpyW(pMenuEntry->szwMenuParams, szParams);
            if (0 == wcsncmp(PszwShortServiceName (), szCmdLine,
                    lstrlenW(PszwShortServiceName ())))
            {
                //
                //      Then we have an included file.  Add the profile dir path
                //
                // Take out the "short service name" because it's already included in the path
                PCWSTR pszFileName = szCmdLine + lstrlenW(PszwShortServiceName()) + 1;
                hr = HrCoTaskMemAlloc ((lstrlenW(pszFileName)+lstrlenW(PszwProfileDir())+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, PszwProfileDir ());
                    lstrcatW(pMenuEntry->szwMenuCmdLine, pszFileName);
                }
            }
            else
            {
                hr = HrCoTaskMemAlloc ((lstrlenW(szCmdLine)+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, szCmdLine);
                }
            }
        }
    }
    if (FAILED(hr))
    {
        //
        //      We Failed so free the memory
        //
        CoTaskMemFree(pMenuEntry->szwMenuText);
        CoTaskMemFree(pMenuEntry->szwMenuCmdLine);
        CoTaskMemFree(pMenuEntry->szwMenuParams);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetCmpFileLocation
//
//  Purpose:    Compares the phonebook file path to path of the current user's
//              application data dir.  If the initial paths are the same we have
//              a private profile.  Please NOTE that calling this function
//              requires the calling client to properly setup CoSetProxyBlanket for
//              a private user profile (matches the call to CoImpersonateClient)
//
//  Arguments:  szwPhonebook -- path to the phonebook the CM connectoid lives in
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetCmpFileLocation(
    PCWSTR szPhonebook,
    PCWSTR szEntryName,
    PWSTR  szCmpFilePath)
{
    DWORD dwSize = MAX_PATH;
    HKEY hKey;
    HANDLE hBaseKey = NULL;
    HANDLE hFile;
    HRESULT hr;
    HRESULT hrImpersonate = E_FAIL;
    static const WCHAR c_mappingsRegKey[] = L"Software\\Microsoft\\Connection Manager\\Mappings";
    HANDLE hImpersonationToken = NULL;   // The token of the thread
    HANDLE hPrimaryToken = NULL;         // The primary token for the new process

    if ((NULL == szCmpFilePath) || (NULL == szPhonebook))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();

        if (SUCCEEDED(hr))
        {
            if (m_fForAllUsers)
            {
                //  We have an all users key so get the information from HKLM
                //
                hBaseKey = HKEY_LOCAL_MACHINE;
            }
            else
            {
                //  Then we have a private profile.  Since netman runs as a system account,
                //  we must impersonate the client and then make an RTL call to get
                //  the current users HKCU hive before querying the registry for the
                //  cmp path.  We also need to get the user token so that we can expand the
                //  cmp string in the single user case.
                //

                hrImpersonate = CoImpersonateClient ();
                TraceError ("HrGetCmpFileLocation -- CoImpersonateClient", hr);

                if (SUCCEEDED(hrImpersonate))
                {
                    NTSTATUS ntstat = RtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hBaseKey);
                    hr = HRESULT_FROM_NT(ntstat);
                    TraceError ("RtlOpenCurrentUser", hr);

                    if (SUCCEEDED(hr))
                    {
                        // Create a primary token
                        //
                        if (!OpenThreadToken(
                                GetCurrentThread(),
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                TRUE,
                                &hImpersonationToken))
                        {
                            hr = HrFromLastWin32Error();
                            TraceError ("HrGetCmpFileLocation -- OpenThreadToken", hr);
                        }
                        else
                        {
                            if(!DuplicateTokenEx(hImpersonationToken,
                                TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &hPrimaryToken
                                ))
                            {
                                hr = HrFromLastWin32Error();
                                TraceError ("HrGetCmpFileLocation -- DuplicateTokenEx", hr);
                            }
                        }
                    }
                }
            }

            //  Now Open the mappings key and get the cmp file path
            //
            if (SUCCEEDED(hr))
            {
                hr = HrRegOpenKeyEx((HKEY)hBaseKey,
                                    c_mappingsRegKey,
                                    KEY_READ, &hKey);

                if (SUCCEEDED(hr))
                {
                    dwSize = MAX_PATH;
                    WCHAR szTemp[MAX_PATH+1];
                    hr = HrRegQuerySzBuffer(hKey, szEntryName, szTemp, &dwSize);

                    if (SUCCEEDED (hr))
                    {
                        //  Check to see if the file exists
                        //
                        if (!m_fForAllUsers)
                        {
                            ExpandEnvironmentStringsForUserW(hPrimaryToken, szTemp,
                                szCmpFilePath, MAX_PATH);
                        }
                        else
                        {
                            lstrcpyW(szCmpFilePath, szTemp);
                        }

                        hFile = CreateFile(szCmpFilePath, GENERIC_READ, FILE_SHARE_READ,
                                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        else
                        {
                            CloseHandle(hFile);
                            hr = S_OK;
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }

        if (!m_fForAllUsers)
        {
            if (hImpersonationToken)
            {
                CloseHandle(hImpersonationToken);
            }

            if (hPrimaryToken)
            {
                CloseHandle(hPrimaryToken);
            }

            // Close the handle opened by RtlOpenCurrentUser
            //
            NtClose(hBaseKey);

        }
        if (SUCCEEDED(hrImpersonate))
        {
            hr = CoRevertToSelf ();
            TraceError ("HrGetCmpFileLocation -- CoRevertToSelf", hr);
        }        
    }

    TraceError ("CDialupConnection::HrGetCmpFileLocation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrEnsureCmStringsLoaded
//
//  Purpose:    This function ensures that the CM specific member vars for dialup
//              are loaded and usable by CM specific functions.  Please NOTE that
//              calling EnsureCmStringsAreLoaded requires the calling client to
//              properly setup CoSetProxyBlanket for a private user profile.
//
//  Arguments: none
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrEnsureCmStringsLoaded()
{
    HRESULT hr = S_OK;

    if (!m_fCmPathsLoaded)
    {
        WCHAR szwCmpFile[MAX_PATH];
        WCHAR szwCmsFile[MAX_PATH];
        WCHAR szwDrive[MAX_PATH];
        WCHAR szwDir[MAX_PATH];
        WCHAR szwFileName[MAX_PATH];
        WCHAR szwExtension[MAX_PATH];
        WCHAR szwProfileDir[MAX_PATH];
        WCHAR szwCmDir[MAX_PATH];

        int nNumChars;

        hr = HrGetCmpFileLocation(PszwPbkFile (), PszwEntryName (), szwCmpFile);

        if (SUCCEEDED(hr))
        {
            //  Now split the path
            //
            _wsplitpath(szwCmpFile, szwDrive, szwDir, szwFileName, szwExtension);

            //  Now construct the path to the cms file
            //
            nNumChars = wsprintfW(szwCmsFile, L"%s%s%s\\%s%s", szwDrive, szwDir, szwFileName, szwFileName, L".cms");
            ASSERT(nNumChars < celems(szwCmsFile));

            //  Now construct the profile dir path
            //
            nNumChars = wsprintfW(szwProfileDir, L"%s%s%s\\", szwDrive, szwDir, szwFileName);
            ASSERT(nNumChars < celems(szwProfileDir));

            //  Now construct the CM dir path
            //
            nNumChars = wsprintfW(szwCmDir, L"%s%s", szwDrive, szwDir);
            ASSERT(nNumChars < celems(szwCmDir));

            //  Now transfer to the member variables
            //
            m_strCmsFile = szwCmsFile;
            m_strProfileDir = szwProfileDir;    // remember this already has the trailing slash
            m_strCmDir = szwCmDir;              // remember this already has the trailing slash
            m_strShortServiceName = szwFileName;
            m_fCmPathsLoaded = TRUE;
        }
    }

    TraceError ("CDialupConnection::HrEnsureCmStringsLoaded", hr);
    return hr;
}

// INetDefaultConnection

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::SetDefault
//
//  Purpose:    Set the default RAS connection
//
//  Arguments:  TRUE to set as default connection. FALSE to unset it
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::SetDefault(BOOL bDefault)
{
    HRESULT hr = S_OK;
    HRESULT hrT = S_OK;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            RASAUTODIALENTRY adEntry;
            ZeroMemory(&adEntry, sizeof(adEntry));
            
            adEntry.dwSize = sizeof(adEntry);
            if (bDefault)
            {
                wcsncpy(adEntry.szEntry, PszwEntryName(), sizeof(adEntry.szEntry) / sizeof(TCHAR));
            }

            hrT = CoImpersonateClient();
            if (SUCCEEDED(hrT))
            {
                DWORD dwErr = RasSetAutodialAddress(
                                NULL,
                                NULL,
                                &adEntry,
                                sizeof(adEntry),
                                1);

                if (dwErr != NO_ERROR)
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
                hrT = CoRevertToSelf();
            }
        }
    }
    TraceError ("CDialupConnection::SetDefault", hr);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetDefault
//
//  Purpose:    Get the default RAS connection
//
//  Arguments:  pbDefault - Is this the default connection
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::GetDefault (BOOL* pbDefault)
{
    HRESULT hr = S_OK;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            if (m_dwFlagsPriv & REED_F_Default)
            {
                *pbDefault = TRUE;
            }
            else
            {
                *pbDefault = FALSE;
            }
        }
    }

    TraceError ("CDialupConnection::GetDefault", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetDefault
//
//  Purpose:    Get the default RAS connection
//
//  Arguments:  pbDefault - Is this the default connection
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::GetPropertiesEx(NETCON_PROPERTIES_EX** ppConnectionPropertiesEx)
{
    HRESULT hr = S_OK;

    *ppConnectionPropertiesEx = NULL;
    
    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProps;
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

        if (pPropsEx)
        {
        
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));

            hr = GetProperties(&pProps);
        
            if (SUCCEEDED(hr))
            {
                hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, dynamic_cast<IPersistNetConnection *>(this));
                if (SUCCEEDED(hr))
                {
                    pPropsEx->bstrPhoneOrHostAddress = SysAllocString(m_strPhoneNumber.c_str());
                    *ppConnectionPropertiesEx = pPropsEx;
                }
                FreeNetconProperties(pProps);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    TraceError ("CDialupConnection::GetPropertiesEx", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\inbound.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       I N B O U N D . C P P
//
//  Contents:   Implements the inbound connection object.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "inbound.h"
#include "nccom.h"
#include "ncnetcon.h"
#include "..\conman\conman.h"

LONG g_CountIncomingConnectionObjects;

static const CLSID CLSID_InboundConnectionUi =
    {0x7007ACC3,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

extern const GUID GUID_InboundConfigConnectionId =
{ /* 89150b9f-9b5c-11d1-a91f-00805fc1270e */
    0x89150b9f,
    0x9b5c,
    0x11d1,
    {0xa9, 0x1f, 0x00, 0x80, 0x5f, 0xc1, 0x27, 0x0e}
};


//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnection::CreateInstance
//
//  Purpose:    Creates an inbound connection object.
//
//  Arguments:
//      fIsConfigConnection [in]
//      hRasSrvConn         [in]
//      pszwName            [in]
//      pguidId             [in]
//      riid                [in]
//      ppv                 [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnection::CreateInstance (
    BOOL        fIsConfigConnection,
    HRASSRVCONN hRasSrvConn,
    PCWSTR     pszwName,
    PCWSTR     pszwDeviceName,
    DWORD       dwType,
    const GUID* pguidId,
    REFIID      riid,
    void**      ppv)
{
    Assert (FIff(fIsConfigConnection, !hRasSrvConn));
    Assert (pguidId);

    HRESULT hr = E_OUTOFMEMORY;

    CInboundConnection* pObj;
    pObj = new CComObject <CInboundConnection>;
    if (pObj)
    {
        if (fIsConfigConnection)
        {
            // No need to start the service (FALSE) since we're being
            // created as a result of the service running.
            //
            pObj->InitializeAsConfigConnection (FALSE);
        }
        else
        {
            // Initialize our members.
            //
            pObj->m_fIsConfigConnection = FALSE;
            pObj->m_hRasSrvConn = hRasSrvConn;
            pObj->SetName (pszwName);
            pObj->SetDeviceName (pszwDeviceName);

            switch (dwType)
            {
                case RASSRVUI_MODEM:
                    pObj->m_MediaType = NCM_PHONE;
                    break;
                case RASSRVUI_VPN:
                    pObj->m_MediaType = NCM_TUNNEL;
                    break;
                case RASSRVUI_DCC:
                    pObj->m_MediaType = NCM_DIRECT;
                    break;
                default:
                    pObj->m_MediaType = NCM_PHONE;
                    break;
            }

            pObj->m_guidId = *pguidId;

            // We are now a full-fledged object.
            //
            pObj->m_fInitialized = TRUE;
        }

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            INetConnection* pCon = static_cast<INetConnection*>(pObj);
            hr = pCon->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    TraceError ("CInboundConnection::CreateInstance", hr);
    return hr;
}

CInboundConnection::CInboundConnection()
{
    InterlockedIncrement (&g_CountIncomingConnectionObjects);

    m_fIsConfigConnection   = FALSE;
    m_hRasSrvConn           = NULL;
    m_MediaType             = NCM_NONE;
    m_fInitialized          = FALSE;
}

CInboundConnection::~CInboundConnection()
{
    InterlockedDecrement (&g_CountIncomingConnectionObjects);
}

HRESULT
CInboundConnection::GetCharacteristics (
    DWORD*    pdwFlags)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pdwFlags)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pdwFlags = NCCF_INCOMING_ONLY | NCCF_ALL_USERS;

        // For the configuration connection, we only allow removal.
        // Don't query for NCCF_SHOW_ICON (below) because this connection
        // never get's connected.
        //
        if (m_fIsConfigConnection)
        {
            *pdwFlags |= NCCF_ALLOW_REMOVAL;
        }
        else
        {
            BOOL fShowIcon;
            DWORD dwErr = RasSrvQueryShowIcon (&fShowIcon);

            TraceError ("RasSrvQueryShowIcon", HRESULT_FROM_WIN32(dwErr));

            if ((ERROR_SUCCESS == dwErr) && fShowIcon)
            {
                *pdwFlags |= NCCF_SHOW_ICON;
            }
        }
    }
    TraceError ("CInboundConnection::GetCharacteristics", hr);
    return hr;
}

HRESULT
CInboundConnection::GetStatus (
    NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    HRESULT hr = S_OK;

    // Initialize the output parameter.
    //
    *pStatus = NCS_DISCONNECTED;

    if (!m_fIsConfigConnection)
    {
        BOOL fConnected;
        DWORD dwErr = RasSrvIsConnectionConnected (m_hRasSrvConn,
                            &fConnected);

        TraceError ("RasSrvIsConnectionConnected",
            HRESULT_FROM_WIN32(dwErr));

        if ((ERROR_SUCCESS == dwErr) && fConnected)
        {
            *pStatus = NCS_CONNECTED;
        }
    }
    TraceError ("CInboundConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnection
//

STDMETHODIMP
CInboundConnection::Connect ()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CInboundConnection::Disconnect ()
{
    HRESULT hr;

    // We don't expect to be called on Disconnect if we are the
    // configuration connection object.  Why?  Because this object never
    // reports itself as connected through GetStatus.
    //
    if (!m_fInitialized || m_fIsConfigConnection)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        DWORD dwErr = RasSrvHangupConnection (m_hRasSrvConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        TraceError ("RasSrvHangupConnection", hr);

        // Disconnect means this object is no longer valid.
        // Indicate so by uniniatializing ourselves (so subsequent
        // method calls will fail) and returning S_OBJECT_NO_LONGER_VALID.
        //
        m_fInitialized = FALSE;
        hr = S_OBJECT_NO_LONGER_VALID;
    }
    TraceError ("CInboundConnection::Disconnect",
        (S_OBJECT_NO_LONGER_VALID == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Delete ()
{
    HRESULT hr;

    // We don't expect to be called on Remove if we are not the
    // configuration connection object.  Why?  Because connected objects never
    // report themselves as removeable through GetCharacteristics.
    //
    if (!m_fInitialized || !m_fIsConfigConnection)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        DWORD dwErr = RasSrvCleanupService ();
        hr = HRESULT_FROM_WIN32 (dwErr);

        TraceError ("RasSrvCleanupService", hr);
    }
    TraceError ("CInboundConnection::Delete", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Duplicate (
    PCWSTR             pszwDuplicateName,
    INetConnection**    ppCon)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CInboundConnection::GetProperties (
    NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            pProps->guidId = m_guidId;

            // pszwName
            //
            hrT = HrCoTaskMemAllocAndDupSz (PszwName(),
                            &pProps->pszwName);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            if (!m_fIsConfigConnection)
            {
                hrT = HrCoTaskMemAllocAndDupSz (PszwDeviceName(),
                                &pProps->pszwDeviceName);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // MediaType
            //
            pProps->MediaType = m_MediaType;

            // dwCharacter
            //
            hrT = GetCharacteristics (&pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_InboundConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_InboundConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CInboundConnection::GetProperties", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::GetUiObjectClassId (
    CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pclsid = CLSID_InboundConnectionUi;
    }
    TraceError ("CInboundConnection::GetUiObjectClassId", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Rename (
    PCWSTR pszwNewName)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// INetInboundConnection
//
STDMETHODIMP
CInboundConnection::GetServerConnectionHandle (
    ULONG_PTR*  phRasSrvConn)
{
    HRESULT hr = S_OK;

    // If this is the configuration connection, the server connection
    // handle better be zero.  This is used by the UI object so that it
    // knows it is the configuration connection.
    //
    Assert (FIff (m_fIsConfigConnection, !m_hRasSrvConn));

    // Because MIDL doesn't know about HRASSRVCONN's, just make sure
    // it is the same size as the ULONG_PTR we pass it as.
    //
    Assert (sizeof (m_hRasSrvConn) == sizeof (*phRasSrvConn));

    *phRasSrvConn = reinterpret_cast<ULONG_PTR>(m_hRasSrvConn);

    TraceError ("CInboundConnection::GetServerConnectionHandle", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::InitializeAsConfigConnection (
    BOOL fStartRemoteAccess)
{
    Assert (!m_fInitialized);

    // Initialize our members.
    //
    m_fIsConfigConnection = TRUE;
    m_hRasSrvConn = 0;
    SetName (SzLoadIds (IDS_INBOUND_CONFIG_CONNECTION_NAME));
    SetDeviceName (NULL);
    m_MediaType = NCM_NONE;
    m_guidId = GUID_InboundConfigConnectionId;

    // We are now a full-fledged object.
    //
    m_fInitialized = TRUE;

    // Start the service if we were told.
    //
    HRESULT hr = S_OK;
    if (fStartRemoteAccess)
    {
        DWORD dwErr = RasSrvInitializeService ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasSrvInitializeService", hr);
    }
    TraceError ("CInboundConnection::InitializeAsConfigConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//
STDMETHODIMP
CInboundConnection::GetClassID (
    CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_InboundConnection;
    }
    TraceError ("CInboundConnection::GetClassID", hr);
    return hr;
}


static const WCHAR c_chwLead  = 0x19;
static const WCHAR c_chwTrail = 0x07;

STDMETHODIMP
CInboundConnection::GetSizeMax (
    ULONG*  pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Size the buffer for the following form:
        //  +--------------------------------------------------------------+
        //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
        //  +--------------------------------------------------------------+
        //
        // m_strDeviceName may be empty, in which case we want to still
        // store the null-terminator.  Don't use PszwDeviceName() as it
        // returns NULL when m_strDeviceName is empty.
        //
        *pcbSize = sizeof (c_chwLead) +
                   sizeof (m_fIsConfigConnection) +
                   sizeof (m_hRasSrvConn) +
                   CbOfSzAndTerm (PszwName()) +
                   CbOfSzAndTerm (m_strDeviceName.c_str()) +
                   sizeof (m_MediaType) +
                   sizeof (m_guidId) +
                   sizeof (c_chwTrail);
    }
    TraceError ("CInboundConnection::GetSizeMax", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Load (
    const BYTE* pbBuf,
    ULONG       cbSize)
{
    // The theoretical minimum size for the buffer.  Computed
    // as the number of bytes in the following minimum string:
    //
    const ULONG c_cbSizeMin = sizeof (c_chwLead) +
                              sizeof (m_fIsConfigConnection) +
                              sizeof (m_hRasSrvConn) +
                              4 +   // 4 bytes for 1 UNICODE char and NULL
                              2 +   // 1 UNICODE NULL for empty device name
                              sizeof (m_MediaType) +
                              sizeof (m_guidId) +
                              sizeof (c_chwTrail);

    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize < c_cbSizeMin)
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // The buffer *should* look like this:
        //  +--------------------------------------------------------------+
        //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
        //  +--------------------------------------------------------------+
        //
        const WCHAR*            pchw;
        const WCHAR*            pchwMax;
        const BOOL*             pfIsConfigConnection;
        BOOL                    fIsConfigConnection;
        const HRASSRVCONN*      phRasSrvCon;
        HRASSRVCONN             hRasSrvConn;
        PCWSTR                  pszwName;
        PCWSTR                  pszwDeviceName;
        const NETCON_MEDIATYPE* pMediaType;
        const GUID*             pguidTemp;
        const GUID*             pguidId;
        NETCON_MEDIATYPE        MediaType;

        pchw = reinterpret_cast<const WCHAR*>(pbBuf);

        // The last valid pointer for the embedded strings.
        //
        pchwMax = reinterpret_cast<const WCHAR*>(pbBuf + cbSize
                       - (sizeof (m_MediaType) +
                          sizeof (m_guidId) +
                          sizeof (c_chwTrail)));

        // Check our lead byte.
        //
        if (c_chwLead != *pchw)
        {
            goto finished;
        }
        pchw++;

        // Get m_fIsConfigConnection.
        //
        pfIsConfigConnection = reinterpret_cast<const BOOL*>(pchw);
        CopyMemory(&fIsConfigConnection, pfIsConfigConnection, sizeof(fIsConfigConnection));
        pfIsConfigConnection++;

        // Get m_hRasSrvConn.
        //
        phRasSrvCon = reinterpret_cast<const HRASSRVCONN*>(pfIsConfigConnection);
        CopyMemory(&hRasSrvConn, phRasSrvCon, sizeof(hRasSrvConn));
        phRasSrvCon++;

        // Get m_strName.  Search for the terminating null and make sure
        // we find it before the end of the buffer.  Using lstrlen to skip
        // the string can result in an AV in the event the string is not
        // actually null-terminated.
        //
        pchw = reinterpret_cast<const WCHAR*>(phRasSrvCon);

        for (pszwName = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_strDeviceName.  Search for the terminating null and make
        // sure we find it before the end of the buffer.
        //
        for (pszwDeviceName = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_MediaType.
        //
        pMediaType = reinterpret_cast<const NETCON_MEDIATYPE*>(pchw);
        CopyMemory(&MediaType, pMediaType, sizeof(MediaType));
        pMediaType++;

        // Get m_guidId.
        //
        pguidTemp = reinterpret_cast<const GUID*>(pMediaType);
        pguidId = pguidTemp;
        pguidTemp++;

        // Check our trail byte.
        //
        pchw = reinterpret_cast<const WCHAR*>(pguidTemp);
        if (c_chwTrail != *pchw)
        {
            goto finished;
        }

        // If we're the configuration object, we can't have a connection
        // HANDLE and vice-versa.
        //
        if ((fIsConfigConnection && hRasSrvConn) ||
            (!fIsConfigConnection && !hRasSrvConn))
        {
            goto finished;
        }

        // We are now a full-fledged object.
        //
        m_fIsConfigConnection = fIsConfigConnection;
        m_hRasSrvConn = hRasSrvConn;
        SetName (pszwName);
        SetDeviceName (pszwDeviceName);
        m_MediaType = MediaType;
        CopyMemory(&m_guidId, pguidId, sizeof(m_guidId));
        m_fInitialized = TRUE;
        hr = S_OK;

    finished:
            ;
    }
    TraceError ("CInboundConnection::Load", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Save (
    BYTE*   pbBuf,
    ULONG   cbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Make sure the user's buffer is big enough.
        //
        ULONG cbSizeRequired;
        SideAssert (SUCCEEDED(GetSizeMax(&cbSizeRequired)));

        if (cbSize < cbSizeRequired)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // Make the buffer look like this when we're done:
            //  +--------------------------------------------------------------+
            //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
            //  +--------------------------------------------------------------+
            //
            WCHAR* pchw = reinterpret_cast<WCHAR*>(pbBuf);

            // Put our lead byte.
            //
            *pchw = c_chwLead;
            pchw++;

            // Put m_fIsConfigConnection.
            //
            BOOL* pfIsConfigConnection =
                    reinterpret_cast<BOOL*>(pchw);
            CopyMemory(pfIsConfigConnection, &m_fIsConfigConnection, sizeof(m_fIsConfigConnection));
            pfIsConfigConnection++;

            // Put m_hRasSrvConn.
            //
            HRASSRVCONN* phRasSrvCon =
                    reinterpret_cast<HRASSRVCONN*>(pfIsConfigConnection);
            CopyMemory(phRasSrvCon, &m_hRasSrvConn, sizeof(m_hRasSrvConn));
            phRasSrvCon++;

            // Put m_strName.
            //
            pchw = reinterpret_cast<WCHAR*>(phRasSrvCon);
            lstrcpyW (pchw, PszwName());
            pchw += lstrlenW (PszwName()) + 1;

            // Put m_strDeviceName.
            //
            lstrcpyW (pchw, m_strDeviceName.c_str());
            pchw += m_strDeviceName.length() + 1;

            // Put m_MediaType.
            //
            NETCON_MEDIATYPE* pMediaType = reinterpret_cast<NETCON_MEDIATYPE*>(pchw);
            CopyMemory(pMediaType, &m_MediaType, sizeof(m_MediaType));
            pMediaType++;

            // Put m_guidId.
            //
            GUID* pguidId = reinterpret_cast<GUID*>(pMediaType);
            CopyMemory(pguidId, &m_guidId, sizeof(m_guidId));
            pguidId++;

            // Put our trail byte.
            //
            pchw = reinterpret_cast<WCHAR*>(pguidId);
            *pchw = c_chwTrail;
            pchw++;

            AssertSz (pbBuf + cbSizeRequired == (BYTE*)pchw,
                "pch isn't pointing where it should be.");
        }
    }
    TraceError ("CInboundConnection::Save", hr);
    return hr;
}

#define ID_DEVICE_DATABASE 1
#define ID_MISC_DATABASE 8

//+---------------------------------------------------------------------------
//
//  Function:   IconStateChanged
//
//  Purpose:    Fires an event to notify NetShell of a Change occuring in an
//              incoming connection.
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
HRESULT CInboundConnection::IconStateChanged()
{
    HRESULT hr = S_OK;

    IncomingEventNotify(REFRESH_ALL, NULL, NULL, NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\lan.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N . C P P
//
//  Contents:   Implementation of LAN connection objects
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include <ncreg.h>
#include <ncsetup.h>
#include "lan.h"
#include "lancmn.h"
#include "nccom.h"
#include "ncmisc.h"
#include "ncnetcon.h"
#include "sensapip.h"       // For SensNotifyNetconEvent
#include "ncstring.h"
#include "ncras.h"
#include "naming.h"
#include "wzcsvc.h"
#include "cobase.h"
#include "gpnla.h"
#include "ncperms.h"
#include "nmpolicy.h"

LONG g_CountLanConnectionObjects;

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

static const WCHAR c_szConnName[]       = L"Name";
static const WCHAR c_szShowIcon[]       = L"ShowIcon";
static const WCHAR c_szAutoConnect[]    = L"AutoConnect";

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueUpperRange[];
static const WCHAR c_chComma = L',';
extern const WCHAR c_szBiNdisAtm[];

static const DWORD c_cchMaxConnNameLen = 256;

static const CLSID CLSID_LanConnectionUi =
    {0x7007ACC5,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

typedef DWORD (APIENTRY *PFNSENSNOTIFY) (PSENS_NOTIFY_NETCON pEvent);

#define NETCFG_S_NOTEXIST 0x00000002

//
// CComObject overrides
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::CreateInstance
//
//  Purpose:    Static function to create an instance of a LAN connection
//              object
//
//  Arguments:
//      hdi   [in]      Device installer device info
//      deid  [in]      Device installer device info
//      riid  [in]      Initial interface to query for
//      ppv   [out]     Returns the new interface pointer
//
//  Returns:    S_OK if success, otherwise OLE or Win32 error code
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::CreateInstance(HDEVINFO hdi,
                                       const SP_DEVINFO_DATA &deid,
                                       PCWSTR pszPnpId,
                                       REFIID riid, LPVOID *ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CLanConnection * pObj;
    pObj = new CComObject<CLanConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_hkeyConn = NULL;
        pObj->m_hdi = hdi;
        pObj->m_deid = deid;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef();
        hr = pObj->FinalConstruct();
        pObj->InternalFinalConstructRelease();

        if (SUCCEEDED(hr))
        {
            hr = pObj->HrInitialize(pszPnpId);
            if (SUCCEEDED(hr))
            {
                hr = pObj->GetUnknown()->QueryInterface(riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    else
    {
        SetupDiDestroyDeviceInfoList(hdi);
    }

    TraceError("CLanConnection::CreateInstance", hr);
    return hr;
}

BOOL VerifyUniqueConnectionName(CIntelliName *pIntelliName, PCWSTR pszPotentialName, NETCON_MEDIATYPE *pncm, NETCON_SUBMEDIATYPE *pncms)
{
    HRESULT     hr = S_OK;
    DWORD       dwSuffix = 2;
    HKEY        hkey;
    BOOL        fDupFound = FALSE;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\"
                        L"Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}",
                        KEY_READ, &hkey);
    if (S_OK == hr)
    {
        FILETIME    ft;
        DWORD       dwIndex = 0;
        WCHAR       szKeyName[MAX_PATH];
        DWORD       cchName = celems(szKeyName);

        while (!fDupFound && (S_OK == (hr = HrRegEnumKeyEx(hkey, dwIndex, szKeyName,
                                            &cchName, NULL, NULL, &ft))) )
        {
            HKEY    hkeyConn;
            WCHAR   szSubKey[MAX_PATH];

            wsprintfW(szSubKey, L"%s\\Connection", szKeyName);

            hr = HrRegOpenKeyEx(hkey, szSubKey, KEY_READ, &hkeyConn);
            if (S_OK == hr)
            {
                tstring     strName;

                hr = HrRegQueryString(hkeyConn, c_szConnName, &strName);
                if (S_OK == hr)
                {
                    if (!lstrcmpiW(pszPotentialName, strName.c_str()))
                    {
                        fDupFound = TRUE;
                        
                        CLSID guidName;
                        if (SUCCEEDED(CLSIDFromString(szKeyName, &guidName)))
                        {
                            hr = pIntelliName->HrGetPseudoMediaTypes(guidName, pncm, pncms);
                            if (FAILED(hr))
                            {
                                *pncm  = NCM_LAN;
                                *pncms = NCSM_LAN;
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "This doesn't look like a GUID.");
                        }

                        break;
                    }
                    else
                    {
                        dwIndex++;
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // If value doesn't exist, that's ok. This is a new
                    // connection.
                    hr = S_OK;
                    dwIndex++;
                }

                RegCloseKey(hkeyConn);
            }
            else
            {
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // If key doesn't exist, that's ok. This is not a
                    // connection.
                    hr = S_OK;
                    dwIndex++;
                }
            }

            cchName = celems(szKeyName);
        }

        RegCloseKey(hkey);
    }
    return fDupFound;
}
//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrInitialize
//
//  Purpose:    Initializes the connection object for the first time.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:      This function is only called when the object is created for
//              the very first time and has no identity.
//
HRESULT CLanConnection::HrInitialize(
    PCWSTR pszPnpId)
{
    HRESULT     hr = S_OK;
    GUID        guid;

    AssertSz(m_hdi, "We should have a component at this point!");
    Assert(pszPnpId);

    hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
    if (S_OK == hr)
    {
        // Open the main connection key. If it doesn't exist, we'll create it
        // here.
        hr = HrOpenConnectionKey(&guid, NULL, KEY_READ_WRITE,
                                 OCCF_CREATE_IF_NOT_EXIST, pszPnpId,
                                 &m_hkeyConn);
        if (SUCCEEDED(hr))
        {
            tstring     strName;

            // First see if a name already exists for this connection
            hr = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
            if (FAILED(hr))
            {
                // no name?
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    //$ REVIEW (danielwe) 30 Oct 1997: If I can be assured
                    // that get_Name is never called before Rename, I
                    // don't need this function to be called.

                    // Note: (danielwe) 31 Oct 1997: This could result in
                    // duplicate names, but we cannot check for duplicates
                    // without recursing infinitely

                    // Set default connection name

                    CIntelliName IntelliName(_Module.GetResourceInstance(), VerifyUniqueConnectionName);

                    GUID gdDevice;
                    LPWSTR szNewName = NULL;
                    hr = HrGetInstanceGuid(m_hdi, m_deid, &gdDevice);
                    Assert(SUCCEEDED(hr));

                    if (SUCCEEDED(hr))
                    {
                        BOOL fNetworkBridge;
                        hr = HrIsConnectionNetworkBridge(&fNetworkBridge);

                        if (SUCCEEDED(hr) && fNetworkBridge)
                        {
                            hr = IntelliName.GenerateName(gdDevice, NCM_BRIDGE, 0, NULL, &szNewName);
                        }
                        else
                        {
                            hr = IntelliName.GenerateName(gdDevice, NCM_LAN, 0, NULL, &szNewName);
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = HrRegSetSz(m_hkeyConn, c_szConnName, szNewName);
                            CoTaskMemFree(szNewName);
                        }
                    }

                    Assert(SUCCEEDED(hr));
                }
            }
        }
    }


    if (SUCCEEDED(hr))
    {
        m_fInitialized = TRUE;
    }

    TraceError("CLanConnection::HrInitialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrOpenRegistryKeys
//
//  Purpose:    Opens the registry keys that this LAN connection object will
//              use
//
//  Arguments:
//      guid [in]   Guid of adapter that this connection uses
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   11 Nov 1997
//
//  Notes:      Keys are expected to exist and this will fail if either do
//              not
//
HRESULT CLanConnection::HrOpenRegistryKeys(const GUID &guid)
{
    HRESULT     hr = S_OK;

    AssertSz(!m_hkeyConn, "Don't call this more than once "
             "on the same connection object!");

    // This should only be called from HrLoad so these keys had better be
    // there.

    hr = HrOpenConnectionKey(&guid, NULL, KEY_READ_WRITE,
            OCCF_NONE, NULL, &m_hkeyConn);

    TraceError("CLanConnection::HrOpenRegistryKeys", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrLoad
//
//  Purpose:    Implements the bulk of IPersistNetConnection::Load.
//
//  Arguments:
//      guid [in]   GUID from which to receive identity
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
HRESULT CLanConnection::HrLoad(const GUID &guid)
{
    HRESULT             hr = S_OK;

    hr = HrLoadDevInfoFromGuid(guid);
    if (SUCCEEDED(hr))
    {
        hr = HrOpenRegistryKeys(guid);
        if (SUCCEEDED(hr))
        {
            // No need to call HrInitialize because this object should
            // already be created properly at a previous time

            m_fInitialized = TRUE;
        }
    }

    TraceError("CLanConnection::HrLoad", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::~CLanConnection
//
//  Purpose:    Called when the connection object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
CLanConnection::~CLanConnection()
{
    RegSafeCloseKey(m_hkeyConn);
    SetupDiDestroyDeviceInfoListSafe(m_hdi);
    InterlockedDecrement(&g_CountLanConnectionObjects);
    CoTaskMemFree(m_pHNetProperties);
}

//
// INetConnection
//


//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Rename
//
//  Purpose:    Changes the name of the connection
//
//  Arguments:
//      pszName [in]     New connection name (must be valid)
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Rename(PCWSTR pszName)
{
    HRESULT     hr = S_OK;

    if (!pszName)
    {
        hr = E_POINTER;
    }
    else if (!*pszName)
    {
        hr = E_INVALIDARG;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else if (!FIsValidConnectionName(pszName))
    {
        // Bad connection name
        hr = E_INVALIDARG;
    }
    else
    {
        AssertSz(m_hkeyConn, "Why don't I have a connection key?");

        // Get the current name for this connection
        tstring strName;
        hr = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
        if (S_OK == hr)
        {
            // Only do something if names are different
            if (lstrcmpiW(pszName, strName.c_str()))
            {
                hr = HrPutName(pszName);
            }
        }
    }

    TraceError("CLanConnection::Rename", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrPutName
//
//  Purpose:    Sets the connection name using the given name
//
//  Arguments:
//      pszName [in]    New name for connection
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   31 Oct 1997
//
//  Notes:      Doesn't check if name is already set to this
//
HRESULT CLanConnection::HrPutName(PCWSTR pszName)
{
    HRESULT     hr = S_OK;
    GUID        guid;

    // Get my device guid first
    hr = GetDeviceGuid(&guid);
    if (S_OK == hr)
    {
        hr = HrIsConnectionNameUnique(guid, pszName);
        if (S_OK == hr)
        {
            hr = HrRegSetSz(m_hkeyConn, c_szConnName, pszName);
            if (S_OK == hr)
            {
                LanEventNotify(CONNECTION_RENAMED, NULL, pszName, &guid);
            }
        }
        else if (S_FALSE == hr)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME);
        }
    }

    TraceErrorOptional("CLanConnection::HrPutName", hr,
                       (hr == HRESULT_FROM_WIN32(ERROR_DUP_NAME)));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::FIsMediaPresent
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if cable is plugged in, FALSE if not
//
//  Author:     danielwe   22 Sep 1998
//
//  Notes:      This function returns TRUE by default.
//
BOOL CLanConnection::FIsMediaPresent()
{
    BOOL    fRet = TRUE;
    GUID    guid;

    if (S_OK == GetDeviceGuid(&guid))
    {
        fRet = ::FIsMediaPresent(&guid);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetStatus
//
//  Purpose:    Returns the status of this LAN connection
//
//  Arguments:
//      pStatus [out]   Returns status value
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::GetStatus(NETCON_STATUS *pStatus)
{
    HRESULT hr;

    if (!pStatus)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID guid;

        hr = GetDeviceGuid(&guid);
        if (S_OK == hr)
        {
            hr = HrGetDevInstStatus(m_deid.DevInst, &guid, pStatus);
        }
    }

    TraceError("CLanConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetDeviceName
//
//  Purpose:    Returns the name of the device being used by this connection
//
//  Arguments:
//      ppszwDeviceName [out]   Receives device name
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:      Returned string must be freed with CoTaskMemFree.
//
HRESULT CLanConnection::GetDeviceName(PWSTR* ppszwDeviceName)
{
    Assert (ppszwDeviceName);
    Assert(m_hdi);

    // Initialize the output parameter.
    *ppszwDeviceName = NULL;

    PWSTR  szDesc;
    HRESULT hr = HrSetupDiGetDeviceName(m_hdi, &m_deid, &szDesc);
    if (SUCCEEDED(hr))
    {
        hr = HrCoTaskMemAllocAndDupSz (szDesc, ppszwDeviceName);

        delete [] reinterpret_cast<BYTE*>(szDesc);
    }

    TraceError("CLanConnection::GetDeviceName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetCharacteristics
//
//  Purpose:    Returns the characteristics of this connection type
//
//  Arguments:
//      pdwFlags [out]    Returns characteristics flags
//
//  Returns:    S_OK if successful, OLE or Win32 error code otherwise
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::GetCharacteristics(NETCON_MEDIATYPE ncm, DWORD* pdwFlags)
{
    Assert (pdwFlags);

    *pdwFlags = NCCF_ALL_USERS | NCCF_ALLOW_RENAME;

    DWORD   dwValue;
    HRESULT hr = HrRegQueryDword(m_hkeyConn, c_szShowIcon, &dwValue);
    if (SUCCEEDED(hr) && dwValue)
    {
        *pdwFlags |= NCCF_SHOW_ICON;
    }

    BOOL fShared;
    hr = HrIsConnectionIcsPublic(&fShared);
    if(SUCCEEDED(hr) && TRUE == fShared)
    {
        *pdwFlags |= NCCF_SHARED;
    }

    BOOL fBridged;
    hr = HrIsConnectionBridged(&fBridged);
    if(SUCCEEDED(hr) && TRUE == fBridged)
    {
        *pdwFlags |= NCCF_BRIDGED;
    }

    BOOL bFirewalled;
    hr = HrIsConnectionFirewalled(&bFirewalled);
    if(SUCCEEDED(hr) && TRUE == bFirewalled)
    {
        *pdwFlags |= NCCF_FIREWALLED;
    }

    if(NCM_BRIDGE == ncm)
    {
        hr = HrEnsureValidNlaPolicyEngine();
        if(SUCCEEDED(hr))
        {
            BOOL fHasPermission;
            hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_AllowNetBridge_NLA, &fHasPermission);
            if(SUCCEEDED(hr) && fHasPermission)
            {
                *pdwFlags |= NCCF_ALLOW_REMOVAL;
            }
        }
    }


    hr = S_OK;

    TraceError("CLanConnection::GetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetUiObjectClassId
//
//  Purpose:    Returns the CLSID of the object that handles UI for this
//              connection type
//
//  Arguments:
//      pclsid [out]    Returns CLSID of UI object
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetUiObjectClassId(CLSID *pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pclsid = CLSID_LanConnectionUi;
    }

    TraceError("CLanConnection::GetUiObjectClassId", hr);
    return hr;
}

static const WCHAR c_szLibPath[]   = L"sens.dll";
static const CHAR c_szaFunction[]  = "SensNotifyNetconEvent";

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrCallSens
//
//  Purpose:    Calls the external SENS notification DLL to let it know that
//              we connected or disconnected.
//
//  Arguments:
//      fConnect [in]   TRUE if connecting, FALSE if disconnecting
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   16 Jun 1998
//
//  Notes:
//
HRESULT CLanConnection::HrCallSens(BOOL fConnect)
{

    HRESULT         hr = S_OK;
    HMODULE         hmod;
    PFNSENSNOTIFY   pfnSensNotifyNetconEvent;

    hr = HrLoadLibAndGetProc(c_szLibPath, c_szaFunction, &hmod,
                             reinterpret_cast<FARPROC *>(&pfnSensNotifyNetconEvent));
    if (SUCCEEDED(hr))
    {
        DWORD               dwErr;
        SENS_NOTIFY_NETCON  snl = {0};

        snl.eType = fConnect ? SENS_NOTIFY_LAN_CONNECT :
                               SENS_NOTIFY_LAN_DISCONNECT;
        snl.pINetConnection = this;

        TraceTag(ttidLanCon, "Calling SENS to notify of %s.",
                 fConnect ? "connect" : "disconnect");

        dwErr = pfnSensNotifyNetconEvent(&snl);
        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            TraceTag(ttidLanCon, "Successfully notified SENS.");
        }

        FreeLibrary(hmod);
    }

    TraceError("CLanConnection::HrCallSens", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrConnectOrDisconnect
//
//  Purpose:    Connects or disconnects this LAN connection
//
//  Arguments:
//      fConnect [in]   TRUE if connect, FALSE if disconnect
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CLanConnection::HrConnectOrDisconnect(BOOL fConnect)
{
    HRESULT     hr = S_OK;

    if (!m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Before attempting to connect, check media state. If it is
        // disconnected, return error code that indicates that network is
        // not present because the cable is unplugged.
        //
        if (fConnect)
        {
            if (!FIsMediaPresent())
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = HrSetupDiSendPropertyChangeNotification(m_hdi, &m_deid,
                                      fConnect ? DICS_ENABLE : DICS_DISABLE,
                                      DICS_FLAG_CONFIGSPECIFIC, 0);
            if (SUCCEEDED(hr))
            {
                NETCON_STATUS   status;

                hr = GetStatus(&status);
                if (SUCCEEDED(hr))
                {
                    if (fConnect)
                    {
                        int nSecondsToWait = 5;
                        HRESULT hrRetry = S_OK;

                        while ((nSecondsToWait) && SUCCEEDED(hrRetry) &&
                               ((NCS_CONNECTING == status) || (NCS_MEDIA_DISCONNECTED == status) || (NCS_INVALID_ADDRESS == status)))
                        {
                            //#300520: check a few more times since the connection is
                            // still coming up
                            Sleep(1000);

                            hrRetry = GetStatus(&status);
                            nSecondsToWait --;
                        }

                        if (status != NCS_CONNECTED)
                        {
                            // did not connect successfully
                            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                            TraceError("HrConnectOrDisconnect - failed to "
                                       "connect!", hr);
                        }
                    }
                    else
                    {
                        if (status != NCS_DISCONNECTED)
                        {
                            // did not disconnect successfully
                            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                            TraceError("HrConnectOrDisconnect - failed to "
                                       "disconnect!", hr);
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrCallSens(fConnect);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidLanCon, "Failed to notify SENS on %s. "
                                 "Non-fatal 0x%08X",
                                 fConnect ? "connect" : "disconnect", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CLanConnection::HrConnectOrDisconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Connect
//
//  Purpose:    Activates the current LAN connection by telling its underlying
//              adapter to activate itself.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   14 Oct 1997
//
//  Notes:      Causes auto-connect value of TRUE to be written for this
//              connection in the current hardware profile.
//
STDMETHODIMP CLanConnection::Connect()
{
    HRESULT     hr = S_OK;

    hr = HrConnectOrDisconnect(TRUE);

    TraceError("CLanConnection::Connect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Disconnect
//
//  Purpose:    Deactivates the current LAN connection by telling its
//              underlying adapter to deactivate itself.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   14 Oct 1997
//
//  Notes:      Causes auto-connect value of FALSE to be written for this
//              connection in the current hardware profile.
//
STDMETHODIMP CLanConnection::Disconnect()
{
    HRESULT     hr = S_OK;

    hr = HrConnectOrDisconnect(FALSE);

    TraceError("CLanConnection::Disconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Delete
//
//  Purpose:    Delete the LAN connection.  This not allowed.
//
//  Arguments:
//      (none)
//
//  Returns:    E_UNEXPECTED;
//
//  Author:     shaunco   21 Jan 1998
//
//  Notes:      This function is not expected to ever be called.
//
STDMETHODIMP CLanConnection::Delete()
{
    HRESULT hr;
    NETCON_PROPERTIES* pProperties;
    hr = GetProperties(&pProperties);
    if(SUCCEEDED(hr))
    {
        if(NCM_BRIDGE == pProperties->MediaType)
        {
            IHNetConnection *pHNetConnection;
            IHNetBridge* pNetBridge;

            Assert(m_fInitialized);

            hr = HrGetIHNetConnection(&pHNetConnection);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConnection->GetControlInterface(
                        IID_IHNetBridge,
                        reinterpret_cast<void**>(&pNetBridge)
                        );

                ReleaseObj(pHNetConnection);

                AssertSz(SUCCEEDED(hr), "Unable to retrieve IHNetBridge");
            }

            if(SUCCEEDED(hr))
            {
                hr = pNetBridge->Destroy();
                ReleaseObj(pNetBridge);
            }
        }
        else
        {
            hr = E_FAIL;  // can't delete anything but NCM_BRIDGE
        }
        FreeNetconProperties(pProperties);
    }
    return hr;
}

STDMETHODIMP CLanConnection::Duplicate (
    PCWSTR             pszDuplicateName,
    INetConnection**    ppCon)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetProperties (
    NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        NETCON_STATUS ncStatus;

        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            hrT = GetDeviceGuid(&pProps->guidId);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwName
            //
            tstring strName;
            hrT = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
            if (SUCCEEDED(hrT))
            {
                hrT = HrCoTaskMemAllocAndDupSz (strName.c_str(),
                                &pProps->pszwName);
            }
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            PWSTR szDesc;
            hrT = HrSetupDiGetDeviceName(m_hdi, &m_deid, &szDesc);
            if (SUCCEEDED(hrT))
            {
                hrT = HrCoTaskMemAllocAndDupSz (szDesc,
                                &pProps->pszwDeviceName);

                delete [] reinterpret_cast<BYTE*>(szDesc);
            }
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Get additional Status information from 802.1X
            //
            if ((NCS_CONNECTED == pProps->Status) 
                || (NCS_INVALID_ADDRESS == pProps->Status) 
                || (NCS_MEDIA_DISCONNECTED == pProps->Status))
            {
                hrT = WZCQueryGUIDNCSState(&pProps->guidId, &ncStatus);
                if (S_OK == hrT)
                {
                    pProps->Status = ncStatus;
                }
            }

            // Type
            //
            BOOL fNetworkBridge;
            hrT = HrIsConnectionNetworkBridge(&fNetworkBridge);
            if(SUCCEEDED(hrT) && TRUE == fNetworkBridge)
            {
                pProps->MediaType = NCM_BRIDGE;
            }
            else
            {
                pProps->MediaType = NCM_LAN;
            }

            // dwCharacter
            //
            hrT = GetCharacteristics (pProps->MediaType, &pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_LanConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_LanConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CLanConnection::GetProperties", hr);
    return hr;
}


//
// INetLanConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetInfo
//
//  Purpose:    Returns information about this connection
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to return. Use
//                          LCIF_ALL to get all fields.
//      pLanConInfo [out]   Structure that holds returned information
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:      Caller should delete the szwConnName value.
//
STDMETHODIMP CLanConnection::GetInfo(DWORD dwMask, LANCON_INFO* pLanConInfo)
{
    HRESULT     hr = S_OK;

    if (!pLanConInfo)
    {
        hr = E_POINTER;
    }
    else if (!m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        ZeroMemory(pLanConInfo, sizeof(LANCON_INFO));

        if (dwMask & LCIF_COMP)
        {
            GUID    guid;

            hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
            pLanConInfo->guid = guid;
        }

        if (dwMask & LCIF_NAME)
        {
            hr = GetDeviceName(&pLanConInfo->szwConnName);
        }

        if (dwMask & LCIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                DWORD dwValue;

                hr = HrRegQueryDword(m_hkeyConn, c_szShowIcon, &dwValue);
                // OK if value not there. Default to FALSE always.
                //
                if (S_OK == hr)
                {
                    pLanConInfo->fShowIcon = !!(dwValue);
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = NETCFG_S_NOTEXIST;
                }
            }
        }
    }

    // Mask S_FALSE if it slipped thru.
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CLanConnection::GetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::SetInfo
//
//  Purpose:    Sets information about this connection.
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to set
//      pLanConInfo [in]    Structure containing information to set
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:      The guid member can only be set if the object is not yet
//              initialized.
//              The AutoConnect value is never set because it is set only upon
//              connect or disconnect.
//              If szwConnName is NULL, it is left unchanged.
//
STDMETHODIMP CLanConnection::SetInfo(DWORD dwMask,
                                     const LANCON_INFO* pLanConInfo)
{
    HRESULT     hr = S_OK;

    if (!pLanConInfo)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        // If we're not yet initialized, the only thing we will allow is the
        // flag that gets us initialized
        if (dwMask != LCIF_COMP)
        {
            hr = E_UNEXPECTED;
        }
        else
        {
            hr = HrLoad(pLanConInfo->guid);
            if (SUCCEEDED(hr))
            {
                WCHAR szPnpId[MAX_DEVICE_ID_LEN];

                hr = HrSetupDiGetDeviceInstanceId(m_hdi, &m_deid, szPnpId,
                            MAX_DEVICE_ID_LEN, NULL);
                if (S_OK == hr)
                {
                    hr = HrInitialize(szPnpId);
                }
            }
        }
    }
    else
    {
        if (dwMask & LCIF_NAME)
        {
            AssertSz(pLanConInfo->szwConnName,
                     "If you're going to set it, set it!");

            // Set connection name
            hr = Rename(pLanConInfo->szwConnName);
        }

        if (dwMask & LCIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                // Set ShowIcon value
                hr = HrRegSetDword(m_hkeyConn, c_szShowIcon,
                                   pLanConInfo->fShowIcon);
            }
        }

        if (SUCCEEDED(hr))
        {
            LanEventNotify(CONNECTION_MODIFIED, this, NULL, NULL);
        }
    }

    TraceError("CLanConnection::SetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetDeviceGuid
//
//  Purpose:    Returns the instance GUID of the device being used by this
//              connection
//
//  Arguments:
//      pguid [out]     Receives GUID of device
//
//  Returns:    S_OK if success, NetCfg error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetDeviceGuid(GUID *pguid)
{
    HRESULT hr;

    AssertSz(m_hdi, "No component?!");

    if (!pguid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrGetInstanceGuid(m_hdi, m_deid, pguid);
    }

    TraceError("CLanConnection::GetDeviceGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetClassID
//
//  Purpose:    Returns the CLSID of LAN connection objects
//
//  Arguments:
//      pclsid [out]    Returns CLSID to caller
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetClassID(CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_LanConnection;
    }
    TraceError("CLanConnection::GetClassID", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetSizeMax
//
//  Purpose:    Returns the maximum size of the persistence data
//
//  Arguments:
//      pcbSize [out]   Returns size
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetSizeMax(ULONG *pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pcbSize = sizeof(GUID);
    }

    TraceError("CLanConnection::GetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Load
//
//  Purpose:    Allows the connection object to initialize (restore) itself
//              from previously persisted data
//
//  Arguments:
//      pbBuf  [in]     Private data to use for restoring
//      cbSize [in]     Size of data
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Load(const BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize != sizeof(GUID))
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID    guid;

        CopyMemory(&guid, pbBuf, sizeof(GUID));
        hr = HrLoad(guid);
    }

    TraceError("CLanConnection::Load", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Save
//
//  Purpose:    Provides the caller with data to use in restoring this object
//              at a later time.
//
//  Arguments:
//      pbBuf  [out]    Returns data to use for restoring
//      cbSize [in]     Size of data buffer
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Save(BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized || !m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID    guid;

        hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
        if (S_OK == hr)
        {
            CopyMemory(pbBuf, &guid, cbSize);
        }
    }

    TraceError("CLanConnection::Save", hr);
    return hr;
}

//
// Private functions
//

extern const WCHAR c_szRegValueNetCfgInstanceId[];

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuid
//
//  Purpose:    Given device info, returns the NetCfg instance GUID of the
//              connection.
//
//  Arguments:
//      hdi   [in]      SetupAPI data
//      deid  [in]      SetupAPI data
//      pguid [out]     GUID of netcfg component
//
//  Returns:    S_OK if success, Win32 or SetupAPI error otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT HrGetInstanceGuid(HDEVINFO hdi, const SP_DEVINFO_DATA &deid,
                          LPGUID pguid)
{
    HRESULT hr;
    HKEY hkey;

    Assert(pguid);

    hr = HrSetupDiOpenDevRegKey(hdi, const_cast<SP_DEVINFO_DATA *>(&deid),
                                DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_READ, &hkey);
    if (S_OK == hr)
    {
        WCHAR       szGuid[c_cchGuidWithTerm];
        DWORD       cbBuf = sizeof(szGuid);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                                szGuid, &cbBuf);
        if (S_OK == hr)
        {
            IIDFromString(szGuid, pguid);
        }

        RegCloseKey(hkey);
    }

    TraceError("HrInstanceGuidFromDeid", hr);
    return hr;
}

static const WCHAR c_szKeyFmt[] = L"%s\\%s\\%s\\Connection";
extern const WCHAR c_szRegKeyComponentClasses[];
extern const WCHAR c_szRegValuePnpInstanceId[];

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadDevInfoFromGuid
//
//  Purpose:    Given a NetCfg instance GUID, loads the m_hdi and m_deid
//              members from the device installer.
//
//  Arguments:
//      guid [in]   GUID of connection
//
//  Returns:    S_OK if success, Win32 or SetupAPI error otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT CLanConnection::HrLoadDevInfoFromGuid(const GUID &guid)
{
    HRESULT             hr = S_OK;
    SP_DEVINFO_DATA     deid = {0};
    HKEY                hkeyNetCfg;
    WCHAR               szRegPath[c_cchMaxRegKeyLengthWithNull];
    WCHAR               szGuid[c_cchGuidWithTerm];
    WCHAR               szClassGuid[c_cchGuidWithTerm];

    StringFromGUID2(GUID_DEVCLASS_NET, szClassGuid, c_cchGuidWithTerm);
    StringFromGUID2(guid, szGuid, c_cchGuidWithTerm);
    wsprintfW(szRegPath, c_szKeyFmt, c_szRegKeyComponentClasses,
             szClassGuid, szGuid);

    // Open the Control\Network\{CLASS}\{Instance GUID} key
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath,
                        KEY_READ, &hkeyNetCfg);
    if (SUCCEEDED(hr))
    {
        tstring     strInstanceId;

        hr = HrRegQueryString(hkeyNetCfg, c_szRegValuePnpInstanceId,
                              &strInstanceId);
        if (SUCCEEDED(hr))
        {
            hr = HrSetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET,
                                               NULL, &m_hdi);
            if (SUCCEEDED(hr))
            {
                hr = HrSetupDiOpenDeviceInfo(m_hdi, strInstanceId.c_str(),
                                             NULL, 0, &m_deid);
            }
        }

        RegCloseKey(hkeyNetCfg);
    }

    TraceError("HrLoadDevInfoFromGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsAtmAdapterFromHkey
//
//  Purpose:    Determines if the given HKEY describes an ATM physical adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is ATM physical adapter, S_FALSE if not,
//              Win32 error otherwise
//
//  Author:     tongl   10 Dec 1998
//
//  Notes:
//
HRESULT CLanConnection::HrIsAtmAdapterFromHkey(HKEY hkey)
{
    HRESULT                     hr = S_OK;
    WCHAR                       szBuf[256];
    DWORD                       cbBuf = sizeof(szBuf);
    list<tstring *>             lstr;
    list<tstring *>::iterator   lstrIter;
    BOOL                        fMatch = FALSE;
    HKEY                        hkeyInterfaces;

    hr = HrRegOpenKeyEx(hkey, c_szRegKeyInterfacesFromInstance,
                        KEY_READ, &hkeyInterfaces);
    if (SUCCEEDED(hr))
    {
        hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueUpperRange,
                                szBuf, &cbBuf);
        if (SUCCEEDED(hr))
        {
            ConvertStringToColString(szBuf, c_chComma, lstr);

            for (lstrIter = lstr.begin(); lstrIter != lstr.end(); lstrIter++)
            {
                // See if it matches one of these

                if (!lstrcmpiW((*lstrIter)->c_str(), c_szBiNdisAtm))
                {
                    fMatch = TRUE;
                    break;
                }
            }

            DeleteColString(&lstr);
        }

        RegCloseKey(hkeyInterfaces);
    }

    if (SUCCEEDED(hr))
    {
        if (fMatch)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TraceError("HrIsAtmAdapterFromHkey", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsAtmElanFromHkey
//
//  Purpose:    Determines if the given HKEY describes an ATM ELAN adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is ELAN capable, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     tongl   21 Oct 1998
//
//  Notes:
//
HRESULT CLanConnection::HrIsAtmElanFromHkey(HKEY hkey)
{
    HRESULT hr;

    // pszInfId should have enough characters to hold "ms_atmelan".
    // If the registry value is bigger than that, we know we don't have
    // a match.
    //
    WCHAR pszInfId [24];
    DWORD cbInfId = sizeof(pszInfId);

    hr = HrRegQuerySzBuffer(hkey, L"ComponentId", pszInfId, &cbInfId);

    if ((S_OK != hr) || (0 != _wcsicmp(pszInfId, L"ms_atmelan")))
    {
        hr = S_FALSE;
    }

    Assert ((S_OK == hr) || (S_FALSE == hr));

    TraceError("HrIsAtmElanFromHkey", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionBridged
//
//  Purpose:    Determines if connection is a member of a brigde
//
//  Arguments:
//      pfBridged [in]   A boolean for the result
//
//  Returns:    S_OK if pfBridged is valid
//              S_FALSE if pfBridged can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionBridged(BOOL* pfBridged)
{
    *pfBridged = FALSE;
    HRESULT hResult = S_OK;

    hResult = HrEnsureHNetPropertiesCached();

    if (S_OK == hResult)
    {
        *pfBridged = m_pHNetProperties->fPartOfBridge;
    }

    return hResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionFirewalled
//
//  Purpose:    Determines if connection is firewalled
//
//  Arguments:
//      pfFirewalled [in]   A boolean for the result
//
//  Returns:    S_OK if pfFirewalled is valid
//              S_FALSE if pfFirewalled can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionFirewalled(BOOL* pfFirewalled)
{
    HRESULT hr = S_OK;
    BOOL fHasPermission = FALSE;

    *pfFirewalled = FALSE;
    // A Connection is only firewalled if the firewall is currently running, so
    // we return FALSE if the permission denies the firewall from running.
    hr = HrEnsureValidNlaPolicyEngine();
    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CRasConnectionBase::HrIsConnectionFirewalled calling HrEnsureValidNlaPolicyEngine", hr);

    if (SUCCEEDED(hr))
    {
        hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_PersonalFirewallConfig, &fHasPermission);
        if (SUCCEEDED(hr) && fHasPermission)
        {
            hr = HrEnsureHNetPropertiesCached();

            if (S_OK == hr)
            {
                *pfFirewalled = m_pHNetProperties->fFirewalled;
            }
        }
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionNetworkBridge
//
//  Purpose:    Determines if a brigde
//
//  Arguments:
//      pfNetworkBridge [in]   A boolean for the result
//
//  Returns:    S_OK if pfNetworkBridge is valid
//              S_FALSE if pfNetworkBridge can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
static const WCHAR c_szNetworkBridgeComponentId[] = L"ms_bridgemp";
extern const WCHAR c_szRegValueComponentId[];

HRESULT CLanConnection::HrIsConnectionNetworkBridge(BOOL* pfNetworkBridge)
{
    *pfNetworkBridge = FALSE;
    HRESULT hr = S_OK;

    HKEY hkey;
    hr = HrSetupDiOpenDevRegKey(m_hdi, const_cast<SP_DEVINFO_DATA *>(&m_deid),
                                DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_READ, &hkey);
    if (S_OK == hr)
    {
        WCHAR       szComponentId[60]; // if it's bigger than this, it's not the bridge, but make it big to shut up the tracing
        DWORD       cbBuf = sizeof(szComponentId);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValueComponentId,
            szComponentId, &cbBuf);
        if (S_OK == hr || HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
        {
            if(0 == lstrcmp(szComponentId, c_szNetworkBridgeComponentId))
            {
                *pfNetworkBridge = TRUE;
            }

            hr = S_OK;
        }

        RegCloseKey(hkey);
    }

    TraceError("HrIsConnectionNetworkBridge", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionIcsPublic
//
//  Purpose:    Determines if connection is shared (ICS public)
//
//  Arguments:
//      pfIcsPublic [out]   A boolean for the result
//
//  Returns:    S_OK if pfIcsPublic is valid
//              S_FALSE if pfIcsPublic can't currently be determined
//              Error otherwise
//
//  Author:     jonburs 31 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionIcsPublic(BOOL* pfIcsPublic)
{
    Assert(NULL != pfIcsPublic);
    *pfIcsPublic = FALSE;
    HRESULT hResult = S_OK;

    hResult = HrEnsureHNetPropertiesCached();

    if (S_OK == hResult)
    {
        *pfIcsPublic = m_pHNetProperties->fIcsPublic;
    }

    return hResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureHNetPropertiesCached
//
//  Purpose:    Makes sure home networking properties are up-to-date
//
//  Arguments:
//
//  Returns:    S_OK if m_pHNetProperties is now valid (success)
//              S_FALSE if it's not currently possible to update the properties
//              (e.g., recursive attempt to update)
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CLanConnection::HrEnsureHNetPropertiesCached(VOID)
{
    HRESULT hr = S_OK;

    Assert(TRUE == m_fInitialized);

    if (!m_fHNetPropertiesCached
        || m_lHNetModifiedEra != g_lHNetModifiedEra)
    {
        //
        // Our cached properties are possibly out of date. Check
        // to see that this is not a recursive entry
        //

        if (0 == InterlockedExchange(&m_lUpdatingHNetProperties, 1))
        {
            IHNetConnection *pHNetConn;
            HNET_CONN_PROPERTIES *pProps;

            hr = HrGetIHNetConnection(&pHNetConn);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConn->GetProperties(&pProps);
                ReleaseObj(pHNetConn);

                if (SUCCEEDED(hr))
                {
                    //
                    // Store new properties, and free old. Note that CoTaskMemFree
                    // properly handles NULL input.
                    //

                    pProps =
                        reinterpret_cast<HNET_CONN_PROPERTIES*>(
                            InterlockedExchangePointer(
                                reinterpret_cast<PVOID*>(&m_pHNetProperties),
                                reinterpret_cast<PVOID>(pProps)
                            )
                        );

                    CoTaskMemFree(pProps);

                    //
                    // Update our era, and note that we have valid properties
                    //

                    InterlockedExchange(&m_lHNetModifiedEra, g_lHNetModifiedEra);
                    m_fHNetPropertiesCached = TRUE;

                    hr = S_OK;
                }
            }
            else
            {
                //
                // If we don't yet have a record of this connection w/in the
                // home networking store, HrGetIHNetConnection will fail (as
                // we ask it not to create new entries). We therefore convert
                // failure to S_FALSE, which means we can't retrieve this info
                // right now.
                //

                hr = S_FALSE;
            }

            //
            // We're no longer updating our properties
            //

            InterlockedExchange(&m_lUpdatingHNetProperties, 0);
        }
        else
        {
            //
            // Update is alredy going on (possibly an earlier call on
            // the same thread). Return S_FALSE.
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CLanConnection::HrGetIHNetConnection(IHNetConnection **ppHNetConnection)
{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    GUID guid;

    Assert(ppHNetConnection);

    hr = GetDeviceGuid(&guid);

    if (SUCCEEDED(hr))
    {
        hr = HrGetHNetCfgMgr(&pCfgMgr);
    }

    if (SUCCEEDED(hr))
    {
        hr = pCfgMgr->GetIHNetConnectionForGuid(
                &guid,
                TRUE,
                FALSE,
                ppHNetConnection
                );

        ReleaseObj(pCfgMgr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShowIcon
//
//  Purpose:    Sets the Icon state for the systray, fires an event to notify
//              NetShell of the Change
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
HRESULT CLanConnection::ShowIcon(const BOOL bShowIcon)
{
    HRESULT hr;
    LANCON_INFO lcInfo;

    hr = GetInfo(LCIF_ICON, &lcInfo);

    if (SUCCEEDED(hr))
    {
        lcInfo.fShowIcon = bShowIcon;
        hr = SetInfo(LCIF_ICON, &lcInfo);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IconStateChanged
//
//  Purpose:    Fires an event to notify NetShell of a Change occuring in an
//              incoming connection.
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
inline
HRESULT CLanConnection::IconStateChanged()
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
HRESULT CLanConnection::GetPropertiesEx(NETCON_PROPERTIES_EX** ppConnectionPropertiesEx)
{
    HRESULT hr = S_OK;

    *ppConnectionPropertiesEx = NULL;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProps;
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

        if (pPropsEx)
        {
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));

            hr = GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, dynamic_cast<IPersistNetConnection *>(this));
                if (SUCCEEDED(hr))
                {
                    if (NCM_LAN == pPropsEx->ncMediaType)
                    {
                        CIntelliName inName(NULL, NULL);
                        NETCON_MEDIATYPE    ncm;
                        NETCON_SUBMEDIATYPE ncsm;

                        hr = inName.HrGetPseudoMediaTypes(pPropsEx->guidId, &ncm, &ncsm);
                        if (FAILED(hr))
                        {
                            hr = HrGetPseudoMediaTypeFromConnection(pPropsEx->guidId, &ncsm);
                            TraceError("HrGetPseudoMediaTypeFromConnection failed.", hr);
                            hr = S_OK;
                        }
                        
                        pPropsEx->ncSubMediaType = ncsm;
                        if (NCSM_WIRELESS == ncsm)
                        {
                            LANCON_INFO LanConInfo;

                            hr = GetInfo(LCIF_ICON, &LanConInfo);
                            if (NETCFG_S_NOTEXIST == hr)
                            {
                                LanConInfo.fShowIcon = TRUE;
                                hr = SetInfo(LCIF_ICON, &LanConInfo);
                                TraceError("SetInfo", hr);
                                pPropsEx->dwCharacter |= NCCF_SHOW_ICON;
                                hr = S_OK;
                            }
                        }
                    }
                    else
                    {
                        pPropsEx->ncSubMediaType = NCSM_NONE;
                    }
 
                    if (SUCCEEDED(hr))
                    {
                        *ppConnectionPropertiesEx = pPropsEx;
                    }
                }

                FreeNetconProperties(pProps);
            }

            if (FAILED(hr))
            {
                *ppConnectionPropertiesEx = NULL;
                HrFreeNetConProperties2(pPropsEx);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError ("CLanConnection::GetPropertiesEx", hr);
    return hr;
}

HRESULT CLanConnection::HrEnsureValidNlaPolicyEngine()
{
    HRESULT hr = S_FALSE;  // Assume we already have the object
 
    if (!m_pNetMachinePolicies)
    {
        hr = CoCreateInstance(CLSID_NetGroupPolicies, NULL, CLSCTX_INPROC, IID_INetMachinePolicies, reinterpret_cast<void**>(&m_pNetMachinePolicies));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\rasconob.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       R A S C O N O B . C P P
//
//  Contents:   Implements the base class used to implement the Dialup,
//              Direct, and Vpn connection objects.  Also includes
//              RAS-related utility functions used only within netman.exe.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nccom.h"
#include "ncperms.h"
#include "ncras.h"
#include "rasconob.h"
#include <raserror.h>
#include "gpnla.h" 

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

//+---------------------------------------------------------------------------
//
//  Function:   HrRasConnectionNameFromGuid
//
//  Purpose:    Exported API used by iphlpapi et. al. to get the connection
//              of a RAS connection given its GUID.
//
//  Arguments:
//      guid     [in]    The guid id representing the connection.
//      pszwName [out]   Pointer to a buffer to store the name.
//      pcchMax  [inout] On input, the length, in characters, of the buffer
//                       including the null terminator.  On output, the
//                       length of the string including the null terminator
//                       (if it was written) or the length of the buffer
//                       required.
//
//  Returns:    HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if the entry was not found.
//              HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//              S_OK
//
//  Author:     shaunco   23 Sep 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrRasConnectionNameFromGuid (
    IN      REFGUID guid,
    OUT     PWSTR   pszwName,
    IN OUT  DWORD*  pcchMax)
{
    Assert (pszwName);
    Assert (pcchMax);

    // Initialize the output parameter.
    //
    *pszwName = NULL;

    // We now need to enumerate all entries in this phonebook and
    // find our details record with the matching guidId.
    //
    RASENUMENTRYDETAILS* aRasEntryDetails;
    DWORD                cRasEntryDetails;
    HRESULT              hr;

    hr = HrRasEnumAllEntriesWithDetails (
            NULL,
            &aRasEntryDetails,
            &cRasEntryDetails);

    if (SUCCEEDED(hr))
    {
        RASENUMENTRYDETAILS* pDetails;

        // Assume we don't find the entry.
        //
        hr = HRESULT_FROM_WIN32 (ERROR_NOT_FOUND);

        for (DWORD i = 0; i < cRasEntryDetails; i++)
        {
            pDetails = &aRasEntryDetails[i];

            if (pDetails->guidId == guid)
            {
                // Only copy the string if the caller has enough room in
                // the output buffer.
                //
                hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER);
                DWORD cchRequired = wcslen(pDetails->szEntryName) + 1;
                if (cchRequired <= *pcchMax)
                {
                    wcscpy (pszwName, pDetails->szEntryName);
                    hr = S_OK;
                }
                *pcchMax = cchRequired;

                break;
            }
        }

        MemFree (aRasEntryDetails);
    }
    else if (HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    TraceError ("HrRasConnectionNameFromGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::CacheProperties
//
//  Purpose:
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   2 Feb 1998
//
//  Notes:
//
VOID
CRasConnectionBase::CacheProperties (
    const RASENUMENTRYDETAILS*  pDetails)
{
    Assert (pDetails);
    AssertSz(pDetails->dwSize >= sizeof(RASENUMENTRYDETAILS), "RASENUMENTRYDETAILS too small");

    m_fEntryPropertiesCached = TRUE;
    m_lRasEntryModifiedVersionEra = g_lRasEntryModifiedVersionEra;

    m_guidId                    = pDetails->guidId;
    SetEntryName (pDetails->szEntryName);
    m_fForAllUsers              = !!(pDetails->dwFlags & REN_AllUsers);
    m_fShowMonitorIconInTaskBar = pDetails->fShowMonitorIconInTaskBar;
    m_strDeviceName             = pDetails->szDeviceName;
    m_dwFlagsPriv               = pDetails->dwFlagsPriv;
    m_strPhoneNumber            = pDetails->szPhoneNumber;

    TraceTag(ttidWanCon, "PhoneNumber: %S", m_strPhoneNumber);

    m_fBranded = (RASET_Internet == pDetails->dwType);

    TraceTag (ttidWanCon, "rdt:0x%08x,  dwType:0x%08x",
        pDetails->rdt,
        pDetails->dwType);

    switch (LOWORD(pDetails->rdt))
    {
        case RDT_PPPoE:
            m_MediaType = NCM_PPPOE;
            break;

        case RDT_Modem:
        case RDT_X25:
            m_MediaType = NCM_PHONE;
            break;

        case RDT_Isdn:
            m_MediaType = NCM_ISDN;
            break;

        case RDT_Serial:
        case RDT_FrameRelay:
        case RDT_Atm:
        case RDT_Sonet:
        case RDT_Sw56:
            m_MediaType = NCM_PHONE;
            break;

        case RDT_Tunnel_Pptp:
        case RDT_Tunnel_L2tp:
            m_MediaType = NCM_TUNNEL;
            break;

        case RDT_Irda:
        case RDT_Parallel:
            m_MediaType = NCM_DIRECT;
            break;

        case RDT_Other:
        default:
            if (RASET_Vpn == pDetails->dwType)
            {
                m_MediaType = NCM_TUNNEL;
            }
            else if (RASET_Direct == pDetails->dwType)
            {
                m_MediaType = NCM_DIRECT;
            }
            else
            {
                m_MediaType = NCM_PHONE;
            }
            break;
    }

    if (pDetails->rdt & RDT_Tunnel)
    {
        m_MediaType = NCM_TUNNEL;
    }
    else if (pDetails->rdt & (RDT_Direct | RDT_Null_Modem))
    {
        m_MediaType = NCM_DIRECT;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::FAllowRemoval
//
//  Purpose:    Returns TRUE if the connection is in a state where we
//              can validly remove it.
//
//  Arguments:
//      phrReason [out] If FALSE is returned, this is the reason.  It is
//                      either E_ACCESSDENIED or E_UNEXPECTED.
//
//  Returns:    TRUE or FALSE.
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
BOOL
CRasConnectionBase::FAllowRemoval (
    HRESULT* phrReason)
{
    Assert (phrReason);
    Assert (m_fEntryPropertiesCached);

    // If this connection is for all users, the user must be
    // an administrator or power user.
    //
    if (m_fForAllUsers && !FIsUserAdmin())
    {
        *phrReason = E_ACCESSDENIED;
        return FALSE;
    }

    // $$NOTE (jeffspr) -- moved the test for connection state to the
    // delete function because we don't want it to affect our loading
    // of characteristics

    //
    // If we passed all tests above, we're okay to remove.
    //
    *phrReason = S_OK;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetCharacteristics
//
//  Purpose:    Get the characteristics of the connection.
//
//  Arguments:
//      pdwFlags [out]
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetCharacteristics (
    DWORD*    pdwFlags)
{
    Assert (pdwFlags);

    DWORD dwFlags = NCCF_OUTGOING_ONLY;

    HRESULT hr = HrEnsureEntryPropertiesCached ();
    if (SUCCEEDED(hr))
    {
        if (FIsBranded ())
        {
            dwFlags |= NCCF_BRANDED;
        }
        else
        {
            dwFlags |= (NCCF_ALLOW_RENAME | NCCF_ALLOW_DUPLICATION);
        }

        if (m_fForAllUsers)
        {
            dwFlags |= NCCF_ALL_USERS;
        }

        if (m_dwFlagsPriv & REED_F_Default)
        {
            dwFlags |= NCCF_DEFAULT;
        }

        HRESULT hrReason;
        if (FAllowRemoval (&hrReason))
        {
            dwFlags |= NCCF_ALLOW_REMOVAL;
        }

        if (FShowIcon ())
        {
            dwFlags |= NCCF_SHOW_ICON;
        }

        if (S_OK == HrEnsureHNetPropertiesCached())
        {
            if (m_HNetProperties.fIcsPublic)
            {
                dwFlags |= NCCF_SHARED;
            }
            
            BOOL fIsFirewalled = FALSE;
            hr = HrIsConnectionFirewalled(&fIsFirewalled);
            if (fIsFirewalled)
            {
                dwFlags |= NCCF_FIREWALLED;
            }

        }
    }

    *pdwFlags = dwFlags;

    TraceError ("CRasConnectionBase::HrGetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetStatus
//
//  Purpose:    Get the stauts of the connection.
//
//  Arguments:
//      pStatus [out] NETCON_STATUS
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetStatus (
    NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    // Initialize output parameters.
    //
    *pStatus = NCS_DISCONNECTED;

    // Find the active RAS connection corresponding to this object if
    // it exists.
    //
    HRASCONN hRasConn;
    HRESULT hr = HrFindRasConn (&hRasConn, NULL);
    if (S_OK == hr)
    {
        hr = HrRasGetNetconStatusFromRasConnectStatus (
                hRasConn, pStatus);

        // When the connection becomes disconnected between HrFindRas
        // and HrRasGet calls above, ERROR_INVALID_HANLDE is returned
        // this simply means that the connection has been disconnected.
        //
        if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr)
        {
            Assert (NCS_DISCONNECTED == *pStatus);
            hr = S_OK;
        }
    }
    else if (S_FALSE == hr)
    {
        hr = S_OK;

        if (!PszwDeviceName())
        {
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
        }

        // NCS_HARDWARE_DISABLED ?
        // NCS_HARDWARE_MALFUNCTION ?
    }
    TraceError ("CRasConnectionBase::HrGetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrEnsureEntryPropertiesCached
//
//  Purpose:    Ensures that the member's corresponding to entry properties
//              are cached by calling RasGetEntryProperties if needed.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   17 Dec 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrEnsureEntryPropertiesCached ()
{
    HRESULT hr = S_OK;

    // If we're not yet cached, or the cache is possibly out of date, we
    // need to update ourselves.  g_lRasEntryModifiedVersionEra is the global
    // version indicator for RAS phonebook entry modifications.  Our local
    // version indicator is set in CacheProperties.
    //
    if (!m_fEntryPropertiesCached ||
        (m_lRasEntryModifiedVersionEra != g_lRasEntryModifiedVersionEra))
    {
        // We now need to enumerate all entries in this phonebook and
        // find our details record with the matching guidId.
        //
        RASENUMENTRYDETAILS* aRasEntryDetails;
        DWORD                cRasEntryDetails;

        // Impersonate the client.
        //
        HRESULT hrT = CoImpersonateClient ();
        TraceHr (ttidError, FAL, hrT, FALSE, "CoImpersonateClient");

        // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
        if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
        {
            hr = HrRasEnumAllEntriesWithDetails (
                    PszwPbkFile(),
                    &aRasEntryDetails,
                    &cRasEntryDetails);
        }

        if (SUCCEEDED(hrT))
        {
            hrT = CoRevertToSelf ();
            TraceHr (ttidError, FAL, hrT, FALSE, "CoRevertToSelf");
        }

        if (SUCCEEDED(hr))
        {
            BOOL fNoGuidYet = (m_guidId == GUID_NULL);

            RASENUMENTRYDETAILS* pDetails;

            // Assume we don't find the entry.
            //
            hr = HRESULT_FROM_WIN32 (ERROR_NOT_FOUND);

            for (DWORD i = 0; i < cRasEntryDetails; i++)
            {
                pDetails = &aRasEntryDetails[i];

                if (pDetails->guidId == m_guidId)
                {
                    CacheProperties (pDetails);
                    hr = S_OK;

                    TraceTag (ttidWanCon,
                        "HrRasEnumAllEntriesWithDetails found entry "
                        "via guid (%S)",
                        PszwEntryName());
                    break;
                }
                else if (fNoGuidYet &&
                         !lstrcmpW (PszwEntryName(), pDetails->szEntryName))
                {
                    CacheProperties (pDetails);
                    hr = S_OK;

                    TraceTag (ttidWanCon,
                        "HrRasEnumAllEntriesWithDetails found entry "
                        "via entryname (%S)",
                        PszwEntryName());
                    break;
                }
            }

            MemFree (aRasEntryDetails);
        }
        else if (HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    }
    TraceError ("CRasConnectionBase::HrEnsureEntryPropertiesCached", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrFindRasConn
//
//  Purpose:    Searches for the active RAS connection that corresponds to
//              this phone book and entry.
//
//  Arguments:
//      phRasConn   [out]   The returned handle to the RAS connection if it
//                          was found.  NULL otherwise.
//      pRasConn    [out]   Optional pointer to returned RASCONN structure
//                          if found.
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     shaunco   29 Sep 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrFindRasConn (
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL)
{
    Assert (phRasConn);
    Assert (m_fInitialized);

    HRESULT hr = S_OK;

    // Initialize the output parameter.
    //
    *phRasConn = NULL;

    // We need m_guidId to be valid.  If it is GUID_NULL, it means
    // we have an entry name with with to look it up.
    //
    if (GUID_NULL == m_guidId)
    {
        hr = HrEnsureEntryPropertiesCached ();
    }

    if (SUCCEEDED(hr))
    {
        hr = HrFindRasConnFromGuidId (&m_guidId, phRasConn, pRasConn);

    }

    TraceError ("CRasConnectionBase::HrFindRasConn",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrLockAndRenameEntry
//
//  Purpose:    Renames the phone book entry and updates our entry name
//              member atomically.
//
//  Arguments:
//      pszwNewName [in] The new name.
//      pObj        [in] Used to Lock the operation.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrLockAndRenameEntry (
    PCWSTR                                     pszwNewName,
    CComObjectRootEx <CComMultiThreadModel>*    pObj)
{
    // Make sure the name is valid in the same phone book.
    //
    DWORD dwErr = RasValidateEntryName (PszwPbkFile (), pszwNewName);

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr,
        "RasValidateEntryName", hr);

    // We can ignore ERROR_ALREADY_EXISTS as it will happen when a user
    // tries to change the case of the entry name.
    //
    if (SUCCEEDED(hr) || (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr))
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // Lock the object and rename it.
            //
            CExceptionSafeComObjectLock EsLock (pObj);

            dwErr = RasRenameEntry (
                        PszwPbkFile (),
                        PszwEntryName (),
                        pszwNewName);

            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceHr (ttidError, FAL, hr, FALSE, "RasRenameEntry");

            if (SUCCEEDED(hr))
            {
                SetEntryName (pszwNewName);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasConnectionBase::HrLockAndRenameEntry");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetRasConnectionInfo
//
//  Purpose:    Implementation of INetRasConnection::GetRasConnectionInfo
//
//  Arguments:
//      pRasConInfo [out] pointer to returned info
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetRasConnectionInfo (
    RASCON_INFO* pRasConInfo)
{
    Assert (m_fInitialized);

    HRESULT hr;

    // Validate parameters.
    //
    if (!pRasConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            ZeroMemory (pRasConInfo, sizeof (*pRasConInfo));

            hr = S_OK;

            HRESULT hrT;

            hrT = HrCoTaskMemAllocAndDupSz (PszwPbkFile(),
                            &pRasConInfo->pszwPbkFile);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            hrT = HrCoTaskMemAllocAndDupSz (PszwEntryName(),
                            &pRasConInfo->pszwEntryName);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            pRasConInfo->guidId = m_guidId;

            if (FAILED(hr))
            {
                RciFree (pRasConInfo);

                AssertSz (!pRasConInfo->pszwPbkFile && !pRasConInfo->pszwEntryName,
                        "RciFree should be zeroing the structure!");
            }
        }
    }
    TraceError ("CRasConnectionBase::HrGetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrSetRasConnectionInfo
//
//  Purpose:    Implementation of INetRasConnection::SetRasConnectionInfo
//
//  Arguments:
//      pRasConInfo [in] info to set
//
//  Returns:    S_OK
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrSetRasConnectionInfo (
    const RASCON_INFO* pRasConInfo)
{
    Assert (!m_fInitialized);

    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pRasConInfo)
    {
        hr = E_POINTER;
    }
    else if (!pRasConInfo->pszwPbkFile ||
             (0 == lstrlenW (pRasConInfo->pszwPbkFile)) ||
             !pRasConInfo->pszwEntryName ||
             (0 == lstrlenW (pRasConInfo->pszwEntryName)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SetPbkFile (pRasConInfo->pszwPbkFile);
        SetEntryName (pRasConInfo->pszwEntryName);
        m_guidId = pRasConInfo->guidId;

        // We are now a full-fledged object.
        //
        m_fInitialized = TRUE;
    }
    TraceError ("CRasConnectionBase::HrSetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetRasConnectionHandle
//
//  Purpose:    Implementation of INetRasConnection::HrGetRasConnectionHandle
//
//  Arguments:
//      phRasConn  [out] pointer to the returned RAS connection handle
//
//  Returns:    S_OK if connected, S_FALSE if not, error code otherwise.
//
//  Author:     CWill   09 Dec 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetRasConnectionHandle (
    HRASCONN* phRasConn)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!phRasConn)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *phRasConn = 0;

        hr = HrFindRasConn (phRasConn, NULL);
    }

    TraceError ("CRasConnectionBase::HrGetRasConnectionHandle",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
// IPersistNetConnection -
//
// For our persistent (across session) data, we choose to store only the
// the phonebook name and the guid Id of the RAS entry.  We explicitly don't
// store the entry name because it can be changed externally.  If it were
// we would have an orhpaned connection.
//
// When loading the connection from the persistent store, we need to
// enumerate all of the entries in the given phonebook looking for the one
// with the matching guid Id.  Once found, the connection can successfully
// be loaded.
//

// Lead and trail characters for our persistent memory form.
//
static const WCHAR c_chwLead  = 0x14;
static const WCHAR c_chwTrail = 0x05;


//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistGetSizeMax
//
//  Purpose:    Implementation of IPersistNetConnection::GetSizeMax
//
//  Arguments:
//      pcbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistGetSizeMax (
    ULONG*  pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Size the buffer for the following form:
        //  +--------------------------------------------+
        //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
        //  +--------------------------------------------+
        //
        *pcbSize = sizeof (c_chwLead) +
                   CbOfSzAndTerm (PszwPbkFile()) +
                   sizeof (m_guidId) +
                   sizeof (m_fForAllUsers) +
                   sizeof (c_chwTrail);
    }
    TraceError ("CRasConnectionBase::HrPersistGetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistLoad
//
//  Purpose:    Implementation of IPersistNetConnection::Load
//
//  Arguments:
//      pbBuf  []
//      cbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistLoad (
    const BYTE* pbBuf,
    ULONG       cbSize)
{
    TraceFileFunc(ttidWanCon);
    // The theoretical minimum size for the buffer is:
    // (4 characters for a minimal path like 'c:\a')
    //
    const ULONG c_cbSizeMin = sizeof (c_chwLead) +
                              (4 + 1) * sizeof(WCHAR) +
                              sizeof (m_guidId) +
                              sizeof (m_fForAllUsers) +
                              sizeof (c_chwTrail);

    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize < c_cbSizeMin)
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // The buffer *should* look like this:
        //  +--------------------------------------------+
        //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
        //  +--------------------------------------------+
        //
        const WCHAR* pchw = reinterpret_cast<const WCHAR*>(pbBuf);
        const WCHAR* pchwMax;
        PCWSTR       pszwPhonebook;
        GUID         guidId;
        const GUID*  pguidId;
        BOOL         fForAllUsers;
        const BOOL*  pfForAllUsers;

        // The last valid pointer for the embedded strings.
        //
        pchwMax = reinterpret_cast<const WCHAR*>(pbBuf + cbSize
                       - (sizeof (m_guidId) +
                          sizeof (m_fForAllUsers) +
                          sizeof (c_chwTrail)));

        if (c_chwLead != *pchw)
        {
            goto finished;
        }

        // Skip past our lead byte.
        //
        pchw++;

        // Get m_strPbkFile.  Search for the terminating null and make sure
        // we find it before the end of the buffer.  Using lstrlen to skip
        // the string can result in an an AV in the event the string is
        // not actually null-terminated.
        //
        for (pszwPhonebook = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_guidId
        //
        pguidId = reinterpret_cast<const GUID*>(pchw);
        CopyMemory(&guidId, pguidId, sizeof(guidId));
        pguidId++;

        // Get m_fForAllUsers
        //
        pfForAllUsers = reinterpret_cast<const BOOL*>(pguidId);
        CopyMemory(&fForAllUsers, pfForAllUsers, sizeof(fForAllUsers));
        pfForAllUsers++;

        // Check our trail byte.
        //
        pchw = reinterpret_cast<const WCHAR*>(pfForAllUsers);
        if (c_chwTrail != *pchw)
        {
            goto finished;
        }

        TraceTag (ttidWanCon, "HrPersistLoad for %S", pszwPhonebook);

        SetPbkFile (pszwPhonebook);
        m_fForAllUsers = fForAllUsers;
        m_guidId = guidId;

        // We are now a full-fledged object.
        //
        m_fInitialized = TRUE;
        hr = S_OK;

    finished:
            ;
    }
    TraceError ("CRasConnectionBase::HrPersistLoad", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistSave
//
//  Purpose:    Implementation of IPersistNetConnection::Save
//
//  Arguments:
//      pbBuf  []
//      cbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistSave (
    BYTE*   pbBuf,
    ULONG   cbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Make sure the user's buffer is big enough.
        //
        ULONG cbSizeRequired;
        SideAssert (SUCCEEDED(HrPersistGetSizeMax(&cbSizeRequired)));

        if (cbSize < cbSizeRequired)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            TraceTag (ttidWanCon, "HrPersistSave for %S (%S)",
                PszwEntryName (),
                PszwPbkFile ());

            hr = HrEnsureEntryPropertiesCached ();
            if (SUCCEEDED(hr))
            {
                // Make the buffer look like this when we're done:
                //  +--------------------------------------------+
                //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
                //  +--------------------------------------------+
                //
                WCHAR* pchw = reinterpret_cast<WCHAR*>(pbBuf);

                // Put our lead byte.
                //
                *pchw = c_chwLead;
                pchw++;

                // Put m_strPbkFile
                //
                ULONG cchw = lstrlenW (PszwPbkFile());
                lstrcpyW (pchw, PszwPbkFile());
                pchw += cchw + 1;

                // Put m_guidId
                //
                GUID* pguidId = reinterpret_cast<GUID*>(pchw);
                CopyMemory(pguidId, &GuidId(), sizeof(*pguidId));
                pguidId++;

                // Put m_fForAllUsers
                //
                BOOL* pfForAllUsers = reinterpret_cast<BOOL*>(pguidId);
                CopyMemory(pfForAllUsers, &m_fForAllUsers, sizeof(*pfForAllUsers));
                pfForAllUsers++;

                // Put our trail byte.
                //
                pchw = reinterpret_cast<WCHAR*>(pfForAllUsers);
                *pchw = c_chwTrail;
                pchw++;

                AssertSz (pbBuf + cbSizeRequired == (BYTE*)pchw,
                    "pch isn't pointing where it should be.");
            }
        }
    }
    TraceError ("CRasConnectionBase::HrPersistSave", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrEnsureHNetPropertiesCached
//
//  Purpose:    Makes sure home networking properties are up-to-date
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if m_pHNetProperties is now valid (success)
//              S_FALSE if it's not currently possible to update the properties
//              (e.g., recursive attempt to update)
//
//  Author:     jonburs     16 August 2000
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrEnsureHNetPropertiesCached ()
{
    HRESULT hr = S_OK;

    if (!m_fHNetPropertiesCached
        || m_lHNetModifiedEra != g_lHNetModifiedEra)
    {
        //
        // Our cached properties are possibly out of date. Check
        // to see that this is not a recursive entry
        //

        if (0 == InterlockedExchange(&m_lUpdatingHNetProperties, 1))
        {
            IHNetConnection *pHNetConn;
            HNET_CONN_PROPERTIES *pProps;

            hr = HrGetIHNetConnection(&pHNetConn);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConn->GetProperties(&pProps);
                ReleaseObj(pHNetConn);

                if (SUCCEEDED(hr))
                {
                    //
                    // Copy retrieved properties to member structure.
                    //

                    CopyMemory(
                        reinterpret_cast<PVOID>(&m_HNetProperties),
                        reinterpret_cast<PVOID>(pProps),
                        sizeof(m_HNetProperties)
                        );

                    CoTaskMemFree(pProps);

                    //
                    // Update our era, and note that we have valid properties
                    //

                    InterlockedExchange(&m_lHNetModifiedEra, g_lHNetModifiedEra);
                    m_fHNetPropertiesCached = TRUE;

                    hr = S_OK;
                }
            }
            else
            {
                //
                // If we don't yet have a record of this connection w/in the
                // home networking store, HrGetIHNetConnection will fail (as
                // we ask it not to create new entries). We therefore convert
                // failure to S_FALSE, which means we can't retrieve this info
                // right now.
                //

                hr = S_FALSE;
            }

            //
            // We're no longer updating our properties
            //

            InterlockedExchange(&m_lUpdatingHNetProperties, 0);
        }
        else
        {
            //
            // Update is alredy going on (possibly an earlier call on
            // the same thread). Return S_FALSE.
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CRasConnectionBase::HrGetIHNetConnection (
    IHNetConnection **ppHNetConnection)
{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    GUID guid;

    Assert(ppHNetConnection);

    hr = HrGetHNetCfgMgr(&pCfgMgr);

    if (SUCCEEDED(hr))
    {
        guid = GuidId();

        hr = pCfgMgr->GetIHNetConnectionForGuid(
                &guid,
                FALSE,
                FALSE,
                ppHNetConnection
                );

        ReleaseObj(pCfgMgr);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CRasConnectionBase::HrIsConnectionFirewalled(
    BOOL* pfFirewalled)
{
    *pfFirewalled = FALSE;

    HRESULT hr = S_OK;
    BOOL fHasPermission = FALSE;
    
    hr = HrEnsureValidNlaPolicyEngine();
    TraceError("CRasConnectionBase::HrIsConnectionFirewalled calling HrEnsureValidNlaPolicyEngine", hr);

    if (SUCCEEDED(hr))
    {
        // A Connection is only firewalled if the firewall is currently running, so
        // we return FALSE if the permission denies the firewall from running.
        hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_PersonalFirewallConfig, &fHasPermission);
        if (SUCCEEDED(hr) && fHasPermission)
        {
            hr = HrEnsureHNetPropertiesCached();
        
            if (S_OK == hr)
            {
                *pfFirewalled = m_HNetProperties.fFirewalled;
            }
        }
    }
    
    return hr;
}

HRESULT CRasConnectionBase::HrEnsureValidNlaPolicyEngine()
{
    HRESULT hr = S_FALSE;  // Assume we already have the object
    
    if (!m_pNetMachinePolicies)
    {
        hr = CoCreateInstance(CLSID_NetGroupPolicies, NULL, CLSCTX_INPROC, IID_INetMachinePolicies, reinterpret_cast<void**>(&m_pNetMachinePolicies));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\conobs\saconob.cpp ===
#include "pch.h"
#pragma hdrstop

#include "nccom.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "saconob.h"
static const CLSID CLSID_SharedAccessConnectionUi =
    {0x7007ACD5,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

static const WCHAR c_szConnName[]                 = L"Name";
static const WCHAR c_szShowIcon[]                 = L"ShowIcon";
static const WCHAR c_szSharedAccessClientKeyPath[] = L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection";

#define UPNP_ACTION_HRESULT(lError) (UPNP_E_ACTION_SPECIFIC_BASE + (lError - FAULT_ACTION_SPECIFIC_BASE))


CSharedAccessConnection::CSharedAccessConnection()
{
    m_pSharedAccessBeacon = NULL;
    m_pWANConnectionService = NULL;
}

HRESULT CSharedAccessConnection::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    ISharedAccessBeaconFinder* pBeaconFinder;
    hr = HrCreateInstance(CLSID_SharedAccessConnectionManager, CLSCTX_SERVER, &pBeaconFinder);
    if(SUCCEEDED(hr))
    {
        hr = pBeaconFinder->GetSharedAccessBeacon(NULL, &m_pSharedAccessBeacon);
        if(SUCCEEDED(hr))
        {
            NETCON_MEDIATYPE MediaType;
            hr = m_pSharedAccessBeacon->GetMediaType(&MediaType);
            if(SUCCEEDED(hr))
            {
                hr = m_pSharedAccessBeacon->GetService(NCM_SHAREDACCESSHOST_LAN == MediaType ? SAHOST_SERVICE_WANIPCONNECTION : SAHOST_SERVICE_WANPPPCONNECTION, &m_pWANConnectionService);
            }
        }
        pBeaconFinder->Release();
    }
    return hr;
}

HRESULT CSharedAccessConnection::FinalRelease()
{
    HRESULT hr = S_OK;
    
    if(NULL != m_pSharedAccessBeacon)
    {
        m_pSharedAccessBeacon->Release();
    }

    if(NULL != m_pWANConnectionService)
    {
        m_pWANConnectionService->Release();
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetConnectionName
//
//  Purpose:    Initializes the connection object for the first time.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is only called when the object is created for
//              the very first time and has no identity.
//
HRESULT CSharedAccessConnection::GetConnectionName(LPWSTR* pName)
{
    HRESULT     hr = S_OK;
    
    HKEY hKey;
    
    // first get the user assigned name
    
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_READ, &hKey);
    if(SUCCEEDED(hr))
    {
        tstring strName;
        hr = HrRegQueryString(hKey, c_szConnName, &strName);
        if (SUCCEEDED(hr))
        {
            hr = HrCoTaskMemAllocAndDupSz (strName.c_str(), pName);
        }
        RegCloseKey(hKey);
    }

    // if that doesn't exist, construct the name
    
    if(FAILED(hr))
    {
        IUPnPService* pOSInfoService;
        hr = m_pSharedAccessBeacon->GetService(SAHOST_SERVICE_OSINFO, &pOSInfoService);
        if(SUCCEEDED(hr))
        {
            BSTR MachineName;
            hr = GetStringStateVariable(pOSInfoService, L"OSMachineName", &MachineName);
            if(SUCCEEDED(hr))
            {
                BSTR SharedAdapterName;
                hr = GetStringStateVariable(m_pWANConnectionService, L"X_Name", &SharedAdapterName);
                if(SUCCEEDED(hr))
                {
                    LPWSTR szNameString;
                    LPCWSTR szTemplateString = SzLoadIds(IDS_SHAREDACCESS_CONN_NAME);
                    Assert(NULL != szTemplateString);
                    
                    LPOLESTR pszParams[] = {SharedAdapterName, MachineName};
                    
                    if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szTemplateString, 0, 0, reinterpret_cast<LPWSTR>(&szNameString), 0, reinterpret_cast<va_list *>(pszParams)))
                    {
                        HrCoTaskMemAllocAndDupSz (szNameString, pName);
                        LocalFree(szNameString);
                    } 
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    SysFreeString(SharedAdapterName);
                }
                SysFreeString(MachineName);
            }
            pOSInfoService->Release();
        }
        
    }
    
    // if that fails, use the default

    if(FAILED(hr))
    {
        hr = HrCoTaskMemAllocAndDupSz (SzLoadIds(IDS_SHAREDACCESS_DEFAULT_CONN_NAME), pName);
    }

    TraceError("CSharedAccessConnection::HrInitialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetStatus
//
//  Purpose:    Returns the status of this ICS connection
//
//  Arguments:
//      pStatus [out]   Returns status value
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
HRESULT CSharedAccessConnection::GetStatus(NETCON_STATUS *pStatus)
{
    HRESULT hr = S_OK;

    if (!pStatus)
    {
        hr = E_POINTER;
    }
    else
    {   
        BSTR ConnectionStatus;
        hr = GetStringStateVariable(m_pWANConnectionService, L"ConnectionStatus", &ConnectionStatus);
        if(SUCCEEDED(hr))
        {
            if(0 == lstrcmp(ConnectionStatus, L"Connected"))
            {
                *pStatus = NCS_CONNECTED;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Disconnected"))
            {
                *pStatus = NCS_DISCONNECTED;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Unconfigured"))
            {
                *pStatus = NCS_HARDWARE_DISABLED; // REVIEW: better state?
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Connecting"))
            {
                *pStatus = NCS_CONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Authenticating"))
            {
                *pStatus = NCS_CONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"PendingDisconnect"))
            {
                *pStatus = NCS_DISCONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Disconnecting"))
            {
                *pStatus = NCS_DISCONNECTING;
            }
            else 
            {
                *pStatus = NCS_HARDWARE_DISABLED;
            }
            SysFreeString(ConnectionStatus);
        }
    }

    TraceError("CSharedAccessConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetCharacteristics
//
//  Purpose:    Returns the characteristics of this connection type
//
//  Arguments:
//      pdwFlags [out]    Returns characteristics flags
//
//  Returns:    S_OK if successful, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
HRESULT CSharedAccessConnection::GetCharacteristics(DWORD* pdwFlags)
{
    Assert (pdwFlags);

    // TODO when get have a place to save the name, allow rename
    HRESULT hr = S_OK;

    *pdwFlags = NCCF_ALL_USERS | NCCF_ALLOW_RENAME; // REVIEW always ok, group policy?

    HKEY hKey;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_QUERY_VALUE, &hKey);
    if(SUCCEEDED(hr))
    {
        DWORD dwShowIcon = 0;
        DWORD dwSize = sizeof(dwShowIcon);
        DWORD dwType;
        hr = HrRegQueryValueEx(hKey, c_szShowIcon, &dwType, reinterpret_cast<LPBYTE>(&dwShowIcon), &dwSize);  
        if(SUCCEEDED(hr) && REG_DWORD == dwType)
        {
            if(0 != dwShowIcon)
            {
                *pdwFlags |= NCCF_SHOW_ICON;
            }
        }
        RegCloseKey(hKey);

    }
    
    hr = S_OK; // it's ok if the key doesn't exist
    
    TraceError("CSharedAccessConnection::GetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Connect
//
//  Purpose:    Connects the remote ICS host
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//

HRESULT CSharedAccessConnection::Connect()
{
    HRESULT hr = S_OK;
    
    VARIANT OutArgs;
    hr = InvokeVoidAction(m_pWANConnectionService, L"RequestConnection", &OutArgs);
    if(UPNP_ACTION_HRESULT(800) == hr)
    {
        hr = E_ACCESSDENIED;
        VariantClear(&OutArgs);
    }
    
    TraceError("CSharedAccessConnection::Connect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Disconnect
//
//  Purpose:    Disconnects the remote ICS host
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//

HRESULT CSharedAccessConnection::Disconnect()
{
    HRESULT hr = S_OK;
    
    VARIANT OutArgs;
    hr = InvokeVoidAction(m_pWANConnectionService, L"ForceTermination", &OutArgs);
    if(UPNP_ACTION_HRESULT(800) == hr)
    {
        hr = E_ACCESSDENIED;
        VariantClear(&OutArgs);
    }
    
    TraceError("CSharedAccessConnection::Disconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Delete
//
//  Purpose:    Delete the remote ICS connection.  This not allowed.
//
//  Arguments:
//      (none)
//
//  Returns:    E_FAIL;
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is not expected to ever be called.
//

HRESULT CSharedAccessConnection::Delete()
{
    return E_FAIL; // can't delete the beacon
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Duplicate
//
//  Purpose:    Duplicates the remote ICS connection.  This not allowed.
//
//  Arguments:
//      (none)
//
//  Returns:    E_UNEXPECTED;
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is not expected to ever be called.
//

STDMETHODIMP CSharedAccessConnection::Duplicate (
    PCWSTR             pszDuplicateName,
    INetConnection**    ppCon)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetProperties (
    NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES), reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            pProps->guidId = CLSID_SharedAccessConnection; // there is only ever one beacon icon, so we'll just use our class id.  
                                                           // we can't use all zeroes because the add connection wizard does that
            
            // pszwName
            //

            hrT = GetConnectionName(&pProps->pszwName);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            hrT = HrCoTaskMemAllocAndDupSz (pProps->pszwName, &pProps->pszwDeviceName); // TODO the spec says the same as pszwName here, is that right
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            if(NULL != m_pSharedAccessBeacon)
            {
                hr = m_pSharedAccessBeacon->GetMediaType(&pProps->MediaType);
            }
            else
            {
                hr = E_UNEXPECTED;
            }

            hrT = GetCharacteristics (&pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_SharedAccessConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_SharedAccessConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CLanConnection::GetProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetUiObjectClassId
//
//  Purpose:    Returns the CLSID of the object that handles UI for this
//              connection type
//
//  Arguments:
//      pclsid [out]    Returns CLSID of UI object
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetUiObjectClassId(CLSID *pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_SharedAccessConnectionUi;
    }

    TraceError("CLanConnection::GetUiObjectClassId", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Rename
//
//  Purpose:    Changes the name of the connection
//
//  Arguments:
//      pszName [in]     New connection name (must be valid)
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Rename(PCWSTR pszName)
{
    HRESULT     hr = S_OK;

    if (!pszName)
    {
        hr = E_POINTER;
    }
    else if (!FIsValidConnectionName(pszName))
    {
        // Bad connection name
        hr = E_INVALIDARG;
    }
    else
    {

        HKEY hKey;
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_SET_VALUE, NULL, &hKey, NULL);
        if(SUCCEEDED(hr))
        {
            hr = HrRegSetSz(hKey, c_szConnName, pszName); 
            if (S_OK == hr)
            {
                INetConnectionRefresh* pNetConnectionRefresh;
                hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                if(SUCCEEDED(hr))
                {
                    pNetConnectionRefresh->ConnectionRenamed(this);
                    pNetConnectionRefresh->Release();
                }
            }
                
        }
    }

    TraceError("CLanConnection::Rename", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetClassID
//
//  Purpose:    Returns the CLSID of connection objects
//
//  Arguments:
//      pclsid [out]    Returns CLSID to caller
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetClassID(CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_SharedAccessConnection; // we just use our guid since there is only ever one saconob
    }
    TraceError("CSharedAccessConnection::GetClassID", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetSizeMax
//
//  Purpose:    Returns the maximum size of the persistence data
//
//  Arguments:
//      pcbSize [out]   Returns size
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetSizeMax(ULONG *pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else
    {
        *pcbSize = sizeof(GUID);
    }

    TraceError("CLanConnection::GetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Load
//
//  Purpose:    Allows the connection object to initialize (restore) itself
//              from previously persisted data
//
//  Arguments:
//      pbBuf  [in]     Private data to use for restoring
//      cbSize [in]     Size of data
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Load(const BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize != sizeof(GUID))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = S_OK; // we don't need this guid, but we have to implemenet IPersistNetConnection
    }

    TraceError("CLanConnection::Load", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Save
//
//  Purpose:    Provides the caller with data to use in restoring this object
//              at a later time.
//
//  Arguments:
//      pbBuf  [out]    Returns data to use for restoring
//      cbSize [in]     Size of data buffer
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Save(BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else
    {
        CopyMemory(pbBuf, &CLSID_SharedAccessConnection, cbSize); // REVIEW can we eliminate this?
    }

    TraceError("CLanConnection::Save", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetInfo
//
//  Purpose:    Returns information about this connection
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to return. Use
//                          SACIF_ALL to get all fields.
//      pLanConInfo [out]   Structure that holds returned information
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   6 Sep 2000
//
//  Notes:      Caller should delete the szwConnName value.
//
STDMETHODIMP CSharedAccessConnection::GetInfo(DWORD dwMask, SHAREDACCESSCON_INFO* pConInfo)
{
    HRESULT     hr = S_OK;

    if (!pConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory(pConInfo, sizeof(SHAREDACCESSCON_INFO));

        if (dwMask & SACIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                DWORD dwValue;

                // OK if value not there. Default to FALSE always.
                //
                
                HKEY hKey;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_QUERY_VALUE, &hKey);
                if(SUCCEEDED(hr))
                {
                    if (S_OK == HrRegQueryDword(hKey, c_szShowIcon, &dwValue))
                    {
                        pConInfo->fShowIcon = !!(dwValue);
                    }
                    RegCloseKey(hKey);
                }
            }
        }
    }

    // Mask S_FALSE if it slipped thru.
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CSharedAccessConnection::GetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::SetInfo
//
//  Purpose:    Sets information about this connection.
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to set
//      pConInfo [in]    Structure containing information to set
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   6 Sep 2000
//

STDMETHODIMP CSharedAccessConnection::SetInfo(DWORD dwMask,
                                     const SHAREDACCESSCON_INFO* pConInfo)
{
    HRESULT     hr = S_OK;

    if (!pConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        if (dwMask & SACIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                // Set ShowIcon value
                HKEY hKey;
                hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_SET_VALUE, NULL, &hKey, NULL);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegSetDword(hKey, c_szShowIcon, pConInfo->fShowIcon);
                    RegCloseKey(hKey);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            INetConnectionRefresh* pNetConnectionRefresh;
            hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
            if(SUCCEEDED(hr))
            {
                pNetConnectionRefresh->ConnectionModified(this);
                pNetConnectionRefresh->Release();
            }
        }
    }

    TraceError("CSharedAccessConnection::SetInfo", hr);
    return hr;
}


HRESULT CSharedAccessConnection::GetLocalAdapterGUID(GUID* pGuid)
{
    return m_pSharedAccessBeacon->GetLocalAdapterGUID(pGuid);
}

HRESULT CSharedAccessConnection::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    return m_pSharedAccessBeacon->GetService(ulService, ppService);
}

HRESULT CSharedAccessConnection::GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;
    
    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName; 
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        
        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }
        
        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnection::GetStringStateVariable");

    return hr;

}

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        SAFEARRAYBOUND  rgsaBound[1];
        SAFEARRAY       * psa = NULL;

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

        if (psa)
        {
            LONG    lStatus;
            VARIANT varInArgs;
            VARIANT varReturnVal;

            VariantInit(&varInArgs);
            VariantInit(pOutParams);
            VariantInit(&varReturnVal);

            varInArgs.vt = VT_VARIANT | VT_ARRAY;

            V_ARRAY(&varInArgs) = psa;

            hr = pService->InvokeAction(bstrActionName,
                                        varInArgs,
                                        pOutParams,
                                        &varReturnVal);
            if(SUCCEEDED(hr))
            {
                VariantClear(&varReturnVal);
            }

            SafeArrayDestroy(psa);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }   

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nmbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for netman.dll
//
//  Notes:
//
//  Author:     shaunco   3 Apr 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nmres.h"
#include "ncreg.h"
#include "regkysec.h"

#define INITGUID
#include "nmclsid.h"
#include "..\conman\conman.h"

static const REGENTRY c_RegEntryEAPOL[3] = { {  L"System\\CurrentControlSet\\Services\\Eventlog\\Application\\EAPOL", L"EventMessageFile", 
                                                REG_EXPAND_SZ, 0, L"%SystemRoot%\\System32\\wzcsvc.dll", NULL, 0, TRUE },
                                             {  L"System\\CurrentControlSet\\Services\\Eventlog\\Application\\EAPOL", L"TypesSupported", 
                                                REG_DWORD, 0x7, NULL, NULL, 0, FALSE },
                                             {  L"Software\\Microsoft\\EAPOL", L"",
                                                REG_NONE, 0, NULL, NULL, 0, FALSE }};

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls (hinst);
        InitializeDebugging();
        _Module.DllProcessAttach (hinst);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netman.dll", _Module.GetLockCount());
        _Module.DllProcessDetach ();
        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by the generic service process when starting
//                this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
EXTERN_C
VOID
WINAPI
ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    _Module.ServiceMain (argc, argv);
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL    fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        _Module.UpdateRegistryFromResource (IDR_NETMAN, TRUE);

        hr = NcAtlModuleRegisterServer (&_Module);

        hr = RegisterSvrHelper();

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netman!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
    _Module.UpdateRegistryFromResource (IDR_NETMAN, FALSE);

    _Module.UnregisterServer ();

    return S_OK;
}



//+---------------------------------------------------------------------------
// RegisterSvrHelper - Sets up registry keys and other information.
//
STDAPI
RegisterSvrHelper()
{
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;
    PSID psidLocalService = NULL;
    PSID psidNetworkService = NULL;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;

    hr = CreateEAPOLKeys();

    if(SUCCEEDED(hr))
    {
        if (AllocateAndInitializeSid(&sidAuth, 1, SECURITY_LOCAL_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &psidLocalService))
        {
            hr = SetKeySecurity(2, psidLocalService, KEY_READ_WRITE_DELETE);

            if (SUCCEEDED(hr))
            {
                if (AllocateAndInitializeSid(&sidAuth, 1, SECURITY_NETWORK_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &psidNetworkService))
                {
                    hr = SetKeySecurity(2, psidNetworkService, KEY_READ_WRITE_DELETE);
                    FreeSid(psidNetworkService);
                }
                else
                {
                    dwErr = GetLastError();
                }
            }
            FreeSid(psidLocalService);
        }
        else
        {
            dwErr = GetLastError();
        }

        if (dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
// CreateEAPOLKeys - Creates the entries required by EAPOL
//
STDAPI
CreateEAPOLKeys()
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;

    // Need to write: HKLM\System\CurrentControlSet\Services\Eventlog\System\EAPOL
    //		EventMessageFile    -   REG_EXPAND_SZ: %SystemRoot%\System32\netman.dll
	//	    TypesSupported      -   REG_DWORD 0x07

    for (int i = 0; i < celems(c_RegEntryEAPOL); i++)
    {
        if (hKey == NULL)
        {
            DWORD dwRet;
            dwRet = RegCreateKey(HKEY_LOCAL_MACHINE, c_RegEntryEAPOL[i].strKeyName, &hKey);
            hr = HRESULT_FROM_WIN32(dwRet);
        }

        if (SUCCEEDED(hr))
        {
            switch (c_RegEntryEAPOL[i].dwType)
            {
            case REG_NONE:
                break;
            case REG_SZ:
            case REG_MULTI_SZ:
            case REG_EXPAND_SZ:
                hr = HrRegSetValueEx(hKey, c_RegEntryEAPOL[i].strValueName, c_RegEntryEAPOL[i].dwType, reinterpret_cast<BYTE*>(c_RegEntryEAPOL[i].strValue), (wcslen(c_RegEntryEAPOL[i].strValue) + 1) * sizeof(WCHAR));
                break;
            case REG_BINARY:
                hr = HrRegSetValueEx(hKey, c_RegEntryEAPOL[i].strValueName, c_RegEntryEAPOL[i].dwType, reinterpret_cast<BYTE*>(c_RegEntryEAPOL[i].pbValue), c_RegEntryEAPOL[i].dwBinLen);
                break;
            case REG_DWORD:
                hr = HrRegSetValueEx(hKey, c_RegEntryEAPOL[i].strValueName, c_RegEntryEAPOL[i].dwType, reinterpret_cast<const BYTE*>(&(c_RegEntryEAPOL[i].dwValue)), sizeof(c_RegEntryEAPOL[i].dwValue));
                break;
            }
        }

        if (!c_RegEntryEAPOL[i].fMoreOnKey)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
// CreateEAPOLKeys - Creates the entries required by EAPOL
//
STDAPI
SetKeySecurity(DWORD dwKeyIndex, PSID psidUserOrGroup, ACCESS_MASK dwAccessMask)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD dwErr = 0;
    CRegKeySecurity rkSec;

    hr = rkSec.RegOpenKey(HKEY_LOCAL_MACHINE, c_RegEntryEAPOL[dwKeyIndex].strKeyName);

    if (SUCCEEDED(hr))
    {
        hr = rkSec.GetKeySecurity();
        if (SUCCEEDED(hr))
        {
            hr = rkSec.GrantRightsOnRegKey(psidUserOrGroup, dwAccessMask, KEY_ALL);
            if (SUCCEEDED(hr))
            {
                hr = rkSec.SetKeySecurity();
            }
        }
        rkSec.RegCloseKey();
    }
    else
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    
    return hr;
}

HRESULT 
GetClientAdvises(LPWSTR** pppszAdviseUsers, LPDWORD pdwCount)
{
    HRESULT hr = S_OK;

    if ( (!pppszAdviseUsers) || (!pdwCount) )
    {
        return E_POINTER;
    }

    CConnectionManager *pConMan = const_cast<CConnectionManager*>(CConnectionManager::g_pConMan);
    if (!pConMan)
    {
        return E_UNEXPECTED;
    }

    DWORD dwTotalLength = 0;
    DWORD dwNumItems    = 0;

    list<tstring> NameList;
    pConMan->g_fInUse = TRUE;
    pConMan->Lock();
    for (ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.begin(); iter != pConMan->m_mapNotify.end(); iter++)
    {
        tstring szName = iter->second->szUserName;

        NameList.push_back(szName);
        dwTotalLength += sizeof(WCHAR) * (szName.length() + 1);
        dwNumItems++;
    }
    pConMan->Unlock();
    pConMan->g_fInUse = FALSE;

    if (!dwNumItems)
    {
        *pppszAdviseUsers = NULL;
        *pdwCount = 0;
        return S_FALSE;
    }

    DWORD dwAllocSize = dwNumItems * sizeof(LPCWSTR) + dwTotalLength;
    *pppszAdviseUsers = reinterpret_cast<LPWSTR *>(CoTaskMemAlloc(dwAllocSize));
    if (!*pppszAdviseUsers)
    {
        return E_OUTOFMEMORY;
    }
    
    LPWSTR  pszEndString     = reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(*pppszAdviseUsers) + dwAllocSize);
    
    // First string in the structure
    LPWSTR  pszCurrentString = reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(*pppszAdviseUsers) + (sizeof(LPWSTR) * dwNumItems));
    // First pointer in the structure
    LPWSTR* lppArray         = *pppszAdviseUsers;
    
    for (list<tstring>::const_iterator iterName = NameList.begin(); iterName != NameList.end(); iterName++)
    {
        *lppArray = pszCurrentString;
        wcscpy(pszCurrentString, iterName->c_str());

        lppArray++;
        pszCurrentString += (iterName->size() + 1);
        Assert(pszCurrentString <= pszEndString);
    }

    *pdwCount = dwNumItems;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\makefile.inc ===
$(O)\eapolmsg.mc: eapollog.h
    mapmsg EAPOL EAPOL_LOG_BASE eapollog.h > $(O)\eapolmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eapoldlg.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\wsdpsvc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       W S D P S V C . H
//
//  Contents:   Start/stop Winsock Direct Path Service.
//
//  Notes:      The service is actually implemented in MS TCP Winsock provider
//
//  Author:     VadimE   24 Jan 2000
//
//----------------------------------------------------------------------------
#pragma once

VOID
StartWsdpService (
    VOID
    );

VOID
StopWsdpService (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Manager"
#define VER_INTERNALNAME_STR            "netman.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\nminit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M I N I T . C P P
//
//  Contents:   Initialization routines for netman.
//
//  Notes:
//
//  Author:     shaunco   27 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nminit.h"

static const WCHAR c_szClassObjectRegistrationEvent [] =
    L"NetmanClassObjectRegistrationEvent";

//+---------------------------------------------------------------------------
//
//  Function:   HrNmCreateClassObjectRegistrationEvent
//
//  Purpose:    Create the named event that will be signaled after
//              our class objects have been registered.
//
//  Arguments:
//      phEvent [out] Returned event handle
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmCreateClassObjectRegistrationEvent (
    HANDLE* phEvent)
{
    Assert (phEvent);

    HRESULT hr = S_OK;

    // Create the name event and return it.
    //
    *phEvent = CreateEvent (NULL, FALSE, FALSE,
                    c_szClassObjectRegistrationEvent);
    if (!*phEvent)
    {
        hr = HrFromLastWin32Error ();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmCreateClassObjectRegistrationEvent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNmWaitForClassObjectsToBeRegistered
//
//  Purpose:    For the event to be signaled if it can be opened.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmWaitForClassObjectsToBeRegistered ()
{
    HRESULT hr = S_OK;

    // Try to open the named event.  If it does not exist,
    // that's okay because we've probably already created and destroyed
    // it before this function was called.
    //
    HANDLE hEvent = OpenEvent (SYNCHRONIZE, FALSE,
                        c_szClassObjectRegistrationEvent);
    if (hEvent)
    {
        // Now wait for the event to be signaled while pumping messages
        // as needed.  We'll wait for up to 10 seconds.  That should be
        // plenty of time for the class objects to be registered.
        //
        while (1)
        {
            const DWORD cMaxWaitMilliseconds = 10000;   // 10 seconds

            DWORD dwWait = MsgWaitForMultipleObjects (1, &hEvent, FALSE,
                                cMaxWaitMilliseconds, QS_ALLINPUT);
            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                // Wait is satisfied, or we had a timeout, or an error.
                //
                if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else if (0xFFFFFFFF == dwWait)
                {
                    hr = HrFromLastWin32Error ();
                }

                break;
            }
        }

        CloseHandle (hEvent);
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmWaitForClassObjectsToBeRegistered");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\svcmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       S V C M A I N . C P P
//
//  Contents:   Service main for netman.dll
//
//  Notes:
//
//  Author:     shaunco   3 Apr 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <dbt.h>
#include "nmbase.h"
#include "nminit.h"
#include "nmres.h"
#include "eapolfunc.h"

#include "wsdpsvc.h"

#undef EAPOL_LINKED

// Includes for COM objects needed in the following object map.
//

// Connection Manager
//
#include "..\conman\conman.h"
#include "..\conman\conman2.h"
#include "..\conman\enum.h"

// Connection Class Managers
//
#include "..\conman\conmani.h"
#include "..\conman\conmanl.h"
#include "..\conman\conmansa.h"
#include "..\conman\conmanw.h"
#include "..\conman\enumi.h"
#include "..\conman\enuml.h"
#include "..\conman\enumsa.h"
#include "..\conman\enumw.h"

// Connection Objects
//
#include "dialup.h"
#include "inbound.h"
#include "lan.h"
#include "saconob.h"

// Install queue
//
#include "ncqueue.h"

// Home networking support
//
#include "nmhnet.h"

// NetGroupPolicies
#include "nmpolicy.h"

#define INITGUID
DEFINE_GUID(CLSID_InternetConnectionBeaconService,0x04df613a,0x5610,0x11d4,0x9e,0xc8,0x00,0xb0,0xd0,0x22,0xdd,0x1f);
// TODO Remove this when we have proper idl

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)

// Connection Manager
//
    OBJECT_ENTRY(CLSID_ConnectionManager,                       CConnectionManager)
    OBJECT_ENTRY(CLSID_ConnectionManagerEnumConnection,         CConnectionManagerEnumConnection)


// Connection Manager2
    OBJECT_ENTRY(CLSID_ConnectionManager2,                       CConnectionManager2)

// Connection Class Managers
//
    OBJECT_ENTRY(CLSID_InboundConnectionManager,                CInboundConnectionManager)
    OBJECT_ENTRY(CLSID_InboundConnectionManagerEnumConnection,  CInboundConnectionManagerEnumConnection)
    OBJECT_ENTRY(CLSID_LanConnectionManager,                    CLanConnectionManager)
    OBJECT_ENTRY(CLSID_LanConnectionManagerEnumConnection,      CLanConnectionManagerEnumConnection)
    OBJECT_ENTRY(CLSID_WanConnectionManager,                    CWanConnectionManager)
    OBJECT_ENTRY(CLSID_WanConnectionManagerEnumConnection,      CWanConnectionManagerEnumConnection)
    OBJECT_ENTRY(CLSID_SharedAccessConnectionManager,           CSharedAccessConnectionManager)
    OBJECT_ENTRY(CLSID_SharedAccessConnectionManagerEnumConnection, CSharedAccessConnectionManagerEnumConnection)

// Connection Objects
//
    OBJECT_ENTRY(CLSID_DialupConnection,                        CDialupConnection)
    OBJECT_ENTRY(CLSID_InboundConnection,                       CInboundConnection)
    OBJECT_ENTRY(CLSID_LanConnection,                           CLanConnection)
    OBJECT_ENTRY(CLSID_SharedAccessConnection,                  CSharedAccessConnection)

// Install queue
//
    OBJECT_ENTRY(CLSID_InstallQueue,                            CInstallQueue)

// Home networking support
//
    OBJECT_ENTRY(CLSID_NetConnectionHNetUtil,                   CNetConnectionHNetUtil)

// NetGroupPolicies
    OBJECT_ENTRY(CLSID_NetGroupPolicies,                        CNetMachinePolicies)

END_OBJECT_MAP()


VOID
CServiceModule::DllProcessAttach (
    HINSTANCE hinst)
{
    CComModule::Init (ObjectMap, hinst);
}

VOID
CServiceModule::DllProcessDetach (
    VOID)
{
    CComModule::Term ();
}

DWORD
CServiceModule::DwHandler (
    DWORD dwControl,
    DWORD dwEventType,
    PVOID pEventData,
    PVOID pContext)
{
    if (SERVICE_CONTROL_STOP == dwControl)
    {
        HRESULT hr;

        TraceTag (ttidConman, "Received SERVICE_CONTROL_STOP request");

        SetServiceStatus (SERVICE_STOP_PENDING);

        hr = ServiceShutdown();
    }

    else if (SERVICE_CONTROL_INTERROGATE == dwControl)
    {
        TraceTag (ttidConman, "Received SERVICE_CONTROL_INTERROGATE request");
        UpdateServiceStatus (FALSE);
    }

    else if ((SERVICE_CONTROL_DEVICEEVENT == dwControl) && pEventData)
    {
        DEV_BROADCAST_DEVICEINTERFACE* pInfo =
                (DEV_BROADCAST_DEVICEINTERFACE*)pEventData;

        if (DBT_DEVTYP_DEVICEINTERFACE == pInfo->dbcc_devicetype)
        {
            if (DBT_DEVICEARRIVAL == dwEventType)
            {
                TraceTag (ttidConman, "Device arrival: [%S]",
                    pInfo->dbcc_name);

                LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
            }
            else if (DBT_DEVICEREMOVECOMPLETE == dwEventType)
            {
                GUID guidAdapter = GUID_NULL;
                WCHAR szGuid[MAX_PATH];
                WCHAR szTempName[MAX_PATH];
                WCHAR* szFindGuid;

                TraceTag (ttidConman, "Device removed: [%S]",
                    pInfo->dbcc_name);

                szFindGuid = wcsrchr(pInfo->dbcc_name, L'{');
                if (szFindGuid)
                {
                    wcscpy(szGuid, szFindGuid);
                    IIDFromString(szGuid, &guidAdapter);
                }

                if (!IsEqualGUID(guidAdapter, GUID_NULL))
                {
                    CONMAN_EVENT* pEvent;

                    pEvent = new CONMAN_EVENT;
                 
                    if (pEvent)
                    {
                        pEvent->ConnectionManager = CONMAN_LAN;
                        pEvent->guidId = guidAdapter;
                        pEvent->Type = CONNECTION_STATUS_CHANGE;
                        pEvent->Status = NCS_DISCONNECTED;

                        if (!QueueUserWorkItemInThread(LanEventWorkItem, reinterpret_cast<LPVOID>(pEvent), EVENTMGR_CONMAN))
                        {
                            FreeConmanEvent(pEvent);
                        }
                    }
                }
                else
                {
                    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
                }
            }
        }

#ifdef EAPOL_LINKED
        TraceTag (ttidConman, "Calling EAPOL ElDeviceNotificationHandler");

        DWORD dwRetCode = NO_ERROR;

        if ((dwRetCode = ElDeviceNotificationHandler (
                            pEventData, dwEventType)) != NO_ERROR)
        {
            TraceTag (ttidConman, "ElDeviceNotificationHandler failed with error %ld",
                    dwRetCode);
        }
            
        TraceTag (ttidConman, "EAPOL ElDeviceNotificationHandler completed");
#endif

    }

    return 1;
}

VOID
CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    m_status.dwCheckPoint   = 0;
    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::SetServiceStatus");
    }
}

VOID CServiceModule::UpdateServiceStatus (
    BOOL fUpdateCheckpoint /* = TRUE */)
{
    if (fUpdateCheckpoint)
    {
        m_status.dwCheckPoint++;
    }

    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::UpdateServiceStatus");
    }
}

VOID
CServiceModule::Run()
{
    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
        "CoInitializeEx failed");

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidConman, "Calling RegisterClassObjects...");

        // Create the event to sychronize registering our class objects
        // with the connection manager which attempts to CoCreate
        // objects which are also registered here.  I've seen cases
        // where the connection manager will be off and running before
        // this completes causing CoCreateInstance to fail.
        // The connection manager will wait on this event before
        // executing CoCreateInstance.
        //
        HANDLE hEvent;
        hr = HrNmCreateClassObjectRegistrationEvent (&hEvent);
        if (SUCCEEDED(hr))
        {
            hr = _Module.RegisterClassObjects (
                    CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                    REGCLS_MULTIPLEUSE);
            TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
                "_Module.RegisterClassObjects failed");

            // Signal the event and close it.  If this delete's the
            // event, so be it. It's purpose is served as all
            // class objects have been registered.
            //
            SetEvent (hEvent);
            CloseHandle (hEvent);
        }

        if (SUCCEEDED(hr))
        {
            hr = ServiceStartup();
        }

        CoUninitialize();
    }

}

VOID
CServiceModule::ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    // Reset the version era for RAS phonebook entry modifications.
    //
    g_lRasEntryModifiedVersionEra = 0;

    m_fRasmanReferenced = FALSE;

    m_dwThreadID = GetCurrentThreadId ();

    ZeroMemory (&m_status, sizeof(m_status));
    m_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    // Register the service control handler.
    //
    m_hStatus = RegisterServiceCtrlHandlerEx (
                    L"netman",
                    _DwHandler,
                    NULL);

    if (m_hStatus)
    {
        SetServiceStatus (SERVICE_START_PENDING);

        // When the Run function returns, the service is running.
        // We now handle shutdown from ServiceShutdown when our DwHandler
        // is called and is passed SERVICE_CONTROL_STOP as the dwControl
        // parameter.  This allows us to terminate our message pump thread
        // which effectively reduces us to 0 threads that we own.
        Run ();
    }
    else
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::ServiceMain - RegisterServiceCtrlHandler failed");
    }
}

// static
DWORD
WINAPI
CServiceModule::_DwHandler (
    DWORD dwControl,
    DWORD dwEventType,
    PVOID pEventData,
    PVOID pContext)
{
    return _Module.DwHandler (dwControl, dwEventType, pEventData, pContext);
}

VOID
CServiceModule::ReferenceRasman (
    RASREFTYPE RefType)
{
    BOOL fRef = (REF_REFERENCE == RefType);

    if (REF_INITIALIZE == RefType)
    {
        Assert (!fRef);

        // RasInitialize implicitly references rasman.
        //
        RasInitialize ();
    }
    // If we need to reference and we're not already,
    // or we need unreference and we're referenced, do the appropriate thing.
    // (This is logical xor.  Quite different than bitwise xor when
    // the two arguments don't neccesarily have the same value for TRUE.)
    //
    else if ((fRef && !m_fRasmanReferenced) ||
            (!fRef && m_fRasmanReferenced))
    {
        RasReferenceRasman (fRef);

        m_fRasmanReferenced = fRef;
    }
}

HRESULT CServiceModule::ServiceStartup()
{
    HRESULT hr = S_OK;

#ifdef EAPOL_LINKED
    //
    // Start EAPOL
    //

    TraceTag (ttidConman, "Starting EAPOL");

    EAPOLServiceMain ( argc, NULL);

    TraceTag (ttidConman, "EAPOL started successfully");
#endif

    StartWsdpService (); // Starts WSDP service on DTC/AdvServer build/
                         // no-op otherwise

    InitializeHNetSupport();

    SetServiceStatus (SERVICE_RUNNING);
    TraceTag (ttidConman, "Netman is now running...");
    
    return hr;
}

HRESULT CServiceModule::ServiceShutdown()
{
    HRESULT hr = S_OK;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        hr = UninitializeEventHandler();

        if (SUCCEEDED(hr))
        {
            CleanupHNetSupport();

            StopWsdpService (); // Stops WSDP service if necessary

            // We must synchronize with the install queue's thread otherwise
            // RevokeClassObjects will kill the InstallQueue object and
            // CoUninitialize will free the NetCfg module before the thread
            // is finished.
            //
            WaitForInstallQueueToExit();

            _Module.RevokeClassObjects ();

            // Unreference rasman now that our service is about to stop.
            //
            _Module.ReferenceRasman (REF_UNREFERENCE);

        #ifdef EAPOL_LINKED
            TraceTag (ttidConman, "Stopping EAPOL");

            EAPOLCleanUp (NO_ERROR);

            TraceTag (ttidConman, "EAPOL stopped successfully");
        #endif

            SetServiceStatus(SERVICE_STOPPED);
        }
        CoUninitialize();
    }

    if (FAILED(hr))
    {
        SetServiceStatus(SERVICE_RUNNING);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\inf\makefile.inc ===
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\eapol.inf: eapol.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\dll\wsdpsvc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       W S D P S V C . C P P
//
//  Contents:   Start/stop Winsock Direct Path Service.
//
//  Notes:      The service is actually implemented in MS TCP Winsock provider
//
//  Author:     VadimE   24 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "wsdpsvc.h"

#define MSTCP_PROVIDER_DLL          TEXT("mswsock.dll")
#define START_WSDP_FUNCTION_NAME    "StartWsdpService"
#define STOP_WSDP_FUNCTION_NAME     "StopWsdpService"

// MS TCP Winsock provider module handle
HINSTANCE   ghMsTcpDll;

// Service start function pointer
typedef INT (WINAPI *PFN_START_WSDP_SVC) (VOID);
PFN_START_WSDP_SVC gpfnStartWsdpSvc;

// Service stop function pointer
typedef VOID (WINAPI *PFN_STOP_WSDP_SVC) (VOID);
PFN_STOP_WSDP_SVC gpfnStopWsdpSvc;


//+---------------------------------------------------------------------------
// StartWsdpService - start WSDP service if running on DTC
//
//
VOID
StartWsdpService (
    VOID
    )
{
    NTSTATUS                status;
    NT_PRODUCT_TYPE         product;

    //
    // First check if we are running Server build
    //
    status = RtlGetNtProductType (&product);
    if (!NT_SUCCESS (status) ||
			 (product == NtProductWinNt)) {
        return;
    }

    //
    // Load MS TCP provider and get WSDP service entry points
    //
    ghMsTcpDll = LoadLibrary (MSTCP_PROVIDER_DLL);
    if (ghMsTcpDll!=NULL) {
        gpfnStartWsdpSvc = (PFN_START_WSDP_SVC) GetProcAddress (
                                ghMsTcpDll,
                                START_WSDP_FUNCTION_NAME);
        gpfnStopWsdpSvc = (PFN_STOP_WSDP_SVC) GetProcAddress (
                                ghMsTcpDll,
                                STOP_WSDP_FUNCTION_NAME);
        if (gpfnStartWsdpSvc != NULL && gpfnStopWsdpSvc != NULL) {
            //
            // Launch the service and return if succeded
            //
            INT err = (*gpfnStartWsdpSvc)();
            if (err==0) {
                return;
            }
        }
        //
        // Cleanup if anything fails
        //
        FreeLibrary (ghMsTcpDll);
        ghMsTcpDll = NULL;
    }
    
}

//+---------------------------------------------------------------------------
// StopWsdpService - stop WSDP service if it was started
//
//
VOID
StopWsdpService (
    VOID
    )
{
    if (ghMsTcpDll!=NULL) {
        //
        // Tell the service to stop and unload the provider
        //
        (*gpfnStopWsdpSvc)();
        FreeLibrary (ghMsTcpDll);
        ghMsTcpDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\parser\eapol.c ===
//============================================================================//
//  MODULE: eapol.c                                                                                                  //
//                                                                                                                 //
//  Description: EAPOL/802.1X Parser                                                                    //
//                                                                                                                 //
//  Note: info for this parsers was gleaned from :
//  IEEE 802.1X
//                                                                                                                 //
//  Modification History                                                                                           //
//                                                                                                                 //
//  timmoore       04/04/2000          Created                                                       //
//===========================================================================//
#include "eapol.h"

// the type of EAPOL packet
LABELED_BYTE lbEAPOLCode[] = 
{
    {  EAPOL_PACKET,          "Packet" },
    {  EAPOL_START,           "Start" },
    {  EAPOL_LOGOFF,          "Logoff"  },
    {  EAPOL_KEY,             "Key"  },       
};

SET EAPOLCodeSET = {(sizeof(lbEAPOLCode)/sizeof(LABELED_BYTE)), lbEAPOLCode };

// property table
PROPERTYINFO EAPOL_Prop[] = {
    //EAPOL_SUMMARY
    { 0, 0,
      "Summary",
      "Summary of EAPOL packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,                     
      EAPOL_FormatSummary   
    },

    //EAPOL_VERSION   
    { 0, 0,
      "Version",
      "EAPOL packet type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_TYPE  
    { 0, 0,
      "Type",
      "EAPOL packet type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &EAPOLCodeSET,
      80,
      FormatPropertyInstance
    },

    //EAPOL_LENGTH
    { 0, 0,
      "Length",
      "EAPOL length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_SIGNTYPE
    { 0, 0,
      "Signature Type",
      "EAPOL Signature Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYTYPE
    { 0, 0,
      "Key Type",
      "EAPOL Key Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYLENGTH
    { 0, 0,
      "Length",
      "EAPOL Key length",
      PROP_TYPE_BYTESWAPPED_WORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_REPLAY
    { 0, 0,
      "Replay",
      "EAPOL Replay Counter",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYIV
    { 0, 0,
      "Key IV",
      "EAPOL Key IV",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYINDEX
    { 0, 0,
      "Index",
      "EAPOL Key Index",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEYSIGN
    { 0, 0,
      "Key Signature",
      "EAPOL Key Signature",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },

    //EAPOL_KEY_KEY
    { 0, 0,
      "Key",
      "EAPOL Key",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      80,
      FormatPropertyInstance
    },
   
};

WORD    NUM_EAPOL_PROPERTIES = sizeof(EAPOL_Prop) / sizeof(PROPERTYINFO);

// Define the entry points that we will pass back at dll entry time...
ENTRYPOINTS EAPOLEntryPoints =
{
    // EAPOL Entry Points
    EAPOL_Register,
    EAPOL_Deregister,
    EAPOL_RecognizeFrame,
    EAPOL_AttachProperties,
    EAPOL_FormatProperties
};
    
// Globals -------------------------------------------------------------------
HPROTOCOL hEAPOL = NULL;
HPROTOCOL hEAP = NULL;

//============================================================================
//  Function: EAPOL_Register
// 
//  Description: Create our property database and handoff sets.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
void BHAPI EAPOL_Register( HPROTOCOL hEAPOL)
{
    WORD  i;

    // tell the kernel to make reserve some space for our property table
    CreatePropertyDatabase( hEAPOL, NUM_EAPOL_PROPERTIES);

    // add our properties to the kernel's database
    for( i = 0; i < NUM_EAPOL_PROPERTIES; i++)
    {
        AddProperty( hEAPOL, &EAPOL_Prop[i]);
    }
    hEAP = GetProtocolFromName("EAP");
}

//============================================================================
//  Function: EAPOL_Deregister
// 
//  Description: Destroy our property database and handoff set
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
VOID WINAPI EAPOL_Deregister( HPROTOCOL hEAPOL)
{
    // tell the kernel that it may now free our database
    DestroyPropertyDatabase( hEAPOL);
}

//============================================================================
//  Function: EAPOL_RecognizeFrame
// 
//  Description: Determine whether we exist in the frame at the spot 
//               indicated. We also indicate who (if anyone) follows us
//               and how much of the frame we claim.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
ULPBYTE BHAPI EAPOL_RecognizeFrame( HFRAME      hFrame,         
                                      ULPBYTE      pMacFrame,      
                                      ULPBYTE      pEAPOLFrame, 
                                      DWORD       MacType,        
                                      DWORD       BytesLeft,      
                                      HPROTOCOL   hPrevProtocol,  
                                      DWORD       nPrevProtOffset,
                                      LPDWORD     pProtocolStatus,
                                      LPHPROTOCOL phNextProtocol,
                                      PDWORD_PTR     InstData)       
{
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)pEAPOLFrame;
    if(pEAPOLHeader->bType == EAPOL_START || pEAPOLHeader->bType == EAPOL_LOGOFF
     || pEAPOLHeader->bType == EAPOL_KEY) {
        *pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
        return NULL;
    }
    else {
        *phNextProtocol = hEAP;
        *pProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;
        return pEAPOLFrame + 4;
    }
}

//============================================================================
//  Function: EAPOL_AttachProperties
// 
//  Description: Indicate where in the frame each of our properties live.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
ULPBYTE BHAPI EAPOL_AttachProperties(  HFRAME      hFrame,         
                                    ULPBYTE      pMacFrame,     
                                    ULPBYTE      pEAPOLFrame,   
                                    DWORD       MacType,        
                                    DWORD       BytesLeft,      
                                    HPROTOCOL   hPrevProtocol,  
                                    DWORD       nPrevProtOffset,
                                    DWORD_PTR       InstData)       

{
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)pEAPOLFrame;

    // summary line
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_SUMMARY].hProperty,
                            (WORD)BytesLeft,
                            (ULPBYTE)pEAPOLFrame,
                            0, 0, 0);

    // Version
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_VERSION].hProperty,
                            sizeof(BYTE),
                            &(pEAPOLHeader->bVersion),
                            0, 1, 0);

    // EAPOL Type
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_TYPE].hProperty,
                            sizeof(BYTE),
                            &(pEAPOLHeader->bType),
                            0, 1, 0);

    // Length
    AttachPropertyInstance( hFrame,
                            EAPOL_Prop[EAPOL_LENGTH].hProperty,
                            sizeof(WORD),
                            &(pEAPOLHeader->wLength),
                            0, 1, 0);

    if(pEAPOLHeader->bType == EAPOL_KEY)
    {
		ULPEAPOLKEY pEAPOLKey = (ULPEAPOLKEY)&(pEAPOLHeader->pEAPPacket[0]);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_SIGNTYPE].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bSignType),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYTYPE].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bKeyType),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYLENGTH].hProperty,
                                    sizeof(WORD),
                                    &(pEAPOLKey->wKeyLength),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYREPLAY].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeyReplay),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYIV].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeyIV),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYINDEX].hProperty,
                                    sizeof(BYTE),
                                    &(pEAPOLKey->bKeyIndex),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEYSIGN].hProperty,
                                    16,
                                    &(pEAPOLKey->bKeySign),
                                    0, 1, 0);
        AttachPropertyInstance( hFrame,
                                    EAPOL_Prop[EAPOL_KEY_KEY].hProperty,
                                    XCHG(pEAPOLKey->wKeyLength),
                                    &(pEAPOLKey->bKey),
                                    0, 1, 0);
    }
    return NULL;
}

//============================================================================
//  Function: EAPOL_FormatProperties
// 
//  Description: Format the given properties on the given frame.
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
DWORD BHAPI EAPOL_FormatProperties(  HFRAME          hFrame,
                                   ULPBYTE          pMacFrame,
                                   ULPBYTE          pEAPOLFrame,
                                   DWORD           nPropertyInsts,
                                   LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }

    return NMERR_SUCCESS;
}

//============================================================================
//  Function: EAPOL_FormatSummary
// 
//  Description: The custom formatter for the summary property
//
//  Modification History
//
//  timmoore       04/04/2000          Created                                                       //
//============================================================================
VOID WINAPIV EAPOL_FormatSummary( LPPROPERTYINST pPropertyInst)
{
    ULPBYTE       pReturnedString = pPropertyInst->szPropertyText;
    ULPEAPHDR pEAPOLHeader = (ULPEAPHDR)(pPropertyInst->lpData);
    char*        szTempString;

    // fetch the message type
    szTempString = LookupByteSetString( &EAPOLCodeSET, pEAPOLHeader->bType );
    if( szTempString == NULL )
    {
        wsprintf( pReturnedString, "Packet Type: Unknown");
    }
    else
    {
        pReturnedString += wsprintf( pReturnedString, "Packet: %s", szTempString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\parser\makefile.inc ===
#
# Copy the ini file next to the parser in the obj dir
#

$(BH_BUILD_ROOT)\$(O)\$(TARGETNAME).ini: $(TARGETNAME).ini
    copy $(TARGETNAME).ini $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\parser\eapol.h ===
//============================================================================//
//  MODULE: eapol.h                                                                                                  //
//                                                                                                                 //
//  Description: EAPOL/802.1X Parser                                                                    //
//                                                                                                                 //
//  Note: info for this parsers was gleaned from :
//  IEEE 802.1X
//                                                                                                                 //
//  Modification History                                                                                           //
//                                                                                                                 //
//  timmoore       04/04/2000           Created                                                       //
//===========================================================================//

#ifndef __EAPOL_H_
#define __EAPOL_H_

#include <windows.h>
#include <netmon.h>
#include <stdlib.h>
#include <string.h>
// #include <parser.h>

// EAPOL Header structure----------------------------------------------------
#pragma pack(1)
typedef struct _EAPHDR 
{
    BYTE bVersion;
    BYTE bType;   // packet type
    WORD wLength;
    BYTE pEAPPacket[0];
} EAPHDR;

typedef EAPHDR UNALIGNED *ULPEAPHDR;

typedef struct _EAPOLKEY
{
	BYTE	bSignType;
	BYTE	bKeyType;
	WORD	wKeyLength;
	BYTE	bKeyReplay[16];
	BYTE	bKeyIV[16];
	BYTE	bKeyIndex;
	BYTE	bKeySign[16];
	BYTE	bKey[0];
} EAPOLKEY;

typedef EAPOLKEY UNALIGNED *ULPEAPOLKEY;

#pragma pack()

// packet types
#define EAPOL_PACKET    0
#define EAPOL_START     1
#define EAPOL_LOGOFF    2
#define EAPOL_KEY       3

// property table indice
typedef enum
{
    EAPOL_SUMMARY,
    EAPOL_VERSION,
    EAPOL_TYPE,
    EAPOL_LENGTH,
    EAPOL_KEY_SIGNTYPE,
    EAPOL_KEY_KEYTYPE,
    EAPOL_KEY_KEYLENGTH,
    EAPOL_KEY_KEYREPLAY,
    EAPOL_KEY_KEYIV,
    EAPOL_KEY_KEYINDEX,
    EAPOL_KEY_KEYSIGN,
    EAPOL_KEY_KEY,
    EAPOL_UNKNOWN,
};

// Functions Prototypes --------------------------------------------------------
extern VOID   WINAPI EAPOL_Register( HPROTOCOL hEAPOL);
extern VOID   WINAPI EAPOL_Deregister( HPROTOCOL hEAPOL);
extern ULPBYTE WINAPI EAPOL_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);
extern ULPBYTE WINAPI EAPOL_AttachProperties(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);
extern DWORD  WINAPI EAPOL_FormatProperties( HFRAME hFrame, 
                                                ULPBYTE pMacFrame, 
                                                ULPBYTE pEAPOLFrame, 
                                                DWORD nPropertyInsts, 
                                                LPPROPERTYINST p);

VOID WINAPIV EAPOL_FormatSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV EAPOL_FormatAttribute( LPPROPERTYINST pPropertyInst);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\parser\eapolint.c ===
//=================================================================================================================//
//  MODULE: eapolinit.c
//
//  Description:
//
//  Attach properties for the BLOODHOUND PPP Parser.
//
//  Modification History
//
//  timmoore       04/04/2000            Created from PPP parser.
//=================================================================================================================//
#include "eapol.h"

extern ENTRYPOINTS EAPOLEntryPoints;
extern HPROTOCOL hEAPOL;

char    IniFile[INI_PATH_LENGTH];

//==========================================================================================================================
//  FUNCTION: DllMain()
//
//  Modification History
//
//  timmoore       04/04/2000            Created from PPP parser.
//==========================================================================================================================
DWORD Attached = 0;

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulCommand, LPVOID lpReserved)
{
    if (ulCommand == DLL_PROCESS_ATTACH)
    {
        if (Attached++ == 0)
        {
            hEAPOL    = CreateProtocol("EAPOL",     &EAPOLEntryPoints,  ENTRYPOINTS_SIZE);
        }                  
    }
    else if (ulCommand == DLL_PROCESS_DETACH)
    {
        if (--Attached == 0)
        {
            DestroyProtocol(hEAPOL);
        }
    }
            
    return TRUE;

    //... Make the compiler happy.

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(lpReserved);
}

//==========================================================================================================================
//  FUNCTION: ParserAutoInstallInfo()
//
//  Modification History
//
//  timmoore       04/04/2000            
//==========================================================================================================================
PPF_PARSERDLLINFO   WINAPI  ParserAutoInstallInfo ()
{
    PPF_PARSERDLLINFO   pParserDllInfo;
    PPF_PARSERINFO      pParserInfo;
    DWORD               dwNumProtocols = 0;

    DWORD               dwNumHandoffs = 0;
    PPF_HANDOFFSET      pHandoffSet;
    PPF_HANDOFFENTRY    pHandoffEntry;

    dwNumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO) HeapAlloc (GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    sizeof( PF_PARSERDLLINFO ) 
                                                    + dwNumProtocols * sizeof( PF_PARSERINFO));

    if ( pParserDllInfo == NULL )
    {
        return NULL;
    }

    pParserDllInfo->nParsers = dwNumProtocols;

    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    wsprintf ( pParserInfo->szProtocolName, "EAPOL");
    wsprintf (pParserInfo->szComment, "EAPOL/802.1x Protocol");
    wsprintf ( pParserInfo->szHelpFile, "");
    
    dwNumHandoffs = 1;
    pHandoffSet = (PPF_HANDOFFSET) HeapAlloc (GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                sizeof( PF_HANDOFFSET ) +
                                                dwNumHandoffs * sizeof( PF_HANDOFFENTRY) );

    if (pHandoffSet == NULL)
    {
        return NULL;
    }

    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = dwNumHandoffs;

    pHandoffEntry = &(pHandoffSet->Entry[0]);
    wsprintf( pHandoffEntry->szIniFile,    "MAC.INI" );
    wsprintf( pHandoffEntry->szIniSection, "ETYPES" );
    wsprintf( pHandoffEntry->szProtocol,   "EAPOL" );
    pHandoffEntry->dwHandOffValue =        0x8180;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_HEX;

    return pParserDllInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eapol.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    eapol.h

Abstract:

    This module contains declarations which will be used by other processes.
    This may be placed in sdk\inc


Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_H_
#define _EAPOL_H_

//
// Structure:   EAPOL_STATS
//

typedef struct _EAPOL_STATS 
{
    DWORD           dwEAPOLFramesRcvd;
    DWORD           dwEAPOLFramesXmt;
    DWORD           dwEAPOLStartFramesXmt;
    DWORD           dwEAPOLLogoffFramesXmt;
    DWORD           dwEAPRespIdFramesXmt;
    DWORD           dwEAPRespFramesXmt;
    DWORD           dwEAPReqIdFramesRcvd;
    DWORD           dwEAPReqFramesRcvd;
    DWORD           dwEAPOLInvalidFramesRcvd;
    DWORD           dwEAPLengthErrorFramesRcvd;
    DWORD           dwEAPOLLastFrameVersion;
    BYTE            bEAPOLLastFrameSource[6];      // assuming 6-byte MAC addr
} EAPOL_STATS, *PEAPOL_STATS;

//
// Structure:   EAPOL_CONFIG
//

typedef struct _EAPOL_CONFIG 
{

    DWORD           dwheldPeriod;       // Time in seconds, for which the
                                        // port will be held in HELD state
    DWORD           dwauthPeriod;       // Time in seconds, for which the 
                                        // port will wait in AUTHENTICATING/
                                        // ACQUIRED state waiting for requests
    DWORD           dwstartPeriod;      // Time in seconds, the port will
                                        // wait in CONNECTING state, before
                                        // re-issuing EAPOL_START packet
    DWORD           dwmaxStart;         // Max number of EAPOL_Start packets
                                        // that can be sent out without any
                                        // response

} EAPOL_CONFIG, *PEAPOL_CONFIG;

//
// EAPOL states
//

typedef enum _EAPOL_STATE 
{
    EAPOLSTATE_LOGOFF,
    EAPOLSTATE_DISCONNECTED,
    EAPOLSTATE_CONNECTING,
    EAPOLSTATE_ACQUIRED,
    EAPOLSTATE_AUTHENTICATING,
    EAPOLSTATE_HELD,
    EAPOLSTATE_AUTHENTICATED
} EAPOL_STATE;

//
// Structure: EAPOL_CUSTOM_AUTH_DATA
//

typedef struct _EAPOL_CUSTOM_AUTH_DATA
{
    DWORD       dwSizeOfCustomAuthData;
    BYTE        pbCustomAuthData[1];
} EAPOL_CUSTOM_AUTH_DATA, *PEAPOL_CUSTOM_AUTH_DATA;

//
// Structure: EAPOL_EAP_UI_DATA
//

typedef struct _EAPOL_EAP_UI_DATA
{
    DWORD       dwContextId;
    PBYTE       pEapUIData;
    DWORD       dwSizeOfEapUIData;
} EAPOL_EAP_UI_DATA, *PEAPOL_EAP_UI_DATA;


// Definitions common to elport.c and eleap.c

//
// Defines states for the EAP protocol.
//

typedef enum _EAPSTATE 
{
    EAPSTATE_Initial,
    EAPSTATE_IdentityRequestSent,
    EAPSTATE_Working,
    EAPSTATE_EapPacketSentToAuthServer,
    EAPSTATE_EapPacketSentToClient,
    EAPSTATE_NotificationSentToClient

}   EAPSTATE;

typedef enum _EAPTYPE 
{
    EAPTYPE_Identity    = 1,
    EAPTYPE_Notification,
    EAPTYPE_Nak,
    EAPTYPE_MD5Challenge,
    EAPTYPE_SKey,
    EAPTYPE_GenericTokenCard

} EAPTYPE;

//
// Actions that need to be performed on EAP data after it is processed
//

typedef enum _ELEAP_ACTION
{
    ELEAP_NoAction,
    ELEAP_Done,
    ELEAP_SendAndDone,
    ELEAP_Send
} ELEAP_ACTION;


//
// EAPOL Authentication Types - Used for MACHINE_AUTH
//

typedef enum _EAPOL_AUTHENTICATION_TYPE
{
    EAPOL_UNAUTHENTICATED_ACCESS,
    EAPOL_USER_AUTHENTICATION,
    EAPOL_MACHINE_AUTHENTICATION
} EAPOL_AUTHENTICATION_TYPE;


#endif  // _EAPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eldefs.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eldefs.h

Abstract:

    The module contains various
    . constants
    . definitions
    . macros
    for the following functions:
      - memory-allocation
      - logging
      - tracing

Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_DEFS_H_
#define _EAPOL_DEFS_H_


// Constants

#define PORT_TABLE_BUCKETS          29 // # buckets in the port hash table
#define INTF_TABLE_BUCKETS          29 // # buckets in the interface hash table

#define MAX_PORT_NAME               255 // Max friendly name of the adapter
#define MAX_NDIS_DEVICE_NAME_LEN    255 // NDIS UI device name

#define NOW                         0
#define DELTA                       1
#define INFINITE_INTERVAL           0x7fffffff    // Used in timers
#define INFINITE_SECONDS            0x7ffff       // Used in timers

#define MAX_PACKET_SIZE             1518
#define MAX_EAPOL_BUFFER_SIZE       1502
#define SIZE_ETHERNET_CRC           4
#define WAP_LEEWAY                  100
#define SIZE_ETHERNET_TYPE          2
#define SIZE_PROTOCOL_VERSION       2
#define EAPOL_8021P_TAG_TYPE        0x0081
#define SIZE_MAC_ADDR               6
#define EAPOL_INIT_START_PERIOD     1   // 1 sec interval between EAPOL_Start
                                        // packets with no user logged on
#define EAPOL_HEAP_INITIAL_SIZE     50000
#define EAPOL_HEAP_MAX_SIZE         0
#define EAPOL_SERVICE_NAME          TEXT("EAPOL")
#define EAPOL_MAX_START             3
#define EAPOL_START_PERIOD          60
#define EAPOL_AUTH_PERIOD           30
#define EAPOL_HELD_PERIOD           60
#define EAPOL_MAX_AUTH_FAIL_COUNT   3

#define MAX_CHALLENGE_SIZE          8
#define MAX_RESPONSE_SIZE           24

#define EAP_TYPE_MD5                4
#define EAP_TYPE_TLS                13

#define EAPOL_DISABLED              0
#define EAPOL_ENABLED               1

#define VERSION7                    7
#define VERSION8                    8

// Default per interface values
#define DEFAULT_EAP_TYPE            EAP_TYPE_TLS
#define DEFAULT_EAPOL_STATE         EAPOL_ENABLED 

#define MAX_NOTIFICATION_MSG_SIZE   255

// Module startup flags
#define DEVICE_MODULE_STARTED       0x0001
#define WMI_MODULE_STARTED          0x0002
#define DEVICE_NOTIF_STARTED        0x0004
#define EAPOL_MODULE_STARTED        0x0008 


// Definitions

//#define LOCKSTORE                   (&(g_dlsDynamicLocksStore))
#define TRACEID                     g_dwTraceId
#define LOGHANDLE                   g_hLogEvents



// Macros
#define SWAP(a, b, c)               { (c)=(a); (a)=(b); (b)=(c); }
#define MAX(a, b)                   (((a) >= (b)) ? (a) : (b))
#define MIN(a, b)                   (((a) <= (b)) ? (a) : (b))
#define ISSET(i, flag)              ((i)->dwFlags & (flag))
#define SET(i, flag)                ((i)->dwFlags |= (flag))
#define RESET(i, flag)              ((i)->dwFlags &= ~(flag))



//
// TIMER
//

// Definitions
#define BLOCKING                    -1
#define NONBLOCKING                 NULL
#define MAX_TIME                    0xffffffff
#define SECTOMILLISEC(x)            ((x) * 1000)
// current time
#define Now()                       (((ULONG)GetTickCount()) / 1000)




// Macros

// Timers will always be one-shot and they will execute in I/O component 
// thread
#define CREATE_TIMER(phHandle, pfn, pvContext, ulWhen, szName, pdwRetCode)      \
{                                                                           \
    TRACE2(ANY, "TIMER: Create  %-20s\tTime: %u", szName, ulWhen);          \
    if (CreateTimerQueueTimer((phHandle),                                   \
                              g_hTimerQueue,                                \
                              (pfn),                                        \
                              (pvContext),                                  \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL,                            \
                              WT_EXECUTEINIOTHREAD))                        \
    {                                                                       \
        *(pdwRetCode)   = NO_ERROR;                                             \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(phHandle) = NULL;                                                 \
        *(pdwRetCode)   = GetLastError();                                       \
        TRACE1(ANY, "Error %u creating timer", *(pdwRetCode));                  \
    }                                                                       \
}

// it is safe to hold locks while making this call if
// 1. tType is NONBLOCKING  or
// 2. tType is BLOCKING and
//    the callback function doesn't acquire any of these locks
#define DELETE_TIMER(hHandle, tType, pdwRetCode)                                \
{                                                                           \
    if (DeleteTimerQueueTimer(g_hTimerQueue,                                \
                              (hHandle),                                    \
                              (HANDLE)tType))                               \
    {                                                                       \
        *(pdwRetCode) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwRetCode) = GetLastError();                                         \
        TRACE1(ANY, "Error %u deleting timer, continuing...", *(pdwRetCode));   \
    }                                                                       \
}

#define RESTART_TIMER(hHandle, ulWhen, szName, pdwRetCode)                      \
{                                                                           \
    TRACE2(ANY, "TIMER: Restart %-20s\tTime: %u", szName, ulWhen);          \
    if (ChangeTimerQueueTimer(g_hTimerQueue,                             \
                              (hHandle),                                    \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL))                           \
    {                                                                       \
        *(pdwRetCode) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwRetCode) = GetLastError();                                         \
        TRACE1(ANY, "Error %u restarting timer, continuing...", *(pdwRetCode)); \
        DebugBreak ();                                                      \
    }                                                                       \
}



// MEMORY ALLOCATION

// MACROS

#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))


//
// TRACING
//

// Definitions
#define EAPOL_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAPOL           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define EAPOL_TRACE_EAP             ((DWORD)0x00020000 | TRACE_USE_MASK)
#define EAPOL_TRACE_INIT            ((DWORD)0x00040000 | TRACE_USE_MASK)
#define EAPOL_TRACE_DEVICE          ((DWORD)0x00080000 | TRACE_USE_MASK)
#define EAPOL_TRACE_LOCK            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define EAPOL_TRACE_PORT            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define EAPOL_TRACE_TIMER           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define EAPOL_TRACE_USER            ((DWORD)0x00800000 | TRACE_USE_MASK)


// Macros
#define TRACE0(l,a)                                                     \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a)
#define TRACE1(l,a,b)                                                   \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)                                                 \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)                                               \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)                                             \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)                                           \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f)
#define TRACE6(l,a,b,c,d,e,f,g)                                         \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfExA(TRACEID, EAPOL_TRACE_ ## l, a, b, c, d, e, f, g)

#define EAPOL_DUMPW(pBuf,dwBuf)                                                \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,4,1,NULL)

#define EAPOL_DUMPB(pbBuf,dwBuf)                                        \
        TraceDumpEx(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)
#define EAPOL_DUMPBA(pbBuf,dwBuf)                                        \
        TraceDumpExA(TRACEID, 0x00010000 | TRACE_USE_MASK,(LPBYTE)pbBuf,dwBuf,1,0,NULL)


//
// EVENT LOGGING
//

#define EapolLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    RouterLogError( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray,    \
                    dwRetCode )

#define EapolLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    RouterLogWarning( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray, 0 )

#define EapolLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    RouterLogInformation(g_hLogEvents,LogId, NumStrings, lpwsSubStringArray,0)

#define EapolLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    RouterLogErrorString( g_hLogEvents, LogId, NumStrings,                  \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    RouterLogWarningString( g_hLogEvents, LogId, NumStrings,                \
                           lpwsSubStringArray, dwRetCode, dwPos )

#define EapolLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    RouterLogInformationString( g_hLogEvents, LogId,                        \
                                NumStrings, lpwsSubStringArray, dwRetCode,dwPos)


#endif // _EAPOL_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eapolutil.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eapolutil.c

Abstract:

    Tools and ends


Revision History:

    sachins, Apr 23 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop


// 
// Definitions used to read/write to registry
//

#define MAX_REGISTRY_VALUE_LENGTH   ((64*1024) - 1)

// Location of User blob
#define cszEapKeyEapolUser   "Software\\Microsoft\\EAPOL\\UserEapInfo"

// Location of Connection blob
#define cszEapKeyEapolConn   "Software\\Microsoft\\EAPOL\\Parameters\\Interfaces"

// Location of EAPOL Parameters Service
#define cszEapKeyEapolServiceParams   "Software\\Microsoft\\EAPOL\\Parameters\\General"

// Location of EAPOL Global state machine params
#define cszEAPOLGlobalParams   "Software\\Microsoft\\EAPOL\\Parameters\\General\\Global"

// Location of EAPOL Global Workspace
#define cszEAPOLWorkspace   "Software\\Microsoft\\EAPOL\\Parameters\\General\\Workspace"

#define cszDefault   "Default"

#define cszDefault          "Default"
#define cszEapolEnabled     "EapolEnabled"
#define cszDefaultEAPType   "DefaultEAPType"
#define cszLastUsedSSID     "LastUsedSSID"
#define cszInterfaceList    "InterfaceList"
#define cszAuthPeriod       "authPeriod"
#define cszHeldPeriod       "heldPeriod"
#define cszStartPeriod      "startPeriod"
#define cszMaxStart         "maxStart"
#define cszLastModifiedGUID "LastModifiedGUID"

//
// Definitions and structures used in creating default EAP-TLS connection
// blob in the registry
//

#define     EAPTLS_CONN_FLAG_REGISTRY           0x00000001
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_CERT   0x00000002
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_NAME   0x00000004

typedef struct _EAPTLS_CONN_PROPERTIES
{
    DWORD       dwVersion;
    DWORD       dwSize;
    DWORD       fFlags;
    //EAPTLS_HASH Hash;
    DWORD       cbHash;
    BYTE        pbHash[20]; // MAX_HASH_SIZE = 20
    WCHAR       awszServerName[1];
} EAPTLS_CONN_PROPERTIES, *PEAPTLS_CONN_PROPERTIES;

#define PASSWORDMAGIC 0xA5


//
// HostToWireFormat16
//
// Description: 
//
// Will convert a 16 bit integer from host format to wire format
//

VOID
HostToWireFormat16 (
    IN 	   WORD  wHostFormat,
    IN OUT PBYTE pWireFormat
    )
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+1) = (BYTE) (wHostFormat);
}


//
// WireToHostFormat16
//
// Description: 
//
// Will convert a 16 bit integer from wire format to host format
//

WORD
WireToHostFormat16 (
    IN PBYTE pWireFormat
    )
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
                        (*((PBYTE)(pWireFormat)+1)));

    return( wHostFormat );
}


//
// HostToWireFormat32
//
// Description: 
//
// Will convert a 32 bit integer from host format to wire format
//

VOID
HostToWireFormat32 (
    IN 	   DWORD dwHostFormat,
    IN OUT PBYTE pWireFormat
    )
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE) ((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE) ((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE) (dwHostFormat);
}


//
// WireToHostFormat32
//
// Description: 
//
// Will convert a 32 bit integer from wire format to host format
//

DWORD
WireToHostFormat32 (
    IN PBYTE pWireFormat
    )
{
    DWORD dwHostFormat = ((*((PBYTE)(pWireFormat)+0) << 24) +
    			  (*((PBYTE)(pWireFormat)+1) << 16) +
        		  (*((PBYTE)(pWireFormat)+2) << 8)  +
                    	  (*((PBYTE)(pWireFormat)+3) ));

    return( dwHostFormat );
}


//
// ElSetCustomAuthData
//
// Description:
//
// Function called to set the connection data for an interface for a specific
// EAP type and SSID (if any). Data will be stored in the HKLM hive
//
// Arguments:
//  pszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be stored
//  pszSSID - Special identifier, if any, for the EAP blob
//  pbConnInfo - pointer to EAP connection data blob
//  dwInfoSize - Size of EAP connection blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

// ISSUE:
// Can we optimize the key openings??? Only open 1 key somehow?

DWORD
ElSetCustomAuthData (
        IN  CHAR        *pszGUID,
        IN  DWORD       dwEapTypeId,
        IN  CHAR        *pszSSID,
        IN  PBYTE       pbConnInfo,
        IN  DWORD       dwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    DWORD       dwDisposition;
    CHAR        szEapTypeId[4]; // EapTypeId can be max 256 + 1 for null char
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetCustomAuthData: GUID = NULL");
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElSetCustomAuthData: GUID = NULL");
            break;
        }
        if ((pbConnInfo == NULL) || (dwInfoSize <= 0))
        {
            TRACE0 (ANY, "ElSetCustomAuthData: Invalid blob data");
            break;
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegCreateKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegCreateKeyExA (
                        hkey,
                        pszGUID,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey1,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegCreateKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        _ltoa(dwEapTypeId, szEapTypeId, 10);

        // Get handle to HKLM\Software\...\Interfaces\<GUID>\<EapTypeId>

        if ((lError = RegCreateKeyExA (
                        hkey1,
                        szEapTypeId,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey2,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegCreateKeyExA for EapTypeId, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // If no SSID is supplied, set the blob as value for "Default"

        if (pszSSID == NULL)
        {
            pszSSID = cszDefault;
        }

        //
        // Set the value of ..\Interfaces\GUID\<EAPTypeId>\(<SSID> or default) 
        // key

        if ((lError = RegSetValueExA (
                        hkey2,
                        pszSSID,
                        0,
                        REG_BINARY,
                        pbConnInfo,
                        dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetCustomAuthData: Error in RegSetValueExA for SSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElSetCustomAuthData: Set value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    
    return dwRetCode;
}


//
// ElGetCustomAuthData
//
// Description:
//
// Function called to retrieve the connection data for an interface for a 
// specific EAP type and SSID (if any). Data is retrieved from the HKLM hive
//
// Arguments:
//
//  pszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be retrieved
//  pszSSID - Special identifier if any for the EAP blob
//  pbUserInfo - output: pointer to EAP connection data blob
//  dwInfoSize - output: pointer to size of EAP connection blob
//
// Return values:
//
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetCustomAuthData (
        IN  CHAR            *pszGUID,
        IN  DWORD           dwEapTypeId,
        IN  CHAR            *pszSSID,
        IN  OUT BYTE        *pbConnInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    PBYTE       pbInfo = NULL;
    DWORD       dwInfoSize = 0;
    DWORD       dwType = 0;
    CHAR        szEapTypeId[4]; // EapTypeId can be max 256 + 1 for null char
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: GUID = NULL");
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: GUID = NULL");
            break;
        }

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        KEY_READ,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: Error in RegOpenKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyExA (
                        hkey,
                        pszGUID,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: Error in RegOpenKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        _ltoa(dwEapTypeId, szEapTypeId, 10);

        // Get handle to HKLM\Software\...\Interfaces\<GUID>\<EapTypeId>

        if ((lError = RegOpenKeyExA (
                        hkey1,
                        szEapTypeId,
                        0,
                        KEY_READ,
                        &hkey2
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: Error in RegOpenKeyExA for EapTypeId, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // If no SSID is supplied, set the blob as value for "Default"

        if (pszSSID == NULL)
        {
            pszSSID = cszDefault;
        }

        // Get the value of ..\Interfaces\GUID\<EAPType>\(<SSID> or default) 
        // key

        if ((lError = RegQueryValueExA (
                        hkey2,
                        pszSSID,
                        0,
                        &dwType,
                        NULL,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetCustomAuthData: Error in RegQueryValueExA for size estimation for SSID, %ld",
                    lError);

            // If pszSSID is "Default" and we cannot read the value for 
            // the key, bail out
            if (!strcmp(pszSSID, cszDefault))
            {
                dwRetCode = (DWORD)lError;
                break;
            }
            else
            {
                // Second try with pszSSID = cszDefault
                TRACE0 (ANY, "ElGetCustomAuthData: Second try for size estimation with SSID = Default");
                pszSSID = cszDefault;
                if ((lError = RegQueryValueExA (
                                        hkey2,
                                        pszSSID,
                                        0,
                                        &dwType,
                                        NULL,
                                        &dwInfoSize)) != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElGetCustomAuthData: Error in RegQueryValueExA for SSID=Default, 2nd try , %ld",
                        lError);

                    dwRetCode = (DWORD)lError;
                    break;
                }
            }
        }
        

        // Data can be read
        pbInfo = MALLOC (dwInfoSize);
        if (pbInfo == NULL)
        {
            TRACE0 (ANY, "ElGetCustomAuthData: Error in memory allocation");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if ((lError = RegQueryValueExA (
                        hkey2,
                        pszSSID,
                        0,
                        &dwType,
                        pbInfo,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElGetCustomAuthData: Error in RegQueryValueExA for SSID = %s, %ld",
                    pszSSID, lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE1 (ANY, "ElGetCustomAuthData: Succeeded: Data size = %ld",
                dwInfoSize);

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }

    // check if caller has allocated enough memory
    // to hold the info
    if ((pbConnInfo != NULL) && (*pdwInfoSize >= dwInfoSize))
    {
        memcpy ((VOID *)pbConnInfo, (VOID *)pbInfo, dwInfoSize);
    }
    else
    {
        dwRetCode = ERROR_BUFFER_TOO_SMALL;
    }

    *pdwInfoSize = dwInfoSize;
        
    // Free the memory allocated for holding blob
    if (pbInfo != NULL)
    {
        FREE (pbInfo);
        pbInfo = NULL;
    }
     
    return dwRetCode;
}


//
// ElSetEapUserInfo
//
// Description:
//
// Function called to store the user data for an interface for a 
// specific EAP type and SSID (if any). Data is stored in the HKCU hive.
// In case of EAP-TLS, this data will be the hash blob of the certificate
// chosen for the last successful authentication.
//
// Arguments:
//
//  hToken - Handle to token for the logged on user
//  pszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  pszSSID - Special identifier if any for the EAP user blob
//  pbUserInfo - pointer to EAP user data blob
//  dwInfoSize - Size of EAP user blob
//
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElSetEapUserInfo (
        IN  HANDLE      hToken,
        IN  CHAR        *pszGUID,
        IN  DWORD       dwEapTypeId,
        IN  CHAR        *pszSSID,
        IN  PBYTE       pbUserInfo,
        IN  DWORD       dwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    HKEY        hkey3 = NULL;
    DWORD       dwDisposition;
    CHAR        szEapTypeId[4]; // EapTypeId can be max 256 + 1 for null char
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (hToken == NULL)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: User Token = NULL");
            break;
        }
        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: GUID = NULL");
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElSetEapUserInfo: GUID = NULL");
            break;
        }
        if ((pbUserInfo == NULL) || (dwInfoSize <= 0))
        {
            TRACE0 (ANY, "ElSetEapUserInfo: Invalid blob data");
            break;
        }

        // Get handle to HKCU

        if ((dwRetCode = ElGetEapKeyFromToken (
                                hToken,
                                &hkey)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in ElGetEapKeyFromToken %ld",
                    dwRetCode);
            break;
        }

        if ((lError = RegCreateKeyExA (
                        hkey,
                        cszEapKeyEapolUser,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey1,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegCreateKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegCreateKeyExA (
                        hkey1,
                        pszGUID,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey2,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegCreateKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        _ltoa(dwEapTypeId, szEapTypeId, 10);

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>\<EAPTypeId>

        if ((lError = RegCreateKeyExA (
                        hkey2,
                        szEapTypeId,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey3,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetEapUserInfo: Error in RegCreateKeyExA for EapTypeId, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // If no SSID is supplied, set the blob as value for "Default"

        if (pszSSID == NULL)
        {
            pszSSID = cszDefault;
        }

        // Set value of ...\UserEapInfo\<GUID>\<EAPTypeId>\(<SSID> or default)
        // key

        if ((lError = RegSetValueExA (
                        hkey3,
                        pszSSID,
                        0,
                        REG_BINARY,
                        pbUserInfo,
                        dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElSetEapUserInfo: Error in RegSetValueExA for SSID = %s, %ld",
                    pszSSID, lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElSetEapUserInfo: Set value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if (hkey3 != NULL)
    {
        RegCloseKey (hkey3);
    }
    
    return dwRetCode;
}


//
// ElGetEapUserInfo
//
// Description:
//
// Function called to retrieve the user data for an interface for a 
// specific EAP type and SSID (if any). Data is retrieved from the HKCU hive
//
// Arguments:
//  hToken - Handle to token for the logged on user
//  pszGUID - pointer to GUID string for the interface
//  dwEapTypeId - EAP type for which user data is to be stored
//  pszSSID - Special identifier if any for the EAP user blob
//  pbUserInfo - output: pointer to EAP user data blob
//  dwInfoSize - output: pointer to size of EAP user blob
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetEapUserInfo (
        IN  HANDLE          hToken,
        IN  CHAR            *pszGUID,
        IN  DWORD           dwEapTypeId,
        IN  CHAR            *pszSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    HKEY        hkey2 = NULL;
    HKEY        hkey3 = NULL;
    PBYTE       pbInfo = NULL;
    DWORD       dwInfoSize = 0;
    DWORD       dwType = 0;
    CHAR        szEapTypeId[4]; // EapTypeId can be max 256 + 1 for null char
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: GUID = NULL");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (dwEapTypeId == 0)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: GUID = NULL");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get handle to HKCU

        if ((dwRetCode = ElGetEapKeyFromToken (
                                hToken,
                                &hkey)) != NO_ERROR)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in ElGetEapKeyFromToken %ld",
                    dwRetCode);
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyExA (
                        hkey,
                        cszEapKeyEapolUser,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>

        if ((lError = RegOpenKeyExA (
                        hkey1,
                        pszGUID,
                        0,
                        KEY_READ,
                        &hkey2
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        _ltoa(dwEapTypeId, szEapTypeId, 10);

        // Get handle to HKCU\Software\...\UserEapInfo\<GUID>\<EAPTypeId>

        if ((lError = RegOpenKeyExA (
                        hkey2,
                        szEapTypeId,
                        0,
                        KEY_READ,
                        &hkey3
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyExA for EapTypeId, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // If no SSID is supplied, set the blob as value for "Default"

        if (pszSSID == NULL)
        {
            pszSSID = cszDefault;
        }

        // Get value of ...\UserEapInfo\<GUID>\<EAPTypeId>\(<SSID> or default) 
        // key

        if ((lError = RegQueryValueExA (
                        hkey3,
                        pszSSID,
                        0,
                        &dwType,
                        NULL,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegQueryValueExA for size estimation for SSID, %ld",
                    lError);

            // If pszSSID is "Default" and we cannot read the value for 
            // the key, bail out
            if (!strcmp(pszSSID, cszDefault))
            {
                dwRetCode = (DWORD)lError;
                break;
            }
            else
            {
                // Second try with pszSSID = cszDefault
                TRACE0 (ANY, "ElGetEapUserInfo: Second try for size estimation with SSID = Default");
                pszSSID = cszDefault;
                if ((lError = RegQueryValueExA (
                                        hkey3,
                                        pszSSID,
                                        0,
                                        &dwType,
                                        NULL,
                                        &dwInfoSize)) != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElGetEapUserInfo: Error in RegOpenKeyExA for SSID=Default in 2nd try , %ld",
                        lError);

                    dwRetCode = (DWORD)lError;
                    break;
                }
            }
        }
        

        // Data can be read
        pbInfo = MALLOC (dwInfoSize);
        if (pbInfo == NULL)
        {
            TRACE0 (ANY, "ElGetEapUserInfo: Error in memory allocation");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if ((lError = RegQueryValueExA (
                        hkey3,
                        pszSSID,
                        0,
                        &dwType,
                        pbInfo,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetEapUserInfo: Error in RegQueryValueExA, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElGetEapUserInfo: Get value succeeded");

    } while (FALSE);

    // Close all the open registry keys

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }
    if (hkey2 != NULL)
    {
        RegCloseKey (hkey2);
    }
    if (hkey3 != NULL)
    {
        RegCloseKey (hkey3);
    }

    if (dwRetCode == ERROR_SUCCESS) 
    {

        // check if caller has allocated enough memory
        // to hold the info
        if ((pbUserInfo != NULL) && (*pdwInfoSize >= dwInfoSize))
        {
            memcpy ((VOID *)pbUserInfo, (VOID *)pbInfo, dwInfoSize);
        }
        else
        {
            // Else just return the size of the blob but not the blob
            dwRetCode = ERROR_BUFFER_TOO_SMALL;
        }

        *pdwInfoSize = dwInfoSize;

    }
        
    // Free the memory allocated for holding blob
    if (pbInfo != NULL)
    {
        FREE (pbInfo);
    }
     
    return dwRetCode;
}


//
// ElGetInterfaceParams
//
// Description:
//
// Function called to retrieve the EAPOL parameters for an interface, stored
// in the HKLM hive.
//
// Arguments:
//
//  pszGUID - pointer to GUID string for the interface
//  pdwDefaultEAPType - output: Pointer to default EAP type for interface
//  pszLastUsedSSID - output: Pointer to last used SSID for the interface
//  pdwEapolEnabled - output: Is EAPOL enabled for the interface?
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetInterfaceParams (
        IN  CHAR            *pszGUID,
        IN  OUT DWORD       *pdwDefaultEAPType,
        IN  OUT CHAR        *pszLastUsedSSID,
        IN  OUT DWORD       *pdwEapolEnabled
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwInfoSize = 0;
    DWORD       dwType = 0;
    BYTE        bValueBuffer[256];
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElGetInterfaceParams: GUID = NULL");
            break;
        }

        TRACE1 (ANY, "ElGetInterfaceParams: Getting stuff from registry for %s", pszGUID);

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        KEY_READ,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetInterfaceParams: Error in RegOpenKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyExA (
                        hkey,
                        pszGUID,
                        0,
                        KEY_READ,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetInterfaceParams: Error in RegOpenKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get the value of ..\Interfaces\GUID\EapolEnabled 

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hkey1,
                        cszEapolEnabled,
                        0,
                        &dwType,
                        (BYTE *)pdwEapolEnabled,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElGetInterfaceParams: Error in RegQueryValueExA for EapolEnabled, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            *pdwEapolEnabled = DEFAULT_EAPOL_STATE;
        }

        TRACE1 (ANY, "ElGetInterfaceParams: Got EapolEnabled = %ld", *pdwEapolEnabled);

        // Get the value of ..\Interfaces\GUID\DefaultEAPType 

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hkey1,
                        cszDefaultEAPType,
                        0,
                        &dwType,
                        (BYTE *)pdwDefaultEAPType,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElGetInterfaceParams: Error in RegQueryValueExA for DefaultEAPType, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            *pdwDefaultEAPType = DEFAULT_EAP_TYPE;        
        }

        TRACE1 (ANY, "ElGetInterfaceParams: Got DefaultEAPType = %ld", *pdwDefaultEAPType);

        // Get the value of ..\Interfaces\GUID\LastUsedSSID 

        dwInfoSize = 256;
        if ((lError = RegQueryValueExA (
                        hkey1,
                        cszLastUsedSSID,
                        0,
                        &dwType,
                        (PUCHAR)pszLastUsedSSID,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetInterfaceParams: Error in RegQueryValueExA for LastUsedSSID, %ld",
                    lError);
            pszLastUsedSSID = NULL;
        }

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }

    return dwRetCode;

}

//
// ElSetInterfaceParams
//
// Description:
//
// Function called to set the EAPOL parameters for an interface, in the HKLM
// hive
//
// Arguments:
//
//  pszGUID - Pointer to GUID string for the interface
//  pdwDefaultEAPType - default EAP type for interface
//  pszLastUsedSSID - SSID that was received in the last EAP-Request/Identity
//              packet
//  pdwEapolEnabled - Is EAPOL enabled for the interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
//

DWORD
ElSetInterfaceParams (
        IN  CHAR            *pszGUID,
        IN  DWORD           *pdwDefaultEAPType,
        IN  CHAR            *pszLastUsedSSID,
        IN  DWORD           *pdwEapolEnabled
        )
{
    HKEY        hkey = NULL;
    HKEY        hkey1 = NULL;
    DWORD       dwInfoSize = 0;
    DWORD       dwType = 0;
    LONG        lError = ERROR_SUCCESS;
    DWORD       dwRetCode = ERROR_SUCCESS;

    do
    {
        // Validate input params

        if (pszGUID == NULL)
        {
            TRACE0 (ANY, "ElSetInterfaceParams: GUID = NULL");
            break;
        }

        TRACE1 (ANY, "Setting stuff from registry for %s", pszGUID);

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        KEY_WRITE,
                        &hkey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegOpenKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyExA (
                        hkey,
                        pszGUID,
                        0,
                        KEY_WRITE,
                        &hkey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegOpenKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Set the value of ..\Interfaces\GUID\EapolEnabled 

        if ((lError = RegSetValueExA (
                        hkey1,
                        cszEapolEnabled,
                        0,
                        REG_DWORD,
                        (BYTE *)pdwEapolEnabled,
                        sizeof(DWORD))) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegSetValueExA for EapolEnabled, %ld",
                    lError);
        }

        // Set the value of ..\Interfaces\GUID\DefaultEAPType 

        if ((lError = RegSetValueExA (
                        hkey1,
                        cszDefaultEAPType,
                        0,
                        REG_DWORD,
                        (BYTE *)pdwDefaultEAPType,
                        sizeof(DWORD))) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElSetInterfaceParams: Error in RegSetValueExA for DefaultEAPType, %ld",
                    lError);
        }

        // Set the value of ..\Interfaces\GUID\LastUsedSSID 

        if ((lError = RegSetValueExA (
                        hkey1,
                        cszLastUsedSSID,
                        0,
                        REG_SZ,
                        pszLastUsedSSID,
                        strlen(pszLastUsedSSID))) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElGetInterfaceParams: Error in RegSetValueExA for LastUsedSSID, %ld",
                    lError);
        }

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }
    if (hkey1 != NULL)
    {
        RegCloseKey (hkey1);
    }

    return dwRetCode;

}


//
// ElGetEapKeyFromToken
//
// Description:
//
// Function to get handle to User hive from User Token
//
// Arguments:
//  hUserToken - handle to user token
//  phkey - output: pointer to handle to user hive
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetEapKeyFromToken (
        IN  HANDLE      hUserToken,
        OUT HKEY        *phkey
        )
{
    DWORD               dwSizeNeeded;
    TOKEN_USER          *pTokenData = NULL;
    UNICODE_STRING      UnicodeSidString;
    WCHAR               wsUnicodeBuffer[256];
    HKEY                hUserKey;
    HKEY                hkeyEap;
    DWORD               dwDisposition;
    NTSTATUS            Status = STATUS_SUCCESS;
    PBYTE               pbInfo = NULL;
    CHAR                *pszInfo = NULL;
    DWORD               dwType;
    DWORD               dwInfoSize = 0;
    LONG                lRetVal;
    EAPOL_PCB           *pPCB;
    DWORD               i;
    LONG                lError = ERROR_SUCCESS;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        if (hUserToken != NULL)
        {
            if (!GetTokenInformation(hUserToken, TokenUser, 0, 0, &dwSizeNeeded))
            {
                if ((dwRetCode = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                {
                    pTokenData = (TOKEN_USER *) MALLOC (dwSizeNeeded);

                    if (pTokenData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (ANY,"ElGetEapKeyFromToken: Allocation for TokenData failed");
                        break;
                    }
                    // Reset error code since we are continuing processing
                    // This was a valid scenario
                    dwRetCode = NO_ERROR;
                }
                else
                {
                    TRACE1 (ANY,"ElGetEapKeyFromToken: Error in GetTokenInformation = %ld",
                            dwRetCode);
                    break;
                }

                if (!GetTokenInformation (hUserToken,
                                            TokenUser,
                                            pTokenData,
                                            dwSizeNeeded,
                                            &dwSizeNeeded))
                {
                    dwRetCode = GetLastError ();
                    
                    TRACE1 (ANY,"ElGetEapKeyFromToken: GetTokenInformation failed with error %ld",
                            dwRetCode);
                    break;
                }

                UnicodeSidString.Buffer = wsUnicodeBuffer;
                UnicodeSidString.Length = 0;
                UnicodeSidString.MaximumLength = sizeof(wsUnicodeBuffer);

                Status = RtlConvertSidToUnicodeString (
                                        &UnicodeSidString,
                                        pTokenData->User.Sid,
                                        FALSE);

                if (!NT_SUCCESS(Status))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetEapKeyFromToken: RtlconvertSidToUnicodeString failed with error %ld",
                            dwRetCode);
                    break;
                }

                UnicodeSidString.Buffer[UnicodeSidString.Length] = 0;

                // Open the user's key
                if ((lError = RegOpenKeyEx(HKEY_USERS, 
                            UnicodeSidString.Buffer, 
                            0, 
                            KEY_ALL_ACCESS, 
                            &hUserKey)) != ERROR_SUCCESS)
                {
                    dwRetCode = (DWORD)lError;
                    TRACE1 (USER, "ElGetEapKeyFromToken: RegOpenKeyExA failed with error %ld",
                            dwRetCode);
                    break;
                }
                else
                {
                    TRACE0 (ANY, "ElGetEapKeyFromToken: RegOpenKeyExA succeeded"); 
                }

            }
            else
            {
                TRACE0 (ANY,"ElGetEapKeyFromToken: GetTokenInformation succeeded when it should have failed");
                break;
            }
        }
        else
        {
            TRACE0 (ANY, "ElGetEapKeyFromToken: Error, hUserToken == NULL ");
            break;
        }

        *phkey = hUserKey;

    } while (FALSE);

    if (pTokenData != NULL)
    {
        FREE (pTokenData);
    }

    return dwRetCode;
}


//
// ElInitRegPortData
//
// Description:
//
// Function to verify existence of connection data for the port
// If no data exists, initialize with default values
// For EAP-TLS, default settings are no server certificate authentication, 
// registry certificates
//
// Arguments:
//  pszDeviceGUID - Pointer to GUID string for the port for which data is being
//                  initialized
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElInitRegPortData (
        CHAR        *pszDeviceGUID
        )
{
    PBYTE                   pbInfo      = NULL;
    DWORD                   dwInfoSize  = 0;
    EAPTLS_CONN_PROPERTIES  *pConnProp  = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {
        // Get the size of the Eap data first
        if ((dwRetCode = ElGetCustomAuthData (
                        pszDeviceGUID,
                        EAPCFG_DefaultKey,
                        NULL,   // SSID
                        NULL,   // pbInfo
                        &dwInfoSize
                       )) != NO_ERROR)
        {
            TRACE1 (ANY, "ElInitRegPortData: ElGetCustomAuthData returned error %ld",
                    dwRetCode);

            if ((dwRetCode == ERROR_BUFFER_TOO_SMALL) && (dwInfoSize != 0))
            {
                // There is valid data in the default key in the registry
                dwRetCode = NO_ERROR;
                TRACE1 (ANY, "ElInitRegPortData: ElGetCustomAuthData returned blob size = %ld",
                        dwInfoSize);
                break;
            }

            // Initialize port place with default data
            pConnProp = MALLOC (sizeof (EAPTLS_CONN_PROPERTIES));
            if (pConnProp == NULL)
            {
                TRACE0 (ANY, "ElInitRegPortData: Failed allocation for Conn Prop");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Registry certs, No server cert validation, No server name
            // comparison

            pConnProp->fFlags = (EAPTLS_CONN_FLAG_REGISTRY |
                                    EAPTLS_CONN_FLAG_NO_VALIDATE_CERT |
                                    EAPTLS_CONN_FLAG_NO_VALIDATE_NAME);
#if REG_CERT_VALIDATE
            pConnProp->fFlags = EAPTLS_CONN_FLAG_REGISTRY;
            pConnProp->fFlags &= ~EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;
            pConnProp->fFlags &= ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
#endif

            pConnProp->dwSize = sizeof (EAPTLS_CONN_PROPERTIES);

            // Set this blob into the registry for the port

            if ((dwRetCode = ElSetCustomAuthData (
                        pszDeviceGUID,
                        EAPCFG_DefaultKey,
                        NULL,
                        (BYTE *)pConnProp,
                        pConnProp->dwSize
                       )) != NO_ERROR)
            {
                TRACE1 (ANY, "ElInitRegPortData: ElSetCustomAuthData failed with %ld",
                        dwRetCode);
                break;
            }
        } 

    } while (FALSE);

    if (pConnProp != NULL)
    {
        FREE (pConnProp);
        pConnProp = NULL;
    }


    TRACE1 (ANY, "ElInitRegPortData: completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElAuthAttributeGetVendorSpecific
//
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetVendorSpecific (
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
    )
{
    HANDLE               hAttribute;
    RAS_AUTH_ATTRIBUTE * pAttribute;

    //
    // First search for the vendor specific attribute
    //

    pAttribute = ElAuthAttributeGetFirst ( raatVendorSpecific,
                                           pAttributes,
                                           &hAttribute );

    while ( pAttribute != NULL )
    {
        //
        // If this attribute is of at least size to hold vendor Id/Type
        //

        if ( pAttribute->dwLength >= 8 )
        {
            //
            // Does this have the correct VendorId
            //

            if (WireToHostFormat32( (PBYTE)(pAttribute->Value) ) == dwVendorId)
            {
                //
                // Does this have the correct Vendor Type
                //

                if ( *(((PBYTE)(pAttribute->Value))+4) == dwVendorType )
                {
                    return( pAttribute );
                }
            }
        }

        pAttribute = ElAuthAttributeGetNext ( &hAttribute,
                                              raatVendorSpecific );
    }

    return( NULL );
}


//
// ElAuthAttributeGetFirst
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetFirst (
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes,
    OUT HANDLE *                 phAttribute
    )
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pRequiredAttribute;

    pRequiredAttribute = ElAuthAttributeGet ( raaType, pAttributes );

    if ( pRequiredAttribute == NULL )
    {
        *phAttribute = NULL;

        return( NULL );
    }

    *phAttribute = pRequiredAttribute;

    return( pRequiredAttribute );
}


//
// ElAuthAttributeGetNext
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetNext (
    IN  OUT HANDLE *             phAttribute,
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType
    )
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pAttributes = (RAS_AUTH_ATTRIBUTE *)*phAttribute;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    pAttributes++;

    while( pAttributes->raaType != raatMinimum )
    {
        if ( pAttributes->raaType == raaType )
        {
            *phAttribute = pAttributes;
            return( pAttributes );
        }

        pAttributes++;
    }

    *phAttribute = NULL;
    return( NULL );
}


//
// ElAuthAttributeGet
//
// Description:
//      Helper function used to extract MPPE Key out of Attrribute.
//

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGet (
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes
    )
{
    DWORD dwIndex;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ )
    {
        if ( pAttributes[dwIndex].raaType == raaType )
        {
            return( &(pAttributes[dwIndex]) );
        }
    }

    return( NULL );
}


//
// ElReverseString
//
// Description:
//      Reverses order of characters in 'psz'
//

VOID
ElReverseString (
    CHAR* psz 
    )
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


//
// ElEncodePw
//
// Description:
//
//      Obfuscate 'pszPassword' in place to foil memory scans for passwords.
//      Returns the address of 'pszPassword'.
//

CHAR*
ElEncodePw (
    IN OUT CHAR* pszPassword 
    )
{
    if (pszPassword)
    {
        CHAR* psz;

        ElReverseString (pszPassword);

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != (CHAR)PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }

    return pszPassword;
}


//
// ElDecodePw
//
// Description:
//
//      Un-obfuscate 'pszPassword' in place.
//      Returns the address of 'pszPassword'.
//

CHAR*
ElDecodePw (
    IN OUT CHAR* pszPassword 
    )
{
    return ElEncodePw (pszPassword);
}


//
// Call: ElEncryptKeyUsingMD5
//
// Description:
//      Given a secret, encrypt a given blob
//      
//
//

VOID
ElEncryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        )
{
    MD5_CTX     MD5Context;
    BYTE        bcipherText[MD5DIGESTLEN];
    BYTE        *pbWork = NULL, *pbEnd = NULL;
    BYTE        *pbEndBlock = NULL, *pbSrc = NULL;

    //
    // Compute the beginning and end of the data to be crypted
    //
    pbWork = pbBuf;
    pbEnd   = pbBuf + ulBufLen;

    //
    // Loop through the buffer
    //
    while (pbWork < pbEnd)
    {
        // Compute the digest
        MD5Init (&MD5Context);
        MD5Update (&MD5Context, pbSecret, ulSecretLen);
        MD5Final (&MD5Context);

        // Find the end of the block to be decrypted
        pbEndBlock = pbWork + MD5DIGESTLEN;
        if (pbEndBlock >= pbEnd)
        {
            // We've reached the end of the buffer
            pbEndBlock = pbEnd;
        }
        else
        {
            // ISSUE: Save the ciphertext for the next pass?
        }
    
        // Crypt the block
        for (pbSrc = MD5Context.digest; pbWork < pbEndBlock; ++pbWork, ++pbSrc)
        {
            *pbWork ^= *pbSrc;
        }
    }
}


//
// ElDecryptKeyUsingMD5
//
// Description:
//      Given a secret, decrypt a given blob
//      
//
//

VOID
ElDecryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        )
{
    MD5_CTX     MD5Context;
    BYTE        bcipherText[MD5DIGESTLEN];
    BYTE        *pbWork = NULL, *pbEnd = NULL;
    BYTE        *pbEndBlock = NULL, *pbSrc = NULL;
    DWORD       dwNumBlocks = 0;
    DWORD       dwBlock = 0;
    DWORD       dwIndex = 0;

    dwNumBlocks = ( ulBufLen - 2 ) / MD5DIGESTLEN;

    //
    // Walk through the blocks
    //
    for (dwBlock = 0; dwBlock < dwNumBlocks; dwBlock++ )
    {
        MD5Init ( &MD5Context);
        MD5Update ( &MD5Context, (PBYTE)pbSecret, ulSecretLen);

        //
        // ISSUE:
        // Do we use any part of the ciphertext at all to generate 
        // the digest
        //

        MD5Final ( &MD5Context);

        for ( dwIndex = 0; dwIndex < MD5DIGESTLEN; dwIndex++ )
        {
            *pbBuf ^= MD5Context.digest[dwIndex];
            pbBuf++;
        }
    }

}


//
// ElGetHMACMD5Digest
//
// Description:
//
//      Given a secret, generate a MD5 digest
//
// Arguments:
//      pbBuf - pointer to data stream
//      dwBufLen - length of data stream
//      pbKey - pointer to authentication key
//      dwKeyLen - length of authentication key
//      pvDigest - caller digest to be filled in
//
// Return values:
//      None
//

VOID
ElGetHMACMD5Digest (
        IN      BYTE        *pbBuf,
        IN      DWORD       dwBufLen,
        IN      BYTE        *pbKey,
        IN      DWORD       dwKeyLen,
        IN OUT  VOID        *pvDigest
        )
{
        MD5_CTX         MD5context;
        UCHAR           k_ipad[65];	/* inner padding - key XORd with ipad */
        UCHAR           k_opad[65];  /* outer padding - key XORd with opad */
        UCHAR           tk[16];
        DWORD           dwIndex = 0;
        
        //
        // the HMAC_MD5 transform looks like:
        //
        // MD5(K XOR opad, MD5(K XOR ipad, text))
        //
        // where K is an n byte key
        // ipad is the byte 0x36 repeated 64 times
        // opad is the byte 0x5c repeated 64 times
        // and text is the data being protected
        //

        // start out by storing key in pads
        ZeroMemory ( k_ipad, sizeof k_ipad);
        ZeroMemory ( k_opad, sizeof k_opad);
        memcpy ( k_ipad, pbKey, dwKeyLen);
        memcpy ( k_opad, pbKey, dwKeyLen);

        // XOR key with ipad and opad values
        for (dwIndex=0; dwIndex<64; dwIndex++) 
        {
            k_ipad[dwIndex] ^= 0x36;
            k_opad[dwIndex] ^= 0x5c;
        }

        //
        // perform inner MD5
        //

        // init context for 1st pass
        MD5Init(&MD5context);                   		
        // start with inner pad
        MD5Update(&MD5context, k_ipad, 64);
        // then text of datagram 
        MD5Update(&MD5context, pbBuf, dwBufLen); 	
        // finish up 1st pass
        MD5Final(&MD5context);
        memcpy (pvDigest, MD5context.digest, MD5DIGESTLEN);

        //
        // perform outer MD5
        //

        // init context for 2nd pass
        MD5Init(&MD5context);                   		
        // start with outer pad
        MD5Update(&MD5context, k_opad, 64);     	
        // then results of 1st hash
        MD5Update(&MD5context, pvDigest, 16);     	
        // finish up 2nd pass
        MD5Final(&MD5context);
        memcpy (pvDigest, MD5context.digest, MD5DIGESTLEN);
}


//
// ElWmiGetValue
//
// Description:
//
// Get a value for a GUID instance through WMI
//
// Arguments:
//      pGuid - Pointer to guid for which value is to be fetched
//      pszInstanceName - Friendly name for the interface
//      pbInputBuffer - Pointer to data
//      dwInputBufferSize - Size of data
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElWmiGetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  OUT BYTE    *pbOutputBuffer,
        IN  OUT DWORD   *pdwOutputBufferSize
        )
{
    WMIHANDLE               WmiHandle = NULL;
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   ulBufferSize = 0;
    WCHAR                   *pwszInstanceName = NULL;
    BYTE                    *pbLocalBuffer = NULL;
    DWORD                   dwLocalBufferSize = 0;
    LONG                    lStatus = ERROR_SUCCESS;

    do 
    {

        if ((pwszInstanceName = MALLOC ((strlen(pszInstanceName)+1) * sizeof (WCHAR))) == NULL)
        {
            TRACE2 (ANY, "ElWmiGetValue: MALLOC failed for pwszInstanceName, Friendlyname =%s, len= %ld",
                    pszInstanceName, strlen(pszInstanceName));
            lStatus = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pszInstanceName,
                    -1,
                    pwszInstanceName,
                    strlen(pszInstanceName)+1 ) )
        {
            lStatus = GetLastError();
    
            TRACE2 (ANY, "ElWmiGetValue: MultiByteToWideChar(%s) failed: %ld",
                    pszInstanceName, lStatus);
            break;
        }
        pwszInstanceName[strlen(pszInstanceName)] = L'\0';
    
        TRACE1 (ANY, "ElWmiGetValue: MultiByteToWideChar succeeded: %S",
                pwszInstanceName);

        if ((lStatus = WmiOpenBlock (pGuid, 0, &WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiGetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
            break;
        }

        if ((lStatus = WmiQuerySingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                &dwLocalBufferSize,
                                                NULL)) != ERROR_SUCCESS)
        {

            if (lStatus == ERROR_INSUFFICIENT_BUFFER)
            {
                TRACE1 (ANY, "ElWmiGetValue: Size Required = %ld",
                        dwLocalBufferSize);

                if ((pbLocalBuffer = MALLOC (dwLocalBufferSize)) == NULL)
                {
                    TRACE0 (ANY, "ElWmiGetValue: MALLOC failed for pbLocalBuffer");
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if ((lStatus = WmiQuerySingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                &dwLocalBufferSize,
                                                pbLocalBuffer))
                                                    != ERROR_SUCCESS)
                {
                    TRACE1 (ANY, "ElWmiGetValue: WmiQuerySingleInstance failed with error %ld",
                        lStatus);
                    break;
                }

                pWnode = (PWNODE_SINGLE_INSTANCE)pbLocalBuffer;

                // If enough space in the output buffer, copy the data block
                if (*pdwOutputBufferSize >= pWnode->SizeDataBlock)
                {
                    memcpy (pbOutputBuffer, 
                            (PBYTE)((BYTE *)pWnode + pWnode->DataBlockOffset),
                            pWnode->SizeDataBlock
                            );
                }
                else
                {
                    lStatus = ERROR_INSUFFICIENT_BUFFER;
                    TRACE0 (ANY, "ElWmiGetValue: Not sufficient space to copy DataBlock");
                    *pdwOutputBufferSize = pWnode->SizeDataBlock;
                    break;
                }
                 
                *pdwOutputBufferSize = pWnode->SizeDataBlock;
        
                TRACE0 (ANY, "ElWmiGetValue: Got values from Wmi");
        
                TRACE1 (ANY, "SizeofDataBlock = %ld", pWnode->SizeDataBlock);
        
                EAPOL_DUMPBA (pbOutputBuffer, *pdwOutputBufferSize);
        
            }
            else
            {
                TRACE1 (ANY, "ElWmiGetValue: WmiQuerySingleInstance failed with error %ld",
                        lStatus);
                break;
            }

        }


        
    } while (FALSE);

    if (WmiHandle != NULL)
    {
        if ((lStatus = WmiCloseBlock (WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiGetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
        }
    }

    if (pbLocalBuffer != NULL)
    {
        FREE (pbLocalBuffer);
    }

    if (pwszInstanceName  != NULL)
    {
        FREE (pwszInstanceName);
    }

    return (DWORD)lStatus;

}


//
// ElWmiSetValue
//
// Description:
//
// Set a value for a GUID instance through WMI
//
// Arguments:
//      pGuid - Pointer to guid for which value is to be set
//      pszInstanceName - Friendly name for the interface
//      pbInputBuffer - Pointer to data
//      dwInputBufferSize - Size of data
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElWmiSetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  BYTE        *pbInputBuffer,
        IN  DWORD       dwInputBufferSize
        )
{
    WMIHANDLE               WmiHandle = NULL;
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   ulBufferSize = 0;
    WCHAR                   *pwszInstanceName = NULL;
    BYTE                    bBuffer[4096];

    LONG            lStatus = ERROR_SUCCESS;

    do 
    {

        if ((pwszInstanceName = MALLOC ((strlen(pszInstanceName)+1) * sizeof (WCHAR))) == NULL)
        {
            TRACE0 (ANY, "ElWmiSetValue: MALLOC failed for pwszInstanceName");
            lStatus = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (0 == MultiByteToWideChar (
                    CP_ACP,
                    0,
                    pszInstanceName,
                    -1,
                    pwszInstanceName,
                    strlen(pszInstanceName)+1 ) )
        {
            lStatus = GetLastError();
    
            TRACE2 (ANY, "ElWmiSetValue: MultiByteToWideChar(%s) failed: %d",
                    pszInstanceName,
                    lStatus);
            break;
        }
        pwszInstanceName[strlen(pszInstanceName)] = L'\0';
    
        if ((lStatus = WmiOpenBlock (pGuid, 0, &WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
            break;
        }

        if ((lStatus = WmiSetSingleInstance (WmiHandle,
                                                pwszInstanceName,
                                                1,
                                                dwInputBufferSize,
                                                pbInputBuffer)) 
                                                     != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiSetSingleInstance failed with error %ld",
                    lStatus);
            break;
        }

        TRACE0 (ANY, "ElWmiSetValue: Successful !!!");

    } while (FALSE);

    if (WmiHandle != NULL)
    {
        if ((lStatus = WmiCloseBlock (WmiHandle)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWmiSetValue: WmiOpenBlock failed with error %ld",
                    lStatus);
        }
    }

    if (pwszInstanceName != NULL)
    {
        FREE (pwszInstanceName);
    }

    return (DWORD)lStatus;

}


//
// ElNdisuioSetOIDValue
//
// Description:
//
// Set a value for an OID for an interface using Ndisuio
//
// Arguments:
//      hInterface - Ndisuio handle to interface 
//      Oid - Oid for which value needs to be set
//      pbOidData - Pointer to Oid data 
//      ulOidDataLength - Oid data length
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElNdisuioSetOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       ulOidDataLength
        )
{
    PNDISUIO_SET_OID    pSetOid = NULL;
    DWORD               BytesReturned = 0;
    BOOLEAN             fSuccess = TRUE;
    DWORD               dwRetCode = NO_ERROR;


    do
    {
        pSetOid = (PNDISUIO_SET_OID) MALLOC (ulOidDataLength + sizeof(NDISUIO_SET_OID)); 

        if (pSetOid == NULL)
        {
            TRACE0 (ANY, "ElNdisuioSetOIDValue: MALLOC failed for pSetOid");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        pSetOid->Oid = Oid;
        memcpy(&pSetOid->Data[0], pbOidData, ulOidDataLength);

        fSuccess = (BOOLEAN) DeviceIoControl (
                                    hInterface, 
                                    IOCTL_NDISUIO_SET_OID_VALUE,
                                    (LPVOID)pSetOid,
                                    FIELD_OFFSET(NDISUIO_SET_OID, Data) + ulOidDataLength,
                                    (LPVOID)pSetOid,
                                    0,
                                    &BytesReturned,
                                    NULL);
        if (!fSuccess)
        {
            TRACE1 (ANY, "ElNdisuioSetOIDValue: DeviceIoControl failed with error %ld",
                    (dwRetCode = GetLastError()));
            break;
        }
        else
        {
            TRACE0 (ANY, "ElNdisuioSetOIDValue: DeviceIoControl succeeded");
        }

    }
    while (FALSE);

    if (pSetOid != NULL)
    {
        FREE (pSetOid);
    }

    return dwRetCode;
}


//
// ElNdisuioQueryOIDValue
//
// Description:
//
// Query the value for an OID for an interface using Ndisuio
//
// Arguments:
//      hInterface - Ndisuio handle to interface 
//      Oid - Oid for which value needs to be set
//      pbOidValue - Pointer to Oid value 
//      pulOidDataLength - Pointer to Oid data length
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElNdisuioQueryOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       *pulOidDataLength
        )
{
    PNDISUIO_QUERY_OID  pQueryOid = NULL;
    DWORD               BytesReturned = 0;
    BOOLEAN             fSuccess = TRUE;
    DWORD               dwRetCode = NO_ERROR;


    do
    {
        pQueryOid = (PNDISUIO_QUERY_OID) MALLOC (*pulOidDataLength + sizeof(NDISUIO_QUERY_OID)); 

        if (pQueryOid == NULL)
        {
            TRACE0 (ANY, "ElNdisuioQueryOIDValue: MALLOC failed for pQueryOid");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        pQueryOid->Oid = Oid;

        fSuccess = (BOOLEAN) DeviceIoControl (
                                    hInterface, 
                                    IOCTL_NDISUIO_QUERY_OID_VALUE,
                                    (LPVOID)pQueryOid,
                                    FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + *pulOidDataLength,
                                    (LPVOID)pQueryOid,
                                    FIELD_OFFSET(NDISUIO_QUERY_OID, Data) + *pulOidDataLength,
                                    &BytesReturned,
                                    NULL);
        if (!fSuccess)
        {
            dwRetCode = GetLastError();
            TRACE2 (ANY, "ElNdisuioQueryOIDValue: DeviceIoControl failed with error %ld, BytesReturned = %ld",
                    dwRetCode, BytesReturned); 
            *pulOidDataLength = BytesReturned;
            break;
        }
        else
        {
            TRACE0 (ANY, "ElNdisuioQueryOIDValue: DeviceIoControl succeeded");

            if (BytesReturned >= *pulOidDataLength)
            {
                TRACE2 (ANY, "ElNdisuioQueryOIDValue: BytesRet (%ld) >= SizeofInput (%ld); truncating data",
                        BytesReturned, *pulOidDataLength);
                BytesReturned = *pulOidDataLength;
            }
            else
            {
                dwRetCode = ERROR_INVALID_DATA;
                TRACE2 (ANY, "ElNdisuioQueryOIDValue: BytesRet (%ld) < SizeofInput (%ld)",
                        BytesReturned, *pulOidDataLength);
                *pulOidDataLength = BytesReturned;
            }

            memcpy(pbOidData, &pQueryOid->Data[0], BytesReturned);
            
        }

    }
    while (FALSE);

    if (pQueryOid != NULL)
    {
        FREE (pQueryOid);
    }

    return dwRetCode;
}

#if 0

//
// ElGuidFromString
//
// Description:
//
// Convert a GUID-string to GUID
//
// Arguments:
//      pGuid - pointer to GUID
//      pszGuidString - pointer to string version of GUID
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//

DWORD 
ElGuidFromString (
        IN  OUT GUID        *pGuid,
        IN      CHAR        *pszGuidString
        )
{
    DWORD       dwGuidLen = 0;
    WCHAR       wszGuidString[64];
    LPWSTR      lpwszWithBraces = NULL;
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

    if (pszGuidString == NULL)
    {
        break;
    }

    ZeroMemory (pGuid, sizeof(GUID));

    dwGuidLen = strlen (pszGuidString);
    if (dwGuidLen != 36)
    {
        TRACE0 (ANY, "GuidFromString: Guid Length != required 36");
        break;
    }
    
    if (0 == MultiByteToWideChar(
                CP_ACP,
                0,
                pszGuidString,
                -1,
                wszGuidString,
                dwGuidLen ) )
    {
        dwRetCode = GetLastError();

        TRACE2 (ANY, "GuidFromString: MultiByteToWideChar(%s) failed: %d",
                pszGuidString,
                dwRetCode);
        break;
    }
    wszGuidString[dwGuidLen] = L'\0';

    // add the braces
    lpwszWithBraces = (LPWSTR) MALLOC ((dwGuidLen + 1 + 2) * sizeof(WCHAR));

    wsprintf (lpwszWithBraces, L"{%s}", wszGuidString);

    CLSIDFromString (lpwszWithBraces, pGuid);

    } while (FALSE);

    return dwRetCode;
}

#endif


//
// ElGetLoggedOnUserName
//
// Description:
//
// Get the Username and Domain of the currently logged in user
//
// Arguments:
//      pPCB - Pointer to port on which logged-on user's name is to be
//              obtained
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElGetLoggedOnUserName (
        IN      EAPOL_PCB       *pPCB
        )
{
    HANDLE              hUserToken; 
    WCHAR               *pwszUserNameBuffer = NULL;
    DWORD               dwBufferSize = 0;
    BOOL                fNeedToRevertToSelf = FALSE;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        hUserToken = pPCB->hUserToken;

        if (hUserToken != NULL)
        {
            if (!ImpersonateLoggedOnUser (hUserToken))
            {
                dwRetCode = GetLastError();
                TRACE1 (USER, "ElGetLoggedOnUserName: ImpersonateLoggedOnUser failed with error %ld",
                        dwRetCode);
                break;
            }

            fNeedToRevertToSelf = TRUE;


            dwBufferSize = 0;
            if (!GetUserNameEx (NameSamCompatible,
                        NULL,
                        &dwBufferSize))
            {
                dwRetCode = GetLastError ();
                if (dwRetCode == ERROR_MORE_DATA)
                {
                    if ((pwszUserNameBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                    {
                        TRACE0 (ANY, "ElGetLoggedOnUserName: MALLOC failed for pwszUserNameBuffer");
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
    
                    if (!GetUserNameEx (NameSamCompatible,
                                            pwszUserNameBuffer,
                                            &dwBufferSize))
                    {
                        dwRetCode = GetLastError ();
                        TRACE1 (ANY, "ElGetLoggedOnUserName: GetUserNameEx failed with error %ld",
                                dwRetCode);
                        break;
                    }
                    pwszUserNameBuffer[dwBufferSize]=L'\0';
    
                    TRACE1 (ANY, "ElGetLoggedOnUserName: Got User Name %S",
                            pwszUserNameBuffer);
                }
                else
                {
                    TRACE1 (ANY, "ElGetLoggedOnUserName: GetUserNameEx failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
        }
        else
        {
            TRACE0 (ANY, "ElGetLoggedOnUserName: UserToken is NULL");
            break;
        }

    } while (FALSE);


    if (pwszUserNameBuffer != NULL)
    {
        FREE (pwszUserNameBuffer);
    }

    // Revert impersonation
            
    if (fNeedToRevertToSelf)
    {
        if (!RevertToSelf())
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetLoggedOnUserName: Error in RevertToSelf = %ld",
                    dwRetCode);
        }
    }

    return dwRetCode;

}


//
// ElGetMachineName
//
// Description:
//
// Get the machine name of the computer the service is currently running on
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which machine name is to
//              to be obtained
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElGetMachineName (
        IN      EAPOL_PCB       *pPCB
        )
{
    WCHAR               *pwszComputerNameBuffer = NULL;
    CHAR                *pszComputerNameBuffer = NULL;
    WCHAR               *pwszComputerDomainBuffer = NULL;
    CHAR                *pszComputerDomainBuffer = NULL;
    DWORD               dwBufferSize = 0;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        dwBufferSize = 0;
        if (!GetComputerNameEx (ComputerNamePhysicalNetBIOS,
                                    NULL,
                                    &dwBufferSize))
        {
            dwRetCode = GetLastError ();
            if (dwRetCode == ERROR_MORE_DATA)
            {
                // Reset error
                dwRetCode = NO_ERROR;
                if ((pwszComputerNameBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pwszComputerNameBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (!GetComputerNameEx (ComputerNamePhysicalNetBIOS,
                                        pwszComputerNameBuffer,
                                        &dwBufferSize))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                            dwRetCode);
                    break;
                }

                TRACE1 (ANY, "ElGetMachineName: Got Computer Name %S",
                        pwszComputerNameBuffer);

                pszComputerNameBuffer = 
                    MALLOC (wcslen(pwszComputerNameBuffer) + 1);
                if (pszComputerNameBuffer == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pszComputerNameBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (0 == WideCharToMultiByte (
                            CP_ACP,
                            0,
                            pwszComputerNameBuffer,
                            -1,
                            pszComputerNameBuffer,
                            wcslen(pwszComputerNameBuffer)+1,
                            NULL, 
                            NULL ))
                {
                    dwRetCode = GetLastError();
         
                    TRACE2 (ANY, "ElGetMachineName: WideCharToMultiByte (%ws) failed: %ld",
                            pwszComputerNameBuffer, dwRetCode);
                    break;
                }

                pszComputerNameBuffer[wcslen(pwszComputerNameBuffer)] = L'\0';

            }
            else
            {
                TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        dwBufferSize = 0;
        if (!GetComputerNameEx (ComputerNamePhysicalDnsDomain,
                                    NULL,
                                    &dwBufferSize))
        {
            dwRetCode = GetLastError ();
            if (dwRetCode == ERROR_MORE_DATA)
            {
                // Reset error
                dwRetCode = NO_ERROR;
                if ((pwszComputerDomainBuffer = MALLOC (dwBufferSize*sizeof(WCHAR))) == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pwszComputerDomainBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (!GetComputerNameEx (ComputerNamePhysicalDnsDomain,
                                        pwszComputerDomainBuffer,
                                        &dwBufferSize))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx Domain failed with error %ld",
                            dwRetCode);
                    break;
                }

                TRACE1 (ANY, "ElGetMachineName: Got Computer Domain %S",
                        pwszComputerDomainBuffer);

                pszComputerDomainBuffer = 
                    MALLOC (wcslen(pwszComputerDomainBuffer) + 1);
                if (pszComputerDomainBuffer == NULL)
                {
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pszComputerDomainBuffer");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (0 == WideCharToMultiByte (
                            CP_ACP,
                            0,
                            pwszComputerDomainBuffer,
                            -1,
                            pszComputerDomainBuffer,
                            wcslen(pwszComputerDomainBuffer)+1,
                            NULL, 
                            NULL ))
                {
                    dwRetCode = GetLastError();
         
                    TRACE2 (ANY, "ElGetMachineName: WideCharToMultiByte (%ws) failed: %ld",
                            pwszComputerDomainBuffer, dwRetCode);
                    break;
                }

                pszComputerDomainBuffer[wcslen(pwszComputerDomainBuffer)] = L'\0';
                *(strrchr (pszComputerDomainBuffer, '.')) = '\0';

                if (pPCB->pszIdentity != NULL)
                {
                    FREE (pPCB->pszIdentity);
                    pPCB->pszIdentity = NULL;
                }

                pPCB->pszIdentity = MALLOC (strlen(pszComputerDomainBuffer) +
                        strlen(pszComputerNameBuffer) + 3);

                if (pPCB->pszIdentity == NULL)
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    TRACE0 (ANY, "ElGetMachineName: MALLOC failed for pPCB->pszIdentity");
                    break;
                }
                        
                memcpy (pPCB->pszIdentity, 
                        pszComputerDomainBuffer,
                        strlen(pszComputerDomainBuffer));
                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)] = '\\';
                memcpy (&pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1], 
                        pszComputerNameBuffer,
                        strlen(pszComputerNameBuffer));

                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1+strlen(pszComputerNameBuffer)] = '$';
                pPCB->pszIdentity[strlen(pszComputerDomainBuffer)+1+strlen(pszComputerNameBuffer)+1] = '\0';

            }
            else
            {
                TRACE1 (ANY, "ElGetMachineName: GetComputerNameEx failed with error %ld",
                        dwRetCode);
                break;
            }
        }

    } while (FALSE);


    if (pwszComputerNameBuffer != NULL)
    {
        FREE (pwszComputerNameBuffer);
    }

    if (pszComputerNameBuffer != NULL)
    {
        FREE (pszComputerNameBuffer);
    }

    if (pwszComputerDomainBuffer != NULL)
    {
        FREE (pwszComputerDomainBuffer);
    }

    if (pszComputerDomainBuffer != NULL)
    {
        FREE (pszComputerDomainBuffer);
    }

    return dwRetCode;

}


//
// ElUpdateRegistryInterfaceList
//
// Description:
//
// Write the interface list to which NDISUIO is bound to, to the registry
//
// Arguments:
//      Interfaces - Interface list containing Device Name and Description
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
//
//

DWORD
ElUpdateRegistryInterfaceList (
        IN  PNDIS_ENUM_INTF     Interfaces
        )
{
    CHAR        *pszRegInterfaceList = NULL;
    HKEY        hkey = NULL;
    DWORD       dwDisposition = 0;
    LONG        lError = ERROR_SUCCESS;

    DWORD       dwRetCode = NO_ERROR;

    do 
    {
        ANSI_STRING		InterfaceName;
        UCHAR			ucBuffer[256];
        DWORD			i;
        DWORD           dwSizeOfList = 0;


        // Determine the number of bytes in the list
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
        
            ZeroMemory (ucBuffer, 256);
            InterfaceName.Length = 0;
            InterfaceName.MaximumLength = 256;
            InterfaceName.Buffer = ucBuffer;

            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                if (RtlUnicodeStringToAnsiString(&InterfaceName, 
                        &(Interfaces->Interface[i].DeviceName), FALSE) != STATUS_SUCCESS)
                {
                    TRACE1 (ANY, "ElUpdateRegistryInterfaceList: Error in RtlUnicodeStringToAnsiString for DeviceName %ws",
                            Interfaces->Interface[i].DeviceName.Buffer);
                }

                InterfaceName.Buffer[InterfaceName.Length] = '\0';

                dwSizeOfList += (strlen(InterfaceName.Buffer) + 1);
            }
            else
            {
                TRACE0(INIT, "ElUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }

            TRACE1(INIT, "Device: %s", InterfaceName.Buffer);

        }

        // One extra char for terminating NULL char
        pszRegInterfaceList = (CHAR *) MALLOC ( dwSizeOfList + 1 );

        if ( pszRegInterfaceList == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElUpdateRegistryInterfaceList: MALLOC failed for pszRegInterfaceList");
            break;
        }

        // Start again
        dwSizeOfList = 0;

        // Create the string in REG_SZ format
        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            ZeroMemory (ucBuffer, 256);
            InterfaceName.Length = 0;
            InterfaceName.MaximumLength = 256;
            InterfaceName.Buffer = ucBuffer;

            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                if (RtlUnicodeStringToAnsiString(&InterfaceName, 
                        &Interfaces->Interface[i].DeviceName, FALSE) != 
                                                                STATUS_SUCCESS)
                {
                    TRACE0 (ANY, "ElUpdateRegistryInterfaceList: Error in RtlUnicodeStringToAnsiString for DeviceName");
                }

                InterfaceName.Buffer[InterfaceName.Length] = '\0';

                memcpy (&pszRegInterfaceList[dwSizeOfList], 
                        InterfaceName.Buffer, 
                        (strlen(InterfaceName.Buffer) ));
                dwSizeOfList += (strlen(InterfaceName.Buffer));
            }
            else
            {
                TRACE0(INIT, "ElUpdateRegistryInterfaceList: Device Name was NULL");
                continue;
            }
        }

        // Final NULL character
        pszRegInterfaceList[dwSizeOfList++] = '\0';

        // Write the string as a REG_SZ value

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolServiceParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hkey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElUpdateRegistryInterfaceList: Error in RegCreateKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        //
        // Set the value of 
        // ...\EAPOL\Parameters\General\InterfaceList key
        //

        if ((lError = RegSetValueExA (
                        hkey,
                        cszInterfaceList,
                        0,
                        REG_SZ,
                        pszRegInterfaceList,
                        dwSizeOfList)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElUpdateRegistryInterfaceList: Error in RegSetValueExA for InterfaceList, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE0 (ANY, "ElUpdateRegistryInterfaceList: Set value succeeded");

    } while (FALSE);

    if (hkey != NULL)
    {
        RegCloseKey (hkey);
    }

    if (pszRegInterfaceList != NULL)
    {
        FREE (pszRegInterfaceList);
    }

    return dwRetCode;
}


//
// ElWatchGlobalRegistryParams
//
// Description:
//
// Watch the registry for changes for global params. Update in-memory values
//
// Arguments:
//      Unused
//
// Return values:
//
//

VOID 
ElWatchGlobalRegistryParams (
        IN  PVOID pvContext
        )
{
    HKEY        hKey = NULL;
    HANDLE      hRegChangeEvent = NULL;
    HANDLE      hEvents[2];
    BOOL        fExitThread = FALSE;
    DWORD       dwDisposition = 0;
    DWORD       dwStatus = 0;
    LONG        lError = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "ElWatchGlobalRegistryParams: Entered");

    do
    {

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General\Global

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEAPOLGlobalParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWatchGlobalRegistryParams: Error in RegCreateKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Open a handle to a event to perform wait on that event

        hRegChangeEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hRegChangeEvent == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (ANY, "ElWatchGlobalRegistryParams: Error in CreateEvent for hRegChangeEvent = %ld",
                    dwRetCode);
            break;
        }


        // Register to notify change in registry value

        if ((lError = RegNotifyChangeKeyValue (
                        hKey,
                        TRUE,                       // watch entire sub-tree
                        REG_NOTIFY_CHANGE_LAST_SET, // detect value add/delete
                        hRegChangeEvent,
                        TRUE                        // asynchronous
                        )) != ERROR_SUCCESS)
        {
            dwRetCode = (DWORD)lError;
            TRACE1 (ANY, "ElWatchGlobalRegistryParams: RegNotifyChangeKeyValue failed with error %ld",
                    dwRetCode);
            break;
        }

        do 
        {

            // Wait for Registry changes or service termination

            hEvents[0] = hRegChangeEvent;
            hEvents[1] = g_hEventTerminateEAPOL;

            if ((dwStatus = WaitForMultipleObjects(
                            2,
                            hEvents,
                            FALSE,
                            INFINITE
                            )) == WAIT_FAILED)
            {
                dwRetCode = GetLastError ();
                TRACE1 (ANY, "ElWatchGlobalRegistryParams: WaitForMultipleObjects failed with error %ld",
                        dwRetCode);
                break;
            }
            
            switch (dwStatus)
            {

                case WAIT_OBJECT_0:

                    // Registry values changed
                    // Update in-memory values

                    if ((dwRetCode = ElReadGlobalRegistryParams ()) != NO_ERROR)
                    {
                        TRACE1 (ANY, "ElWatchGlobalRegistryParams: ElReadGlobalRegistryParams failed with error %ld",
                                dwRetCode);

                        // continue processing since this is not a critical error
                        dwRetCode = NO_ERROR;
                    }

                    if (!ResetEvent(hRegChangeEvent))
                    {
                        dwRetCode = GetLastError ();
                        TRACE1 (ANY, "ElWatchGlobalRegistryParams: ResetEvent failed with error %ld",
                                dwRetCode);
                        break;
                    }


                    break;

                case WAIT_OBJECT_0+1:

                    // Service shutdown detected
                    fExitThread = TRUE;
                    break;

                default:

                    TRACE1 (ANY, "ElWatchGlobalRegistryParams: No such event = %ld",
                            dwStatus);
                    break;
            }

            if ((dwRetCode != NO_ERROR) || (fExitThread))
            {
                break;
            }

        } while (TRUE);
        

    } while (FALSE);

    TRACE1 (ANY, "ElWatchGlobalRegistryParams: Completed with error %ld",
            dwRetCode);

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return;

}


//
// ElReadGlobalRegistryParams
//
// Description:
//
// Read registry parameters global to EAPOL state machine
//  i.e. maxStart, startPeriod, authPeriod, heldPeriod
//
// Arguments:
//      Unused
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElReadGlobalRegistryParams ()
{
    HKEY        hKey = NULL;
    DWORD       dwDisposition = 0;
    DWORD       dwType = 0;
    DWORD       dwInfoSize = 0;
    DWORD       lError = 0;
    DWORD       dwmaxStart=0, dwstartPeriod=0, dwauthPeriod=0, dwheldPeriod=0;
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General\Global

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEAPOLGlobalParams,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElReadGlobalRegistryParams: Error in RegCreateKeyExA for base key, %ld",
                    lError);
            break;
        }

            
        ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);

        // If setting values for the first time, initialize values

        if (!(g_dwmaxStart || g_dwstartPeriod || g_dwauthPeriod || g_dwheldPeriod))
        {
            g_dwmaxStart = EAPOL_MAX_START;
            g_dwstartPeriod = EAPOL_START_PERIOD;
            g_dwauthPeriod = EAPOL_AUTH_PERIOD;
            g_dwheldPeriod = EAPOL_HELD_PERIOD;
        }

        RELEASE_WRITE_LOCK (&g_EAPOLConfig);

        dwmaxStart = g_dwmaxStart;
        dwstartPeriod = g_dwstartPeriod;
        dwauthPeriod = g_dwauthPeriod;
        dwheldPeriod = g_dwheldPeriod;


        // Get the value of ..\General\EAPOLGlobal\authPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey,
                        cszAuthPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwauthPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueExA for cszAuthPeriod, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwauthPeriod = g_dwauthPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\heldPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey,
                        cszHeldPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwheldPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueExA for cszHeldPeriod, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwheldPeriod = g_dwheldPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\startPeriod

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey,
                        cszStartPeriod,
                        0,
                        &dwType,
                        (BYTE *)&dwstartPeriod,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueExA for cszStartPeriod, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwstartPeriod = g_dwstartPeriod;
            lError = ERROR_SUCCESS;
        }

        // Get the value of ..\General\EAPOLGlobal\maxStart

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey,
                        cszMaxStart,
                        0,
                        &dwType,
                        (BYTE *)&dwmaxStart,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElReadGlobalRegistryParams: Error in RegQueryValueExA for cszMaxStart, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwmaxStart = g_dwmaxStart;
            lError = ERROR_SUCCESS;
        }

        // Successful in reading all parameters
        
        ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);

        g_dwmaxStart = dwmaxStart;
        g_dwstartPeriod = dwstartPeriod;
        g_dwauthPeriod = dwauthPeriod;
        g_dwheldPeriod = dwheldPeriod;

        RELEASE_WRITE_LOCK (&g_EAPOLConfig);

    } while (FALSE);
    
    dwRetCode = (DWORD)lError;
    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (ANY, "ElReadGlobalRegistryParams: failed with error %ld",
            dwRetCode);
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return dwRetCode;

}


//
// ElWatchEapConfigRegistryParams
//
// Description:
//
// Watch the registry for changes in EAP config
//  - HKLM - EAP type
//  - HKLM - EAPOLEnabled
//
//  Restart the state machine if the params change
//
// Arguments:
//
// Return values:
//
//

VOID 
ElWatchEapConfigRegistryParams (
        IN  PVOID pvContext
        )
{
    HKEY        hUserKey = NULL;
    HKEY        hWorkspaceKey = NULL;
    HKEY        hRegChangeKey = NULL;
    HANDLE      hRegChangeEvent = NULL;
    HANDLE      hEvents[2];
    HANDLE      hUserToken = NULL;
    DWORD       dwDisposition = 0;
    BOOL        fExitThread = FALSE;
    DWORD       dwStatus = 0;
    LONG        lError = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "ElWatchEapConfigRegistryParams: Entered");

    do
    {

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hWorkspaceKey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElWatchEapConfigRegistryParams: Error in RegCreateKeyExA for cszEapKeyEapolConn, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Open a handle to a event to perform wait on that event

        hRegChangeEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hRegChangeEvent == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (ANY, "ElWatchEapConfigRegistryParams: Error in CreateEvent for hRegChangeEvent = %ld",
                    dwRetCode);
            break;
        }


        do 
        {
            // Register to notify change in registry value

            if ((lError = RegNotifyChangeKeyValue (
                            hWorkspaceKey,
                            TRUE,                       // watch entire sub-tree
                            REG_NOTIFY_CHANGE_LAST_SET, // detect value add/delete
                            hRegChangeEvent,
                            TRUE                        // asynchronous
                            )) != ERROR_SUCCESS)
            {
                dwRetCode = (DWORD)lError;
                TRACE1 (ANY, "ElWatchEapConfigRegistryParams: RegNotifyChangeKeyValue failed with error %ld",
                        dwRetCode);
                break;
            }

            // Wait for Registry changes, service termination

            hEvents[0] = hRegChangeEvent;
            hEvents[1] = g_hEventTerminateEAPOL;

            if ((dwStatus = WaitForMultipleObjects(
                            2,
                            hEvents,
                            FALSE,
                            INFINITE
                            )) == WAIT_FAILED)
            {
                dwRetCode = GetLastError ();
                TRACE1 (ANY, "ElWatchEapConfigRegistryParams: WaitForMultipleObjects failed with error %ld",
                        dwRetCode);
                break;
            }
            
            switch (dwStatus)
            {

                case WAIT_OBJECT_0:
                    
                    TRACE0 (ANY, "ElWatchEapConfigRegistryParams: Got reg change event !!! ");

                    // Registry values changed
                    // Update in memory values
                    if ((dwRetCode = ElProcessEapConfigChange ()) != NO_ERROR)
                    {
                        TRACE1 (ANY, "ElWatchEapConfigRegistryParams: ElProcessEapConfigChange failed with error %ld",
                                dwRetCode);

                        // log

                        // continue processing since this is not a critical error
                        dwRetCode = NO_ERROR;
                    }

                    if (!ResetEvent(hRegChangeEvent))
                    {
                        dwRetCode = GetLastError ();
                        TRACE1 (ANY, "ElWatchEapConfigRegistryParams: ResetEvent failed with error %ld",
                                dwRetCode);
                        break;
                    }

                    break;

                case WAIT_OBJECT_0+1:

                    // Service shutdown detected
                    fExitThread = TRUE;
                    TRACE0 (ANY, "ElWatchEapConfigRegistryParams: Service shutdonw");
                    break;

                default:

                    TRACE1 (ANY, "ElWatchEapConfigRegistryParams: No such event = %ld",
                            dwStatus);
                    break;
            }

            if ((dwRetCode != NO_ERROR) || (fExitThread))
            {
                break;
            }

            TRACE0 (ANY, "ElWatchEapConfigRegistryParams: RegNotifyChangeKeyValue being reposted !!!");

        } while (TRUE);
        

    } while (FALSE);

    TRACE1 (ANY, "ElWatchEapConfigRegistryParams: Completed with error %ld",
            dwRetCode);

    if (hUserKey != NULL)
    {
        RegCloseKey(hUserKey);
    }

    if (hWorkspaceKey != NULL)
    {
        RegCloseKey(hWorkspaceKey);
    }

    if (!CloseHandle(hRegChangeEvent))
    {
        TRACE1 (ANY, "ElWatchEapConfigRegistryParams: Error in closing event handle", (dwRetCode = GetLastError()));
    }

    return;

}


//
// ElProcessEapConfigChange
//
// Description:
//
// Read EAP config changes made in registry. Restart EAPOL on the particular
// interface or stop EAPOL
//
// Arguments:
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElProcessEapConfigChange ()
{
    DWORD       dwEapolEnabled = 0;
    DWORD       dwDefaultEAPType = 0;
    CHAR        szLastUsedSSID[256];
    HKEY        hWorkspaceKey = NULL;
    HKEY        hKey = NULL, hKey1 = NULL;
    DWORD       dwType = 0;
    DWORD       dwInfoSize = 0;
    DWORD       dwDisposition = 0;
    CHAR        *pszLastModifiedGUID = NULL;
    DWORD       dwbData = 0;
    PBYTE       pbAuthData = NULL;
    EAPOL_PCB   *pPCB = NULL;
    BOOL        fReStartAuthentication = FALSE;
    LONG        lError = 0;
    DWORD       dwRetCode = NO_ERROR;

    do
    {
        // Get the GUID for the interface for which EAP config was modified

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\General\EAPOLGlobal

        if ((lError = RegCreateKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEAPOLWorkspace,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hWorkspaceKey,
                        &dwDisposition)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: Error in RegCreateKeyExA for cszEAPOLWorkspace key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }


        // Get the value of ..\General\EAPOLGlobal\LastModifiedGUID

        dwInfoSize = 0;
        if ((lError = RegQueryValueExA (
                        hWorkspaceKey,
                        cszLastModifiedGUID,
                        0,
                        &dwType,
                        NULL,
                        &dwInfoSize)) == ERROR_SUCCESS)
        {
            if ((pszLastModifiedGUID = (CHAR *) MALLOC ( dwInfoSize ))
                    == NULL)
            {
                TRACE0 (ANY, "ElProcessEapConfigChange: Error in MALLOC for pszLastModifiedGUID");
                lError = (ULONG) ERROR_NOT_ENOUGH_MEMORY;
                dwRetCode = (DWORD)lError;
                break;
            }

            if ((lError = RegQueryValueExA (
                            hWorkspaceKey,
                            cszLastModifiedGUID,
                            0,
                            &dwType,
                            pszLastModifiedGUID,
                            &dwInfoSize)) != ERROR_SUCCESS)
            {
                TRACE1 (ANY, "ElProcessEapConfigChange: RegQueryValueExA failed for pszLastModifiedGUID with error %ld",
                        lError);
                dwRetCode = (DWORD)lError;
                break;
            }
        }
        else
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: Error in estimating size fo cszLastModifiedGUID = %ld",
                    lError);
            break;
        }


        // Check the value of EAPOLEnabled for that interface

        // Get handle to HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces

        if ((lError = RegOpenKeyExA (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolConn,
                        0,
                        KEY_READ,
                        &hKey
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: Error in RegOpenKeyExA for base key, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get handle to HKLM\Software\...\Interfaces\<GUID>

        if ((lError = RegOpenKeyExA (
                        hKey,
                        pszLastModifiedGUID,
                        0,
                        KEY_READ,
                        &hKey1
                        )) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: Error in RegOpenKeyExA for GUID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get the value of ..\Interfaces\GUID\EapolEnabled 
        // This value should exist since it will always be set from UI

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey1,
                        cszEapolEnabled,
                        0,
                        &dwType,
                        (BYTE *)&dwEapolEnabled,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElProcessEapConfigChange: Error in RegQueryValueExA for EapolEnabled, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwRetCode = (DWORD)lError;
            break;
        }

        TRACE1 (ANY, "ElProcessEapConfigChange: Got EapolEnabled = %ld", dwEapolEnabled);

        // Get the value of ..\Interfaces\GUID\DefaultEAPType 
        // This value should exist since it will always be set from UI

        dwInfoSize = sizeof(DWORD);
        if ((lError = RegQueryValueExA (
                        hKey1,
                        cszDefaultEAPType,
                        0,
                        &dwType,
                        (BYTE *)&dwDefaultEAPType,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE2 (ANY, "ElProcessEapConfigChange: Error in RegQueryValueExA for DefaultEAPType, %ld, InfoSize=%ld",
                    lError, dwInfoSize);
            dwRetCode = (DWORD)lError;
            break;
        }

        // Get the value of ..\Interfaces\GUID\LastUsedSSID 

        dwInfoSize = 256;
        ZeroMemory ((BYTE *)szLastUsedSSID, 256);
        if ((lError = RegQueryValueExA (
                        hKey1,
                        cszLastUsedSSID,
                        0,
                        &dwType,
                        (PUCHAR)szLastUsedSSID,
                        &dwInfoSize)) != ERROR_SUCCESS)
        {
            TRACE1 (ANY, "ElProcessEapConfigChange: Error in RegQueryValueExA for LastUsedSSID, %ld",
                    lError);
            dwRetCode = (DWORD)lError;
            if (dwRetCode == ERROR_FILE_NOT_FOUND)
            {
                // SSID may not be received as yet from AP/switch
                // Changes will be made stored for "Default" SSID
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
        }


        // Check existence/absence of PCB i.e. if EAPOL state machine was
        // started on the interface, and take appropriate action based on
        // EAPOLEnabled value

        if (dwEapolEnabled == 0)
        {
            ACQUIRE_WRITE_LOCK (&(g_PCBLock));

            if ((pPCB = ElGetPCBPointerFromPortGUID (pszLastModifiedGUID)) 
                    != NULL)
            {
                RELEASE_WRITE_LOCK (&(g_PCBLock));

                // Found PCB for interface, where EAPOLEnabled = 0
                // Stop EAPOL on the port and remove the port from the module

                if ((dwRetCode = ElShutdownInterface (pszLastModifiedGUID))
                            != NO_ERROR)
                {
                    TRACE1 (ANY, "ElProcessEapConfigChange: ElShutdownInterface failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
            else
            {
                // No PCB found for interface, valid condition,
                // continue processing
                RELEASE_WRITE_LOCK (&(g_PCBLock));
            }
        }
        else
        {
            ACQUIRE_WRITE_LOCK (&(g_PCBLock));

            if ((pPCB = ElGetPCBPointerFromPortGUID (pszLastModifiedGUID)) 
                    == NULL)
            {
                RELEASE_WRITE_LOCK (&(g_PCBLock));

                // Did not find PCB for interface, where EAPOLEnabled = 1
                // Start EAPOL on the port

                ACQUIRE_WRITE_LOCK (&g_ITFLock);

                if ((dwRetCode = ElEnumAndOpenInterfaces (NULL,
                                                        pszLastModifiedGUID))
                        != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&g_ITFLock);
                    TRACE1 (ANY, "ElProcessEapConfigChange: ElEnumAndOpenInterfaces returned error %ld",
                            dwRetCode);
                    break;
                }

                RELEASE_WRITE_LOCK (&g_ITFLock);
            }
            else
            {
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                if (pPCB->dwEapTypeToBeUsed != dwDefaultEAPType)
                {

                    // Default EAP Type has changed

                    fReStartAuthentication = TRUE;

                }
                else
                {
                    // Default EAP Type is the same
                    // Check if the CustomAuthData is the same
                    // If not the same, do further processing
                    // Else, no change occured, same config was reapplied

                    // Get the size of the EAP blob
                    if ((dwRetCode = ElGetCustomAuthData (
                                    pszLastModifiedGUID,
                                    dwDefaultEAPType,
                                    szLastUsedSSID,
                                    NULL,
                                    &dwbData
                                    )) != NO_ERROR)
                    {
                        if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
                        {
                            if (dwbData <= 0)
                            {
                                if (pPCB->pCustomAuthConnData->pbCustomAuthData)
                                {
                                    // No EAP blob stored in the registry
                                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                                    RELEASE_WRITE_LOCK (&(g_PCBLock));
                                    TRACE0 (ANY, "ElProcessEapConfigChange: NULL sized EAP blob, cannot continue");
                                    pbAuthData = NULL;
                                
                                    dwRetCode = ERROR_CAN_NOT_COMPLETE;
                                    break;
                                }
                            }
                            else
                            {
                                // Allocate memory to hold the blob
                                pbAuthData = MALLOC (dwbData);
                                if (pbAuthData == NULL)
                                {
                                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                                    RELEASE_WRITE_LOCK (&(g_PCBLock));
                                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                                    TRACE0 (ANY, "ElProcessEapConfigChange: Error in memory allocation for EAP blob");
                                    break;
                                }
                                if ((dwRetCode = ElGetCustomAuthData (
                                            pszLastModifiedGUID,
                                            dwDefaultEAPType,
                                            szLastUsedSSID,
                                            pbAuthData,
                                            &dwbData
                                            )) != NO_ERROR)
                                {
                                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                                    RELEASE_WRITE_LOCK (&(g_PCBLock));
                                    TRACE1 (ANY, "ElProcessEapConfigChange: ElGetCustomAuthData failed with %ld",
                                            dwRetCode);
                                    break;
                                }
                            }
                        }
                        else
                        {
                            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                            RELEASE_WRITE_LOCK (&(g_PCBLock));
                            TRACE1 (ANY, "ElProcessEapConfigChange: ElGetCustomAuthData failed in size estimation with error %ld",
                                    dwRetCode);
                            break;
                        }
                    }

                    if (pPCB->pCustomAuthConnData == NULL)
                    {
                        if (dwbData > 0)
                        {
                            fReStartAuthentication = TRUE;
                        }
                    }
                    else
                    {
                        if (pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData
                                != dwbData)
                        {
                            // Same EAP Type, but different lengths

                            fReStartAuthentication = TRUE;
                        }
                        else
                        {
                            if (memcmp (
                                    pPCB->pCustomAuthConnData->pbCustomAuthData, 
                                    pbAuthData, dwbData) != 0)
                            {
                                // Same EAP Type, same data length, but 
                                // different contents

                                fReStartAuthentication = TRUE;
                            }
                            else
                            {
                                // No change in EAP config data for this 
                                // interface
                            }
                        }
                    }

                }
                                    
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));

                if (fReStartAuthentication)
                {
                    if ((dwRetCode = ElReStartPort (pPCB)) != NO_ERROR)
                    {
                        RELEASE_WRITE_LOCK (&(g_PCBLock));
                        TRACE1 (ANY, "ElProcessEapConfigChange: Error in ElReStartPort = %d",
                                dwRetCode);
                        break;
                    }
                }

                RELEASE_WRITE_LOCK (&(g_PCBLock));

            }
        }

    } while (FALSE);
    
    if (hWorkspaceKey != NULL)
    {
        RegCloseKey(hWorkspaceKey);
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if (hKey1 != NULL)
    {
        RegCloseKey(hKey1);
    }

    if (pszLastModifiedGUID != NULL)
    {
        FREE (pszLastModifiedGUID);
    }

    if (pbAuthData != NULL)
    {
        FREE (pbAuthData);
    }


    return dwRetCode;
}


//
// ElStringToGuid
//
// Description:
//
// Function to convert a Guid-String to a GUID
//
// Arguments:
//      psGuid  - String-ized Guid
//      pGuid   - Pointer to Guid
//
// Return values:
//  None
//

VOID
ElStringToGuid (
        IN  CHAR        * psGuid,
        OUT LPGUID      pGuid      
        )
{
    CHAR    c;
    DWORD   i=0;

    //
    // If the first character is a '{', skip it.
    //

    if ( psGuid[0] == L'{' )
        psGuid++;


    //
    // Convert string to guid
    // (since psGuid may be used again below, no permanent modification to
    //  it may be made)
    //

    c = psGuid[8];
    psGuid[8] = 0;
    pGuid->Data1 = strtoul ( &psGuid[0], 0, 16 );
    psGuid[8] = c;
    c = psGuid[13];
    psGuid[13] = 0;
    pGuid->Data2 = (USHORT)strtoul ( &psGuid[9], 0, 16 );
    psGuid[13] = c;
    c = psGuid[18];
    psGuid[18] = 0;
    pGuid->Data3 = (USHORT)strtoul ( &psGuid[14], 0, 16 );
    psGuid[18] = c;

    c = psGuid[21];
    psGuid[21] = 0;
    pGuid->Data4[0] = (unsigned char)strtoul ( &psGuid[19], 0, 16 );
    psGuid[21] = c;
    c = psGuid[23];
    psGuid[23] = 0;
    pGuid->Data4[1] = (unsigned char)strtoul ( &psGuid[21], 0, 16 );
    psGuid[23] = c;

    for ( i=0; i < 6; i++ )
    {
        c = psGuid[26+i*2];
        psGuid[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)strtoul ( &psGuid[24+i*2], 0, 16 );
        psGuid[26+i*2] = c;
    }

    return;
}


//
// ElGetIdentity
//
// Description:
//
// Get the identity depending on the authentication type being used
//
// Arguments:
//      pPCB - Pointer to PCB for the port
//
// Return values:
//
//  NO_ERROR - success
//  non-zero - error
//

DWORD
ElGetIdentity (
        IN  EAPOL_PCB   *pPCB
        )
{
    DWORD       dwRetCode = NO_ERROR;

    do
    {

            // Get user's identity if it has not been obtained till now
            if ((g_fUserLoggedOn) && 
                    (pPCB->dwAuthFailCount <= EAPOL_MAX_AUTH_FAIL_COUNT) &&
                    (pPCB->PreviousAuthenticationType != EAPOL_MACHINE_AUTHENTICATION))
            {
                TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth");
                if (!(pPCB->fGotUserIdentity))
                {

                    // NOTE: Hardcoding for now
                    // Needs to be solved

                    if (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)
                    {
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: MD5");
                        // EAP-MD5CHAP
                        if ((dwRetCode = ElGetUserNamePassword (
                                            pPCB)) != NO_ERROR)
                        {
                            TRACE1 (ANY, "ElEapMakeMessage: Error in ElGetUserNamePassword %ld",
                                    dwRetCode);
                        }
                    }
                    else
                    {
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: !MD5");
                        // All other EAP Types
                        if ((dwRetCode = ElGetUserIdentity (
                                            pPCB)) != NO_ERROR)
                        {
                            TRACE1 (ANY, "ElEapMakeMessage: Error in ElGetUserIdentity %ld",
                                    dwRetCode);
                        }
                    }

                    if (dwRetCode == NO_ERROR)
                    {
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: No Error: User Auth fine");
                        pPCB->PreviousAuthenticationType = EAPOL_USER_AUTHENTICATION;
                    }
                    else
                    {
                        TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: Error");

                        // No UI required
                        if ((pPCB->dwEapTypeToBeUsed != EAP_TYPE_MD5) &&
                                (g_dwMachineAuthEnabled))
                        {
                            TRACE0 (ANY, "ElGetIdentity: Userlogged, <Maxauth, Prev !Machine auth: Error: !MD5, Machine Auth");

                            // Get Machine name
                            dwRetCode = NO_ERROR;
                            pPCB->PreviousAuthenticationType = 
                                        EAPOL_MACHINE_AUTHENTICATION;
                            dwRetCode = ElGetUserIdentity (pPCB);
                        
                            if (dwRetCode != NO_ERROR)
                            {
                                TRACE1 (ANY, "ElGetIdentity: ElGetUserIdentity failed with error %ld",
                                    dwRetCode);
                            }
                        }

                        if ((dwRetCode != NO_ERROR) ||
                                (!g_dwMachineAuthEnabled) ||
                                (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5))
                        {
                            TRACE3 (ANY, "ElGetIdentity: Userlogged, <Maxauth, !Machine auth: Error: Error=%ld, Machauth=%ld, MD5=%ld",
                                    dwRetCode?1:0,
                                    g_dwMachineAuthEnabled?1:0,
                                    (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)?1:0);

                            if (pPCB->pszIdentity != NULL)
                            {
                                FREE (pPCB->pszIdentity);
                                pPCB->pszIdentity = NULL;
                            }

                            pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                            dwRetCode = NO_ERROR;
                        }
                    }
                }
            }
            else
            {
                TRACE2 (ANY, "ElGetIdentity: Userlogged=%ld, auth>max, Machine auth=%ld",
                        g_fUserLoggedOn?1:0, 
                        (pPCB->PreviousAuthenticationType==EAPOL_MACHINE_AUTHENTICATION)?1:0 );

                // No UI required
                if ((pPCB->dwEapTypeToBeUsed != EAP_TYPE_MD5) &&
                        (g_dwMachineAuthEnabled))
                {

                    TRACE0 (ANY, "ElGetIdentity: !MD5, Machine auth");

                    pPCB->PreviousAuthenticationType = EAPOL_MACHINE_AUTHENTICATION;

                    // Get Machine credentials
                    dwRetCode = ElGetUserIdentity (pPCB);

                    if (dwRetCode != NO_ERROR)
                    {
                        TRACE1 (ANY, "ElGetIdentity: ElGetUserIdentity failed with error %ld",
                                dwRetCode);
                    }
                }

                if ((dwRetCode != NO_ERROR) ||
                    (!g_dwMachineAuthEnabled) ||
                        (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5))
                {
                    TRACE3 (ANY, "ElGetIdentity: Error=%ld, Machine auth=%ld, MD5=%ld",
                                    dwRetCode?1:0,
                                    g_dwMachineAuthEnabled?1:0,
                                    (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)?1:0);

                    if (pPCB->pszIdentity != NULL)
                    {
                        FREE (pPCB->pszIdentity);
                        pPCB->pszIdentity = NULL;
                    }

                    pPCB->PreviousAuthenticationType = EAPOL_UNAUTHENTICATED_ACCESS;
                    dwRetCode = NO_ERROR;
                }
            }

    }
    while (FALSE);

    return dwRetCode;
}



//
// ElNLAConnectLPC
//
// Description: 
//
// Function called to connect to the LPC port for NLA service
//
// Arguments:
//      None
//
// Return values:
//      Non-NULL - valid handle
//      NULL - error
//

HANDLE
ElNLAConnectLPC () 
{

    HANDLE              h = NULL;
    LARGE_INTEGER       sectionSize;
    UNICODE_STRING      portName;
    SECURITY_QUALITY_OF_SERVICE dynamicQoS = 
    {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityAnonymous,
        SECURITY_DYNAMIC_TRACKING,
        FALSE
    };
    WSM_LPC_DATA        data;
    ULONG               dataLength;

    NTSTATUS            status = STATUS_SUCCESS;

    do 
    {
            
        TRACE0 (EAP, "NLAConnectLPC: Entered");

        // Create a shared section for passing the large-size LPC messages.
        RtlZeroMemory(&g_ClientView, sizeof(g_ClientView));
        g_ClientView.Length = sizeof(g_ClientView);
        g_ClientView.ViewSize = sizeof(LOCATION_802_1X);
        sectionSize.QuadPart = sizeof(LOCATION_802_1X);
    
        status = NtCreateSection (&g_ClientView.SectionHandle,
                                (SECTION_MAP_READ | SECTION_MAP_WRITE),
                                NULL,
                                &sectionSize,
                                PAGE_READWRITE,
                                SEC_COMMIT,
                                NULL
                                );
    
        if (!NT_SUCCESS(status))
        {
            h = NULL;
            TRACE1 (EAP, "NLAConnectLPC: NtCreateSection failed with error",
                    status);
            break;
        }
    
        // Connect via LPC to the Network Location Awareness (NLA) service.
        RtlInitUnicodeString (&portName, WSM_PRIVATE_PORT_NAME);
    
        RtlZeroMemory (&data, sizeof (data));
        data.signature = WSM_SIGNATURE;
        data.connect.version.major = WSM_VERSION_MAJOR;
        data.connect.version.minor = WSM_VERSION_MINOR;
    
        dataLength = sizeof (data);
    
        status = NtConnectPort (&h,
                            &portName,
                            &dynamicQoS,
                            &g_ClientView,
                            NULL,
                            NULL,
                            &data,
                            &dataLength
                            );
    
        // If NtConnectPort() succeeded, LPC will maintain a reference
        // to the section, otherwise we no longer need it.
    
        NtClose (g_ClientView.SectionHandle);
        g_ClientView.SectionHandle = NULL;
    
        if (!NT_SUCCESS(status)) {
            TRACE1 (EAP, "NLAConnectLPC: NtConnectPort failed with error %ld",
                    status);
            ASSERT (h == NULL);
        }

    } 
    while (FALSE);

    return (h);

} 


//
// ElNLACleanupLPC
//
// Description: 
//
// Function called to close the LPC port for NLA service
//
// Arguments:
//      None
//
// Return values:
//      None
//

VOID
ElNLACleanupLPC () 
{
    if (g_hNLA_LPC_Port != NULL) {
        NtClose (g_hNLA_LPC_Port);
        g_hNLA_LPC_Port = NULL;
    }
} 


//
// ElNLARegister_802_1X
//
// Description: 
//
// Function called to register 802.1X information with NLA
//
// Arguments:
//      plocation - Pointer to data needed to be registered with NLA
//
// Return values:
//      None
//

VOID
ElNLARegister_802_1X ( 
        IN  PLOCATION_802_1X    plocation 
        ) 
{

    WSM_LPC_MESSAGE     message;
    NTSTATUS            status;

    ACQUIRE_WRITE_LOCK (&g_NLALock); 

    do 
    {

        TRACE0 (EAP, "NLARegister_802_1X: Entered");

        // Connect to the Network Location Awareness (NLA) service if
        // necessary.

        if (g_hNLA_LPC_Port == NULL) {
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) {
                RELEASE_WRITE_LOCK (&g_NLALock);
                return;
            }
        }

        TRACE0 (EAP, "NLARegister_802_1X: g_hNLA_LPC_Port != NULL");

        // Send information to the NLA service.
        RtlZeroMemory (&message, sizeof (message));
        message.portMsg.u1.s1.TotalLength = sizeof (message);
        message.portMsg.u1.s1.DataLength = sizeof (message.data);
        message.data.signature = WSM_SIGNATURE;
        message.data.request.type = LOCATION_802_1X_REGISTER;
        __try {
            RtlCopyMemory (g_ClientView.ViewBase, 
                            plocation, sizeof(LOCATION_802_1X));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return;
        }

        status = NtRequestWaitReplyPort ( g_hNLA_LPC_Port, (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);

        if (status != STATUS_SUCCESS) {
        
            TRACE1 (EAP, "NLARegister_802_1X: NtWaitReplyPort failed with error",
                    status);

            // It's possible the service was stopped and restarted.
            // Ditch the old LPC connection.
            CloseHandle (g_hNLA_LPC_Port);
        
            // Create a new LPC connection.
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) {
                RELEASE_WRITE_LOCK (&g_NLALock);
                TRACE0 (EAP, "NLARegister_802_1X: NLAConnectLPC failed");
                return;
            }

            // Try the send one last time.
            status = NtRequestWaitReplyPort (g_hNLA_LPC_Port, 
                            (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);
            TRACE1 (EAP, "NLARegister_802_1X: NtWaitReplyPort, try 2, failed with error",
                    status);

        }

        TRACE1 (EAP, "NLARegister_802_1X: Completed with status = %ld",
                status);

    }
    while (FALSE);
        
    RELEASE_WRITE_LOCK (&g_NLALock);

} 


//
// ElNLADelete_802_1X
//
// Description: 
//
// Function called to de-register 802.1X information registered with NLA
//
// Arguments:
//      plocation - Pointer to data to be de-registered from NLA
//
// Return values:
//      None
//

VOID
ElNLADelete_802_1X (
        IN  PLOCATION_802_1X    plocation
        ) 
{

    WSM_LPC_MESSAGE     message;
    NTSTATUS            status;

    ACQUIRE_WRITE_LOCK (&g_NLALock); 

    do 
    {

        // Connect to the NLA service if necessary.
        if (g_hNLA_LPC_Port == NULL) 
        {
            if ((g_hNLA_LPC_Port = ElNLAConnectLPC ()) == NULL) 
            {
                RELEASE_WRITE_LOCK (&g_NLALock);
                return;
            }
        }

        // Send information to the NLA service.
        RtlZeroMemory (&message, sizeof(message));
        message.portMsg.u1.s1.TotalLength = sizeof (message);
        message.portMsg.u1.s1.DataLength = sizeof (message.data);
        message.data.signature = WSM_SIGNATURE;
        message.data.request.type = LOCATION_802_1X_DELETE;
        __try {
            RtlCopyMemory (g_ClientView.ViewBase, 
                    plocation, sizeof(plocation->adapterName));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return;
        }

        status = NtRequestWaitReplyPort (g_hNLA_LPC_Port, 
                        (PPORT_MESSAGE)&message, (PPORT_MESSAGE)&message);

        if (status != STATUS_SUCCESS) 
        {
            // If the service was stopped (and possibly restarted), we don't
            // care ... it won't have this information in its list for us
            // to bother deleting.
            CloseHandle (g_hNLA_LPC_Port);
            g_hNLA_LPC_Port = NULL;
        }

    }
    while (FALSE);

    RELEASE_WRITE_LOCK (&g_NLALock);

} 


//
// ElGetInterfaceNdisStatistics
//
// Function to query NDIS NIC_STATISTICS parameters for an interface
//
// Input arguments:
//  pszInterfaceName - Interface Name
//
// Return values:
//  pStats - NIC_STATISTICS structure 
//  
//

DWORD
ElGetInterfaceNdisStatistics (  
        IN      CHAR            *pszInterfaceName,
        IN OUT  NIC_STATISTICS  *pStats
        )
{
    WCHAR               *pwszInterfaceName = NULL;
    UNICODE_STRING      UInterfaceName;
    DWORD               dwRetCode = NO_ERROR;

    do
    {
        pwszInterfaceName = MALLOC ((strlen (pszInterfaceName)+12)*sizeof(WCHAR));
        if (pwszInterfaceName == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (ANY, "ElGetInterfaceNdisStatistics: MALLOC failed for pwszInterfaceName");
            break;
        }

        wcscpy (pwszInterfaceName, L"\\Device\\{");

        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pszInterfaceName,
                    -1,
                    &pwszInterfaceName[9],
                    (strlen(pszInterfaceName)+12)*sizeof(WCHAR)))
        {
            dwRetCode = GetLastError();
    
            TRACE2 (ANY, "ElGetInterfaceNdisStatistics: MultiByteToWideChar(%s) failed: %ld",
                    pszInterfaceName, dwRetCode);
            break;
        }

        pwszInterfaceName[strlen(pszInterfaceName) + 9] = L'\0';

        wcscat (pwszInterfaceName, L"}");


        TRACE1 (ANY, "ElGetInterfaceNdisStatistics: pwszInterfaceName = (%ws)",
                pwszInterfaceName);

        RtlInitUnicodeString (&UInterfaceName, pwszInterfaceName);
    
        pStats->Size = sizeof(NIC_STATISTICS);
        if (NdisQueryStatistics (&UInterfaceName, pStats))
        {
        }
        else
        {
            dwRetCode = GetLastError ();
            TRACE2 (ANY, "ElGetInterfaceNdisStatistics: NdisQueryStatistics failed with error (%ld), Interface=%ws",
                    dwRetCode, UInterfaceName.Buffer);
        }
    }
    while (FALSE);

    if (pwszInterfaceName != NULL)
    {
        FREE (pwszInterfaceName);
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eapolutil.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eapolutil.h

Abstract:

    Definitions for tools and ends


Revision History:

    sachins, May 04 2000, Created

--*/

#ifndef _EAPOLUTIL_H_
#define _EAPOLUTIL_H_

//
// FUNCTION DECLARATIONS
//

VOID
HostToWireFormat16(
    IN 	   WORD         wHostFormat,
    IN OUT PBYTE        pWireFormat
    );

WORD
WireToHostFormat16(
    IN PBYTE                pWireFormat
    );

VOID
HostToWireFormat32(
    IN 	   DWORD            dwHostFormat,
    IN OUT PBYTE            pWireFormat
    );

DWORD
WireToHostFormat32(
    IN PBYTE pWireFormat
    );

DWORD
ElSetCustomAuthData (
        IN  CHAR        *pszGuid,
        IN  DWORD       dwEapTypeId,
        IN  CHAR        *pszSSID,
        IN  BYTE        *pbConnInfo,
        IN  DWORD       dwInfoSize
        );

DWORD
ElGetCustomAuthData (
        IN  CHAR            *pszGuid,
        IN  DWORD           dwEapTypeId,
        IN  CHAR            *pszSSID,
        IN  OUT BYTE        *pbConnInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

DWORD
ElSetEapUserInfo (
        IN  HANDLE      hToken,
        IN  CHAR        *pszGuid,
        IN  DWORD       dwEapTypeId,
        IN  CHAR        *pszSSID,
        IN  BYTE        *pbUserInfo,
        IN  DWORD       dwInfoSize
        );

DWORD
ElGetEapUserInfo (
        IN  HANDLE          hToken,
        IN  CHAR            *pszGuid,
        IN  DWORD           dwEapTypeId,
        IN  CHAR            *pszSSID,
        IN  OUT BYTE        *pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

DWORD
ElSetInterfaceParams (
        IN  CHAR            *pszGUID,
        IN  DWORD           *pdwDefaultEAPType,
        IN  CHAR            *pszLastUsedSSID,
        IN  DWORD           *pdwEapolEnabled
        );

DWORD
ElGetInterfaceParams (
        IN  CHAR            *pszGUID,
        IN  OUT DWORD       *pdwDefaultEAPType,
        IN  OUT CHAR        *pszLastUsedSSID,
        IN  OUT DWORD       *pdwEapolEnabled
        );

DWORD
ElGetEapKeyFromToken (
        IN  HANDLE      hUserToken,
        OUT HKEY        *phkey
        );

DWORD
ElInitRegPortData (
        IN  CHAR        *pszDeviceGUID
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetVendorSpecific (
        IN  DWORD                       dwVendorId,
        IN  DWORD                       dwVendorType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetFirst (
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes,
        OUT HANDLE                      *phAttribute
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGetNext (
        IN  OUT HANDLE                  *phAttribute,
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType
        );

RAS_AUTH_ATTRIBUTE *
ElAuthAttributeGet (
        IN  RAS_AUTH_ATTRIBUTE_TYPE     raaType,
        IN  RAS_AUTH_ATTRIBUTE          *pAttributes
        );

VOID
ElReverseString (
        IN  CHAR        *psz 
    );

CHAR*
ElEncodePw (
        IN OUT CHAR     *pszPassword 
    );

CHAR*
ElDecodePw (
        IN OUT CHAR     *pszPassword 
    );

VOID
ElEncryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        );

VOID
ElDecryptBlockUsingMD5 (
        IN  BYTE        *pbSecret,
        IN  ULONG       ulSecretLen,
        IN  OUT BYTE    *pbBuf,
        IN  ULONG       ulBufLen
        );

VOID
ElGetHMACMD5Digest (
        IN      BYTE        *pbBuf,     
        IN      DWORD       dwBufLen,   
        IN      BYTE        *pbKey,
        IN      DWORD       dwKeyLen,
        IN OUT  VOID        *pvDigest
        );

DWORD
ElWmiGetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  OUT BYTE    *pbOutputBuffer,
        IN  OUT DWORD   *pdwOutputBufferSize
        );

DWORD
ElWmiSetValue (
        IN  GUID        *pGuid,
        IN  CHAR        *pszInstanceName,
        IN  BYTE        *pbInputBuffer,
        IN  DWORD       dwInputBufferSize
        );

DWORD
ElNdisuioSetOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       ulOidDataLength
        );

DWORD
ElNdisuioQueryOIDValue (
        IN  HANDLE      hInterface,
        IN  NDIS_OID    Oid,
        IN  BYTE        *pbOidData,
        IN  ULONG       *pulOidDataLength
        );

DWORD 
ElGuidFromString (
        IN  OUT GUID        *pGuid,
        IN      CHAR        *pszGuidString
        );

DWORD
ElGetLoggedOnUserName (
        IN      EAPOL_PCB       *pPCB
        );

DWORD
ElGetMachineName (
        IN      EAPOL_PCB       *pPCB
        );

DWORD
ElUpdateRegistryInterfaceList (
        IN      PNDIS_ENUM_INTF     Interfaces
        );

VOID 
ElWatchGlobalRegistryParams (
        IN      PVOID       pvContext
        );

DWORD
ElReadGlobalRegistryParams ();

VOID 
ElWatchEapConfigRegistryParams (
        IN      PVOID       pvContext
        );

DWORD
ElReadGlobalRegistryParams ();

DWORD
ElProcessEapConfigChange ();

VOID
ElStringToGuid (
        IN      CHAR        *psGuid,
        OUT     LPGUID      pGuid      
        );

DWORD
ElGetIdentity (
        IN      EAPOL_PCB   *pPCB
        );

HANDLE
ElNLAConnectLPC ();

VOID
ElNLACleanupLPC ();

VOID
ElNLARegister_802_1X ( 
        IN      PLOCATION_802_1X plocation 
        );

VOID
ElNLADelete_802_1X (
        IN      PLOCATION_802_1X plocation
        );

DWORD
ElGetInterfaceNdisStatistics (  
        IN      CHAR            *pszInterfaceName,
        IN OUT  NIC_STATISTICS  *pStats
        );

#endif // _EAPOLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eldeviceio.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    eldeviceio.c

Abstract:

    This module contains implementations for media-management and device I/O.
    The routines declared here operate asynchronously on the handles 
    associated with an I/O completion port opened on the ndis uio driver. 

Revision History:

    sachins, Apr 23 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

// NDISUIO constants

CHAR            NdisuioDevice[] = "\\\\.\\\\Ndisuio";
CHAR *          pNdisuioDevice = &NdisuioDevice[0];

// TEST globals
PVOID g_QueryBinding;
PVOID g_TempBuf;
PVOID g_ItfBuffer;
PVOID g_Buf;
DWORD g_ItfBufferSize;
DWORD g_BreakAt;


extern 
VOID 
ElUserLogonDetection (
        PVOID   pvContext
        );


//
// ElMediaInit
// 
// Description:
//
// Called on EAPOL service startup to initialize all the media related events 
// and callback functions
// 
//
// Arguments:
//
// Return Values:
//

DWORD
ElMediaInit (
        )
{
    DWORD       dwIndex = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (INIT, "ElMediaInit: Entered");

    do 
    {
        // --ft:12/04/00: Initialize locks as the first thing to do. Otherwise, EAPOL registers
        // with WMI and if a notification comes in before getting to initialize the lock this can
        // result in an AV. 
        // Stress failure reported an AV on the following stack:
        // ntdll!RtlpWaitForCriticalSection+0xb1 [z:\nt\base\ntdll\resource.c @ 1631]
        // ntdll!RtlEnterCriticalSection+0x46 [Z:\nt\base\ntdll\i386\critsect.asm @ 157]
        // netman!AcquireWriteLock+0xf [z:\nt\net\config\netman\eapol\service\elsync.c @ 137]
        // netman!ElMediaSenseCallbackWorker+0x15c [z:\nt\net\config\netman\eapol\service\eldeviceio.c @ 937]
        //
        // The CRITICAL_SECTION looked like below:
        //     75e226c4  00000000 00000001 00000000 00000000
        //     75e226d4  00001990 
        // 
        // The (null) DebugInfo shows the object not being initialized successfully.
        //
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_ITFLock), "ITF") != NO_ERROR)
        {
            TRACE1(EAPOL, "ElMediaInit: Error (%ld) in creating g_ITFLock read-write-lock", dwRetCode);
            break;
        }
        // Initialize NLA locks
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_NLALock), "NLA") != NO_ERROR)
        {
            TRACE1(EAPOL, "ElMediaInit: Error (%ld) in creating g_NLALock read-write-lock", dwRetCode);
            break;
        }

        // Register for Media Sense detection of MEDIA_CONNECT and 
        // MEDIA_DISCONNECT of interfaces
        // This is done before anything else, so that no MEDIA events are lost
    
        if ((dwRetCode = ElMediaSenseRegister (TRUE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElMediaSenseRegister failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            g_dwModulesStarted |= WMI_MODULE_STARTED;
            TRACE0(INIT, "ElMediaInit: ElMediaSenseRegister successful");
        }

        // Register for device notifications. We are interested in LAN 
        // interfaces coming and going. 

        if ((dwRetCode = ElDeviceNotificationRegister (TRUE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElDeviceNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            g_dwModulesStarted |= DEVICE_NOTIF_STARTED;
            TRACE0(INIT, "ElMediaInit: ElDeviceNotificationRegister successful");
        }

        // Initialize EAPOL structures

        if ((dwRetCode = ElInitializeEAPOL()) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElInitializeEAPOL failed with dwRetCode = %d", 
                    dwRetCode );
            break;
        }
        else
        {
            TRACE0(INIT, "ElMediaInit: ElInitializeEAPOL successful");
            g_dwModulesStarted |= EAPOL_MODULE_STARTED;
        }
    
        // Watch and update change in global registry parameters

        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)ElWatchGlobalRegistryParams,
                    NULL,
                    WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElMediaInit: Critical error: QueueUserWorkItem failed for ElWatchGlobalRegistryParams with error %ld",
                    dwRetCode);
            break;
        }
    
        // Watch changes in EAP config params by checking on
        // ..\EAPOL\Interfaces key

        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)ElWatchEapConfigRegistryParams,
                    NULL,
                    WT_EXECUTELONGFUNCTION 
                    ))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElMediaInit: Critical error: QueueUserWorkItem failed for ElWatchEapConfigRegistryParams with error %ld",
                    dwRetCode);
            break;
        }

        // Use task bar window for getting login notifications

        if (!QueueUserWorkItem (
            (LPTHREAD_START_ROUTINE)ElUserLogonDetection,
            NULL,
            WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "Critical error: QueueUserWorkItem failed for ElUserLogonDetection with error %ld",
                    dwRetCode);
            break;
        }
    
        // Initialize interface hash bucket table
    
        g_ITFTable.pITFBuckets = (ITF_BUCKET *) MALLOC (INTF_TABLE_BUCKETS * sizeof (ITF_BUCKET));
    
        if (g_ITFTable.pITFBuckets == NULL)
        {
            TRACE0 (DEVICE, "Error in allocation memory for ITF buckets");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    
        for (dwIndex=0; dwIndex < INTF_TABLE_BUCKETS; dwIndex++)
        {
            g_ITFTable.pITFBuckets[dwIndex].pItf=NULL;
        }
    
        ACQUIRE_WRITE_LOCK (&g_ITFLock)

        // Enumerate all the interfaces and start EAPOL state machine
        // on interfaces which are of LAN type

        if ((dwRetCode = ElEnumAndOpenInterfaces (NULL, NULL)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaInit: ElEnumAndOpenInterfaces failed with dwRetCode = %d", 
                    dwRetCode );
                    
            RELEASE_WRITE_LOCK (&g_ITFLock);
            break;
        }
        else
        {
            RELEASE_WRITE_LOCK (&g_ITFLock);
            TRACE0(INIT, "ElMediaInit: ElEnumAndOpenInterfaces successful");
        }
        
    } while (FALSE);
        
    if (dwRetCode == NO_ERROR)
    {
        TRACE0(INIT, "ElMediaInit successful");
    }
    else
    {
    }

    return dwRetCode;
}

    
//
// ElMediaDeInit
// 
// Description:
//
// Called on EAPOL service shutdown to de-initialize all the media 
// related events and callback functions
// 
//
// Arguments:
//
// Return Values:
//

DWORD
ElMediaDeInit (
        )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (INIT, "ElMediaDeInit: Entered");

    // DeRegister Media Sense detection of MEDIA_CONNECT and MEDIA_DISCONNECT
    // of interfaces

    if (g_dwModulesStarted & WMI_MODULE_STARTED)
    {
        if ((dwRetCode = ElMediaSenseRegister (FALSE)) != NO_ERROR )
        {
            TRACE1(INIT, "ElMediaDeInit: ElMediaSenseRegister failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            TRACE0(INIT, "ElMediaDeInit: ElMediaSenseRegister successful");
        }
            
        g_dwModulesStarted &= ~WMI_MODULE_STARTED;
    }

    // Deregister device notifications that may have been posted

    if (g_dwModulesStarted & DEVICE_NOTIF_STARTED)
    {
        if ((dwRetCode = ElDeviceNotificationRegister (FALSE)) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaDeInit: ElDeviceNotificationRegister failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            TRACE0(INIT, "ElMediaDeInit: ElDeviceNotificationRegister successful");
        }

        g_dwModulesStarted &= ~DEVICE_NOTIF_STARTED;
    }

    // Shutdown EAPOL state machine
            
    if (g_dwModulesStarted & EAPOL_MODULE_STARTED)
    {
        if ((dwRetCode = ElEAPOLDeInit()) != NO_ERROR)
        {
            TRACE1(INIT, "ElMediaDeInit: ElEAPOLDeInit failed with dwRetCode = %d", 
                    dwRetCode );
            // log
        }
        else
        {
            TRACE0(INIT, "ElMediaDeInit: ElEAPOLDeInit successful");
        }

        g_dwModulesStarted &= ~EAPOL_MODULE_STARTED;
    }

    // Free the interface table

    if (READ_WRITE_LOCK_CREATED(&(g_ITFLock)))
    {
        ACQUIRE_WRITE_LOCK (&(g_ITFLock));
#if 0
    if (!FREE(g_ITFTable.pITFBuckets))
    {
        TRACE0 (EAPOL, "ElMediaDeInit: Error in freeing ITF table memory");
        dwRetCode = GetLastError();
    }
#endif
        FREE(g_ITFTable.pITFBuckets);
        ZeroMemory (&g_ITFTable, sizeof (g_ITFTable));
        RELEASE_WRITE_LOCK (&(g_ITFLock));
    
        // Delete ITF table lock

        DELETE_READ_WRITE_LOCK(&(g_ITFLock));

        // Delete NLA lock

        DELETE_READ_WRITE_LOCK(&(g_NLALock));
    }
    
    TRACE0(INIT, "ElMediaDeInit completed");

    return dwRetCode;
}


//
// Description:
//
// Function called to register CallBack function with WMI
// for MEDIA_CONNECT/MEDIA_DISCONNECT events
//
// Arguments: 
//      fRegister - True = Register for Media Sense
//                  False = Deregister Media Sense requests
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElMediaSenseRegister (
        IN  BOOL        fRegister
        )
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = ElMediaSenseCallback;

    dwRetCode = WmiNotificationRegistrationA(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_CONNECT),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR) 
    {
		TRACE1(INIT, "ElMediaSenseRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_STATUS_MEDIA_CONNECT", dwRetCode);
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistrationA(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_DISCONNECT),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if (dwRetCode != NO_ERROR)
    {
		TRACE1(INIT, "ElMediaSenseRegister: Error %d in WmiNotificationRegistration:GUID_NDIS_STATUS_MEDIA_DISCONNECT", dwRetCode);
        return( dwRetCode );
    }

    TRACE1 (INIT, "ElMediaSenseRegister - completed with RetCode %d", dwRetCode);

    return( dwRetCode );
}


//
// ElDeviceNotificationRegister
// 
// Description:
//
// Function called to register for device addition/removal notifications
//
// Arguments: 
//      fRegister - True = Register for Device Notifications
//                  False = Deregister Device Notifications
//
// Return values:
//      NO_ERROR  - Successful
//      non-zero  - Error
//

DWORD
ElDeviceNotificationRegister (
        IN  BOOL        fRegister
        )
{
    HANDLE      hDeviceNotification = NULL;
    DWORD       dwRetCode = NO_ERROR;

#ifdef EAPOL_SERVICE

    DEV_BROADCAST_DEVICEINTERFACE   PnPFilter;

    ZeroMemory (&PnPFilter, sizeof(PnPFilter));

    PnPFilter.dbcc_size = sizeof(PnPFilter);
    PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    PnPFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

    // NOTE:
    // EAPOL service is only working with ANSI strings, hence the ANSI calls

    hDeviceNotification = RegisterDeviceNotificationA(
                                (HANDLE)g_hServiceStatus,
                                &PnPFilter,
                                DEVICE_NOTIFY_SERVICE_HANDLE );

    if (hDeviceNotification == NULL)
    {
        dwRetCode = GetLastError();

        TRACE1 (DEVICE, "ElDeviceNotificationRegister failed with error %ld",
                dwRetCode);
    }

#endif

    return dwRetCode;
}


//
// ElDeviceNotificationHandler
// 
// Description:
//
// Function called to handle device notifications for interface addition/
// removal
//
// Arguments:
//      lpEventData - interface information
//      dwEventType - notification type 
//

DWORD
ElDeviceNotificationHandler (
        IN  VOID        *lpEventData,
        IN  DWORD       dwEventType
        )
{
    DWORD                           dwEventStatus = 0;
    DEV_BROADCAST_DEVICEINTERFACE   *pInfo = 
        (DEV_BROADCAST_DEVICEINTERFACE *) lpEventData;
    PVOID                           pvBuffer = NULL;
    DWORD                           dwRetCode = NO_ERROR;

    TRACE0 (DEVICE, "ElDeviceNotificationHandler entered");

    do
    {

        if (g_hEventTerminateEAPOL == NULL)
        {
            break;
        }

        // Check if have already gone through EAPOLCleanUp before

        if ((dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1(INIT, "ElDeviceNotificationHandler: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            // log
    
            break;
        }

        if (dwEventStatus == WAIT_OBJECT_0)
        {
            TRACE0(INIT, "ElDeviceNotificationHandler: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }
    
        if (lpEventData == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: lpEventData == NULL");
            break;
        }
    
        if (pInfo->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: Event for Interface type");
    
            if ((pvBuffer = MALLOC (pInfo->dbcc_size + 8)) == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (DEVICE, "ElDeviceNotificationHandler: MALLOC failed for pvBuffer");
                break;
            }
    
            *((DWORD *)pvBuffer) = dwEventType;
            memcpy ((PBYTE)pvBuffer + 8, (PBYTE)pInfo, pInfo->dbcc_size);
    
            if (!QueueUserWorkItem (
                (LPTHREAD_START_ROUTINE)ElDeviceNotificationHandlerWorker,
                pvBuffer,
                WT_EXECUTELONGFUNCTION))
            {
                dwRetCode = GetLastError();
                TRACE1 (DEVICE, "ElDeviceNotificationHandler: QueueUserWorkItem failed with error %ld",
                        dwRetCode);
	            break;
            }

        }
        else
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandler: Event NOT for Interface type");
        }

    }
        
    while (FALSE);
    
    TRACE1 (DEVICE, "ElDeviceNotificationHandler completed with error %ld",
            dwRetCode);

    if (dwRetCode != NO_ERROR)
    {
        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

    return dwRetCode;
}


//
// ElDeviceNotificationHandlerWorker
// 
// Description:
//
// Worker function for ElDeviceNotificationHandlerWorker
//
// Arguments:
//      pvContext - interface information
//

VOID
ElDeviceNotificationHandlerWorker (
        IN  PVOID       pvContext
        )
{
    EAPOL_PCB                       *pPCB = NULL;
    EAPOL_ITF                       *pITF = NULL;
    HANDLE                          hDevice = NULL;
    DEV_BROADCAST_DEVICEINTERFACE   *pInfo = NULL;
    DWORD                           dwEventType = 0;
    DWORD                           dwRetCode = NO_ERROR;

    TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Entered");

    do
    {
        if (pvContext == NULL)
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: pvContext == NULL");
            break;
        }

        dwEventType = *((DWORD *) pvContext);
        pInfo = (DEV_BROADCAST_DEVICEINTERFACE*)((PBYTE)pvContext + 8);

        if ((dwEventType == DBT_DEVICEARRIVAL) ||
                (dwEventType == DBT_DEVICEREMOVECOMPLETE))
        {
            // Extract GUID from the \Device\GUID string

            WCHAR   *pwszGUIDStart = NULL;
            WCHAR   *pwszGUIDEnd = NULL;
            CHAR    *pszGUIDStart = NULL;
            WCHAR   chGUIDSaveLast;
            WCHAR   Buffer1[256];
            CHAR    Buffer2[256];
            UNICODE_STRING      UnicodeGUID;
            ANSI_STRING         AnsiGUID;
        
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Interface arr/rem");

            pwszGUIDStart  = wcsrchr( pInfo->dbcc_name, L'{' );
            pwszGUIDEnd    = wcsrchr( pInfo->dbcc_name, L'}' );

            if ((pwszGUIDStart != NULL) && (pwszGUIDEnd != NULL))
            {
                chGUIDSaveLast = *(pwszGUIDEnd+1);
                            
                // Ignore the leading '{' and the trailing '}'
                // in the GUID

                *(pwszGUIDEnd) = L'\0';
                pwszGUIDStart ++;

                UnicodeGUID.Buffer = Buffer1;
                UnicodeGUID.MaximumLength = 256*sizeof(WCHAR);
                RtlInitUnicodeString (&UnicodeGUID, pwszGUIDStart);

                // Will not fail since memory is already allocated for the 
                // conversion

                AnsiGUID.Buffer = Buffer2;
                AnsiGUID.MaximumLength = 256;
                RtlUnicodeStringToAnsiString (&AnsiGUID, 
                        &UnicodeGUID, FALSE);

                AnsiGUID.Buffer[AnsiGUID.Length] = '\0';
                pszGUIDStart = AnsiGUID.Buffer;

                TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: For interface %s",
                        pszGUIDStart);

                // Interface was added

                if (dwEventType == DBT_DEVICEARRIVAL)
                {
                    ACQUIRE_WRITE_LOCK (&g_ITFLock);

                    TRACE0(DEVICE, "ElDeviceNotificationHandlerWorker: Callback for device addition");
        
                    if ((dwRetCode = ElEnumAndOpenInterfaces (NULL, 
                                        pszGUIDStart))
                                        != NO_ERROR)
                    {
                        TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: ElEnumAndOpenInterfaces returned error %ld", 
                            dwRetCode);
                    }
        
                    RELEASE_WRITE_LOCK (&g_ITFLock);
                }
                else
                {
        
                    TRACE0(DEVICE, "ElDeviceNotificationHandlerWorker: Callback for device removal");

                    ACQUIRE_WRITE_LOCK (&(g_ITFLock));

                    // Check if EAPOL was actually started on this interface
                    // Verify by checking existence of corresponding 
                    // entry in hash table
        
                    ACQUIRE_WRITE_LOCK (&(g_PCBLock));
                    if ((pPCB = ElGetPCBPointerFromPortGUID(pszGUIDStart))
                            != NULL)
                    {
                        RELEASE_WRITE_LOCK (&(g_PCBLock));
                        TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Found PCB entry for interface");
        
                        if ((pITF = ElGetITFPointerFromInterfaceDesc(
                                        pPCB->pszFriendlyName))
                                        == NULL)
                        {
                            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Did not find ITF entry when PCB exits, HOW BIZARRE !!!");

                        }

                        if ((dwRetCode = ElDeletePort (
                                        pszGUIDStart, 
                                        &hDevice)) != NO_ERROR)
                        {
                            TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: Error in deleting port for %s", 
                                pPCB->pszDeviceGUID);
                        }
        
                        //
                        // Remove interface entry from interface table
                        //
                        
                        if (pITF != NULL)
                        {
                            ElRemoveITFFromTable(pITF);
                                    
                            if (pITF->pszInterfaceDesc)
                            {
                                FREE (pITF->pszInterfaceDesc);
                            }
                            if (pITF->pszInterfaceGUID)
                            {
                                FREE (pITF->pszInterfaceGUID);
                            }
                            if (pITF)
                            {
                                FREE (pITF);
                            }
                        }

                        // Close the handle to the NDISUIO driver

                        if (hDevice != NULL)
                        {
                            if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) 
                                    != NO_ERROR)
                            {
                                TRACE1 (DEVICE, 
                                    "ElDeviceNotificationHandlerWorker: Error in ElCloseInterfaceHandle %d", 
                                    dwRetCode);
                            }
                        }
            
                        TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker: Port deleted %s", 
                                pszGUIDStart);

                    }
                    else
                    {
                        RELEASE_WRITE_LOCK (&(g_PCBLock));

                        // Ignore device removal 
                        //
                        TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: ElGetPCBPointerFromPortGUID did not find any matching entry, ignoring DEVICE REMOVAL");
        
                    }

                    RELEASE_WRITE_LOCK (&g_ITFLock);
                }
            }
        }
        else
        {
            TRACE0 (DEVICE, "ElDeviceNotificationHandlerWorker: Event type is is NOT device arr/rem");
        }

    }
    while (FALSE);

    if (pvContext != NULL)
    {
        FREE (pvContext);
    }

    TRACE1 (DEVICE, "ElDeviceNotificationHandlerWorker completed with error %ld",
            dwRetCode);

    return;
}


//
// ElMediaSenseCallback
// 
// Description:
//
// Callback function called by WMI on MEDIA_CONNECT/MEDIA_DISCONNECT 
// events
//
// Arguments:
//      pWnodeHeader - Pointer to information returned by the event
//      uiNotificationContext - unused
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

VOID
CALLBACK
ElMediaSenseCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        )
{
    DWORD       dwEventStatus = 0;
    PVOID       pvBuffer = NULL;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (DEVICE, "ElMediaSenseCallback: Entered");

    do
    {
        if (g_hEventTerminateEAPOL == NULL)
        {
            dwRetCode = NO_ERROR;
            break;
        }

        // Check if have already gone through EAPOLCleanUp before

        if (( dwEventStatus = WaitForSingleObject (
                    g_hEventTerminateEAPOL,
                    0)) == WAIT_FAILED)
        {
            dwRetCode = GetLastError ();
            TRACE1 (INIT, "ElMediaSenseCallback: WaitForSingleObject failed with error %ld, Terminating !!!",
                    dwRetCode);
            // log
    
            break;
        }

        if (dwEventStatus == WAIT_OBJECT_0)
        {
            dwRetCode = NO_ERROR;
            TRACE0 (INIT, "ElMediaSenseCallback: g_hEventTerminateEAPOL already signaled, returning");
            break;
        }

        if (pWnodeHeader == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (DEVICE, "ElMediaSenseCallback: pWnodeHeader == NULL");
            break;
        }

        if ((pvBuffer = MALLOC (pWnodeHeader->BufferSize)) == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (DEVICE, "ElMediaSenseCallback: MALLOC failed for pvBuffer");
            break;
        }

        memcpy ((PVOID)pvBuffer, (PVOID)pWnodeHeader, pWnodeHeader->BufferSize);

        if (!QueueUserWorkItem (
            (LPTHREAD_START_ROUTINE)ElMediaSenseCallbackWorker,
            pvBuffer,
            WT_EXECUTELONGFUNCTION))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElMediaSenseCallback: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
	        ASSERT (0);
        }
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (DEVICE, "ElMediaSenseCallback: Failed with error %ld",
                dwRetCode);

        if (pvBuffer != NULL)
        {
            FREE (pvBuffer);
        }
    }

}


//
// ElMediaSenseCallbackWorker
// 
// Description:
//
// Worker function for ElMediaSenseCallback and executes in a separate
// thread
//
// Arguments:
//      pvContext - Pointer to information returned by the media-sense event
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

VOID
ElMediaSenseCallbackWorker (
        IN  PVOID       pvContext
        )
{
    PWNODE_HEADER           pWnodeHeader = (PWNODE_HEADER)pvContext;
    PWNODE_SINGLE_INSTANCE  pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                  lpwsName;
    CHAR                    *psName;
    CHAR                    *psDeviceName = NULL;
    CHAR                    psLength;
    USHORT                  cpsLength;
    CHAR                    *psNameEnd;
    LPWSTR                  lpwsDeviceName = NULL;
    HANDLE                  hDevice = NULL;
    UNICODE_STRING          uInterfaceDescription;
    ANSI_STRING             InterfaceDescription;
    PCHAR                   pszInterfaceDescription;
    UCHAR			        Buffer[256];
    CHAR                    *pszInterfaceDesc = NULL;
    DWORD                   dwIndex;
    EAPOL_ITF               *pITF;
    ULONG                   i = 0;
    EAPOL_PCB               *pPCB = NULL;
    DWORD                   dwRetCode = NO_ERROR;

    do
    {

#ifdef EAPOL_SERVICE

    if ((g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
         ||
         (g_ServiceStatus.dwCurrentState == SERVICE_STOPPED))
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Callback received while service was stopping");
        break;
    }

#endif // EAPOL_SERVICE

    if (pWnodeHeader == NULL)
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Callback received with NULL NDIS interface details");

        break;
    }

    psName = (PCHAR)RtlOffsetToPointer(
                                    pWnode,
                                    pWnode->OffsetInstanceName );

    // Get the length of the string
    // Null terminate it 

    cpsLength = (SHORT)( *((SHORT *)psName) );

    if (!(psDeviceName = (CHAR *) MALLOC ((cpsLength+1)*sizeof(CHAR))))
    {
        TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Error in Memory allocation for psDeviceName");
        break;
    }

    memcpy ((CHAR *)psDeviceName, (CHAR *)psName+sizeof(SHORT), cpsLength);
    psDeviceName[cpsLength] = '\0';
    RtlInitAnsiString (&InterfaceDescription, psDeviceName);
    InterfaceDescription.Buffer[cpsLength] = '\0';

    TRACE3(DEVICE, "ElMediaSenseCallbackWorker: For interface ANSI %s, true= %s, lengt of block = %d", 
            InterfaceDescription.Buffer, psDeviceName, cpsLength);

    
    pszInterfaceDescription = InterfaceDescription.Buffer;
                                
    TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: Interface desc = %s", 
            pszInterfaceDescription);

    //
    // Get the information for the media disconnect.
    //

    if (memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_STATUS_MEDIA_DISCONNECT, 
                 sizeof(GUID)) == 0)
    {
        // MEDIA DISCONNECT callback 

        TRACE0(DEVICE, "ElMediaSenseCallbackWorker: Callback for sense disconnect");

        ACQUIRE_WRITE_LOCK (&(g_ITFLock))

        // Check if EAPOL was actually started on this interface
        // Verify by checking existence of corresponding entry in hash table

        if ((pITF = ElGetITFPointerFromInterfaceDesc(pszInterfaceDescription))
                != NULL)
        {
            TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: Found ITF entry for interface");

#if 0
            if ((dwRetCode = ElDeletePort (pITF->pszInterfaceGUID, &hDevice)) != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: Error in deleting port for %s", 
                        pITF->pszInterfaceGUID);
            }

            // Remove interface entry from interface table

            ElRemoveITFFromTable(pITF);

            if (pITF->pszInterfaceDesc)
            {
                FREE (pITF->pszInterfaceDesc);
                pITF->pszInterfaceDesc = NULL;
            }
            if (pITF->pszInterfaceGUID)
            {
                FREE (pITF->pszInterfaceGUID);
                pITF->pszInterfaceGUID = NULL;
            }
            if (pITF)
            {
                FREE (pITF);
                pITF = NULL;
            }

            // Close the handle to the NDISUIO driver

            if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) != NO_ERROR)
            {
                TRACE1 (DEVICE, 
                        "ElMediaSenseCallbackWorker: Error in ElCloseInterfaceHandle %d", 
                        dwRetCode);
            }
            
            TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: Port deleted %s", 
                    pszInterfaceDescription);
#endif

            ACQUIRE_WRITE_LOCK (&(g_PCBLock));
            pPCB = ElGetPCBPointerFromPortGUID (pITF->pszInterfaceGUID);
            if (pPCB != NULL)
            {
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
                if ((dwRetCode = FSMDisconnected (pPCB)) != NO_ERROR)
                {
                    TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: FSMDisconnected failed with error %ld", 
                        dwRetCode);
                }
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            }
            RELEASE_WRITE_LOCK (&(g_PCBLock));

            TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: Port marked disconnected %s", 
                    pszInterfaceDescription);

        }
        else
        {
            // Ignore MEDIA DISCONNECT

            TRACE0 (DEVICE, "ElMediaSenseCallbackWorker: ElHashInterfaceDescToBucket did not find any matching entry, ignoring MEDIA_DISCONNECT");
        }

        RELEASE_WRITE_LOCK (&g_ITFLock);

    }
    else
    {

        if (memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_STATUS_MEDIA_CONNECT, 
                     sizeof(GUID)) == 0)
        {
            // MEDIA CONNECT callback

            ACQUIRE_WRITE_LOCK (&g_ITFLock)

            TRACE0(DEVICE, "ElMediaSenseCallbackWorker: Callback for sense connect");

            if ((dwRetCode = ElEnumAndOpenInterfaces (
                            pszInterfaceDescription, NULL))
                != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: ElEnumAndOpenInterfaces returned error %ld", 
                        dwRetCode);
            }
        
            RELEASE_WRITE_LOCK (&g_ITFLock);

        }
    }

    }
    while (FALSE);

    TRACE1 (DEVICE, "ElMediaSenseCallbackWorker: processed, RetCode = %ld", dwRetCode);


    if (pWnodeHeader != NULL)
    {
        FREE (pWnodeHeader);
    }

    if (psDeviceName != NULL)
    {
        FREE (psDeviceName);
    }

    return;
}


// 
// ElEnumAndOpenInterfaces
// 
// Description:
//
// Enumerates interfaces and intializes EAPOL on desired ones.
//
// If EAPOL is to be started on an interface, it opens a handle to 
// the NDISUIO driver, calls EAPOL to create and initialize PCB for the 
// interface, and finally adds an entry to the interface hashtable.
//
// If pszDesiredGUID is not NULL, all interfaces are enumerated, but 
// EAPOL will be initialized only on the interface whose GUID matches.
//
// If pszDescription is not NULL, all interfaces are enumerated, but 
// EAPOL will be initialized only on the interface whose description matches.
//
// If pszDesiredGUID and pszDescription are both NULL, all interfaces are 
// enumerated. EAPOL will be initialized only on all interfaces that 
// does have an entry in the interface hashtable.
//
//
// Arguments:
//      pszDesiredDescription - Interface Description on which EAPOL is to 
//                  be started
//      pszDesiredGUID - Interface GUID on which EAPOL is to be started
//
// Return values:
//      NO_ERROR - Success
//      non-zero - Error
//

DWORD
ElEnumAndOpenInterfaces (
        CHAR    *pszDesiredDescription,
        CHAR    *pszDesiredGUID
        )
{
    CHAR				EnumerateBuffer[256];
    PNDIS_ENUM_INTF		Interfaces = NULL;
    BYTE                *pbNdisuioEnumBuffer = NULL;
    DWORD               dwNdisuioEnumBufferSize = 0;
    DWORD				dwNicCardStatus = 0;
    DWORD				dwMediaType = 0;
    HANDLE              hDevice = NULL;
    EAPOL_ITF           *pNewITF = NULL;
    DWORD               dwIndex = 0;
    UCHAR               csCurrMacAddress[6];
    UCHAR               csPermMacAddress[6];
    UCHAR               csOidVendData[16];
    BOOL                fSearchByDescription = FALSE;
    BOOL                fSearchByGUID = FALSE;
    DWORD               dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
    DWORD               dwEapolEnabled = DEFAULT_EAPOL_STATE;
    CHAR                csDummyBuffer[256];
    UNICODE_STRING      TempUString;
    CHAR                *pszGUIDStart = NULL;
    EAPOL_PCB           *pPCB = NULL;
    BOOL                fPCBExists = FALSE;
    DWORD               dwAvailableInterfaces = 0;
    DWORD				dwRetCode = NO_ERROR;


    TRACE2 (DEVICE, "ElEnumAndOpenInterfaces: DeviceDesc = %s, GUID = %s",
            pszDesiredDescription, pszDesiredGUID);

    if (pszDesiredGUID == NULL)
    {
        if (pszDesiredDescription != NULL)
        {
            fSearchByDescription = TRUE;
        }
    }
    else
    {
        if (pszDesiredDescription != NULL)
        {
            return ERROR;
        }
        fSearchByGUID = TRUE;
    }

    ZeroMemory (EnumerateBuffer, 256);
    Interfaces = (PNDIS_ENUM_INTF)EnumerateBuffer;

    //
    // Allocate amount of memory as instructed by NdisEnumerateInterfaces
    // once the API allows querying of bytes required
    //

    Interfaces->TotalInterfaces = 0;
    Interfaces->AvailableInterfaces = 0;
    Interfaces->BytesNeeded = 0;
    if (!NdisEnumerateInterfaces(Interfaces, 256)) 
    {
        dwRetCode = GetLastError ();
        TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: NdisEnumerateInterfaces failed with error %ld",
                dwRetCode);
        return dwRetCode;
    }

    TRACE3 (DEVICE, "ElEnumAndOpenInterfaces: TotalInterfaces = %ld, AvailInt = %ld, Bytes needed = %ld",
            Interfaces->TotalInterfaces, 
            Interfaces->AvailableInterfaces, 
            Interfaces->BytesNeeded);

    dwAvailableInterfaces = Interfaces->AvailableInterfaces;

    dwNdisuioEnumBufferSize = (Interfaces->BytesNeeded + 7) & ~7;

    if (dwNdisuioEnumBufferSize == 0) {
        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: MALLOC skipped for zero length pbNdisuioEnumBuffer");
        dwRetCode = NO_ERROR;
        return dwRetCode;
    }

    pbNdisuioEnumBuffer = (BYTE *) MALLOC (4*dwNdisuioEnumBufferSize);

    if (pbNdisuioEnumBuffer == NULL)
    {
        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: MALLOC failed for pbNdisuioEnumBuffer");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        return dwRetCode;
    }

    Interfaces = (PNDIS_ENUM_INTF)pbNdisuioEnumBuffer;


    // Enumerate all the interfaces present on the machine

    if ((dwRetCode = ElNdisuioEnumerateInterfaces (
                            Interfaces, 
                            dwAvailableInterfaces,
                            4*dwNdisuioEnumBufferSize)) == NO_ERROR)
    {
        ANSI_STRING		InterfaceName;
        ANSI_STRING		InterfaceDescription;
        UNICODE_STRING	UInterfaceName;
        UCHAR			Buffer1[256];
        UCHAR			Buffer2[256];
        WCHAR			Buffer3[256];
        DWORD			i;

        InterfaceName.MaximumLength = 256;
        InterfaceName.Buffer = Buffer1;
        InterfaceDescription.MaximumLength = 256;
        InterfaceDescription.Buffer = Buffer2;

        TRACE1 (DEVICE, "TotalInterfaces=%ld", Interfaces->TotalInterfaces);

        // Update the interface list in the registry that NDISUIO has bound to.
        // The current interface list is just overwritten into the registry.


        if ((dwRetCode = ElUpdateRegistryInterfaceList (Interfaces)) 
                != NO_ERROR)
        {
            TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: ElUpdateInterfaceList failed with error =%ld", 
                    dwRetCode);

            // log
        }

        for (i=0; i < Interfaces->TotalInterfaces; i++)
        {
            if (Interfaces->Interface[i].DeviceName.Buffer != NULL)
            {
                InterfaceName.Length = 0;
                InterfaceName.MaximumLength = 256;
                if (RtlUnicodeStringToAnsiString(&InterfaceName, 
                        &Interfaces->Interface[i].DeviceName, FALSE) != STATUS_SUCCESS)
                {
                    TRACE0 (INIT, "Error in RtlUnicodeStringToAnsiString for DeviceName");
                }

                InterfaceName.Buffer[InterfaceName.Length] = '\0';
            }
            else
            {
                TRACE0(INIT, "NdisEnumerateInterfaces: Device Name was NULL");
                continue;
            }

            TRACE1(INIT, "Device: %s", InterfaceName.Buffer);

            // BUBUG:
            // Should Device Name be retained in Unicode or converted to ANSI

            InterfaceDescription.Length = 0;
            InterfaceDescription.MaximumLength = 256;
            if (RtlUnicodeStringToAnsiString(&InterfaceDescription, 
                    &Interfaces->Interface[i].DeviceDescription, FALSE) != STATUS_SUCCESS)
            {
                    TRACE0 (INIT, "Error in RtlUnicodeStringToAnsiString for DeviceDescription");
            }

            InterfaceDescription.Buffer[InterfaceDescription.Length] = '\0';

            TRACE1(INIT, "Description: %s", InterfaceDescription.Buffer);


            // Create PCB for interface and start EAPOL state machine

            // EAPOL requested be started only a particular
            // interface

            if (fSearchByDescription)
            {
                if (strcmp (InterfaceDescription.Buffer,
                            pszDesiredDescription)
                        != 0)
                {
                    // No match, continue with next interface
                    continue;
                }

                TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Found interface after enumeration %s", InterfaceDescription.Buffer);
            }

            if (fSearchByGUID)
            {
                if (strstr (InterfaceName.Buffer,
                            pszDesiredGUID)
                        == NULL)
                {
                    // No match, continue with next interface
                    continue;
                }

                TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Found interface after enumeration %s", InterfaceName.Buffer);
            }

            {
                // Extract GUID-string out of device name

                CHAR    *pszGUIDEnd;
                CHAR    *pszGUID;
                CHAR    chGUIDSaveLast;

                pszGUID = InterfaceName.Buffer;
                pszGUIDStart  = strchr( pszGUID, '{' );
                pszGUIDEnd    = strchr( pszGUID, '}' );

                if (RtlAnsiStringToUnicodeString (
                                                &TempUString,
                                                &InterfaceName,
                                                TRUE))
                {
                    TRACE0 (DEVICE, "Error in RtlAnsiStringToUnicodeString for TempUString");
                }
                    
                // Query MAC address for the interface

                if (!NdisQueryHwAddress (
                                &TempUString,
                                csCurrMacAddress,
                                csPermMacAddress,
                                csOidVendData))
                {
                    RtlFreeUnicodeString (&TempUString);
                    dwRetCode = GetLastError();
                    TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Error in NdisQueryHwAddress = %d", dwRetCode);
                    dwRetCode = NO_ERROR;
                    continue;
                }

                RtlFreeUnicodeString (&TempUString);
                    
                TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: NdisQueryHwAddress successful");

                if (pszGUIDStart != NULL)
                {
                    chGUIDSaveLast = *(pszGUIDEnd);
                    
                    // Ignore the leading '{' and the trailing '}'
                    // in the GUID

                    *(pszGUIDEnd) = (CHAR)NULL;
                    pszGUIDStart ++;

                }

                // Verify if a PCB already exists for the interface
                // This is possible if no media disconnect was received
                // after the initial media connect

                ACQUIRE_WRITE_LOCK (&g_PCBLock);

                pPCB = ElGetPCBPointerFromPortGUID (pszGUIDStart);

                RELEASE_WRITE_LOCK (&g_PCBLock);

                // Restore interface buffer

                *(pszGUIDEnd) = chGUIDSaveLast;

                if (pPCB != NULL)
                {
                    // Point to existing handle

                    hDevice = pPCB->hPort;
                    fPCBExists = TRUE;
                    dwRetCode = NO_ERROR;
                    TRACE0 (INIT, "ElEnumAndOpenInterfaces: Found PCB already existing for interface");
                }
                else
                {
                    TRACE0 (INIT, "ElEnumAndOpenInterfaces: Did NOT find PCB already existing for interface");

                    // Open handle to ndisuio driver

                    if ((dwRetCode = ElOpenInterfaceHandle (
                                    InterfaceName.Buffer,
                                    &hDevice
                                    )) != NO_ERROR)
                    {
                        TRACE1 (INIT, "ElEnumAndOpenInterfaces: ElOpenInterfaceHandle failed with error = %d\n",
                            dwRetCode );
                    }
                }

                *(pszGUIDEnd) = (CHAR)NULL;

            }

            if (dwRetCode != NO_ERROR)
            {
                TRACE0 (INIT, "ElEnumAndOpenInterfaces: Failed to open handle");
                dwRetCode = NO_ERROR;
                continue;
            }
            else
            {
                // Verify if EAPOL is to be started on the interface
                // at all

                if ((dwRetCode = ElGetInterfaceParams (
                                pszGUIDStart,
                                &dwEapTypeToBeUsed,
                                csDummyBuffer,
                                &dwEapolEnabled
                                )) != NO_ERROR)
                {
                    TRACE2 (INIT, "ElEnumAndOpenInterfaces: ElGetInterfaceParams failed with error %ld for interface %s",
                            dwRetCode, pszDesiredGUID);

                    dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
                    dwEapolEnabled = DEFAULT_EAPOL_STATE;

                    if (dwEapolEnabled)
                    {
                        dwRetCode = NO_ERROR;
                    }
                    else
                    {

                        // Close the handle to the ndisuio driver

                        if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) 
                                != NO_ERROR)
                        {
                            TRACE1 (DEVICE, 
                                "ElEnumAndOpenInterfaces: Error in ElCloseInterfaceHandle %d", 
                                dwRetCode);
                        }
                        dwRetCode = NO_ERROR;

                        TRACE1 (INIT, "EAPOL will not be started on %s", InterfaceName.Buffer);
                        // Continue with other interfaces
                        continue;
                    }

                }

                if (dwEapolEnabled != EAPOL_ENABLED)
                {
                    TRACE1 (INIT, "EAPOL not to be started on interface %s",
                            pszDesiredGUID);

                    // Close the handle to the ndisuio driver

                    if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) 
                            != NO_ERROR)
                    {
                        TRACE1 (DEVICE, 
                            "ElEnumAndOpenInterfaces: Error in ElCloseInterfaceHandle %d", 
                            dwRetCode);
                    }

                    // Continue with the next interface

                    dwRetCode = NO_ERROR;
                    continue;
                }
                
                // ISSUE:
                // What MAC address should we pass to CreatePort
                // perm or cur

                // Create EAPOL PCB and start state machine

                if ((dwRetCode = ElCreatePort (
                                hDevice,
                                pszGUIDStart,
                                InterfaceDescription.Buffer,
                                csCurrMacAddress
                                )) != NO_ERROR)
                {
                    TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Error in CreatePort = %d", dwRetCode);

                    // Close the handle to the ndisuio driver

                    if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) != NO_ERROR)
                    {
                        TRACE1 (DEVICE, 
                            "ElEnumAndOpenInterfaces: Error in ElCloseInterfaceHandle %d", 
                            dwRetCode);
                    }

                    // Continue with the next interface

                    dwRetCode = NO_ERROR;
                    continue;
                }
                else
                {
                    TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: CreatePort successful");

                    // If PCB already existed, do not add to the hash
                    // table

                    if (fPCBExists == TRUE)
                    {
                        TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: PCB already existed, skipping Interface hash table addition");
                        fPCBExists = FALSE;
                        dwRetCode = NO_ERROR;
                        continue;
                    }

                    
                    // Add entry to Interface hash table

                    dwIndex = ElHashInterfaceDescToBucket (
                        InterfaceDescription.Buffer);
                    pNewITF = (PEAPOL_ITF) 
                        MALLOC (sizeof (EAPOL_ITF));
                    if (pNewITF != NULL) 
                    {
                        pNewITF->pszInterfaceGUID = 
                            (CHAR *) MALLOC (strlen(pszGUIDStart) + 1);
                        if (pNewITF->pszInterfaceGUID != NULL)
                        {
                            memcpy (pNewITF->pszInterfaceGUID,
                                pszGUIDStart,
                                strlen (pszGUIDStart));
                            pNewITF->pszInterfaceGUID[strlen (pszGUIDStart)] = '\0';
                        }
                        pNewITF->pszInterfaceDesc = 
                            (CHAR *) MALLOC (strlen(InterfaceDescription.Buffer) + 1);
                        if (pNewITF->pszInterfaceDesc != NULL)
                        {
                            memcpy (pNewITF->pszInterfaceDesc,
                                InterfaceDescription.Buffer,
                                strlen (InterfaceDescription.Buffer));
                            pNewITF->pszInterfaceDesc[strlen (InterfaceDescription.Buffer)] = '\0';
                        }


                        pNewITF->pNext = 
                            g_ITFTable.pITFBuckets[dwIndex].pItf;
                        g_ITFTable.pITFBuckets[dwIndex].pItf = pNewITF;

                        if ( (pNewITF->pszInterfaceGUID == NULL) ||
                                (pNewITF->pszInterfaceDesc == NULL))
                        {
                            ElRemoveITFFromTable (pNewITF); 
                            if (pNewITF->pszInterfaceDesc)
                            {
                                FREE (pNewITF->pszInterfaceDesc);
                            }
                            if (pNewITF->pszInterfaceGUID)
                            {
                                FREE (pNewITF->pszInterfaceGUID);
                            }
                            if (pNewITF)
                            {
                                FREE (pNewITF);
                            }

                            pNewITF = NULL;

                            TRACE0 (DEVICE, "ElEnumAndOpenInterfaces: Error in memory allocation, ITF structure not created");

                        }
                    }

                    // Could not create new interface entry
                    // Delete Port entry created for this GUID

                    if (pNewITF == NULL)
                    {
                        if ((dwRetCode = ElDeletePort (
                                        pszGUIDStart,
                                        &hDevice)) != NO_ERROR)
                        {
        
                            TRACE1 (DEVICE, "ElEnumAndOpenInterfaces: Error in deleting port for %s", 
                                    pszGUIDStart);
                            // log
                        }

                        // Close the handle to the NDISUIO driver

                        if ((dwRetCode = ElCloseInterfaceHandle (
                                        hDevice)) != NO_ERROR)
                        {
                            TRACE1 (DEVICE, 
                                    "ElMediaSenseCallback: Error in ElCloseInterfaceHandle %d", 
                                    dwRetCode);
                            // log
                        }
                    }
                    else
                    {
                        TRACE3 (DEVICE, "ElEnumAndOpenInterfaces: Added to hash table GUID= %s : Desc= %s at Index=%d",
                                pNewITF->pszInterfaceGUID,
                                pNewITF->pszInterfaceDesc,
                                dwIndex
                                );
                        //
                        // Interface Handle created successfully
                        // Notify Zero Config about it
                        //
                    }
                }
            }
        } // for (i=0; i < Interfaces
    }
    else
    {
        TRACE1(INIT, "ElEnumAndOpenInterfaces: ElNdisuioEnumerateInterfaces failed with error %d", 
                dwRetCode);
    }

    TRACE1(INIT, "ElEnumAndOpenInterfaces: Completed with retcode = %d", 
            dwRetCode);

    if (pbNdisuioEnumBuffer != NULL)
    {
        FREE(pbNdisuioEnumBuffer);
    }

    return dwRetCode;
}


//
// ElGetCardStatus
//
// Function to query the media information for an interface
//
// Input arguments:
//  pDeviceName - Unicode device name
//
// Return values:
//  pdwNetCardStatus - Media state
//  pdwMediaType    - Media type as exposed to NDIS e.g. 802.3
//

DWORD
ElGetCardStatus (  
        PUNICODE_STRING pDeviceName, 
        DWORD           *pdwNetCardStatus,
        DWORD           *pdwMediaType
        )
{
    NIC_STATISTICS 	Stats;
    DWORD		dwNicStatus = 0;
    DWORD		dwRetCode = NO_ERROR;

    Stats.Size = sizeof(NIC_STATISTICS);
    if (NdisQueryStatistics(pDeviceName, &Stats))
    {
        switch (Stats.MediaState)
        {
            case MEDIA_STATE_CONNECTED:
                dwNicStatus = MEDIA_STATE_CONNECTED;
                TRACE0(INIT, "ElGetCardStatus: dwNicStatus = NETCARD_CONNECTED\n");
                break;
            case MEDIA_STATE_DISCONNECTED:
                dwNicStatus = MEDIA_STATE_DISCONNECTED;
                TRACE0(INIT, "ElGetCardStatus: dwNicStatus = NETCARD_DISCONNECTED\n");
                break;
            default:
                dwNicStatus = MEDIA_STATE_UNKNOWN;
                TRACE0(INIT, "ElGetCardStatus: dwNicStatus = NETCARD_STATUS_UNKNOWN\n");
                break;
        }

        switch (Stats.MediaType)
        {
            case NdisMedium802_3:
                TRACE0 (INIT, "ElGetCardStatus: MediaType is 802.3");
                break;
            default:
                TRACE0 (INIT, "ElGetCardStatus: MediaType is NOT *802.3*");
                break;
        }

        *pdwMediaType = Stats.MediaType;
    }
    else
    {
        dwRetCode = GetLastError ();
        TRACE1(INIT, "ElGetCardStatus: NdisQueryStatistics failed with error %d\n", dwRetCode);
    }

    *pdwNetCardStatus = dwNicStatus;

    return dwRetCode;
}


//
// ElOpenInterfaceHandle
// 
// Description:
//
// Function called to open handle to the NDISUIO driver for an interface.
//
// Arguments:
//      DeviceName - Identifier for the interface is of the 
//                     form \Device\{GUID String}
//      phDevice - Output pointer to handle of NDISUIO driver for 
//                      the interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElOpenInterfaceHandle (
        IN  CHAR        *pszDeviceName,
        OUT HANDLE      *phDevice
        )
{
    DWORD   dwDesiredAccess;
    DWORD   dwShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;
    DWORD   dwCreationDistribution;
    DWORD   dwFlagsAndAttributes;
    HANDLE  hTemplateFile;
    HANDLE  hHandle;
    DWORD   dwRetCode = NO_ERROR;
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];
    INT     wNameLength;
    INT     NameLength = strlen(pszDeviceName);
    DWORD   dwBytesReturned;
    USHORT  wEthernetType=0x8081;
    INT     i;

    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    dwCreationDistribution = OPEN_EXISTING;
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
    hTemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    TRACE1 (INIT, "ElOpenInterfaceHandle: Opening handle for %s", pszDeviceName);

    do 
    {

        hHandle = CreateFileA(
                    pNdisuioDevice,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    dwFlagsAndAttributes,
                    hTemplateFile
                    );

        if (hHandle == INVALID_HANDLE_VALUE)
        {
            *phDevice = NULL;
            dwRetCode = GetLastError();
            TRACE1 (INIT, "ElOpenInterfaceHandle: Failed in CreateFile with error %d", dwRetCode);
            break;
        }
        else
        {
            *phDevice = hHandle;
        }
    
    
        // Convert to unicode string - non-localized...
        
        wNameLength = 0;
        for (i = 0; i < NameLength && i < MAX_NDIS_DEVICE_NAME_LEN-1; i++)
        {
            wNdisDeviceName[i] = (WCHAR)pszDeviceName[i];
            wNameLength++;
        }
        wNdisDeviceName[i] = L'\0';
    
        TRACE1(DEVICE, "ElOpenInterfaceHandle: Trying to access NDIS Device: %ws\n", 
                wNdisDeviceName);
    

        if (!(DeviceIoControl(
                *phDevice,
                IOCTL_NDISUIO_OPEN_DEVICE,
                (LPVOID)&wNdisDeviceName[0],
                wNameLength*sizeof(WCHAR),
                NULL,
                0,
                &dwBytesReturned,
                NULL)))
                
        {
            *phDevice = NULL;
            if ((dwRetCode = GetLastError()) == 0)
            {
                dwRetCode = ERROR_IO_DEVICE;
            }
            TRACE1(DEVICE, "ElOpenInterfaceHandle: Error in accessing NDIS Device: %ws", wNdisDeviceName);
            break;
        }
    
        // IOCTL down the Ethernet type

        if (!(DeviceIoControl(
                *phDevice,
                IOCTL_NDISUIO_SET_ETHER_TYPE,
                (LPVOID)&wEthernetType,
                sizeof(USHORT),
                NULL,
                0,
                &dwBytesReturned,
                NULL)))
                
        {
            *phDevice = NULL;
            if ((dwRetCode = GetLastError()) == 0)
            {
                dwRetCode = ERROR_IO_DEVICE;
            }
            TRACE1(DEVICE, "ElOpenInterfaceHandle: Error in ioctling ETHER type : %ws", wNdisDeviceName);
            break;
        }

        // Bind for asynchronous I/O handling of Read/Write data
        // Depending on whether it is completion for Readfile() or WriteFile()
        // ElIoCompletionRoutine will call ElReadCompletionRoutine
        // or ElWriteCompletionRoutine
       
        if (!BindIoCompletionCallback(
                *phDevice,
                ElIoCompletionRoutine,
                0
                ))
        {
            *phDevice = NULL;
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElOpenInterfaceHandle: Error in BindIoCompletionCallBac %d", dwRetCode);
            break;
        }
        
    } while (FALSE);

    // Cleanup if there is error

    if (dwRetCode != NO_ERROR)
    {
        if (hHandle != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(hHandle))
            {
                dwRetCode = GetLastError();
                TRACE1 (INIT, "ElOpenInterfaceHandle: Error in CloseHandle %d", dwRetCode);
            }
        }
    }
        
    TRACE2 (INIT, "ElOpenInterfaceHandle: Opened handle %p with dwRetCode %d", *phDevice, dwRetCode);

    return (dwRetCode);

}


//
// ElCloseInterfaceHandle
// 
// Description:
//
// Function called to close handle to NDISUIO driver for an interface 
//
// Arguments:
//      hDevice - Handle to NDISUIO device for the interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCloseInterfaceHandle (
        IN  HANDLE      hDevice
        )
{
    DWORD   dwRetCode = NO_ERROR;

    TRACE0 (DEVICE, "ElCloseInterfaceHandle entered");

    if (!CloseHandle(hDevice))
    {
        dwRetCode = GetLastError();
        TRACE1 (INIT, "ElCloseInterfaceHandle: Error in CloseHandle %d", 
                dwRetCode);
    }

    return dwRetCode;
}


//
// ElReadFromInterface
// 
// Description:
//
// Function called to perform Overlapped read on handle to NDISUIO driver
//
// Arguments:
//      hDevice - Handle to NDISUIO driver for this interface
//      pElBuffer - Context buffer
//      dwBufferLength - Bytes to be read
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElReadFromInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pElBuffer,
        IN DWORD            dwBufferLength
        )
{
    DWORD   dwRetCode = NO_ERROR;

    if (!ReadFile (
                hDevice,
                pElBuffer->pBuffer,
                dwBufferLength,
                NULL,
                &pElBuffer->Overlapped
                ))
    {
        dwRetCode = GetLastError();
            
        if (dwRetCode == ERROR_IO_PENDING)
        {
            // Pending status is fine, we are doing OVERLAPPED read

            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE1 (DEVICE, "ElReadFromInterface: ReadFile failed with error %d",
                    dwRetCode);
        }
    }

    return dwRetCode;
}


//
// ElWriteToInterface
// 
// Description:
//
// Function called to perform Overlapped write on handle to NDISUIO driver
//
// Arguments:
//      hDevice - Handle to NDISUIO device for this interface
//      pElBuffer - Context buffer
//      dwBufferLength - Bytes to be written
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElWriteToInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pElBuffer,
        IN DWORD            dwBufferLength
        )
{
    DWORD   dwRetCode = NO_ERROR;
    
    TRACE0 (DEVICE, "ElWriteToInterface entered");

    if (!WriteFile (
                hDevice,
                pElBuffer->pBuffer,
                dwBufferLength,
                NULL,
                &pElBuffer->Overlapped
                ))
    {
        dwRetCode = GetLastError();
            
        if (dwRetCode == ERROR_IO_PENDING)
        {
            // Pending status is fine, we are doing OVERLAPPED write

            dwRetCode = NO_ERROR;
        }
        else
        {
            TRACE1 (DEVICE, "ElWriteToInterface: WriteFile failed with error %d",
                dwRetCode);
        }
    }

    TRACE1 (DEVICE, "ElWriteToInterface completed, dwRetCode = %d", dwRetCode);
    return dwRetCode;
}


// 
// ElHashInterfaceDescToBucket
// 
// Description:
//
// Function called to convert Friendly name of interface into interface hash 
// table index.
//
// Arguments:
//      pszInterfaceDesc - Friendly name of the interface
//
// Return values:
//      Hash table index between from 0 to INTF_TABLE_BUCKETS-1
//

DWORD
ElHashInterfaceDescToBucket (
        IN CHAR *pszInterfaceDesc
        )
{
    return ((DWORD)((atol(pszInterfaceDesc)) % INTF_TABLE_BUCKETS)); 
}


//
// ElGetITFPointerFromInterfaceDesc
//
// Description:
//
// Function called to convert Friendly name of interface to ITF entry pointer
//
// Arguments:
//      pszInterfaceDesc - Friendly name of the interface
//
// Return values:
//      Pointer to interface entry in hash table
//

PEAPOL_ITF
ElGetITFPointerFromInterfaceDesc (
        IN CHAR *pszInterfaceDesc 
        )
{
    EAPOL_ITF   *pITFWalker = NULL;
    DWORD       dwIndex;
    INT         i=0;

    TRACE1 (DEVICE, "ElGetITFPointerFromInterfaceDesc: Desc = %s", pszInterfaceDesc);
        
    if (pszInterfaceDesc == NULL)
    {
        return (NULL);
    }

    dwIndex = ElHashInterfaceDescToBucket (pszInterfaceDesc);

    TRACE1 (DEVICE, "ElGetITFPointerFromItfDesc: Index %d", dwIndex);

    for (pITFWalker = g_ITFTable.pITFBuckets[dwIndex].pItf;
            pITFWalker != NULL;
            pITFWalker = pITFWalker->pNext
            )
    {
        if (strncmp (pITFWalker->pszInterfaceDesc, pszInterfaceDesc, strlen(pszInterfaceDesc)) == 0)
        {
            return pITFWalker;
        }
    }

    return (NULL);
}


//
// ElRemoveITFFromTable
// 
// Description:
//
// Function called to remove an interface entry from the interface hash 
// table
//
// Arguments:
//      pITF - Point to the Interface entry in the hash table
//
// Return values:
// 

VOID
ElRemoveITFFromTable (
        IN EAPOL_ITF *pITF
        )
{
    DWORD       dwIndex;
    EAPOL_ITF   *pITFWalker = NULL;
    EAPOL_ITF   *pITFTemp = NULL;

    if (pITF == NULL)
    {
        TRACE0 (EAPOL, "ElRemoveITFFromTable: Deleting NULL ITF, returning");
        return;
    }

    dwIndex = ElHashInterfaceDescToBucket (pITF->pszInterfaceDesc);
    pITFWalker = g_ITFTable.pITFBuckets[dwIndex].pItf;
    pITFTemp = pITFWalker;

    while (pITFTemp != NULL)
    {
        if (strncmp (pITFTemp->pszInterfaceGUID, 
                    pITF->pszInterfaceGUID, strlen(pITF->pszInterfaceGUID)) == 0)
        {
            // Entry is at head of list in table
            if (pITFTemp == g_ITFTable.pITFBuckets[dwIndex].pItf)
            {
                g_ITFTable.pITFBuckets[dwIndex].pItf = pITFTemp->pNext;
            }
            else
            {
                // Entry is inside list in table
                pITFWalker->pNext = pITFTemp->pNext;
            }
        
            break;
        }

        pITFWalker = pITFTemp;
        pITFTemp = pITFWalker->pNext;
    }

    return;
}


//
// ElNdisuioEnumerateInterfaces
// 
// Description:
//
// Function called to enumerate the interfaces on which NDISUIO is bound
//
// Arguments:
//      pBuffer - Pointer to buffer which will hold interface details
//      dwAvailableInterfaces - Number of interfaces for which details can
//                      be held in pItfBuffer
//      dwBufferSize - Number of bytes in pItfBuffer
//
// Return values:
// 

DWORD
ElNdisuioEnumerateInterfaces (
        IN OUT  PNDIS_ENUM_INTF     pItfBuffer,
        IN      DWORD               dwAvailableInterfaces,
        IN      DWORD               dwBufferSize
        )
{
    DWORD       dwDesiredAccess;
    DWORD       dwShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;
    DWORD       dwCreationDistribution;
    DWORD       dwFlagsAndAttributes;
    HANDLE      hTemplateFile;
    HANDLE      hHandle;
    DWORD       dwBytesReturned = 0;
    INT         i;
    CHAR        Buf[1024];
    DWORD       BufLength = sizeof(Buf);
    DWORD       BytesWritten = 0;
    PNDISUIO_QUERY_BINDING pQueryBinding = NULL;
    PCHAR       pTempBuf = NULL;
    DWORD       dwRetCode = NO_ERROR;

    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    dwCreationDistribution = OPEN_EXISTING;
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
    hTemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    TRACE0 (DEVICE, "ElNdisuioEnumerateInterfaces: Opening handle");

    do 
    {

        hHandle = CreateFileA (
                    pNdisuioDevice,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    0,
                    NULL
                    );

        if (hHandle == INVALID_HANDLE_VALUE)
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Failed in CreateFile with error %d", dwRetCode);

            break;
        }

        // Send IOCTL to ensure NDISUIO binds to all relevant interfaces

        if (!DeviceIoControl (
                    hHandle,
                    IOCTL_NDISUIO_BIND_WAIT,
                    NULL,
                    0,
                    NULL,
                    0,
                    &dwBytesReturned,
                    NULL))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Failed in DeviceIoCoontrol NDISUIO_BIND_WAIT with error %d", dwRetCode);
            break;
        }
    
        pQueryBinding = (PNDISUIO_QUERY_BINDING)Buf;

        pTempBuf = (PBYTE)pItfBuffer + dwBufferSize;

        i = 0;
        for (pQueryBinding->BindingIndex = i;
            pQueryBinding->BindingIndex < dwAvailableInterfaces;
            pQueryBinding->BindingIndex = ++i)
        {

Try_Again:

            g_QueryBinding = NULL;
            g_TempBuf = NULL;
            g_ItfBuffer = NULL;
            g_Buf = NULL;
            g_ItfBufferSize = 0;
            g_BreakAt = 1;
            
            // Query for one interface at a time
            
            if (DeviceIoControl (
                    hHandle,
                    IOCTL_NDISUIO_QUERY_BINDING,
                    pQueryBinding,
                    sizeof(NDISUIO_QUERY_BINDING),
                    Buf,
                    BufLength,
                    &BytesWritten,
                    NULL))
            {
                TRACE3 (DEVICE, "NdisuioEnumerateInterfaces: NDISUIO bound to: %2d. %ws\n     - %ws\n",
                    pQueryBinding->BindingIndex,
                    (PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset,
                    (PUCHAR)pQueryBinding + pQueryBinding->DeviceDescrOffset);

                g_QueryBinding = (PVOID)pQueryBinding;
                g_TempBuf = (PVOID)pTempBuf;
                g_ItfBuffer = (PVOID)pItfBuffer;
                g_ItfBufferSize = dwBufferSize;
                g_Buf = (PVOID)Buf;
                g_BreakAt = 1;

                pTempBuf = pTempBuf - ((pQueryBinding->DeviceNameLength + 7) & 0xfffffff8);

                if (((PBYTE)pTempBuf - (PBYTE)&pItfBuffer->Interface[pItfBuffer->TotalInterfaces]) <= 0)
                {
                    // Going beyond start of buffer, Error
                    TRACE0 (DEVICE, "NdisuioEnumerateInterfaces: DeviceName: Memory being corrupted !!!");
                    DebugBreak ();

                    goto Try_Again;
                }

                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Buffer = (PWCHAR) pTempBuf;


                memcpy ((BYTE *)(pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Buffer), (BYTE *)((PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset), (pQueryBinding->DeviceNameLength - sizeof(WCHAR)));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.Length = (SHORT) ( pQueryBinding->DeviceNameLength - sizeof(WCHAR));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceName.MaximumLength = (SHORT) ( pQueryBinding->DeviceNameLength - sizeof(WCHAR));

                pTempBuf = pTempBuf - ((pQueryBinding->DeviceDescrLength + 7) & 0xfffffff8);;
                g_BreakAt = 2;

                if (((PBYTE)pTempBuf - (PBYTE)&pItfBuffer->Interface[pItfBuffer->TotalInterfaces]) <= 0)
                {
                    // Going beyond start of buffer, Error
                    TRACE0 (DEVICE, "NdisuioEnumerateInterfaces: DeviceDescr: Memory being corrupted !!!");
                    DebugBreak ();
                    goto Try_Again;
                }

                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Buffer = (PWCHAR) pTempBuf;


                memcpy ((pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Buffer), (PWCHAR)((PUCHAR)pQueryBinding + pQueryBinding->DeviceDescrOffset), (pQueryBinding->DeviceDescrLength - sizeof(WCHAR)));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.Length = (SHORT) (pQueryBinding->DeviceDescrLength - sizeof(WCHAR));
                pItfBuffer->Interface[pItfBuffer->TotalInterfaces].DeviceDescription.MaximumLength = (SHORT) (pQueryBinding->DeviceDescrLength - sizeof(WCHAR));

                pItfBuffer->TotalInterfaces++;

                memset(Buf, 0, BufLength);
            }
            else
            {
                dwRetCode = GetLastError ();
                if (dwRetCode != ERROR_NO_MORE_ITEMS)
                {
                    TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: DeviceIoControl terminated for with IOCTL_NDISUIO_QUERY_BINDING with error %ld",
                            dwRetCode);
                }
                else
                {
                    // Reset error, since it only indicates end-of-list
                    dwRetCode = NO_ERROR;
                    TRACE0 (DEVICE, "ElNdisuioEnumerateInterfaces: DeviceIoControl IOCTL_NDISUIO_QUERY_BINDING has no more entries");
                }
                break;
            }
        }
            
    } while (FALSE);

    // Cleanup 

    if (hHandle != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hHandle))
        {
            dwRetCode = GetLastError();
            TRACE1 (DEVICE, "ElNdisuioEnumerateInterfaces: Error in CloseHandle %d", dwRetCode);
        }
    }
         
    TRACE2 (DEVICE, "ElNdisuioEnumerateInterfaces: Opened handle %p with dwRetCode %d", 
            hHandle, dwRetCode);

    return dwRetCode;
}



//
// ElShutdownInterface
// 
// Description:
//
// Function called to stop EAPOL state machine, close handle to NDISUIO and
//  remove existence of the interface from the module
//
// Arguments:
//      pszGUID - Pointer to interface GUID
//
// Return values:
//  NO_ERROR - success
//  non-zero - error
// 

DWORD
ElShutdownInterface (
        IN      CHAR               *pszGUID
        )
{
    EAPOL_PCB   *pPCB = NULL;
    EAPOL_ITF   *pITF = NULL;
    HANDLE      hDevice = NULL;
    DWORD       dwRetCode = NO_ERROR;

    do
    {

        TRACE0(DEVICE, "ElShutdownInterface: Called for interface removal");

        ACQUIRE_WRITE_LOCK (&(g_ITFLock));

        // Check if EAPOL was actually started on this interface
        // Verify by checking existence of corresponding 
        // entry in hash table
    
        ACQUIRE_WRITE_LOCK (&(g_PCBLock));
        if ((pPCB = ElGetPCBPointerFromPortGUID(pszGUID))
                != NULL)
        {
            RELEASE_WRITE_LOCK (&(g_PCBLock));
            TRACE0 (DEVICE, "ElShutdownInterface: Found PCB entry for interface");
    
            if ((pITF = ElGetITFPointerFromInterfaceDesc(
                            pPCB->pszFriendlyName))
                            == NULL)
            {
                TRACE0 (DEVICE, "ElShutdownInterface: Did not find ITF entry when PCB exits, HOW BIZARRE !!!");
            }
    
            if ((dwRetCode = ElDeletePort (
                            pszGUID, 
                            &hDevice)) != NO_ERROR)
            {
                TRACE1 (DEVICE, "ElShutdownInterface: Error in deleting port for %s", 
                    pPCB->pszDeviceGUID);
            }
    
            // Remove interface entry from interface table
            
            if (pITF != NULL)
            {
                ElRemoveITFFromTable(pITF);
                        
                if (pITF->pszInterfaceDesc)
                {
                    FREE (pITF->pszInterfaceDesc);
                }
                if (pITF->pszInterfaceGUID)
                {
                    FREE (pITF->pszInterfaceGUID);
                }
                if (pITF)
                {
                    FREE (pITF);
                }
            }
    
            // Close the handle to the NDISUIO driver

            if (hDevice != NULL)
            {
                if ((dwRetCode = ElCloseInterfaceHandle (hDevice)) 
                        != NO_ERROR)
                {
                    TRACE1 (DEVICE, 
                        "ElShutdownInterface: Error in ElCloseInterfaceHandle %d", 
                        dwRetCode);
                }
            }
    
            TRACE1 (DEVICE, "ElShutdownInterface: Port deleted %s", 
                    pszGUID);
    
        }
        else
        {
            RELEASE_WRITE_LOCK (&(g_PCBLock));

            // Ignore device removal 
            
            TRACE0 (DEVICE, "ElShutdownInterface: ElGetPCBPointerFromPortGUID did not find any matching entry, ignoring interface REMOVAL");
    
        }
    
        RELEASE_WRITE_LOCK (&g_ITFLock);

    } while (FALSE);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eldeviceio.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eldeviceio.h

Abstract:

    This module contains declarations for media-management and device I/O.
    The module interfaces with WMI, NDIS for device managment, and NDIS UIO
    for read/write of data.
    The routines declared here operate asynchronously on the handles 
    associated with an I/O completion port opened on the ndis uio driver. 


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_DEVICEIO_H_
#define _EAPOL_DEVICEIO_H_

//
// Hash table definition for interfaces
//

typedef struct _EAPOL_ITF
{
    struct _EAPOL_ITF  *pNext;
    CHAR                *pszInterfaceDesc; // Friendly name of interface
    CHAR                *pszInterfaceGUID; // GUID 
} EAPOL_ITF, *PEAPOL_ITF;


typedef struct _ITF_BUCKET
{
    EAPOL_ITF           *pItf;
} ITF_BUCKET, *PITF_BUCKET;


typedef struct _ITF_TABLE
{
    ITF_BUCKET          *pITFBuckets;
    DWORD               dwNumITFBuckets;
} ITF_TABLE, *PITF_TABLE;


//
// Variables global to eldeviceio.h
//

// Interface table containing interface friendly-name GUID pair

ITF_TABLE           g_ITFTable;         

// Read-write lock for interface table synchronization

READ_WRITE_LOCK     g_ITFLock;          


//
// FUNCTION DECLARATIONS
//

DWORD
ElMediaInit (
        );

DWORD
ElMediaDeInit (
        );

DWORD
ElMediaSenseRegister (
        IN  BOOL            Register
        );

VOID
ElMediaSenseCallback (
        IN PWNODE_HEADER    pWnodeHeader,
        IN UINT_PTR         uiNotificationContext
        );

VOID
ElMediaSenseCallbackWorker (
        IN PVOID            pvContext
        );

DWORD
ElDeviceNotificationRegister (
        IN  BOOL            fRegister
        );

DWORD
ElDeviceNotificationHandler (
        IN  PVOID           lpEventData,
        IN  DWORD           dwEventType
        );

VOID
ElDeviceNotificationHandlerWorker (
        IN  PVOID           pvContext
        );

DWORD
ElEnumAndOpenInterfaces (
        IN CHAR             *pszDesiredDescription,
        IN CHAR             *pszDesiredGUID
        );

DWORD
ElOpenInterfaceHandle (
        IN  CHAR            *pszDeviceName,
        OUT HANDLE          hDevice
        );

DWORD
ElCloseInterfaceHandle (
        IN  HANDLE          hDevice
        );

DWORD
ElReadFromInterface (
        IN HANDLE           hDevice,
        IN PEAPOL_BUFFER    pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElWriteToInterface (
        IN HANDLE  hDevice,
        IN PEAPOL_BUFFER    pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElGetCardStatus (
        UNICODE_STRING      *pInterface,
        DWORD               *pdwNetCardStatus,
        DWORD               *pdwMediaType
        );

DWORD
ElHashInterfaceDescToBucket (
        IN CHAR             *pszInterfaceDesc
        );

PEAPOL_ITF
ElGetITFPointerFromInterfaceDesc (
        IN CHAR             *pszInterfaceDesc
        );

VOID
ElRemoveITFFromTable (
        IN EAPOL_ITF        *pITF
        );

DWORD
ElNdisuioEnumerateInterfaces (
        IN OUT  PNDIS_ENUM_INTF     pItfBuffer,
        IN      DWORD               dwTotalInterfaces,
        IN      DWORD               dwBufferSize
        );

DWORD
ElShutdownInterface (
        IN      CHAR               *pszGUID
        );


#endif //_EAPOL_DEVICEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eleap.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eleap.c

Abstract:
    Module that will do interfacing between the EAPOL engine and the EAP
    implementations

Revision History:

    sachins, May 04 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>
//#include <mprlog.h>
//#include <mprerror.h>
//#include <raserror.h>
#include <raseapif.h>


//
// ElLoadEapDlls
//
// Description: 
//
// Function called to load all the EAP dlls installed in the PPP
// configuration in the registry
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElLoadEapDlls (
    VOID 
    )
{
    HKEY        hKeyEap             = (HKEY)NULL;
    LPWSTR      pEapDllPath         = (LPWSTR)NULL;
    LPWSTR      pEapDllExpandedPath = (LPWSTR)NULL;
    HKEY        hKeyEapDll          = (HKEY)NULL;
    DWORD       dwRetCode;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       dwKeyIndex;
    WCHAR       wchSubKeyName[50];
    HINSTANCE   hInstance;
    FARPROC     pRasEapGetInfo;
    DWORD       cbSubKeyName;
    DWORD       dwSecDescLen;
    DWORD       cbSize;
    DWORD       dwType;
    DWORD       dwEapTypeId;

    //
    // Open the EAP key
    //

    dwRetCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              RAS_EAP_REGISTRY_LOCATION,
                              0,
                              KEY_READ,
                              &hKeyEap);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (EAP,"ElLoadEapDlls: RegOpenKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
        //EapolLogErrorString( ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL, dwRetCode,0);

        return dwRetCode;
    }

    //
    // Find out how many EAP DLLs there are
    //

    dwRetCode = RegQueryInfoKey (
                                hKeyEap,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL);

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (EAP,"ElLoadEapDlls: RegQueryInfoKey failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
        //EapolLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL, dwRetCode,0);

        RegCloseKey (hKeyEap);

        return dwRetCode;
    }

    //
    // Allocate space in the table to hold information for each one 
    //

    g_pEapTable= (EAP_INFO*) MALLOC (sizeof(EAP_INFO)*dwNumSubKeys);

    if (g_pEapTable == NULL)
    {
        RegCloseKey (hKeyEap);

        return(GetLastError());
    }

    //
    // Read the registry to find out the various EAPs to load.
    //

    for (dwKeyIndex = 0; dwKeyIndex < dwNumSubKeys; dwKeyIndex++)
    {
        cbSubKeyName = sizeof(wchSubKeyName);

        dwRetCode = RegEnumKeyEx (   
                                hKeyEap,
                                dwKeyIndex,
                                wchSubKeyName,
                                &cbSubKeyName,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if ((dwRetCode != NO_ERROR)      &&
             (dwRetCode != ERROR_MORE_DATA)   &&
             (dwRetCode != ERROR_NO_MORE_ITEMS))
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegEnumKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION with error = %ld", 
                dwRetCode);
            //EapolLogErrorString(ROUTERLOG_CANT_ENUM_REGKEYVALUES,0,
                              //NULL,dwRetCode,0);
            break;
        }
        else
        {
            if (dwRetCode == ERROR_NO_MORE_ITEMS)
            {
                dwRetCode = NO_ERROR;

                break;
            }
        }

        do 
        {

        dwRetCode = RegOpenKeyEx (
                                hKeyEap,
                                wchSubKeyName,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyEapDll);


        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegOpenKeyEx failed for HKLM\\RAS_EAP_REGISTRY_LOCATION\\dll with error = %ld", 
                dwRetCode);
            //EapolLogErrorString( ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                               //dwRetCode,0);
            break;
        }

        dwEapTypeId = _wtol (wchSubKeyName);

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey (
                                hKeyEapDll,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegQueryInfoKey failed for hKeyEapDll with error = %ld", 
                dwRetCode);
            //EapolLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              //dwRetCode,0);
            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        cbMaxValueDataSize += sizeof (WCHAR);

        pEapDllPath = (LPWSTR) MALLOC (cbMaxValueDataSize);

        if (pEapDllPath == (LPWSTR)NULL)
        {
            dwRetCode = GetLastError();
            //EapolLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx (
                                hKeyEapDll,
                                RAS_EAP_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                (LPBYTE)pEapDllPath,
                                &cbMaxValueDataSize);

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: RegQueryValueEx failed for hKeyEapDll\\RAS_EAP_VALUENAME_PATH with error = %ld", 
                dwRetCode);
            //EapolLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ((dwType != REG_EXPAND_SZ) && (dwType != REG_SZ))
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            TRACE1 (EAP,"ElLoadEapDlls: Registry corrupt for hKeyEapDll\\RAS_EAP_VALUENAME_PATH with error = %ld", 
                dwRetCode);
            //EapolLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings (pEapDllPath, NULL, 0);

        if (cbSize == 0)
        {
            dwRetCode = GetLastError();
            //EapolLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        pEapDllExpandedPath = (LPWSTR) MALLOC (cbSize*sizeof(WCHAR));

        if (pEapDllExpandedPath == (LPWSTR)NULL)
        {
            dwRetCode = GetLastError();
            //EapolLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        cbSize = ExpandEnvironmentStrings (pEapDllPath,
                                           pEapDllExpandedPath,
                                           cbSize*sizeof(WCHAR));
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            //EapolLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        hInstance = LoadLibrary (pEapDllExpandedPath);

        if (hInstance == (HINSTANCE)NULL)
        {
            dwRetCode = GetLastError();
            TRACE1 (EAP,"ElLoadEapDlls: LoadLibrary failed with error = %ld", 
                dwRetCode);
            //EapolLogErrorString( ROUTERLOG_PPP_CANT_LOAD_DLL,1,
                               //&pEapDllExpandedPath,dwRetCode, 1);
            break;
        }

        g_pEapTable[dwKeyIndex].hInstance = hInstance;

        g_dwNumEapProtocols++;

        pRasEapGetInfo = GetProcAddress (hInstance, "RasEapGetInfo");

        if (pRasEapGetInfo == (FARPROC)NULL)
        {
            dwRetCode = GetLastError();

            TRACE1 (EAP,"ElLoadEapDlls: GetProcAddress failed with error = %ld", 
                dwRetCode);
            //EapolLogErrorString( ROUTERLOG_PPPCP_DLL_ERROR, 1,
                               //&pEapDllExpandedPath, dwRetCode, 1);
            break;
        }

        g_pEapTable[dwKeyIndex].RasEapInfo.dwSizeInBytes = 
                                                    sizeof(PPP_EAP_INFO);

        dwRetCode = (DWORD) (*pRasEapGetInfo) (dwEapTypeId,
                                        &(g_pEapTable[dwKeyIndex].RasEapInfo));

        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAP,"ElLoadEapDlls: pRasEapGetInfo failed with error = %ld", 
                dwRetCode);
            //EapolLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                              //&pEapDllExpandedPath, dwRetCode, 1);
            break;
        }

        if (g_pEapTable[dwKeyIndex].RasEapInfo.RasEapInitialize != NULL)
        {
            dwRetCode = g_pEapTable[dwKeyIndex].RasEapInfo.RasEapInitialize (
                            TRUE);

            if (dwRetCode != NO_ERROR)
            {
                TRACE1 (EAP,"ElLoadEapDlls: RasEapInitialize failed with error = %ld", 
                dwRetCode);
                //EapolLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                                  //&pEapDllExpandedPath, dwRetCode, 1);
                break;
            }
        }

        TRACE1 (EAP,"ElLoadEapDlls: Successfully loaded EAP DLL type id = %d", 
                dwEapTypeId );

        } while (FALSE);

        if (hKeyEapDll != NULL)
        {
            RegCloseKey (hKeyEapDll);
            hKeyEapDll = (HKEY)NULL;
        }

        if (pEapDllExpandedPath != NULL)
        {
            FREE( pEapDllExpandedPath );
            pEapDllExpandedPath = NULL;
        }

        if (pEapDllPath != NULL)
        {
            FREE (pEapDllPath);
            pEapDllPath = (LPWSTR)NULL;
        }


        // Reset error code and continue loading next EAP Dll
        dwRetCode = NO_ERROR;

    }

    if (hKeyEap != (HKEY)NULL)
    {
        RegCloseKey (hKeyEap);
    }

    if (hKeyEapDll == (HKEY)NULL)
    {
        RegCloseKey (hKeyEapDll);
    }

    if (pEapDllPath != (LPWSTR)NULL)
    {
        FREE (pEapDllPath);
    }

    if (pEapDllExpandedPath != NULL)
    {
        FREE (pEapDllExpandedPath);
    }

    return dwRetCode;
}


//
// ElEapInit
//
// Description: 
// Function called to initialize/uninitialize EAP module.
// In the former case, fInitialize will be TRUE; in the latter case, 
// it will be FALSE.
//
// Arguments:
//      fInitialize - TRUE - initialize EAP
//                    FALSE - uninitialize EAP
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapInit (
    IN  BOOL        fInitialize
    )
{
    DWORD   dwRetCode = NO_ERROR;

    // Initialize EAP globals 
            
    g_dwNumEapProtocols = 0;
    g_pEapTable = NULL;
    g_dwGuid = 1;

    if (fInitialize)
    {
        if ((dwRetCode = ElLoadEapDlls()) != NO_ERROR)
        {
            if (g_pEapTable != NULL)
            {
                FREE (g_pEapTable);

                g_pEapTable = NULL;
            }

            g_dwNumEapProtocols = 0;

            return dwRetCode;
        }
    }
    else
    {
        if (g_pEapTable != NULL)
        {
            DWORD dwIndex;

            //
            // Unload loaded DLLs
            //

            for (dwIndex = 0; dwIndex < g_dwNumEapProtocols; dwIndex++)
            {
                if (g_pEapTable[dwIndex].hInstance != NULL)
                {
                    if (g_pEapTable[dwIndex].RasEapInfo.RasEapInitialize !=
                         NULL)
                    {
                        dwRetCode = g_pEapTable[dwIndex].RasEapInfo.
                                        RasEapInitialize (
                                            FALSE);

                        if (dwRetCode != NO_ERROR)
                        {
                            TRACE2 (EAP,
                                "RasEapInitialize(%d) failed and returned %d",
                                g_pEapTable[dwIndex].RasEapInfo.dwEapTypeId,
                                dwRetCode);
                        }
                    }

                    FreeLibrary (g_pEapTable[dwIndex].hInstance);
                    g_pEapTable[dwIndex].hInstance = NULL;
                }
            }

            FREE(g_pEapTable);

            g_pEapTable = NULL;
        }

        g_dwNumEapProtocols    = 0;
    }

    return (NO_ERROR);
}


//
// EapBegin
//
// Description: 
//
// Function called by the EAPOL engine to initialize an EAP session for
// a particular port.
//
// Arguments:
//      pPCB - Pointer to PCB for port on which EAP is to be initialized
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapBegin (
        IN  EAPOL_PCB       *pPCB
    )
{
    DWORD        dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapBegin entered");

    if (pPCB->dwEapTypeToBeUsed != -1)
    {
        //
        // First check if we support this EAP type
        //

        if (ElGetEapTypeIndex((BYTE)(pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE0 (EAP, "ElEapBegin: EAPType not supported");
            return (ERROR_NOT_SUPPORTED);
        }
    }

    pPCB->fEapInitialized = TRUE;

    TRACE0 (EAP,"ElEapBegin done");

    return (NO_ERROR);
}


//
// ElEapEnd
//
// Description: 
//
// Function called to end the Eap session initiated by an ElEapBegin.
// Called when port goes down
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which EAP session is to be
//      shut-down.
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapEnd (
    IN EAPOL_PCB    *pPCB
    )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapEnd entered");

    if ((pPCB == NULL) || (!(pPCB->fEapInitialized)))
    {
        return( NO_ERROR );
    }

    if ((dwRetCode = ElEapDllEnd (pPCB)) != NO_ERROR)
    {
        TRACE1 (EAP, "ElEapEnd: Error in ElEapDllEnd %ld", dwRetCode);
    }

    if (pPCB->EapUIData.pEapUIData != NULL)
    {
        FREE( pPCB->EapUIData.pEapUIData );
        pPCB->EapUIData.pEapUIData = NULL;
    }

    pPCB->fEapInitialized = FALSE;

    return (NO_ERROR);
}

//
// ElEapExtractMessage
//
// Description: 
//
// If there is any message in the Request/Notification packet, then
// save the string in pResult->pszReplyMessage
//
// Arguments:
//      pReceiveBuf - Pointer to EAP packet received
//      pResult - Pointer to result structure
//
// Return values:
//

VOID
ElEapExtractMessage (
    IN  PPP_EAP_PACKET  *pReceiveBuf,
    OUT ELEAP_RESULT    *pResult 
    )
{
    DWORD   dwNumBytes = 0;
    CHAR*   pszReplyMessage  = NULL;
    WORD    cbPacket;

    do 
    {

        cbPacket = WireToHostFormat16 (pReceiveBuf->Length);

        if (PPP_EAP_PACKET_HDR_LEN + 1 >= cbPacket)
        {
            TRACE2 (EAP, "ElEapExtractMessage: Packet length %ld less than minimum %ld",
                    cbPacket, PPP_EAP_PACKET_HDR_LEN+1);
            break;
        }

        dwNumBytes = cbPacket - PPP_EAP_PACKET_HDR_LEN - 1;

        //
        // One more for the terminating NULL.
        //

        pszReplyMessage = (CHAR *) MALLOC (dwNumBytes+1);

        if (pszReplyMessage == NULL)
        {
            TRACE0 (EAP, "ElEapExtractMessage: MALLOC failed. Cannot extract server's message." );
            break;
        }

        CopyMemory (pszReplyMessage, pReceiveBuf->Data + 1, dwNumBytes);

        pszReplyMessage[dwNumBytes] = '\0';

        // FREE( pResult->pszReplyMessage );

        pResult->pszReplyMessage = pszReplyMessage;

        pszReplyMessage = NULL;

    } while (FALSE);

    return;
}


//
// ElParseIdentityString
//
// Description: 
// Parse the identity string
//
// Arguments:
//      pReceiveBuf - Pointer to EAP packet received
//      pPCB - Pointer to PCB for port on which data is being processed
//
// Return values:
//

DWORD
ElParseIdentityString (
    IN      PPP_EAP_PACKET  *pReceiveBuf,
    IN OUT  EAPOL_PCB       *pPCB 
    )
{
    DWORD   dwNumBytes = 0;
    WORD    cbPacket = 0;
    DWORD   dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
    DWORD   dwEapolEnabled = DEFAULT_EAPOL_STATE;
    CHAR    czDummyBuffer[256];
    CHAR    *pszLocalIdString = NULL;
    CHAR    *pszDisplayString = NULL;
    CHAR    *pszDisplayStringEnd = NULL;
    CHAR    *pszTupleValueStart = NULL;
    CHAR    *pszTupleTypeStart = NULL;
    CHAR    *pszTupleTypeEnd = NULL;
    CHAR    *pszTupleValueEnd = NULL;
    CHAR    *pszNetworkId = NULL;
    CHAR    *pszNASId = NULL;
    CHAR    *pszPortId = NULL;
    CHAR    *pczNetworkId = "NetworkId";
    CHAR    *pczNASId = "NASId";
    CHAR    *pczPortId = "PortId";
    CHAR    *pszNLAInformation = NULL;
    DWORD   dwNLAInformationLen = 0;
    WCHAR   *pwszNLAInformation = NULL;
    CHAR    *pszGUID = NULL;
    LOCATION_802_1X location;
    DWORD   dwRetCode = NO_ERROR;

    do 
    {

        cbPacket = WireToHostFormat16 (pReceiveBuf->Length);

        if (PPP_EAP_PACKET_HDR_LEN + 1 >= cbPacket)
        {
            TRACE2 (EAP, "ElParseIdentityString: Packet length %ld less than minimum %ld",
                    cbPacket, PPP_EAP_PACKET_HDR_LEN+1);
            break;
        }

        dwNumBytes = cbPacket - PPP_EAP_PACKET_HDR_LEN - 1;

        pszLocalIdString = MALLOC (dwNumBytes + 2);
        if (pszLocalIdString == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszLocalIdString");
            break;
        }

        memcpy (pszLocalIdString, pReceiveBuf->Data + 1, dwNumBytes);
        pszLocalIdString[dwNumBytes] = '\0';

        pszDisplayStringEnd = strchr (pszLocalIdString, '\0');

        if (pszDisplayStringEnd == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (EAP, "ElParseIdentityString: Identity string does not contain mandatory NULL character");
            break;
        }

        pszDisplayString = MALLOC (pszDisplayStringEnd - pszLocalIdString + 1);
        if (pszDisplayString == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszDisplayString");
            break;
        }


        strcpy (pszDisplayString, pReceiveBuf->Data + 1);

        TRACE1 (EAP, "ElParseIdentityString: DisplayString = %s",
                pszDisplayString);
        TRACE1 (EAP, "ElParseIdentityString: LocalIdString = %s",
                pszDisplayStringEnd+1);
        TRACE1 (EAP, "ElParseIdentityString: LocalIdString Length = %ld",
                dwNumBytes);

        // If only Display String is received, bail out
        if (pszDisplayStringEnd == (pszLocalIdString+dwNumBytes))
        {
            // ISSUE
            // Just for test version

            // dwRetCode = ERROR_INVALID_DATA;

            dwRetCode = NO_ERROR;

            TRACE0 (EAP, "ElParseIdentityString: Identity string does not contain tuples");

            if (pPCB->pszSSID  != NULL)
            {
                // Verify if NetworkId has changed i.e. we are on a new network
    
                if (strcmp (pPCB->pszSSID, pszDisplayString))
                {
                    pPCB->fAuthenticationOnNewNetwork = TRUE;
     
                    TRACE2 (EAP, "ElParseIdentityString: SSIDs are different, old= %s, new= %s",
                            pPCB->pszSSID, pszDisplayString);
                }
    
                FREE (pPCB->pszSSID);
                pPCB->pszSSID = NULL;
            }
    
            // New instance of SSID will be freed either on receipt of next SSID
            // or user logoff
    
            pPCB->pszSSID = (CHAR *) MALLOC (strlen(pszDisplayString) + 1);
    
            if (pPCB->pszSSID == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (EAP, "ElParseIdentityString: MALLOC failed. Cannot extract SSID" );
                break;
            }

            strcpy (pPCB->pszSSID, pszDisplayString);
    
            TRACE1 (EAP, "ElParseIdentityString: Got SSID %s", pPCB->pszSSID);
    
            break;
        }

        pszTupleTypeStart = pszDisplayStringEnd + 1;

        while (TRUE)
        {
            pszTupleTypeEnd = strchr (pszTupleTypeStart, '=');

            if (!(_strnicmp (pszTupleTypeStart, pczNetworkId, strlen (pczNetworkId))))
            {
                pszTupleValueStart = pszTupleTypeEnd + 1;
                pszTupleValueEnd = strchr (pszTupleValueStart, ',');
                if (pszTupleValueEnd == NULL)
                {
                    // End-of-string
                    pszTupleValueEnd = &pszLocalIdString[dwNumBytes];
                }
                TRACE1 (ANY, "ElParseIdentityString: NetworkID Size = %ld",
                        pszTupleValueEnd - pszTupleValueStart + 1);
                pszNetworkId = MALLOC (pszTupleValueEnd - pszTupleValueStart + 1);
                if (pszNetworkId == NULL)
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszNetworkId");
                    break;
                }
                memcpy (pszNetworkId, pszTupleValueStart, pszTupleValueEnd - pszTupleValueStart);
                pszNetworkId[pszTupleValueEnd - pszTupleValueStart] = '\0';

                TRACE1 (EAP, "Got NetworkId = %s", pszNetworkId);
            }
            else
            {
                if (!(_strnicmp (pszTupleTypeStart, pczNASId, strlen (pczNASId))))
                {
                    pszTupleValueStart = pszTupleTypeEnd + 1;
                    pszTupleValueEnd = strchr (pszTupleValueStart, ',');
                    if (pszTupleValueEnd == NULL)
                    {
                        // End-of-string
                        pszTupleValueEnd = &pszLocalIdString[dwNumBytes];
                    }
                    pszNASId = MALLOC (pszTupleValueEnd - pszTupleValueStart + 1);
                    if (pszNASId == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszNASId");
                        break;
                    }
                    memcpy (pszNASId, pszTupleValueStart, pszTupleValueEnd - pszTupleValueStart);
                    pszNASId[pszTupleValueEnd - pszTupleValueStart] = '\0';
                    TRACE1 (EAP, "Got NASId = %s", pszNASId);
                }
                else
                {
                    if (!(_strnicmp (pszTupleTypeStart, pczPortId, strlen (pczPortId))))
                    {
                        pszTupleValueStart = pszTupleTypeEnd + 1;
                        pszTupleValueEnd = strchr (pszTupleValueStart, ',');
                        if (pszTupleValueEnd == NULL)
                        {
                            // End-of-string
                            pszTupleValueEnd = &pszLocalIdString[dwNumBytes];
                        }

                        TRACE1 (EAP, "ElParseIdentityString: For PortId, length = %ld",
                                pszTupleValueEnd - pszTupleValueStart);
                        pszPortId = MALLOC (pszTupleValueEnd - pszTupleValueStart + 1);
                        if (pszPortId == NULL)
                        {
                            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszPortId");
                            break;
                        }
                        memcpy (pszPortId, pszTupleValueStart, pszTupleValueEnd - pszTupleValueStart);
                        pszPortId[pszTupleValueEnd - pszTupleValueStart] = '\0';
                        TRACE1 (EAP, "Got PortId = %s", pszPortId);
                    }
                    else
                    {
                        dwRetCode = ERROR_INVALID_DATA;
                        TRACE0 (EAP, "ElParseIdentityString: Invalid tuple type");
                        break;
                    }
                }
            }

            if (*pszTupleValueEnd == '\0')
            {
                TRACE0 (EAP, "ElParseIdentityString: End of String reached");
                break;
            }
            else
            {
                // Position pointer beyond ','
                pszTupleTypeStart = pszTupleValueEnd+1;

            }
        }

        TRACE0 (EAP, "ElParseIdentityString: Out of while loop");

        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        TRACE0 (EAP, "ElParseIdentityString: Out of while loop: NO ERROR");

        // Mandatory tuples
        
        if (pszNetworkId == NULL)
        {
            dwRetCode = ERROR_INVALID_DATA;
            TRACE0 (EAP, "ElParseIdentityString: Invalid NetworkId = NULL");
            break;
        }

            
        pPCB->fAuthenticationOnNewNetwork = FALSE;

        // Free previous instance of SSID if any

        if (pPCB->pszSSID  != NULL)
        {
            // Verify if NetworkId has changed i.e. we are on a new network

            if (strcmp (pPCB->pszSSID, pszNetworkId))
            {
                pPCB->fAuthenticationOnNewNetwork = TRUE;
    
                TRACE2 (EAP, "ElParseIdentityString: SSIDs are different, old= %s, new= %s",
                        pPCB->pszSSID, pszNetworkId);
            }

            FREE (pPCB->pszSSID);
            pPCB->pszSSID = NULL;
        }

        // New instance of SSID will be freed either on receipt of next SSID
        // or user logoff

        pPCB->pszSSID = (CHAR *) MALLOC (strlen(pszNetworkId) + 1);

        if (pPCB->pszSSID == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed. Cannot extract SSID" );
            break;
        }

        strcpy (pPCB->pszSSID, pszNetworkId);

        TRACE1 (EAP, "ElParseIdentityString: Got SSID %s", pPCB->pszSSID);


        //
        // Retrieve the current interface params
        //

        if ((dwRetCode = ElGetInterfaceParams (
                                pPCB->pszDeviceGUID,
                                &dwEapTypeToBeUsed,
                                czDummyBuffer,
                                &dwEapolEnabled
                                )) != NO_ERROR)
        {
            TRACE1 (PORT, "ElParseIdentityString: ElGetInterfaceParams failed with error %ld",
                    dwRetCode);

            dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
            dwEapolEnabled = DEFAULT_EAPOL_STATE;

            dwRetCode = NO_ERROR;
        }

        //
        // Store the SSID alongwith the retrieved params
        //

        if ((dwRetCode = ElSetInterfaceParams (
                                pPCB->pszDeviceGUID,
                                &dwEapTypeToBeUsed,
                                pPCB->pszSSID,
                                &dwEapolEnabled
                                )) != NO_ERROR)
        {
            TRACE1 (PORT, "ElParseIdentityString: ElSetInterfaceParams failed with error %ld",
                    dwRetCode);
    
            break;
        }

        //
        // Send type=value tuple string to NLA for processing
        //

        pszNLAInformation = pszDisplayStringEnd + 1;

        // 3 extra for '{','}', and '\0'
        pszGUID = MALLOC (strlen (pPCB->pszDeviceGUID) + 3);
        if (pszGUID == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pszGUID" );
            break;
        }


        pszGUID[0] = '{';
        strcpy (&pszGUID[1], pPCB->pszDeviceGUID);
        pszGUID[strlen (pPCB->pszDeviceGUID) + 1] = '}';
        pszGUID[strlen (pPCB->pszDeviceGUID) + 2] = '\0';

        RtlZeroMemory(&location, sizeof(location));
        strcpy(location.adapterName, pszGUID);

        dwNLAInformationLen = strlen (pszNLAInformation);

        pwszNLAInformation = MALLOC ((dwNLAInformationLen+2) * sizeof(WCHAR));

        if (pwszNLAInformation == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElParseIdentityString: MALLOC failed for pwszNLAInformation");
            break;
        }
        

        if (dwNLAInformationLen > 0)
        {
            if (0 == MultiByteToWideChar (
                    CP_ACP,
                    0,
                    pszNLAInformation,
                    -1,
                    pwszNLAInformation, 
                    dwNLAInformationLen + 2))
            {
                dwRetCode = GetLastError();
    
                TRACE2 (EAP,"ElParseIdentityString: MultiByteToWideChar(%s) failed for pszNLAInformation with error (%ld)",
                                            pszNLAInformation,
                                            dwRetCode);
                break;
            }
        }
        else
        {
            pwszNLAInformation[0] = L'\0';
        }

        // strcpy (location.information, pszNLAInformation);

        wcscpy (location.information, pwszNLAInformation);


        TRACE2 (EAP, "ElParseIdentityString: Calling NLARegister_802_1X with params %s and %ws",
                pszGUID, pwszNLAInformation);

        ElNLARegister_802_1X(&location);

        TRACE0 (EAP, "ElParseIdentityString: Returned after calling NLARegister_802_1X");

    } while (FALSE);

    if (pszLocalIdString != NULL)
    {
        FREE (pszLocalIdString);
    }

    if (pszDisplayString != NULL)
    {
        FREE (pszDisplayString);
    }

    if (pszNetworkId != NULL)
    {
        FREE (pszNetworkId);
    }

    if (pszNASId != NULL)
    {
        FREE (pszNASId);
    }

    if (pszPortId != NULL)
    {
        FREE (pszPortId);
    }

    if (pszGUID != NULL)
    {
        FREE (pszGUID);
    }

    if (pwszNLAInformation != NULL)
    {
        FREE (pwszNLAInformation);
    }

    return dwRetCode;
}


//
// ElEapExtractSSID
//
// Description: 
// If there is a SSID in the Request/Id packet, then 
// save the string in pPCB->pszSSID
//
// Arguments:
//      pReceiveBuf - Pointer to EAP packet received
//      pPCB - Pointer to PCB for port on which data is being processed
//
// Return values:
//

DWORD
ElEapExtractSSID (
    IN      PPP_EAP_PACKET  *pReceiveBuf,
    IN OUT  EAPOL_PCB       *pPCB 
    )
{
    DWORD   dwNumBytes = 0;
    WORD    cbPacket;
    DWORD   dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
    DWORD   dwEapolEnabled = DEFAULT_EAPOL_STATE;
    CHAR    czDummyBuffer[256];
    DWORD   dwRetCode = NO_ERROR;

    do 
    {

        cbPacket = WireToHostFormat16 (pReceiveBuf->Length);

        if (PPP_EAP_PACKET_HDR_LEN + 1 >= cbPacket)
        {
            TRACE2 (EAP, "ElEapExtractSSID: Packet length %ld less than minimum %ld",
                    cbPacket, PPP_EAP_PACKET_HDR_LEN+1);
            break;
        }

        dwNumBytes = cbPacket - PPP_EAP_PACKET_HDR_LEN - 1;

        //
        // One more for the terminating NULL.
        //

        // Free previous instance of SSID if any
        if (pPCB->pszSSID  != NULL)
        {
            FREE (pPCB->pszSSID);
            pPCB->pszSSID = NULL;
        }

        // New instance of SSID will be freed either on receipt of next SSID
        // or user logoff

        EAPOL_DUMPBA (pReceiveBuf->Data + 1, dwNumBytes);

        pPCB->pszSSID = (CHAR *) MALLOC (dwNumBytes+1);

        if (pPCB->pszSSID == NULL)
        {
            TRACE0 (EAP, "ElEapExtractSSID: MALLOC failed. Cannot extract SSID" );
            break;
        }

        CopyMemory (pPCB->pszSSID, pReceiveBuf->Data + 1,  dwNumBytes);

        pPCB->pszSSID[dwNumBytes] = '\0';

        TRACE1 (EAP, "ElEapExtractSSID: Got SSID %s", pPCB->pszSSID);

        //
        // Retrieve the current interface params
        //

        if ((dwRetCode = ElGetInterfaceParams (
                                pPCB->pszDeviceGUID,
                                &dwEapTypeToBeUsed,
                                czDummyBuffer,
                                &dwEapolEnabled
                                )) != NO_ERROR)
        {
            TRACE1 (PORT, "ElEapExtractSSID: ElGetInterfaceParams failed with error %ld",
                    dwRetCode);

            dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
            dwEapolEnabled = DEFAULT_EAPOL_STATE;

            if (dwEapolEnabled)
            {
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
    
        }

        //
        // Store the SSID alongwith the retrieved params
        //

        if ((dwRetCode = ElSetInterfaceParams (
                                pPCB->pszDeviceGUID,
                                &dwEapTypeToBeUsed,
                                pPCB->pszSSID,
                                &dwEapolEnabled
                                )) != NO_ERROR)
        {
            TRACE1 (PORT, "ElEapExtractSSID: ElSetInterfaceParams failed with error %ld",
                    dwRetCode);
    
            break;
        }

    } while (FALSE);

    return dwRetCode;
}


//
// ElEapMakeMessage
//
// Description: 
//
// Function called to process a received EAP packet and/or to send 
// out an EAP packet.
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapMakeMessage (
    IN  EAPOL_PCB           *pPCB,
    IN  PPP_EAP_PACKET      *pReceiveBuf,
    IN  OUT PPP_EAP_PACKET  *pSendBuf,
    IN  DWORD               dwSizeOfSendBuf,
    OUT ELEAP_RESULT        *pResult
    )
{
    DWORD       dwIdentityLength = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElEapMakeMessage entered");

    if ((pReceiveBuf != NULL) && (pReceiveBuf->Code == EAPCODE_Request))
    {
        //
        // Always respond to notitication request, with a notification response
        //

        if (pReceiveBuf->Data[0] == EAPTYPE_Notification) 
        {
            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            HostToWireFormat16 (PPP_EAP_PACKET_HDR_LEN + 1, pSendBuf->Length);

            pSendBuf->Data[0] = EAPTYPE_Notification;   

            pResult->Action = ELEAP_Send;

            // Indicate to EAPOL what is length of the EAP packet
            pResult->wSizeOfEapPkt = PPP_EAP_PACKET_HDR_LEN + 1;

            // Extract the notification message from server and save
            // it in the result struct for display to the user
            ElEapExtractMessage (pReceiveBuf, pResult);

            return (NO_ERROR);
        }

        //
        // Always respond to Identity request, with an Identity response
        //

        if (pReceiveBuf->Data[0] == EAPTYPE_Identity)
        {
            // Extract SSID out of the body of the received packet
            // and save it in the SSID field of the PCB
            // Also, save the SSID received as the last used SSID

#if 0
            if ((dwRetCode = ElEapExtractSSID (
                                    pReceiveBuf, 
                                    pPCB)) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapMakeMessage: Error in ElEapExtractSSID = %ld",
                        dwRetCode);
                return dwRetCode;
            }
#else
            if ((dwRetCode = ElParseIdentityString (
                                    pReceiveBuf,
                                    pPCB)) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapMakeMessage: Error in ElParseIdentityString = %ld",
                        dwRetCode);
                return dwRetCode;
            }
#endif

#if DRAFT7
            if (g_dwMachineAuthEnabled)
            {
#endif

            if ((dwRetCode = ElGetIdentity (
                                pPCB)) != NO_ERROR)
            {
                TRACE1 (EAP, "ElEapMakeMessage: Error in ElGetIdentity %ld",
                        dwRetCode);
                return dwRetCode;
            }

#if DRAFT7
            }
            else
            {

            // Get user's identity if it has not been obtained till now
            if (g_fUserLoggedOn)
            {
                if (!(pPCB->fGotUserIdentity))
                {

                    // ISSUE: Hardcoding for now
                    // Needs to be solved

                    if (pPCB->dwEapTypeToBeUsed == EAP_TYPE_MD5)
                    {
                        // EAP-MD5CHAP
                        if ((dwRetCode = ElGetUserNamePassword (
                                            pPCB)) != NO_ERROR)
                        {
                            TRACE1 (EAP, "ElEapMakeMessage: Error in ElGetUserNamePassword %ld",
                                    dwRetCode);
                        }
                    }
                    else
                    {
                        // All other EAP Types
                        if ((dwRetCode = ElGetUserIdentity (
                                            pPCB)) != NO_ERROR)
                        {
                            TRACE1 (EAP, "ElEapMakeMessage: Error in ElGetUserIdentity %ld",
                                    dwRetCode);
                        }
                    }
                }
            }

            // If user is not logged on or error in obtaining user
            // credentials, send no user identity
            // The AP/switch will respond with EAP_Success or EAP_Failure
            // depending on unauthorized access setting
            if ((!g_fUserLoggedOn) || (dwRetCode != NO_ERROR))
            {
                if (pPCB->pszIdentity != NULL)
                {
                    FREE (pPCB->pszIdentity);
                    pPCB->pszIdentity = NULL;
                }
                dwRetCode = NO_ERROR;
            }

            } // g_dwMachineAuthEnabled 
#endif


            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            if (pPCB->pszIdentity != NULL)
            {
                dwIdentityLength = strlen (pPCB->pszIdentity);
            }
            else
            {
                dwIdentityLength = 0;
            }

            HostToWireFormat16 (
                (WORD)(PPP_EAP_PACKET_HDR_LEN+1+dwIdentityLength),
                pSendBuf->Length );

            strncpy ((CHAR *)pSendBuf->Data+1, (CHAR *)pPCB->pszIdentity, 
                    dwIdentityLength);

            TRACE1 (EAPOL, "Identity sent out = %s", pPCB->pszIdentity);

            pSendBuf->Data[0] = EAPTYPE_Identity;

            pResult->Action = ELEAP_Send;

            // Indicate to EAPOL what is length of the EAP packet
            pResult->wSizeOfEapPkt = (WORD)(PPP_EAP_PACKET_HDR_LEN+
                                        1+dwIdentityLength);

            return( NO_ERROR );
        }
    }

    return
        ElMakeSupplicantMessage (
                pPCB, pReceiveBuf, pSendBuf, dwSizeOfSendBuf, pResult);
}


//
// ElMakeSupplicantMessage
//
// Description: 
//
// EAP Supplicant engine. Can be part of ElEapMakeMessage, but separated for
// readability
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElMakeSupplicantMessage (
    IN      EAPOL_PCB       *pPCB,
    IN      PPP_EAP_PACKET* pReceiveBuf,
    IN  OUT PPP_EAP_PACKET* pSendBuf,
    IN      DWORD           dwSizeOfSendBuf,
    IN  OUT ELEAP_RESULT*   pResult
    )
{
    DWORD   dwEapIndex;
    DWORD   dwRetCode = NO_ERROR;

    TRACE0 (EAP,"ElMakeSupplicantMessage entered");

    switch (pPCB->EapState)
    {
    case EAPSTATE_Initial:

        TRACE0 (EAP,"EAPSTATE_Initial");

        if (pReceiveBuf == NULL)
        {
            //
            // Do nothing. Wait for request from authenticator
            //

            TRACE0 (EAP, "ElMakeSupplicantMessage: Received NULL EAP pkt, No Action");
            pResult->Action = ELEAP_NoAction;

            break;
        }
        else
        {
            if (pReceiveBuf->Code != EAPCODE_Request)
            {
                //
                // We are authenticatee side so drop everything other than
                // requests, since we do not send requests
                //

                pResult->Action = ELEAP_NoAction;

                break;
            }

            //
            // We got a packet, see if we support this EAP type, also that  
            // we are authorized to use it
            //

            dwEapIndex = ElGetEapTypeIndex (pReceiveBuf->Data[0]);

            if ((dwEapIndex == -1) ||
                ((pPCB->dwEapTypeToBeUsed != -1) &&
                  (dwEapIndex != ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed))))
            {
                //
                // We do not support this type or we are not authorized to use
                // it so we NAK with a type we support
                //

                pSendBuf->Code  = EAPCODE_Response;
                pSendBuf->Id    = pReceiveBuf->Id;

                HostToWireFormat16 (PPP_EAP_PACKET_HDR_LEN + 2, 
                        pSendBuf->Length);

                pSendBuf->Data[0] = EAPTYPE_Nak;

                if (pPCB->dwEapTypeToBeUsed != -1)
                {
                    pSendBuf->Data[1] = (BYTE)pPCB->dwEapTypeToBeUsed;
                }
                else
                {
                    pSendBuf->Data[1] = 
                                (BYTE)g_pEapTable[0].RasEapInfo.dwEapTypeId;
                }

                pResult->Action = ELEAP_Send;

                break;
            }
            else
            {
                //
                // The EAP type is acceptable to us so we begin authentication
                //

                if ((dwRetCode = ElEapDllBegin (pPCB, dwEapIndex)) != NO_ERROR)
                {
                    break;
                }

                pPCB->EapState = EAPSTATE_Working;

                //
                // Fall thru
                //
            }
        }

    case EAPSTATE_Working:

        TRACE0 (EAP,"EAPSTATE_Working");

        if (pReceiveBuf != NULL)
        {
            if ((pReceiveBuf->Code != EAPCODE_Request) &&
                 (pReceiveBuf->Code != EAPCODE_Success) &&
                 (pReceiveBuf->Code != EAPCODE_Failure))
            {
                //
                // We are supplicant side so drop everything other than
                // request/success/failure 
                //

                TRACE0 (EAP,"ElMakeSupplicantMessage: Dropping invlid packet not request/success/failure");

                pResult->Action = ELEAP_NoAction;

                break;
            }

            if ((pReceiveBuf->Code == EAPCODE_Request) &&
                 (pReceiveBuf->Data[0] != 
                     g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId))
            {
                TRACE0 (EAP,"ElMakeSupplicantMessage: Dropping invalid request packet with unknown Id");

                pResult->Action = ELEAP_NoAction;

                break;
            }
        }

        dwRetCode = ElEapDllWork (pPCB, 
                                pReceiveBuf, 
                                pSendBuf, 
                                dwSizeOfSendBuf, 
                                pResult
                                );

        break;

    default:

        TRACE0 (EAP, "ElMakeSupplicantMessage: Invalid EAP State");

        break;
    }

    return dwRetCode;
}


//
//
// ElEapDllBegin
//
// Description: 
//
// Function called to initiate an EAP session for a certain EAP type
//
// Arguments:
//      pPCB - Pointer to PCB for the port in context
//      dwEapIndex - EAP type for which a session has to be started
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
//

DWORD
ElEapDllBegin (
    IN EAPOL_PCB    *pPCB,
    IN DWORD        dwEapIndex
    )
{
    PPP_EAP_INPUT   PppEapInput;
    WCHAR           *pwszIdentity = NULL;
    DWORD           dwIdentityLength = 0;
    WCHAR           *pwszPassword = NULL;
    DWORD           dwPasswordLength = 0;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAP,"ElEapDllBegin called for EAP Type %d",  
            g_pEapTable[dwEapIndex].RasEapInfo.dwEapTypeId);

    do 
    {

        // Format the identity string correctly.
        // For EAP-TLS, it will be the identity on the chosen certificate
        // For EAP-CHAP, it will be domain\username

        if (pPCB->pszIdentity != NULL)
        {
            dwIdentityLength = strlen (pPCB->pszIdentity);
        }
        else
        {
            dwIdentityLength = 0;
        }

        pwszIdentity = MALLOC ((dwIdentityLength+2) * sizeof(WCHAR));

        if (pwszIdentity == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElEapDllBegin: MALLOC failed for pwszIdentity");
            break;
        }
        
        TRACE0 (EAP,"Before MALLOC");

        if (pPCB->pszPassword != NULL)
        {
            dwPasswordLength = strlen (pPCB->pszPassword);
        }
        else
        {
            dwPasswordLength = 0;
        }

        pwszPassword = 
            MALLOC ((dwPasswordLength + 2) * sizeof(WCHAR));

        TRACE0 (EAP,"After MALLOC");

        if (pwszPassword == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (EAP, "ElEapDllBegin: MALLOC failed for pwszPassword");
            break;
        }
        
        if (dwIdentityLength > 0)
        {
            if (0 == MultiByteToWideChar (
                    CP_ACP,
                    0,
                    pPCB->pszIdentity,
                    -1,
                    pwszIdentity, 
                    dwIdentityLength+2))
            {
                dwRetCode = GetLastError();
    
                TRACE2 (EAP,"MultiByteToWideChar(%s) failed: %d",
                                            pPCB->pszIdentity,
                                            dwRetCode);
                break;
            }
        }
        else
        {
            pwszIdentity[0] = L'\0';
        }
    
        ZeroMemory (&PppEapInput, sizeof (PppEapInput));
    
        PppEapInput.dwSizeInBytes = sizeof (PPP_EAP_INPUT);
    
        if (g_dwMachineAuthEnabled)
        {
            // Set flag to indicate machine cert is to be picked up for machine
            // authentication
    
            if (pPCB->PreviousAuthenticationType == 
                                        EAPOL_MACHINE_AUTHENTICATION)
            {
                TRACE0 (EAP, "ElEapDllBegin: Going for machine authentication");
                PppEapInput.fFlags |= RAS_EAP_FLAG_MACHINE_AUTH;
            }
        }
    
        PppEapInput.fAuthenticator          = FALSE;    // Always supplicant
        PppEapInput.pwszIdentity            = pwszIdentity;
        PppEapInput.pwszPassword            = pwszPassword;
        PppEapInput.hTokenImpersonateUser   = pPCB->hUserToken;
        PppEapInput.fAuthenticationComplete = FALSE;
        PppEapInput.dwAuthResultCode        = NO_ERROR;
    
        if (pPCB->pCustomAuthConnData != NULL)
        {
            PppEapInput.pConnectionData =
                pPCB->pCustomAuthConnData->pbCustomAuthData;
            PppEapInput.dwSizeOfConnectionData =
                pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData;
        }
    
        if (pPCB->pCustomAuthUserData != NULL)
        {
            PppEapInput.pUserData =
                pPCB->pCustomAuthUserData->pbCustomAuthData;
            PppEapInput.dwSizeOfUserData =
                pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData;
        }
    
        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            PppEapInput.pDataFromInteractiveUI   = 
                                        pPCB->EapUIData.pEapUIData;
            PppEapInput.dwSizeOfDataFromInteractiveUI =
                                        pPCB->EapUIData.dwSizeOfEapUIData;
        }
    
        // Unhash password stored locally
        ElDecodePw (pPCB->pszPassword);
    
        if (dwPasswordLength > 0)
        {
            if ( 0 == MultiByteToWideChar (
                                CP_ACP,
                                0,
                                pPCB->pszPassword,
                                -1,
                                pwszPassword,
                                dwPasswordLength+2))
            {
                dwRetCode = GetLastError();
                     
                TRACE1 (EAP,"MultiByteToWideChar failed for password: %d",
                            dwRetCode);
                break;
            }
        }
        else
        {
            pwszPassword[0] = L'\0';
        }


        // Call the RasEapBegin API
    
        dwRetCode = g_pEapTable[dwEapIndex].RasEapInfo.RasEapBegin ( 
                                                    &pPCB->lpEapDllWorkBuffer,   
                                                    &PppEapInput);
    
        // Hash out password while storing locally
        ElEncodePw (pPCB->pszPassword);
        if (pwszPassword != NULL)
        {
            FREE (pwszPassword);
            pwszPassword = NULL;
        }
    
        if (dwRetCode == NO_ERROR)
        {
            pPCB->dwEapIndex = dwEapIndex;
        }
        else
        {
            TRACE1 (EAP, "ElEapDllBegin: RasEapBegin failed with error %ld",
                    dwRetCode);
            pPCB->dwEapIndex = (DWORD)-1;
        }
    
    }
    while (FALSE);

    if (pwszPassword != NULL)
    {
        FREE (pwszPassword);
    }

    if (pwszIdentity != NULL)
    {
        FREE (pwszIdentity);
    }

    return dwRetCode;
}


//
// ElEapDllEnd
//
// Description: 
//
// Function called to end an EAP session 
//
// Arguments:
//      pPCB - Pointer to the PCB for the port in context
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapDllEnd (
    EAPOL_PCB       *pPCB
    )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE1 (EAP, "ElEapDllEnd called for EAP Index %d", pPCB->dwEapIndex );

    if (pPCB->lpEapDllWorkBuffer != NULL)
    {
        if (pPCB->dwEapIndex != (DWORD)-1)
        {
            dwRetCode = g_pEapTable[pPCB->dwEapIndex].RasEapInfo.RasEapEnd (
                                                    pPCB->lpEapDllWorkBuffer);
        }

        pPCB->lpEapDllWorkBuffer = NULL;
    }

    pPCB->dwEapIndex = (DWORD)-1;
    pPCB->EapState = EAPSTATE_Initial;

    return dwRetCode;
}


//
// ElEapDllWork
//
// Description: 
//
// Function called to process an incoming packet or timeout etc
// The RasEapMakeMessage entrypoint in the appropriate EAP DLL is called 
// to process the packet.
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which data is being processed
//      pReceiveBuf - Pointer to EAP Packet that was received
//      pSendBuf - output: Pointer to buffer created to hold output EAP packet
//      dwSizeOfSendBuf - Number of bytes pSendBuf is allocated
//      pResult - output: result structure containing various results of EAP
//              processing
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElEapDllWork ( 
    IN      EAPOL_PCB           *pPCB,    
    IN      PPP_EAP_PACKET      *pReceiveBuf,
    IN OUT  PPP_EAP_PACKET      *pSendBuf,
    IN      DWORD               dwSizeOfSendBuf,
    IN OUT  ELEAP_RESULT        *pResult
    )
{
    PPP_EAP_OUTPUT  PppEapOutput;
    PPP_EAP_INPUT   PppEapInput;
    CHAR *          pChar = NULL;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAP, "ElEapDllWork called for EAP Type %d", 
            g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId);

    ZeroMemory (&PppEapOutput, sizeof (PppEapOutput));
    PppEapOutput.dwSizeInBytes = sizeof (PppEapOutput);

    ZeroMemory (&PppEapInput, sizeof (PppEapInput));
    PppEapInput.dwSizeInBytes = sizeof (PPP_EAP_INPUT);

    PppEapInput.fAuthenticator = FALSE; // We are always supplicant
    PppEapInput.hTokenImpersonateUser = pPCB->hUserToken;

    // Fill in data received via RasEapInvokeInteractiveUI
#if 0
    if (pInput != NULL)
    {
        PppEapInput.fAuthenticationComplete = pInput->fAuthenticationComplete;
        PppEapInput.dwAuthResultCode        = pInput->dwAuthResultCode;
        PppEapInput.fSuccessPacketReceived  = pInput->fSuccessPacketReceived;

        if (pInput->fEapUIDataReceived)
        {
            if (pInput->EapUIData.dwContextId != pPCB->dwUIInvocationId)
            {
                //
                // Ignore this data received
                //

                TRACE0 (EAP,"ElEapDllWork: Out of date data received from UI");

                return(NO_ERROR);
            }

            PppEapInput.fDataReceivedFromInteractiveUI = TRUE;

            PppEapInput.pDataFromInteractiveUI   = 
                                        pInput->EapUIData.pEapUIData;
            PppEapInput.dwSizeOfDataFromInteractiveUI =
                                        pInput->EapUIData.dwSizeOfEapUIData;

        }
    }
#endif

    if (pPCB->fEapUIDataReceived)
    {

#if 0
        if (pInput->EapUIData.dwContextId != pPCB->dwUIInvocationId)
        {
            // Ignore this data received

            TRACE0 (EAP,"ElEapDllWork: Out of date data received from UI");

            return(NO_ERROR);
        }
#endif

        PppEapInput.fDataReceivedFromInteractiveUI = TRUE;

        PppEapInput.pDataFromInteractiveUI   = 
                                    pPCB->EapUIData.pEapUIData;
        PppEapInput.dwSizeOfDataFromInteractiveUI =
                                    pPCB->EapUIData.dwSizeOfEapUIData;

        pPCB->fEapUIDataReceived = FALSE;

    }

    dwRetCode = g_pEapTable[pPCB->dwEapIndex].RasEapInfo.RasEapMakeMessage (
                                                pPCB->lpEapDllWorkBuffer,   
                                                (PPP_EAP_PACKET *)pReceiveBuf,
                                                (PPP_EAP_PACKET *)pSendBuf,
                                                dwSizeOfSendBuf,
                                                &PppEapOutput,
                                                &PppEapInput);

    // Free InvokeInteractive UI data since we no longer need it
    if (pPCB->EapUIData.pEapUIData != NULL)
    {
        FREE (pPCB->EapUIData.pEapUIData);
        pPCB->EapUIData.pEapUIData = NULL;
    }


    if (dwRetCode != NO_ERROR)
    {
        switch (dwRetCode)
        {
        case ERROR_PPP_INVALID_PACKET:

            TRACE0 (EAP,"Silently discarding invalid EAP packet");

            pResult->Action = ELEAP_NoAction;

            return (NO_ERROR);
        
        default:

            TRACE2 (EAP,"EapDLLMakeMessage for type %d returned %d",
                    g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId,
                    dwRetCode );
            break;
        }

        return dwRetCode;
    }

    switch (PppEapOutput.Action)
    {
    case EAPACTION_NoAction:

        pResult->Action = ELEAP_NoAction;
        TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_NoAction" );
        break;

    case EAPACTION_Send:

        pResult->Action = ELEAP_Send;
        TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_Send" );
        break;

    case EAPACTION_Done:
    case EAPACTION_SendAndDone:

        if (PppEapOutput.Action == EAPACTION_SendAndDone)
        {
            pResult->Action = ELEAP_SendAndDone;
            TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_SendAndDone" );
        }
        else
        {
            pResult->Action = ELEAP_Done;
            TRACE0 (EAP, "EAP Dll returned Action=EAPACTION_Done" );
        }

        // These are the attributes that are filled in by the EAP-DLL
        // e.g in EAP-TLS it will be MPPE Keys
        pResult->dwError         = PppEapOutput.dwAuthResultCode; 
        pResult->pUserAttributes = PppEapOutput.pUserAttributes;

        if (pPCB->pszIdentity != NULL)
        {
            strcpy (pResult->szUserName, pPCB->pszIdentity);
        }
        else
        {
            pResult->szUserName[0] = '\0';
        }

        break;

    case EAPACTION_SendWithTimeout:
    case EAPACTION_SendWithTimeoutInteractive:
    case EAPACTION_Authenticate:

        TRACE1 (EAP, "EAP Dll returned disallowed Action=%d",    
                                                    PppEapOutput.Action);
        break;

    default:

        TRACE1 (EAP, "EAP Dll returned unknown Action=%d", PppEapOutput.Action);
        break;
    }
    
    //
    // Check to see if EAP dll wants to bring up UI
    //

    if (PppEapOutput.fInvokeInteractiveUI)
    {
        if (PppEapOutput.pUIContextData != NULL)
        {
            pResult->InvokeEapUIData.dwSizeOfUIContextData =
                                            PppEapOutput.dwSizeOfUIContextData;

            // The context data memory is freed after the InvokeUI entrypoint
            // in the EAP DLL is called
            pResult->InvokeEapUIData.pbUIContextData 
                      = MALLOC (PppEapOutput.dwSizeOfUIContextData);

            if (pResult->InvokeEapUIData.pbUIContextData == NULL)
            {
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
        
            CopyMemory (pResult->InvokeEapUIData.pbUIContextData,
                        PppEapOutput.pUIContextData, 
                        pResult->InvokeEapUIData.dwSizeOfUIContextData);
        }
        else
        {
            pResult->InvokeEapUIData.pbUIContextData        = NULL;
            pResult->InvokeEapUIData.dwSizeOfUIContextData = 0;
        }

        pResult->fInvokeEapUI                = TRUE;
        pPCB->dwUIInvocationId             = InterlockedIncrement(&(g_dwGuid));
        pResult->InvokeEapUIData.dwContextId = pPCB->dwUIInvocationId;
        pResult->InvokeEapUIData.dwEapTypeId = 
                    g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId;

        TRACE0 (EAP, "EAP Dll wants to invoke interactive UI" );
    }

    pResult->dwEapTypeId      = pPCB->dwEapTypeToBeUsed;
    pResult->fSaveUserData    = PppEapOutput.fSaveUserData;
    pResult->pUserData        = PppEapOutput.pUserData;
    pResult->dwSizeOfUserData = PppEapOutput.dwSizeOfUserData;

    pResult->fSaveConnectionData    = PppEapOutput.fSaveConnectionData;
    pResult->SetCustomAuthData.pConnectionData =
                                    PppEapOutput.pConnectionData;
    pResult->SetCustomAuthData.dwSizeOfConnectionData =
                                    PppEapOutput.dwSizeOfConnectionData;

    TRACE2 (EAP,"ElEapDllWork finished for EAP Type %d with error %ld", 
            g_pEapTable[pPCB->dwEapIndex].RasEapInfo.dwEapTypeId,
            dwRetCode);
    return dwRetCode;
}


//
// ElGetEapIndex
//
// Description: 
//
// Function called to get the index into the global EAP dll table for the 
// specified EAP type
//
// Arguments:
//      dwEapTypeId - Index into the EAP table for the input EAP type
//                    e.g. TLS = 13, MD5 = 4
//

DWORD
ElGetEapTypeIndex ( 
    IN  DWORD   dwEapTypeId
    )
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < g_dwNumEapProtocols; dwIndex++)
    {
        if (g_pEapTable[dwIndex].RasEapInfo.dwEapTypeId == dwEapTypeId)
        {
            return(dwIndex);
        }
    }

    return((DWORD)-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eleap.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    eleap.h

Abstract:
e   This module contains the definitions and declarations related to 
    EAP protocol


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_EAP_H_
#define _EAPOL_EAP_H_

//#define EAP_DUMPW(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,4,1,NULL)
//#define EAP_DUMPB(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,1,1,NULL)


//
// Structure used to hold information about EAP DLLs that are loaded
//

typedef struct _EAP_INFO 
{
    // Handle to loaded EAP DLL
    HINSTANCE       hInstance;
    
    // Struture holding pointer to mandatory EAP DLL entrypoints
    PPP_EAP_INFO    RasEapInfo;

} EAP_INFO, *PEAP_INFO;

// 
// Structure used to hold port/connection configuration blob
// received from the EAP DLL, using RasEapInvokeConfigUI
//
typedef struct _ELEAP_SET_CUSTOM_AUTH_DATA
{
    BYTE        *pConnectionData;
    DWORD       dwSizeOfConnectionData;

} ELEAP_SET_CUSTOM_AUTH_DATA;

// 
// Structure used to hold data blob
// received from the EAP DLL, using RasEapInvokeInteractiveUI
//
typedef struct _ELEAP_INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    BYTE        *pbUIContextData;
    DWORD       dwSizeOfUIContextData;

} ELEAP_INVOKE_EAP_UI;

//
// Structure used to pass results and data between EAP processing and EAPOL
//

typedef struct _ELEAP_RESULT
{
    ELEAP_ACTION    Action;

    //
    // The packet ID which will cause the timeout for this send to be removed
    // from the timer queue.  Otherwise, the timer queue is not touched.  The
    // packet received is returned to the AP regardless of whether the timer
    // queue is changed.
    //

    BYTE            bIdExpected;

    //
    // dwError is valid only with an Action code of Done or SendAndDone.  0
    // indicates succesful authentication.  Non-0 indicates unsuccessful
    // authentication with the value indicating the error that occurred.
    //

    DWORD	        dwError;

    //
    // Valid only when dwError is non-0.  Indicates whether client is allowed
    // to retry without restarting authentication.  (Will be true in MS
    // extended CHAP only)
    //

    BOOL            fRetry;

    CHAR            szUserName[ UNLEN + 1 ];

    //
    // Set to attributes to be used for this user. If this is NULL, attributes 
    // from the authenticator will be used for this user. It is upto the
    // allocater of this memory to free it. Must be freed during the RasCpEnd 
    // call. 
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Used by MS-CHAP to pass the challenge used during the authentication
    // protocol. These 8 bytes are used as the variant for the 128 bit
    // encryption keys.
    //

    BYTE                            abChallenge[MAX_CHALLENGE_SIZE];

    BYTE                            abResponse[MAX_RESPONSE_SIZE];

    // Size of EAP packet constructed by EAP DLL
    WORD                            wSizeOfEapPkt;

    // Does RasEapInvokeInteractiveUI entrypoint need to be invoked?
    BOOL                            fInvokeEapUI;

    // Data obtained via RasEapInvokeInteractiveUI entrypoint of the DLL
    ELEAP_INVOKE_EAP_UI             InvokeEapUIData;

    // EAP type e.g. for EAP-TLS = 13
    DWORD                           dwEapTypeId;

    // Does user data blob created by EAP DLL need to be stored in the
    // registry
    BOOL                            fSaveUserData;
    
    // User data blob created by EAP DLL
    BYTE                            *pUserData;

    // Size of user data blob created by EAP DLL
    DWORD                           dwSizeOfUserData;

    // Does connection data blob created by EAP DLL need to be stored in the
    // registry
    BOOL                            fSaveConnectionData;

    // Connection data blob created by EAP DLL
    ELEAP_SET_CUSTOM_AUTH_DATA      SetCustomAuthData;
    
    // Notification text extracted from EAP-Notification message
    CHAR                            *pszReplyMessage;
  
} ELEAP_RESULT;

//
// CONSTANTS DECLARATIONS
//

// Default EAP type at startup for the system
#define     EAPCFG_DefaultKey   EAP_TYPE_TLS

//
// EAP DLL configuration entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI, RasEapFreeUserData and
// RasEapGetIdentity. For each EAP DLL, a check will be made to see if these
// entrypoints exists for the Dll, if they exist the entrypoints will be 
// stored as variables of the types below for usage
//

typedef DWORD (APIENTRY * EAPOLEAPFREE)( PBYTE );

typedef DWORD (APIENTRY * EAPOLEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);

typedef DWORD (APIENTRY * EAPOLEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );

typedef DWORD (APIENTRY * EAPOLEAPINVOKEINTERACTIVEUI)( DWORD, HWND, PBYTE, DWORD, PBYTE*, DWORD* );

//
//
// FUNCTION DECLARATIONS
//

DWORD
ElEapInit (
        IN  BOOL            fInitialize
    );

DWORD
ElEapBegin (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElEapEnd (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElEapMakeMessage (
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElMakeSupplicantMessage (
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElEapDllBegin (
        IN EAPOL_PCB        *pPCB,
        IN DWORD            dwEapIndex
        );

DWORD
ElEapDllWork ( 
        IN      EAPOL_PCB       *pPCB,
        IN      PPP_EAP_PACKET  *pReceiveBuf,
        IN OUT  PPP_EAP_PACKET  *pSendBuf,
        IN      DWORD           dwSizeOfSendBuf,
        IN OUT  ELEAP_RESULT    *pResult
        );

DWORD
ElEapDllEnd (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElGetEapTypeIndex ( 
        IN  DWORD           dwEapType
        );

#endif // _EAPOL_EAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elglobals.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elglobals.h

Abstract:

    This module contains declaration of global variables


Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_GLOBALS_H_
#define _EAPOL_GLOBALS_H_

// Current count of allocated PCBs
ULONG               g_MaxPorts;         

// Global read-write lock for PCB Hash bucket list
READ_WRITE_LOCK     g_PCBLock;          

// Structure used to define hash-table entities
typedef struct _PCB_BUCKET              
{                                       
    EAPOL_PCB       *pPorts;
} PCB_BUCKET, *PPCB_BUCKET;

typedef struct _PCB_TABLE
{
    PCB_BUCKET      *pPCBBuckets;
    DWORD           dwNumPCBBuckets;
} PCB_TABLE, *PPCB_TABLE;


// EAPOL PCB table
PCB_TABLE           g_PCBTable;         

// Handle to event log
HANDLE              g_hLogEvents;       

// Identifier of trace output
DWORD               g_dwTraceId;        

// Service Control Manager handle
SC_HANDLE           g_hServiceCM;

// NDISUIO service handle
SC_HANDLE           g_hNDISUIOService;

// Global Heap from which memory will be allocated
HANDLE              g_hGlobalHeap;      

// Pool of reusable read-write locks
PDYNAMIC_LOCKS_STORE g_dlsDynamicLockStore;  


// Global indication as to whether user has logged on
ULONG               g_fUserLoggedOn;     

// Global indication as to whether netman is autostart and thereby
// machine auth supported or not
DWORD               g_dwMachineAuthEnabled;

// Global timer queue for queueing timers using thread pool
HANDLE              g_hTimerQueue;


//
// EAPOL globals
//

// Max number of EAPOL_STARTs that can be sent out without response
DWORD               g_dwmaxStart;         

// Default time interval in secs between two EAPOL_STARTs
DWORD               g_dwstartPeriod;      

// Default time interval in secs between sending EAP_Resp/Id and not
// receiving any authenticator packet
DWORD               g_dwauthPeriod;       

// Default time in secs held in case of received EAP_Failure
DWORD               g_dwheldPeriod;       

// Global read-write lock for EAPOL configuration
READ_WRITE_LOCK     g_EAPOLConfig;          


//
// EAP Globals
//

// Table containing pointer to functions of different EAP dlls
EAP_INFO            *g_pEapTable;

// Number of EAP protocols for which DLLs are loaded
DWORD               g_dwNumEapProtocols;

DWORD               g_dwGuid;


//
// EAPOL service globals
//

// Event to exit main service thread
HANDLE              g_hStopService;

// Event to indicate shutdown of EAPOL module and cleanup threads
HANDLE              g_hEventTerminateEAPOL;

SERVICE_STATUS_HANDLE   g_hServiceStatus;

SERVICE_STATUS      g_ServiceStatus;

DWORD               g_dwModulesStarted;

// Global values for NLA

HANDLE              g_hNLA_LPC_Port;

PORT_VIEW           g_ClientView;

READ_WRITE_LOCK     g_NLALock;


#endif  // _EAPOL_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elport.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elport.c

Abstract:
   
    This module deals with the port management for EAPOL, r/w to ports


Revision History:

    sachins, Apr 28 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

BYTE DEFAULT_DEST_MAC_ADDR[]={0x01, 0x80, 0xc2, 0x00, 0x00, 0x0f};
BYTE ETHERNET_TYPE_8021X[]={0x81, 0x80};
BYTE DEFAULT_8021X_VERSION=0x01;


//
// ElReadPerPortRegistryParams
//
// Description:
//
// Function called to read per port interface parameters from the registry
//
// Arguments:
//      pszDeviceGUID - GUID-string for the port
//      pNewPCB - Pointer to PCB for the port
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD
ElReadPerPortRegistryParams (
        IN  CHAR        *pszDeviceGUID,
        IN  EAPOL_PCB   *pNewPCB
        )
{
    CHAR        czDummyBuffer[256];
    DWORD       dwSizeofRemoteMacAddr = 0;
    DWORD       dwRetCode = NO_ERROR;

    // Read EAP type and default EAPOL state

    if ((dwRetCode = ElGetInterfaceParams (
                            pszDeviceGUID,
                            &pNewPCB->dwEapTypeToBeUsed,
                            czDummyBuffer,
                            &pNewPCB->dwEapolEnabled
                            )) != NO_ERROR)
    {
        TRACE1 (PORT, "ElReadPerPortRegistryParams: ElGetInterfaceParams failed with error %ld",
                dwRetCode);

        pNewPCB->dwEapTypeToBeUsed = DEFAULT_EAP_TYPE;
        pNewPCB->dwEapolEnabled = DEFAULT_EAPOL_STATE;

        if (pNewPCB->dwEapolEnabled)
        {
            dwRetCode = NO_ERROR;
        }
        else
        {
            return dwRetCode;
        }
    }


    memcpy(pNewPCB->bEtherType, &ETHERNET_TYPE_8021X[0], SIZE_ETHERNET_TYPE);

    pNewPCB->bProtocolVersion = DEFAULT_8021X_VERSION;

    return dwRetCode;
}


//
// ElHashPortToBucket
//
// Description:
//
// Function called to convert Device GUID into PCB hash table index.
//
// Arguments:
//      pszDeviceGUID - GUID-string for the port
//
// Return values:
//      PCB hash table index from 0 to PORT_TABLE_BUCKETS-1
//

DWORD
ElHashPortToBucket (
        IN CHAR *pszDeviceGUID
        )
{
    return ((DWORD)((atol(pszDeviceGUID)) % PORT_TABLE_BUCKETS)); 
}


//
// ElRemovePCBFromTable
//
// Description:
//
// Function called to remove a PCB from the Hash Bucket table
// Delink it from the hash table, but do not free up the memory
//
// Arguments:
//      pPCB - Pointer to PCB entry to be removed
//
//  Return values:
//

VOID
ElRemovePCBFromTable (
        IN EAPOL_PCB *pPCB
        )
{
    DWORD       dwIndex;
    EAPOL_PCB   *pPCBWalker = NULL;
    EAPOL_PCB   *pPCBTemp = NULL;

    if (pPCB == NULL)
    {
        TRACE0 (PORT, "ElRemovePCBFromTable: Deleting NULL PCB, returning");
        return;
    }

    dwIndex = ElHashPortToBucket (pPCB->pszDeviceGUID);
    pPCBWalker = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
    pPCBTemp = pPCBWalker;

    while (pPCBTemp != NULL)
    {
        if (strncmp (pPCBTemp->pszDeviceGUID, 
                    pPCB->pszDeviceGUID, strlen(pPCB->pszDeviceGUID)) == 0)
        {
            // Entry is at head of list in table
            if (pPCBTemp == g_PCBTable.pPCBBuckets[dwIndex].pPorts)
            {
                g_PCBTable.pPCBBuckets[dwIndex].pPorts = pPCBTemp->pNext;
            }
            else
            {
                // Entry in inside list in table
                pPCBWalker->pNext = pPCBTemp->pNext;
            }
        
            break;
        }

        pPCBWalker = pPCBTemp;
        pPCBTemp = pPCBWalker->pNext;
    }

    return;

}


//
// ElGetPCBPointerFromPortGUID
//
// Description:
//
// Function called to convert interface GUID to PCB pointer for the entry in 
// the PCB hash table
//
// Arguments:
//      pszDeviceGUID - Identifier of the form GUID-String
//
// Return values:
//

PEAPOL_PCB
ElGetPCBPointerFromPortGUID (
        IN CHAR *pszDeviceGUID 
        )
{
    EAPOL_PCB   *pPCBWalker = NULL;
    DWORD       dwIndex;

    TRACE1 (PORT, "ElGetPCBPointerFromPortGUID: GUID %s", pszDeviceGUID);
        
    dwIndex = ElHashPortToBucket (pszDeviceGUID);

    TRACE1 (PORT, "ElGetPCBPointerFromPortGUID: Index %d", dwIndex);

    for (pPCBWalker = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
            pPCBWalker != NULL;
            pPCBWalker = pPCBWalker->pNext
            )
    {
        if (strncmp (pPCBWalker->pszDeviceGUID, pszDeviceGUID, strlen(pszDeviceGUID)) == 0)
        {
            return pPCBWalker;
        }
    }

    return (NULL);
}


//
// ElInitializeEAPOL
//
// Description:
//
// Function to initialize EAPOL protocol module.
// Global EAPOL parameters are read from the registry.
// PCB hash table is initialized.
// EAP protocol is intialized.
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElInitializeEAPOL (
        )
{
    DWORD       dwIndex;
    DWORD       dwRetCode = NO_ERROR;

    do 
    {
        // Initialize global config locks
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_EAPOLConfig), "CFG") != NO_ERROR)
        {
            TRACE1(PORT, "ElInitializeEAPOL: Error %d creating g_EAPOLConfig read-write-lock", dwRetCode);
            // LOG
            break;
        }
    
        // Read parameters stored in registry
        if ((dwRetCode = ElReadGlobalRegistryParams ()) != NO_ERROR)
        {
            TRACE1 (PORT, "ElInitializeEAPOL: ElReadGlobalRegistryParams failed with error = %ld",
                    dwRetCode);
            dwRetCode = NO_ERROR;

            // Don't exit, since default values will be used
        }
     
        // Initialize Hash Bucket Table
        g_PCBTable.pPCBBuckets = (PCB_BUCKET *) MALLOC ( PORT_TABLE_BUCKETS * sizeof (PCB_BUCKET));
    
        if (g_PCBTable.pPCBBuckets == NULL)
        {
            TRACE0 (PORT, "ElInitializeEAPOL: Error in allocating memory for PCB buckets");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    
        for (dwIndex=0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
        {
            g_PCBTable.pPCBBuckets[dwIndex].pPorts=NULL;
        }
    
        // Initialize global locks
        if (dwRetCode = CREATE_READ_WRITE_LOCK(&(g_PCBLock), "PCB") != NO_ERROR)
        {
            TRACE1(PORT, "ElInitializeEAPOL: Error %d creating g_PCBLock read-write-lock", dwRetCode);
            // LOG
            break;
        }
    
        // Create global timer queue for the various EAPOL state machines
        if ((g_hTimerQueue = CreateTimerQueue()) == NULL)
        {
            dwRetCode = GetLastError();
            TRACE1(PORT, "ElInitializeEAPOL: Error %d creating timer queue", dwRetCode);
            break;
        }

        // Initialize EAP
        if ((dwRetCode = ElEapInit(TRUE)) != NO_ERROR)
        {
            TRACE1 (PORT, "ElInitializeEAPOL: Error in ElEapInit= %ld",
                    dwRetCode);
            break;
        }
    
    } while (FALSE);
    
    if (dwRetCode != NO_ERROR)
    {
        if (g_PCBTable.pPCBBuckets != NULL)
        {
            FREE (g_PCBTable.pPCBBuckets);
        }

        if (READ_WRITE_LOCK_CREATED(&(g_PCBLock)))
        {
            DELETE_READ_WRITE_LOCK(&(g_PCBLock));
        }

        if (READ_WRITE_LOCK_CREATED(&(g_EAPOLConfig)))
        {
            DELETE_READ_WRITE_LOCK(&(g_EAPOLConfig));
        }

        if (g_hTimerQueue != NULL)
        {
            if (!DeleteTimerQueueEx(
                    g_hTimerQueue,
                    INVALID_HANDLE_VALUE 
                    ))
            {
                dwRetCode = GetLastError();
                
                // Pending on timer deletion is asked above
                if (dwRetCode != ERROR_IO_PENDING)
                {
                    TRACE1 (PORT, "ElInitializeEAPOL: Error in DeleteTimerQueueEx = %d",
                            dwRetCode);
                }
            }
        }

        // DeInit EAP
        ElEapInit(FALSE);
    }

    TRACE1 (PORT, "ElInitializeEAPOL: Completed, RetCode = %ld", dwRetCode);
    return dwRetCode;
}


//
// ElCreatePort
//
// Description:
//
// Function to initialize Port Control Block for a port and start EAPOL
// on it. If the PCB already exists for the GUID, EAPOL state machine 
// is restarted for that port.
//
// Arguments:
//      hDevice - Handle to open NDISUIO driver on the interface
//      pszGUID - Pointer to GUID-String for the interface
//      pszFriendlyName - Friendly name of the interface
//      psSrcMacAddr - Mac Address of the interface
// 
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElCreatePort (
        IN  HANDLE  hDevice,
        IN  CHAR    *pszGUID,
        IN  CHAR    *pszFriendlyName,
        IN  BYTE    *psSrcMacAddr
        )
{
    EAPOL_PCB       *pNewPCB;
    BOOL            fPortToBeReStarted = FALSE;
    BOOL            fPCBCreated = FALSE;
    DWORD           dwIndex = 0;
    DWORD           dwSizeofRemoteMacAddr = 0;
    DWORD           ulOidDataLength = 0;
    NIC_STATISTICS  NicStatistics;
    DWORD           dwRetCode = NO_ERROR;

    do 
    {
        TRACE2 (PORT, "ElCreatePort: Entered for Handle=%p, GUID=%s",
                hDevice, pszGUID);

        // See if the port already exists
        // If yes, initialize the state machine
        // Else, create a new port
    
        ACQUIRE_WRITE_LOCK (&g_PCBLock);
    
        pNewPCB = ElGetPCBPointerFromPortGUID (pszGUID);

        if (pNewPCB != NULL)
        {
            // PCB found, restart EAPOL STATE machine

            fPortToBeReStarted = TRUE;

        }
        else
        {
            // PCB not found, create new PCB and initialize it
            TRACE1 (PORT, "ElCreatePort: No PCB found for %s", pszGUID);
    
            // Allocate and initialize a new PCB
            pNewPCB = (PEAPOL_PCB) MALLOC (sizeof(EAPOL_PCB));
            if (pNewPCB == NULL)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                TRACE0(PORT, "ElCreatePort: Error in memory allocation using MALLOC");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                return dwRetCode;
            }

        }

        // Get Media Statistics for the interface

        ZeroMemory ((PVOID)&NicStatistics, sizeof(NIC_STATISTICS));
        if ((dwRetCode = ElGetInterfaceNdisStatistics (
                        pszGUID,
                        &NicStatistics
                        )) != NO_ERROR)
        {
            RELEASE_WRITE_LOCK (&g_PCBLock);
            TRACE1(PORT, "ElCreatePort: ElGetInterfaceNdisStatistics failed with error %ld",
                    dwRetCode);
            break;
        }


        if  (fPortToBeReStarted)
        {
            if (NicStatistics.MediaState != MEDIA_STATE_CONNECTED)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                dwRetCode = ERROR_INVALID_STATE;
                TRACE1(PORT, "ElCreatePort: Invalid media status for port to be restarted = (%ld)",
                        dwRetCode);
                break;
            }
        }
        else
        {
            if ((NicStatistics.MediaState != MEDIA_STATE_CONNECTED) &&
                (NicStatistics.MediaState != MEDIA_STATE_DISCONNECTED))
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                dwRetCode = ERROR_INVALID_STATE;
                TRACE1(PORT, "ElCreatePort: Invalid media status for port = (%ld)",
                        NicStatistics.MediaState);
                break;
            }
        }


        pNewPCB->MediaState = NicStatistics.MediaState;
        pNewPCB->PhysicalMediumType = NicStatistics.PhysicalMediaType;

        
        // Initialize per port information from registry
        if ((dwRetCode = ElReadPerPortRegistryParams(pszGUID, pNewPCB)) != NO_ERROR)
        {
            RELEASE_WRITE_LOCK (&g_PCBLock);
            TRACE1(PORT, "ElCreatePort: ElReadPerPortRegistryParams failed with error %ld",
                    dwRetCode);
            break;
        }

        if (fPortToBeReStarted)
        {
            // Only port state will be changed to CONNECTING
            // No read requests will be cancelled
            // Hence no new read request will be posted
            TRACE1 (PORT, "ElCreatePort: PCB found for %s", pszGUID);
    
            if ((dwRetCode = ElReStartPort (pNewPCB)) != NO_ERROR)
            {
                TRACE1 (PORT, "ElCreatePort: Error in ElReStartPort = %d",
                        dwRetCode);
            
            }
            RELEASE_WRITE_LOCK (&g_PCBLock);
            break;
        }
        else
        {
            // New Port Control Block created

            // Port management variables
            pNewPCB->dwRefCount = 1; // Creation reference count
            pNewPCB->hPort = hDevice; 

            // Mark the port as active 
            pNewPCB->dwFlags = EAPOL_PORT_FLAG_ACTIVE; 

            pNewPCB->pszDeviceGUID = (PCHAR) MALLOC (strlen(pszGUID) + 1);
            if (pNewPCB->pszDeviceGUID == NULL)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                TRACE0(PORT, "ElCreatePort: Error in memory allocation for GUID");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            memcpy (pNewPCB->pszDeviceGUID, pszGUID, strlen(pszGUID));
            pNewPCB->pszDeviceGUID[strlen(pszGUID)] = '\0';

            pNewPCB->pszFriendlyName = (PCHAR) MALLOC (strlen(pszFriendlyName) + 1);
            if (pNewPCB->pszFriendlyName == NULL)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                TRACE0(PORT, "ElCreatePort: Error in memory allocation for Friendly Name");
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            memcpy (pNewPCB->pszFriendlyName, 
                    pszFriendlyName, strlen(pszFriendlyName));
            pNewPCB->pszFriendlyName[strlen(pszFriendlyName)] = '\0';

            memcpy(pNewPCB->bSrcMacAddr, psSrcMacAddr, SIZE_MAC_ADDR);

            // Get the Remote Mac address if possible
            dwSizeofRemoteMacAddr = SIZE_MAC_ADDR;

            if (dwRetCode = ElNdisuioQueryOIDValue (
                                    pNewPCB->hPort,
                                    OID_802_11_BSSID,
                                    pNewPCB->bDestMacAddr,
                                    &dwSizeofRemoteMacAddr
                                            ) != NO_ERROR)
            {
                TRACE1 (PORT, "ElCreatePort: ElNdisuioQueryOIDValue for OID_802_11_BSSID failed with error %ld",
                        dwRetCode);
                
                // Copy default destination Mac address value
                memcpy(pNewPCB->bDestMacAddr, &DEFAULT_DEST_MAC_ADDR[0], SIZE_MAC_ADDR);
                dwRetCode = NO_ERROR;

                // If destination MacAddress is going to be multicast
                // inform the driver to accept the packets from this address

                if ((dwRetCode = ElNdisuioSetOIDValue (
                                                pNewPCB->hPort,
                                                OID_802_3_MULTICAST_LIST,
                                                (BYTE *)&DEFAULT_DEST_MAC_ADDR[0],
                                                SIZE_MAC_ADDR)) 
                                                        != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&g_PCBLock);
                    TRACE1 (PORT, "ElCreatePort: ElNdisuioSetOIDValue for OID_802_3_MULTICAST_LIST failed with error %ld",
                            dwRetCode);
                    break;
                }
                else
                {
                    TRACE0 (PORT, "ElCreatePort: ElNdisuioSetOIDValue for OID_802_3_MULTICAST_LIST successful");
                }
            }
            else
            {
                TRACE0 (PORT, "ElCreatePort: ElNdisuioQueryOIDValue for OID_802_11_BSSID successful");
                EAPOL_DUMPBA (pNewPCB->bDestMacAddr, dwSizeofRemoteMacAddr);
            }


    
            pNewPCB->fGotUserIdentity = FALSE;

            // Assume port is on a network with authentication enabled
            pNewPCB->fIsRemoteEndEAPOLAware = TRUE;
    
            // EAPOL state machine variables
            pNewPCB->State = EAPOLSTATE_LOGOFF;

    
            // Create timer with very high due time and infinite period
            // Timer will be deleted when the port is deleted
            CREATE_TIMER(&(pNewPCB->hTimer), 
                    ElTimeoutCallbackRoutine, 
                    (PVOID)pNewPCB, 
                    INFINITE_SECONDS,
                    "PCB", 
                    &dwRetCode);
            if (dwRetCode != NO_ERROR)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                TRACE1 (PORT, "ElCreatePort: Error in CREATE_TIMER %ld", dwRetCode);
                break;
            }
    
            // EAPOL_Start s that have been sent out
            pNewPCB->ulStartCount = 0;

            // Last received Id from the remote end
            pNewPCB->dwPreviousId = 256;

            // Which 802.1X version state machines will talk?
            // Default = draft 7
            pNewPCB->fRemoteEnd8021XD8 = FALSE;

    
            ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);
            
            pNewPCB->EapolConfig.dwheldPeriod = g_dwheldPeriod;
            pNewPCB->EapolConfig.dwauthPeriod = g_dwauthPeriod;
            pNewPCB->EapolConfig.dwstartPeriod = g_dwstartPeriod;
            pNewPCB->EapolConfig.dwmaxStart = g_dwmaxStart;
    
            RELEASE_WRITE_LOCK (&g_EAPOLConfig);

            // Initialize read-write lock
            if (dwRetCode = CREATE_READ_WRITE_LOCK(&(pNewPCB->rwLock), "EPL") 
                    != NO_ERROR)
            {
                RELEASE_WRITE_LOCK (&g_PCBLock);
                TRACE1(PORT, "ElCreatePort: Error %d creating read-write-lock", 
                        dwRetCode);
                // LOG
                break;
            }
    
            // Initialize registry connection auth data for this port
            // If connection data is not present for EAP-TLS and SSID="Default"
            // create the blob
            if ((dwRetCode = ElInitRegPortData (
                            pNewPCB->pszDeviceGUID
                            )) != NO_ERROR)
            {
                TRACE1 (PORT, "ElCreatePort: Error in ElInitRegPortData = %d",
                        dwRetCode);
                break;
            }

            // Insert NewPCB into PCB hash table
            dwIndex = ElHashPortToBucket (pszGUID);
            pNewPCB->pNext = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
            g_PCBTable.pPCBBuckets[dwIndex].pPorts = pNewPCB;
            pNewPCB->dwPortIndex = dwIndex;

            fPCBCreated = TRUE;

            RELEASE_WRITE_LOCK (&g_PCBLock);

            ACQUIRE_WRITE_LOCK (&(pNewPCB->rwLock));

            //
            // Post a read request on the port
            //

            // Initiate read operation on the port, since it is now active
            if (dwRetCode = ElReadFromPort (
                        pNewPCB,
                        NULL,
                        0
                        )
                    != NO_ERROR)
            {
                RELEASE_WRITE_LOCK (&(pNewPCB->rwLock));
                TRACE1 (PORT, "ElCreatePort: Error in ElReadFromPort = %d",
                        dwRetCode);
                break;
            }

            
            //
            // Kick off EAPOL state machine
            //

            if (pNewPCB->MediaState == MEDIA_STATE_CONNECTED)
            {
                // Set port to EAPOLSTATE_CONNECTING State
                // Send out EAPOL_Start Packets to detect if it is a secure
                // or non-secure LAN based on response received from remote end

                if ((dwRetCode = FSMConnecting (pNewPCB)) != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&(pNewPCB->rwLock));
                    TRACE1 (PORT, "ElCreatePort: FSMConnecting failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
            else
            {
                // Set port to EAPOLSTATE_DISCONNECTED State
                if ((dwRetCode = FSMDisconnected (pNewPCB)) != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&(pNewPCB->rwLock));
                    TRACE1 (PORT, "ElCreatePort: FSMDisconnected failed with error %ld",
                            dwRetCode);
                    break;
                }
            }

            RELEASE_WRITE_LOCK (&(pNewPCB->rwLock));
        
            TRACE1 (PORT, "ElCreatePort: Completed for GUID=%s", pszGUID);
        }

    } while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        // If PCB was not being restarted
        if (!fPortToBeReStarted)
        {
            // If PCB was created
            if (fPCBCreated)
            {
                HANDLE  hTempDevice;

                // Mark the Port as deleted. Cleanup if possible
                // Don't worry about return code
                ElDeletePort (
                        pNewPCB->pszDeviceGUID,
                        &hDevice
                        );
            }
            else
            {
                // Remove all partial traces of port creation
                if (pNewPCB->pszDeviceGUID != NULL)
                {
                    FREE(pNewPCB->pszDeviceGUID);
                    pNewPCB->pszDeviceGUID = NULL;
                }
                if (pNewPCB->pszFriendlyName != NULL);
                {
                    FREE(pNewPCB->pszFriendlyName);
                    pNewPCB->pszFriendlyName = NULL;
                }
                if (pNewPCB != NULL)
                {
                    ZeroMemory ((PVOID)pNewPCB, sizeof (EAPOL_PCB));
                    FREE (pNewPCB);
                    pNewPCB = NULL;
                }
            }
        }
    }

    return dwRetCode;
}
        

//
// ElDeletePort
//
// Description:
//
// Function to stop EAPOL and delete PCB for a port.
// Returns back pointer to handle opened on the interface so that
// the handle can be closed by the interface management module.
//
// Input arguments:
//      pszDeviceGUID - GUID-String of the interface whose PCB needs to be 
//                      deleted
//      pHandle - Output: Handle to NDISUIO driver for this port
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElDeletePort (
        IN  CHAR    *pszDeviceGUID,
        OUT HANDLE  *pHandle
        )
{
    EAPOL_PCB   *pPCB = NULL;
    DWORD       dwRetCode = NO_ERROR;

    ACQUIRE_WRITE_LOCK (&(g_PCBLock));

    // Verify if PCB exists for this GUID

    TRACE1 (PORT, "ElDeletePort entered for GUID %s", pszDeviceGUID);
    pPCB = ElGetPCBPointerFromPortGUID (pszDeviceGUID);

    if (pPCB == NULL)
    {
        RELEASE_WRITE_LOCK (&(g_PCBLock));
        TRACE1 (PORT, "ElDeletePort: PCB not found entered for Port %s", 
                pszDeviceGUID);
        return ERROR_NO_SUCH_INTERFACE;
    }

    ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

    // Make sure it isn't already deleted

    if (EAPOL_PORT_DELETED(pPCB)) 
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
        RELEASE_WRITE_LOCK (&(g_PCBLock));
        TRACE1 (PORT, "ElDeletePort: PCB already marked deleted for Port %s", 
                pszDeviceGUID);
        return ERROR_NO_SUCH_INTERFACE;
    }
   
    // Retain handle to NDISUIO device
    *pHandle = pPCB->hPort;

    // Mark the PCB as deleted and remove it from the hash bucket
    pPCB->dwFlags = EAPOL_PORT_FLAG_DELETED;
    ElRemovePCBFromTable(pPCB);
    
    // Shutdown EAP 
    // Will always return NO_ERROR, so no check on return value
    ElEapEnd (pPCB);

    // Do explicit decrement reference count. 
    // If it is non-zero, cleanup will complete later


    TRACE1 (PORT, "ElDeletePort: RefCount for port = %ld", pPCB->dwRefCount);
    
    if (--pPCB->dwRefCount) 
    {
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
        RELEASE_WRITE_LOCK (&(g_PCBLock));
        TRACE1 (PORT, "ElDeletePort: PCB deletion pending for Port %s", 
                pszDeviceGUID);
        return NO_ERROR;
    }
    
    RELEASE_WRITE_LOCK (&(pPCB->rwLock));

    // The reference count is zero, so perform final cleanup
    
    ElCleanupPort (pPCB);

    RELEASE_WRITE_LOCK (&(g_PCBLock));

    return NO_ERROR;
}


//
// ElCleanupPort
//
// Description:
//
// Function called when the very last reference to a PCB
// is released. The PCB memory is released and zeroed out
//
// Arguments:
//  pPCB - Pointer to port control block to be destroyed
// 
//

VOID
ElCleanupPort (
        IN  PEAPOL_PCB  pPCB
        )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE1 (PORT, "ElCleanupPort entered for %s", pPCB->pszDeviceGUID);

    // Do a BLOCKING deletion of the timer that was created on this port
    // If a timer callback function was queued, it will be executed before
    // the deletion returns.
    // The PCB->rwLock needs to be held in the callback function
    // ElCleanupPort is called always without holding any locks
    // So, no deadlock issues should occur
    DELETE_TIMER (pPCB->hTimer, INVALID_HANDLE_VALUE, &dwRetCode);

    if (pPCB->pszDeviceGUID != NULL)
    {
        FREE (pPCB->pszDeviceGUID);
    }
    if (pPCB->pszFriendlyName)
    {
        FREE (pPCB->pszFriendlyName);
    }

    if (pPCB->pszEapReplyMessage != NULL)
    {
        FREE (pPCB->pszEapReplyMessage);
    }

    if (pPCB->pszSSID != NULL)
    {
        FREE (pPCB->pszSSID);
    }

    if (pPCB->EapUIData.pEapUIData != NULL)
    {
        FREE (pPCB->EapUIData.pEapUIData);
    }

    if (pPCB->pbMPPESendKey != NULL)
    {
        FREE (pPCB->pbMPPESendKey);
    }

    if (pPCB->pbMPPERecvKey != NULL)
    {
        FREE (pPCB->pbMPPERecvKey);
    }

    if (pPCB->pszIdentity != NULL)
    {
        FREE (pPCB->pszIdentity);
    }

    if (pPCB->pszPassword != NULL)
    {
        FREE (pPCB->pszPassword);
    }

    if (pPCB->pCustomAuthUserData != NULL)
    {
        FREE (pPCB->pCustomAuthUserData);
    }

    if (pPCB->pCustomAuthConnData != NULL)
    {
        FREE (pPCB->pCustomAuthConnData);
    }

    if (pPCB->pbPreviousEAPOLPkt != NULL)
    {
        FREE (pPCB->pbPreviousEAPOLPkt);
    }

    if (READ_WRITE_LOCK_CREATED(&(pPCB->rwLock)))
    {
        DELETE_READ_WRITE_LOCK(&(pPCB->rwLock));
    }
    
    ZeroMemory ((PVOID)pPCB, sizeof(EAPOL_PCB));

    FREE (pPCB);

    pPCB = NULL;

    TRACE0 (PORT, "ElCleanupPort completed");

    return;

} 


//
// ElReStartPort
//
// Description:
//
// Function called to reset the EAPOL state machine to Connecting state
// This may be called due to:
//      1. From ElCreatePort, for an existing PCB
//      2. Configuration parameters may have changed. Initialization
//          is required to allow new values to take effect.
//      Initialization will take the EAPOL state to CONNECTING
//
// Arguments:
//  pPCB - Pointer to port control block to be initialized
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElReStartPort (
        IN  EAPOL_PCB *pPCB
        )
{
    DWORD       dwSizeofRemoteMacAddr = 0;
    DWORD       dwCurrenTickCount = 0;
    DWORD       dwRetCode = NO_ERROR;

    TRACE1 (PORT, "ElReStartPort: Entered: Refcnt = %ld",
            pPCB->dwRefCount);

    do
    {

        ACQUIRE_WRITE_LOCK (&pPCB->rwLock);

        if (EAPOL_PORT_DELETED(pPCB)) 
        {
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            TRACE1 (PORT, "ElReStartPort: PCB already marked deleted for Port %s", 
                    pPCB->pszDeviceGUID);
            break;
        }

        // If port was not restarted in the last 2 seconds,
        // only then restart the machine. Else, there are too many
        // restarts during roaming
        // 2000 milliseconds should be sufficient time for a TLS authentication
        // to go through

        dwCurrenTickCount = GetTickCount ();

        if ((dwCurrenTickCount - pPCB->dwLastRestartTickCount) <= 2000)
        {
            RELEASE_WRITE_LOCK (&pPCB->rwLock);
            TRACE1 (PORT, "ElReStartPort: NOT restarting, since only %ld msecs have passed",
                    (dwCurrenTickCount - pPCB->dwLastRestartTickCount));
            break;
        }

        if (EAPOL_PORT_DELETED(pPCB)) 
        {
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            TRACE1 (PORT, "ElReStartPort: PCB already marked deleted for Port %s", 
                    pPCB->pszDeviceGUID);
            break;
        }

        pPCB->dwFlags = EAPOL_PORT_FLAG_ACTIVE;
    
        pPCB->fGotUserIdentity = FALSE;
        pPCB->ulStartCount = 0;
        pPCB->dwPreviousId = 256;
        pPCB->dwLogoffSent = 0;
        pPCB->fIsRemoteEndEAPOLAware = TRUE;
        pPCB->ullLastReplayCounter = 0;
        pPCB->fAuthenticationOnNewNetwork = FALSE;
        pPCB->fRemoteEnd8021XD8 = FALSE;

        // Initialize per port information from registry
        if ((dwRetCode = ElReadPerPortRegistryParams(pPCB->pszDeviceGUID, 
                                                        pPCB)) != NO_ERROR)
        {
            RELEASE_WRITE_LOCK (&pPCB->rwLock);
            TRACE1(PORT, "ElReStartPort: ElReadPerPortRegistryParams failed with error %ld",
                    dwRetCode);
            break;
        }

        // Clean out CustomAuthData since EAP type may have changed
        // During authentication, CustomAuthData for the connection will be
        // picked up again

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }
    
        // Parameters initialization
        memcpy(pPCB->bEtherType, &ETHERNET_TYPE_8021X[0], SIZE_ETHERNET_TYPE);
        pPCB->bProtocolVersion = DEFAULT_8021X_VERSION;
     
        // Get the Remote-end Mac address if possible
    
        dwSizeofRemoteMacAddr = SIZE_MAC_ADDR;
    
        if (dwRetCode = ElNdisuioQueryOIDValue (
                                pPCB->hPort,
                                OID_802_11_BSSID,
                                pPCB->bDestMacAddr,
                                &dwSizeofRemoteMacAddr
                                        ) != NO_ERROR)
        {
            TRACE1 (PORT, "ElReStartPort: ElNdisuioQueryOIDValue for OID_802_11_BSSID failed with error %ld",
                    dwRetCode);
            
            // Copy default destination Mac address value
            memcpy(pPCB->bDestMacAddr, &DEFAULT_DEST_MAC_ADDR[0], SIZE_MAC_ADDR);
            dwRetCode = NO_ERROR;

            // If destination MacAddress is going to be multicast
            // inform the driver to accept the packets from this address

            if ((dwRetCode = ElNdisuioSetOIDValue (
                                            pPCB->hPort,
                                            OID_802_3_MULTICAST_LIST,
                                            (BYTE *)&DEFAULT_DEST_MAC_ADDR[0],
                                            SIZE_MAC_ADDR)) 
                                                    != NO_ERROR)
            {
                TRACE1 (PORT, "ElReStartPort: ElNdisuioSetOIDValue for OID_802_3_MULTICAST_LIST failed with error %ld",
                        dwRetCode);
            }
            else
            {
                TRACE0 (PORT, "ElReStartPort: ElNdisuioSetOIDValue for OID_802_3_MULTICAST_LIST successful");
            }
        }
        else
        {
            TRACE0 (PORT, "ElReStartPort: ElNdisuioQueryOIDValue for OID_802_11_BSSID successful");
            EAPOL_DUMPBA (pPCB->bDestMacAddr, dwSizeofRemoteMacAddr);
        }

        // Set EAPOL timeout values
     
        ACQUIRE_WRITE_LOCK (&g_EAPOLConfig);
            
        pPCB->EapolConfig.dwheldPeriod = g_dwheldPeriod;
        pPCB->EapolConfig.dwauthPeriod = g_dwauthPeriod;
        pPCB->EapolConfig.dwstartPeriod = g_dwstartPeriod;
        pPCB->EapolConfig.dwmaxStart = g_dwmaxStart;

        RELEASE_WRITE_LOCK (&g_EAPOLConfig);

        // Set restart tickcount

        pPCB->dwLastRestartTickCount = dwCurrenTickCount;


        // Send out EAPOL_Start Packets

        if ((dwRetCode = FSMConnecting (pPCB)) != NO_ERROR)
        {
            TRACE1 (PORT, "ElReStartPort: FSMConnecting failed with error %ld",
                    dwRetCode);
        }
    
        RELEASE_WRITE_LOCK (&pPCB->rwLock);

    } while (FALSE);

    return dwRetCode;
}


//
// ElEAPOLDeInit
//
// Description:
//
// Function called to shutdown EAPOL module 
// Shutdown EAP.
// Cleanup all used memory
//
// Arguments:
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//
//

DWORD
ElEAPOLDeInit (
        )
{
    EAPOL_PCB       *pPCBWalker = NULL;
    EAPOL_PCB       *pPCB = NULL;
    DWORD           dwIndex = 0;              
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (PORT, "ElEAPOLDeInit entered");

    do 
    {
        // Walk the hash table
        // Mark PCBs as deleted. Free PCBs which we can

        ACQUIRE_WRITE_LOCK (&(g_PCBLock));

        for (dwIndex = 0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
        {
            pPCBWalker = g_PCBTable.pPCBBuckets[dwIndex].pPorts;

            while (pPCBWalker != NULL)
            {
                pPCB = pPCBWalker;
                pPCBWalker = pPCB->pNext;

                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                // Mark the PCB as deleted and remove it from the hash bucket
                pPCB->dwFlags = EAPOL_PORT_FLAG_DELETED;
                ElRemovePCBFromTable(pPCB);

                // Shutdown EAP 
                ElEapEnd (pPCB);

                // Close the handle to the NDISUIO driver
                if ((dwRetCode = ElCloseInterfaceHandle (pPCB->hPort)) 
                        != NO_ERROR)
                {
                    TRACE1 (DEVICE, 
                        "ElMediaSenseCallback: Error in ElCloseInterfaceHandle %d", 
                        dwRetCode);
                }
                
                // Do explicit decrement reference count. 
                // If it is zero, cleanup right now

                if ((pPCB->dwRefCount--) == 0)
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    ElCleanupPort (pPCB);
                }
                else
                {
                    // Cleanup will happen later
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                }
            }
        }

        RELEASE_WRITE_LOCK (&(g_PCBLock));
    
        // Delete EAPOL config lock
        if (READ_WRITE_LOCK_CREATED(&(g_EAPOLConfig)))
        {
            DELETE_READ_WRITE_LOCK(&(g_EAPOLConfig));
        }
    
        // Delete global PCB table lock
        if (READ_WRITE_LOCK_CREATED(&(g_PCBLock)))
        {
            DELETE_READ_WRITE_LOCK(&(g_PCBLock));
        }
    
        // Delete global timer queue
        if (g_hTimerQueue != NULL)
        {
            if (!DeleteTimerQueueEx(
                g_hTimerQueue,
                NULL // Not waiting for timer callbacks to complete
                ))
            {
                dwRetCode = GetLastError();

                // Pending on timer deletion is asked above
                if (dwRetCode != ERROR_IO_PENDING)
                {
                    TRACE1 (PORT, "ElEAPOLDeInit: Error in DeleteTimerQueueEx = %d",
                            dwRetCode);
                    break;
                }

                // If ERROR_IO_PENDING ignore error
                dwRetCode = NO_ERROR;
            }
        }
    
        // Un-initialize EAP
        if ((dwRetCode = ElEapInit(FALSE)) != NO_ERROR)
        {
            TRACE1 (PORT, "ElEAPOLDeInit: Error in ElEapInit(FALSE) = %ld",
                    dwRetCode);
            break;
        }
    
    } while (FALSE);

    TRACE1 (PORT, "ElEAPOLDeInit completed, RetCode = %d", dwRetCode);

    return dwRetCode;
}


//
// Currently Unsupported 
// Read EAPOL statistics for the port
//

VOID
ElReadPortStatistics (
        IN  CHAR            *pszDeviceGUID,
        OUT PEAPOL_STATS    pEapolStats
        )
{
}


//
// Currently Unsupported 
// Read EAPOL Port Configuration for the mentioned port
//

VOID
ElReadPortConfiguration (
        IN  CHAR            *pszDeviceGUID,
        OUT PEAPOL_CONFIG   pEapolConfig
        )
{
}


//
// Currently Unsupported 
// Set EAPOL Port Configuration for the mentioned port
//

DWORD
ElSetPortConfiguration (
        IN  CHAR            *pszDeviceGUID,
        IN  PEAPOL_CONFIG   pEapolConfig
        )
{
    DWORD   dwRetCode = NO_ERROR;

    return dwRetCode;
}


//
// ElReadCompletionRoutine
//
// Description:
//
// This routine is invoked upon completion of an OVERLAPPED read operation
// on an interface on which EAPOL is running
//
// The message read is validated and processed, and if necessary,
// a reply is generated and sent out
//
// Arguments:
//      dwError - Win32 status code for the I/O operation
//
//      dwBytesTransferred - number of bytes in 'pEapolBuffer'
// 
//      pEapolBuffer - holds data read from the datagram socket
//
// Notes:
//  A reference to the component will have been made on our behalf
//  by ElReadPort(). Hence g_PCBLock, will not be required
//  to be taken since current PCB existence is guaranteed
//

VOID 
CALLBACK
ElReadCompletionRoutine (
        DWORD           dwError,
        DWORD           dwBytesReceived,
        EAPOL_BUFFER    *pEapolBuffer 
        )
{
    EAPOL_PCB       *pPCB;
    DWORD           dwRetCode;

    pPCB = (EAPOL_PCB *)pEapolBuffer->pvContext;
    TRACE1 (PORT, "ElReadCompletionRoutine entered, %ld bytes recvd",
            dwBytesReceived);

    do 
    {
        if (dwError)
        {
            // Error in read request
           
            TRACE2 (PORT, "ElReadCompletionRoutine: Error %d on port %s",
                    dwError, pPCB->pszDeviceGUID);
            
            // Having a ref count from the read posted, guarantees existence
            // of PCB. Hence no need to acquire g_PCBLock

            ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
            if (!EAPOL_PORT_ACTIVE(pPCB))
            {
                TRACE1 (PORT, "ElReadCompletionRoutine: Port %s not active",
                        pPCB->pszDeviceGUID);
                // Port is not active, release Context buffer
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                FREE (pEapolBuffer);
            }
            else
            {
                TRACE1 (PORT, "ElReadCompletionRoutine: Reposting buffer on port %s",
                        pPCB->pszDeviceGUID);


                // Repost buffer for another read operation
                // Free the current buffer, ElReadFromPort creates a new 
                // buffer
                FREE(pEapolBuffer);

                if ((dwRetCode = ElReadFromPort (
                                pPCB,
                                NULL,
                                0
                                )) != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    TRACE1 (PORT, "ElReadCompletionRoutine: ElReadFromPort error %d",
                            dwRetCode);
                    break;
                }
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            }
            break;
        }
            
        // Successful read completion

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            // Port is not active
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            FREE (pEapolBuffer);
            TRACE1 (PORT, "ElReadCompletionRoutine: Port %s is inactive",
                    pPCB->pszDeviceGUID);
            break;
        }
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

        // Queue a work item to the Thread Pool to execute in the
        // I/O component. Callbacks from BindIoCompletionCallback do not
        // guarantee to be running in I/O component. So, on a non I/O
        // component thread may die while requests are pending.
        // (Refer to Jeffrey Richter, pg 416, Programming Applications for
        // Microsoft Windows, Fourth Edition

        // pEapolBuffer will be the context for the function
        // since it stores all relevant information for processing
        // i.e. pBuffer, dwBytesTransferred, pContext => pPCB

        if (!QueueUserWorkItem (
                    (LPTHREAD_START_ROUTINE)ElProcessReceivedPacket,
                    (PVOID)pEapolBuffer,
                    WT_EXECUTEINIOTHREAD
                    ))
        {
            dwRetCode = GetLastError();
            TRACE1 (PORT, "ElReadCompletionRoutine: Critical error: QueueUserWorkItem failed with error %ld",
                    dwRetCode);
            break;
        }
        else
        {
            //TRACE1 (PORT, "ElReadCompletionRoutine: QueueUserWorkItem work item queued for port %p",
                    //pPCB);

            // The received packet has still not been processed. 
            // The ref count cannot be decrement, yet
            // Return without decrementing
            
            return;
        }

    } while (FALSE);

    // Decrement refcount for error cases

    EAPOL_DEREFERENCE_PORT(pPCB); 

    TRACE2 (PORT, "ElReadCompletionRoutine: pPCB= %p, RefCnt = %ld", 
            pPCB, pPCB->dwRefCount);
}


//
// ElWriteCompletionRoutine
//
// Description:
//
// This routine is invoked upon completion of an OVERLAPPED write operation
// on an interface on which EAPOL is running.
//
//
// Arguments:
//      dwError - Win32 status code for the I/O operation
//
//      dwBytesTransferred - number of bytes sent out
// 
//      pEapolBuffer - buffer sent to the WriteFile command 
//
// Notes:
//  The reference count for the write operation is removed.
//

VOID 
CALLBACK
ElWriteCompletionRoutine (
        DWORD           dwError,
        DWORD           dwBytesSent,
        EAPOL_BUFFER    *pEapolBuffer 
        )
{
    PEAPOL_PCB  pPCB = (PEAPOL_PCB)pEapolBuffer->pvContext;

    TRACE2 (DEVICE, "ElWriteCompletionRoutine sent out %d bytes with error %d",
            dwBytesSent, dwError);

    // No need to acquire locks, since PCB existence is guaranteed
    // by reference made when write was posted
    EAPOL_DEREFERENCE_PORT(pPCB);
    TRACE2 (PORT, "ElWriteCompletionRoutine: pPCB= %p, RefCnt = %ld", 
            pPCB, pPCB->dwRefCount);
    FREE(pEapolBuffer);
    return;

    // Free Read/Write buffer area, if it is dynamically allocated
    // We have static Read-write buffer for now
}


//
// ElIoCompletionRoutine
//
// Description:
//
// Callback function defined to BindIoCompletionCallback
// This routine is invoked by the I/O system upon completion of a read/write
// operation
// This routine in turn calls ElReadCompletionRoutine or 
// ElWriteCompletionRoutine depending on what command invoked the 
// I/O operation i.e. ReadFile or WriteFile
// 
// Input arguments:
//      dwError - system-supplied error code
//      dwBytesTransferred - system-supplied byte-count
//      lpOverlapped - called-supplied context area
//
// Return values:
//

VOID 
CALLBACK
ElIoCompletionRoutine (
        DWORD           dwError,
        DWORD           dwBytesTransferred,
        LPOVERLAPPED    lpOverlapped
        )
{
    PEAPOL_BUFFER pBuffer = CONTAINING_RECORD (lpOverlapped, EAPOL_BUFFER, Overlapped);

    TRACE1 (DEVICE, "ElIoCompletionRoutine called, %ld bytes xferred",
            dwBytesTransferred);

    pBuffer->dwErrorCode = dwError;
    pBuffer->dwBytesTransferred = dwBytesTransferred;
    pBuffer->CompletionRoutine (
            pBuffer->dwErrorCode,
            pBuffer->dwBytesTransferred,
            pBuffer
            );

    return;

} 


//
// ElReadFromPort
//
// Description:
//
// Function to read EAPOL packets from a port
// 
// Arguments: 
//      pPCB - Pointer to PCB for port on which read is to be performed
//      pBuffer - unused
//      dwBufferLength - unused
//
// Return values:
//
// Locks:
//  pPCB->rw_Lock should be acquired before calling this function
//  

DWORD
ElReadFromPort (
        IN PEAPOL_PCB       pPCB,
        IN PCHAR            pBuffer,
        IN DWORD            dwBufferLength
        )
{
    PEAPOL_BUFFER   pEapolBuffer;
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (PORT, "ElReadFromPort entered");

    // Allocate Context buffer

    if ((pEapolBuffer = (PEAPOL_BUFFER) MALLOC (sizeof(EAPOL_BUFFER))) == NULL)
    {
        TRACE0 (PORT, "ElReadFromPort: Error in memory allocation");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize Context data used in Overlapped operations
    pEapolBuffer->pvContext = (PVOID)pPCB;
    pEapolBuffer->CompletionRoutine = ElReadCompletionRoutine;

    // Make a reference to the port
    // this reference is released in the completion routine
    if (!EAPOL_REFERENCE_PORT(pPCB))
    {
        //RELEASE_WRITE_LOCK (&(g_PCBLock));
        TRACE0 (PORT, "ElReadFromPort: Unable to obtain reference to port");
        FREE (pEapolBuffer);
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2 (DEVICE, "ElReadFromPort: pPCB = %p, RefCnt = %ld",
            pPCB, pPCB->dwRefCount);

    // Read from the NDISUIO interface corresponding to this port
    if ((dwRetCode = ElReadFromInterface(
                    pPCB->hPort,
                    pEapolBuffer,
                    MAX_PACKET_SIZE - SIZE_ETHERNET_CRC 
                            // read the maximum data possible
                    )) != NO_ERROR)
    {
        TRACE1 (DEVICE, "ElReadFromPort: Error in ElReadFromInterface = %d",
                dwRetCode);

        FREE(pEapolBuffer);
    
        // Decrement refcount just incremented, since it will not be
        // decremented in ReadCompletionRoutine since it will not be called.

        EAPOL_DEREFERENCE_PORT(pPCB); 
        TRACE2 (PORT, "ElReadFromPort: pPCB= %p, RefCnt = %ld", 
                pPCB, pPCB->dwRefCount);

    }

    return dwRetCode;

} 


//
// ElWriteToPort
//
// Description:
//
// Function to write EAPOL packets to a port
// 
// Input arguments: 
//      pPCB - Pointer to PCB for port on which write is to be performed
//      pBuffer - Pointer to data to be sent out
//      dwBufferLength - Number of bytes to be sent out
//
// Return values:
//  
// Locks:
//  pPCB->rw_Lock should be acquired before calling this function
//  

DWORD
ElWriteToPort (
        IN PEAPOL_PCB       pPCB,
        IN PCHAR            pBuffer,
        IN DWORD            dwBufferLength
        )
{
    PEAPOL_BUFFER   pEapolBuffer;
    PETH_HEADER     pEthHeader;
    DWORD           dwTotalBytes = 0;
    DWORD           dwRetCode = NO_ERROR;


    TRACE1 (PORT, "ElWriteToPort entered: Pkt Length = %ld", dwBufferLength);

    if ((pEapolBuffer = (PEAPOL_BUFFER) MALLOC (sizeof(EAPOL_BUFFER))) == NULL)
    {
        TRACE0 (PORT, "ElWriteToPort: Error in memory allocation");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize Context data used in Overlapped operations
    pEapolBuffer->pvContext = (PVOID)pPCB;
    pEapolBuffer->CompletionRoutine = ElWriteCompletionRoutine;

    pEthHeader = (PETH_HEADER)pEapolBuffer->pBuffer;

    // Copy the source MAC address and the destination MAC address
    memcpy ((PBYTE)pEthHeader->bDstAddr, 
            (PBYTE)pPCB->bDestMacAddr, 
            SIZE_MAC_ADDR);
    memcpy ((PBYTE)pEthHeader->bSrcAddr, 
            (PBYTE)pPCB->bSrcMacAddr, 
            SIZE_MAC_ADDR);
    
    // Validate packet length
    if ((dwBufferLength + sizeof(ETH_HEADER)) > 
            (MAX_PACKET_SIZE - SIZE_ETHERNET_CRC))
    {
        TRACE2 (PORT, "ElWriteToPort: Packetsize %d greater than maximum allowed",
                dwBufferLength, 
                (MAX_PACKET_SIZE - SIZE_ETHERNET_CRC - sizeof(ETH_HEADER)));
        FREE (pEapolBuffer);
        return ERROR_BAD_LENGTH;
    }

    // Copy the EAPOL packet and body
    if (pBuffer != NULL)
    {
        if (pPCB->fRemoteEnd8021XD8)
        {
            EAPOL_PACKET    *pEapolPkt = NULL;
            EAPOL_PACKET_D8 *pEapolPktD8 = NULL;

            pEapolPkt = (EAPOL_PACKET *)pBuffer;
            pEapolPktD8 = 
                (EAPOL_PACKET_D8 *)((PBYTE)pEapolBuffer->pBuffer + 
                                    sizeof(ETH_HEADER));

            memcpy (pEapolPktD8->EthernetType, pEapolPkt->EthernetType, 2);
            pEapolPktD8->ProtocolVersion = pEapolPkt->ProtocolVersion;
            pEapolPktD8->PacketType = pEapolPkt->PacketType;
            memcpy (pEapolPktD8->PacketBodyLength, pEapolPkt->PacketBodyLength, 
                    2);
            HostToWireFormat16 ((WORD)AUTH_Continuing, 
                    pEapolPktD8->AuthResultCode);

            memcpy (pEapolPktD8->PacketBody, pEapolPkt->PacketBody, 
                    dwBufferLength - sizeof(EAPOL_PACKET) + 1);

            dwBufferLength = dwBufferLength + 2;

            TRACE0 (PORT, "ElWriteToPort: Writing out a DRAFT 8 type EAPOL packet");
        }
        else
        {
            memcpy ((PBYTE)((PBYTE)pEapolBuffer->pBuffer+sizeof(ETH_HEADER)),
                    (PBYTE)pBuffer, 
                    dwBufferLength);
        }
    }

    dwTotalBytes = dwBufferLength + sizeof(ETH_HEADER);


    // Buffer will be released by calling function
        
    // Write to the NDISUIO interface corresponding to this port
    
    // Make a reference to the port
    // this reference is released in the completion routine
    if (!EAPOL_REFERENCE_PORT(pPCB))
    {
        TRACE0 (PORT, "ElWriteToPort: Unable to obtain reference to port");
        FREE (pEapolBuffer);
        return ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        TRACE2 (DEVICE, "ElWriteToPort: pPCB = %p, RefCnt = %ld",
            pPCB, pPCB->dwRefCount);

        if ((dwRetCode = ElWriteToInterface (
                    pPCB->hPort,
                    pEapolBuffer,
                    dwTotalBytes
                )) != NO_ERROR)
        {
            FREE (pEapolBuffer);
            TRACE1 (PORT, "ElWriteToPort: Error %d", dwRetCode);

            // Decrement refcount incremented in this function, 
            // since it will not be decremented in WriteCompletionRoutine 
            // as it will never be called.

            EAPOL_DEREFERENCE_PORT(pPCB); 
            TRACE2 (PORT, "ElWriteToPort: pPCB= %p, RefCnt = %ld", 
                    pPCB, pPCB->dwRefCount);

            return dwRetCode;
        }
    }

    //TRACE1 (PORT, "ElWriteToPort completed, dwRetCode =%d", dwRetCode);
    return dwRetCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elport.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elport.h

Abstract:
    This module contains declarations for port management for EAPOL, 
    r/w to ports


Revision History:

    sachins, Apr 23 2000, Created

--*/


#ifndef _EAPOL_PORT_H_
#define _EAPOL_PORT_H_

//
// EAPOL PCB Flags
//

#define EAPOL_PORT_FLAG_DELETED     0x8000
#define EAPOL_PORT_DELETED(i) \
    ((i)->dwFlags & EAPOL_PORT_FLAG_DELETED)

#define EAPOL_PORT_FLAG_ACTIVE      0x4000
#define EAPOL_PORT_ACTIVE(i) \
        ((i)->dwFlags & EAPOL_PORT_FLAG_ACTIVE)

//
// EAPOL Timer Flags
//

#define EAPOL_AUTH_TIMER            0x8000
#define EAPOL_AUTH_TIMER_SET(i) \
    ((i)->dwTimerFlags & EAPOL_AUTH_TIMER)

#define EAPOL_HELD_TIMER            0x4000
#define EAPOL_HELD_TIMER_SET(i) \
    ((i)->dwTimerFlags & EAPOL_HELD_TIMER)

#define EAPOL_START_TIMER           0x2000
#define EAPOL_START_TIMER_SET(i) \
    ((i)->dwTimerFlags & EAPOL_START_TIMER)

#define EAPOL_NO_TIMER              0x0000
#define EAPOL_NO_TIMER_SET(i) \
    ((i)->dwTimerFlags & EAPOL_NO_TIMER)

#define SET_EAPOL_AUTH_TIMER(i) \
    ((i)->dwTimerFlags = EAPOL_AUTH_TIMER)

#define SET_EAPOL_HELD_TIMER(i) \
    ((i)->dwTimerFlags = EAPOL_HELD_TIMER)

#define SET_EAPOL_START_TIMER(i) \
    ((i)->dwTimerFlags = EAPOL_START_TIMER)

#define SET_EAPOL_NO_TIMER(i) \
    ((i)->dwTimerFlags = EAPOL_NO_TIMER)

#define CHECK_EAPOL_TIMER(i) \
    ((i)->dwTimerFlags & (EAPOL_AUTH_TIMER|EAPOL_HELD_TIMER|EAPOL_START_TIMER))


//
// Structure:   EAPOL_PCB
//
// EAPOL Port Control Block
// This structure holds the operational information for an interface/port
// from the EAPOL protocol standpoint.
// It also maintains state information for EAP protocol.
//
// Each PCB is inserted in a hash bucket list, one for each interface
//
// Synchronization on PCBs is done using a read-write PCB list lock, 
// and a per-PCB read-write lock, and a per-port ref count. 
// The locks are single-write, multiple-read. Currently, locks are used 
// in write mode only
//
// If PCB's are to be added or deleted, the PCB list lock should 
// be acquired. 
//
// If any PCB needs to be modified, the per-PCB list lock should be acquired
// in write mode. 
//
// Acquiring a reference to a port guarantees the PCBs existence;
// acquiring the PCB lock guarantees consistency of the PCB fields
//
//

typedef struct _EAPOL_PCB 
{
    // Pointer to next PCB in the hash bucket
    struct _EAPOL_PCB       *pNext;         

    // Handle to NDIS UIO device
    HANDLE                  hPort;          

    // Port number on the system Will be an integer value cast
    DWORD                   dwPortIndex;    

    // Friendly name of the interface on which this port is opened
    CHAR                    *pszFriendlyName;

    // GUID string uniquely identifying the interface 
    CHAR                    *pszDeviceGUID;   

    // Additional identiifier for a connected port e.g. MSFTWLAN
    CHAR                    *pszSSID;       

    // Version of EAPOL supported on this port 
    DWORD                   dwEapolVersion; 

    // Pointer to EAP Work Buffer for this PCB
    PVOID                   pEapWorkBuffer; 

    // Per PCB read-write lock
    READ_WRITE_LOCK         rwLock;         

    // Number of references made to this port
    DWORD                   dwRefCount;

    // Indicates whether port is ACTIVE or DISABLED
    DWORD                   dwFlags;

    // EAPOL state
    EAPOL_STATE             State;

    // EAPOL statistics for this port     
    EAPOL_STATS             EapolStats;     

    // EAPOL configuration parameters for this port
    EAPOL_CONFIG            EapolConfig;    

    // Version of EAPOL supported
    BYTE                    bProtocolVersion;   
    
    // Handle to EAPOL timer currently running on this machine
    HANDLE                  hTimer;         

    // Ethertype for this LAN
    BYTE                    bEtherType[SIZE_ETHERNET_TYPE];   
    
    // Mac Addr of peer (switch port access point)
    BYTE                    bSrcMacAddr[SIZE_MAC_ADDR];  

    // Mac Addr of peer (switch port or access point)
    BYTE                    bDestMacAddr[SIZE_MAC_ADDR]; 

    // Media State
    NDIS_MEDIA_STATE        MediaState;

    // Physical Medium Type
    NDIS_PHYSICAL_MEDIUM    PhysicalMediumType;

    DWORD                   dwTimerFlags;

    // Time in milliseconds next timeout should occur
    ULONG                   ulTimeout;      

    // Number of EAPOL_Start messages that have been sent without
    // receiving response    
    ULONG                   ulStartCount;   

    // Identifier in the most recently received EAP Request frame
    DWORD                   dwPreviousId; 

    // Copy of last sent out EAPOL packet
    // Used for retransmission
    BYTE                    *pbPreviousEAPOLPkt;
    DWORD                   dwSizeOfPreviousEAPOLPkt;

    // Has Identity for the user obtained using RasEapGetIdentity ?
    BOOL                    fGotUserIdentity;

    // Is the port on a authenticated network i.e. is the remote end
    // EAPOL aware
    BOOL                    fIsRemoteEndEAPOLAware;

    //
    // EAP related variables
    //

    BOOL                    fEapInitialized;

    BOOL                    fLogon;

    BOOL                    fUserLoggedIn;

    // Authentication identity using RasGetUserIdentity or other means
    CHAR                    *pszIdentity;

    // User Password for EAP MD5 CHAP
    CHAR                    *pszPassword;

    // Token for interactively logged-on user obtained using 
    // GetCurrentUserToken
    HANDLE                  hUserToken;             

    // EAP configuration blob stored for each GUID
    EAPOL_CUSTOM_AUTH_DATA  *pCustomAuthConnData;    

    // User blob stored for GUID 
    EAPOL_CUSTOM_AUTH_DATA  *pCustomAuthUserData;    

    // Data obtained using RasEapInvokeInteractiveUI
    EAPOL_EAP_UI_DATA       EapUIData;                  

    // Interactive data received from InvokeInteractiveUI
    BOOL                    fEapUIDataReceived;                  

    // EAP type for the connection
    DWORD                   dwEapTypeToBeUsed;      
                                                        
    // Index for current EAP type in index table
    DWORD                   dwEapIndex;             
                                                        
    // Unique identifier for UI invocation
    DWORD                   dwUIInvocationId;       

    // Interactive dialog allowed?
    BOOL                    fNonInteractive;        

    // EAP state for the port
    EAPSTATE                EapState;           
     
    // Work space for EAP implementation DLL
    // PCB just holds the pointer, the memory allocation is done by the EAP DLL
    // during RasEapBegin and should be passed to RasEapEnd for cleanup
    LPVOID                  lpEapDllWorkBuffer;  
                                                
    // Notification message
    CHAR                    *pszEapReplyMessage;     

    // Encryption keys
    BYTE                    *pbMPPESendKey;
    DWORD                   dwMPPESendKeyLength;
    BYTE                    *pbMPPERecvKey;
    DWORD                   dwMPPERecvKeyLength;
    
    // Last replay counter. Used to guard against security attacks
    ULONGLONG               ullLastReplayCounter; 

    // EAPOL to run on this port or not
    DWORD                   dwEapolEnabled;

    // Has EAPOL_Logoff packet been sent out on this port?
    DWORD                   dwLogoffSent;

    // Authentication type last performed - Used with MACHINE_AUTH
    EAPOL_AUTHENTICATION_TYPE       PreviousAuthenticationType; 

    // Number of current authentication failures for the port - MACHINE_AUTH
    DWORD                   dwAuthFailCount;

    // Is authentication being done on a new AP/Switch/Network?
    BOOLEAN                 fAuthenticationOnNewNetwork;

    // Tick count, the last time the port was restart
    DWORD                   dwLastRestartTickCount;

    // Implementation version supported by remote end
    // Default is Draft 7, Draft 8 if detected
    BOOLEAN                 fRemoteEnd8021XD8;

} EAPOL_PCB, *PEAPOL_PCB;


//
// Structure: ETH_HEADER
//

typedef struct _ETH_HEADER 
{
    BYTE            bDstAddr[SIZE_MAC_ADDR];
    BYTE            bSrcAddr[SIZE_MAC_ADDR];
} ETH_HEADER, *PETH_HEADER;


//
// Structure:   EAPOL_BUFFER
//
// This structure holds a buffer used for I/O to the ndis uio driver
// EAPOL_BUFFER structure is used in the OVERLAPPED read-write operations. 
// On the OVERLAPPED read/write completion, pvContext is used to 
// identity the port on which the I/O occured
//

typedef struct _EAPOL_BUFFER 
{
    //
    // This is the pointer to the EAPOL_PCB structure of the interface on which 
    // I/O was performed
    //
    PVOID pvContext;

    // Send/Recv data buffer

    CHAR  pBuffer[MAX_PACKET_SIZE]; 
    
    //
    // Passed as the system context area for any I/O using the buffer
    //        
    OVERLAPPED Overlapped;

    //
    // Pointer to Completion Routine
    // 
    VOID    (CALLBACK *CompletionRoutine)
                    (DWORD, DWORD, struct _EAPOL_BUFFER *);

    // Fields which are filled on IoCompletion
    DWORD   dwErrorCode;
    DWORD   dwBytesTransferred;
    
} EAPOL_BUFFER, *PEAPOL_BUFFER;


//
// Synchronization
//
#define EAPOL_REFERENCE_PORT(PCB) \
    (EAPOL_PORT_DELETED(PCB) ? FALSE : (InterlockedIncrement(&(PCB)->dwRefCount), TRUE))

#define EAPOL_DEREFERENCE_PORT(PCB) \
    (InterlockedDecrement(&(PCB)->dwRefCount) ? TRUE : (ElCleanupPort(PCB), FALSE))


//
// FUNCTION DECLARATIONS
//

DWORD
ElHashPortToBucket (
        IN  CHAR             *pszDeviceGUID
        );

VOID
ElRemovePCBFromTable (
        IN  EAPOL_PCB        *pPCB
        );

PEAPOL_PCB
ElGetPCBPointerFromPortGUID (
        IN CHAR             *pszDeviceGUID
        );

DWORD
ElCreatePort (
        IN  HANDLE          hDevice,
        IN  CHAR            *pszGUID,
        IN  CHAR            *pszFriendlyName,
        IN  BYTE            *psSrcMacAddr
        );

DWORD
ElDeletePort (
        IN  CHAR            *pszDeviceName,
        OUT HANDLE          *hDevice
        );

VOID
ElCleanupPort (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElReStartPort (
        IN  PEAPOL_PCB      pPCB
        );

DWORD
ElReadFromPort (
        IN PEAPOL_PCB       pPCB,
        IN PCHAR            pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElWriteToPort (
        IN PEAPOL_PCB       pPCB,
        IN PCHAR            pBuffer,
        IN DWORD            dwBufferLength
        );

DWORD
ElInitializeEAPOL (
        );

DWORD
ElEAPOLDeInit (
        );

VOID
ElReadPortStatistics (
        IN  CHAR            *pszDeviceName,
        OUT PEAPOL_STATS    pEapolStats
        );

VOID
ElReadPortConfiguration (
        IN  CHAR            *pszDeviceName,
        OUT PEAPOL_CONFIG   pEapolConfig
        );

ULONG
ElSetPortConfiguration (
        IN  CHAR            *pszDeviceName,
        IN  PEAPOL_CONFIG   pEapolConfig
        );

VOID CALLBACK
ElReadCompletionRoutine (
        IN  DWORD           dwError,
        IN  DWORD           dwBytesReceived,
        IN  PEAPOL_BUFFER   pEapolBuffer 
        );

VOID CALLBACK
ElWriteCompletionRoutine (
        IN  DWORD           dwError,
        IN  DWORD           dwBytesSent,
        IN  PEAPOL_BUFFER   pEapolBuffer 
        );

VOID CALLBACK
ElIoCompletionRoutine (
        IN  DWORD           dwError,
        IN  DWORD           dwBytesTransferred,
        IN  LPOVERLAPPED    lpOverlapped
        );

DWORD
ElReadPerPortRegistryParams(
        IN  CHAR            *pszDeviceGUID,
        IN  EAPOL_PCB       *pNewPCB
        );


#endif  // _EAPOL_PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elprotocol.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elprotocol.h

Abstract:
    This module contains definitions and declarations related to EAPOL 
    protocol


Revision History:

    sachins, Apr 30 2000, Created

--*/

#ifndef _EAPOL_PROTOCOL_H_
#define _EAPOL_PROTOCOL_H_

//
// EAPOL packet types
//
typedef enum _EAPOL_PACKET_TYPE 
{
    EAP_Packet = 0,              
    EAPOL_Start,            
    EAPOL_Logoff,          
    EAPOL_Key            
} EAPOL_PACKET_TYPE;

//
// Authorization Result Code
//
typedef enum _AUTH_RESULT_CODE
{
    AUTH_Continuing = 0,              
    AUTH_Authorized,
    AUTH_Unauthorized,
    AUTH_Unknown
} AUTH_RESULT_CODE;

//
// Structure: EAPOL_PACKET
//

typedef struct _EAPOL_PACKET 
{
    BYTE        EthernetType[2];
    BYTE        ProtocolVersion;
    BYTE        PacketType;
    BYTE        PacketBodyLength[2];
    BYTE        PacketBody[1];
} EAPOL_PACKET, *PEAPOL_PACKET;

typedef struct _EAPOL_PACKET_D8
{
    BYTE        EthernetType[2];
    BYTE        ProtocolVersion;
    BYTE        PacketType;
    BYTE        AuthResultCode[2];
    BYTE        PacketBodyLength[2];
    BYTE        PacketBody[1];
} EAPOL_PACKET_D8, *PEAPOL_PACKET_D8;

typedef struct _EAPOL_PACKET_D8_D7
{
    BYTE        AuthResultCode[2];
    BYTE        EthernetType[2];
    BYTE        ProtocolVersion;
    BYTE        PacketType;
    BYTE        PacketBodyLength[2];
    BYTE        PacketBody[1];
} EAPOL_PACKET_D8_D7, *PEAPOL_PACKET_D8_D7;

//
// Structure: EAPOL_KEY_PACKET
//

typedef struct _EAPOL_KEY_DESCRIPTOR 
{
    BYTE        SignatureType;
    BYTE        EncryptType;
    BYTE        KeyLength[2];
    BYTE        ReplayCounter[8];
    BYTE        Key_IV[16];
    BYTE        KeyIndex;
    BYTE        KeySignature[16];
    BYTE        Key[1];
} EAPOL_KEY_DESC, *PEAPOL_KEY_DESC;

typedef struct _EAPOL_KEY_DESCRIPTOR_D8 
{
    BYTE        DescriptorType;
    BYTE        KeyLength[2];
    BYTE        ReplayCounter[8];
    BYTE        Key_IV[16];
    BYTE        KeyIndex;
    BYTE        KeySignature[16];
    BYTE        Key[1];
} EAPOL_KEY_DESC_D8, *PEAPOL_KEY_DESC_D8;

// 
// CONSTANTS
//

#define MAX_EAPOL_PACKET_TYPE          EAPOL_Key

//
// FUNCTION DECLARATIONS
//

VOID
ElProcessReceivedPacket (
        IN  PVOID           pvContext
        );

DWORD
FSMDisconnected (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
FSMLogoff (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
FSMConnecting (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
FSMAcquired (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        );

DWORD
FSMAuthenticating (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        );

DWORD
FSMHeld (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
FSMAuthenticated (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        );

DWORD
FSMRxKey (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        );

VOID 
ElTimeoutCallbackRoutine (
        IN  PVOID           pvContext,
        IN  BOOLEAN         fTimerOfWaitFired
        );

DWORD
ElEapWork (
        IN  EAPOL_PCB       *pPCB,
        IN  PPP_EAP_PACKET  *pRecvPkt
        );

DWORD
ElExtractMPPESendRecvKeys (
        IN  EAPOL_PCB               *pPCB, 
        IN  RAS_AUTH_ATTRIBUTE      *pUserAttributes,
        IN  BYTE                    *pChallenge,
        IN  BYTE                    *pResponse
        );

DWORD
ElProcessEapSuccess (
        IN EAPOL_PCB        *pPCB,
        IN EAPOL_PACKET     *pEapolPkt
    );

DWORD
ElProcessEapFail (
        IN EAPOL_PCB        *pPCB,
        IN EAPOL_PACKET     *pEapolPkt
    );

#endif  // _EAPOL_PROTOCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\ellogon.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:


Abstract:



Revision History:

    timmoore, sachins, May 19 2000, Created

--*/

#include "pcheapol.h"

#pragma hdrstop


LONG_PTR FAR PASCAL 
WndProc(
        HWND hWnd, 
        unsigned message, 
        WPARAM wParam, 
        LPARAM lParam
        );

#define TASK_BAR_CREATED    L"TaskbarCreated"

TCHAR                       EAPOLClassName[] = TEXT("EAPOLClass");

UINT                        g_TaskbarCreated;
HWND                        g_hWnd = 0;
HINSTANCE                   g_hInstance;
HANDLE                      g_UserToken;

HWINSTA                     hWinStaUser = 0;
HWINSTA                     hSaveWinSta = 0;
HDESK                       hDeskUser = 0;
HDESK                       hSaveDesk = 0;


//
// WindowInit
//
// Description:
//
// Function called create the taskbar used to detect user logon/logoff
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
WindowInit ()
{
    WNDCLASS        Wc;
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into WindowInit ========================\n");

    do
    {
	    if ((g_TaskbarCreated = RegisterWindowMessage(TASK_BAR_CREATED)) 
			== 0)
	    {
            	dwRetCode = GetLastError ();
		TRACE1 (ANY, "WindowInit: RegisterWindowMessage failed with error %ld\n",
		dwRetCode);
            	break;
	    }

        TRACE1 (ANY, "WindowInit: TaskbarCreated id = %ld", 
                g_TaskbarCreated);

        // save current desktop and window station
        // so that it can be restored when we shutdown
        
        if ((hSaveWinSta = GetProcessWindowStation()) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: GetProcessWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
    
        if ((hSaveDesk = GetThreadDesktop(GetCurrentThreadId())) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: GetThreadDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        // Open the current user's window station and desktop
     
        if ((hWinStaUser = OpenWindowStation(L"WinSta0", FALSE, MAXIMUM_ALLOWED)) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: OpenWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        if (!SetProcessWindowStation(hWinStaUser))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: SetProcessWindowStation failed with error %ld\n",
                    dwRetCode);
            break;
        }
        else 
        {
		    TRACE0 (ANY, "WindowInit: SetProcessWindowStation succeeded\n");
        }
    
        if ((hDeskUser = OpenDesktop(L"Default", 0 , FALSE, MAXIMUM_ALLOWED))
                == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: OpenDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
     
        if (!SetThreadDesktop(hDeskUser))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: SetThreadDesktop failed with error %ld\n",
                    dwRetCode);
            break;
        }
        else
        {
            TRACE0 (ANY, "WindowInit: SetThreadDesktop succeeded\n");
        }
    
        //
        // Register the class for the window
        //

	    Wc.style            = CS_NOCLOSE;
	    Wc.cbClsExtra       = 0;
	    Wc.cbWndExtra       = 0;
	    Wc.hInstance        = g_hInstance;
	    Wc.hIcon            = NULL;
	    Wc.hCursor          = NULL;
	    Wc.hbrBackground    = NULL;
	    Wc.lpszMenuName     = NULL;
	    Wc.lpfnWndProc      = WndProc;
	    Wc.lpszClassName    = EAPOLClassName;
    
	    if (!RegisterClass(&Wc))
	    {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: RegisterClass failed with error %ld\n",
                    dwRetCode);
            if (dwRetCode == ERROR_CLASS_ALREADY_EXISTS)
            {
                dwRetCode = NO_ERROR;
            }
            else
            {
                break;
            }
	    }

	    // Create the window that will receive the taskbar menu messages.
	    // The window has to be created after opening the user's desktop
    
	    if ((g_hWnd = CreateWindow(
                EAPOLClassName,
		        L"EAPOLWindow",
		        WS_OVERLAPPEDWINDOW,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        CW_USEDEFAULT,
		        NULL,
		        NULL,
		        g_hInstance,
		        NULL)) == NULL)
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: CreateWindow failed with error %ld\n",
                    dwRetCode);
            break;
        }

        // We don't care about the return value, since we just want it to
        // be hidden and it will always succeed

	    ShowWindow(g_hWnd, SW_HIDE);
    
	    if (!UpdateWindow(g_hWnd))
        {
            dwRetCode = GetLastError ();
		    TRACE1 (ANY, "WindowInit: UpdateWindow failed with error %ld\n",
                    dwRetCode);
            break;
        }
    
        TRACE0 (ANY, "WindowInit: CreateWindow succeeded\n");

    } while (FALSE);

    return dwRetCode;
    
}


//
// WindowShut
//
// Description:
//
// Function called to delete the task bar created to detect user logon/logoff
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
WindowShut ()
{
    DWORD       dwRetCode = NO_ERROR;

    do
    {

        if (g_hWnd)
        {
            if (!DestroyWindow (g_hWnd))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: DestroyWindow failed with error %ld\n",
                        dwRetCode);
                // log
            }
        }

        if (g_hInstance)
        {
            if (!UnregisterClass (
                    EAPOLClassName,
                    g_hInstance))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: UnregisterClass failed with error %ld\n",
                        dwRetCode);
                // log
            }
            g_hInstance = NULL;
        }
            
        if (hDeskUser)
        {
            if (CloseDesktop(hDeskUser) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseDesktop-hDeskUser failed with error %ld\n",
                        dwRetCode);
                // log
            }
            hDeskUser = 0;
        }
     
        if (hWinStaUser)
        {
            if (CloseWindowStation(hWinStaUser) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseWindowStation-hWinStaUser failed with error %ld\n",
                        dwRetCode);
                // log
            }
            hWinStaUser = 0;
        }


        if (hSaveDesk)
        {
            if (!SetThreadDesktop(hSaveDesk))
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: SetThreadDesktop failed with error %ld\n",
                        dwRetCode);
                // log
            }
    
            if (hSaveWinSta)
            {
                if (SetProcessWindowStation(hSaveWinSta) == 0)
                {
                    TRACE1 (ANY, "WindowShut: SetProcessWindowStation failed with error %ld\n",
                            dwRetCode);
                    dwRetCode = GetLastError ();
                    // log
                }
            }
     
            if (CloseDesktop(hSaveDesk) == 0)
            {
                dwRetCode = GetLastError ();
		        TRACE1 (ANY, "WindowShut: CloseDesktop-hSaveDesk failed with error %ld\n",
                        dwRetCode);
                // log
            }

            hSaveDesk = 0;
     
            if (hSaveWinSta)
            {
                if (CloseWindowStation(hSaveWinSta) == 0)
                {
                    dwRetCode = GetLastError ();
		            TRACE1 (ANY, "WindowShut: CloseWindowStation-hSaveWinSta failed with error %ld\n",
                            dwRetCode);
                    // log
                }
                hSaveWinSta = 0;
            }

        }
    } while (FALSE);

    return dwRetCode;

}


//
// UserLogon
//
// Description:
//
// Function called to do processing when user logs on
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
UserLogon ()
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into UserLogon ===================\n");

    do 
    {
        ElUserLogonCallback (
                NULL,
                TRUE
                );
        TRACE0 (ANY, "UserLogon: ElUserLogonCallback completed");

    } while (FALSE);

    return dwRetCode;

}


//
// UserLogoff
//
// Description:
//
// Function called to do processing when user logs off
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
UserLogoff ()
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (ANY, "Came into UserLogoff ===================\n");

    do 
    {
        ElUserLogoffCallback (
                NULL,
                TRUE
                );
        TRACE0 (ANY, "UserLogoff: ElUserLogoffCallback completed");

    } while (FALSE);

    return dwRetCode;
}


//
// ElWaitOnEvent
//
// Description:
//
// Function called to wait on taskbar event changes
//
// Arguments:
//
// Return values:
//      NO_ERROR - success 
//      NON-zero - error
//

DWORD 
ElWaitOnEvent () 
{
    MSG         Msg;
    HANDLE      hEvents[1];
    BOOL        fExitThread = FALSE;
    DWORD       dwStatus = NO_ERROR;
    DWORD       dwRetCode = NO_ERROR;

    // Check if 802.1X service has stopped
    // Exit if so

    if (( dwStatus = WaitForSingleObject (
                g_hEventTerminateEAPOL,
                0)) == WAIT_FAILED)
    {
        dwRetCode = GetLastError ();
        if ( g_dwTraceId != INVALID_TRACEID )
	    {
            TRACE1 (INIT, "ElWaitOnEvent: WaitForSingleObject failed with error %ld, Terminating cleanup",
                dwRetCode);
        }

        // log

        return dwRetCode;
    }

    if (dwStatus == WAIT_OBJECT_0)
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            dwRetCode = NO_ERROR;
            TRACE0 (INIT, "ElWaitOnEvent: g_hEventTerminateEAPOL already signaled, returning");
        }
        return dwRetCode;
    }

    if (!g_dwMachineAuthEnabled)
    {
	    if ((dwRetCode = UserLogon()) != NO_ERROR)
        {
            TRACE1 (ANY, "ElWaitOnEvent: UserLogon failed with error %ld",
                    dwRetCode);
            return dwRetCode;
        }
    }

    do
    {
		do 
        {
            hEvents[0] = g_hEventTerminateEAPOL;

			dwStatus = MsgWaitForMultipleObjects(
                            1, 
                            hEvents, 
                            FALSE, 
                            INFINITE, 
                            QS_ALLINPUT | QS_ALLEVENTS | QS_ALLPOSTMESSAGE);

            if (dwStatus == WAIT_FAILED)
            {
                dwRetCode = GetLastError ();
                TRACE1 (ANY, "ElWaitOnEvent: MsgWaitForMultipleObjects failed with error %ld",
                        dwRetCode);
                // log
                break;
            }

			switch (dwStatus)
			{
			    case WAIT_OBJECT_0:
                    // Service exit detected
                    fExitThread = TRUE;
                    TRACE0 (ANY, "ElWaitOnEvent: Service exit detected");
				    break;

			    default:
				    while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))
				    {
					    if (Msg.message == WM_QUIT)
					    {
						    break;
					    }
    
                        TRACE3 (ANY, "ElWaitonEvent: Mesg %ld, wparam %lx, lparam %lx",
                                (DWORD)Msg.message, Msg.wParam, Msg.lParam);
					    if (!IsDialogMessage(g_hWnd, &Msg))
					    {
						    TranslateMessage(&Msg);
						    DispatchMessage(&Msg);
					    }
                    }
                    break;
            }

		} while (dwStatus != WAIT_OBJECT_0);

        if ((dwRetCode != NO_ERROR) || (fExitThread))
        {
            TRACE0 (ANY, "ElWaitOnEvent: Exit wait loop");
            break;
        }

    } while (TRUE);

    return dwRetCode;

}


//
// WndProc
//
// Description:
//
// Function called to process taskbar events
//
// Arguments:
//
// Return values:
//

LONG_PTR FAR PASCAL 
WndProc (
        IN  HWND        hWnd, 
        IN  unsigned    message, 
        IN  WPARAM      wParam, 
        IN  LPARAM      lParam
        )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE1 (ANY, "WndProc: Came into WndProc %ld", (DWORD)message );

    switch (message)
    {
        case WM_ENDSESSION:
			TRACE2 (ANY, "WndProc: Endsession (logoff) %x %x\n", 
                    wParam, lParam);
			if(wParam)
            {
                // Only user session logoff
                if (lParam & ENDSESSION_LOGOFF)
                {
				    if ((dwRetCode = UserLogoff()) != NO_ERROR)
                    {
                        TRACE1 (ANY, "WndProc: UserLogoff failed with error %ld",
                                dwRetCode);
                    }
                }
            }
            break;

        default:
            if (message == g_TaskbarCreated)
            {
				TRACE0 (ANY, "WndProc: Taskbar created (Logon)\n");
				if ((dwRetCode = UserLogon()) != NO_ERROR)
                {
                    TRACE1 (ANY, "WndProc: UserLogon failed with error %ld",
                            dwRetCode);
                }
            }
    }

    return (DefWindowProc(hWnd, message, wParam, lParam));
}


//
// ElUserLogonDetection
//
// Description:
//
// Function called to initialize module detecting user logon/logoff
//
// Arguments:
//      pvContext - Unused
//
// Return values:
//

VOID 
ElUserLogonDetection (
        PVOID pvContext
        )
{
    DWORD       dwRetCode = NO_ERROR;

    do 
    {

        if ((dwRetCode = WindowInit()) != NO_ERROR)
        {
            break;
        }


        if ((dwRetCode = ElWaitOnEvent()) != NO_ERROR)
        {
            // no action
        }

    } while (FALSE);

    dwRetCode = WindowShut();

    if (dwRetCode != NO_ERROR)
    {
        TRACE1 (ANY, "ElUserLogonDetection: Error in processing = %ld",
                dwRetCode);
        // log
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elsync.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    elsync.h

Abstract:
    This module contains the declarations for providing synchronization 
    between multiple threads

Revision History:

    mohitt, sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_SYNC_H_
#define _EAPOL_SYNC_H_

//
// Structure: READ_WRITE_LOCK
//

typedef struct _READ_WRITE_LOCK
{
    CHAR                RWL_Name[4]; // overhead! but useful :)
    
    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;
} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

//
// FUNCTION DECLARATIONS
//

DWORD
CreateReadWriteLock(
    OUT PREAD_WRITE_LOCK   pRWL,
    IN  PCHAR               szName);

VOID
DeleteReadWriteLock(
    IN  PREAD_WRITE_LOCK    pRWL);

VOID
AcquireReadLock(
    IN  PREAD_WRITE_LOCK    pRWL);

VOID
ReleaseReadLock(
    IN  PREAD_WRITE_LOCK    pRWL);

VOID
AcquireWriteLock(
    IN  PREAD_WRITE_LOCK    pRWL);

VOID
ReleaseWriteLock(
    IN  PREAD_WRITE_LOCK    pRWL);

#define CREATE_READ_WRITE_LOCK(pRWL, szName)                        \
    CreateReadWriteLock(pRWL, szName)
#define DELETE_READ_WRITE_LOCK(pRWL)                                \
    DeleteReadWriteLock(pRWL)
#define READ_WRITE_LOCK_CREATED(pRWL)                               \
    ((pRWL)->RWL_ReaderDoneEvent != NULL)

// MACRO functions for manipulating a read-write lock

#define ACQUIRE_READ_LOCK(pRWL)                                 \
{                                                               \
    TRACE1(LOCK, "+R: %.3s", (pRWL)->RWL_Name);                   \
    AcquireReadLock(pRWL);                                      \
    TRACE0(LOCK, "Done.");                                      \
}
        
#define RELEASE_READ_LOCK(pRWL)                                 \
{                                                               \
    TRACE1(LOCK, "-R: %.3s", (pRWL)->RWL_Name);                   \
    ReleaseReadLock(pRWL);                                      \
    TRACE0(LOCK, "Done.");                                      \
}

#define ACQUIRE_WRITE_LOCK(pRWL)                                \
{                                                               \
    TRACE1(LOCK, "+W: %.3s", (pRWL)->RWL_Name);                   \
    AcquireWriteLock(pRWL);                                     \
    TRACE0(LOCK, "Done.");                                      \
}

#define RELEASE_WRITE_LOCK(pRWL)                                \
{                                                               \
    TRACE1(LOCK, "-W: %.3s", (pRWL)->RWL_Name);                   \
    ReleaseWriteLock(pRWL);                                     \
    TRACE0(LOCK, "Done.");                                      \
}


//
// MACRO functions for manipulating a dynamic read-write lock
//

#define ACQUIRE_READ_DLOCK(ppLock)                              \
{                                                               \
    TRACE1(LOCK, "+R: %s", LOCKSTORE->szName);                  \
    while(                                                      \
    AcquireDynamicReadwriteLock(ppLock, READ_MODE, LOCKSTORE)   \
    != NO_ERROR) { Sleep(SECTOMILLISEC(DELTA)); }               \
    TRACE0(LOCK, "Done.");                                      \
}

#define RELEASE_READ_DLOCK(ppLock)                              \
{                                                               \
    TRACE1(LOCK, "-R: %s", LOCKSTORE->szName);                  \
    ReleaseDynamicReadwriteLock(ppLock, READ_MODE, LOCKSTORE);  \
    TRACE0(LOCK, "Done.");                                      \
}

#define ACQUIRE_WRITE_DLOCK(ppLock)                             \
{                                                               \
    TRACE1(LOCK, "+W: %s", LOCKSTORE->szName);                  \
    while(                                                      \
    AcquireDynamicReadwriteLock(ppLock, WRITE_MODE, LOCKSTORE)  \
    != NO_ERROR) { Sleep(SECTOMILLISEC(DELTA)); }               \
    TRACE0(LOCK, "Done.");                                      \
}

#define RELEASE_WRITE_DLOCK(ppLock)                             \
{                                                               \
    TRACE1(LOCK, "-W: %s", LOCKSTORE->szName);                  \
    ReleaseDynamicReadwriteLock(ppLock, WRITE_MODE, LOCKSTORE); \
    TRACE0(LOCK, "Done.");                                      \
}


//
// STRUCTURE: LOCKED_LIST
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST
{
    CHAR                name[4];

    CRITICAL_SECTION    lock;
    LIST_ENTRY          head;
    DWORD               created;
} LOCKED_LIST, *PLOCKED_LIST;

#define INITIALIZE_LOCKED_LIST(pLL, szName)                         \
{                                                                   \
    do                                                              \
    {                                                               \
        sprintf((pLL)->name, "%.3s", szName);                       \
        __try {                                                     \
            InitializeCriticalSection(&((pLL)->lock));              \
        }                                                           \
        __except (EXCEPTION_EXECUTE_HANDLER) {                      \
            break;                                                  \
        }                                                           \
        InitializeListHead(&((pLL)->head));                         \
        (pLL)->created = 0x12345678;                                \
    } while (FALSE);                                                \
}

#define LOCKED_LIST_INITIALIZED(pLL)                                \
     ((pLL)->created == 0x12345678)

#define DELETE_LOCKED_LIST(pLL, FreeFunction)                       \
{                                                                   \
     (pLL)->created = 0;                                            \
     FreeList(&((pLL)->head), FreeFunction);                        \
     DeleteCriticalSection(&(pLL)->lock);                           \
}

#define AcquireListLock(pLL)    EnterCriticalSection(&(pLL)->lock)
#define ReleaseListLock(pLL)    LeaveCriticalSection(&(pLL)->lock)


#define LOCKED_QUEUE    LOCKED_LIST
#define PLOCKED_QUEUE   PLOCKED_LIST

         
#define INITIALIZE_LOCKED_QUEUE(pLQ, szName)                        \
     INITIALIZE_LOCKED_LIST(pLQ, szName)
#define LOCKED_QUEUE_INITIALIZED(pLQ)                               \
     LOCKED_LIST_INITIALIZED(pLQ)
#define DELETE_LOCKED_QUEUE(pLQ, FreeFunction)                      \
     DELETE_LOCKED_LIST(pLQ, FreeFunction)



//
// STRUCTURE: DYNAMIC_READWRITE_LOCK
//

typedef struct _DYNAMIC_READWRITE_LOCK 
{
    READ_WRITE_LOCK     rwlLock;
    union
    {
        ULONG           ulCount;    // number of waiting threads
        LIST_ENTRY      leLink;     // link in list of free locks
    };
} DYNAMIC_READWRITE_LOCK, *PDYNAMIC_READWRITE_LOCK;

//
// STRUCTURE: DYNAMIC_LOCKS_STORE
// store of free dynamic locks that can be allocated as required.
//

typedef struct _DYNAMIC_LOCKS_STORE 
{
    CHAR                szName[4];
    
    HANDLE              hHeap;
    
    LOCKED_LIST         llFreeLocksList;

    ULONG               ulCountAllocated;
    ULONG               ulCountFree;
} DYNAMIC_LOCKS_STORE, *PDYNAMIC_LOCKS_STORE;



// if more than DYNAMIC_LOCKS_HIGH_THRESHOLD locks are
// allocated then any locks that are freed are destroyed
#define DYNAMIC_LOCKS_HIGH_THRESHOLD 7

#define DYNAMIC_LOCKS_STORE_INITIALIZED(pStore)                     \
    (LOCKED_LIST_INITIALIZED(&(pStore)->llFreeLocksList))

typedef enum { READ_MODE, WRITE_MODE } LOCK_MODE;

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore,
    HANDLE                  hHeap,
    PCHAR                   szName
    );

DWORD
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore
    );

DWORD
AcquireDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

VOID
ReleaseDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    );

#endif // _EAPOL_SYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elprotocol.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    elprotocol.c

Abstract:
    This module implements functions related to EAPOL 
    protocol


Revision History:

    sachins, Apr 30 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

#define EAPOL_SERVICE

#ifndef EAPOL_SERVICE

HRESULT 
EAPOLMANAuthenticationStarted (
        REFGUID InterfaceId
);

HRESULT 
EAPOLMANAuthenticationSucceeded (
        REFGUID InterfaceId
);

HRESULT 
EAPOLMANAuthenticationFailed ( 
        REFGUID InterfaceId,
        DWORD dwType
);

HRESULT EAPOLMANNotification(
        REFGUID InterfaceId,
        LPWSTR szwNotificationMessage,
        DWORD dwType
);

#endif

//
// ElProcessReceivedPacket
//
// Description:
//
//      Function called to process data received from the NDISUIO driver.
//      The EAPOL packet is extracted and further processing is done.
//
//
// Arguments:
//      pvContext - Context buffer which is a pointer to EAPOL_BUFFER structure
//
// Return Values:
//

VOID 
ElProcessReceivedPacket (
        IN  PVOID   pvContext
        )
{
    EAPOL_PCB       *pPCB = NULL;
    EAPOL_BUFFER    *pEapolBuffer = NULL;
    DWORD           dwLength = 0;
    ETH_HEADER      *pEthHdr = NULL;
    EAPOL_PACKET    *pEapolPkt = NULL;
    EAPOL_PACKET_D8 *pEapolPktD8 = NULL;
    BOOLEAN         fRemoteEnd8021XD8 = FALSE;
    PPP_EAP_PACKET  *pEapPkt = NULL;
    BYTE            *pBuffer;
    BOOLEAN         ReqId = FALSE;      // EAPOL state machine local variables
    BOOLEAN         ReqAuth = FALSE;
    BOOLEAN         EapSuccess = FALSE;
    BOOLEAN         EapFail = FALSE;
    BOOLEAN         RxKey = FALSE;
    GUID            DeviceGuid;
    EAPOL_PACKET_D8_D7      DummyHeader;
    DWORD           dwRetCode = NO_ERROR;


    if (pvContext == NULL)
    {
        TRACE0 (EAPOL, "ProcessReceivedPacket: Critical error, Context is NULL");
        return;
    }

    pEapolBuffer = (EAPOL_BUFFER *)pvContext;
    pPCB = (EAPOL_PCB *)pEapolBuffer->pvContext;
    dwLength = pEapolBuffer->dwBytesTransferred;
    pBuffer = (BYTE *)pEapolBuffer->pBuffer;

    TRACE1 (EAPOL, "ProcessReceivedPacket entered, length = %ld", dwLength);

    do 
    {
        // The Port was verified to be active before the workitem
        // was queued. But do a double-check

        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (EAPOL, "ProcessReceivedPacket: Port %s not active",
                    pPCB->pszDeviceGUID);
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            FREE (pEapolBuffer);
            break;
        }
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

        // Validate packet length
        // Should be atleast ETH_HEADER and first 4 required bytes of 
        // EAPOL_PACKET
        if (dwLength < (sizeof(ETH_HEADER) + 4))
        {
            TRACE2 (EAPOL, "ProcessReceivedPacket: Packet length %ld is less than minimum required %d. Ignoring packet",
                    dwLength, (sizeof(ETH_HEADER) + 4));
            FREE (pEapolBuffer);
            dwRetCode =  ERROR_INVALID_PACKET_LENGTH_OR_ID;
            break;
        }

        // Validate Destination MAC Address
        // Compare with MAC address got during MEDIA_CONNECT

#if 0
        pEthHdr = (ETH_HEADER *)pBuffer;
        if ((memcmp ((BYTE *)pEthHdr->bSrcAddr, 
                        (BYTE *)pPCB->bDestMacAddr, 
                        SIZE_MAC_ADDR)) != 0)
        {
            TRACE2 (EAPOL, "ProcessReceivedPacket: Dest MAC address %s does not match PAE address %s. Ignoring packet",
                    pEthHdr->SrcAddr,
                    pPCB->bDestMacAddr);
            FREE (pEapolBuffer);
            dwRetCode = ERROR_INVALID_ADDRESS;
            break;
        }
#endif

        // Verify if the packet contains a 802.1P tag. If so, skip the 4 bytes
        // after the src+dest mac addresses

        if ((WireToHostFormat16(pBuffer + sizeof(ETH_HEADER)) == EAPOL_8021P_TAG_TYPE))
        {
            pEapolPkt = (EAPOL_PACKET *)(pBuffer + sizeof(ETH_HEADER) + 4);
        }
        else
        {
            pEapolPkt = (EAPOL_PACKET *)(pBuffer + sizeof(ETH_HEADER));
        }

        // Validate Ethernet type in the incoming packet
        // It should be the same as the one defined for the
        // current port

        if (memcmp ((BYTE *)pEapolPkt->EthernetType, (BYTE *)pPCB->bEtherType,
                        SIZE_ETHERNET_TYPE) != 0)
        {
            TRACE2 (EAPOL, "ProcessReceivedPacket: Packet PAE type %s does not match expected type %s. Ignoring packet",
                    pEapolPkt->EthernetType,
                    pPCB->bEtherType);
            FREE (pEapolBuffer);
            dwRetCode = ERROR_INVALID_PACKET_LENGTH_OR_ID;
            break;
        }

        // EAPOL packet type should be valid
        if ((pEapolPkt->PacketType != EAP_Packet) &&
                (pEapolPkt->PacketType != EAPOL_Start) &&
                (pEapolPkt->PacketType != EAPOL_Logoff) &&
                (pEapolPkt->PacketType != EAPOL_Key))
        {
            TRACE1 (EAPOL, "ProcessReceivedPacket: Invalid EAPOL packet type %d. Ignoring packet",
                    pEapolPkt->PacketType);
            FREE (pEapolBuffer);
            dwRetCode = ERROR_INVALID_PACKET;
            break;
        }


        // Determine the value of local EAPOL state variables
        if (pEapolPkt->PacketType == EAP_Packet)
        {
            TRACE0 (EAPOL, "ProcessReceivedPacket: EAP_Packet");
            // Validate length of packet for EAP
            // Should be atleast (ETH_HEADER+EAPOL_PACKET)
            if (dwLength < (sizeof (ETH_HEADER) + sizeof (EAPOL_PACKET)))
            {
                TRACE1 (EAPOL, "ProcessReceivedPacket: Invalid length of EAP packet %d. Ignoring packet",
                        dwLength);
                FREE (pEapolBuffer);
                dwRetCode = ERROR_INVALID_PACKET_LENGTH_OR_ID;
                break;
            }


            // Determine if the packet is draft 8 or not

            pEapolPktD8 = (EAPOL_PACKET_D8 *)pEapolPkt;

            pEapPkt = (PPP_EAP_PACKET *)pEapolPktD8->PacketBody;


            switch (WireToHostFormat16(pEapolPktD8->AuthResultCode))
            {
                case AUTH_Continuing:
                    if (pEapPkt->Code == EAPCODE_Request)
                    {
                        fRemoteEnd8021XD8 = TRUE;
                    }
                    break;

                case AUTH_Authorized:
                    if (pEapPkt->Code ==  EAPCODE_Success)

                    {
                        fRemoteEnd8021XD8 = TRUE;
                    }
                    break;

                case AUTH_Unauthorized:
                    if ((pEapPkt->Code ==  EAPCODE_Failure) ||
                        (pEapPkt->Code ==  EAPCODE_Success))
                    {
                        fRemoteEnd8021XD8 = TRUE;
                    }
                    break;
            }

            if (fRemoteEnd8021XD8 && (WireToHostFormat16(pEapolPktD8->PacketBodyLength) != 0))
            {
                TRACE0 (EAPOL, "ProcessReceivedPacket: Packet received DRAFT 8 format");
                pPCB->fRemoteEnd8021XD8 = TRUE;

                memcpy (DummyHeader.AuthResultCode, pEapolPktD8->AuthResultCode,
                        2);
                memcpy (DummyHeader.EthernetType, pEapolPktD8->EthernetType,
                        2);
                DummyHeader.ProtocolVersion = pEapolPktD8->ProtocolVersion;
                DummyHeader.PacketType = pEapolPktD8->PacketType;

                memcpy ((BYTE *)pEapolPktD8, (BYTE *)&DummyHeader, 6);

                pEapolPkt = (EAPOL_PACKET *)((BYTE *)pEapolPktD8 + 2);
            }
            else
            {
                pPCB->fRemoteEnd8021XD8 = FALSE;
                TRACE0 (EAPOL, "ProcessReceivedPacket: Packet received PRE-DRAFT 8 format");
            }

            pEapPkt = (PPP_EAP_PACKET *)pEapolPkt->PacketBody;

            if (pEapPkt->Code == EAPCODE_Request)
            {
                // Validate length of packet for EAP-Request packet
                // Should be atleast (ETH_HEADER+EAPOL_PACKET-1+PPP_EAP_PACKET)
                if (dwLength < (sizeof (ETH_HEADER) + sizeof(EAPOL_PACKET)-1
                            + sizeof (PPP_EAP_PACKET)))
                {
                    TRACE1 (EAPOL, "ProcessReceivedPacket: Invalid length of EAP Request packet %d. Ignoring packet",
                            dwLength);
                    FREE (pEapolBuffer);
                    dwRetCode = ERROR_INVALID_PACKET_LENGTH_OR_ID;
                    break;
                }
                if (pEapPkt->Data[0] == EAPTYPE_Identity)
                {
                    pPCB->fIsRemoteEndEAPOLAware = TRUE;
                    ReqId = TRUE;
                }
                else
                {
                    ReqAuth = TRUE;
                }
            }
            else if (pEapPkt->Code ==  EAPCODE_Success)
            {
                EapSuccess = TRUE;
            }
            else if (pEapPkt->Code == EAPCODE_Failure)
            {
                EapFail = TRUE;
            }
            else
            {
                // Invalid type
                TRACE1 (EAPOL, "ProcessReceivedPacket: Invalid EAP packet type %d. Ignoring packet",
                        pEapPkt->Code);
                FREE (pEapolBuffer);
                dwRetCode = ERROR_INVALID_PACKET;
                break;
            }
        }
        else
        {
            TRACE0 (EAPOL, "ProcessReceivedPacket: != EAP_Packet");
            if (pEapolPkt->PacketType == EAPOL_Key)
            {
                TRACE0 (EAPOL, "ProcessReceivedPacket: == EAPOL_Key");
                RxKey = TRUE;
            
                // Determine if the packet is draft 8 or not

                pEapolPktD8 = (EAPOL_PACKET_D8 *)pEapolPkt;

                // In pre-draft 8, PacketBodyLength cannot be '0'
                // If it is zero, it is draft 8 packet format

                if (WireToHostFormat16(pEapolPktD8->AuthResultCode)
                        == AUTH_Continuing)
                {
                    pPCB->fRemoteEnd8021XD8 = TRUE;

                    memcpy (DummyHeader.AuthResultCode, 
                            pEapolPktD8->AuthResultCode,
                            2);

                    memcpy (DummyHeader.EthernetType, 
                            pEapolPktD8->EthernetType,
                            2);

                    DummyHeader.ProtocolVersion = pEapolPktD8->ProtocolVersion;
                    DummyHeader.PacketType = pEapolPktD8->PacketType;

                    memcpy ((BYTE *)pEapolPktD8, (BYTE *)&DummyHeader, 6);

                    pEapolPkt = (EAPOL_PACKET *)((BYTE *)pEapolPktD8 + 2);
                }
                else
                {
                    pPCB->fRemoteEnd8021XD8 = FALSE;
                    TRACE0 (EAPOL, "ProcessReceivedPacket: EAPOL_Key Packet received PRE-DRAFT 8 format");
                }
            }
        }

        //
        // NOTE:
        // Should we check values of EAP type
        //

        // Checking value of PCB fields now
        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        switch (pPCB->State)
        {
            // ReqId, ReqAuth, EapSuccess, EapFail, RxKey are inherently 
            // mutually exclusive
            // No checks will be made to verify this
            // Also, assumption is being made that in any state, maximum 
            // one timer may be active on the port.

            case EAPOLSTATE_LOGOFF:
                // Only a User Logon event can get the port out of
                // LOGOFF state
                TRACE0 (EAPOL, "ProcessReceivedPacket: LOGOFF state, Ignoing packet");
                break;

            case EAPOLSTATE_DISCONNECTED:
                // Only a Media Connect event can get the port out of
                // DISCONNECTED state
                TRACE0 (EAPOL, "ProcessReceivedPacket: DISCONNECTED state, Ignoing packet");
                break;

            case EAPOLSTATE_CONNECTING:
                TRACE0 (EAPOL, "ProcessReceivedPacket: EAPOLSTATE_CONNECTING");
                if (ReqId | EapSuccess | EapFail)
                {
                    // Deactivate current timer
                    RESTART_TIMER (pPCB->hTimer,
                            INFINITE_SECONDS, 
                            "PCB",
                            &dwRetCode);
                    if (dwRetCode != NO_ERROR)
                    {
                        break;
                    }
                }

                if (EapSuccess)
                {
                    if ((dwRetCode = ElProcessEapSuccess (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                else
                if (EapFail)
                {
                    if ((dwRetCode = ElProcessEapFail (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                else
                if (ReqId)
                {
                    if ((dwRetCode = FSMAcquired (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }


                break;

            case EAPOLSTATE_ACQUIRED:
                TRACE0 (EAPOL, "ProcessReceivedPacket: EAPOLSTATE_ACQUIRED");
                if (ReqId | ReqAuth | EapSuccess | EapFail)
                {
                    // Deactivate current timer
                    RESTART_TIMER (pPCB->hTimer,
                            INFINITE_SECONDS,  
                            "PCB",
                            &dwRetCode);
                    if (dwRetCode != NO_ERROR)
                    {
                        break;
                    }
                }

                if (EapSuccess)
                {
                    if ((dwRetCode = ElProcessEapSuccess (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                else
                if (EapFail)
                {
                    if ((dwRetCode = ElProcessEapFail (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                else
                if (ReqId)
                {
                    if ((dwRetCode = FSMAcquired (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                else
                if (ReqAuth)
                {
                    if ((dwRetCode = FSMAuthenticating (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }

                break;

            case EAPOLSTATE_AUTHENTICATING:
                TRACE0 (EAPOL, "ProcessReceivedPacket: EAPOLSTATE_AUTHENTICATING");
                // Common timer deletion
                if (ReqAuth | ReqId | EapSuccess | EapFail)
                {
                    // Deactivate current timer
                    RESTART_TIMER (pPCB->hTimer,
                            INFINITE_SECONDS,   
                            "PCB",
                            &dwRetCode);
                    if (dwRetCode != NO_ERROR)
                    {
                        break;
                    }

                    if (ReqId)
                    {
                        if ((dwRetCode = FSMAcquired (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if ((dwRetCode = FSMAuthenticating (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                        {
                            break;
                        }
                    }
                }

                // Continue further processing

                if (EapSuccess | EapFail)
                {
                    // Auth timer will have restarted in FSMAuthenticating
                    // Deactivate the timer
                    RESTART_TIMER (pPCB->hTimer,
                            INFINITE_SECONDS,
                            "PCB",
                            &dwRetCode);
                    if (dwRetCode != NO_ERROR)
                    {
                        break;
                    }

                    // If the packet received was a EAP-Success, go into 
                    // AUTHENTICATED state
                    if (EapSuccess)
                    {
                        if ((dwRetCode = ElProcessEapSuccess (pPCB,
                                                    pEapolPkt)) != NO_ERROR)
                        {
                            break;
                        }
    
                    }
                    else
                    // If the packet received was a EAP-Failure, go into 
                    // HELD state
                    if (EapFail)
                    {
                        if ((dwRetCode = ElProcessEapFail (pPCB,
                                               