                METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE) pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              (PBYTE)pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [in] */ DWORD dwMDEnumDataIndex,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all metadata values once per call. Values are numbered from 0 to NumValues - 1, where
    NumValues is the number of current valules. If EnumDataIndex is >= NumValues, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, , relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_INVALID_PARAMETER
                 ERROR_PATH_NOT_FOUND
                 ERROR_ACCESS_DENIED
                 ERROR_INSUFFICIENT_BUFFER
                 ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pbdRetrieve = pboAffected->EnumDataObject(dwMDEnumDataIndex,
                                                      pmdrMDData->dwMDAttributes,
                                                      pmdrMDData->dwMDUserType,
                                                      pmdrMDData->dwMDDataType,
                                                      &pboAssociated);
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            pbdRetrieve = pboAffected->EnumInheritableDataObject(dwMDEnumDataIndex,
                                                                 pmdrMDData->dwMDUserType,
                                                                 pmdrMDData->dwMDDataType,
                                                                 &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE)pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pbdRetrieve->GetIdentifier(),
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDIdentifier = pbdRetrieve->GetIdentifier();
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDIdentifier,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a data object.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Identifier - The identifier of the data to remove.

    DataType   - Optional type of the data to remove. If specified, only data of that
                 type will be removed. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              MD_ERROR_DATA_NOT_FOUND

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
       g_rMasterResource->Lock(TSRES_LOCK_WRITE);
       CMDBaseObject *pboAffected;
       hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
       if (SUCCEEDED(hresReturn)) {
           if (pboAffected->RemoveDataObject(dwMDIdentifier, dwMDDataType, TRUE) != NULL) {
               CMDHandle *phoHandle;

               hresReturn = ERROR_SUCCESS;
               g_dwSystemChangeNumber++;

               phoHandle = GetHandleObject(hMDHandle);
               PREFIX_ASSUME(phoHandle != NULL, "GetHandleObject(hMDHandle) is guaranteed not to return NULL");
               MD_ASSERT(phoHandle != NULL);
               phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwMDIdentifier);

               INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                              phoHandle,
                                              (LPSTR)pszMDPath,
                                              bUnicode);
           }
           else {
               hresReturn = MD_ERROR_DATA_NOT_FOUND;
           }
       }
       g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        /* [in] */ DWORD dwMDBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all data associated with a Meta Object.

Arguments:

    Handle     - METADATA_MASTER_ROOT_HANDLE or a handle returned by ComMDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be returned. Se imd.h.

    DataType   - The Type of the data. If not set to ALL_METADATA only metadata
                 of the specified Data Type will be returned. See imd.h.

    NumDataEntries - On successful output, specifes the number of entries copied to Buffer.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if ERROR_SUCCESS or ERROR_INSUFFICIENT_BUFFER is returned. See ComMDGetDataSetNumber.

    BufferSize     - The size in bytes of buffer. If the return code is ERROR_INSUFFICIENT_BUFFER, this contains
                     the number of bytes needed.

    Buffer         - Buffer to store the data. On successful return it will
                     contain an array of METADATA_GETALL_RECORD.

    RequiredBufferSize - If ERROR_INSUFFICIENT_BUFFER is returned, This contains
        the required buffer length, in bytes.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use
    a handle returned by ComMDOpenMetaObject.

    DWORD data is aligned on non-Intel platforms. This may not hold true on remote clients.
--*/
{
    BOOL fUseInternalStructure = !!(dwMDAttributes & METADATA_REFERENCE);
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDataSetNumber();
            }
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboAffected != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDescendantDataSetNumber();
            }
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              dwMDAttributes,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              bInheritableOnly);
            PBYTE pbEnd = pbBuffer + dwMDBufferSize;
            PBYTE pbDataStart;
            if (fUseInternalStructure)
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_INTERNAL_RECORD));
            }
            else
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_RECORD));
            }
            PBYTE pbNextDataStart = pbDataStart;

            for (i = 0;
                 (i < dwNumDataObjects) ;
                 i++, pbDataStart = pbNextDataStart) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                DWORD dwDataLen = pbdCurrent->GetDataLen(bUnicode);
                PBYTE pbData = (PBYTE)(pbdCurrent->GetData(bUnicode));
                CMDBaseObject *pboAssociated;
                BUFFER bufData;
                STRAU strData;
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                    METADATA_REFERENCE) == 0) {
                    if ((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) != 0) {
                        //
                        // First do a get to get the metaobject associated with this data object
                        //
                        if (bInheritableOnly) {
                            MD_REQUIRE(pboAffected->GetInheritableDataObject(pbdCurrent->GetIdentifier(),
                                                                               pbdCurrent->GetDataType(),
                                                                               &pboAssociated) != NULL);
                        }
                        else {
                            MD_REQUIRE(pboAffected->GetDataObject(pbdCurrent->GetIdentifier(),
                                                                  dwMDAttributes,
                                                                  pbdCurrent->GetDataType(),
                                                                  &pboAssociated) != NULL);
                        }

                        hresReturn= InsertPathIntoData(&bufData,
                                                       &strData,
                                                       &pbData,
                                                       &dwDataLen,
                                                       pbdCurrent,
                                                       hMDHandle,
                                                       pboAssociated,
                                                       bUnicode);
                    }
                    pbNextDataStart = (pbDataStart + dwDataLen);

                    // The following will ensure that the pointer remains on a DWORD boundary.

                    pbNextDataStart = (PBYTE)(((DWORD_PTR)pbNextDataStart + 3) & ~((DWORD_PTR)(3)));

                }
                if (SUCCEEDED(hresReturn)) {
                    if (pbEnd < pbNextDataStart) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else {
                        if (fUseInternalStructure)
                        {
                            if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                                METADATA_REFERENCE) == 0) {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                                MD_COPY(pbDataStart, pbData, dwDataLen);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            }
                            else {
                                MD_ASSERT((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) == 0);
                                MD_ASSERT(pbdCurrent->GetData(bUnicode) != NULL);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].pbMDData = (PBYTE)pbdCurrent->GetData(bUnicode);
                                pbdCurrent->IncrementReferenceCount();
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = pbdCurrent->GetMappingId();
                            }
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                        else
                        {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                            MD_COPY(pbDataStart, pbData, dwDataLen);
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                    }
                }
            }
            FreeMainDataBuffer(ppvMainDataBuf);
            if (SUCCEEDED(hresReturn)) {
                *pdwMDNumDataEntries = dwNumDataObjects;
                if ((dwNumDataObjects > 0) &&
                    (dwMDAttributes & METADATA_ISINHERITED) &&
                    (dwMDAttributes & METADATA_INHERIT)) {
                    //
                    // Set the ISINHERITED flag
                    //
                    if (bInheritableOnly) {
                        for (i = 0; i < dwNumDataObjects; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }
                    }
                    else {

                        ppvMainDataBuf = GetMainDataBuffer();

                        dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                                          dwMDAttributes & ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                                          dwMDUserType,
                                                                          dwMDDataType,
                                                                          bInheritableOnly);

                        //
                        // Current implementation puts the local items first
                        // So just set the rest to inherited
                        //
                        // DBG loop asserts that the implementation has not changed.
                        //

                        #if DBG
                        for (i = 0; i < dwNumDataObjects ; i++) {
                            pbdCurrent = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                            MD_ASSERT(pbdCurrent != NULL);
                            if (fUseInternalStructure)
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                            else
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                        }
                        #endif //DBG

                        for (i = dwNumDataObjects; i < *pdwMDNumDataEntries; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }

                        FreeMainDataBuffer(ppvMainDataBuf);
                    }
                }
            }
            *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - pbBuffer);
            #ifndef _X86_
            //
            // Alignment fluff. Alignment could cause up to 3 bytes to be added to
            // the total needed if the buffer size ends in a different modulo 4
            // than the one passed in.
            //
            if (FAILED(hresReturn)) {
                *pdwMDRequiredBufferSize +=3;
            }
            #endif
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
{
    HRESULT hresReturn;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDHandle *phoHandle;
    CMDBaseObject *pboAffected;
    DWORD dwCurrentDataID;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            MD_REQUIRE((phoHandle = GetHandleObject(hMDHandle)) != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              METADATA_NO_ATTRIBUTES,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              FALSE);
            for (i = 0; i < dwNumDataObjects ; i++) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                dwCurrentDataID = pbdCurrent->GetIdentifier();
                MD_REQUIRE(pboAffected->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
            }
            if (dwNumDataObjects > 0) {
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                               phoHandle,
                                               (LPSTR)pszMDPath,
                                               bUnicode);
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              pszMDSourcePath,
                              hMDDestHandle,
                              pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              (PBYTE)pszMDSourcePath,
                              hMDDestHandle,
                              (PBYTE)pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination object.
    Optionally copies inherited data based on the value of Attributes.

Arguments:

    SrcHandle  - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    SrcPath    - The path of the meta object with which then source data is associated, relative to the
                 path of SrcHandle.

    DestHandle - A handle returned by MDOpenMetaObject with write permission.

    DestPath   - The path of the meta object for data to be copied to, relative to the path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be copied. See imd.h.

    DataType   - Optional type of the data to copy. If not set to ALL_METADATA,
                 only data of that type will be copied.

    CopyFlag   - If true, data will be copied. If false, data will be moved.
                 Must be true if METADATA_INHERIT is set.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid source handle if CopyFlag == TRUE,
        but provides no gaurantee that other threads will not also change
        things. If a consistent data state is desired, use a handle returned by
        MDOpenMetaObject. METADATA_MASTER_ROOT_HANDLE is not a valid destination
        handle.

    If inherited data is copied, it will be copied to the destination object,
        not the corresponding ancestor objects.
--*/
{
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        hresReturn = E_INVALIDARG;
    }
    else {
        //
        // Lock for source object. If copying, just get read lock. If moving,
        // Need write lock.
        //
        g_rMasterResource->Lock((bMDCopyFlag) ? TSRES_LOCK_READ : TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboSource,
                                       hMDSourceHandle,
                                       ((bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE),
                                       (LPSTR)pszSourcePath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboSource != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf,
                                                            dwMDAttributes,
                                                            dwMDUserType,
                                                            dwMDDataType,
                                                            bInheritableOnly);
            g_rMasterResource->Convert(TSRES_CONV_WRITE);

            CMDHandle *hMDDestHandleObject = GetHandleObject(hMDDestHandle);
            if(hMDDestHandleObject == NULL)
            {
                hresReturn = E_HANDLE;
            }
            else
            {
                hresReturn = GetObjectFromPathWithHandle(pboDest,
                                                         hMDDestHandle,
                                                         hMDDestHandleObject,
                                                         METADATA_PERMISSION_WRITE,
                                                         (LPSTR)pszDestPath,
                                                         bUnicode);
            }

            if (SUCCEEDED(hresReturn)) {
                for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
                    pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                    MD_ASSERT(pbdCurrent != NULL);
                    hresReturn = pboDest->SetDataObject(pbdCurrent);
                    if (SUCCEEDED(hresReturn)) {
                        MD_ASSERT(GetHandleObject(hMDDestHandle) != NULL);
                        hMDDestHandleObject->SetChangeData(pboDest,
                                                           MD_CHANGE_TYPE_SET_DATA,
                                                           pbdCurrent->GetIdentifier());
                    }
                }
                if ((!bMDCopyFlag) && (SUCCEEDED(hresReturn))) {
                    for (i = 0; i < dwNumDataObjects; i++) {
                        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                        MD_ASSERT(pbdCurrent != NULL);
                        MD_REQUIRE(pboSource->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                        MD_ASSERT(GetHandleObject(hMDSourceHandle) != NULL);
                        GetHandleObject(hMDSourceHandle)->SetChangeData(pboSource,
                                                                        MD_CHANGE_TYPE_DELETE_DATA,
                                                                        pbdCurrent->GetIdentifier());
                    }
                }
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle, 
                                               hMDDestHandleObject, 
                                               pszDestPath,
                                               bUnicode); 

            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{

    return ComMDGetMetaDataPathsD(hMDHandle,
                                  pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetMetaDataPathsD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  (PBYTE)pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsD(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    IN BOOL bUnicode)
{
    HRESULT hresReturn = S_OK;
    CMDBaseObject *pboAssociated;
    CMDBaseObject *pboHandle;
    LPSTR pszPath = (LPSTR)pszMDPath;
    DWORD i, dwNumMetaObjects;
    DWORD dwBytesPerChar = ((bUnicode) ? sizeof(WCHAR) : sizeof(char));

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDBufferSize != 0) && (pszMDBuffer == NULL)) ||
             (dwMDDataType >= INVALID_END_METADATA) ||
             (pdwMDRequiredBufferSize == NULL)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        hresReturn = GetObjectFromPath(pboAssociated, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            PBYTE pbDataStart = pszMDBuffer;
            PBYTE pbNextDataStart = pbDataStart;
            PBYTE pbDataEnd = pszMDBuffer + (dwMDBufferSize * dwBytesPerChar);
            CMDBaseObject *pboCurrent;
            BUFFER bufPath;
            BUFFER bufMainDataBuf;
            DWORD dwReturn;

            PREFIX_ASSUME(GetHandleObject(hMDHandle) != NULL, "GetHandleObject(hMDHandle) is guaranteed not to return NULL");
            pboHandle = GetHandleObject(hMDHandle)->GetObject();
            MD_ASSERT(pboHandle != NULL);
            dwNumMetaObjects = 0;

            hresReturn = pboAssociated->GetDataRecursive(&bufMainDataBuf,
                                                         dwMDIdentifier,
                                                         dwMDDataType,
                                                         dwNumMetaObjects);

            if (SUCCEEDED(hresReturn)) {

                if (dwNumMetaObjects != 0) {


                    CMDBaseObject **ppboList = (CMDBaseObject **)bufMainDataBuf.QueryPtr();

                    for (i = 0;
                         (i < dwNumMetaObjects) &&
                             ( SUCCEEDED(hresReturn) ||
                               hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
                         i++, pbDataStart = pbNextDataStart) {
                        pboCurrent=ppboList[i];
                        MD_ASSERT(pboCurrent != NULL);
                        DWORD dwStringLen = 0;

                        dwReturn = GetObjectPath(pboCurrent,
                                                 &bufPath,
                                                 dwStringLen,
                                                 pboHandle,
                                                 bUnicode);
                        if (dwReturn != ERROR_SUCCESS) {
                            //
                            // Only blow away previous hresReturn if this failed.
                            //
                            hresReturn = RETURNCODETOHRESULT(dwReturn);
                        }
                        else {

                            //
                            // Need 2 extra characters for "/"
                            //

                            pbNextDataStart = pbDataStart + ((dwStringLen + 2) * dwBytesPerChar);
                            if (pbDataEnd < pbNextDataStart) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                            }
                            else {
                                MD_COPY(pbDataStart,
                                        bufPath.QueryPtr(),
                                        dwStringLen * dwBytesPerChar);
                                if (bUnicode) {
                                    *(((LPWSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETERW;
                                    *(((LPWSTR)pbDataStart) + (dwStringLen + 1)) = (WCHAR)L'\0';
                                }
                                else {
                                    *(((LPSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETER;
                                    *(((LPSTR)pbDataStart) + (dwStringLen + 1)) = (CHAR)'\0';
                                }
                            }
                        }
                    }
                    //
                    // Append a final 0 for double NULL termination
                    //
                    pbNextDataStart = pbDataStart + dwBytesPerChar;
                    if (SUCCEEDED(hresReturn)) {
                        if ((pbDataStart + dwBytesPerChar) <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)L'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                else {
                    if (pszMDBuffer != NULL) {
                        //
                        // If NULL, just return success
                        // No strings, need to append 2 0's for double NULL termination
                        //

                        pbNextDataStart = pbDataStart + (dwBytesPerChar * 2);
                        if (pbNextDataStart <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)L'\0';
                                *(((LPWSTR)pbDataStart) + 1) = (WCHAR)L'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                                *(((LPSTR)pbDataStart) + 1) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                    *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - (PBYTE)pszMDBuffer) / dwBytesPerChar;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAccessRequested,
        /* [in] */ DWORD dwMDTimeOut,
        /* [out] */ PMETADATA_HANDLE phMDNewHandle,
        IN BOOL bUnicode)
/*++

Routine Description:

    Opens a meta object for read and/or write access. The returned handle is
        used by several of the other API's. Opening an object for Read access
        guarantees that that view of the data will not change while the object
        is open. Opening an object for write gaurantees that no other objects
        will read or write any changed data until the handle is closed.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject.

    Path            - The path of the object to be opened.

    AccessRequested - The permissions requested. See imd.h.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    NewHandle - The handled to be passed to other MD routines.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_PATH_BUSY

Notes:
    Multiple read handles or a single  write handle can be open on any given
    object.
    Opens for read will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for write.
    Opens for write will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for read and/or write.

    If the request is for write access or Handle has write access, Handle must be closed before
    this request can succeed, unless Handle = METADATA_MASTER_ROOT_HANDLE.
    Handles should be closed as quickly as possible, as open handles can cause other requests to block.
--*/
{
    HRESULT hresReturn;
    DWORD WaitRetCode;
    METADATA_HANDLE mhTemp;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOLEAN bSchemaKey = FALSE;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((phMDNewHandle == NULL) ||
             ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        CMDBaseObject *pboOpen = NULL;
        GetSystemTimeAsFileTime(&TempTime);
        ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) +
                      (_int64)TempTime.dwLowDateTime +
                      ((_int64)dwMDTimeOut * 10000);
        TimeLeft = dwMDTimeOut;
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
        }
        //
        // Spin loop waiting for permissions. Events get pulsed whenever a handle is closed.
        // Use a wait interval in case the close comes between the Unlock and the Wait.
        //
        while ((SUCCEEDED(hresReturn)) && (!bPermissionsAvailable) && (TimeLeft > 0)) {
            g_rMasterResource->Unlock();
            if (dwMDAccessRequested & METADATA_PERMISSION_WRITE) {
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            else {
                WaitRetCode = WaitForSingleObject(g_phEventHandles[EVENT_WRITE_INDEX], LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            GetSystemTimeAsFileTime(&TempTime);

            CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
            TimeLeft = ((ExpireTime - CurrentTime) / 10000);
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            //
            // Get object again to make sure the object hasn't been deleted
            // Should probably put an exception handler PermissionsAvailable and use
            // the current object
            //
            hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
            }
        }
        if (SUCCEEDED(hresReturn))  {
            if (bPermissionsAvailable) {

                if(METADATA_MASTER_ROOT_HANDLE == hMDHandle)
                { 
                    if((pszPath != NULL) && (0 != *pszPath))
                    {
                        if(bUnicode)
                        {
                            if( (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME1, WSZSCHEMA_KEY_LENGTH1))  ||
                                (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME2, WSZSCHEMA_KEY_LENGTH2))  ||
                                (0 == _wcsnicmp((LPWSTR)(pszMDPath), WSZSCHEMA_KEY_NAME3, WSZSCHEMA_KEY_LENGTH3)) 
                              )                                                                            
                            {
                                bSchemaKey = TRUE;
                            }
                        }
                        else
                        {
                            if( (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME1, SZSCHEMA_KEY_LENGTH1))  ||
                                (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME2, SZSCHEMA_KEY_LENGTH2))  ||
                                (0 == _strnicmp((LPSTR)(pszMDPath), SZSCHEMA_KEY_NAME3, SZSCHEMA_KEY_LENGTH3)) 
                              )                                                                            
                            {
                                bSchemaKey = TRUE;
                            }
                        }
                    }
                }
                else 
                {
                    CMDHandle *phoHandle;
                    phoHandle = GetHandleObject(hMDHandle);
                    if(phoHandle->IsSchemaHandle())
                    {
                        bSchemaKey = TRUE;
                    }
                }
                hresReturn = AddHandle(pboOpen, dwMDAccessRequested, mhTemp, bSchemaKey);
                if (SUCCEEDED(hresReturn)) {
                    *phMDNewHandle = mhTemp;
                }
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
        }

        if (bUnicode) {
            if (SUCCEEDED(hresReturn)) {
                DBGINFO((DBG_CONTEXT,
                         "Metabase  handle %u opened, From handle %u and path %S, permissions = %u\n",
                         mhTemp,
                         hMDHandle,
                         ((pszMDPath == NULL) || *((WCHAR *)pszMDPath) == (WCHAR)L'\0') ? L"NULL" : (WCHAR *)pszMDPath,
                         dwMDAccessRequested));
            }
            else {
                DBGINFO((DBG_CONTEXT,
                         "Metabase Open of handle %u and path %S failed, return code = %X\n",
                         hMDHandle,
                         ((pszMDPath == NULL) || *((WCHAR *)pszMDPath) == (WCHAR)L'\0') ? L"NULL" : (WCHAR *)pszMDPath,
                         hresReturn));
            }
        }
        else {
            if (SUCCEEDED(hresReturn)) {
                DBGINFO((DBG_CONTEXT,
                         "Metabase  handle %u opened, From handle %u and path %s, permissions = %u\n",
                         mhTemp,
                         hMDHandle,
                         ((pszMDPath == NULL) || *((CHAR *)pszMDPath) == (CHAR)'\0') ? "NULL" : (CHAR *)pszMDPath,
                         dwMDAccessRequested));
            }
            else {
                DBGINFO((DBG_CONTEXT,
                         "Metabase Open of handle %u and path %s failed, return code = %X\n",
                         hMDHandle,
                         ((pszMDPath == NULL) || *((CHAR *)pszMDPath) == (CHAR)'\0') ? "NULL" : (CHAR *)pszMDPath,
                         hresReturn));
            }
        }

        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Closes a handle to a meta object. If the handle was opened with write
    permission and changes have been made via this handle, this will cause all
    registered callback functions to be called.

Arguments:

    Handle  - The handle returned by MDOpenMetaObject.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE

--*/
{
    HRESULT hresReturn;
    CMDHandle *hoTemp = NULL;
    BOOL bPulseWrite = FALSE;
    BOOL bPulseRead = FALSE;
    BOOL bSendNotifications = FALSE;
    BOOL bDeleteChangeData = FALSE;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) ||
        ((hoTemp = RemoveHandleObject(hMDHandle)) == NULL)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        if (hoTemp->IsWriteAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            bPulseWrite = TRUE;
            bSendNotifications = TRUE;
            bDeleteChangeData = TRUE;
        }
        if (hoTemp->IsReadAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            bPulseRead = TRUE;
        }
        if (bPulseWrite) {
            bPulseWrite = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
        }
        if (bPulseRead && !bPulseWrite) {
            //
            // A write pulse activates everyone, so only do this if we didn't already do a write pulse
            //
            bPulseRead = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
        }
        if (bSendNotifications) {
            g_rMasterResource->Convert(TSRES_CONV_READ);
            if (FAILED(CreateNotifications(hoTemp,
                                           &dwNumChangeEntries,
                                           &pcoBuffer,
                                           &ppbufStorageArray))) {
                bSendNotifications = FALSE;
            }
        }

        hresReturn = ERROR_SUCCESS;
    }

    if (SUCCEEDED(hresReturn)) {
        DBGINFO((DBG_CONTEXT,
                 "Metabase handle %u closed\n",
                 hMDHandle));
    }

    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                          dwNumChangeEntries,
                          pcoBuffer,
                          ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);
    }

    if (bDeleteChangeData) {

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    }

    delete (hoTemp);

    if (bDeleteChangeData) {
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle. If the handle had write permission and is being changed
    to read only, this will cause all registered callback functions to be called.

Arguments:

    Handle  - The handle to be modified.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    AccessRequested - The requested permissions. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
              ERROR_PATH_BUSY

Notes:
    Success or failure when adding permissions follows the same rules as OpenMetaObject.
    TimeOut values should be short for this call, as it is quite possible for 2 threads
    with read permission on the same data to attempt to update to write at the same time.
    Both will block until one read handle is closed.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoTemp;
    DWORD WaitRetCode;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    BOOL bAddRead, bAddWrite, bRemoveRead, bRemoveWrite;
    BOOL bEventPulsed = FALSE;
    BOOL bSendNotifications = FALSE;
    CMDHandle *phoNotifyHandle;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) || ((hoTemp = GetHandleObject(hMDHandle)) == NULL) ||
        ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else if ((hoTemp = GetHandleObject(hMDHandle)) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        bAddRead = (!(hoTemp->IsReadAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_READ));
        bAddWrite = (!(hoTemp->IsWriteAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_WRITE));
        bRemoveRead = ((hoTemp->IsReadAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_READ));
        bRemoveWrite = ((hoTemp->IsWriteAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_WRITE));

        MD_ASSERT(!(bAddRead && bAddWrite));
        MD_ASSERT(!(bRemoveRead && bRemoveWrite));
        MD_ASSERT(!(bAddRead && bRemoveRead));
        MD_ASSERT(!(bAddWrite && bRemoveWrite));

        //
        // Add permissions first, because if delete comes first, another
        // object could open a handle to this in the interim, and the
        // object could get deleted.
        // Also, AddWrite can fail so it must be before RemoveRead
        // to avoid partial completion.
        //

        if (bAddWrite) {
            MD_ASSERT(hoTemp->IsReadAllowed());
            GetSystemTimeAsFileTime(&TempTime);
            ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime + ((_int64)dwMDTimeOut * 10000);
            TimeLeft = dwMDTimeOut;
            bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
            while ((!bPermissionsAvailable) && (TimeLeft > 0) && (hoTemp!=NULL)) {
                g_rMasterResource->Unlock();
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
                GetSystemTimeAsFileTime(&TempTime);
                CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
                TimeLeft = ((ExpireTime - CurrentTime) / 10000);
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                //
                // The meta object could not have been deleted while the handle is open
                // but the handle object could have been deleted, so get it again.
                //
                hoTemp = GetHandleObject(hMDHandle);
                if (hoTemp != NULL) {
                    bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
                }
            }
            if (hoTemp == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
            }
            else if (!bPermissionsAvailable) {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
            else {
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (bAddRead) {
                MD_ASSERT(hoTemp->IsWriteAllowed());
                //
                // Must already have write access
                // Just add read access
                //
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            }
            if (bRemoveRead) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
            }
            if (bRemoveWrite) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
            }
            hoTemp->SetPermissions(dwMDAccessRequested);
        }
    }
    if ((SUCCEEDED(hresReturn)) && bRemoveWrite) {
        if (SUCCEEDED(CreateNotifications(hoTemp,
                                          &dwNumChangeEntries,
                                          &pcoBuffer,
                                          &ppbufStorageArray))) {
            phoNotifyHandle = new CMDHandle(hoTemp);
            if (phoNotifyHandle == NULL) {
                DeleteNotifications(dwNumChangeEntries,
                                    pcoBuffer,
                                    ppbufStorageArray);
            }
            else {
                bSendNotifications = TRUE;
                hoTemp->ZeroChangeList();
            }
        }
        hoTemp->RemoveNotifications();
    }
    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                  dwNumChangeEntries,
                  pcoBuffer,
                  ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        delete (phoNotifyHandle);
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSaveData(
            IN METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              Errors returned by the file system.
Notes:
    If the main file has been modified by other applications, this call will overwrite them.

--*/
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        hresReturn = InitStorageAndSessionKey(
                         &CryptoStorage,
                         &pSessionKeyBlob
                         );

        if( SUCCEEDED(hresReturn) ) {
            if (g_dwInitialized == 0) {
                hresReturn = MD_ERROR_NOT_INITIALIZED;
            }
            else {
                hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, NULL, NULL, hMDHandle);
//                RetCode = SaveAllDataToRegistry();
            }
            ::IISCryptoFreeBlob(pSessionKeyBlob);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo)
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    Handle  - The handle to get information about.

    Info    - Structure filled in with the information. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
Notes:
    pmdhiInfo->dwMDSystemChangeNumber will correspond to the System Change Number at the time
    the handle was created. It will not change if writes are done via this handle, or any other
    handle. A client can compare this number with the value returned by MDGetSystemChangeNumber
    to see if any writes have been done since the handle was opened.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *HandleObject;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pmdhiInfo == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        HandleObject = GetHandleObject(hMDHandle);
        if (HandleObject == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else {
            HandleObject->GetHandleInfo(pmdhiInfo);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber)
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    SystemChangeNumber - The system change number. This is incremented every time the metadata is updated.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwSystemChangeNumber == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        *pdwSystemChangeNumber = g_dwSystemChangeNumber;
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  pszMDPath,
                                  pdwMDDataSetNumber,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  pdwMDDataSetNumber,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if successful.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
All paths with the same data set number have identical data if inherited data is included.
The inverse is not true, eg. there may be paths with identical data but different data set numbers.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwMDDataSetNumber == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            *pdwMDDataSetNumber=pboQueried->GetDataSetNumber();
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL)) {
            *pdwMDDataSetNumber=pboQueried->GetDescendantDataSetNumber();
            hresReturn = ERROR_SUCCESS;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddRefReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    AddRefs data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        #if DBG
            //
            // Make sure this is in the table
            //
            CMDBaseData *pbdAddRef = (CMDBaseData *)g_PointerMapper->FindMapping(dwMDDataTag);

            DWORD dwHash = DATA_HASH(pbdAddRef->GetIdentifier());
            CMDBaseData *pbdIndex;
            BOOL bFound = FALSE;

            if (g_ppbdDataHashTable[dwHash] == pbdAddRef) {
                bFound = TRUE;
            }
            else {
                for (pbdIndex=g_ppbdDataHashTable[dwHash];
                    (pbdIndex != NULL ) && (pbdIndex->GetNextPtr() != pbdAddRef);
                    pbdIndex = pbdIndex->GetNextPtr()) {
                }
                if (pbdIndex != NULL) {
                    bFound = TRUE;
                }
            }
            if (!bFound) {
                MD_ASSERT(FALSE);
            }
        #endif

        ((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)))->IncrementReferenceCount();

        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDReleaseReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    Releases data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        DeleteDataObject((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)));
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - The new change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboAffected->SetLastChangeTime(pftMDLastChangeTime);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - Place to return the change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    PFILETIME pftTemp;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if ((SUCCEEDED(hresReturn)) ||
            ((hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL))) {
            pftTemp = pboQueried->GetLastChangeTime();
            *pftMDLastChangeTime = *pftTemp;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        FALSE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupWithPasswdW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd)
{
    STRAU strauPasswd;
        
    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupD(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL bUnicode,
            /* [in] */ LPSTR pszPasswd)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarning = ERROR_SUCCESS;
    IIS_CRYPTO_STORAGE * pCryptoStorage = NULL;
    PIIS_CRYPTO_BLOB pSessionKeyBlob = NULL;
    OFSTRUCT ReOpenBuff;

    STRAU strauBackupLocation;
    STRAU strauSchemaLocation;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDFlags & !(MD_BACKUP_OVERWRITE |
                           MD_BACKUP_SAVE_FIRST |
                           MD_BACKUP_FORCE_BACKUP)) != 0) ||
             (((dwMDFlags & MD_BACKUP_SAVE_FIRST) == 0) &&
                 ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        if( dwMDFlags == 0 )
        {
            dwMDFlags = MD_BACKUP_SAVE_FIRST;
        }

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);
        if( FAILED( hresReturn ) )
        {
            return hresReturn;
        }

        MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
        MD_ASSERT(strauSchemaLocation.QueryStr(FALSE) != NULL);

        if( ( ( dwMDFlags & MD_BACKUP_OVERWRITE ) == 0 ) &&
            ( ( HFILE_ERROR != OpenFile( strauBackupLocation.QueryStr(FALSE),
                                          &ReOpenBuff,
                                          OF_EXIST ) )   ||
              ( HFILE_ERROR != OpenFile( strauSchemaLocation.QueryStr(FALSE),
                                          &ReOpenBuff,
                                          OF_EXIST ) ) ) )
        {
            return HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        } 

        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0 || pszPasswd != NULL) {

            if( !pszPasswd )
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey(
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }
            else
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE2;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey2(
                                     pszPasswd,
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }

            if( SUCCEEDED(hresReturn) ) {
                if (g_dwInitialized == 0) {
                    hresReturn = MD_ERROR_NOT_INITIALIZED;
                }
                else {
                    if( !pszPasswd )
                    {
                        hresReturn = SaveAllData(FALSE, 
                                                 pCryptoStorage, 
                                                 pSessionKeyBlob, 
                                                 NULL,
                                                 NULL,
                                                 hMDHandle, 
                                                 TRUE 
                                                 );
                    }
                    else
                    {
                        hresReturn = SaveAllData(FALSE, 
                                                 pCryptoStorage, 
                                                 pSessionKeyBlob, 
                                                 (LPWSTR)strauBackupLocation.QueryStr(TRUE),
                                                 (LPWSTR)strauSchemaLocation.QueryStr(TRUE),
                                                 hMDHandle, 
                                                 TRUE
                                                 );
                    }
                }

                if( !pszPasswd )
                {
                    ::IISCryptoFreeBlob(pSessionKeyBlob);
                }
                else
                {
                    ::IISCryptoFreeBlob2(pSessionKeyBlob);
                }
            }
            if (FAILED(hresReturn)) {
                hresWarning = MD_WARNING_SAVE_FAILED;
            }
        }

        if (SUCCEEDED(hresReturn) || ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0)) {

            //
            // Copy the file
            //

            if ( !pszPasswd ) {
                BOOL bFailIfExists = ((dwMDFlags & MD_BACKUP_OVERWRITE) == 0) ? TRUE : FALSE;

                //
                // Copy the file, for old backup method
                //
                if (!CopyFile(g_strRealFileName->QueryStr(),
                              strauBackupLocation.QueryStr(FALSE),
                              bFailIfExists) ||
                    !CopyFile(g_strSchemaFileName->QueryStr(),
                              strauSchemaLocation.QueryStr(FALSE),
                              bFailIfExists)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hresReturn)) {

                HANDLE hTempFileHandle;

                hTempFileHandle = CreateFile(strauBackupLocation.QueryStr(FALSE),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                if (hTempFileHandle != INVALID_HANDLE_VALUE) {
                    FILETIME ftCurrent;
                    GetSystemTimeAsFileTime(&ftCurrent);
                    SetFileTime(hTempFileHandle,
                                NULL,   // Creation Time
                                &ftCurrent,   // Last AccessTime
                                &ftCurrent); // Last Change Time
                    CloseHandle(hTempFileHandle);
                }

                hresReturn = BackupCertificates ((LPCWSTR)pszMDBackupLocation,
                                                    strauBackupLocation.QueryStr(FALSE),
                                                    g_strRealFileName->QueryStr());
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }

    if( pCryptoStorage )
    {
        delete pCryptoStorage;
        pCryptoStorage = NULL;
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         FALSE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreWithPasswdW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd
            )
{
    STRAU strauPasswd;
        
    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL  bUnicode,
            /* [in] */ LPSTR pszPasswd
            )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((dwMDVersion == MD_BACKUP_NEXT_VERSION) ||
        (dwMDFlags != 0)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {

        STRAU strauBackupLocation;
        STRAU strauSchemaLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = Restore(
                pszMDBackupLocation,
                &strauBackupLocation,
                &strauSchemaLocation,
                pszPasswd);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsD(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((pszMDBackupLocation == NULL) ||
        (pdwMDVersion == NULL)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        if (!strauBackupLocation.Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!strauBackupLocation.Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (*(LPWSTR)pszMDBackupLocation == (WCHAR)L'\0') {
                    if (!strauBackupLocation.Append(L"*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPWSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
            else {
                if (*(LPSTR)pszMDBackupLocation == '\0') {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }
        if (SUCCEEDED(hresReturn)) {
            if (SUCCEEDED(hresReturn)) {
                if (!strauBackupLocation.Append(MD_BACKUP_SUFFIX)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else {

                        //
                        // Make sure MultiByte string is valid
                        //

                        if (strauBackupLocation.QueryStrA() == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Successfully created the search name
            // Enumerate files
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            DWORD dwEnumIndex = (DWORD) -1;
            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                if (CheckDigits(wfdFile.cFileName +
                                GetBackupNameLen(wfdFile.cFileName) +
                                (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                    dwEnumIndex++;
                }
                while (SUCCEEDED(hresReturn) && (dwEnumIndex != dwMDEnumIndex)) {
                    //
                    // Process the remaining files
                    //
                    if (FindNextFile(hFile, &wfdFile)) {
                        if (CheckDigits(wfdFile.cFileName +
                                        GetBackupNameLen(wfdFile.cFileName) +
                                        (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                            //
                            // One of our files
                            //
                            dwEnumIndex++;
                        }
                    }
                    else {
                        hresReturn = GetLastHResult();
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                //
                // Found the file
                // File name is in wfdFile.cFileName
                // Time is in wfdFile.ftLastWriteTime
                // Need to separate the name and version
                // Reuse strauBackupLocation
                //

                DWORD dwNameLen;
                if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                    (strauBackupLocation.QueryStrW() == NULL))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    //
                    // ANSI bytes might not equal characters, so use unicode
                    //
                    dwNameLen = GetBackupNameLen(strauBackupLocation.QueryStrW());
                    strauBackupLocation.SetLen(dwNameLen);
                    if (strauBackupLocation.QueryCB(bUnicode) >
                        (MD_BACKUP_MAX_LEN * ((bUnicode) ? sizeof(WCHAR) : sizeof(char)))) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                    }
                    else {
                        MD_COPY(pszMDBackupLocation,
                                strauBackupLocation.QueryStr(bUnicode),
                                strauBackupLocation.QueryCB(bUnicode) +
                                    ((bUnicode) ? sizeof(WCHAR) : sizeof(char)));
                        *pdwMDVersion = atol(wfdFile.cFileName +

                                             //
                                             // dwNameLen is # characters
                                             // Need to add # bytes, so
                                             // Get it from STRAU
                                             //

                                             strauBackupLocation.QueryCBA() +
                                             (sizeof(MD_BACKUP_SUFFIX) - 1));
                        MD_COPY(pftMDBackupTime,
                                &(wfdFile.ftLastWriteTime),
                                sizeof(FILETIME));
                    }
                }
            }
            else {
                if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                    (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
                }
            }
        }

        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (dwMDVersion == MD_BACKUP_NEXT_VERSION) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;
        STRAU strauSchemaLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation,
                                          &strauSchemaLocation);

        if (SUCCEEDED(hresReturn)) {
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

            //
            // Delete the file
            //

            if (!DeleteFile(strauBackupLocation.QueryStr(FALSE)) ||
                !DeleteFile(strauSchemaLocation.QueryStr(FALSE)) ) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDExportW(
            /* [in] */ METADATA_HANDLE i_hMDHandle,
            /* [string][in][unique] */ LPCWSTR i_wszPasswd,
            /* [string][in][unique] */ LPCWSTR i_wszFileName,
            /* [string][in][unique] */ LPCWSTR i_wszAbsSourcePath,
            /* [in] */ DWORD i_dwMDFlags)
{
    HRESULT             hresReturn      = ERROR_SUCCESS;
    HRESULT             hresWarning     = ERROR_SUCCESS;
    IIS_CRYPTO_STORAGE* pCryptoStorage  = NULL;
    PIIS_CRYPTO_BLOB    pSessionKeyBlob = NULL;

    //
    // Validate parameters
    //
    if(i_wszFileName == NULL || i_wszAbsSourcePath == NULL) 
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~(MD_EXPORT_INHERITED | MD_EXPORT_NODE_ONLY)) != 0 &&
        i_dwMDFlags != 0 )
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
    }

    //
    // We need ansi versions of these
    //
    STRAU strauPasswd;

    if (g_dwInitialized == 0) 
    {
        return MD_ERROR_NOT_INITIALIZED;
    }

    if(!strauPasswd.Copy(i_wszPasswd == NULL ? L"" : (LPWSTR)i_wszPasswd)) 
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    //
    // TODO: Verify I need this semaphore.
    // I think it is needed to read/write from the xml metabase.  And, possibly
    // for a temp file.  I am not sure.
    //
    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    //
    // Never do machine dependent encryption.
    //
    pCryptoStorage = new IIS_CRYPTO_STORAGE2;
    if( !pCryptoStorage )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {
        hresReturn = InitStorageAndSessionKey2(
            strauPasswd.QueryStrA(),
            pCryptoStorage,
            &pSessionKeyBlob);
    }

    if( SUCCEEDED(hresReturn) ) {
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {            
            hresReturn = SaveSomeData(
                i_dwMDFlags & MD_EXPORT_INHERITED,
                i_dwMDFlags & MD_EXPORT_NODE_ONLY,
                true,                   // bOverwriteFile
                pCryptoStorage, 
                pSessionKeyBlob, 
                i_wszFileName,
                i_hMDHandle,
                i_wszAbsSourcePath,
                TRUE);
        }

        ::IISCryptoFreeBlob2(pSessionKeyBlob);
    }
            
    // Now just set the file time
    if (SUCCEEDED(hresReturn)) {

        HANDLE hTempFileHandle;

        hTempFileHandle = CreateFileW(i_wszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
        if (hTempFileHandle != INVALID_HANDLE_VALUE) {
            FILETIME ftCurrent;
            GetSystemTimeAsFileTime(&ftCurrent);
            SetFileTime(hTempFileHandle,
                        NULL,   // Creation Time
                        &ftCurrent,   // Last AccessTime
                        &ftCurrent); // Last Change Time
            CloseHandle(hTempFileHandle);
        }

        //
        // TODO: Figure out what this is and if i need it
        //
        /*hresReturn = BackupCertificates ((LPCWSTR)pszFileName,
                                            strauFileName.QueryStr(FALSE),
                                            g_strRealFileName->QueryStr());*/
    }

    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }

    if( pCryptoStorage )
    {
        delete pCryptoStorage;
        pCryptoStorage = NULL;
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDImportW(
            /* [in] */ METADATA_HANDLE i_hMDHandle,
            /* [string][in][unique] */ LPCWSTR i_wszDestPath,
            /* [string][in][unique] */ LPCWSTR i_wszKeyType,
            /* [string][in][unique] */ LPCWSTR i_wszPasswd,
            /* [string][in][unique] */ LPCWSTR i_wszFileName,
            /* [string][in][unique] */ LPCWSTR i_wszSourcePath,
            /* [in] */ DWORD i_dwMDFlags)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (i_wszFileName   == NULL || 
        i_wszSourcePath == NULL || 
        i_wszDestPath   == NULL ||
        i_wszKeyType    == NULL) 
    {
        return E_INVALIDARG;
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~(MD_IMPORT_INHERITED | MD_IMPORT_NODE_ONLY | MD_IMPORT_MERGE)) != 0 &&
        i_dwMDFlags != 0 )
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
    }

    //
    // We need ANSI versions of the following
    //
    STRAU strauPasswd;

    if (g_dwInitialized == 0) 
    {
        return MD_ERROR_NOT_INITIALIZED;
    }
    if(!strauPasswd.Copy(i_wszPasswd == NULL ? L"" : (LPWSTR)i_wszPasswd)) 
    {
        return E_OUTOFMEMORY;
    }

    CMDBaseObject* pboNew = NULL;

    //
    // Clean up source path.
    //
    ULONG  cchSource = wcslen(i_wszSourcePath);
    LPWSTR wszSource = new WCHAR[cchSource];
    if(wszSource == NULL)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    for(ULONG i = 0; i <= cchSource; i++)
    {
        wszSource[i] = (i_wszSourcePath[i] == MD_ALT_PATH_DELIMETERW) ? 
            MD_PATH_DELIMETERW : i_wszSourcePath[i];
    }

    //
    // Read the data from XML
    //
    if(SUCCEEDED(hresReturn))
    {
        hresReturn = ReadSomeDataFromXML(
            strauPasswd.QueryStrA(),
            (LPWSTR)i_wszFileName,
            wszSource,
            i_wszKeyType,
            i_dwMDFlags,
            FALSE, // do not have ReadSave semaphore
            &pboNew);
        if(FAILED(hresReturn)) {
            DBGPRINTF(( DBG_CONTEXT, 
                "[CMDCOM::ComMDImportW] ReadSomeDataFromXML failed - error 0x%08lx\n", hresReturn));
        }
    }

    //
    // Copy the data into the metabase
    //
    if(SUCCEEDED(hresReturn)) {
        hresReturn = CopyMetaObject(
            NULL,    //hMDSourceHandle
            (LPBYTE)L"", //pszMDSourcePath
            false,   //bUseSourceHandle
            pboNew,  //we already have a pbo, use this instead
            i_hMDHandle,
            (LPBYTE)i_wszDestPath,
            !(i_dwMDFlags & MD_IMPORT_MERGE),
            TRUE,    //bMDCopyFlag
            TRUE     //bUnicode
            );
        if(FAILED(hresReturn)) {
            DBGPRINTF(( DBG_CONTEXT, 
                "[CMDCOM::ComMDImportW] CopyMetaObject failed - error 0x%08lx\n", hresReturn));
        }
    }

    delete pboNew;
    delete [] wszSource;

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreHistoryW(
            /* [unique][in][string] */ LPCWSTR i_wszMDHistoryLocation,
            /* [in] */ DWORD i_dwMDMajorVersion,
            /* [in] */ DWORD i_dwMDMinorVersion,
            /* [in] */ DWORD i_dwMDFlags)
{
    int     iLenHistoryLocation;
    HRESULT hresReturn = ERROR_SUCCESS;
    
    //
    // Validate string len
    //
    if(i_wszMDHistoryLocation)
    {
        for(iLenHistoryLocation = 0; iLenHistoryLocation < MD_BACKUP_MAX_LEN; iLenHistoryLocation++) 
        {
            if(i_wszMDHistoryLocation[iLenHistoryLocation] == L'\0') break;
        }
        if(iLenHistoryLocation == MD_BACKUP_MAX_LEN) 
        {
            hresReturn = E_INVALIDARG;
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            return hresReturn;
        }
    }

    //
    // Validate flags
    //
    if( (i_dwMDFlags & ~MD_HISTORY_LATEST) != 0 &&
        i_dwMDFlags != 0 )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_FLAGS);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        return hresReturn;
    }

    LPWSTR  wszHistoryPathPlusFile     = NULL;
    LPWSTR  wszHistoryPathPlusSchema   = NULL;
    STRAU   strauHistoryPathPlusFile;
    STRAU   strauHistoryPathPlusSchema;
    LPCWSTR wszHistoryLocation         = NULL;
    ULONG   cchHistoryLocation         = NULL;

    //
    // Use i_wszMDHistoryLocation if supplied, else defaults
    //
    if(i_wszMDHistoryLocation == NULL || i_wszMDHistoryLocation[0] == L'\0')
    {
        wszHistoryLocation = g_wszHistoryFileDir;
        cchHistoryLocation = g_cchHistoryFileDir;
    }
    else
    {
        wszHistoryLocation = i_wszMDHistoryLocation;
        cchHistoryLocation = iLenHistoryLocation;
    }

    //
    // Construct wszHistoryPathPlusFile, wszHistoryPathPlusSchema
    //
    hresReturn = ConstructHistoryFileName(
        &wszHistoryPathPlusFile,
        (LPWSTR)wszHistoryLocation,
        cchHistoryLocation,
        g_wszRealFileNameWithoutPathWithoutExtension,
        g_cchRealFileNameWithoutPathWithoutExtension,
        g_wszRealFileNameExtension,
        g_cchRealFileNameExtension,
        i_dwMDMajorVersion,
        i_dwMDMinorVersion);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    hresReturn = ConstructHistoryFileName(
        &wszHistoryPathPlusSchema,
        (LPWSTR)wszHistoryLocation,
        cchHistoryLocation,
        g_wszSchemaFileNameWithoutPathWithoutExtension,
        g_cchSchemaFileNameWithoutPathWithoutExtension,
        g_wszSchemaFileNameExtension,
        g_cchSchemaFileNameExtension,
        i_dwMDMajorVersion,
        i_dwMDMinorVersion);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Use MD_HISTORY_LATEST flag if supplied
    //
    LPWSTR awszFiles[] = { wszHistoryPathPlusFile,     wszHistoryPathPlusSchema,     NULL };
    LPWSTR awszExts[]  = { g_wszRealFileNameExtension, g_wszSchemaFileNameExtension, NULL };
    LPWSTR apInsert[] =  { NULL,                       NULL,                         NULL };
    if(i_dwMDFlags & MD_HISTORY_LATEST)
    {
        DWORD dwMajor = 0;
        DWORD dwMinor = 0;
        for(ULONG i = 0; awszFiles[i] != NULL; i++)
        {
            SIZE_T cch         =  wcslen(awszFiles[i]);
            apInsert[i]        =  awszFiles[i] + cch;
            apInsert[i]        -= wcslen(awszExts[i]);     // i.e. Go to start of: .xml
            apInsert[i]        -= MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
            memcpy(
                apInsert[i], 
                MD_HISTORY_FILE_SEARCH_EXTENSIONW, 
                (MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW) * sizeof(WCHAR));
        }
        
        hresReturn = GetMostRecentHistoryFile(
            awszFiles[0],   // this is: blah\metabase_??????????_??????????.xml
            &dwMajor,
            &dwMinor);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        for(ULONG i = 0; apInsert[i] != NULL; i++)
        {
            // Move to first set of "?"
            apInsert[i]++;
            _snwprintf(apInsert[i], MD_DEFAULT_HISTORY_MAJOR_NUM_DIGITS, L"%010lu", dwMajor);

            // Move to second set of "?"
            apInsert[i] += MD_DEFAULT_HISTORY_MAJOR_NUM_DIGITS+1;
            _snwprintf(apInsert[i], MD_DEFAULT_HISTORY_MINOR_NUM_DIGITS, L"%010lu", dwMinor);
        }
    }

    if(!strauHistoryPathPlusFile.Copy(wszHistoryPathPlusFile))
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    if(!strauHistoryPathPlusSchema.Copy(wszHistoryPathPlusSchema))
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    hresReturn = Restore(
        NULL,
        &strauHistoryPathPlusFile,
        &strauHistoryPathPlusSchema,
        NULL);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

exit:
    delete [] wszHistoryPathPlusFile;
    delete [] wszHistoryPathPlusSchema;
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumHistoryW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR io_wszMDHistoryLocation,
            /* [out] */ DWORD *o_pdwMDMajorVersion,
            /* [out] */ DWORD *o_pdwMDMinorVersion,
            /* [out] */ PFILETIME o_pftMDHistoryTime,
            /* [in] */ DWORD i_dwMDEnumIndex)
{
    STRAU strauPattern;
    int iLenHistoryLocation;
    HRESULT hresReturn = ERROR_SUCCESS;

    //
    // Copies of out params
    //
    DWORD dwMDMajorVersion;
    DWORD dwMDMinorVersion;
    FILETIME ftMDHistoryTime;

    //
    // Validate parameters
    //
    if(io_wszMDHistoryLocation == NULL || o_pdwMDMajorVersion == NULL ||
        o_pdwMDMinorVersion == NULL || o_pftMDHistoryTime == NULL) {
        return E_INVALIDARG;
    }

    //
    // Validate string len
    //
    for(iLenHistoryLocation = 0; iLenHistoryLocation < MD_BACKUP_MAX_LEN; iLenHistoryLocation++) 
    {
        if(io_wszMDHistoryLocation[iLenHistoryLocation] == L'\0') break;
    }
    if(iLenHistoryLocation == MD_BACKUP_MAX_LEN) {
        return E_INVALIDARG;
    }

    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    //
    // Eg. c:\windows\system32\inetsrv\history\
    //
    if(io_wszMDHistoryLocation[0] == L'\0') {
        //
        // TODO: Get more meaningful hr
        //
        if(wcslen(g_wszHistoryFileDir) > MD_BACKUP_MAX_LEN-1) {
            hresReturn = E_INVALIDARG;
            goto exit;
        }
        
        if(!strauPattern.Copy(g_wszHistoryFileDir)) {
            hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    }
    else {
        if(!strauPattern.Copy(io_wszMDHistoryLocation)) {
            hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        if(io_wszMDHistoryLocation[iLenHistoryLocation-1] != L'\\') {
            if(!strauPattern.Append(L"\\")) {
                hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
        }
    }

    //
    // Eg. c:\windows\system32\inetsrv\history\metabase_??????????_??????????.xml
    //
    if(!strauPattern.Append(g_wszRealFileNameWithoutPathWithoutExtension)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }        
    if(!strauPattern.Append(MD_HISTORY_FILE_SEARCH_EXTENSIONW)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    if(!strauPattern.Append(g_wszRealFileNameExtension)) {
        hresReturn = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    hresReturn = EnumFiles(strauPattern.QueryStrW(),
        i_dwMDEnumIndex,
        &dwMDMajorVersion,
        &dwMDMinorVersion,
        &ftMDHistoryTime);

    if(FAILED(hresReturn)) {
        goto exit;
    }

    //
    // If everything succeeded, set out parameters
    //
    if(io_wszMDHistoryLocation[0] == L'\0') {
        wcscpy(io_wszMDHistoryLocation, g_wszHistoryFileDir);
    }
    *o_pdwMDMajorVersion = dwMDMajorVersion;
    *o_pdwMDMinorVersion = dwMDMinorVersion;
    memcpy(o_pftMDHistoryTime, &ftMDHistoryTime, sizeof(FILETIME));

exit:
    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    return hresReturn;
}

HRESULT CMDCOM::Restore(
    LPSTR  i_pszMDBackupLocation,
    STRAU* i_pstrauFile,
    STRAU* i_pstrauSchema,
    LPSTR  i_pszPasswd)
/*++

Synopsis: 
    Private method used by Restore and RestoreHistory

Arguments: [i_pszMDBackupLocation] - can be NULL
           [i_pstrauFile] - 
           [i_pstrauSchema] - 
           [i_pszPasswd] - can be NULL (always NULL in case of RestoreHistory)
           
Return Value: 

--*/
{
    MD_ASSERT(i_pstrauFile);
    MD_ASSERT(i_pstrauSchema);

    HRESULT hresReturn        = S_OK;
    DWORD   dwInitializedSave = 0;

    //
    // Send notifications before we grab locks in case users
    // try to access metabase. It would be nice to check the
    // file name before doing this but that requires ReadSaveSemaphore.
    //
    // Send Shutdown Notification since we don't have a Restore
    // Notification and it's close enough.
    //

    SendShutdownNotifications();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    // IISADMIN and factory both have refences we do not wait for.
    //
    // We don't actually need to wait during restore, since
    // interfaces are preserved, but waiting will allow clients
    // to cleanup properly.
    //

    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 3) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

    if (SUCCEEDED(hresReturn)) {
        //
        // Got a valid name
        // See if the file exists
        //
        MD_ASSERT(i_pstrauFile->QueryStr(FALSE) != NULL);
        MD_ASSERT(i_pstrauSchema->QueryStr(FALSE) != NULL);
        HANDLE hFile = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA wfdFile;
        STR   strCopyOfMetabaseFileName (*g_strRealFileName);

        hFile = FindFirstFile(i_pstrauFile->QueryStrA(),
                              &wfdFile);
        if (hFile == INVALID_HANDLE_VALUE) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        }
        else {
            FindClose(hFile);
            //
            // File actually exists,
            // Go ahead and restore.
            //
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);

            //
            // Prevent saves during termination.
            //
            BOOL bPrevSaveDisallowed = g_bSaveDisallowed;
            g_bSaveDisallowed = TRUE;
            dwInitializedSave = 0;
            if( g_dwInitialized != 0 )
            {
                dwInitializedSave = g_dwInitialized;

                while (g_dwInitialized > 0) {
                    TerminateWorker1(TRUE);
                }
            }

            g_bSaveDisallowed = bPrevSaveDisallowed;

            while (SUCCEEDED(hresReturn) && (g_dwInitialized < dwInitializedSave))
            {
                hresReturn = InitWorker(TRUE, 
                                        i_pszPasswd, 
                                        i_pstrauFile->QueryStr(FALSE),
                                        i_pstrauSchema->QueryStr(FALSE));

                if(HRESULT_FACILITY(hresReturn) == FACILITY_CONFIGURATION)
                {
                    //
                    // Some facility_configuration errors are converted to md_error
                    // in InitWorker.  For the remainder, this has to suffice.
                    //
                    DBGERROR((DBG_CONTEXT, 
                        "[CMDCOM::Restore] InitWorker returned hr=0x%x\n", hresReturn));
                    hresReturn = MD_ERROR_READ_METABASE_FILE;
                }
            }

            if( SUCCEEDED(hresReturn) && i_pszMDBackupLocation)
            {
                RestoreCertificates ((LPCWSTR)i_pszMDBackupLocation,
                                      i_pstrauFile->QueryStr(FALSE),
                                      strCopyOfMetabaseFileName.QueryStr());
            }

            //
            // Need to flush the newly restored data out
            //
            g_dwSystemChangeNumber++;
            g_dwSchemaChangeNumber++;

            g_rMasterResource->Unlock();

            //
            // At this point all old handles are invalidated
            // and all no new handles have been opened.
            // So tell clients to invalidate any open handles now.
            //

            if (SUCCEEDED(hresReturn)) {
                SendEventNotifications(MD_EVENT_MID_RESTORE);
            }
        }

    }
    MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    //
    // Try to load metadata from metabase.bin file on failure        
    //
    if( FAILED( hresReturn ) )
    {
        HRESULT hrTemp = S_OK;
        while (SUCCEEDED(hrTemp) && (g_dwInitialized < dwInitializedSave))
        {
            hrTemp = InitWorker(FALSE, NULL, NULL, NULL);
            //
            // Some facility_configuration errors are converted to md_error
            // in InitWorker.  For the remainder, this has to suffice.
            //
            if(HRESULT_FACILITY(hresReturn) == FACILITY_CONFIGURATION)
            {
                DBGERROR((DBG_CONTEXT, 
                    "[CMDCOM::Restore] InitWorker returned hr=0x%x\n", hresReturn));
                hresReturn = MD_ERROR_READ_METABASE_FILE;
            }
        }
    }
    else
    {
        //
        // Need to flush newly restored data to Metabase.bin file 
        //
        hresReturn = ComMDSaveData( METADATA_MASTER_ROOT_HANDLE );
    }

    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
    }
    return hresReturn;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CMDCOM::NotifySinks(METADATA_HANDLE hHandle,
                    PMD_CHANGE_OBJECT pcoChangeList,
                    DWORD dwNumEntries,
                    BOOL bUnicode,
                    DWORD dwNotificationType,
                    DWORD dwEvent)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* pIConnectionPoint;
  IEnumConnections* pIEnum;
  CONNECTDATA ConnData;
  HRESULT hrTemp;


  FlushSomeData ();

  //
  // Correct broken connections.
  // It's not likely to be a high number so
  // save a memory allocation by using an array.
  //
  DWORD pdwLostConnections[10];
  DWORD dwNumLostConnections = 0;

  // If there was a paper event, broadcast appropriate notifications to
  // all Sinks connected to each connection point.
//  if (PAPER_EVENT_NONE != PaperEvent)
  {
      if (bUnicode) {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
      }
      else {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
      }
      if (NULL != pIConnectionPoint)
      {
          pIConnectionPoint->AddRef();
          g_rSinkResource->Lock(TSRES_LOCK_READ);
          hr = pIConnectionPoint->EnumConnections(&pIEnum);
          if (SUCCEEDED(hr)) {
              // Loop thru the connection point's connections and if the
              // listening connection supports IPaperSink (ie, PaperSink events)
              // then dispatch the PaperEvent event notification to that sink.
              while (NOERROR == pIEnum->Next(1, &ConnData, NULL))
              {
                IMDCOMSINK* pIMDCOMSINK;

                if (bUnicode) {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_W,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                else {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_A,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                if (SUCCEEDED(hr))
                {
                    switch (dwNotificationType) {
                        case MD_SINK_MAIN: {
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_W)pcoChangeList);
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_A)pcoChangeList);
                            }
                        }
                        break;
                        case MD_SINK_SHUTDOWN: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                        }
                        break;
                        case MD_SINK_EVENT: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDEventNotify(dwEvent);
                            }
                            else {
                                DBG_ASSERT(FALSE);
                            }
                        }
                        break;
                        default: {
                            DBG_ASSERT(FALSE);
                        }
                    }

                    pIMDCOMSINK->Release();
                    if (FAILED(hrTemp)) {
                        if ((HRESULT_CODE(hrTemp) == RPC_S_SERVER_UNAVAILABLE) ||
                            ((HRESULT_CODE(hrTemp) >= RPC_S_NO_CALL_ACTIVE) &&
                                (HRESULT_CODE(hrTemp) <= RPC_S_CALL_FAILED_DNE))) {
                            if (dwNumLostConnections < 10) {
                                pdwLostConnections[dwNumLostConnections++] = ConnData.dwCookie;
                            }
                        }
                    }
                }
                ConnData.pUnk->Release();
              }
              pIEnum->Release();
          }
          g_rSinkResource->Unlock();
          while (dwNumLostConnections > 0) {
              pIConnectionPoint->Unadvise(pdwLostConnections[--dwNumLostConnections]);
          }
          pIConnectionPoint->Release();
      }
  }

  return hr;
}

HRESULT
CMDCOM::ConvertNotificationsToDBCS(DWORD dwNumChangeEntries,
                                   BUFFER **ppbufStorageArray)
{
    HRESULT hresReturn = S_OK;
    //
    // ppbufStorageArray is an array of buffer pointers,
    // where each buffer contains a UNICODE path string
    // which needs to be converted to a Local System path string
    //

    STRAU strauPath;
    STRAU strauPathOptional;
    LPSTR pszDBCSPath;
    LPSTR pszDBCSPathOptional;
    LPSTR pmultiszTarget;
    DWORD dwStrLen1,dwStrLen2 = 0;

    for (DWORD i = 0; i < dwNumChangeEntries; i++) {
        MD_ASSERT(ppbufStorageArray[i] != NULL);

        pmultiszTarget = (LPSTR) ppbufStorageArray[i]->QueryPtr();
        if (!strauPath.Copy((LPWSTR)pmultiszTarget))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            if ((PWORD)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR)))
            {
                if (!strauPathOptional.Copy((LPWSTR)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR))))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    pszDBCSPathOptional = strauPathOptional.QueryStrA();
                    if (pszDBCSPathOptional == NULL)
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else
                    {
                        dwStrLen2 = strauPathOptional.QueryCBA() + 1 ;
                    }
                }
            }

            if (hresReturn == S_OK)
            {
                pszDBCSPath = strauPath.QueryStrA();
                if (pszDBCSPath == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    dwStrLen1 = strauPath.QueryCBA() + 1 ;

                    MD_ASSERT(ppbufStorageArray[i]->QuerySize() >= (dwStrLen1 + dwStrLen2 + sizeof(char)));

                    MD_COPY(pmultiszTarget, pszDBCSPath, dwStrLen1 );
                    if ( dwStrLen2 >0 )
                    {
                        MD_COPY(pmultiszTarget + dwStrLen1 , pszDBCSPathOptional, dwStrLen2 );
                    }
                    *(pmultiszTarget + dwStrLen1 + dwStrLen2) = '\0';
                }
            }
        }
    }
    return hresReturn;
}

VOID
CMDCOM::SendShutdownNotifications()
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_SHUTDOWN);
    NotifySinks(0,
                NULL,
                0,
                FALSE,
                MD_SINK_SHUTDOWN);
}

VOID
CMDCOM::SendEventNotifications(DWORD dwEvent)
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_EVENT,
                dwEvent);
}

VOID
CMDCOM::SendNotifications(METADATA_HANDLE hHandle,
                          DWORD dwTotalNumChangeEntries,
                          PMD_CHANGE_OBJECT_W pcoBuffer,
                          BUFFER **ppbufStorageArray
                          )
{

    DWORD dwNumChangeEntries;
    DWORD dwRemainingNumChangeEntries = dwTotalNumChangeEntries;


    MD_ASSERT(sizeof(MD_CHANGE_OBJECT_A) == sizeof(MD_CHANGE_OBJECT_W));

    while (dwRemainingNumChangeEntries != 0) {
        dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
        NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                    dwNumChangeEntries,
                    TRUE,
                    MD_SINK_MAIN);
        dwRemainingNumChangeEntries -= dwNumChangeEntries;
    }

    if (SUCCEEDED(ConvertNotificationsToDBCS(dwTotalNumChangeEntries,
                                             ppbufStorageArray))) {
        dwRemainingNumChangeEntries = dwTotalNumChangeEntries;
        while (dwRemainingNumChangeEntries != 0) {
            dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
            NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                        dwNumChangeEntries,
                        FALSE,
                        MD_SINK_MAIN);
            dwRemainingNumChangeEntries -= dwNumChangeEntries;
        }
    }
}

VOID
CMDCOM::DeleteNotifications(DWORD dwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W pcoBuffer,
                            BUFFER **ppbufStorageArray
                            )
{
    if (dwNumChangeEntries != 0 ) 
    {
        if( ppbufStorageArray != NULL )
        {
            for( DWORD i = 0; i < dwNumChangeEntries; i++ )
            {
                if (ppbufStorageArray[i] != NULL) 
                {
                    delete ppbufStorageArray[i];
                    ppbufStorageArray[i] = NULL;
                }
            }

            delete [] ppbufStorageArray;
        }

        delete pcoBuffer;
    }
}


HRESULT
CMDCOM::CreateNotifications(CMDHandle *phoHandle,
                            DWORD *pdwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W *ppcoBuffer,
                            BUFFER ***pppbufStorageArray
                            )
{
    HRESULT hRes = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    PCHANGE_ENTRY pceChange;
    DWORD i,j;
    BUFFER **ppbufStorageArray = NULL;
    DWORD dwStringLen, dwStringOldNameLen;
    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;

    dwNumChangeEntries = phoHandle->GetNumChangeEntries();
    if (dwNumChangeEntries != 0) {
        ppbufStorageArray = new BUFFER *[dwNumChangeEntries];

        if (ppbufStorageArray == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            for (i = 0; i < dwNumChangeEntries; i++) {
                ppbufStorageArray[i] = new BUFFER();
                if (ppbufStorageArray[i] == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                //
                // Create UNICODE callbacks
                //
                pcoBuffer = new MD_CHANGE_OBJECT_W[dwNumChangeEntries];
                if (pcoBuffer == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    for (i = 0;
                        (dwReturn == ERROR_SUCCESS) && (i < dwNumChangeEntries);
                         i++) {
                        MD_REQUIRE((pceChange = phoHandle->EnumChangeEntries(i)) != NULL);
                        dwStringLen = 0;
                        dwReturn = GetObjectPath(pceChange->pboChanged,
                                                 ppbufStorageArray[i],
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 TRUE);
                        if (dwReturn == ERROR_SUCCESS) {
                            dwStringOldNameLen = 0;
                            if ( pceChange->pStrOrigName !=NULL) {
                                dwStringOldNameLen = pceChange->pStrOrigName->QueryCCH ();
                            }

                            // we adding 5, because: 1 for path_delimiter first line 1 for term-zero for first line
                            // 1 for path_delimiter second line 1 for term-zero for second line
                            // and last 1 for multisz term-zero
                            if (!ppbufStorageArray[i]->Resize((dwStringLen + dwStringOldNameLen + 5 ) * sizeof(WCHAR))) {
                                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else {
                                pcoBuffer[i].dwMDChangeType = pceChange->dwChangeType;
                                pcoBuffer[i].pszMDPath = (LPWSTR)(ppbufStorageArray[i]->QueryPtr());
                                pcoBuffer[i].pszMDPath[dwStringLen] = MD_PATH_DELIMETERW;
                                pcoBuffer[i].pszMDPath[dwStringLen + 1] = (WCHAR)L'\0';
                                pcoBuffer[i].pszMDPath[dwStringLen + 2] = (WCHAR)L'\0';
                                if ( dwStringOldNameLen )
                                {
                                    memcpy (&(pcoBuffer[i].pszMDPath[dwStringLen + 2]),
                                            pceChange->pStrOrigName->QueryStrW(),
                                            dwStringOldNameLen * sizeof(WCHAR) );
                                    pcoBuffer[i].pszMDPath[dwStringLen + 2 + dwStringOldNameLen] = MD_PATH_DELIMETERW;
                                    pcoBuffer[i].pszMDPath[dwStringLen + 3 + dwStringOldNameLen] = (WCHAR)L'\0';
                                }
                                pcoBuffer[i].dwMDNumDataIDs = pceChange->dwNumDataIDs;
                                if (pceChange->dwNumDataIDs != 0) {
                                    MD_ASSERT(pceChange->pbufDataIDs != NULL);
                                    pcoBuffer[i].pdwMDDataIDs = (DWORD *)(pceChange->pbufDataIDs->QueryPtr());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (dwReturn != ERROR_SUCCESS) {
        //
        // Free Buffers
        //
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    else {
        //
        // Pass back info
        // DeleteNotifications will be called later
        //
        *pdwNumChangeEntries = dwNumChangeEntries;
        *pppbufStorageArray = ppbufStorageArray;
        *ppcoBuffer = pcoBuffer;
    }

    if (dwReturn != ERROR_SUCCESS) {
        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    return hRes;
}






VOID CMDCOM::InitializeFlusher (VOID)
{
    if (!fFlusherInitialized)
    {
        fFlusherInitialized = TRUE;

        EnterCriticalSection( &csFlushLock );
        dwFlushCnt = 0;
        dwFlushPeriodExtensions = 0;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
        LeaveCriticalSection( &csFlushLock );

    }

}

// The algorithm for flushing changes of emtabase to ahrd disk is the following:
// when change to metabase is made, and SlushSomeData is called from NotifySinks
// counter which counts the number of changes in metabase is incremented  and first time
// the change happens work item is schedulled for scheduller to flush a metabase after 60seconds
// if during 60 seconds more than INETA_MB_FLUSH_TRESHOLD changes will happen , then metabase will not
// flush cahnges to disk, but will extend flushing period for another 60 seconds. If during another 60 secs
// number of changes will be higer than INETA_MB_FLUSH_TRESHOLD agian period will be extended
// but no more times than INETA_MB_FLUSH_PERIODS_EXTENSION
// if in some period number of changes in metabase will be less than INETA_MB_FLUSH_TRESHOLD then
// peirod will not be extended and metabase will be saved to disk


VOID WINAPI CMDCOM::MetabaseLazyFlush(
    VOID * pv
    )
/*++

    Description:

        Scheduler callback for flushing the metabase

--*/
{
    BOOL fExtendPeriod =FALSE;
    CMDCOM *pMasterObject = (CMDCOM *)pv;

    MD_ASSERT(pMasterObject != NULL);

    EnterCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized)
    {
        pMasterObject->dwMBFlushCookie = 0;
        if ( pMasterObject->dwFlushCnt > INETA_MB_FLUSH_TRESHOLD)
        {
            if ( pMasterObject->dwFlushPeriodExtensions < INETA_MB_FLUSH_PERIODS_EXTENSION)
            {
                fExtendPeriod = TRUE;
                pMasterObject->dwFlushPeriodExtensions ++;
            }
        }

        pMasterObject->dwFlushCnt = 0;
        if (!fExtendPeriod)
        {
            pMasterObject->dwFlushPeriodExtensions = 0;
        }
        else
        {
            pMasterObject->dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                               pv, //context,
                                                               pMasterObject->msMBFlushTime);
        }
    }

    LeaveCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized && !fExtendPeriod)
    {
        MB mb(pMasterObject);
        mb.Save();
    }

}

VOID CMDCOM::FlushSomeData (VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        dwFlushCnt++;
        if ( !dwMBFlushCookie )
        {
            dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                this, //context,
                                                msMBFlushTime,
                                                FALSE);
        }
    }
    LeaveCriticalSection( &csFlushLock );
}


VOID CMDCOM::TerminateFlusher(VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        fFlusherInitialized = FALSE;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
    }
    LeaveCriticalSection( &csFlushLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\listenercontroller.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ListenerController.cpp

Abstract:

	Implementation of the class that starts and stops the Listener.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include <locale.h>
#include <mdcommon.hxx>
#include    "catalog.h"
#include    "pudebug.h"
#include    "catmeta.h"
#include    "svcmsg.h"
#include    "WriterGlobalHelper.h"
#include    "Writer.h"
#include    "ListenerController.h"
#include    <iadmw.h>
#include    "Listener.h"
#include    "mdmsg.h"
#include    "process.h"

// Fwd declaration 
extern CListenerController* g_pListenerController;
UINT WINAPI StartListenerThread(LPVOID	lpParam);

// TODO: Is this timeout sufficient for large edits?
#define EDIT_WHILERUNNING_WAIT_TIMEOUT 5000

/***************************************************************************++

Routine Description:

    Constructor for the ListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::CListenerController()
{
	m_pEventLog						     = NULL;
	memset(m_aHandle, 0, sizeof(m_aHandle));
	m_hListenerThread                    = NULL;
	m_bDoneWaitingForListenerToTerminate = FALSE;
	m_cRef                               = 0;
	m_eState                             = iSTATE_STOP_TEMPORARY;

	for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++) 
	{ 
		m_aHandle[i] = INVALID_HANDLE_VALUE;
	}
}

/***************************************************************************++

Routine Description:

    Implementation of IUnknown::QueryInterface

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP CListenerController::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
	{
		return E_INVALIDARG;
	}

	*ppv = NULL;

	if(riid == IID_IUnknown)
	{
		*ppv = (IUnknown*) this;
	}
	
	if (NULL != *ppv)
	{
		((IUnknown*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}

} // CListenerController::QueryInterface


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::AddRef

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CListenerController::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
} // CListenerController::AddRef


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::Release

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CListenerController::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;

} // CListenerController::Release

/***************************************************************************++

Routine Description:

    Initialize events, locks, and the state of the controller.
	Stop listening event is used to signal to the listener thread to stop
	listening to file change notifications.
	Process notifications event is used in the listener thread to trigger
	processing the file changes.
	The state vaiable is to to keep the state of the listener thread - 
	if it has been started or stopped. It is initialized to stop temporary.
	Stop permanent state is set when you do not want to make any more
	transitions to the start state, like when the service is shutting down.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CListenerController::Init()
{
	HRESULT                  hr           = S_OK;
    ISimpleTableDispenser2*  pISTDisp     = NULL;
    IAdvancedTableDispenser* pISTAdvanced = NULL;

	for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++) 
	{ 
		m_aHandle[i] = INVALID_HANDLE_VALUE;
	}

	m_aHandle[iEVENT_MANAGELISTENING] = CreateEvent(NULL,   // no security attributes
												  FALSE,  // auto-reset event object
												  FALSE,  // initial state is nonsignaled
												  NULL);  // unnamed object

	if (m_aHandle[iEVENT_MANAGELISTENING] == INVALID_HANDLE_VALUE) 
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}


	m_aHandle[iEVENT_PROCESSNOTIFICATIONS] = CreateEvent(NULL,   // no security attributes
												         FALSE,  // auto-reset event object
												         FALSE,  // initial state is nonsignaled
												         NULL);  // unnamed object

	if (m_aHandle[iEVENT_PROCESSNOTIFICATIONS] == INVALID_HANDLE_VALUE) 
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

	m_eState = iSTATE_STOP_TEMPORARY;

	hr = m_LockStartStop.Initialize();

	if(FAILED(hr))
	{
		goto exit;
	}

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
		goto exit;
	}

    hr = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser,
                                  (LPVOID*)&pISTAdvanced);

    if(FAILED(hr))
    {
		goto exit;
	}

    hr = pISTAdvanced->GetCatalogErrorLogger(&m_pEventLog);

    if(FAILED(hr))
    {
		goto exit;
	}

exit:

	if(NULL != pISTAdvanced)
	{
		pISTAdvanced->Release();
		pISTAdvanced = NULL;
	}

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}

	return hr;

}


/***************************************************************************++

Routine Description:

    Destructor for the CListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::~CListenerController()
{
	for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++) 
	{ 
		if((m_aHandle[i] != INVALID_HANDLE_VALUE) &&
           (m_aHandle[i] != 0)
		  )
		{
			CloseHandle(m_aHandle[i]);
			m_aHandle[i] = INVALID_HANDLE_VALUE;
		}
	}

	m_LockStartStop.Terminate();

	if(m_pEventLog)
	{
		m_pEventLog->Release();
		m_pEventLog = NULL;
	}

	if(!m_bDoneWaitingForListenerToTerminate)
	{
		//
		// Do not close the handle to the listener thread in the destructor.
		// It is handed out to the caller when they stop permanent so that
		// the caller can wait for the thread to terminate. After the wait  
		// the caller should close the handle.  The reason why we canot wait 
		// within the stop function is because while calling start/stop the 
		// caller takes the g_rMasterResource lock, and you do not want to 
		// wait while the lock is taken, because the listener thread also
		// takes the same g_rMasterResource lock under certain conditions,
		// and this can lead to a deadlock.
		//

		m_hListenerThread = NULL;
	}
	else if(NULL != m_hListenerThread)
	{
		CloseHandle(m_hListenerThread);
		m_hListenerThread = NULL;
	}

}


/***************************************************************************++

Routine Description:

    Start the state listener.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CListenerController::Start()
{

	HRESULT      hr			                       = S_OK;
	UINT 	     iThreadID;
	DWORD        dwRes                             = 0; 

	CLock	StartStopLock(&m_LockStartStop);

	if(m_eState == iSTATE_STOP_TEMPORARY)
	{
		//
		// Start only if the previous state is stop temporary.
		//

        if(NULL == m_hListenerThread)
		{
			AddRef();

			DBGINFOW((DBG_CONTEXT,
					  L"[Start] Creating edit while running thread.\n", 
					  hr));			

			m_hListenerThread = (HANDLE) _beginthreadex(NULL, 
								                        0, 
								                        StartListenerThread, 
								                        (LPVOID)this, 
								                        0, 
								                        &iThreadID);

			if (m_hListenerThread == NULL)
			{
				dwRes = GetLastError();
				hr = HRESULT_FROM_WIN32(dwRes);

				DBGINFOW((DBG_CONTEXT,
						  L"[Start] Could not create edit while running thread. CreateThread falied with hr=0x%x\n", 
						  hr));			

				Release();
				//
				// Note: If the thread is created successfully, it will do the release
				//
				return hr;
			}
			
			//
			// Keep the thread handle around to detect the demise of the 
			// thread when the service stops.
			//
		 
		}

		m_eState = iSTATE_START;

		DBGINFOW((DBG_CONTEXT,
				  L"[Start] Setting start event.\n"));			

		if(!SetEvent(m_aHandle[iEVENT_MANAGELISTENING]))
		{
			dwRes = GetLastError();
			hr = HRESULT_FROM_WIN32(dwRes);

			DBGINFOW((DBG_CONTEXT,
					  L"[Start] Setting start event failed with hr=0x%x. Resetting state to iSTATE_STOP_TEMPORARY.\n", 
					  hr));			

			m_eState = iSTATE_STOP_TEMPORARY;
		}

	}

	return hr;
	
} // CListenerController::Start


/***************************************************************************++

Routine Description:

    Stop the listener.

Arguments:

    Stop type - permanent, means you cannot go back to start state.
	          - temporary means you can restart.
    Handle    - When a valid handle pointer is specified and the stop type is
	            permanent it means that the caller wants to wait for the 
				listener thread to die outside the stop function and we 
				hand the thread handle out to the caller and we do not
				wait for the thread to die or close the handle. The reason
				why the caller would want to wait outside the stop function
				is because the caller may have obtained a lock before calling
				stop and may want to wait outside the scope of the function.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CListenerController::Stop(eSTATE   i_eState,
								  HANDLE*  o_hListenerThread)
{
	HRESULT      hr			                       = S_OK;
	DWORD        dwRes                             = 0; 
	HANDLE       hListenerThread                   = INVALID_HANDLE_VALUE;

	DBG_ASSERT((i_eState == iSTATE_STOP_TEMPORARY) || 
	           (i_eState == iSTATE_STOP_PERMANENT));

	CLock	StartStopLock(&m_LockStartStop);

	eSTATE  eStateWAS = m_eState;
	hListenerThread = m_hListenerThread;
                                                                                 
	if((m_eState == iSTATE_START)                     ||
	   ((m_eState == iSTATE_STOP_TEMPORARY)  &&
        (i_eState == iSTATE_STOP_PERMANENT)
	   )
	  )
	{
		//
		// Set an event that will stop listening
		//

		m_eState = i_eState;

		DBGINFOW((DBG_CONTEXT,
				  L"[Stop] Setting stop event.\n"));			

		if(!SetEvent(m_aHandle[iEVENT_MANAGELISTENING]))
		{
			//
			// If set event fails then do not reset the state. One of the
			// following can happen:
			// A. Stop event is called which will attempt to stop again.
			// B. Start event is called and it will not start because it is
			//    is alredy in the start state.
			//

			dwRes = GetLastError();
			hr = HRESULT_FROM_WIN32(dwRes);

			DBGINFOW((DBG_CONTEXT,
					  L"[Stop] Setting stop event failed with hr=0x%x. Resetting state to %d.\n", 
					  hr,
					  (DWORD)eStateWAS));			

			m_eState = eStateWAS;

			return hr;
		}
	}

	StartStopLock.UnLock();

	if((i_eState   == iSTATE_STOP_PERMANENT)     &&
	   (NULL       != hListenerThread)         &&
       ((eStateWAS == iSTATE_START)          ||
	    (eStateWAS == iSTATE_STOP_TEMPORARY)   
	   ) 
	  )
	{
		if(NULL != o_hListenerThread)
		{
			*o_hListenerThread = hListenerThread;
			StartStopLock.Lock();
			m_bDoneWaitingForListenerToTerminate = FALSE;
			m_hListenerThread = NULL;
			StartStopLock.UnLock();
		}
		else
		{

			dwRes = WaitForSingleObject(hListenerThread,
										INFINITE);

			if((dwRes == WAIT_ABANDONED) ||
			   (dwRes == WAIT_TIMEOUT)
			  )
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[Stop] Wait for Edit while running thread to terminate failed. dwRes=0x%x. Ignoring this event.\n", 
						  dwRes));	
				// TODO: Log an error
			}

			StartStopLock.Lock();
			m_bDoneWaitingForListenerToTerminate = TRUE;
			CloseHandle(m_hListenerThread);
			m_hListenerThread = NULL;
			StartStopLock.UnLock();

		}
	}

	return S_OK;

} // CListenerController::Stop


/***************************************************************************++

Routine Description:

    Helper function that returns a pointer to the handle array.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HANDLE * CListenerController::Event()
{
	return (HANDLE *)m_aHandle;
}



/***************************************************************************++

Routine Description:

    Helper function that returns a pointer to the eventlog object.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
ICatalogErrorLogger2 * CListenerController::EventLog()
{
	return (ICatalogErrorLogger2*)m_pEventLog;
}


/***************************************************************************++

Routine Description:

    Function that starts the listener thread. We ensure that there is only one
	listener thread at any given time by taking a lock. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
UINT WINAPI StartListenerThread(LPVOID	lpParam)
{
	CListenerController*    pListenerController = (CListenerController*)lpParam;

    CoInitializeEx (NULL, COINIT_MULTITHREADED);

	DBG_ASSERT(NULL != pListenerController);

    pListenerController->Listen();

	//
	// CListenerController::Start addrefs the CListenerController and calls CreateThread.
	// If create thread fails, it releases it. Else the thread is supposed to release it.
	//

	pListenerController->Release();

    CoUninitialize();

	return 0;
}


/***************************************************************************++

Routine Description:

    Function that waits for the start/stop event and creates or deletes the
	listener.

Arguments:

    None.

Return Value:

    void

--***************************************************************************/
void CListenerController::Listen()
{
    CFileListener*  pListener  = NULL;
	HRESULT         hr         = S_OK;

	//
	// First create and initialize the listener object.
	//

	while(TRUE)
	{
        DWORD dwRes = WaitForMultipleObjects(cmaxLISTENERCONTROLLER_EVENTS,
                                             m_aHandle,
                                             FALSE,
                                             INFINITE);

		if((WAIT_FAILED == dwRes) ||
		   ((iEVENT_MANAGELISTENING      != (dwRes - WAIT_OBJECT_0)) &&
		    (iEVENT_PROCESSNOTIFICATIONS != (dwRes - WAIT_OBJECT_0))
		   )
		  )
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[Listen] Unexpected event received. dwRes=0x%x. Ignoring this event.\n", 
					  HRESULT_FROM_WIN32(GetLastError())));

			continue;
		}

        if(NULL == pListener)
		{
		    //
			// If the listener has never been created, then create it. If the
			// creation fails then set the state to stop temporary. Note that
			// the listener has to be created on the heap because it is handed
			// off to the file notification object which then makes async calls
			// on it and it releases it when done.
			//

			DBGINFOW((DBG_CONTEXT, L"[Listen] Creating listener object.\n"));

		  	hr = CreateListener(&pListener);


			if(FAILED(hr))
			{
                              LogEvent(EventLog(),
                                          MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS,
                                          EVENTLOG_ERROR_TYPE,
                                          ID_CAT_CAT,
                                          hr);

	            CLock    StartStopLock(&m_LockStartStop);
                m_eState = iSTATE_STOP_TEMPORARY;
				continue;
			}
		}

		DBG_ASSERT(NULL != pListener);

        CLock    StartStopLock(&m_LockStartStop);

        if(iEVENT_MANAGELISTENING == (dwRes - WAIT_OBJECT_0))
		{
			switch(m_eState)
			{
				case iSTATE_STOP_TEMPORARY:

					DBGINFOW((DBG_CONTEXT, L"[Listen] Unsubscribing temporarily..\n"));
				    pListener->UnSubscribe();
				    break;

				case iSTATE_STOP_PERMANENT:

					DBGINFOW((DBG_CONTEXT, L"[Listen] Unsubscribing permanently..\n"));
					pListener->UnSubscribe();
					goto exit;

				case iSTATE_START:

					DBGINFOW((DBG_CONTEXT, L"[Listen] Subscibing..\n"));
				    hr = pListener->Subscribe();
					if(FAILED(hr))
					{
                                            LogEvent(EventLog(),
                                                        MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS,
                                                        EVENTLOG_ERROR_TYPE,
                                                        ID_CAT_CAT,
                                                        hr);

                        m_eState = iSTATE_STOP_TEMPORARY;
					}
				    break;

				default:
					DBG_ASSERT(0 && L"Unknown state");
				    break;
			}
			continue;
		}
		else if(m_eState != iSTATE_START)
		{
		    //
			// This means that the process notifications event was set, but
			// the state is not started, so ignore the notification.
			//
            continue;
		}

        StartStopLock.UnLock();

		DBGINFOW((DBG_CONTEXT, L"[Listen] Processing changes..\n"));
   		pListener->ProcessChanges();
		DBGINFOW((DBG_CONTEXT, L"[Listen] Done Processing changes..\n"));

	} // end while

exit:

    if(NULL != pListener)
	{
	    pListener->Release();
		pListener = NULL;
	}

	return;

} // CListenerController::Listen


/***************************************************************************++

Routine Description:

    Function creates the listener object and starts listening

Arguments:

    None.

Return Value:

    void

--***************************************************************************/
HRESULT CListenerController::CreateListener(CFileListener** o_pListener)
{
	HRESULT        hr        = S_OK;
	CFileListener* pListener = NULL;

    *o_pListener = NULL;

	// 
	// Listener is always created on the heap because it is handed off to the
	// File advise object that makes aync calls.
	//

	pListener = new CFileListener();
	if(NULL == pListener)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	pListener->AddRef();

	hr = pListener->Init(this);
	if (FAILED(hr)) 
	{
		goto exit;
	}

	pListener->AddRef();
    *o_pListener = pListener;

exit:

	if(NULL != pListener)
	{
		pListener->Release();
        pListener = NULL;
	}

	return hr;

} // CListenerController::CreateListener


/***************************************************************************++

Routine Description:

    Returns the ListenerControler object.
	This object is a singleton, global object and hence it is necessary to 
	take the g_rMasterResource lock when calling this function, and any place
	where this object is used. Note that while we use new to create the object
	it is destroyed by calling release, because the object is ref-counted. 
	It is ref-counted, because the listener object also holds a reference to 
	it.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeListenerController()
{

	HRESULT hr = S_OK;

	if(NULL == g_pListenerController)
	{
		g_pListenerController = new CListenerController();

		if(NULL == g_pListenerController)
		{
			return E_OUTOFMEMORY;
		}

		g_pListenerController->AddRef();

		hr = g_pListenerController->Init();

		if(FAILED(hr))
		{
			g_pListenerController->Release();
			g_pListenerController = NULL;
			return hr;
		}

	}

	return hr;
}

/***************************************************************************++

Routine Description:

    Releases the global listener controller object.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT UnInitializeListenerController()
{

	HRESULT hr = S_OK;

	if(NULL != g_pListenerController)
	{
		g_pListenerController->Release();
		g_pListenerController = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\memalloc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


extern "C" {


#include <iiscrypt.h>



PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return (PVOID)LocalAlloc( LPTR, Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    (VOID)LocalFree( (HLOCAL)Buffer );

}   // IISCryptoFreeMemory


}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\listener.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Listner.cpp

Abstract:

    Implementation of the class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "mdcommon.hxx"
#include "pudebug.h"
#include "iisdef.h"
#include "Lock.hxx"
#include "CLock.hxx"
#include "svcmsg.h"
#include "Writer.h"
#include <stdio.h>
#include <initguid.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include "Listener.h"
#include "LocationWriter.h"
#include "WriterGlobals.h"

#define MB_TIMEOUT (30 * 1000)

HRESULT GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent, 
                        CWriterGlobalHelper**    ppCWriterGlobalHelper);


HRESULT
GetGlobalValue(ISimpleTableRead2*    pISTProperty,
               LPCWSTR               wszName,
               ULONG*                pcbSize,
               LPVOID*               ppVoid);

void 
ResetMetabaseAttributesIfNeeded(LPTSTR pszMetabaseFile,
							    BOOL   bUnicode);

/***************************************************************************++

  Notes - The listener controller creates the CFileListener and can call the
  following methods on it: (i.e. the ListenerControler thread can call the 
  following methods on it)
  Init
  Subscribe
  Unsubscribe
  ProcessChanges

  The listener object implements the ISimpleTableFileChange interface and 
  this interface is handed out on a subscribe call - which means that the 
  catalog can call back on the methods of this interface.

  Hence there are two threads acceessing this object, but they touch
  different methods.

--***************************************************************************/

/***************************************************************************++

Routine Description:

    Constructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::CFileListener()
{
    m_cRef                                            = 0;
    m_pISTDisp                                        = NULL;
    m_pISTFileAdvise                                  = NULL;
    m_dwNotificationCookie                            = 0;
    m_wszHistoryFileDir                               = NULL;
    m_cchHistoryFileDir                               = 0;
    m_wszRealFileName                                 = NULL;
    m_cchRealFileName                                 = 0;
    m_wszRealFileNameWithoutPath                      = NULL;
    m_cchRealFileNameWithoutPath                      = 0;
    m_wszRealFileNameWithoutPathWithoutExtension      = NULL;
    m_cchRealFileNameWithoutPathWithoutExtension      = 0;
    m_wszRealFileNameExtension                        = NULL;
    m_cchRealFileNameExtension                        = 0;
    m_wszSchemaFileName                               = NULL;
    m_cchSchemaFileName                               = 0;
    m_wszSchemaFileNameWithoutPath                    = NULL;
    m_cchSchemaFileNameWithoutPath                    = 0;
    m_wszSchemaFileNameWithoutPathWithoutExtension    = NULL;
    m_cchSchemaFileNameWithoutPathWithoutExtension    = 0;
    m_wszSchemaFileNameExtension                      = NULL;
    m_cchSchemaFileNameExtension                      = 0;
    m_wszErrorFileSearchString                        = NULL;
    m_cchErrorFileSearchString                        = 0;
    m_wszMetabaseDir                                  = NULL;
    m_cchMetabaseDir                                  = 0;
    m_wszHistoryFileSearchString                      = NULL;
    m_cchHistoryFileSearchString                      = 0;
	m_wszEditWhileRunningTempDataFile                 = NULL;
	m_cchEditWhileRunningTempDataFile                 = 0;
	m_wszEditWhileRunningTempSchemaFile               = NULL;
	m_cchEditWhileRunningTempSchemaFile               = 0;
	m_wszEditWhileRunningTempDataFileWithAppliedEdits = NULL;
	m_cchEditWhileRunningTempDataFileWithAppliedEdits = 0;
	m_bIsTempSchemaFile                               = FALSE;
    m_pCListenerController                            = NULL;
	m_pAdminBase                                      = NULL;

} // CFileListener::CFileListener


/***************************************************************************++

Routine Description:

    Initializes member vaiables.

Arguments:

    Event handle array.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::Init(CListenerController* i_pListenerController)
{
    HRESULT    hr      = S_OK;
	BOOL       bLocked = FALSE;

    if(NULL == m_pISTDisp)
    {
        hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &m_pISTDisp);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::Init] Unable to get the dispenser. GetSimpleTableDispenser failed with hr = 0x%x.\n",
                      hr));

            goto exit;
        }
    }

    if(NULL == m_pISTFileAdvise)
    {
        hr = m_pISTDisp->QueryInterface(IID_ISimpleTableFileAdvise, (void**)&m_pISTFileAdvise);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Keep a reference to the listener controller - it has the handles.
    //

    m_pCListenerController = i_pListenerController;

    m_pCListenerController->AddRef();

    //
    // We make a copy of the following global variables, it eliminates the 
	// need for taking the g_rMasterResource lock everytime we want read 
	// these variables.
    //

    g_rMasterResource->Lock(TSRES_LOCK_READ);
	bLocked = TRUE;

	// Note that g_wszRealFileNameExtension & g_wszSchemaFileNameExtension may
	// be NULL.

    if((NULL == g_wszHistoryFileDir)                           || 
       (NULL == g_wszRealFileName)                             ||
       (NULL == g_wszRealFileNameWithoutPath)                  ||
       (NULL == g_wszRealFileNameWithoutPathWithoutExtension)  ||
       (NULL == g_wszSchemaFileName)                           ||
       (NULL == g_wszSchemaFileNameWithoutPath)                ||
       (NULL == g_wszSchemaFileNameWithoutPathWithoutExtension)||
       (NULL == g_wszErrorFileSearchString)                    ||
       (NULL == g_wszHistoryFileSearchString) 
      )
    {
        hr = E_INVALIDARG;
        goto exit;

    }

    m_wszHistoryFileDir = new WCHAR[g_cchHistoryFileDir+1];
    if(NULL == m_wszHistoryFileDir)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszHistoryFileDir, g_wszHistoryFileDir);
    m_cchHistoryFileDir = g_cchHistoryFileDir;

    m_wszRealFileName = new WCHAR[g_cchRealFileName+1];
    if(NULL == m_wszRealFileName)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszRealFileName, g_wszRealFileName);
    m_cchRealFileName = g_cchRealFileName;
	
    m_wszRealFileNameWithoutPath = new WCHAR[g_cchRealFileNameWithoutPath+1];
    if(NULL == m_wszRealFileNameWithoutPath)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszRealFileNameWithoutPath, g_wszRealFileNameWithoutPath);
    m_cchRealFileNameWithoutPath = g_cchRealFileNameWithoutPath;

    m_wszRealFileNameWithoutPathWithoutExtension = new WCHAR[g_cchRealFileNameWithoutPathWithoutExtension+1];
    if(NULL == m_wszRealFileNameWithoutPathWithoutExtension)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszRealFileNameWithoutPathWithoutExtension, g_wszRealFileNameWithoutPathWithoutExtension);
    m_cchRealFileNameWithoutPathWithoutExtension = g_cchRealFileNameWithoutPathWithoutExtension;

	if(NULL != g_wszRealFileNameExtension)
	{
		m_wszRealFileNameExtension = new WCHAR[g_cchRealFileNameExtension+1];
		if(NULL == m_wszRealFileNameExtension)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		wcscpy(m_wszRealFileNameExtension, g_wszRealFileNameExtension);
		m_cchRealFileNameExtension = g_cchRealFileNameExtension;
	}

    m_wszSchemaFileName = new WCHAR[g_cchSchemaFileName+1];
    if(NULL == m_wszSchemaFileName)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszSchemaFileName, g_wszSchemaFileName);
    m_cchSchemaFileName = g_cchSchemaFileName;

    m_wszSchemaFileNameWithoutPath = new WCHAR[g_cchSchemaFileNameWithoutPath+1];
    if(NULL == m_wszSchemaFileNameWithoutPath)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszSchemaFileNameWithoutPath, g_wszSchemaFileNameWithoutPath);
    m_cchSchemaFileNameWithoutPath = g_cchSchemaFileNameWithoutPath;

    m_wszSchemaFileNameWithoutPathWithoutExtension = new WCHAR[g_cchSchemaFileNameWithoutPathWithoutExtension+1];
    if(NULL == m_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszSchemaFileNameWithoutPathWithoutExtension, g_wszSchemaFileNameWithoutPathWithoutExtension);
    m_cchSchemaFileNameWithoutPathWithoutExtension = g_cchSchemaFileNameWithoutPathWithoutExtension;

	if(NULL != g_wszSchemaFileNameExtension)
	{
		m_wszSchemaFileNameExtension = new WCHAR[g_cchSchemaFileNameExtension+1];
		if(NULL == m_wszSchemaFileNameExtension)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		wcscpy(m_wszSchemaFileNameExtension, g_wszSchemaFileNameExtension);
		m_cchSchemaFileNameExtension = g_cchSchemaFileNameExtension;
	}

    m_wszErrorFileSearchString = new WCHAR[g_cchErrorFileSearchString+1];
    if(NULL == m_wszErrorFileSearchString)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszErrorFileSearchString, g_wszErrorFileSearchString);
    m_cchErrorFileSearchString = g_cchErrorFileSearchString;

    m_wszMetabaseDir = new WCHAR[g_cchMetabaseDir+1];
    if(NULL == m_wszMetabaseDir)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszMetabaseDir, g_wszMetabaseDir);
    m_cchMetabaseDir = g_cchMetabaseDir;

    m_wszHistoryFileSearchString = new WCHAR[g_cchHistoryFileSearchString+1];
    if(NULL == m_wszHistoryFileSearchString)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
    wcscpy(m_wszHistoryFileSearchString, g_wszHistoryFileSearchString);
    m_cchHistoryFileSearchString = g_cchHistoryFileSearchString;

	if(bLocked)
	{
		g_rMasterResource->Unlock();
		bLocked = FALSE;
	}

	m_cchEditWhileRunningTempDataFile = m_cchMetabaseDir + (sizeof(MD_EDIT_WHILE_RUNNING_TEMP_DATA_FILE_NAMEW)/sizeof(WCHAR));
	m_wszEditWhileRunningTempDataFile = new WCHAR[m_cchEditWhileRunningTempDataFile+1];
	if(NULL == m_wszEditWhileRunningTempDataFile)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
	wcscpy(m_wszEditWhileRunningTempDataFile, m_wszMetabaseDir);
	wcscat(m_wszEditWhileRunningTempDataFile, MD_EDIT_WHILE_RUNNING_TEMP_DATA_FILE_NAMEW);

	m_cchEditWhileRunningTempSchemaFile = m_cchMetabaseDir + (sizeof(MD_EDIT_WHILE_RUNNING_TEMP_SCHEMA_FILE_NAMEW)/sizeof(WCHAR));
	m_wszEditWhileRunningTempSchemaFile = new WCHAR[m_cchEditWhileRunningTempSchemaFile+1];
	if(NULL == m_wszEditWhileRunningTempSchemaFile)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
	wcscpy(m_wszEditWhileRunningTempSchemaFile, m_wszMetabaseDir);
	wcscat(m_wszEditWhileRunningTempSchemaFile, MD_EDIT_WHILE_RUNNING_TEMP_SCHEMA_FILE_NAMEW);

	m_cchEditWhileRunningTempDataFileWithAppliedEdits = m_cchHistoryFileDir + (sizeof(MD_DEFAULT_DATA_FILE_NAMEW)/sizeof(WCHAR) + (sizeof(MD_TEMP_DATA_FILE_EXTW)/sizeof(WCHAR)));
	m_wszEditWhileRunningTempDataFileWithAppliedEdits = new WCHAR[m_cchEditWhileRunningTempDataFileWithAppliedEdits+1];
	if(NULL == m_wszEditWhileRunningTempDataFileWithAppliedEdits)
    {
        hr = E_OUTOFMEMORY;
		goto exit;
    }
	wcscpy(m_wszEditWhileRunningTempDataFileWithAppliedEdits, m_wszHistoryFileDir);
	wcscat(m_wszEditWhileRunningTempDataFileWithAppliedEdits, MD_DEFAULT_DATA_FILE_NAMEW);
	wcscat(m_wszEditWhileRunningTempDataFileWithAppliedEdits, MD_TEMP_DATA_FILE_EXTW);

    hr = CoCreateInstance(CLSID_MSAdminBase,                  // CLSID
                          NULL,                               // controlling unknown
                          CLSCTX_SERVER,                      // desired context
                          IID_IMSAdminBase,                   // IID
                          (VOID**) (&m_pAdminBase ) );          // returned interface

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::Init] Unable to create the admin base object. hr = 0x%x\n", 
                  hr));

        goto exit;
    }

exit:

	if(bLocked)
	{
		g_rMasterResource->Unlock();
		bLocked = FALSE;
	}

    return hr;

} // CFileListener::Init


/***************************************************************************++

Routine Description:

    Destructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::~CFileListener()
{
    ULONG i = 0;

    if(NULL != m_pISTFileAdvise)
    {
        m_pISTFileAdvise->Release();
        m_pISTFileAdvise = NULL;
    }

    if(NULL != m_pISTDisp)
    {
        m_pISTDisp->Release();
        m_pISTDisp = NULL;
    }

    if(NULL != m_wszHistoryFileDir)
    {
        delete [] m_wszHistoryFileDir;
        m_wszHistoryFileDir = NULL;
    }
    m_cchHistoryFileDir             = 0;

    if(NULL != m_wszRealFileName)
    {
        delete [] m_wszRealFileName;
        m_wszRealFileName = NULL;
    }
    m_cchRealFileName    = 0;

    if(NULL != m_wszRealFileNameWithoutPath)
    {
        delete [] m_wszRealFileNameWithoutPath;
        m_wszRealFileNameWithoutPath = NULL;
    }
    m_cchRealFileNameWithoutPath    = 0;

    if(NULL != m_wszRealFileNameWithoutPathWithoutExtension)
    {
        delete [] m_wszRealFileNameWithoutPathWithoutExtension;
        m_wszRealFileNameWithoutPathWithoutExtension = NULL;
    }
    m_cchRealFileNameWithoutPathWithoutExtension    = 0;

    if(NULL != m_wszRealFileNameExtension)
    {
        delete [] m_wszRealFileNameExtension;
        m_wszRealFileNameExtension = NULL;
    }
    m_cchRealFileNameExtension    = 0;

    if(NULL != m_wszSchemaFileName)
    {
        delete [] m_wszSchemaFileName;
        m_wszSchemaFileName = NULL;
    }
    m_cchSchemaFileNameWithoutPath    = 0;

    if(NULL != m_wszSchemaFileNameWithoutPath)
    {
        delete [] m_wszSchemaFileNameWithoutPath;
        m_wszSchemaFileNameWithoutPath = NULL;
    }
    m_cchSchemaFileNameWithoutPath    = 0;

    if(NULL != m_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        delete [] m_wszSchemaFileNameWithoutPathWithoutExtension;
        m_wszSchemaFileNameWithoutPathWithoutExtension = NULL;
    }
    m_cchSchemaFileNameWithoutPathWithoutExtension    = 0;

    if(NULL != m_wszSchemaFileNameExtension)
    {
        delete [] m_wszSchemaFileNameExtension;
        m_wszSchemaFileNameExtension = NULL;
    }
    m_cchSchemaFileNameExtension    = 0;

    if(NULL != m_wszErrorFileSearchString)
    {
        delete [] m_wszErrorFileSearchString;
        m_wszErrorFileSearchString = NULL;
    }
    m_cchErrorFileSearchString = 0;

    if(NULL != m_wszMetabaseDir)
    {
        delete [] m_wszMetabaseDir;
        m_wszMetabaseDir = NULL;
    }
    m_cchMetabaseDir = 0;

    if(NULL != m_wszHistoryFileSearchString)
    {
        delete [] m_wszHistoryFileSearchString;
        m_wszHistoryFileSearchString = NULL;
    }
    m_cchHistoryFileSearchString = 0;

    if(NULL != m_wszEditWhileRunningTempDataFile)
    {
        delete [] m_wszEditWhileRunningTempDataFile;
        m_wszEditWhileRunningTempDataFile = NULL;
    }
    m_cchEditWhileRunningTempDataFile = 0;

    if(NULL != m_wszEditWhileRunningTempSchemaFile)
    {
        delete [] m_wszEditWhileRunningTempSchemaFile;
        m_wszEditWhileRunningTempSchemaFile = NULL;
    }
    m_cchEditWhileRunningTempSchemaFile = 0;

    if(NULL != m_wszEditWhileRunningTempDataFileWithAppliedEdits)
    {
        delete [] m_wszEditWhileRunningTempDataFileWithAppliedEdits;
        m_wszEditWhileRunningTempDataFileWithAppliedEdits = NULL;
    }
    m_cchEditWhileRunningTempDataFileWithAppliedEdits = 0;

    if(NULL != m_pCListenerController)
    {
        m_pCListenerController->Release();
        m_pCListenerController = NULL;
    }

    if(NULL != m_pAdminBase)
    {
        m_pAdminBase->Release();
        m_pAdminBase = NULL;
    }

}


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::QueryInterface

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP CFileListener::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv) 
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ISimpleTableFileChange)
    {
        *ppv = (ISimpleTableFileChange*) this;
    }
    else if(riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableFileChange*) this;
    }
    
    if (NULL != *ppv)
    {
        ((ISimpleTableFileChange*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }

} // CFileListener::QueryInterface


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::AddRef

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
    
} // CFileListener::AddRef


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::Release

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;

} // CFileListener::Release


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileCreate
    It adds the notifications to the received queue. 

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileCreate(LPCWSTR i_wszFileName)
{
    return AddReceivedNotification(i_wszFileName, eFILE_CREATE);

} // CFileListener::OnFileCreate


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileModify
    It adds the notifications to the received queue. 

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileModify(LPCWSTR i_wszFileName)    
{
    return AddReceivedNotification(i_wszFileName, eFILE_MODIFY);

} // CFileListener::OnFileModify


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileDelete
    It adds the notifications to the received queue. 

Arguments:

    [in]    FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileDelete(LPCWSTR i_wszFileName)
{
	//
	// Ignore delete notofications.
	//

	return S_OK;
    
} // CFileListener::OnFileDelete


/***************************************************************************++

Routine Description:

    Read home directory of all sites and subscribe for file change 
    notifications on them. Adds notification cookies to the requested queue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::Subscribe()
{
	HRESULT hr = S_OK;

    //
    // Subscribe to the directory where metabase.xml resides.
    //

    if(0 == m_dwNotificationCookie)
	{

	    DWORD      dwCookie     = 0;

		//
		// Subscribe for Notification
		//

		hr = m_pISTFileAdvise->SimpleTableFileAdvise((ISimpleTableFileChange *)this,
													 m_wszMetabaseDir,
													 m_wszRealFileNameWithoutPath,
													 0,  // No need to recursively search this directory.
													 &dwCookie);

		if (FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[CFileListener::Subscribe] Unable to subscribe to file changes. hr = 0x%x.\n",
					  hr));

			return hr;
		}

		//
		// Save notification cookie
		//

		m_dwNotificationCookie = dwCookie;

	}
	else
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[Subscribe] Already subscribed. %d\n",m_dwNotificationCookie));			
	}


	//
	// If m_dwNotificationCookie is non-zero the is means that we've already 
	// subscribed.
	//

	return hr;

} // CFileListener::Subscribe


/***************************************************************************++

Routine Description:

    Unsubscribe for file change notifications on obsolete directories or 
    all directories if the service is being stopped. Purges entries from the 
    requested queue.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::UnSubscribe()
{

    HRESULT hr = S_OK;
    ULONG i = 0;

    if(m_dwNotificationCookie != 0)
    {
        //
        // Unsubscribe only if you have subscribed before.
        //

        hr = m_pISTFileAdvise->SimpleTableFileUnadvise(m_dwNotificationCookie);

        m_dwNotificationCookie = 0;

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[UnSubscribe] Unsubscribing for file change notifications failed hr=0x%x.\n", 
					  hr));			
		}


    }
	else
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[UnSubscribe] Nothing to unsubscribe for.\n"));			
	}

    return hr;
    
} // CFileListener::UnSubscribe


/***************************************************************************++

Routine Description:

    This method checks to see if the received notification is relevant and if
    so, sets the event to trigger processing.

Arguments:

    [in] Notified file name .
    [in] Notified status.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::AddReceivedNotification(LPCWSTR i_wszFile, DWORD i_eNotificationStatus)
{
    HRESULT hr        = S_OK;

    if(0 == _wcsicmp(i_wszFile, m_wszRealFileName))
    {
        if(!SetEvent((m_pCListenerController->Event())[iEVENT_PROCESSNOTIFICATIONS]))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

    }

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::AddReceivedNotification] Error while saving file change notification. hr = 0x%x.\n", 
                  hr));
    }

    return hr;

} // CFileListener::AddReceivedNotification


/***************************************************************************++

Routine Description:

    This processes the changes.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CFileListener::ProcessChanges()
{
    HRESULT                   hr                          = S_OK;
    ULONG                     ulMajorVersion              = 0;
    LPWSTR                    wszHistoryFile              = NULL;
    WCHAR                     wszMinorVersionNumber[MD_CCH_MAX_ULONG+1];
	int                       res                         = 0;
    LPWSTR                    pwsz                        = NULL;
    HANDLE                    hFind                       = INVALID_HANDLE_VALUE;    
    WIN32_FIND_DATAW          FileData;    
    ULONG                     ulStartMinorVersion         = 0;
    ULONG                     ulStartMinorVersionFileData = 0;
    ULONG                     ulMaxMinorVersion           = 0;
    ULONG                     ulMinorVersion              = 0;
    ULONG                     cRetry                      = 0;
    ULONG                     cchVersionNumber            = 0;
	BOOL                      bGetTableFailed             = FALSE;

	if(ProgrammaticMetabaseSaveNotification())
	{
		goto exit;
	}

    //
    // Get the version number
	// GetVersionNumber already has the retry logic in it.
    //
          
    hr = GetVersionNumber(m_wszEditWhileRunningTempDataFile,
		                  &ulMajorVersion,
						  &bGetTableFailed);

    if(FAILED(hr))
    {

        LogEvent(m_pCListenerController->EventLog(),
                    MD_ERROR_READ_XML_FILE,
                    EVENTLOG_ERROR_TYPE,
                    ID_CAT_CAT,
                    hr);

        goto exit;

    }

    //
    // Construct the history file search string, to search for the largest minor version.
    //

    hr = ConstructHistoryFileNameWithoutMinorVersion(&wszHistoryFile,
                                                     &ulStartMinorVersion,
                                                     m_wszHistoryFileSearchString,
                                                     m_cchHistoryFileSearchString,
                                                     m_wszRealFileNameExtension,
                                                     m_cchRealFileNameExtension,
                                                     ulMajorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ProcessChanges] Searching for history files of type: %s.\n", 
              wszHistoryFile));

    //
    // Search for all history files with the matching version number, pick the 
    // one with the largest minor version and compute the history file name
	// with the largest minor.
    //

    hFind = FindFirstFileW(wszHistoryFile, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LogEvent(m_pCListenerController->EventLog(),
			        MD_ERROR_NO_MATCHING_HISTORY_FILE,
                    EVENTLOG_ERROR_TYPE,
					ID_CAT_CAT,
					hr,
					wszHistoryFile);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] No history files found of type %s. FindFirstFileW failed with hr=0x%x.\n", 
                  wszHistoryFile,
                  hr));
		bGetTableFailed = TRUE; // Set this so that we force a flush to disk
        goto exit;
    }

    ulMaxMinorVersion = 0;
    do
    {
        hr = ParseVersionNumber(FileData.cFileName,
			                    m_cchRealFileNameWithoutPathWithoutExtension,
								&ulMinorVersion,
                                NULL);

		if(FAILED(hr))
		{
			goto exit;
		}

        if(ulMinorVersion >= ulMaxMinorVersion)
        {
            ulMaxMinorVersion                   = ulMinorVersion;
            wszHistoryFile[ulStartMinorVersion] = 0;

			res = _snwprintf(wszMinorVersionNumber, 
							 MD_CCH_MAX_ULONG+1, 
							 L"%010lu", 
							 ulMinorVersion);
			if(res < 0)
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[ProcessChanges] _snwprintf returned a negative value. This should never happen.\n"));
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto exit;
			}

            memcpy(&(wszHistoryFile[ulStartMinorVersion]),
				   wszMinorVersionNumber, 
				   MD_CCH_MAX_ULONG*sizeof(WCHAR));
        }

    }while (FindNextFileW(hFind, &FileData));

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ProcessChanges] History file found %s.\n", 
              wszHistoryFile));

	//
	// Process changes
	//

	pwsz = wcsstr(wszHistoryFile, MD_LONG_STRING_PREFIXW);
	if((NULL != pwsz) &&
	   (wszHistoryFile == pwsz)
	  )
	{
		pwsz = pwsz + MD_CCH_LONG_STRING_PREFIXW;
	}
	else
	{
		pwsz = wszHistoryFile;
	}

    hr = ProcessChangesFromFile(pwsz,
                                ulMajorVersion,
                                ulMaxMinorVersion,
								&bGetTableFailed);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		hFind = INVALID_HANDLE_VALUE;
	}

	if(FAILED(hr))
	{
        CopyErrorFile(bGetTableFailed);

	}

	DeleteTempFiles();

    if(NULL != wszHistoryFile)
    {
        delete [] wszHistoryFile;
        wszHistoryFile = NULL;
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Diff the real file with the given file and process changes

Arguments:

    [in] History file to diff with
    [in] Next minor version of the history file that will have updated changes

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::ProcessChangesFromFile(LPWSTR i_wszHistoryFile,
                                              ULONG  i_ulMajorVersion,
                                              ULONG  i_ulMaxMinorVersion,
                                              BOOL*  o_bGetTableFailed)
{
    ISimpleTableWrite2*       pISTDiff                = NULL;
    ISimpleTableWrite2*       pISTBack                = NULL;
    CWriterGlobalHelper*      pISTHelper              = NULL;
    HRESULT                   hr                      = S_OK;
    HRESULT                   hrSav                   = S_OK;
    STQueryCell               QueryCell[3];
    ULONG                     cCell                   = sizeof(QueryCell)/sizeof(STQueryCell);
    STQueryCell               QueryCellHistory[1];
    ULONG                     cCellHistory            = sizeof(QueryCellHistory)/sizeof(STQueryCell);
    ULONG                     iRow                    = 0;
    DWORD                     dwPreviousLocationID    = -1;
    METADATA_HANDLE           hMBPath                 = NULL;
    LPWSTR                    wszChildKey             = NULL;
    LPWSTR                    wszParentKey            = NULL;
    LPWSTR                    wszEnd                  = NULL;
    LPVOID                    a_pv[cMBPropertyDiff_NumberOfColumns];
    ULONG                     a_Size[cMBPropertyDiff_NumberOfColumns];
    ULONG                     a_iCol[]                = {iMBPropertyDiff_Name,  
                                                         iMBPropertyDiff_Type,  
                                                         iMBPropertyDiff_Attributes,  
                                                         iMBPropertyDiff_Value,  
                                                         iMBPropertyDiff_Group,  
                                                         iMBPropertyDiff_Location,  
                                                         iMBPropertyDiff_ID,  
                                                         iMBPropertyDiff_UserType,  
                                                         iMBPropertyDiff_LocationID,  
                                                         iMBPropertyDiff_Directive,  
                                                         };
    ULONG                     cCol                    = sizeof(a_iCol)/sizeof(ULONG);
    METADATA_RECORD           MBRecord;

	*o_bGetTableFailed = FALSE;

    //
    // Fetch the diff-ed table.
    //

	hr = GetGlobalHelperAndCopySchemaFile(&pISTHelper);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] GetGlobalHelper failed with hr = 0x%x. Hence unable to get meta tables and hence unable to process changes.\n", 
                  hr));

        goto exit;
    }

    QueryCell[0].pData     = (LPVOID)pISTHelper->m_wszBinFileForMeta;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = 0;

    QueryCell[1].pData     = (LPVOID)i_wszHistoryFile;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iST_CELL_FILE;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = 0;

    QueryCell[2].pData     = (LPVOID)m_wszEditWhileRunningTempDataFile;
    QueryCell[2].eOperator = eST_OP_EQUAL;
    QueryCell[2].iCell     = iST_CELL_FILE;
    QueryCell[2].dbType    = DBTYPE_WSTR;
    QueryCell[2].cbSize    = 0;

    hr = m_pISTDisp->GetTable(wszDATABASE_METABASE,
                              wszTABLE_MBPropertyDiff,
                              (LPVOID)QueryCell,
                              (LPVOID)&cCell,
                              eST_QUERYFORMAT_CELLS,
                              fST_LOS_READWRITE,
                              (LPVOID *)&pISTDiff);

    if(FAILED(hr))
    {
        //
        // TODO: When the file is locked, we need to wait and retry.
        // We wait at the time when we check the version number. do 
        // we need to wait here again??
        //

        LogEvent(m_pCListenerController->EventLog(),
			        MD_ERROR_COMPUTING_TEXT_EDITS,
                    EVENTLOG_ERROR_TYPE,
					ID_CAT_CAT,
					hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to get the %s table. hr = 0x%x\n", 
                  wszTABLE_MBPropertyDiff, hr));

        *o_bGetTableFailed = TRUE;

        goto exit;
    }


    //
    // Traverse the diffed table and apply changes
    //

	if(NULL == m_pAdminBase)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        LogEvent(m_pCListenerController->EventLog(),
		         MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
                 EVENTLOG_ERROR_TYPE,
				 ID_CAT_CAT,
				 hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Admin base object not initialized. hr = 0x%x\n", 
                  hr));

        goto exit;
    }


    for(iRow=0;;iRow++)
    {
        BOOL                bLocationWithProperty   = TRUE;
        BOOL                bSecure                 = FALSE;
        BOOL                bChangeApplied          = FALSE;
		BOOL                bInsertedNewLocation    = FALSE;

        MBRecord.dwMDDataTag = 0; 

        hr = pISTDiff->GetColumnValues(iRow,
                                       cCol,
                                       a_iCol,
                                       a_Size,
                                       a_pv);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;

            if(0== iRow)
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::ProcessChanges] No changes occured.\n"));

                goto exit;
            }
            else
            {
                break;
            }
        }
        else if(FAILED(hr))
        {

			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_READING_TEXT_EDITS,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr);

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::ProcessChanges] Unable to read from %s table. GetColumnValues on %d row failed with hr = 0x%x\n", 
                      wszTABLE_MBPropertyDiff, iRow, hr));

            goto exit;
        }

        //
        // Apply the changes to the metabase.
        //

        if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == L'#'))
        {
            bLocationWithProperty = FALSE;
        }

        if(((DWORD)(*(DWORD*)a_pv[iMBPropertyDiff_Attributes]) & ((DWORD)METADATA_SECURE)) != 0)
        {
            bSecure = TRUE;
        }

        if(dwPreviousLocationID != *(DWORD*)a_pv[iMBPropertyDiff_LocationID])
        {
            //
            // Detected a new location. Open the metabase key at that location.
            //

            dwPreviousLocationID = *(DWORD*)a_pv[iMBPropertyDiff_LocationID];

            if(NULL != hMBPath)
            {
                m_pAdminBase->CloseKey(hMBPath);
                hMBPath = NULL;
            }

			switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
			{
			case eMBPropertyDiff_Insert:

					// For inserts open the current node. If the node is 
					// missing, add it - perhaps it is the 1st property 
					// in the node.

					hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
								 m_pAdminBase,
								 TRUE,      
								 &hMBPath,
								 &bInsertedNewLocation);
					break;

				case eMBPropertyDiff_Update:

					// For update open the current node. If the node is 
					// missing, do not add it - perhaps it was deleted

					hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
								 m_pAdminBase,
								 FALSE,      
								 &hMBPath,
								 NULL);
					break;

				case eMBPropertyDiff_Delete:
					
					// For update open the current node. If the node is 
					// missing, do not add it - perhaps it was deleted

					hr = OpenKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
								 m_pAdminBase,
								 FALSE,      
								 &hMBPath,
								 NULL);

					if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
					{
						// If the parent is already deleted, we assume child has 
						// already been deleted and continue.

						bChangeApplied = TRUE;

						hr = SaveChange(iRow,
										pISTDiff);

						if(SUCCEEDED(hr))
						{
							continue;
						}
					}
					break;

				case eMBPropertyDiff_DeleteNode:

					// For delete node - open the parent node.

					hr = OpenParentKeyAndGetChildKey((LPWSTR)a_pv[iMBPropertyDiff_Location],
													 m_pAdminBase,
													 &hMBPath,
													 &wszChildKey);

					if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
					{
						// If the parent is already deleted, we assume child has 
						// already been deleted and continue.

						bChangeApplied = TRUE;

						hr = SaveChange(iRow,
										pISTDiff);

						if(SUCCEEDED(hr))
						{
							continue;
						}
					}
					break;

				default:
					 hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
					break;
			}

			if(FAILED(hr))
			{

				LogEvent(m_pCListenerController->EventLog(),
							MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
							EVENTLOG_ERROR_TYPE,
							ID_CAT_CAT,
							hr,
							(LPWSTR)a_pv[iMBPropertyDiff_Location]);
				goto exit;
			}

        } // End if new location

		MD_ASSERT(NULL != a_pv[iMBPropertyDiff_ID]);
		MD_ASSERT(NULL != a_pv[iMBPropertyDiff_Attributes]);
		MD_ASSERT(NULL != a_pv[iMBPropertyDiff_UserType]);
		MD_ASSERT(NULL != a_pv[iMBPropertyDiff_Type]);

        MBRecord.dwMDIdentifier    = *(DWORD*)a_pv[iMBPropertyDiff_ID]; 
        MBRecord.dwMDAttributes    = *(DWORD*)a_pv[iMBPropertyDiff_Attributes]; 
        MBRecord.dwMDUserType      = *(DWORD*)a_pv[iMBPropertyDiff_UserType]; 
        MBRecord.dwMDDataType      = *(DWORD*)a_pv[iMBPropertyDiff_Type]; 
        MBRecord.dwMDDataLen       = a_Size[iMBPropertyDiff_Value]; 
        MBRecord.pbMDData          = (unsigned char*)a_pv[iMBPropertyDiff_Value]; 

        bChangeApplied = FALSE;

        switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
        {
             case eMBPropertyDiff_Insert:
             case eMBPropertyDiff_Update:
                 if(bLocationWithProperty && (!bSecure) && (MBRecord.dwMDIdentifier != MD_GLOBAL_SESSIONKEY))
                 {
                     hr = m_pAdminBase->SetData(hMBPath,
                                              NULL,
                                              &MBRecord);

                     bChangeApplied = TRUE;

                     DBGINFOW((DBG_CONTEXT,
                               L"[CFileListener::ProcessChanges] Set %s:%d.\n", 
                              (LPWSTR)a_pv[iMBPropertyDiff_Location], MBRecord.dwMDIdentifier));

                 }
                 else if(!bLocationWithProperty)
                 {
                     bChangeApplied = TRUE;
                 }

                 break;
             case eMBPropertyDiff_Delete:
                 if(bLocationWithProperty && (!bSecure))
                 {
                     hr = m_pAdminBase->DeleteData(hMBPath,
                                                 NULL,
                                                 MBRecord.dwMDIdentifier,
                                                 MBRecord.dwMDDataType);
                     
					 if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
					 {
					    hr = S_OK; // Reset hr and assume already deleted.
					 }

                     bChangeApplied = TRUE;

                     DBGINFOW((DBG_CONTEXT,
                               L"[CFileListener::ProcessChanges] Deleted %s:%d.\n", 
                              (LPWSTR)a_pv[iMBPropertyDiff_Location], MBRecord.dwMDIdentifier));

                 }
                 break;
             case eMBPropertyDiff_DeleteNode:
                 hr = m_pAdminBase->DeleteKey(hMBPath,
                                            wszChildKey);

                 if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
				 {
					hr = S_OK; // Reset hr and assume already deleted.
				 }

                 bChangeApplied = TRUE;

                 DBGINFOW((DBG_CONTEXT,
                           L"[CFileListener::ProcessChanges] Deleted key %s.\n", 
                          (LPWSTR)a_pv[iMBPropertyDiff_Location]));

                 break;
             default:
                 hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                 break;

        }
        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::ProcessChanges] Above action failed with hr= 0x%x.\n", 
                      hr));

			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr,
						(LPWSTR)a_pv[iMBPropertyDiff_Location]);

			if((bInsertedNewLocation) && 
			   (eMBPropertyDiff_Insert == *(DWORD*)a_pv[iMBPropertyDiff_Directive]))			{

				//
				// This means that the first property could not be added, but the node has been 
				// added - hence save a change that indicates a node with no property was added.
				//

				hrSav = SaveChangeAsNodeWithNoPropertyAdded(a_pv,
					                                        pISTDiff);
					                              
				if(FAILED(hrSav))
				{
					goto exit;
				}
			}

            goto exit;
        }
        else if(bChangeApplied)
        {
            //
            // Keep track of the succeeded row, by adding to the write cache.
            //

            hr = SaveChange(iRow,
                            pISTDiff);

            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:

	//
	// We should always attempt to create a history file with successfully 
	// applied changes - even if we were not able to apply all changes and
	// there were errors half way through. This is because we want to track
	// the changes that made it to memory. This way if the user re-edits 
	// the file, the diff will happen correctly. For Eg: If a user inserts
	// a node A and edits some properties on another node B. Lets say that
	// node A insert is applied and node B edits cause an error. If we do 
	// not create a history file with node A edits, then if the user re-edits
	// the file and deletes node A, we will not capture that in the diff.
	//

	//
	// Compute the next minor version.
	//

	if(0xFFFFFFFF == i_ulMaxMinorVersion)
	{
		LogEvent(m_pCListenerController->EventLog(),
					MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND,
					EVENTLOG_WARNING_TYPE,
					ID_CAT_CAT,
					hr);

	}
	else
	{
		i_ulMaxMinorVersion++;
	}

	hrSav = ApplyChangeToHistoryFile(pISTHelper,
								     pISTDiff,
								     i_wszHistoryFile,
								     i_ulMajorVersion,
								     i_ulMaxMinorVersion);

	if(FAILED(hrSav))
	{
		LogEvent(m_pCListenerController->EventLog(),
					MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY,
					EVENTLOG_ERROR_TYPE,
					ID_CAT_CAT,
					hr);

		if(SUCCEEDED(hr))
		{
			hr = hrSav;
		}
	}

    if(NULL != hMBPath)
    {
        m_pAdminBase->CloseKey(hMBPath);
        hMBPath = NULL;
    }

    if(NULL != pISTDiff)
    {
        pISTDiff->Release();
        pISTDiff = NULL;
    }


    if(NULL != pISTHelper)
    {
        delete pISTHelper;
        pISTHelper = NULL;
    }

    return hr;

}  // CFileListener::ProcessChangesFromFile


/***************************************************************************++

Routine Description:

    Opens the parent key and returns the pointer to the child key.

Arguments:

	[in]  Location.
	[in]  Adminbase pointer.
	[out] Metadata handle to opened key.
	[out] Pointer in the location string to the child key.

Return Value:

    HRESULT_FROM_WIN32(ERROR_INVALID_DATA) If the parent key is not found (eg
	                                       when the location string is mal-
										   formed, or the parent is the 
										   root location.
	HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) If the parent key is found but
	                                         missing in the metabase ie if we 
											 cannot open the parent key.
	Base Object error codes for IMSAdminBase::OpenKey

--***************************************************************************/
HRESULT CFileListener::OpenParentKeyAndGetChildKey(LPWSTR           i_wszLocation,
			                                       IMSAdminBase*    i_pAdminBase,
							                       METADATA_HANDLE* o_pHandle,
							                       WCHAR**          o_wszChildKey)
{
	HRESULT hr           = S_OK;
	LPWSTR  wszParentKey = NULL;
	LPWSTR  wszEnd       = NULL;

	*o_wszChildKey = NULL;

	wszParentKey = new WCHAR[wcslen(i_wszLocation)+1];
	if(NULL == wszParentKey)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(wszParentKey, i_wszLocation);
    wszEnd = wcsrchr(wszParentKey, g_wchFwdSlash);

    if(NULL == wszEnd)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

		DBGINFOW((DBG_CONTEXT,
				  L"[CFileListener::OpenParentKeyAndGetChildKey] Unable to find parent key: %s\n", 
				  i_wszLocation));
        goto exit;
    }
    else if(wszParentKey != wszEnd)
    {
        *wszEnd = NULL;
    }
    else if(*(++wszEnd) == L'\0')
    {
        //
        // Someone is trying to delete the root location.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::OpenParentKeyAndGetChildKey] Unable to delete/modify the root key: %s\n", 
                  i_wszLocation));

        goto exit;

    }
    else
    {
        //
        // Someone is trying to delete the subkey of the root.
        //

        *wszEnd=0;
    }

    *o_wszChildKey = wcsrchr(i_wszLocation, g_wchFwdSlash);

    //
    // At this point wszChildKey cannot be NULL because it has been validated above,
    // 
    //

    (*o_wszChildKey)++;

    hr = i_pAdminBase->OpenKey(NULL,
                               wszParentKey,
                               METADATA_PERMISSION_WRITE,                // TODO: Check if OK
                               MB_TIMEOUT,                            // TODO: Check if OK
                               o_pHandle);

    if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        //
        // TODO: If the parent is already deleted, then do we care?
        //       The child should have also been deleted.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to open %s key. IMSAdminBase::OpenKey failed with hr = 0x%x. Assuming %s is deleted.\n", 
                  wszParentKey, hr, i_wszLocation));

        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ProcessChanges] Unable to open %s key. IMSAdminBase::OpenKey failed with hr = 0x%x. Hence unable to delete %s.\n", 
                  wszParentKey, hr, i_wszLocation));

        goto exit;
    }

exit:

	if(NULL != wszParentKey)
	{
		delete [] wszParentKey;
		wszParentKey = NULL;
	}

	return hr;

} // CFileListener::OpenParentKeyAndGetChildKey


/***************************************************************************++

Routine Description:

    Opens the parent key and returns the pointer to the child key.

Arguments:

	[in]  Location.
	[in]  Adminbase pointer.
	[out] Metadata handle to opened key.
	[out] Pointer in the location string to the child key.
	[out] Bool indicating key was created.

Return Value:

    E_OUTOFMEMORY
	Base Object error codes for IMSAdminBase::OpenKey

--***************************************************************************/
HRESULT CFileListener::OpenKey(LPWSTR           i_wszLocation,
	                           IMSAdminBase*    i_pAdminBase,
							   BOOL             i_bAddIfMissing,
	                           METADATA_HANDLE* o_pHandle,
							   BOOL*            o_bInsertedKey)
{
	HRESULT hr           = S_OK;
	LPWSTR  wszParentKey = NULL;
	LPWSTR  wszChildKey  = NULL;

	if(NULL != o_bInsertedKey)
	{
		*o_bInsertedKey = FALSE;
	}

	hr = i_pAdminBase->OpenKey(NULL,
							   i_wszLocation,
							   METADATA_PERMISSION_WRITE,  
							   MB_TIMEOUT,                 
							   o_pHandle);

	if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr) 
	{
		if(i_bAddIfMissing)
		{
			 // 
			 // Perhaps a location was inserted and this was the first property
			 // in the location. Add the key and reopen it for write.
			 //

			hr = OpenParentKeyAndGetChildKey(i_wszLocation,
											 i_pAdminBase,
											 o_pHandle,
											 &wszChildKey);

			if(FAILED(hr))
			{
				if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
				{
					LogEvent(m_pCListenerController->EventLog(),
								MD_ERROR_METABASE_PATH_NOT_FOUND,
								EVENTLOG_ERROR_TYPE,
								ID_CAT_CAT,
								hr,
								i_wszLocation);

				}

				return hr;
			}

			hr = i_pAdminBase->AddKey(*o_pHandle,
									  wszChildKey);

			i_pAdminBase->CloseKey(*o_pHandle);
			*o_pHandle = NULL;

			if(FAILED(hr))
			{

				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::OpenKey] Unable to add %s key. IMSAdminBase::AddKey failed with hr = 0x%x.\n", 
						  i_wszLocation, hr));

				return hr;
			}

			if(NULL != o_bInsertedKey)
			{
				*o_bInsertedKey = TRUE;
			}

			hr = i_pAdminBase->OpenKey(NULL,
									   i_wszLocation,
									   METADATA_PERMISSION_WRITE,                
									   MB_TIMEOUT,                            
									   o_pHandle);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::OpenKey] Unable to open %s key, after successfully adding it. IMSAdminBase::OpenKey failed with hr = 0x%x.\n", 
						  i_wszLocation, hr));

				return hr;
			}

			DBGINFOW((DBG_CONTEXT,
					  L"[CFileListener::OpenKey] Successfully added and reopened %s key.\n", 
					  i_wszLocation));
		}
		else
		{
			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_METABASE_PATH_NOT_FOUND,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr,
						i_wszLocation);
		}

	}	
	else if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
          L"[CFileListener::OpenKey] Unable to open %s key. IMSAdminBase::OpenKey failed with unexpected hr = 0x%x.\n", 
          i_wszLocation, hr));
	}

	return hr;

} // CFileListener::OpenKey


/***************************************************************************++

Routine Description:

    Copies the read row into the write cache. This routine is called when
    a change has successfully been applied to the metabase. By copying the
    read row in the write cache, we are keeping track of all successful
    changes.

Arguments:

    [in] Read row index.
    [in] Write cache IST

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::SaveChange(ULONG                    i_iRow,
                                  ISimpleTableWrite2*    i_pISTDiff)
{
    ULONG   iWriteRow = 0;
    HRESULT hr        = S_OK;

    hr = i_pISTDiff->AddRowForUpdate(i_iRow,
                                     &iWriteRow);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n", 
                  hr));

		LogEvent(m_pCListenerController->EventLog(),
			        MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
			        EVENTLOG_ERROR_TYPE,
			        ID_CAT_CAT,
			        hr);

    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Adds a row in the write cache. It is called when a node is inserted in 
	the metabase, but the properties could not be applied.

Arguments:

    [in] Location.
    [in] Write cache IST

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::SaveChangeAsNodeWithNoPropertyAdded(LPVOID*                i_apvDiff,
									                       ISimpleTableWrite2*    i_pISTDiff)
{
    ULONG   iWriteRow = 0;
    HRESULT hr        = S_OK;

	MD_ASSERT(NULL != i_pISTDiff);

    hr = i_pISTDiff->AddRowForInsert(&iWriteRow);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n", 
                  hr));

		LogEvent(m_pCListenerController->EventLog(),
			        MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
			        EVENTLOG_ERROR_TYPE,
			        ID_CAT_CAT,
			        hr);

    }
	else
	{
		static LPCWSTR wszLocationNoProperty = L"#LocationWithNoProperties";
		static DWORD   dwIDLocation          = MD_LOCATION;
		static DWORD   dwType                = STRING_METADATA;
		static DWORD   dwAttributes          = METADATA_NO_ATTRIBUTES;
		static DWORD   dwDirective           = eMBPropertyDiff_Insert;
		static DWORD   dwUserType            = IIS_MD_UT_SERVER;
		static DWORD   dwGroup               = eMBProperty_IIsConfigObject;

	    LPVOID  a_pv[cMBPropertyDiff_NumberOfColumns];
		ULONG   a_iCol[] = {iMBPropertyDiff_Name,
                            iMBPropertyDiff_Type,
                            iMBPropertyDiff_Attributes,
                            iMBPropertyDiff_Value, 
                            iMBPropertyDiff_Location,   
                            iMBPropertyDiff_ID,   
                            iMBPropertyDiff_UserType,
                            iMBPropertyDiff_LocationID,
                            iMBPropertyDiff_Directive, 
                            iMBPropertyDiff_Group
		};
		ULONG  cCol = sizeof(a_iCol)/sizeof(ULONG);
	    ULONG  a_cb[cMBPropertyDiff_NumberOfColumns];

		a_cb[iMBPropertyDiff_Value] = 0;

		a_pv[iMBPropertyDiff_Name]        = (LPVOID)wszLocationNoProperty;
		a_pv[iMBPropertyDiff_Type]        = (LPVOID)&dwType;
		a_pv[iMBPropertyDiff_Attributes]  = (LPVOID)&dwAttributes;
		a_pv[iMBPropertyDiff_Value]       = NULL;
		a_pv[iMBPropertyDiff_Location]    = i_apvDiff[iMBPropertyDiff_Location];
		a_pv[iMBPropertyDiff_ID]          = (LPVOID)&dwIDLocation;
		a_pv[iMBPropertyDiff_UserType]    = (LPVOID)&dwUserType;
		a_pv[iMBPropertyDiff_LocationID]  = i_apvDiff[iMBPropertyDiff_LocationID];
		a_pv[iMBPropertyDiff_Directive]   = (LPVOID)&dwDirective;
		a_pv[iMBPropertyDiff_Group]       = (LPVOID)&dwGroup;

		hr = i_pISTDiff->SetWriteColumnValues(iWriteRow,
			                                  cCol,
											  a_iCol,
											  a_cb,
											  a_pv);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::SaveChanges] Unable to track successful changes. AddRowForUpdate failed with hr= 0x%x.\n", 
                      hr));

			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_SAVING_APPLIED_TEXT_EDITS,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr);

		}

	}

	return hr;

} // CFileListener::SaveChangeAsNodeWithNoPropertyAdded


/***************************************************************************++

Routine Description:

    Copies the changed file to the history directory with errors appended to 
    it.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::CopyErrorFile(BOOL            i_bGetTableFailed)
{
    LPWSTR              wszErrorFile        = NULL;
    HANDLE              hFind               = INVALID_HANDLE_VALUE;    
    WIN32_FIND_DATAW    FileData;    
    ULONG               ulMaxErrorVersion    = 0;
    ULONG               ulErrorVersion       = 0;
    WCHAR               wszErrorVersionNumber[MD_CCH_MAX_ULONG+1];
    HRESULT             hr                  = S_OK;
	int                 res                 = 0;
	LPWSTR              pEnd                = NULL;
	ULONG               ulBeginUnderscore   = 0;
	ULONG               ulBeginVersion      = 0;

	//
	// Restore the search string in case it has been overwritten
	//

	ulBeginUnderscore = m_cchErrorFileSearchString           - 
		                m_cchRealFileNameExtension           - 
		                MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW;

	ulBeginVersion = ulBeginUnderscore +
		             MD_CCH_UNDERSCOREW;

	pEnd = m_wszErrorFileSearchString + ulBeginUnderscore;
    memcpy(pEnd, MD_ERROR_FILE_SEARCH_EXTENSIONW, MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));

    //
    // Search for all existing error files and compute version number for the
	// new error file
    //

    hFind = FindFirstFileW(m_wszErrorFileSearchString, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
		hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::CopyErrorFile] No error files found. hr=0x%x.\n", 
                  hr));
    }
    else
    {
        do
        {
			ULONG 	ulBeginUnderscoreFileData = m_cchRealFileNameWithoutPathWithoutExtension +
				                                MD_CCH_ERROR_FILE_NAME_EXTENSIONW;

			res = swscanf(&(FileData.cFileName[ulBeginUnderscoreFileData]), 
						  L"_%lu",
						  &ulErrorVersion);

			if((0   == res) ||
			   (EOF == res)
			  )
			{
				// Simply continue;
				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::CopyErrorFile] Could not fetch error version number from %s - swscanf failed.\n", 
						  FileData.cFileName));

				continue;
			}

            if(ulErrorVersion >= ulMaxErrorVersion)
            {
                ulMaxErrorVersion = ulErrorVersion;
            }

        }while (FindNextFileW(hFind, &FileData));

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }

		if(0xFFFFFFFF == ulMaxErrorVersion)
		{
			ulMaxErrorVersion = 0;
		}
		else
		{
			ulMaxErrorVersion++;
		}
    }

	//
	// Compute the name for the new error file
	//

    res = _snwprintf(wszErrorVersionNumber, 
		             MD_CCH_MAX_ULONG+1, 
			         L"%010lu", 
                     ulMaxErrorVersion);

	if(res < 0)
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[CopyErrorFile] _snwprintf returned a negative value. This should never happen.\n"));

	}
	else
	{
		pEnd = m_wszErrorFileSearchString + ulBeginVersion;
	    memcpy(pEnd, wszErrorVersionNumber, MD_CCH_MAX_ULONG*sizeof(WCHAR));

		//
		// Copy the error file and set security on it.
		//

		if(!CopyFileW(m_wszEditWhileRunningTempDataFile,
					  m_wszErrorFileSearchString,
					  FALSE))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());

			DBGINFOW((DBG_CONTEXT,
					  L"[CFileListener::CopyErrorFile] CopyFile failed with. hr=0x%x.\n", 
					  hr));

			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_COPY_ERROR_FILE,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr,
						m_wszErrorFileSearchString);

		}
		else
		{
			SetSecurityOnFile(m_wszEditWhileRunningTempDataFile,
							  m_wszErrorFileSearchString);

			LogEvent(m_pCListenerController->EventLog(),
						MD_ERROR_PROCESSING_TEXT_EDITS,
						EVENTLOG_ERROR_TYPE,
						ID_CAT_CAT,
						hr);

		}
	}

    //
    // If GetTable fails, then force savedata so that an invalid XML 
    // file overwritten with the correct in memory representation.
    // That way if the service is shuts down, we are not left with
    // an invalid file
    //

    if(i_bGetTableFailed)
    {
        if(NULL == m_pAdminBase)
        {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::CopyErrorFile] Unable to create the admin base object. hr = 0x%x\n", 
                      hr));
        }
		else
        {
			g_rMasterResource->Lock(TSRES_LOCK_WRITE);

			g_dwSystemChangeNumber++; // Increment the system change number to force a flush to  disk.

    		g_rMasterResource->Unlock();

            hr = m_pAdminBase->SaveData();

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::CopyErrorFile] IMSAdminBase::SaveData failed with hr = 0x%x\n", 
                          hr));
            }

        }
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Create a new history file with an inceremented minor version and apply 
    to it all the succesful changes that made it into memory/

Arguments:

    [in] IST helper.
    [in] Diff table that has all the successful updates in the write cache.
    [in] changed file.
    [in] history file against which the changed file was compared
    [in] new minor version, with which you need to create the history file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::ApplyChangeToHistoryFile(CWriterGlobalHelper*       pISTHelper,
                                        ISimpleTableWrite2*        pISTDiff,
                                        LPWSTR                     wszHistoryFile,
                                        ULONG                      i_ulMajorVersion,
                                        ULONG                      i_ulMinorVersion)
{
    STQueryCell           QueryCellHistory[2];
    ULONG                 cCellHistory           = sizeof(QueryCellHistory)/sizeof(STQueryCell);
    HRESULT               hr                     = S_OK;
    ISimpleTableRead2*    pISTHistory            = NULL;
    ULONG                 iWriteRowDiff          = 0;
    ULONG                 iReadRowHistory        = 0;
    LPWSTR                wszNewHistoryFile      = NULL;
    LPWSTR                wszNewSchemaFile       = NULL;
    LPCWSTR               wszDotExtension        = L".";
    WCHAR                 wchDotExtension        = L'.';
    LPWSTR                wszEnd                 = NULL;
    CWriter*              pCWriter               = NULL;
	BOOL                  bNoChanges             = FALSE;

	//
	// If the diff table is missing the assume no changes. This can happen when
	// there is a parsing error and get table on it fails.
	//

	if(NULL == pISTDiff)
	{
		goto exit;
	}

    //
    // Create the temp bakup file
    //

    hr = ConstructHistoryFileName(&wszNewHistoryFile,
                                  m_wszHistoryFileDir,
                                  m_cchHistoryFileDir,
                                  m_wszRealFileNameWithoutPathWithoutExtension,
                                  m_cchRealFileNameWithoutPathWithoutExtension,
                                  m_wszRealFileNameExtension,
                                  m_cchRealFileNameExtension,
                                  i_ulMajorVersion,
                                  i_ulMinorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = ConstructHistoryFileName(&wszNewSchemaFile,
                                  m_wszHistoryFileDir,
                                  m_cchHistoryFileDir,
                                  m_wszSchemaFileNameWithoutPathWithoutExtension,
                                  m_cchSchemaFileNameWithoutPathWithoutExtension,
                                  m_wszSchemaFileNameExtension,
                                  m_cchSchemaFileNameExtension,
                                  i_ulMajorVersion,
                                  i_ulMinorVersion);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBGINFOW((DBG_CONTEXT,
              L"[CFileListener::ApplyChangeToHistoryFile] Attempting to create a new version of the hisory file %s, %s that contains all the successful updates to the metabase.\n", 
              wszNewHistoryFile, wszNewSchemaFile));

    DBGINFOW((DBG_CONTEXT,
              L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n", 
              wszNewHistoryFile,
              pISTHelper->m_wszBinFileForMeta));

    pCWriter = new CWriter();
    if(NULL == pCWriter)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pCWriter->Initialize(m_wszEditWhileRunningTempDataFileWithAppliedEdits,
                              pISTHelper,
                              NULL);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the hisory file %s. CWriter::Initialize failed with hr = 0x%x.\n", 
                  wszNewHistoryFile, hr));
        goto exit;
    }

    //
    // Get the backed up table
    //

    QueryCellHistory[0].pData     = (LPVOID)pISTHelper->m_wszBinFileForMeta;
    QueryCellHistory[0].eOperator = eST_OP_EQUAL;
    QueryCellHistory[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCellHistory[0].dbType    = DBTYPE_WSTR;
    QueryCellHistory[0].cbSize    = 0;

    QueryCellHistory[1].pData     = (LPVOID)wszHistoryFile;
    QueryCellHistory[1].eOperator = eST_OP_EQUAL;
    QueryCellHistory[1].iCell     = iST_CELL_FILE;
    QueryCellHistory[1].dbType    = DBTYPE_WSTR;
    QueryCellHistory[1].cbSize    = (lstrlenW(wszHistoryFile)+1)*sizeof(WCHAR);

    hr = m_pISTDisp->GetTable(wszDATABASE_METABASE,
                              wszTABLE_MBProperty,
                              (LPVOID)QueryCellHistory,
                              (LPVOID)&cCellHistory,
                              eST_QUERYFORMAT_CELLS,
                              0,
                              (LPVOID *)&pISTHistory);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the hisory file %s. GetTable on table %s from file %s failed with hr = 0x%x.\n", 
                  wszNewHistoryFile, wszTABLE_MBProperty, wszHistoryFile, hr));

        goto exit; // TODO: Log an error
    }

    hr = pCWriter->BeginWrite(eWriter_Metabase);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the hisory file %s. CWriter::BeginWrite failed with hr = 0x%x.\n", 
                  wszNewHistoryFile, hr));
        goto exit;
    }

    for(iWriteRowDiff=0,iReadRowHistory=0; ;)
    {
        LPVOID a_pvDiff[cMBPropertyDiff_NumberOfColumns];
        ULONG  a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
        ULONG  cColDiff = cMBPropertyDiff_NumberOfColumns;
        LPVOID a_pvHistory[cMBProperty_NumberOfColumns];
        ULONG  a_cbSizeHistory[cMBProperty_NumberOfColumns];
        ULONG  cColHistory = cMBProperty_NumberOfColumns;

        //
        // Get a property from the diff table.
        //

        hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
                                            cColDiff,
                                            NULL,
                                            NULL,
                                            a_cbSizeDiff,
                                            a_pvDiff);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            if(iWriteRowDiff > 0)
            {
                //
                // Write the remaining records from the History table.
                //

                hr = MergeRemainingLocations(pCWriter,
                                             pISTHistory,
                                             TRUE,             // indicates wszTABLE_MBProperty,
                                             &iReadRowHistory);

            }
            else
            {
                //
                // There are no differences. Delete the temp file and exit.
                //
                bNoChanges = TRUE;
            }
            goto exit;
        }
        
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // Get a property from the history table.
        //

        hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                          cColHistory,
                                          NULL,
                                          a_cbSizeHistory,
                                          a_pvHistory);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;

            //
            // WriteRemaining records from diff table.
            //

            ISimpleTableRead2* pISTDiffRead = NULL;

            hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2, 
                                          (LPVOID*)&pISTDiffRead);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = MergeRemainingLocations(pCWriter,
                                         pISTDiffRead,
                                         FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                         &iWriteRowDiff);

            pISTDiffRead->Release();

            goto exit;
        }
        
        if(FAILED(hr))
        {
            goto exit;
        }

        if(_wcsicmp((LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]),(LPWSTR)(a_pvHistory[iMBProperty_Location])) < 0)
        {
            //
			// Found a location in the diff table that is not present in the 
			// history table - Assume inserts and write all properties of this 
			// location from the diff table.
            //

            ISimpleTableRead2* pISTDiffRead = NULL;

            hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2, 
                                          (LPVOID*)&pISTDiffRead);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = MergeLocation(pCWriter,
                               pISTDiffRead,
                               FALSE,           // indicates wszTABLE_MBPropertyDiff,
                               &iWriteRowDiff,
                               *(DWORD*)(a_pvDiff[iMBPropertyDiff_LocationID]),
                               (LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]));

            pISTDiffRead->Release();

        }
        else if(_wcsicmp((LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]),(LPWSTR)(a_pvHistory[iMBProperty_Location])) > 0)
        {
            //
			// Found a location in the history table that is not present in the 
			// diff table - Assume no change and write all properties of this 
			// location from the history table.
            //

            hr = MergeLocation(pCWriter,
                               pISTHistory,
                               TRUE,          // indicates wszTABLE_MBProperty,
                               &iReadRowHistory,
                               *(DWORD*)(a_pvHistory[iMBProperty_LocationID]),
                               (LPWSTR)(a_pvHistory[iMBProperty_Location]));

        }
        else 
        {
            //
            // Merge properties of this location from History and diff table.            
            //

            if(eMBPropertyDiff_DeleteNode == *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                //
                // No need to merge if the location has been deleted.
                // Move the History pointer to the next location.
                //

                ULONG  LocationIDHistory = *(DWORD*)a_pvHistory[iMBProperty_LocationID]; // save the location ID
                LPWSTR wszDelHistoryLocationStart = (LPWSTR)a_pvHistory[iMBProperty_Location];
                LPWSTR wszDelDiffLocationStart = (LPWSTR)a_pvDiff[iMBPropertyDiff_Location];

                iWriteRowDiff++;

                do
                {
                    iReadRowHistory++;

                    hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                                      cColHistory,
                                                      NULL,
                                                      a_cbSizeHistory,
                                                      a_pvHistory);

                    if(E_ST_NOMOREROWS == hr)
                    {
                        //
                        // WriteRemaining records from diff table.
                        //

                        ISimpleTableRead2* pISTDiffRead = NULL;

                        hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2, 
                                                      (LPVOID*)&pISTDiffRead);

                        if(FAILED(hr))
                        {
                            goto exit;
                        }

                        hr = MergeRemainingLocations(pCWriter,
                                                     pISTDiffRead,
                                                     FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                                     &iWriteRowDiff);

                        pISTDiffRead->Release();
            
                        goto exit;

                    }
                    else if(FAILED(hr))
                    {
                        goto exit;
                    }

					if(LocationIDHistory != *(DWORD*)(a_pvHistory[iMBProperty_LocationID]))
					{
						//
						// Reached a new location in the history table. Check if this is a sub-
						// location of the deleted location. If so, ignore all
						// such sub locations.
						//

						LPWSTR wszStart = wcsstr((LPWSTR)a_pvHistory[iMBProperty_Location], wszDelHistoryLocationStart);

						if(wszStart == (LPWSTR)a_pvHistory[iMBProperty_Location])
						{
							LocationIDHistory = *(DWORD*)(a_pvHistory[iMBProperty_LocationID]);
						}

						//
						// Move to the next location in the diff table. If it is a subset of the
						// parent location that was deleted, then assume it is a delete. Note
						// that if it is an update, we will ignore and treat it as a delete.
						//

						hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
															cColDiff,
															NULL,
															NULL,
															a_cbSizeDiff,
															a_pvDiff);

						if(E_ST_NOMOREROWS == hr)
						{
							hr = S_OK;
						}
						else if(FAILED(hr))
						{
							goto exit;
						}
						else
						{
							wszStart = wcsstr((LPWSTR)a_pvDiff[iMBPropertyDiff_Location], wszDelDiffLocationStart);

							if(wszStart == (LPWSTR)a_pvDiff[iMBPropertyDiff_Location])
							{
								iWriteRowDiff++;
							}
						}
					}

                }while(LocationIDHistory ==
                       *(DWORD*)(a_pvHistory[iMBProperty_LocationID])     
                      );

                continue;
            }
            else
            {
                hr = MergeLocation(pCWriter,
                                   pISTHistory,
                                   &iReadRowHistory,
                                   *(DWORD*)(a_pvHistory[iMBProperty_LocationID]),
                                   pISTDiff,
                                   &iWriteRowDiff,
                                   *(DWORD*)(a_pvDiff[iMBPropertyDiff_LocationID]),
                                   (LPWSTR)(a_pvDiff[iMBPropertyDiff_Location]));
            }
        }

        if(FAILED(hr))
        {
            goto exit;
        }

    }

exit:

	//
	// Release the history file before the move.
	//

    if(NULL != pISTHistory)
    {
        pISTHistory->Release();
        pISTHistory = NULL;
    }

	if(NULL != pCWriter)
	{
		if(FAILED(hr) || bNoChanges)
		{
			//
			// Delete the file.
			//

			HRESULT hrSav = S_OK;

			hrSav = pCWriter->EndWrite(eWriter_Abort);

			if(FAILED(hrSav))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::ApplyChangeToHistoryFile] Unable to abort write history data file %s. CWriter::EndWriter failed with hr = 0x%x.\n", 
						  wszNewHistoryFile, hrSav));
			}

		}
		else
		{
			hr = pCWriter->EndWrite(eWriter_Metabase);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the history data file %s. CWriter::EndWrite failed with hr = 0x%x.\n", 
						  wszNewHistoryFile, hr));

			}

		}

        delete pCWriter;
        pCWriter = NULL;

		//
		// Rename the updated minor version and 
		// Copy the schema file that corresponds to the bin file.
		//

		if(SUCCEEDED(hr) && (!bNoChanges))
		{
			if(MoveFileExW(m_wszEditWhileRunningTempDataFileWithAppliedEdits,
						   wszNewHistoryFile,
						   MOVEFILE_REPLACE_EXISTING)
			  )
			{
				LPWSTR pwszSchemaFile = m_wszEditWhileRunningTempSchemaFile;

				if(!m_bIsTempSchemaFile)
				{
					pwszSchemaFile = m_wszSchemaFileName;
				}


				if(!CopyFileW(pwszSchemaFile, 
							  wszNewSchemaFile,
							  FALSE))
				{
					hr = HRESULT_FROM_WIN32(GetLastError());

					DBGINFOW((DBG_CONTEXT,
							  L"[CFileListener::ApplyChangeToHistoryFile] Unable to write to new version of the history schema file %s. CopyFile failed with hr = 0x%x.\n", 
							  wszNewSchemaFile, hr));
					// TODO: Log an error - It is non fatal if you cannot copy teh schema file.
					hr = S_OK;
				}
				else
				{
					SetSecurityOnFile(pwszSchemaFile,
									  wszNewSchemaFile);

				}
			}
			else
			{
				hr = GetLastError();
				hr = HRESULT_FROM_WIN32(hr);

				DBGINFOW((DBG_CONTEXT,
						  L"[CFileListener::ApplyChangeToHistoryFile] Unable to create a new history file with the changes. MoveFile from %s to %s failed with hr = 0x%x. \n", 
						  m_wszEditWhileRunningTempDataFileWithAppliedEdits,
						  wszNewHistoryFile,
						  hr));

			}
		}

	}

    if(NULL != wszNewHistoryFile)
    {
        delete [] wszNewHistoryFile;
        wszNewHistoryFile = NULL;
    }

    if(NULL != wszNewSchemaFile)
    {
        delete [] wszNewSchemaFile;
        wszNewSchemaFile = NULL;
    }

    return hr;

} // CFileListener::ApplyChangeToHistoryFile


/***************************************************************************++

Routine Description:

    This function merges the remaining locations from either the write cache 
    of the diff table or the read cache of the mbproperty table from the  
    history file. It is called only when there are locations left in one or
    or the other, not both. i.e when common locations do not exist.

Arguments:

    [in] Writer object
    [in] IST to read locations from - note it can either be a read or write
         cache
    [in] Bool - used to identify read/write cache. If true, it indicates
	     MBProperty, else it indicates MBPropertyDiff
    [in] row index to start merging from.


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeRemainingLocations(CWriter*                pCWriter,
                                       ISimpleTableRead2*      pISTRead,
                                       BOOL                    bMBPropertyTable,
                                       ULONG*                  piRow)
{
    HRESULT                hr             = S_OK;
    ISimpleTableWrite2*    pISTWrite      = NULL;
    ULONG                  cCol           = 0;
    ULONG*                 a_cbSize       = NULL;
    LPVOID*                a_pv           = NULL;
    ULONG                  a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID                 a_pvDiff[cMBPropertyDiff_NumberOfColumns];
    ULONG                  a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID                 a_pvHistory[cMBProperty_NumberOfColumns];
    ULONG                  iColLocationID = 0;
    ULONG                  iColLocation   = 0;

    if(!bMBPropertyTable)
    {
        hr = pISTRead->QueryInterface(IID_ISimpleTableWrite2,
                                      (LPVOID*)&pISTWrite);

        if(FAILED(hr))
        {
            return hr;
        }

        cCol           = cMBPropertyDiff_NumberOfColumns;
        a_cbSize       = a_cbSizeDiff;
        a_pv           = a_pvDiff;
        iColLocationID = iMBPropertyDiff_LocationID;
        iColLocation   = iMBPropertyDiff_Location;
		
    }
    else
    {
        cCol           = cMBProperty_NumberOfColumns;
        a_cbSize       = a_cbSizeHistory;
        a_pv           = a_pvHistory;
        iColLocationID = iMBProperty_LocationID;
        iColLocation   = iMBProperty_Location;

    }


    for(ULONG iRow=*piRow;;)
    {
        if(NULL != pISTWrite)
        {
            hr = pISTWrite->GetWriteColumnValues(iRow,
                                                 cCol,
                                                 NULL,
                                                 NULL,
                                                 a_cbSize,
                                                 a_pv);
        }
        else
        {
            hr = pISTRead->GetColumnValues(iRow,
                                           cCol,
                                           NULL,
                                           a_cbSize,
                                           a_pv);
        }

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            goto exit;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        hr = MergeLocation(pCWriter,
                           pISTRead,
                           bMBPropertyTable,
                           &iRow,
                           *(DWORD*)a_pv[iColLocationID],
                           (LPWSTR)a_pv[iColLocation]);
    
        if(FAILED(hr))
        {
            goto exit;
        }
    }    

exit:

    if(SUCCEEDED(hr))
    {
        *piRow = iRow;
    }

    if(NULL != pISTWrite)
    {
        pISTWrite->Release();
        pISTWrite = NULL;
    }

    return hr;

} // CFileListener::MergeRemainingLocations


/***************************************************************************++

Routine Description:

    This function merges a location from the write cache of the diff table
    with the read cache of the mbproperty table. It basically applies all 
    the changes that were applied to the metabase (stored in the write cache
    of the diff table) with the read cache of the mbproperty table from the  
    history file.

Arguments:

    [in] Writer object
    [in] read cache of the mbproperty table from history file
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         read cache
    [in] write cache of the diff table
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         write cache
    [in] location being merged.

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeLocation(CWriter*                pCWriter,
                             ISimpleTableRead2*      pISTHistory,
                             ULONG*                  piReadRowHistory,
                             ULONG                   LocationIDHistory,
                             ISimpleTableWrite2*     pISTDiff,
                             ULONG*                  piWriteRowDiff,
                             ULONG                   LocationIDDiff,
                             LPCWSTR                 wszLocation)
{

    HRESULT                     hr                  = S_OK;
    ISimpleTableWrite2*         pISTMerged          = NULL;
    ULONG                       iReadRowHistory, iWriteRowDiff;
    IAdvancedTableDispenser*    pISTAdvanced        = NULL;
    CLocationWriter*            pCLocationWriter    = NULL;

     DBGINFOW((DBG_CONTEXT,
               L"[CFileListener::MergeLocation] %s.\n", wszLocation));

    //
    // Merge History and the diff table. Merge the well known properties first,
    // then the custom properties.
    //

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszLocation);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s. failed because CWriter::GetLocationWriter failed with hr = 0x%x.\n", 
                  wszLocation, hr));

        goto exit;
    }

    iReadRowHistory = *piReadRowHistory;
    iWriteRowDiff = *piWriteRowDiff;

    hr = MergeProperties(pCLocationWriter,
                         pISTHistory,
                         &iReadRowHistory,
                         LocationIDHistory,
                         pISTDiff,
                         &iWriteRowDiff,
                         LocationIDDiff);

    if(FAILED(hr))
    {
        goto exit;
    }

    *piReadRowHistory = iReadRowHistory;
    *piWriteRowDiff = iWriteRowDiff;

    hr = pCLocationWriter->WriteLocation(TRUE);    // Need to sort - Custom property may have been converted to a well-known property and vice versa.

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s. failed because CWriter::WriteLocation failed with hr = 0x%x.\n", 
                  wszLocation, hr));

        goto exit;
    }

exit:

    if(NULL != pISTMerged)
    {
        pISTMerged->Release();
        pISTMerged = NULL;
    }

    if(NULL != pISTAdvanced)
    {
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pCLocationWriter)
    {    
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;

} // CFileListener::MergeLocation


/***************************************************************************++

Routine Description:

    This function merges properties in a given location from the write cache 
    of the diff table with the read cache of the mbproperty table. It basically 
    applies all  the changes that were applied to the metabase (stored in the 
    write cache of the diff table) with the read cache of the mbproperty 
    table from the history file.

Arguments:

    [in] Bool to indicate merging custom or well-known properties
    [in] Location writer object
    [in] read cache of the mbproperty table from history file
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         read cache
    [in] write cache of the diff table
    [in] start row index for the above cache
    [in] location id of the location being merged, with respect to the above
         write cache

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeProperties(CLocationWriter*        pCLocationWriter,
                               ISimpleTableRead2*      pISTHistory,
                               ULONG*                  piReadRowHistory,
                               ULONG                   LocationIDHistory,
                               ISimpleTableWrite2*     pISTDiff,
                               ULONG*                  piWriteRowDiff,
                               ULONG                   LocationIDDiff)    
{
    HRESULT             hr               = S_OK;
    ISimpleTableRead2*    pISTDiffRead   = NULL;
    ULONG               iReadRowHistory  = 0;
    ULONG               iWriteRowDiff    = 0;

    ULONG               cColHistory      = cMBProperty_NumberOfColumns;
    ULONG               a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID              a_pvHistory[cMBProperty_NumberOfColumns];

    ULONG               cColDiff         = cMBPropertyDiff_NumberOfColumns;
    ULONG               a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID              a_pvDiff[cMBPropertyDiff_NumberOfColumns];

    BOOL                bGetNextReadRowFromHistory = TRUE;
    BOOL                bGetNextWriteRowFromDiff   = TRUE;

    for(iReadRowHistory=(*piReadRowHistory), iWriteRowDiff=(*piWriteRowDiff);;)
    {
        if(bGetNextReadRowFromHistory)
        {
            //
            // Move to the next property in the History table. 
            //

            hr = pISTHistory->GetColumnValues(iReadRowHistory,
                                             cColHistory,
                                             NULL,
                                             a_cbSizeHistory,
                                             a_pvHistory);

            if( (E_ST_NOMOREROWS == hr) ||
                (LocationIDHistory != *(DWORD*)a_pvHistory[iMBProperty_LocationID])
              )
            {
                //
                //    Merge the remaining properties from the diff table.
                //

                hr = pISTDiff->QueryInterface(IID_ISimpleTableRead2,
                                              (LPVOID*)&pISTDiffRead);

                if(FAILED(hr))
                {
                    goto exit;
                }

                hr = MergeRemainingProperties(pCLocationWriter,
                                              pISTDiffRead,
                                              FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                              &iWriteRowDiff,
                                              LocationIDDiff);

                pISTDiffRead->Release();
                pISTDiffRead = NULL;

                goto exit;
            }
            else if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] GetColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                          iReadRowHistory, wszTABLE_MBProperty, hr, 
                          (LPWSTR)a_pvHistory[iMBProperty_Location], 
                          *(DWORD*)a_pvHistory[iMBProperty_ID]));
                goto exit;
            }

        }

        if(bGetNextWriteRowFromDiff)
        {
            //
            // Move to the next property in the diff table. 
            //

            hr = pISTDiff->GetWriteColumnValues(iWriteRowDiff,
                                                cColDiff,
                                                NULL,
                                                NULL,
                                                a_cbSizeDiff,
                                                a_pvDiff);

            if( (E_ST_NOMOREROWS == hr) ||
                (LocationIDDiff != *(DWORD*)a_pvDiff[iMBProperty_LocationID])
              )
            {
                //
                //    Merge the remaining properties from the History table.
                //

                hr = MergeRemainingProperties(pCLocationWriter,
                                              pISTHistory,
                                              TRUE,               // indicates wszTABLE_MBProperty,
                                              &iReadRowHistory,
                                              LocationIDHistory);
                goto exit;
            }
            else if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] GetColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                          iWriteRowDiff, wszTABLE_MBPropertyDiff, hr, 
                          (LPWSTR)a_pvDiff[iMBPropertyDiff_Location], 
                          *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                goto exit;
            }

        }

        //
        // After moving in both tables, reset the flags
        //

        bGetNextReadRowFromHistory = FALSE;
        bGetNextWriteRowFromDiff = FALSE;

        if(_wcsicmp((LPWSTR)a_pvDiff[iMBPropertyDiff_Name], (LPWSTR)a_pvHistory[iMBProperty_Name]) < 0)
        {
            //
            // Found a name in the diff table that is not present in the History
            // table. Should be an insert and not update/delete. Increment the
            // diff pointer.
            //

            switch(*(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                case eMBPropertyDiff_Insert:
                    hr = pCLocationWriter->AddProperty(FALSE,          // indicates wszTABLE_MBPropertyDiff
                                                       a_pvDiff,
                                                       a_cbSizeDiff);

                    if(FAILED(hr))
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n", 
                                  wszTABLE_MBPropertyDiff, hr, 
                                  (LPWSTR)a_pvDiff[iMBPropertyDiff_Location], 
                                  *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));

                        goto exit;
                    }

                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;

                    break;

                case eMBPropertyDiff_Update:
                case eMBPropertyDiff_Delete:
                case eMBPropertyDiff_DeleteNode:
                default:
                    //
                    // TODO: Assert or log an error here
                    //

                    DBGINFOW((DBG_CONTEXT,
                              L"[CFileListener::MergeProperties] Unexpected directive:%d. Location = %s, Property ID: %d.\n", 
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive], 
                              (LPWSTR)a_pvDiff[iMBPropertyDiff_Location], 
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));

                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto exit;

            }
        }
        else if(_wcsicmp((LPWSTR)a_pvDiff[iMBPropertyDiff_Name], (LPWSTR)a_pvHistory[iMBProperty_Name]) > 0)
        {
            //
            // Add the History row to the merged table.
            // Increment the History pointer.
            //
            hr = pCLocationWriter->AddProperty(TRUE,            // indicates wszTABLE_MBProperty
                                               a_pvHistory,
                                               a_cbSizeHistory);
            

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n", 
                          wszTABLE_MBProperty, hr, 
                          (LPWSTR)a_pvHistory[iMBProperty_Location], 
                          *(DWORD*)a_pvHistory[iMBProperty_ID]));
                goto exit;
            }

            iReadRowHistory++;
            bGetNextReadRowFromHistory = TRUE;

        }
        else
        {
            //
            // Read from Diff table.
            // Increment the History and the diff pointer.
            //

            switch(*(DWORD*)a_pvDiff[iMBPropertyDiff_Directive])
            {
                case eMBPropertyDiff_Insert:
                case eMBPropertyDiff_Update:

                    hr = pCLocationWriter->AddProperty(FALSE,           // indicates wszTABLE_MBPropertyDiff,
                                                       a_pvDiff,
                                                       a_cbSizeDiff);

                    if(FAILED(hr))
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[CFileListener::MergeProperties] CLocationWriter::AddProperty from a location in table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n", 
                                  wszTABLE_MBPropertyDiff, hr, 
                                  (LPWSTR)a_pvDiff[iMBPropertyDiff_Location], 
                                  *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                        goto exit;
                    }

                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;
                    iReadRowHistory++;
                    bGetNextReadRowFromHistory = TRUE;

                    break;

                case eMBPropertyDiff_Delete:
                    iWriteRowDiff++;
                    bGetNextWriteRowFromDiff = TRUE;
                    iReadRowHistory++;
                    bGetNextReadRowFromHistory = TRUE;
                    break;

                case eMBPropertyDiff_DeleteNode:                    
                default:
                    //
                    // TODO: Assert or log an error here
                    //
                    DBGINFOW((DBG_CONTEXT,
                              L"[CFileListener::MergeProperties] Unexpected directive:%d. Location = %s, Property ID: %d.\n", 
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_Directive], 
                              (LPWSTR)a_pvDiff[iMBPropertyDiff_Location], 
                              *(DWORD*)a_pvDiff[iMBPropertyDiff_ID]));
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto exit;

            }
        }

    }

exit:

    if(SUCCEEDED(hr))
    {
        *piReadRowHistory = iReadRowHistory;
        *piWriteRowDiff = iWriteRowDiff;
    }

    return hr;

} // CFileListener::MergeProperties


/***************************************************************************++

Routine Description:

    This function merges a location either from the write cache of the diff 
    table or the read cache of the mbproperty table from the history file,
    not both. It is called when there are no more common locations left to 
    be merged, and one of the caches has remianing locations,

Arguments:

    [in] writer object
    [in] IST to read locations from - note it can either be a read or write
         cache 
    [in] Bool - used to identify read/write cache. If true it indicates 
	     MBProperty else it indicates MBPropertyDiff
    [in] row index to start merging from.
    [in] location id of the location being merged, with respect to the above
         cache
    [in] location name

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeLocation(CWriter*                pCWriter,
                             ISimpleTableRead2*      pISTRead,
                             BOOL                    bMBPropertyTable,
                             ULONG*                  piRow,
                             ULONG                   LocationID,
                             LPCWSTR                 wszLocation)
{

    HRESULT                     hr               = S_OK;
    ULONG                       iRow             = *piRow;
    ISimpleTableWrite2*         pISTMerged       = NULL;
    IAdvancedTableDispenser*    pISTAdvanced     = NULL;
    CLocationWriter*            pCLocationWriter = NULL;
	LPWSTR                      wszTable         = NULL;
	
	if(bMBPropertyTable)
	{
		wszTable = wszTABLE_MBProperty;
	}
	else
	{
		wszTable = wszTABLE_MBPropertyDiff;
	}

     DBGINFOW((DBG_CONTEXT,
               L"[CFileListener::MergeLocation] Copy %s from %s.\n", 
               wszLocation, wszTable));

    //
    // Merge the diff table with the History table, location by location.
    //

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszLocation);

    if(FAILED(hr))
    {

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] %s from %s. Unable to merge, GetLocationWriter failed with hr = 0x%x.\n", 
                  wszLocation, wszTable, hr));

        goto exit;
    }

    hr = MergeRemainingProperties(pCLocationWriter,
                                  pISTRead,
                                  bMBPropertyTable,
                                  &iRow,
                                  LocationID);
    
    if(FAILED(hr))
    {
        goto exit;
    }

    *piRow = iRow;

    hr = pCLocationWriter->WriteLocation(TRUE);    // Need to sort - a custom property may have got converted to a non custom and vice versa.
    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::MergeLocation] Copy %s from %s failed CLocationWriter::WriteLocation failed with hr = 0x%x.\n", 
                  wszLocation, wszTable, hr));
        goto exit;
    }

exit:

    if(NULL != pISTMerged)
    {
        pISTMerged->Release();
        pISTMerged = NULL;
    }

    if(NULL != pISTAdvanced)
    {    
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;

} // CFileListener::MergeLocation


/***************************************************************************++

Routine Description:

    This function merges remaining properties from a location either from 
    the write cache of the diff table or the read cache of the mbproperty,
    table from the history file, not both. It is called when there are no 
    more common locations left to be merged, and one of the caches has 
    remaining locations with properties.

Arguments:

    [in] location writer
    [in] IST to read locations from - note it can either be a read or write
         cache 
    [in] bool - used to identify read/write cache. if true it is in 
	     MBProperty, else MBPropertyDiff
    [in] row index to start merging from.
    [in] location id of the location being merged, with respect to the above
         cache

    Note - Although one location is being merged, the same location can have
    different IDs in different IST caches.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::MergeRemainingProperties(CLocationWriter*    pCLocationWriter,
                                        ISimpleTableRead2*  pISTRead,
                                        BOOL                bMBPropertyTable,
                                        ULONG*              piRow,
                                        ULONG                LocationID)
{
    HRESULT             hr             = S_OK;
    ISimpleTableWrite2*    pISTWrite      = NULL;
    ULONG               cCol           = 0;
    ULONG*              a_cbSize       = NULL;
    LPVOID*             a_pv           = NULL;
    ULONG               iColLocation   = 0;
    ULONG               iColLocationID = 0;
    ULONG               iColGroup      = 0;
    ULONG               cColMerged     = cMBProperty_NumberOfColumns;
    ULONG                iColID         = 0;
    ULONG                iColValue      = 0;
	LPWSTR              wszTable       = NULL;
    
    ULONG               a_cbSizeDiff[cMBPropertyDiff_NumberOfColumns];
    ULONG               a_cbSizeHistory[cMBProperty_NumberOfColumns];
    LPVOID              a_pvDiff[cMBPropertyDiff_NumberOfColumns];
    LPVOID              a_pvHistory[cMBProperty_NumberOfColumns];

    //
    // If the table being merged if the "Diff" table then we need to read from
    // its write cache because all the successful updates will have been moved
    // into the write cache.

    //
    // If the table being merged is the "History" table the we need to read from
    // the read cache.
    //

    if(!bMBPropertyTable)
    {
        hr = pISTRead->QueryInterface(IID_ISimpleTableWrite2,
                                      (LPVOID*)&pISTWrite);

        if(FAILED(hr))
        {
            return hr;
        }

        cCol           = cMBPropertyDiff_NumberOfColumns;
        a_cbSize       = a_cbSizeDiff;
        a_pv           = a_pvDiff;
        iColLocation   = iMBPropertyDiff_Location;
        iColLocationID = iMBPropertyDiff_LocationID;
        iColGroup      = iMBPropertyDiff_Group;
        iColID         = iMBPropertyDiff_ID;
        iColValue      = iMBPropertyDiff_Value;
		wszTable       = wszTABLE_MBPropertyDiff;
    }
    else 
    {
        cCol           = cMBProperty_NumberOfColumns;
        a_cbSize       = a_cbSizeHistory;
        a_pv           = a_pvHistory;
        iColLocation   = iMBProperty_Location;
        iColLocationID = iMBProperty_LocationID;
        iColGroup      = iMBProperty_Group;
        iColID         = iMBProperty_ID;
        iColValue      = iMBProperty_Value;
		wszTable       = wszTABLE_MBProperty;
    }

    for(ULONG iRow=*piRow;;iRow++)
    {
        ULONG iWriteRowMerged = 0;

        if(NULL == pISTWrite)
        {
            hr = pISTRead->GetColumnValues(iRow,
                                           cCol,
                                           NULL,
                                           a_cbSize,
                                           a_pv);


        }
        else
        {
            hr = pISTWrite->GetWriteColumnValues(iRow,
                                                 cCol,
                                                 NULL,
                                                 NULL,
                                                 a_cbSize,
                                                 a_pv);
        }

        if(E_ST_NOMOREROWS == hr)
        {
            *piRow = iRow;
            hr = S_OK;
            goto exit;
        }
        else if (FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[CFileListener::MergeRemainingProperties] GetColumnValues/GetWriteColumnValues on row %d from table %s failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                      iRow, wszTable, hr,
                      (LPWSTR)a_pv[iColLocation], 
                      *(DWORD*)a_pv[iColID]));
            return hr;
        }
        else if(*(DWORD*)a_pv[iColLocationID] != LocationID)
        {
            *piRow = iRow;
            hr = S_OK;
            goto exit;
        }
        else if(NULL != pISTWrite)
        {
            //
            // If we are merging properties from the diff table, then make sure 
            // that the directive is correct.
            //
            switch(*(DWORD*)a_pv[iMBPropertyDiff_Directive])
            {
            case eMBPropertyDiff_Insert:
                break;
            case eMBPropertyDiff_Update:
            case eMBPropertyDiff_Delete:
            case eMBPropertyDiff_DeleteNode:
            default:
                //
                // TODO: Assert here.
                //
                DBGINFOW((DBG_CONTEXT,
                          L"[CFileListener::MergeRemainingProperties] Incorrect directive.\n"));

                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto exit;
            }
        }
    
        hr = pCLocationWriter->AddProperty(bMBPropertyTable,
                                           a_pv,
                                           a_cbSize);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                       L"[CFileListener::MergeRemainingProperties] CLocationWriter::AddProperty failed with hr = 0x%x. Location = %s, Property ID: %d.\n",
                       hr, (LPWSTR)a_pv[iColLocation], *(DWORD*)a_pv[iColID]));

            goto exit;
        }

    }

exit:

    if(NULL != pISTWrite)
    {
        pISTWrite->Release();
        pISTWrite = NULL;
    }

    return hr;

} // CFileListener::MergeRemainingProperties


/***************************************************************************++

Routine Description:

    Utility function to fetch the version number of the file. 

Arguments:

    [out] Version number

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CFileListener::GetVersionNumber(LPWSTR    i_wszDataFile,
								ULONG*    o_pulVersionNumber,
								BOOL*     o_bGetTableFailed)
{
    HRESULT                    hr                = S_OK;
    ISimpleTableDispenser2* pISTDisp          = NULL;
    ISimpleTableRead2*      pISTProperty      = NULL;
    STQueryCell             QueryCell[2];
    ULONG                   cCell             = sizeof(QueryCell)/sizeof(STQueryCell);
    LPWSTR                  wszGlobalLocation = MD_GLOBAL_LOCATIONW;
    LPWSTR                  wszMajorVersion   = MD_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBERW;
    ULONG                   cbMajorVersion    = 0;
    ULONG*                  pulVersionNumber  = NULL;
	ULONG                   cRetry            = 0;

    //
    // Get only the root location - that where the timestamps are stored.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // No need to specify the schema file because we are getting a shipped
    // property from a global location.
    //

    QueryCell[0].pData     = (LPVOID)i_wszDataFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszDataFile)+1)*sizeof(WCHAR);
    
    QueryCell[1].pData     = (LPVOID)wszGlobalLocation;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iMBProperty_Location;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszGlobalLocation)+1)*sizeof(WCHAR);

	do
	{
		if(cRetry++ > 0)
		{
			//
			// If retrying because of sharing violation or path/file not found
			//, then sleep. Path or file not found can happen when the metabase
			// file is being renamed at the end of save all data.
			//
			Sleep(2000); 
		}

		hr = pISTDisp->GetTable(wszDATABASE_METABASE,
								wszTABLE_MBProperty,
								(LPVOID)QueryCell,
								(LPVOID)&cCell,
								eST_QUERYFORMAT_CELLS,
								0,
								(LPVOID *)&pISTProperty);

	} while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
			  (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
			  (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)    ||
			  (E_ST_INVALIDTABLE == hr)
			) && 
			(cRetry < 10)
		   );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] GetTable on %s from %s failed with hr = 0x%x.\n",
                  wszTABLE_MBProperty,
				  i_wszDataFile,
                  hr));

		if((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr) &&
		   (NULL != o_bGetTableFailed)
		  )
		{
			*o_bGetTableFailed = TRUE;
		}

        goto exit;
    }


    //
    // Get the version number.
    //

    hr = GetGlobalValue(pISTProperty,
                        wszMajorVersion,
                        &cbMajorVersion,
                        (LPVOID*)&pulVersionNumber);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetVersionNumber] Unable to read %s. GetGlobalValue failed with hr = 0x%x.\n",
                  wszMajorVersion,
                  hr));
        goto exit;

    }

    *o_pulVersionNumber = *(ULONG*)pulVersionNumber;

exit:

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Utility function to determine if the notification received is because of
	a programmatic save or a user edit. Note that if two SaveAllData's happen 
	in quick succession, this algorithm will break and it will treat it as
	as user edit and proceed with the diff. But at least for cases when
	this doesn't happen, the diff can be avoided.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
BOOL CFileListener::ProgrammaticMetabaseSaveNotification()
{
	HRESULT           hr                                    = S_OK;
	BOOL              bProgrammaticMetabaseSaveNotification = FALSE;
    WIN32_FIND_DATAW  CurrentMetabaseAttr;   
	WIN32_FIND_DATAW  CurrentEditWhileRunningTempDataFileAttr;
	FILETIME*         pCurrentEditWhileRunningTempDataFileLastWriteTimeStamp = NULL;
	FILETIME          MostRecentMetabaseFileLastWriteTimeStamp;
	ULONG             ulMostRecentMetabaseVersionNumber       = 0;
	ULONG             ulCurrentMetabaseVersion              = 0;
	BOOL              bSavingMetabaseFileToDisk             = FALSE;
	DWORD             dwRes                                 = 0;
	ULONG             cRetry                                = 0;

	//
	// Determine if it was a notification because of a programatic save or a 
	// save due to a user edit. Note that if two SaveAllData's happen in
	// quick succession, this algorithm will break and it will treat it as
	// as user edit and proceed with the diff. But at least for cases when
	// this doesn't happen, the diff can be avoided.
	//

	EnterCriticalSection(&g_csEditWhileRunning);

	bSavingMetabaseFileToDisk = g_bSavingMetabaseFileToDisk;

	if(bSavingMetabaseFileToDisk)
	{
		//
		// This means that a programmatic save was happening.
		// Save the metabase attributes as seen by the programmatic save.
		//

		MostRecentMetabaseFileLastWriteTimeStamp = g_MostRecentMetabaseFileLastWriteTimeStamp;
		ulMostRecentMetabaseVersionNumber        = g_ulMostRecentMetabaseVersion;
	}

	DBGINFO((DBG_CONTEXT,
			 "[ProgrammaticMetabaseSaveNotification] PREVIOUS SAVE TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n", 
			 g_MostRecentMetabaseFileLastWriteTimeStamp.dwLowDateTime,
			 g_MostRecentMetabaseFileLastWriteTimeStamp.dwHighDateTime));

	LeaveCriticalSection(&g_csEditWhileRunning);

	if(bSavingMetabaseFileToDisk)
	{
		//
		// This means that a programmatic save was happening.
		// Fetch the current metabase attributes
		//

		hr = GetMetabaseAttributes(&CurrentMetabaseAttr,
			                       &ulCurrentMetabaseVersion);

		if(SUCCEEDED(hr))
		{
			DBGINFO((DBG_CONTEXT,
					 "[ProgrammaticMetabaseSaveNotification] CURRENT TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n", 
					 CurrentMetabaseAttr.ftLastWriteTime.dwLowDateTime,
					 CurrentMetabaseAttr.ftLastWriteTime.dwHighDateTime));

			bProgrammaticMetabaseSaveNotification = CompareMetabaseAttributes(&MostRecentMetabaseFileLastWriteTimeStamp,
																			  ulMostRecentMetabaseVersionNumber,
																			  &(CurrentMetabaseAttr.ftLastWriteTime),
																			  ulCurrentMetabaseVersion);


		}

		//
		// If GetMetabaseAttributes fails, assume that it is not a programmatic
		// save and proceed with the diff.
		//

		if(bProgrammaticMetabaseSaveNotification)
		{
			goto exit;
		}

	}

	//
	// If you reach here it means that it was not a programmatic save or a
	// programmatic save happened but the current metabase attributes did
	// not match that of the programmatic save (may be due to a competing
	// user edit or due to two programmatic saves in quick succession). 
	// We assume that it is a user edit and we will proceed to copy  
	// the metabase to a temporary file in order to process the edit. It 
	// is necessary to make a copy of the file, because the file can be 
	// overwritten in the window between the version number fetch and the 
	// diff. If we always work with the copy we will not have the problem.
	// Note that once we make the copy we will re-get the version number
	// from the copied file and then proceed with the diff.
	//

	do
	{
		if(cRetry++ > 0)
		{
			//
			// If retrying because of sharing violation or path/file not found
			// then sleep. Path or file not found can happen when the metabase
			// file is being renamed at the end of save all data.
			//
			Sleep(2000); 
		}

		if(!CopyFileW(m_wszRealFileName,
					  m_wszEditWhileRunningTempDataFile,
					  FALSE))
		{
			dwRes = GetLastError();
			hr = HRESULT_FROM_WIN32(dwRes);
		}
		else
		{
			hr = S_OK;
		}

	} while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
			  (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
			  (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr) 
			) && 
			(cRetry < 10) 
		   );

	if(FAILED(hr))
	{

		DBGINFOW((DBG_CONTEXT,
			  L"[CFileListener::ProgrammaticMetabaseSaveNotification] CopyFile from %s to %s failed with hr = 0x%x. Hence unable to process edits.\n",
			  m_wszRealFileName,
			  m_wszEditWhileRunningTempDataFile,
			  hr));

		LogEvent(m_pCListenerController->EventLog(),
					MD_ERROR_COPYING_EDITED_FILE,
					EVENTLOG_ERROR_TYPE,
					ID_CAT_CAT,
					hr);

		CopyErrorFile(FALSE);

		//
		// Set this to true so that this user edit is not processed, because 
		// file copy to a temp file failed.
		//

		bProgrammaticMetabaseSaveNotification = TRUE;

		goto exit;
	}

	//
	// Reset the attributes on the temp file if necessary
	//

	ResetMetabaseAttributesIfNeeded((LPTSTR)m_wszEditWhileRunningTempDataFile,
									TRUE);

	//
	// Set the security on the file
	//

    SetSecurityOnFile(m_wszRealFileName,
                      m_wszEditWhileRunningTempDataFile);


    //
	// Save the last write time stamp on the file being processed.
	//

	if(!GetFileAttributesExW(m_wszEditWhileRunningTempDataFile, 
						     GetFileExInfoStandard,
						     &CurrentEditWhileRunningTempDataFileAttr)
	)
	{
		pCurrentEditWhileRunningTempDataFileLastWriteTimeStamp = &(CurrentMetabaseAttr.ftLastWriteTime);
	}
	else
	{
		pCurrentEditWhileRunningTempDataFileLastWriteTimeStamp = &(CurrentEditWhileRunningTempDataFileAttr.ftLastWriteTime);
	}

	EnterCriticalSection(&g_csEditWhileRunning);
	g_EWRProcessedMetabaseTimeStamp = *pCurrentEditWhileRunningTempDataFileLastWriteTimeStamp;
	LeaveCriticalSection(&g_csEditWhileRunning);

exit:

	if(bSavingMetabaseFileToDisk)
	{
		//
		// Reset the switch - This indicates that you are done with 
		// processing the notification that initially arrived because 
		// of a programmatic save. Note that it does not matter if
		// you did not treat it as a programmatic save.
		//

		EnterCriticalSection(&g_csEditWhileRunning);
		g_bSavingMetabaseFileToDisk              = FALSE;
		LeaveCriticalSection(&g_csEditWhileRunning);

	}

	return bProgrammaticMetabaseSaveNotification;

} // CFileListener::ProgrammaticMetabaseSaveNotification


/***************************************************************************++

Routine Description:

    Utility function to that fetches the current file attributes of the 
	metabase file and the version number in it. Note that this function
	does not lock the file, so it is not guranteed that both out params
	are indeed from the same file. (ie the metabase file can be overwritten
	in between the file attribute fetch and the version number fetch).

Arguments:

    [out] Metabase file attributes.
	[out] Metabase version number.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::GetMetabaseAttributes(WIN32_FIND_DATAW* pCurrentMetabaseAttr,
			                                 ULONG*            pulCurrentMetabaseVersion)
{

	HRESULT   hr       = S_OK;
    ULONG     cRetry   = 0;

	do
	{
		if(cRetry++ > 0)
		{
			//
			// If retrying because of sharing violation or path/file not found
			//, then sleep. Path or file not found can happen when the metabase
			// file is being renamed at the end of save all data.
			//
			Sleep(2000); 
		}

		if(!GetFileAttributesExW(m_wszRealFileName, 
								 GetFileExInfoStandard,
								 pCurrentMetabaseAttr)
		  )
		{
			DWORD dwRes = GetLastError();
			hr = HRESULT_FROM_WIN32(dwRes);
		}
		else
		{
			hr = S_OK;
		}

	} while(( (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr) ||
			  (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)    ||
			  (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)    
			) && 
			(cRetry < 10)
		   );


	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
		  L"[CFileListener::GetMetabaseAttributes] GetFileAttributesEx of %s failed with hr = 0x%x. Hence unable to determine if this is a programmatic save notification. Will assume that it is not.\n",
		  m_wszRealFileName,
		  hr));
		return hr;
	}

	//
	// GetVersionNumber already has the retry logic in it.
	//

	hr = GetVersionNumber(m_wszRealFileName,
		                  pulCurrentMetabaseVersion,
						  NULL);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
		  L"[CFileListener::GetMetabaseAttributes] GetVersionNumber of %s failed with hr = 0x%x. Hence unable to determine if this is a programmatic save notification. Will assume that it is not.\n",
		  m_wszRealFileName,
		  hr));
		return hr;
	}


	return hr;

} // CFileListener::GetMetabaseAttributes


/***************************************************************************++

Routine Description:

    Utility function to that compares the metabase file times and the metabase
	version number

Arguments:

    [in] Previous file create time stamp.
    [in] Previous last write create time stamp.
    [in] Previous metabase version
    [in] Current file create time stamp.
    [in] Current last write create time stamp.
    [in] Current metabase version

Return Value:

    BOOL

--***************************************************************************/
BOOL CFileListener::CompareMetabaseAttributes(FILETIME* pMostRecentMetabaseFileLastWriteTimeStamp,
											  ULONG		ulMostRecentMetabaseVersion,
											  FILETIME* pCurrentMetabaseFileLastWriteTimeStamp,
											  ULONG		ulCurrentMetabaseVersion)
{
	if( (ulMostRecentMetabaseVersion == ulCurrentMetabaseVersion)          && 
		(0 == CompareFileTime(pMostRecentMetabaseFileLastWriteTimeStamp,
			                  pCurrentMetabaseFileLastWriteTimeStamp)
	    )
	  )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

} // CFileListener::CompareMetabaseAttributes

/***************************************************************************++

Routine Description:

    This function gets the global helper object that has a  pointer to the bin
	file containing meta information. It is necessary that we copy the schema
	file because this can change while edits are being processed. (by a
	competing savealldata).

Arguments:

    [out] Global helper object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CFileListener::GetGlobalHelperAndCopySchemaFile(CWriterGlobalHelper**      o_pISTHelper)
{
	HRESULT hr = S_OK;

	//
	// We want to take a read lock here because we want to prevent any schema 
	// compilations. When the server is running, schema compilations take 
	// place when SaveAllData is called and if there is a schema change since 
	// the previous save. We will make a copy of the schema file before we 
	// release the lock, so that we have a snapshot of the schema that is used 
	// to process edit while running changes.
	//

	g_rMasterResource->Lock(TSRES_LOCK_WRITE);

    hr = ::GetGlobalHelper(TRUE,          // Means the call will fail if bin file is absent. 
                           o_pISTHelper);

    if(FAILED(hr))
    {
		LogEvent(m_pCListenerController->EventLog(),
					MD_ERROR_READING_SCHEMA_BIN,
					EVENTLOG_ERROR_TYPE,
					ID_CAT_CAT,
					hr);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::GetGlobalHelperAndCopySchemaFile] GetGlobalHelper failed with hr = 0x%x. Hence unable to get meta tables and hence unable to process changes.\n", 
                  hr));

        goto exit;
    }

	if(!CopyFileW(m_wszSchemaFileName,
			      m_wszEditWhileRunningTempSchemaFile,
				  FALSE))
	{
		DWORD dwRes = GetLastError();
		hr = HRESULT_FROM_WIN32(dwRes);

        DBGINFOW((DBG_CONTEXT,
                  L"[CFileListener::GetGlobalHelperAndCopySchemaFile] Copying schema file failed with hr = 0x%x. The schema file that is being stored with this version of edits may not be current.\n", 
                  hr));

		m_bIsTempSchemaFile = FALSE;
		hr = S_OK;
	}
	else
	{	
		m_bIsTempSchemaFile = TRUE;
		SetSecurityOnFile(m_wszSchemaFileName,
						  m_wszEditWhileRunningTempSchemaFile);
	}

exit:

	g_rMasterResource->Unlock();

	return hr;


} // CFileListener::GetGlobalHelperAndCopySchemaFile


/***************************************************************************++

Routine Description:

    This function deletes the temporary files created for processing in:
    ProgrammaticMetabaseSaveNotification
	GetGlobalHelperAndCopySchemaFile

Arguments:

    None

Return Value:

    void

--***************************************************************************/
void CFileListener::DeleteTempFiles()

{
	DeleteFileW(m_wszEditWhileRunningTempDataFile);

	if(m_bIsTempSchemaFile)
	{
		DeleteFileW(m_wszEditWhileRunningTempSchemaFile);
	}

    return;

} // CFileListener::DeleteTempFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\loadmd.cxx ===
// %%Includes: ---------------------------------------------------------------
#define INC_OLE2
#define STRICT
#include <mdcommon.hxx>

    DWORD   g_dwRegister;
// ---------------------------------------------------------------------------
// %%Function: main
// ---------------------------------------------------------------------------
BOOL
InitComMetadata(BOOL bRunAsExe)
{
    HRESULT hr;
    BOOL bReturn = TRUE;
    // initialize COM for free-threading
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        bReturn = FALSE;
    }
    CMDCOMSrvFactory   *pMDClassFactory = new CMDCOMSrvFactory;
    // register the class-object with OLE
    hr = CoRegisterClassObject(GETMDCLSID(!bRunAsExe), pMDClassFactory,
        CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &g_dwRegister);
    if (FAILED(hr)) {
        bReturn = FALSE;
    }

    return bReturn;
}  // main

BOOL
TerminateComMetadata()
{
    if( FAILED( CoRevokeClassObject(g_dwRegister) ) )
    {
        return FALSE;
    }

    CoUninitialize();

    return TRUE;
}

// EOF =======================================================================


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\importer.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ImpExpUtils.cpp

Abstract:

    IIS MetaBase subroutines to support Import

Author:

    Mohit Srivastava            04-April-01

Revision History:

Notes:

--*/

#include <svcmsg.h>
#include <mdcommon.hxx>

#include <iiscnfg.h>
#include <Importer.h>

//
// public
//

CImporter::CImporter(
    LPCWSTR  i_wszFileName,
    LPCSTR   i_pszPassword) : m_iRowDuplicateLocation(0xFFFFFFFF)
{
    m_bInitCalled  = false;

    m_wszFileName  = i_wszFileName;
    m_pszPassword  = i_pszPassword;
}

CImporter::~CImporter()
{
}

HRESULT CImporter::Init()
{
    MD_ASSERT(m_bInitCalled == false);
    m_bInitCalled = true;
    return InitIST();
}

HRESULT CImporter::DoIt(
    LPWSTR           i_wszSourcePath,
    LPCWSTR          i_wszKeyType,
    DWORD            i_dwMDFlags,
    CMDBaseObject**  o_ppboNew)
/*++

Synopsis: 

Arguments: [i_wszSourcePath] - 
           [i_wszKeyType] - 
           [i_dwMDFlags] - 
           [o_ppboNew] - 
           
Return Value: 

--*/
{
    MD_ASSERT(m_bInitCalled);
    MD_ASSERT(i_wszKeyType);
    MD_ASSERT(o_ppboNew);
    MD_ASSERT(*o_ppboNew == NULL);

    HRESULT              hr              = S_OK;
    BOOL                 bSawSourcePath  = false;

    //
    // This is a pointer to some node in *o_ppboNew
    // It is the current node we are reading to.
    //
    CMDBaseObject*       pboRead  = NULL;

    //
    // Used for decryption
    //
    IIS_CRYPTO_STORAGE*  pStorage = NULL;

    
    g_rMasterResource->Lock(TSRES_LOCK_READ);
    hr = InitSessionKey(m_spISTProperty, &pStorage, (LPSTR)m_pszPassword);
    g_rMasterResource->Unlock();
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Create the parent base object
    //
    *o_ppboNew = new CMDBaseObject(L"Thenamedoesntmatter", NULL);
    if (*o_ppboNew == NULL || !((*o_ppboNew)->IsValid()) ) 
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete *o_ppboNew;
        goto exit;
    }

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache.
    // Properties are sorted by location.
    //
    ULONG          acbMBPropertyRow[cMBProperty_NumberOfColumns];
    tMBPropertyRow MBPropertyRow;
    BOOL           bSkipLocation        = FALSE;
    DWORD          dwPreviousLocationID = -1;
    Relation       eRelation            = eREL_NONE;
    for(ULONG i=0; ;i++)
    {
        BOOL    bLocationWithProperty = TRUE;
        BOOL    bNewLocation          = FALSE;

        hr = m_spISTProperty->GetColumnValues(
            i, 
            cMBProperty_NumberOfColumns, 
            0, 
            acbMBPropertyRow, 
            (LPVOID*)&MBPropertyRow);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadSomeDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%s. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));

            goto exit;
        }
        else if(0 == wcscmp(MD_GLOBAL_LOCATIONW, MBPropertyRow.pLocation))
        {
            //
            // Ignore globals.
            //
            continue;
        }

        if((*MBPropertyRow.pID == MD_LOCATION) && (*MBPropertyRow.pName == MD_CH_LOC_NO_PROPERTYW))
        {
            bLocationWithProperty = FALSE;
        }
        if(dwPreviousLocationID != *MBPropertyRow.pLocationID)
        {
            bNewLocation  = TRUE;
            bSkipLocation = FALSE;
            dwPreviousLocationID = *MBPropertyRow.pLocationID;
            pboRead       = *o_ppboNew;
        }
        if(bSkipLocation)
        {
            continue;
        }
#if DBG
        if(bLocationWithProperty == false)
        {
            MD_ASSERT(bNewLocation);
        }
#endif

        if(bNewLocation)
        {
            //
            // See if we're at a (grand*)child or self
            //
            eRelation = GetRelation(i_wszSourcePath, MBPropertyRow.pLocation);

            switch(eRelation)
            {
            case eREL_SELF:
                if(*MBPropertyRow.pGroup != eMBProperty_IIsInheritedProperties)
                {
                    bSawSourcePath = true;
                }
                break;
            case eREL_PARENT:
                if(!(i_dwMDFlags & MD_IMPORT_INHERITED))
                {
                    bSkipLocation = TRUE;
                    continue;
                }
                break;
            case eREL_CHILD:
                if(i_dwMDFlags & MD_IMPORT_NODE_ONLY) 
                {
                    bSkipLocation = TRUE;
                    continue;
                }
                break;
            default: // eRelation == eREL_NONE
                bSkipLocation = TRUE;
                continue;
            }

            if(*MBPropertyRow.pGroup == eMBProperty_IIsInheritedProperties)
            {
                if(!(i_dwMDFlags & MD_IMPORT_INHERITED))
                {
                    bSkipLocation = TRUE;
                    continue;
                }
            }
        }

        //
        // Some checks to see whether we skip just the current property, but not
        // necessarily the entire location.
        //
        if(*MBPropertyRow.pGroup == eMBProperty_IIsInheritedProperties)
        {
            if( !(fMBProperty_INHERIT & *MBPropertyRow.pAttributes) )
            {
                continue;
            }
        }
        else
        {
            //
            // Check for keytype match
            //
            if( eRelation                     == eREL_SELF   &&
                *MBPropertyRow.pID            == MD_KEY_TYPE &&
                MBPropertyRow.pValue          != NULL &&
                i_wszKeyType[0]               != L'\0' )
            {
                if(_wcsicmp((LPWSTR)MBPropertyRow.pValue, i_wszKeyType) != 0)
                {
                    hr = RETURNCODETOHRESULT(ERROR_NO_MATCH);
                    goto exit;
                }
            }
        }

        if(eRelation == eREL_PARENT)
        {
            if( !(fMBProperty_INHERIT & *MBPropertyRow.pAttributes) )
            {
                continue;
            }
        }

        if(bNewLocation && (eRelation != eREL_PARENT))
        {
            //
            // Create node in the metabase if it is not there yet.
            // pboRead is pointer to this node.
            //
            hr = ReadMetaObject(i_wszSourcePath,
                                *o_ppboNew,
                                MBPropertyRow.pLocation,
                                &pboRead);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        if(bLocationWithProperty)
        {
            MD_ASSERT(pboRead != NULL);
            hr = ReadDataObject(pboRead,
                                (LPVOID*)&MBPropertyRow,
                                acbMBPropertyRow,
                                pStorage,
                                TRUE);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

    }

    if(!bSawSourcePath)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }

exit:

    //
    // Cleanup
    //
    if(FAILED(hr) && NULL != *o_ppboNew) 
    {
        delete (*o_ppboNew);
        *o_ppboNew = NULL;
    }

    delete pStorage;
    pStorage = NULL;

    return hr;
}

HRESULT CImporter::InitIST()
/*++

Synopsis: 

Return Value: 

--*/
{
    HRESULT     hr = S_OK;
    STQueryCell QueryCell[1];

    //
    // Get the property table.
    //
    QueryCell[0].pData     = (LPVOID)m_wszFileName;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(m_wszFileName)+1)*sizeof(WCHAR);

    ULONG cCell            = sizeof(QueryCell)/sizeof(STQueryCell);
        
    //
    // No need to initilize dispenser (InitializeSimpleTableDispenser()), 
    // because we now specify USE_CRT=1 in sources, which means that 
    // globals will be initialized.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &m_spISTDisp);
    if(FAILED(hr))
    {
        DBGERROR((
            DBG_CONTEXT,
            "[%s] GetSimpleTableDispenser failed with hr = 0x%x.\n",__FUNCTION__,hr));
        return hr;
    }

    hr = m_spISTDisp->GetTable(
        wszDATABASE_METABASE,
        wszTABLE_MBProperty,
        (LPVOID)QueryCell,
        (LPVOID)&cCell,
        eST_QUERYFORMAT_CELLS,
        fST_LOS_DETAILED_ERROR_TABLE | fST_LOS_NO_LOGGING,
        (LPVOID *)&m_spISTProperty);

    //
    // Log warnings/errors in getting the mb property table
    // Do this BEFORE checking the return code of GetTable.
    //
    CComPtr<IErrorInfo> spErrorInfo;
    HRESULT hrErrorTable = GetErrorInfo(0, &spErrorInfo);
    if(hrErrorTable == S_OK) // GetErrorInfo returns S_FALSE when there is no error object
    {
        //
        // Get the ICatalogErrorLogger interface to log the errors.
        //
        CComPtr<IAdvancedTableDispenser> spISTDispAdvanced;
        hrErrorTable = m_spISTDisp->QueryInterface(
            IID_IAdvancedTableDispenser,
            (LPVOID*)&spISTDispAdvanced);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT, 
                "[%s] Could not QI for Adv Dispenser, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            return hr;
        }

        hrErrorTable = spISTDispAdvanced->GetCatalogErrorLogger(&m_spILogger);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT, 
                "[%s] Could not get ICatalogErrorLogger2, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            return hr;
        }

        //
        // Get the ISimpleTableRead2 interface to read the errors.
        //
        hrErrorTable = 
            spErrorInfo->QueryInterface(IID_ISimpleTableRead2, (LPVOID*)&m_spISTError);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((DBG_CONTEXT, "[%s] Could not get ISTRead2 from IErrorInfo\n, __FUNCTION__"));
            return hr;
        }
            
        for(ULONG iRow=0; ; iRow++)
        {
            tDETAILEDERRORSRow ErrorInfo;            
            hrErrorTable = m_spISTError->GetColumnValues(
                iRow, 
                cDETAILEDERRORS_NumberOfColumns, 
                0, 
                0, 
                (LPVOID*)&ErrorInfo);
            if(hrErrorTable == E_ST_NOMOREROWS)
            {
                break;
            }
            if(FAILED(hrErrorTable))
            {
                DBGWARN((DBG_CONTEXT, "[%s] Could not read an error row.\n", __FUNCTION__));
                return hr;
            }

            DBG_ASSERT(ErrorInfo.pEvent);
            switch(*ErrorInfo.pEvent)
            {
            case IDS_METABASE_DUPLICATE_LOCATION:
                m_iRowDuplicateLocation = iRow;
                break;
            default:
                hrErrorTable =
                    m_spILogger->ReportError(
                        BaseVersion_DETAILEDERRORS, 
                        ExtendedVersion_DETAILEDERRORS, 
                        cDETAILEDERRORS_NumberOfColumns, 
                        0, 
                        (LPVOID*)&ErrorInfo);
                if(FAILED(hrErrorTable))
                {
                    DBGWARN((DBG_CONTEXT, "[%s] Could not log error.\n", __FUNCTION__));
                    return hr;
                }
                hr = MD_ERROR_READ_METABASE_FILE;
            }
        } // for(ULONG iRow=0; ; iRow++)
    } // if(hrErrorTable == S_OK)

    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] GetTable failed with hr = 0x%x.\n",__FUNCTION__,hr));
        return hr;
    }

    return hr;
}

//
// private
//

CImporter::Relation CImporter::GetRelation(
    LPCWSTR i_wszSourcePath,
    LPCWSTR i_wszCheck)
/*++

Synopsis: 

Arguments: [i_wszSourcePath] - 
           [i_wszCheck] - 
           
Return Value: 

--*/
{
    Relation eRelation     = eREL_NONE;
    BOOL     bIsSourcePath = false;
    BOOL     bIsChild      = IsChild(i_wszSourcePath, i_wszCheck, &bIsSourcePath);
    if(bIsChild)
    {
        eRelation = (bIsSourcePath) ? eREL_SELF : eREL_CHILD;
    }
    else
    {
        BOOL bIsParent = IsChild(i_wszCheck, i_wszSourcePath, &bIsSourcePath);
        if(bIsParent)
        {
            MD_ASSERT(bIsSourcePath == false);
            eRelation = eREL_PARENT;
        }
        else
        {
            eRelation = eREL_NONE;
        }
    }

    return eRelation;
}

BOOL
CImporter::IsChild(
    LPCWSTR i_wszParent, 
    LPCWSTR i_wszCheck,
    BOOL    *o_pbSamePerson)
/*++

Synopsis: 

Arguments: [i_wszParent] -    Ex. /LM/w3svc/1/root
           [i_wszCheck] -     Ex. /LM/w3svc/1
           [o_pbSamePerson] - true if i_wszParent and i_wszCheck is same person
           
Return Value: 
    true if i_wszCheck is child or same person

--*/
{
    MD_ASSERT(i_wszParent != NULL);
    MD_ASSERT(i_wszCheck  != NULL);
    MD_ASSERT(o_pbSamePerson != NULL);

    LPCWSTR pParent;
    LPCWSTR pCheck;

    pParent = i_wszParent;
    pCheck  = i_wszCheck;

    SKIP_DELIMETER(pParent, MD_PATH_DELIMETERW);
    SKIP_DELIMETER(pCheck,  MD_PATH_DELIMETERW);

    if(*pParent == L'\0')
    {
        switch(*pCheck)
        {
        case L'\0':
            *o_pbSamePerson = TRUE;
            break;
        default:
            *o_pbSamePerson = FALSE;
        }
        return TRUE;
    }

    while(*pParent != L'\0') 
    {
        if(_wcsnicmp(pParent, pCheck, 1) == 0) 
        {
            pParent++;
            pCheck++;
        }
        else if(*pParent == MD_PATH_DELIMETERW && pParent[1] == L'\0' && *pCheck == L'\0') 
        {
            *o_pbSamePerson = TRUE;
            return TRUE;
        }
        else 
        {
            return FALSE;
        }
    }

    switch(*pCheck)
    {
    case L'\0':
        *o_pbSamePerson = TRUE;
        return TRUE;
    case MD_PATH_DELIMETERW:
        *o_pbSamePerson = (pCheck[1] == L'\0') ? TRUE : FALSE;
        return TRUE;
    default:
        return FALSE;
    }
}

HRESULT CImporter::ReadMetaObject(
    IN LPCWSTR i_wszAbsParentPath,
    IN CMDBaseObject *i_pboParent,
    IN LPCWSTR i_wszAbsChildPath,
    OUT CMDBaseObject **o_ppboChild)
/*++

Synopsis: 
    Returns a pbo for the child.  If it does not already exist, it is
    created.

Arguments: [i_wszAbsParentPath] - 
           [i_pboParent] - pbo corresponding to i_wszAbsParentPath
           [i_wszAbsChildPath] - 
           [o_ppboChild] - pbo corresponding to i_wszAbsChildPath
           
Return Value: 

--*/
{
    MD_ASSERT(i_pboParent != NULL);
    MD_ASSERT(i_wszAbsParentPath != NULL);
    MD_ASSERT(i_wszAbsChildPath != NULL);
    MD_ASSERT(o_ppboChild != NULL);

    HRESULT hr = ERROR_SUCCESS;
    HRESULT hrWarn = ERROR_SUCCESS;

    int iLenParent = wcslen(i_wszAbsParentPath);
    int iLenChild  = wcslen(i_wszAbsChildPath);
    
    LPWSTR wszParent = new wchar_t[iLenParent+1];
    if(wszParent == NULL)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    LPWSTR wszChild = new wchar_t[iLenChild+1];
    if(wszChild == NULL)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }

    int idxParent = 0;
    int idxChild = 0;

    BOOL bRetParent = FALSE;
    BOOL bRetChild  = FALSE;

    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboLastParent = i_pboParent;

    while(1) {
        bRetParent = EnumMDPath(i_wszAbsParentPath, wszParent, &idxParent);
        bRetChild =  EnumMDPath(i_wszAbsChildPath,  wszChild,  &idxChild);

        if(bRetParent == FALSE) {
            break;
        }
    }

    while(bRetChild == TRUE) {
        //
        // This is okay, since function that uses this takes an LPSTR
        // and a bool saying whether or not the string is unicode.
        //
        LPSTR pszTemp = (LPSTR)wszChild;

        pboNew = pboLastParent->GetChildObject(pszTemp, &hrWarn, TRUE);
        if(pboNew == NULL) {
            //
            // Create it
            //
            pboNew = new CMDBaseObject(wszChild, NULL);
            if (pboNew == NULL) {
                hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            else if (!pboNew->IsValid()) {
                hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                goto exit;
            }
            hr = pboLastParent->InsertChildObject(pboNew);
            if(FAILED(hr)) {
                delete pboNew;
                goto exit;
            }
        }
        pboLastParent = pboNew;

        bRetChild = EnumMDPath(i_wszAbsChildPath,  wszChild,  &idxChild);
    }

    //
    // Set out params
    //
    *o_ppboChild = pboLastParent;

exit:
    delete [] wszParent;
    delete [] wszChild;

    return hr;
}

BOOL CImporter::EnumMDPath(
    LPCWSTR i_wszFullPath,
    LPWSTR  io_wszPath,
    int*    io_iStartIndex)
/*++

Synopsis: 
    Starting at io_iStartIndex, this function will find the next token.
    Eg. i_wszFullPath   =  /LM/w3svc/1
        *io_iStartIndex =  3
        io_wszPath      => w3svc
        *io_iStartIndex =  9

Arguments: [i_wszFullPath] -  Ex. /LM/w3svc/1
           [io_wszPath] -     Should be at least same size as i_wszFullPath
           [io_iStartIndex] - 0-based index to start looking from
           
Return Value: 
    true if io_wszPath is set.

--*/
{
    MD_ASSERT(i_wszFullPath != NULL);
    MD_ASSERT(io_wszPath    != NULL);

    int idxEnd =   *io_iStartIndex;
    int idxStart = *io_iStartIndex;

    if(i_wszFullPath[idxStart] == MD_PATH_DELIMETERW) 
    {
        idxStart++;
        idxEnd++;
    }

    //
    // If there is no more to enum, just exit and don't set out params
    //
    if(i_wszFullPath[idxStart] == L'\0') 
    {
        return FALSE;
    }

    for(; ; idxEnd++) 
    {
        if(i_wszFullPath[idxEnd] == MD_PATH_DELIMETERW) 
        {
            break;
        }
        if(i_wszFullPath[idxEnd] == L'\0') 
        {
            break;
        }
    }

    //
    // Set out params
    //
    *io_iStartIndex = idxEnd;
    memcpy(io_wszPath, &i_wszFullPath[idxStart], sizeof(wchar_t) * (idxEnd-idxStart));
    io_wszPath[idxEnd-idxStart] = L'\0';

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\mbcollectionwriter.cpp ===
#include "catalog.h"
#include "Catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "WriterGlobals.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"

typedef CMBPropertyWriter*	LP_CMBPropertyWriter;

//
// TODO: Determine an optimal number - set to max number of properties in an ADSI class?
//

#define MAX_PROPERTY        700


/***************************************************************************++
Routine Description:

    Constructor for CMBCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBCollectionWriter::CMBCollectionWriter():
m_pCWriter(NULL),
m_wszMBClass(NULL),
m_wszContainerClassList(NULL),
m_bContainer(FALSE),
m_apProperty(NULL),
m_cProperty(0),
m_iProperty(0),
m_aIndexToProperty(NULL),
m_dwLargestID(1)
{

} // CCollectionWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBCollectionWriter::~CMBCollectionWriter()
{
	if(NULL != m_apProperty)
	{
		for(ULONG i=0; i<m_iProperty; i++)
		{
			if(NULL != m_apProperty[i])
			{
				delete m_apProperty[i];
				m_apProperty[i] = NULL;
			}
		}

		delete [] m_apProperty;
		m_apProperty = NULL;
	}
	m_cProperty = 0;
	m_iProperty = 0;

} // ~CCollectionWriter


/***************************************************************************++
Routine Description:

    Initialize the collection writer object

Arguments:

    [in] Name of the collection
    [in] Optional - Is its a container class (for Non-IIsConfigObject 
         collections)
    [in] Optional - Container class list (for Non-IIsConfigObject 
         collections)
    [in] Writer object - Assume that it is valid for the lifetime of the
         collection writer

Return Value:

    None.

--***************************************************************************/
void CMBCollectionWriter::Initialize(LPCWSTR           i_wszMBClass,
								     BOOL			   i_bContainer,
                                     LPCWSTR           i_wszContainerClassList,
									 CWriter*		   i_pcWriter)
{
	m_wszMBClass            = i_wszMBClass;
	m_bContainer            = i_bContainer;
	m_wszContainerClassList = i_wszContainerClassList;

	//
    // Assumption: i_pcWriter will be valid for the 
	// lifetime of the schema writer object.
	//

	m_pCWriter              = i_pcWriter;

} // CCatalogCollectionWriter::Initialize


/***************************************************************************++
Routine Description:

    Creates a new property writer and adds it to its list.
    Note: This is called only when you add a property to the IIsConfigObject 
          collection.

Arguments:

    [in]  Property ID.
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetMBPropertyWriter(DWORD					i_dwID,
											     CMBPropertyWriter**    o_pProperty)
{
	HRESULT hr = S_OK;

	if((NULL == m_aIndexToProperty)              || 
	   (i_dwID > m_dwLargestID)                  ||
	   (NULL == m_aIndexToProperty[i_dwID])
	  )
	{
		//
		// If index not created, then create a new property.
		// If index does not have an object for this id, then create it.
		// Note if the ID is greater than the largest id and the index 
		// has been created then GetNewMBPropertyWriter reallocates
		// the index. GetNewMBPropertyWriter updates the index with
		// the new property, if the index array has been created.
		//

		hr = GetNewMBPropertyWriter(i_dwID,
		                            o_pProperty);
	}
	else
	{
		//
		// If Index has a valid object, then return from index.
		//

		*o_pProperty = m_aIndexToProperty[i_dwID];
	}

	return hr;

} // CMBCollectionWriter::GetMBPropertyWriter


/***************************************************************************++
Routine Description:

    Creates a new property writer and adds it to its list.
    Note: This is called only when you add a property to the non-
          IIsConfigObject collection.

Arguments:

    [in] Name of the collection
    [in] Is it a manditory property or not.
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetMBPropertyWriter(LPCWSTR				i_wszName,
                                                 BOOL                   i_bMandatory,
											     CMBPropertyWriter**    o_pProperty)
{
	HRESULT hr = S_OK;
	DWORD   dwID = -1;

	//
	// TODO: Assert that the index is always NULL.
	//

	if(m_iProperty == m_cProperty)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}


	m_apProperty[m_iProperty++] = new CMBPropertyWriter();

	if(NULL == m_apProperty[m_iProperty-1])
	{
		return E_OUTOFMEMORY;
	}

	m_apProperty[m_iProperty-1]->Initialize(dwID,
	                                        i_bMandatory,
									        this,
	                                        m_pCWriter);

	m_apProperty[m_iProperty-1]->AddNameToProperty(i_wszName);

	*o_pProperty = m_apProperty[m_iProperty-1];

	return hr;

} // CMBCollectionWriter::GetMBPropertyWriter


/***************************************************************************++
Routine Description:

    Helper function that creates a new property writer and adds it to its 
    list.
    
Arguments:

    [in] Property ID
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetNewMBPropertyWriter(DWORD 					i_dwID,
													CMBPropertyWriter**     o_pProperty)
{
	HRESULT hr = S_OK;

	if(m_iProperty == m_cProperty)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_apProperty[m_iProperty++] = new CMBPropertyWriter();

	if(NULL == m_apProperty[m_iProperty-1])
	{
		return E_OUTOFMEMORY;
	}

	m_apProperty[m_iProperty-1]->Initialize(i_dwID,
	                                        FALSE,
									        this,
	                                        m_pCWriter);

	*o_pProperty = m_apProperty[m_iProperty-1];

	if(NULL == m_aIndexToProperty)
	{

		hr = ReAllocateIndex(i_dwID);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	if(i_dwID > m_dwLargestID)
	{
		//
		// If the ID being added, is greater than the highest ID seen so far,
		// then update the highest id saved, and if the index has been
		// created, update it.
		//

		hr = ReAllocateIndex(i_dwID);

		if(FAILED(hr))
		{
			return hr;
		}

	}

	//
	// If the index has been created, then updated it with the new property
	//

	m_aIndexToProperty[i_dwID] = *o_pProperty;
	
	return hr;

} // CMBCollectionWriter::GetNewMBPropertyWriter


/***************************************************************************++
Routine Description:

    Helper function grows the buffer that contains all property writers of
    a collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::ReAllocate()
{
	CMBPropertyWriter** pSav = NULL;

	pSav = new LP_CMBPropertyWriter[m_cProperty + MAX_PROPERTY];
	if(NULL == pSav)
	{
		return E_OUTOFMEMORY;
	}
	memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(m_cProperty + MAX_PROPERTY));

	if(NULL != m_apProperty)
	{
		memcpy(pSav, m_apProperty, (sizeof(LP_CMBPropertyWriter))*(m_cProperty));
		delete [] m_apProperty;
		m_apProperty = NULL;
	}

	m_apProperty = pSav;
	m_cProperty = m_cProperty + MAX_PROPERTY;

	return S_OK;

} // CMBCollectionWriter::ReAllocate


/***************************************************************************++
Routine Description:

    In order to  provide fast access to locate the property writer of a given
    property, we create an index to the property writer buffer based on the
    property id. m_aIndexToProperty[PropertyID] will give you a pointer to the
    property writer object for that property.

    This function creates the index.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::CreateIndex()
{
	HRESULT hr = S_OK;

	hr = ReAllocateIndex(m_dwLargestID);

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		m_aIndexToProperty[m_apProperty[i]->ID()] = m_apProperty[i];
	}

	return hr;

} // CMBCollectionWriter::CreateIndex

  
/***************************************************************************++
Routine Description:

    Helper function grows the property writer index buffer.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::ReAllocateIndex(DWORD i_dwLargestID)
{
	CMBPropertyWriter** pSav = NULL;
	DWORD               dwLargestID = 0;

	//
	// Always allocate one more that the largest ID because if the largest 
	// ID is say "i" we will store in m_aIndexToProperty[i] and hence need
	// array of size i+1
	//
	// Since the index is being updated everytime a new property is added
	// we allocate extra space so that we dont have to reallocate each time.
	//
	//

	if(i_dwLargestID < 0xFFFFFFFF)
	{
		if(i_dwLargestID < 0xFFFFFFFF-(50+1))
		{
			dwLargestID = i_dwLargestID+50;

		}
		else
		{
			dwLargestID = i_dwLargestID;
		}
	}
	else
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	pSav = new LP_CMBPropertyWriter[dwLargestID+1];
	if(NULL == pSav)
	{
		return E_OUTOFMEMORY;
	}
	memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(dwLargestID+1));

	if(NULL != m_aIndexToProperty)
	{
		memcpy(pSav, m_aIndexToProperty, (sizeof(LP_CMBPropertyWriter))*(m_dwLargestID+1));
		delete [] m_aIndexToProperty;
		m_aIndexToProperty = NULL;
	}

	m_aIndexToProperty = pSav;
	m_dwLargestID = dwLargestID;

	return S_OK;

} // CMBCollectionWriter::ReAllocateIndex


/***************************************************************************++
Routine Description:

    Function that writes the collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::WriteCollection()
{
	HRESULT hr = S_OK;

	hr = BeginWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		hr = m_apProperty[i]->WriteProperty();

		if(FAILED(hr))
		{
			return hr;
		}

	}

	hr = EndWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CMBCollectionWriter::WriteCollection


/***************************************************************************++
Routine Description:

    Function that writes the begin collection tag
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::BeginWriteCollection()
{
	HRESULT		hr							= S_OK;
	LPWSTR      wszEndBeginCollection		= NULL;
	ULONG       cchEndBeginCollection		= 0;
	ULONG       iColMetaFlagsEx	            = iTABLEMETA_SchemaGeneratorFlags;
	LPWSTR      wszContainer				= NULL;
	
	if(0 == _wcsicmp(m_wszMBClass, wszTABLE_IIsConfigObject))
	{
		wszEndBeginCollection = (LPWSTR)g_wszSchemaGen;
		cchEndBeginCollection = g_cchSchemaGen;
	}
	else
	{
		wszEndBeginCollection = (LPWSTR)g_wszInheritsFrom;
		cchEndBeginCollection = g_cchInheritsFrom;
	}


	if(m_bContainer)
	{
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(fTABLEMETA_CONTAINERCLASS, 
															  &wszContainer,
															  wszTABLE_TABLEMETA,
										            		  iColMetaFlagsEx);

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginCollection,
		                         g_cchBeginCollection);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)m_wszMBClass,
		                         wcslen(m_wszMBClass));

	if(FAILED(hr))
	{
		goto exit;
	}

	if(m_bContainer)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszMetaFlagsExEq,
									 g_cchMetaFlagsExEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszContainer,
									 wcslen(wszContainer));

		if(FAILED(hr))
		{
			goto exit;
		}

	}

	if(m_wszContainerClassList)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszContainerClassListEq,
									 g_cchContainerClassListEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)m_wszContainerClassList,
									 wcslen(m_wszContainerClassList));

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszEndBeginCollection,
								 wcslen(wszEndBeginCollection));

	if(FAILED(hr))
	{
		goto exit;
	}

exit:

	if(NULL != wszContainer)
	{
		delete [] wszContainer;
		wszContainer = NULL;
	}

	return hr;

} // CMBCollectionWriter::BeginWriteCollection


/***************************************************************************++
Routine Description:

    Function that writes the end collection tag
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::EndWriteCollection()
{
	return m_pCWriter->WriteToFile((LPVOID)g_wszEndCollection,
		                           g_cchEndCollection);

} // CMBCollectionWriter::EndWriteCollection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\mbpropertywriter.cpp ===
#include "catalog.h"
#include "Catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "WriterGlobals.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"
#include "mddefw.h"
#include "pudebug.h"

typedef CMBPropertyWriter* LP_CMBPropertyWriter;

#define     IIS_SYNTAX_ID_DWORD         1
#define     IIS_SYNTAX_ID_STRING        2
#define     IIS_SYNTAX_ID_EXPANDSZ      3
#define     IIS_SYNTAX_ID_MULTISZ       4
#define     IIS_SYNTAX_ID_BINARY        5
#define     IIS_SYNTAX_ID_BOOL          6
#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
#define     IIS_SYNTAX_ID_MIMEMAP       8
#define     IIS_SYNTAX_ID_IPSECLIST     9
#define     IIS_SYNTAX_ID_NTACL        10
#define     IIS_SYNTAX_ID_HTTPERRORS   11
#define     IIS_SYNTAX_ID_HTTPHEADERS  12

#define    cMaxFlag 32	// TODO: Check if max flag is ok.

static DWORD g_dwCatalogTypeFromSynID[]=
{
  0,								   //invalid     no equivalent in IISSynID.h                          
  eCOLUMNMETA_DWORD_METADATA,		   //#define     IIS_SYNTAX_ID_DWORD         1
  eCOLUMNMETA_STRING_METADATA,         //#define     IIS_SYNTAX_ID_STRING        2
  eCOLUMNMETA_EXPANDSZ_METADATA,       //#define     IIS_SYNTAX_ID_EXPANDSZ      3
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MULTISZ       4
  eCOLUMNMETA_BINARY_METADATA,         //#define     IIS_SYNTAX_ID_BINARY        5
  eCOLUMNMETA_DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL          6
  eCOLUMNMETA_DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MIMEMAP       8
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_IPSECLIST     9
  eCOLUMNMETA_BINARY_METADATA,         //#define     IIS_SYNTAX_ID_NTACL        10
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPERRORS   11
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPHEADERS  12
  0
};

static DWORD g_dwMetabaseTypeFromSynID[]=
{
  0,					   //invalid     no equivalent in IISSynID.h                          
  DWORD_METADATA,		   //#define     IIS_SYNTAX_ID_DWORD         1
  STRING_METADATA,         //#define     IIS_SYNTAX_ID_STRING        2
  EXPANDSZ_METADATA,       //#define     IIS_SYNTAX_ID_EXPANDSZ      3
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MULTISZ       4
  BINARY_METADATA,         //#define     IIS_SYNTAX_ID_BINARY        5
  DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL          6
  DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MIMEMAP       8
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_IPSECLIST     9
  BINARY_METADATA,         //#define     IIS_SYNTAX_ID_NTACL        10
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPERRORS   11
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPHEADERS  12
  0
};

static DWORD g_dwCatalogTypeFromMetaType[]=
{
  0,								   //invalid     no equivalent for metatype               
  eCOLUMNMETA_DWORD_METADATA,		   //#define     DWORD_METADATA         1
  eCOLUMNMETA_STRING_METADATA,         //#define     STRING_METADATA        2
  eCOLUMNMETA_BINARY_METADATA,         //#define     BINARY_METADATA        3
  eCOLUMNMETA_EXPANDSZ_METADATA,       //#define     EXPANDSZ_METADATA      4
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     MULTISZ_METADATA       5
  0
};

//
// TODO: Delete after getting from schema
//

LPWSTR g_wszDWORD			= L"DWORD";
LPWSTR g_wszBINARY			= L"BINARY";
LPWSTR g_wszSTRING			= L"STRING";
LPWSTR g_wszGUID			= L"GUID";
LPWSTR g_wszDBTIMESTAMP		= L"DBTIMESTAMP";

LPWSTR g_wszUNKNOWN_UserType	= L"UNKNOWN_UserType";
LPWSTR g_wszIIS_MD_UT_SERVER	= L"IIS_MD_UT_SERVER";
LPWSTR g_wszIIS_MD_UT_FILE		= L"IIS_MD_UT_FILE";
LPWSTR g_wszIIS_MD_UT_WAM		= L"IIS_MD_UT_WAM";
LPWSTR g_wszASP_MD_UT_APP		= L"ASP_MD_UT_APP";

HRESULT GetType(DWORD   i_dwType,
				LPWSTR* o_pwszType)
{
	switch(i_dwType)
	{
	case 19:
		*o_pwszType = g_wszDWORD;
		break;
	case 128:
		*o_pwszType = g_wszBINARY;
		break;
	case 130:
		*o_pwszType = g_wszSTRING;
		break;
	case 72:
		*o_pwszType = g_wszGUID;
		break;
	case 135:
		*o_pwszType = g_wszDBTIMESTAMP;
		break;
	default:
		return E_INVALIDARG;
	}

	return S_OK;
}


HRESULT GetTypefromSynID(DWORD		i_dwSynID,
						 LPWSTR*	o_pwszType)
{
	if((i_dwSynID < 1) || (i_dwSynID > 12))
	{
		return E_INVALIDARG;
	}
	else
	{
		*o_pwszType = (LPWSTR)g_aSynIDToWszType[i_dwSynID];
	}

	return S_OK;
}


/***************************************************************************++
Routine Description:

    Constructor for CMBPropertyWriter
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
CMBPropertyWriter::CMBPropertyWriter():
m_pCWriter(NULL),
m_wszName(NULL),
m_pType(NULL),
m_dwID(0),
m_bDefault(NULL),
m_cbDefault(0),
m_apFlag(NULL),
m_cFlag(0),
m_iFlag(0),
m_IsProperty(TRUE),
m_bMandatory(FALSE),
m_pCollection(NULL)
{

} // CMBPropertyWriter::CMBPropertyWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBPropertyWriter
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
CMBPropertyWriter::~CMBPropertyWriter()
{
	if(NULL != m_apFlag)
	{
		for(ULONG i=0; i<m_iFlag; i++)
		{
			if(NULL != m_apFlag[i])
			{
				m_apFlag[i] = NULL; // No need to delete because you had simply saved the pointer.
			}
		}

		delete [] m_apFlag;
		m_apFlag = NULL;
	}

	m_cFlag = 0;
	m_iFlag = 0;
	
} // CMBPropertyWriter::CMBPropertyWriter


/***************************************************************************++
Routine Description:

    Initialize property writer.
    
Arguments:

    [in] Property ID
    [in] Bool indicating manditory property or optional.
    [in] Pointer to the Collection writer object to which it belongs.
         Assuming that the collection writer is valid for the lifetime
         of this property writer.
    [in] Pointer to the writer object. Assuming that the writer is valid for 
         the lifetime of this property writer.

Return Value:

    HRESULT

--***************************************************************************/
void CMBPropertyWriter::Initialize(DWORD					i_dwID,
								   BOOL                     i_bMandatory,
								   CMBCollectionWriter*	    i_pCollection,
			                       CWriter*				    i_pcWriter)
{
	//
    // Assumption: i_pcWriter will be valid for the 
	// lifetime of the schema writer object.
	//
	m_pCWriter		= i_pcWriter;
	m_dwID			= i_dwID;
	m_bMandatory    = i_bMandatory;
	//
    // Assumption: i_pCollection will be valid for the 
	// lifetime of the property writer object.
	//
	m_pCollection	= i_pCollection;

	return;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property's name.
    
Arguments:

    [in] Property Name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddNameToProperty(LPCWSTR	i_wszName)
{
	//
	// We have to make a copy of the name because
	//

	m_wszName  = i_wszName;

	return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property type.
    
Arguments:

    [in] PropValue structure that has metabase type information.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddTypeToProperty(PropValue*	i_pType)
{
	HRESULT hr = S_OK;

	//
	// First save the type, then if the meta/prop ids differ, mark the 
	// object as a flag and add it to its property.
	//

	m_pType = i_pType;

	//
	// A lot of tests dont really ensure that PropID == MetaID.
	// They just set PropID to zero. We must not interpret this as a flag
	//

	if((0 != i_pType->dwPropID) && (i_pType->dwMetaID != i_pType->dwPropID))
	{
		//
		// This is a flag. Add it as a flag to its property
		//
		
		//
		// TODO: Assert that the ID of this object is the same as the propID.
		//

		CMBPropertyWriter*	pPropertyWriter = NULL;

		DBGINFOW((DBG_CONTEXT,
			  L"[AddTypeToProperty] Saving a non-shipped flag. Adding tag ID %d to its property ID %d\n",
			  i_pType->dwPropID,
			  i_pType->dwMetaID));

		hr = m_pCollection->GetMBPropertyWriter(i_pType->dwMetaID,
												&pPropertyWriter);

		if(FAILED(hr))
		{
			return hr;
		}

		hr = pPropertyWriter->AddFlagToProperty(this);

		m_IsProperty = FALSE;

	}

	return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property defaults.
    
Arguments:

    [in] Default value
    [in] Count of bytes for default value.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddDefaultToProperty(BYTE*      i_bDefault,
											    ULONG      i_cbDefault)
{
	m_bDefault = i_bDefault;
	m_cbDefault = i_cbDefault;

	return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Save property's flag. Note that flag objects are also the same data
    structure as property objects i.e. CMBPropertyWriter
    
Arguments:

    [in] Flag object

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddFlagToProperty(CMBPropertyWriter* i_pFlag)
{
	//
	// ASSUMPTION: A meta ID will have only one occurance of a Prop ID. i.e. flag
	//

	HRESULT hr = S_OK;

	if(m_iFlag == m_cFlag)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_apFlag[m_iFlag++] = i_pFlag;

	return hr;

}


/***************************************************************************++
Routine Description:

    Helper function to grow the buffer that holds the flag objects
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::ReAllocate()
{
	CMBPropertyWriter** pSav = NULL;

	pSav = new LP_CMBPropertyWriter[m_cFlag + cMaxFlag];
	if(NULL == pSav)
	{
		return E_OUTOFMEMORY;
	}
	memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(m_cFlag + cMaxFlag));

	if(NULL != m_apFlag)
	{
		memcpy(pSav, m_apFlag, (sizeof(LP_CMBPropertyWriter))*(m_cFlag));
		delete [] m_apFlag;
		m_apFlag = NULL;
	}

	m_apFlag = pSav;
	m_cFlag = m_cFlag + cMaxFlag;

	return S_OK;

} // CMBPropertyWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Function that writes the property.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WriteProperty()
{
	HRESULT hr = S_OK;

	if(!m_IsProperty)
	{
		return S_OK;
	}

	if(0 == _wcsicmp(m_pCollection->Name(), wszTABLE_IIsConfigObject))
	{
		hr = WritePropertyLong();
	}
	else 
	{
		hr = WritePropertyShort();
	}

	return hr;

} // CMBPropertyWriter::WriteProperty


/***************************************************************************++
Routine Description:

    Helper function to determine if the property is a bool.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
BOOL CMBPropertyWriter::IsPropertyFlag(BOOL	i_bLog)
{
	if(NULL != m_apFlag)
	{
		DBGINFOW((DBG_CONTEXT,
			  L"[IsPropertyFlag] PropertyID %d. Type: %d.\n",
			  m_dwID,
			  m_pType));

		DBGINFOW((DBG_CONTEXT,
			  L"[IsPropertyFlag] PropertyID %d. SynID: %d.\n",
			  m_dwID,
			  m_pType->dwSynID));

		if(eCOLUMNMETA_DWORD_METADATA == g_dwCatalogTypeFromSynID[m_pType->dwSynID])
		{
			return TRUE;
		}
		else
		{
			if(i_bLog)
			{
				DBGINFOW((DBG_CONTEXT,
					  L"[IsPropertyFlag] PropertyID %d is not a DWORD. Ignoring flags for this property.\n",m_dwID));
			}

			return FALSE;

		}
	}
	else
	{
		return FALSE;
	}

} // CMBPropertyWriter::IsPropertyFlag


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to the global IIsConfigObject collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WritePropertyLong()
{
	HRESULT hr = S_OK;

	hr = BeginWritePropertyLong();

	if(FAILED(hr))
	{
		if(HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr)
		{
			return S_OK;
		}
		else
		{
			return hr;
		}
	}

	if(IsPropertyFlag(FALSE))
	{	
		for(ULONG i=0; i<m_iFlag; i++)
		{
			hr = WriteFlag(i);
			// hr = m_aFlag[i]->WriteFlag;

			if(FAILED(hr))
			{
				return hr;
			}
		}
	}

	hr = EndWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CMBPropertyWriter::WritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (short form) i.e. property that belongs
    to a non-IIsConfigObject collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WritePropertyShort()
{
	HRESULT			hr                  = S_OK;
	static WCHAR	wchSeparator		= L',';
	WCHAR*          wszEndName			= NULL;
	WCHAR*			wszName             = NULL;
	WCHAR			wszUnknownName[25];
	size_t			cchPropertyName		= 0;
	DWORD           dwMetaFlagsEx       = fCOLUMNMETA_MANDATORY;
	DWORD	        iColMetaFlagsEx     = iCOLUMNMETA_SchemaGeneratorFlags;
	WCHAR*          wszMetaFlagsEx      = NULL;

	if(NULL == m_wszName)
	{

		CreateUnknownName(wszUnknownName,
		                  m_dwID);
		wszName = wszUnknownName;
		cchPropertyName = wcslen(wszName);
	}
	else
	{
		wszName = (LPWSTR)m_wszName;
		wszEndName = wcschr(m_wszName, wchSeparator);
		if(NULL == wszEndName)
		{
			cchPropertyName = wcslen(m_wszName);
		}
		else
		{
			cchPropertyName = wszEndName-m_wszName; // No need to divide by WCHAR because both are WCHAR pointers
		}
	}

	if(m_bMandatory)
	{
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
															  &wszMetaFlagsEx,
															  wszTABLE_COLUMNMETA,
															  iColMetaFlagsEx);

		if(FAILED(hr))
		{
			goto exit;
		}

	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyShort,
		                         g_cchBeginPropertyShort);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszName,
		                         cchPropertyName);

	if(FAILED(hr))
	{
		goto exit;
	}

	if(m_bMandatory)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsExEq,
									 g_cchPropMetaFlagsExEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)g_wszOr,
									 g_cchOr);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
									 wcslen(wszMetaFlagsEx));

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyShort,
								 g_cchEndPropertyShort);

	if(FAILED(hr))
	{
		goto exit;
	}

exit:

	if(NULL != wszMetaFlagsEx)
	{
		delete [] wszMetaFlagsEx;
		wszMetaFlagsEx = NULL;
	}

	return hr;

} // CMBPropertyWriter::WritePropertyShort


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::BeginWritePropertyLong()
{

	HRESULT			hr								= S_OK;
	WCHAR*			wszEndName						= NULL;
	static WCHAR	wchSeparator					= L',';
	WCHAR*			wszName							= NULL;
	WCHAR			wszUnknownName[40];
	size_t			cchPropertyName					= 0;
	WCHAR			wszID[11];
	WCHAR*			wszType							= NULL;
	DWORD			iColType						= iCOLUMNMETA_Type;
	WCHAR*			wszUserType						= NULL;
	ULONG           cchUserType                     = 0;
	BOOL			bAllocedUserType				= FALSE;
	WCHAR*			wszAttribute					= NULL;
	DWORD			iColAttribute					= iCOLUMNMETA_Attributes;
	WCHAR*			wszMetaFlags					= NULL;
	WCHAR*			wszMetaFlagsEx					= NULL;
	WCHAR*			wszDefault						= NULL;
	WCHAR			wszMinValue[40];
	WCHAR			wszMaxValue[40];

	//
	// Compute the individual strings and lengths.
	//

	//
	// Name
	//

	if(NULL == m_wszName)
	{

		CreateUnknownName(wszUnknownName,
		                  m_dwID);
		wszName = wszUnknownName;
		cchPropertyName = wcslen(wszName);
	}
	else
	{
		wszName = (LPWSTR)m_wszName;
		wszEndName = wcschr(m_wszName, wchSeparator);
		if(NULL == wszEndName)
		{
			cchPropertyName = wcslen(m_wszName);
		}
		else
		{
			cchPropertyName = wszEndName-m_wszName; // // No need to divide by WCHAR because both are WCHAR pointers
		}
	}
	
	//
	// ID
	// 

	wszID[0] = 0;
	_ultow(m_dwID, wszID, 10);

	//
	// Type
	//

	if(NULL == m_pType)
	{
		//
		// TODO: Log the fact that you found a property with no type and move on to the next property
		//
		DBGINFOW((DBG_CONTEXT,
			  L"[BeginWritePropertyLong] Type not found for PropertyID %d.\n",
			  m_dwID));
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
		goto exit;
	}

	hr = GetTypefromSynID(m_pType->dwSynID,
		                  &wszType);

	/*

	TODO: Get from schema

	hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(g_dwCatalogTypeFromSynID[m_pType->dwSynID],
		                                                  &wszType,
														  wszTABLE_COLUMNMETA,
										            	  iColType);
	*/
	if(FAILED(hr) || (NULL == wszType))
	{
		DBGINFOW((DBG_CONTEXT,
			  L"[GetType] PropertyID %d, type: %d from synid %d is invalid.\n",
			  m_dwID, 
			  g_dwCatalogTypeFromSynID[m_pType->dwSynID],
			  m_pType->dwSynID));
		goto exit;
	}

	if(g_dwCatalogTypeFromSynID[m_pType->dwSynID] != g_dwCatalogTypeFromMetaType[m_pType->dwMetaType])
	{
		//
		// TODO: Log a warning.
		//
	}

	//
	// UserType
	//

	hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(m_pType->dwUserGroup,
		                                                 &wszUserType,
														 &cchUserType,
														 &bAllocedUserType);
	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
			  L"[GetUserType] PropertyID %d, usertype: %d is invalid.\n",m_dwID, m_pType->dwUserGroup));
		goto exit;
	}

	//
	// Attribute
	// TODO: Check if value stored in metabase is the same as catalog.
	//

	hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(m_pType->dwMetaFlags,
		                                                  &wszAttribute,
														  wszTABLE_COLUMNMETA,
										            	  iColAttribute);

	if(FAILED(hr) || (NULL == wszAttribute))
	{
		goto exit;
	}

	//
	// Since this object is used only to write MBSchemaExt.XML, we are not
	// writing the MetaFlags tag, because it will be derived on a compile.
	// And besides, we do not have this info in the metabase - this tag 
	// contains catalog related data
	//

	//
	// MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3)
	//

	hr = GetMetaFlagsExTag(&wszMetaFlagsEx);
	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// DefaultValue
	//

	if(NULL != m_bDefault && m_cbDefault != 0)
	{
		hr = m_pCWriter->m_pCWriterGlobalHelper->ToString(m_bDefault,
														  m_cbDefault,
									            		  m_dwID,
									            		  g_dwMetabaseTypeFromSynID[m_pType->dwSynID],
														  METADATA_NO_ATTRIBUTES,					// Do not check for attributes while applying defaults
														  &wszDefault);

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	wszMinValue[0] = 0;
	wszMaxValue[0] = 0;

	if(DWORD_METADATA == g_dwMetabaseTypeFromSynID[m_pType->dwSynID])
	{
		//
		// Set min/max values only for DWORD types
		//

		//
		// TODO: Get the catalog's default for min/max from schema/ header file
		//

		if(0 != m_pType->dwMinRange)
		{
			_ultow(m_pType->dwMinRange, wszMinValue, 10);
		}

		if(-1 != m_pType->dwMaxRange)
		{
			_ultow(m_pType->dwMaxRange, wszMaxValue, 10);
		}

	}

	//
	// Write the values into the file.
	//

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyLong,
		                         g_cchBeginPropertyLong);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszName,
		                         cchPropertyName);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropIDEq,
		                         g_cchPropIDEq);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszID,
		                         wcslen(wszID));

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropTypeEq,
		                         g_cchPropTypeEq);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszType,
		                         wcslen(wszType));

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropUserTypeEq,
		                         g_cchPropUserTypeEq);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszUserType,
		                         cchUserType);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropAttributeEq,
		                         g_cchPropAttributeEq);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszAttribute,
		                         wcslen(wszAttribute));

	if(FAILED(hr))
	{
		goto exit;
	}

	if(NULL != wszMetaFlags)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsEq,
									 g_cchPropMetaFlagsEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlags,
									 wcslen(wszMetaFlags));

		if(FAILED(hr))
		{
			goto exit;
		}

	}
	if(NULL != wszMetaFlagsEx)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsExEq,
									 g_cchPropMetaFlagsExEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
									 wcslen(wszMetaFlagsEx));

		if(FAILED(hr))
		{
			goto exit;
		}


	}
	if(NULL != wszDefault)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropDefaultEq,
									 g_cchPropDefaultEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszDefault,
									 wcslen(wszDefault));

		if(FAILED(hr))
		{
			goto exit;
		}

	}
	if(0 != *wszMinValue)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMinValueEq,
									 g_cchPropMinValueEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszMinValue,
									 wcslen(wszMinValue));

		if(FAILED(hr))
		{
			goto exit;
		}

	}
	if(0 != *wszMaxValue)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMaxValueEq,
									 g_cchPropMaxValueEq);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = m_pCWriter->WriteToFile((LPVOID)wszMaxValue,
									 wcslen(wszMaxValue));

		if(FAILED(hr))
		{
			goto exit;
		}

	}
	if(IsPropertyFlag(FALSE))
	{
		hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyLongBeforeFlag,
									 g_cchEndPropertyLongBeforeFlag);

		if(FAILED(hr))
		{
			goto exit;
		}

	}

exit:

/*
	if(NULL != wszType)
	{
		delete [] wszType;
		wszType = NULL;
	}
*/

	if((NULL != wszUserType) && bAllocedUserType)
	{
		delete [] wszUserType;
		wszUserType = NULL;
	}
	if(NULL != wszAttribute)
	{
		delete [] wszAttribute;
		wszAttribute = NULL;
	}

	if(NULL != wszMetaFlags)
	{
		delete [] wszMetaFlags;
		wszMetaFlags = NULL;
	}

	if(NULL != wszMetaFlagsEx)
	{
		delete [] wszMetaFlagsEx;
		wszMetaFlagsEx = NULL;
	}

	if(NULL != wszDefault)
	{
		delete [] wszDefault;
		wszDefault = NULL;
	}

	return hr;

} // CMBPropertyWriter::BeginWritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::EndWritePropertyLong()
{
	HRESULT		hr				= S_OK;
	WCHAR*      wszEndProperty	= NULL;

	if(IsPropertyFlag(FALSE))
	{
		wszEndProperty = (LPWSTR)g_wszEndPropertyLongAfterFlag;
	}
	else
	{
		wszEndProperty = (LPWSTR)g_wszEndPropertyShort;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszEndProperty,
		                         wcslen(wszEndProperty));
	return hr;

} // CMBPropertyWriter::EndWriterPropertyLong


/***************************************************************************++
Routine Description:

    Function that writes a flag of the property
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WriteFlag(ULONG i_iFlag)
{
	CMBPropertyWriter*	pFlag       = m_apFlag[i_iFlag];
	HRESULT				hr          = S_OK;
	WCHAR               wszValue[40];
	WCHAR               wszID[40];
	WCHAR               wszUnknownName[40];
	ULONG				cchFlagName = 0;
	WCHAR*              wszFlagName     = NULL;

	if(NULL != pFlag->Name())
	{
		wszFlagName = (LPWSTR)pFlag->Name();
	}
	else
	{
		CreateUnknownName(wszUnknownName,
		                  pFlag->ID());
		wszFlagName = wszUnknownName;
	}
	cchFlagName = wcslen(wszFlagName);
	
	wszValue[0] = 0;
	_ultow(pFlag->FlagValue(), wszValue, 10);

	wszID[0] = 0;
	_ultow(pFlag->ID(), wszID, 10);

	//
	// Write values to the flag
	//

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginFlag,
		                         g_cchBeginFlag);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszFlagName,
		                         cchFlagName);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagValueEq,
		                         g_cchFlagValueEq);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
		                         wcslen(wszValue));

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagIDEq,
		                         g_cchFlagIDEq);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszID,
		                         wcslen(wszID));

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndFlag,
		                         g_cchEndFlag);

	return hr;

} // CMBPropertyWriter::WriteFlag


/***************************************************************************++
Routine Description:

    Helper funciton that creates an unknown name
    TODO: Should we make this a standalone function since it is also used in
    locationWriter?
    
Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
void CMBPropertyWriter::CreateUnknownName(LPWSTR    io_wszUnknownName,
                                          DWORD     i_dwID)
{	
	WCHAR wszID[40];
	wcscpy(io_wszUnknownName, L"UnknownName_");

	_ultow(m_dwID, wszID, 10);
	wcscat(io_wszUnknownName, wszID);

	return;

} // CMBPropertyWriter::CreateUnknownName  


/***************************************************************************++
Routine Description:

    Helper funciton that creates metaflagsex tag
    
Arguments:

    [out] String form of metaflags ex

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::GetMetaFlagsExTag(LPWSTR* o_pwszMetaFlagsEx)
{
	HRESULT hr                   = S_OK;
	DWORD	dwMetaFlagsEx        = 0;
	DWORD	iColMetaFlagsEx      = iCOLUMNMETA_SchemaGeneratorFlags;
	DWORD   dwSynIDAsMetaFlagsEx = 0;

	//
	// TODO: Check if IIS_SYNTAX_ID_BOOL_BITMASK is bool.
	//

	if(1 == m_pType->dwFlags)
	{
		dwMetaFlagsEx = dwMetaFlagsEx | fCOLUMNMETA_CACHE_PROPERTY_MODIFIED; 
	}
	else if (2 == m_pType->dwFlags)
	{
		dwMetaFlagsEx = dwMetaFlagsEx | fCOLUMNMETA_CACHE_PROPERTY_CLEARED; 
	}

	if(0 != dwMetaFlagsEx)
	{
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
															  o_pwszMetaFlagsEx,
															  wszTABLE_COLUMNMETA,
										            		  iColMetaFlagsEx);
	}
	else
	{
		*o_pwszMetaFlagsEx = NULL;
	}


	return hr;

} // CMBPropertyWriter::GetMetaFlagsTag
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\mbschemawriter.cpp ===
#include "catalog.h"
#include "Catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "WriterGlobals.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"
#include "MBSchemaWriter.h"

typedef  CMBCollectionWriter*	LP_CMBCollectionWriter;

//
// TODO: Determine an optimal number - set to max number of ADSI classes?
//

#define  MAX_COLLECTIONS        50		                 

/***************************************************************************++
Routine Description:

    Constructor for CMBSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBSchemaWriter::CMBSchemaWriter(CWriter* i_pcWriter):
m_apCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(NULL)
{
	//
    // Assumption: i_pcWriter will be valid for the 
	// lifetime of the schema writer object.
	//

	m_pCWriter = i_pcWriter;

} // CMBSchemaWriter::CMBSchemaWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBSchemaWriter::~CMBSchemaWriter()
{
	if(NULL != m_apCollection)
	{
		for(ULONG i=0; i<m_iCollection; i++)
		{
			delete m_apCollection[i];
			m_apCollection[i] = NULL;
		}

		delete [] m_apCollection;
		m_apCollection = NULL;
	}

	m_cCollection = 0;
	m_iCollection = 0;

} // CMBSchemaWriter::~CMBSchemaWriter


/***************************************************************************++
Routine Description:

    Creates a new collection writer and saves it in its list

Arguments:

    [in]  Collection name.
    [out] New collection writer object

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::GetCollectionWriter(LPCWSTR				i_wszCollection,
											 BOOL					i_bContainer,
											 LPCWSTR				i_wszContainerClassList,
										     CMBCollectionWriter**	o_pMBCollectionWriter)
{
	CMBCollectionWriter*	pCMBCollectionWriter = NULL;
	HRESULT                 hr                   = S_OK;

	*o_pMBCollectionWriter = NULL;

	if(m_iCollection == m_cCollection)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	pCMBCollectionWriter = new CMBCollectionWriter();
	if(NULL == pCMBCollectionWriter)
	{
		return E_OUTOFMEMORY;
	}

	pCMBCollectionWriter->Initialize(i_wszCollection,
									 i_bContainer,
									 i_wszContainerClassList,
	                                 m_pCWriter);

	m_apCollection[m_iCollection++] = pCMBCollectionWriter;

	*o_pMBCollectionWriter = pCMBCollectionWriter;

	return S_OK;

} // CMBSchemaWriter::GetCollectionWriter


/***************************************************************************++
Routine Description:

    ReAllocates its list of collection writers.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::ReAllocate()
{
	CMBCollectionWriter** pSav = NULL;

	pSav = new LP_CMBCollectionWriter[m_cCollection + MAX_COLLECTIONS];
	if(NULL == pSav)
	{
		return E_OUTOFMEMORY;
	}
	memset(pSav, 0, (sizeof(LP_CMBCollectionWriter))*(m_cCollection + MAX_COLLECTIONS));

	if(NULL != m_apCollection)
	{
		memcpy(pSav, m_apCollection, (sizeof(LP_CMBCollectionWriter))*(m_cCollection));
		delete [] m_apCollection;
		m_apCollection = NULL;
	}

	m_apCollection = pSav;
	m_cCollection = m_cCollection + MAX_COLLECTIONS;

	return S_OK;

} // CMBSchemaWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Wites the schema.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::WriteSchema()
{
	HRESULT hr = S_OK;

	for(ULONG i=0; i<m_iCollection; i++)
	{
		hr = m_apCollection[i]->WriteCollection();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBSchemaWriter::WriteSchema
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\locationwriter.cpp ===
#include <locale.h>
#include <mdcommon.hxx>
#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "LocationWriter.h"
#include "WriterGlobals.h"
#include "mddefw.h"
#include "iiscnfg.h"
#include "wchar.h"
#include "pudebug.h"

typedef struct _MBProperty
{	
	LPWSTR wszPropertyName;
	ULONG  iRow;
} MBProperty;

typedef MBProperty* PMBProperty;

int _cdecl MyCompare(const void *a,
			         const void *b)
{
	return wcscmp(((PMBProperty)a)->wszPropertyName, ((PMBProperty)b)->wszPropertyName);
}

/***************************************************************************++

Routine Description:

    Constructor for CLocationWriter.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CLocationWriter::CLocationWriter()
{
	m_wszKeyType           = NULL;
	m_eKeyTypeGroup        = eMBProperty_IIsConfigObject;
	m_pCWriter             = NULL;
	m_pCWriterGlobalHelper = NULL;
	m_wszLocation          = NULL;
	m_wszComment           = NULL;
	m_cWellKnownProperty   = 0;
	m_cCustomProperty      = 0;

} // CLocationWriter::CLocationWriter


/***************************************************************************++

Routine Description:

    Destructor for CLocationWriter.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CLocationWriter::~CLocationWriter()
{
	if(NULL != m_wszKeyType)
	{
		delete [] m_wszKeyType;
		m_wszKeyType = NULL;
	}

	if(NULL != m_wszLocation)
	{
		delete [] m_wszLocation;
		m_wszLocation = NULL;
	}

	if(NULL != m_wszComment)
	{
		delete [] m_wszComment;
		m_wszComment = NULL;
	}

} // CLocationWriter::CLocationWriter


/***************************************************************************++

Routine Description:

    This function initializes the location writer

Arguments:

    [in] Pointer to the writer object. It is assumed that this pointer is 
         valid for the lifetime of the locationwriter object.
    [in] Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::Initialize(CWriter* pCWriter,
									LPCWSTR  wszLocation)
{
    ISimpleTableAdvanced*	    pISTAdv = NULL;
	HRESULT                     hr      = S_OK;
	
	m_pCWriter = pCWriter;

	//
	//	Clear the cache for this new location.
	//
	hr = m_pCWriter->m_pISTWrite->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID*)&pISTAdv);

    if (FAILED(hr))
    {
		goto exit;
    }

	hr = pISTAdv->PopulateCache();
	
    if (FAILED(hr))
    {
		goto exit;
    }

	m_wszLocation = new WCHAR[wcslen(wszLocation)+1];
	
    if(NULL == m_wszLocation)
    {
		hr = E_OUTOFMEMORY;
    }
    else
    {
		wcscpy(m_wszLocation, wszLocation);
    }

	m_pCWriterGlobalHelper = m_pCWriter->m_pCWriterGlobalHelper;

	m_cWellKnownProperty   = 0;
	m_cCustomProperty      = 0;

exit:
	if(NULL != pISTAdv)
	{
		pISTAdv->Release();
		pISTAdv = NULL;
	}

	return hr;

} // CLocationWriter::Initialize


/***************************************************************************++
Routine Description:

    This function initializes the key type and is called during 
    IMSAdminBase::Export to initialize the keytype of the exported node when
    there are inherited properties involved.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::InitializeKeyTypeAsInherited()
{
    return AssignKeyType(wszTABLE_IIsInheritedProperties);
}


/***************************************************************************++
Routine Description:

    Given a keytype property from the in-memory metabase, this function 
    validates it against the schema and sets the keytype of the location.

Arguments:

    [in] KeyType property ID as seen in the metabase
    [in] KeyType property attributes as seen in the metabase
    [in] KeyType property user type as seen in the metabase
    [in] KeyType property data type as seen in the metabase
    [in] KeyType value as seen in the metabase
    [in] KeyType value count of bytes as seen in the metabase

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::InitializeKeyType(DWORD	dwKeyTypeID,
										   DWORD	dwKeyTypeAttributes,
										   DWORD	dwKeyTypeUserType,
										   DWORD	dwKeyTypeDataType,
										   PBYTE	pbKeyTypeValue,
										   DWORD	cbKeyType)
{
	HRESULT hr = S_OK;

	if(NULL != m_wszKeyType)
    {
		hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        goto exit;
    }

	if(NULL == pbKeyTypeValue)
	{
		//
		// If KeyType is NULL then assign IIsConfigObject
		//
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}

	if((dwKeyTypeAttributes == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_Attributes])) &&
	        (dwKeyTypeUserType   == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_UserType])) &&
	        (dwKeyTypeDataType   == GetMetabaseType(*(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_Type]),
													*(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_MetaFlags])
			                                       )
			)
	       )
	{
		hr = AssignKeyType((LPWSTR)pbKeyTypeValue);
		
		if(FAILED(hr))
        {
			goto exit;
        }

	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}
	
exit:

	if(FAILED(hr))
	{
		//
		// TODO: Log error that KeyType could  not be initialized,
		//       and default  it to IIsConfigObject.
		//

		hr = AssignKeyType(NULL);

	}
	
	return hr;

} // CLocationWriter::InitializeKeyType


/***************************************************************************++
Routine Description:

    Helper function that helps in initializing the keytype

Arguments:

    [in] KeyType string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AssignKeyType(LPWSTR i_wszKeyType)
{
	HRESULT           hr         = S_OK;
	eMBProperty_Group eGroup;
	LPWSTR            wszKeyType = NULL;

	if(NULL != m_wszKeyType)
	{
		delete [] m_wszKeyType;
		m_wszKeyType = NULL;
	}

	if(NULL == i_wszKeyType)
	{
		wszKeyType = wszTABLE_IIsConfigObject;
		m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
	}
	else
	{
		hr = GetGroupEnum(i_wszKeyType,
						  &eGroup,
						  &wszKeyType);

		if(FAILED(hr))
        {
            return hr;
        }

		if(eMBProperty_Custom == eGroup)
		{
			wszKeyType = wszTABLE_IIsConfigObject;
			m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
		}
		else
        {
			m_eKeyTypeGroup = eGroup;
        }
	}
		
	m_wszKeyType = new WCHAR [wcslen(wszKeyType)+1];
	if(NULL == m_wszKeyType)
    {
		return E_OUTOFMEMORY;
    }
	wcscpy(m_wszKeyType, wszKeyType);

	return hr;

} // CLocationWriter::AssignKeyType


/***************************************************************************++
Routine Description:

    This function saves a property belonging to this location, and is used 
    while writing from the in-memory metabase.

Arguments:

    [in] Property ID as seen in the metabase
    [in] Property attributes as seen in the metabase
    [in] Property user type as seen in the metabase
    [in] Property data type as seen in the metabase
    [in] Property value as seen in the metabase
    [in] Property value count of bytes as seen in the metabase

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AddProperty(DWORD	dwID,
									 DWORD	dwAttributes,
									 DWORD	dwUserType,
									 DWORD	dwDataType,
									 PBYTE	pbData,
									 DWORD  cbData)
{
	HRESULT             hr                = S_OK;
	ULONG               iStartRow         = 0;
	ULONG               aColSearchGroup[] = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG               cColSearchGroup   = sizeof(aColSearchGroup)/sizeof(ULONG);
	LPVOID apvSearchGroup[cCOLUMNMETA_NumberOfColumns];
	apvSearchGroup[iCOLUMNMETA_Table]     = (LPVOID)m_wszKeyType;
	apvSearchGroup[iCOLUMNMETA_ID]        = (LPVOID)&dwID;
	ULONG               iRow              = 0;
	LPWSTR              wszName           = NULL;
	BOOL                bAllocedName      = FALSE;
	eMBProperty_Group	eGroup;
	ULONG               aColWrite[]       = {iMBProperty_Name,
                                             iMBProperty_Type,
                                             iMBProperty_Attributes,
                                             iMBProperty_Value,
                                             iMBProperty_Group,
                                             iMBProperty_ID,
                                             iMBProperty_UserType,
											};
	ULONG               cColWrite         = sizeof(aColWrite)/sizeof(ULONG);
	ULONG               acbSizeWrite[cMBProperty_NumberOfColumns];          
	LPVOID              apvWrite[cMBProperty_NumberOfColumns];          
	DWORD               iWriteRow         = 0;


	if((NULL == m_wszKeyType) || (NULL == m_pCWriter->m_pISTWrite))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}

	if((MD_KEY_TYPE == dwID) &&
	   (m_eKeyTypeGroup != eMBProperty_IIsConfigObject)
	  )
	{
		hr = S_OK; // Do not add KeyType, if it is a well-known KeyType.
		goto exit;
	}

	if(MD_COMMENTS == dwID)
	{
		hr = SaveComment(dwDataType,
			            (WCHAR*)pbData); // Save comment and exit
		goto exit;
	}

	//
	// Fetch the Name for this ID
	//

	hr = m_pCWriterGlobalHelper->GetPropertyName(dwID,
		                                         &wszName,
												 &bAllocedName);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Compute the group for this ID.
	//

	if(eMBProperty_IIsConfigObject == m_eKeyTypeGroup)
	{
		//
		// If the KeyType is IIsConfigObject, then directly assign custom group for this ID.
		//

		eGroup = eMBProperty_Custom;

	}
	else
	{
		//
		// 	Check if this ID belogs to its KeyType collection.
		//

		hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID)->GetRowIndexBySearch(iStartRow, 
																				         cColSearchGroup, 
																				         aColSearchGroup,
																				         NULL, 
																				         apvSearchGroup,
																				         &iRow);

		if(E_ST_NOMOREROWS == hr)
		{
			eGroup = eMBProperty_Custom ;
		}
		else if(FAILED(hr))
		{
			goto exit;
		}
		else
		{
			//
			// Match the type, usertype, and attributes of this property.
			// Assign to KeyType group only if they match. Else assign
			// to custom.
			//
			ULONG aColMetaInfo[] = {iCOLUMNMETA_Type,
									iCOLUMNMETA_MetaFlags,
									iCOLUMNMETA_UserType,
									iCOLUMNMETA_Attributes
								   };

			ULONG cColMetaInfo = sizeof(aColMetaInfo)/sizeof(ULONG);
			LPVOID apvMetaInfo[cCOLUMNMETA_NumberOfColumns];

			hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID)->GetColumnValues(iRow,
																				 cColMetaInfo,
																				 aColMetaInfo,
																				 NULL,
																				 apvMetaInfo);
			if(FAILED(hr))
				goto exit;

			if((dwUserType == *(DWORD*)apvMetaInfo[iCOLUMNMETA_UserType]) &&
			   (dwAttributes == *(DWORD*)apvMetaInfo[iCOLUMNMETA_Attributes]) && 
			   (dwDataType == GetMetabaseType(*(DWORD*)apvMetaInfo[iCOLUMNMETA_Type],
										  *(DWORD*)apvMetaInfo[iCOLUMNMETA_MetaFlags])
			   )
			  )
			{			
				eGroup = m_eKeyTypeGroup;
			}
			else
				eGroup = eMBProperty_Custom;		

		}
	}

	//
	// Save the property to the table. 
	//

//	dwType = GetMBPropertyType(dwDataType);

	if(0 == cbData)
		pbData = NULL;  // TODO: Debug this special case. sometimes pbData was valid when cbData was 0 and it was asserting.

	apvWrite[iMBProperty_Name]       = (LPVOID)wszName;
	apvWrite[iMBProperty_Type]       = (LPVOID)&dwDataType;
	apvWrite[iMBProperty_Attributes] = (LPVOID)&dwAttributes;
	apvWrite[iMBProperty_Value]      = (LPVOID)pbData;
	apvWrite[iMBProperty_Group]      = (LPVOID)&eGroup;
	apvWrite[iMBProperty_Location]   = (LPVOID)NULL;
	apvWrite[iMBProperty_ID]         = (LPVOID)&dwID;
	apvWrite[iMBProperty_UserType]   = (LPVOID)&dwUserType;
	apvWrite[iMBProperty_LocationID] = (LPVOID)NULL;

	acbSizeWrite[iMBProperty_Name]       = 0;
	acbSizeWrite[iMBProperty_Type]       = 0;
	acbSizeWrite[iMBProperty_Attributes] = 0;
	acbSizeWrite[iMBProperty_Value]      = cbData;
	acbSizeWrite[iMBProperty_Group]      = 0;
	acbSizeWrite[iMBProperty_Location]   = 0;
	acbSizeWrite[iMBProperty_ID]         = 0;
	acbSizeWrite[iMBProperty_UserType]   = 0;
	acbSizeWrite[iMBProperty_LocationID] = 0;

	hr = m_pCWriter->m_pISTWrite->AddRowForInsert(&iWriteRow);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->m_pISTWrite->SetWriteColumnValues(iWriteRow,
										   cColWrite,
										   aColWrite,
										   acbSizeWrite,
										   apvWrite);

	if(FAILED(hr))
	{
		goto exit;
	}
	 
	IncrementGroupCount(*((DWORD*)apvWrite[iMBProperty_Group]));
	
exit:

	if(bAllocedName && (NULL != wszName))
	{
		delete [] wszName;
		wszName = NULL;
	}
	
	return hr;	

} // CLocationWriter::AddProperty


/***************************************************************************++
Routine Description:

    This function saves a property belonging to this location, and is used 
    while applying edit while running changes to the history file.

Arguments:

    [in] Bool -  identifies the format of the next to buffers - if true, it
	     is according to MBProperty table else MBPropertyDiff table.
    [in] Buffer containing property value and attributes.
    [in] Count of bytes for data in the buffer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AddProperty(BOOL       bMBPropertyTable,
                                     LPVOID*	a_pv,
									 ULONG*     a_cbSize)
{
	HRESULT hr             = S_OK;
	ULONG   iRow           = 0;
	ULONG   cCol           = cMBProperty_NumberOfColumns;
	LPWSTR  wszName        = NULL;
	BOOL    bAllocedName   = FALSE;

	ULONG   a_cbSizeAdd[cMBProperty_NumberOfColumns];
	LPVOID  a_pvAdd[cMBProperty_NumberOfColumns];

	if(!bMBPropertyTable)
	{
	    a_pvAdd[iMBProperty_Name]             = a_pv[iMBPropertyDiff_Name];
		a_pvAdd[iMBProperty_Type]             = a_pv[iMBPropertyDiff_Type];
		a_pvAdd[iMBProperty_Attributes]       = a_pv[iMBPropertyDiff_Attributes];
		a_pvAdd[iMBProperty_Value]            = a_pv[iMBPropertyDiff_Value];
 		a_pvAdd[iMBProperty_Location]         = a_pv[iMBPropertyDiff_Location];
		a_pvAdd[iMBProperty_ID]               = a_pv[iMBPropertyDiff_ID];
	    a_pvAdd[iMBProperty_UserType]         = a_pv[iMBPropertyDiff_UserType];
	    a_pvAdd[iMBProperty_LocationID]       = a_pv[iMBPropertyDiff_LocationID];
	    a_pvAdd[iMBProperty_Group]            = a_pv[iMBPropertyDiff_Group];

	    a_cbSizeAdd[iMBProperty_Name]	      = a_cbSize[iMBPropertyDiff_Name];
		a_cbSizeAdd[iMBProperty_Type]         = a_cbSize[iMBPropertyDiff_Type];
		a_cbSizeAdd[iMBProperty_Attributes]   = a_cbSize[iMBPropertyDiff_Attributes];
		a_cbSizeAdd[iMBProperty_Value]        = a_cbSize[iMBPropertyDiff_Value];
		a_cbSizeAdd[iMBProperty_Location]     = a_cbSize[iMBPropertyDiff_Location];
		a_cbSizeAdd[iMBProperty_ID]           = a_cbSize[iMBPropertyDiff_ID];
	    a_cbSizeAdd[iMBProperty_UserType]     = a_cbSize[iMBPropertyDiff_UserType];
	    a_cbSizeAdd[iMBProperty_LocationID]   = a_cbSize[iMBPropertyDiff_LocationID];
	    a_cbSizeAdd[iMBProperty_Group]        = a_cbSize[iMBPropertyDiff_Group];
		
	}
	else
	{
	    a_pvAdd[iMBProperty_Name]             = a_pv[iMBProperty_Name];
		a_pvAdd[iMBProperty_Type]             = a_pv[iMBProperty_Type];
		a_pvAdd[iMBProperty_Attributes]       = a_pv[iMBProperty_Attributes];
		a_pvAdd[iMBProperty_Value]            = a_pv[iMBProperty_Value];
 		a_pvAdd[iMBProperty_Location]         = a_pv[iMBProperty_Location];
		a_pvAdd[iMBProperty_ID]               = a_pv[iMBProperty_ID];
	    a_pvAdd[iMBProperty_UserType]         = a_pv[iMBProperty_UserType];
	    a_pvAdd[iMBProperty_LocationID]       = a_pv[iMBProperty_LocationID];
	    a_pvAdd[iMBProperty_Group]            = a_pv[iMBProperty_Group];

	    a_cbSizeAdd[iMBProperty_Name]	      = a_cbSize[iMBProperty_Name];
		a_cbSizeAdd[iMBProperty_Type]         = a_cbSize[iMBProperty_Type];
		a_cbSizeAdd[iMBProperty_Attributes]   = a_cbSize[iMBProperty_Attributes];
		a_cbSizeAdd[iMBProperty_Value]        = a_cbSize[iMBProperty_Value];
		a_cbSizeAdd[iMBProperty_Location]     = a_cbSize[iMBProperty_Location];
		a_cbSizeAdd[iMBProperty_ID]           = a_cbSize[iMBProperty_ID];
	    a_cbSizeAdd[iMBProperty_UserType]     = a_cbSize[iMBProperty_UserType];
	    a_cbSizeAdd[iMBProperty_LocationID]   = a_cbSize[iMBProperty_LocationID];
	    a_cbSizeAdd[iMBProperty_Group]        = a_cbSize[iMBProperty_Group];

	}

	//
	// Check if non-primary keys have valid values, if not error
	//

	if((NULL == a_pvAdd[iMBProperty_Type])       || 
	   (NULL == a_pvAdd[iMBProperty_Attributes]) ||
	   (NULL == a_pvAdd[iMBProperty_ID])         ||
	   (NULL == a_pvAdd[iMBProperty_UserType])   ||
	   (NULL == a_pvAdd[iMBProperty_Group])
	  )
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}

	if(MD_COMMENTS == *(DWORD*)a_pvAdd[iMBProperty_ID])
	{
		hr = SaveComment(*(DWORD*)a_pvAdd[iMBProperty_Type],
			            (WCHAR*)a_pvAdd[iMBProperty_Value]);
		goto exit;
	}

	if((NULL == a_pvAdd[iMBProperty_Name]) || (0 == *(LPWSTR)(a_pvAdd[iMBProperty_Name])))
	{
		//
		// Fetch the Name for this ID
		//

		hr = m_pCWriterGlobalHelper->GetPropertyName(*(DWORD*)(a_pvAdd[iMBProperty_ID]),
													 &wszName,
													 &bAllocedName);

		a_pvAdd[iMBProperty_Name] = wszName;

	}

	if(MD_KEY_TYPE == *(DWORD*)a_pvAdd[iMBProperty_ID]) 
	{
		//
		// Initialize the KeyType, only if it is not custom.
		// Note that the case will be correct for valid keytypes because if 
		// someone has typed the keytype with the wrong case then the element
		// itself would be ignored during read and will not show up in the 
		// table.
		//

		if((eMBProperty_Custom != (*(DWORD*)a_pvAdd[iMBProperty_Group])) &&
		   (eMBProperty_IIsConfigObject != (*(DWORD*)a_pvAdd[iMBProperty_Group]))
		  )
		{
			hr = AssignKeyType((LPWSTR)a_pvAdd[iMBProperty_Value]);
			goto exit;
		}
	}

	hr = m_pCWriter->m_pISTWrite->AddRowForInsert(&iRow);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->m_pISTWrite->SetWriteColumnValues(iRow,
                                                       cCol,
                                                       NULL,
                                                       a_cbSizeAdd,
                                                       a_pvAdd);

	if(FAILED(hr))
	{
		goto exit;
	}

	IncrementGroupCount(*((DWORD*)a_pvAdd[iMBProperty_Group]));

exit:

	if(bAllocedName && (NULL != wszName))
	{
		delete [] wszName;
		wszName = NULL;
	}

	return hr;

}	


/***************************************************************************++
Routine Description:

    This function is saves the comment property.

Arguments:

    [in] data type
    [in] comment

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::SaveComment(DWORD  i_dwDataType,
			                         LPWSTR i_wszComment)
{
	HRESULT hr = S_OK;

	if(STRING_METADATA == i_dwDataType)
	{
		if((NULL  != i_wszComment) && 
		   (L'\0' != *i_wszComment)
		  )
		{
			ULONG cchComment = wcslen(i_wszComment);
			m_wszComment = new WCHAR[cchComment+1];

			if(NULL == m_wszComment)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				wcscpy(m_wszComment, i_wszComment);
			}
		}
	}

	return hr;

} // CLocationWriter::SaveComment


/***************************************************************************++
Routine Description:

    Given a string representation of the keytype (also called as group in the
    MBProperty table) this function returns the corresponginf group enum in
    the MBProperty table.

Arguments:

    [in]  KeyType string
    [out] group enum
	[out] group string as seen by the meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::GetGroupEnum(LPWSTR             wszGroup,
									  eMBProperty_Group* peGroup,
									  LPWSTR*            pwszGroup)
{
	ULONG   iReadRow                             = 0;
	DWORD*  pdwGroup                             = NULL;
	HRESULT hr                                   = S_OK;
	ULONG   aColSearch[]                         = {iTAGMETA_Table,
						                            iTAGMETA_ColumnIndex,
						                            iTAGMETA_InternalName};
	ULONG   cColSearch                           = sizeof(aColSearch)/sizeof(ULONG);
	ULONG   a_iCol[]                             = {iTAGMETA_Value,
									                iTAGMETA_InternalName};
	ULONG   cCol                                 = sizeof(a_iCol)/sizeof(ULONG);
	LPVOID  a_pv[cTAGMETA_NumberOfColumns];
   
	ULONG   iCol                                 = iMBProperty_Group;
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
	apvSearch[iTAGMETA_Table]                    = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
	apvSearch[iTAGMETA_ColumnIndex]              = (LPVOID)&iCol;
	apvSearch[iTAGMETA_InternalName]             = (LPVOID)wszGroup;
	ULONG   iStartRow                            = 0;

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndName)->GetRowIndexBySearch(iStartRow, 
																				                  cColSearch, 
																				                  aColSearch,
																				                  NULL, 
																				                  apvSearch,
																				                  &iReadRow);
	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Value does not match any known group. Return Custom
		//
		*peGroup = eMBProperty_Custom;
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"\nGetRowIndexBySearch failed with hr = 0x%x\n",hr));
		goto exit;
	}

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndName)->GetColumnValues (iReadRow, 
																			                   cCol, 
																			                   a_iCol, 
																			                   NULL, 
																			                   (LPVOID*)a_pv);
							
	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Value does not match any known group. Return Custom
		//
		*peGroup = eMBProperty_Custom;
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"\nGetColumnValues failed with hr = 0x%x\n",hr));
		goto exit;
	}
	else
    {
		*peGroup = (eMBProperty_Group)(*(DWORD*)a_pv[iTAGMETA_Value]);
		*pwszGroup = (LPWSTR) a_pv[iTAGMETA_InternalName];
    }

exit:

	return hr;

} // CLocationWriter::GetGroupEnum


/***************************************************************************++
Routine Description:

    This function writes the location and its properties that have been 
    added to it.

    Eg: <IIsWebService	Location ="/LM/W3SVC"
                		AccessFlags="AccessExecute | AccessRead"
		                AnonymousUserName="IUSR_ANILR-STRESS"
		                AnonymousUserPass="496344627000000022000000400000001293a44feb796fdb8b9946a130e4d1292f3f402b02a178747135bf774f3af7f788ad000000000000c8e578cb0f27e78f3823ee341098ef4dda5d44c0121ae53d2959ffb198380af80f15af29e2c865b2473931e1a5e768a1752166062555bd1df951ab71fb67239d"
	                >
	                <Custom
		                Name="AdminServer"
		                ID="2115"
		                Value="2"
		                Type="STRING"
		                UserType="IIS_MD_UT_SERVER"
		                Attributes="INHERIT"
	                />
        </IIsWebService>

    Eg: <IIsConfigObject	Location ="/LM/W3SVC/1/Root/localstart.asp"
	                >
	                <Custom
		                Name="AuthFlags"
		                ID="6000"
		                Value="AuthBasic | AuthNTLM"
		                Type="DWORD"
		                UserType="IIS_MD_UT_FILE"
		                Attributes="INHERIT"
	                />
        </IIsConfigObject>

Arguments:

    [in]  Bool - sort location or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteLocation(BOOL bSort)
{

	HRESULT hr                        = S_OK;
	ULONG*  aiRowSorted               = NULL;
	ULONG   cRowSorted                = 0;
	ULONG   i                         = 0;
	DWORD   bFirstCustomPropertyFound = FALSE; 

	//
	// KeyType has to be initialized, if not initialize it
	//
	
	if(NULL == m_wszKeyType)
	{
		hr = AssignKeyType(NULL);

		if(FAILED(hr))
        {
			goto exit;
        }
	}
	
	if(bSort)
	{
		hr = Sort(&aiRowSorted,
				  &cRowSorted);

		if(FAILED(hr))
        {
			goto exit;	
        }
	
	}

	if(NULL != m_wszComment)
	{
		hr = WriteComment();

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	hr = WriteBeginLocation(m_wszLocation);

	if(FAILED(hr))
    {
		goto exit;
    }

	for(i=0; ;i++)
	{

		ULONG   iRow = 0;
		ULONG   cCol = cMBProperty_NumberOfColumns;
		ULONG   a_cbSize[cMBProperty_NumberOfColumns];
		LPVOID  a_pv[cMBProperty_NumberOfColumns];

		if(bSort && (NULL != aiRowSorted))
		{
			if(cRowSorted == i)
            {
				break;
            }

			iRow =  aiRowSorted[i];
		}
		else 
        {
			iRow = i;
        }

		hr = m_pCWriter->m_pISTWrite->GetWriteColumnValues(iRow,
											   cCol,
											   NULL,
											   NULL,
											   a_cbSize,
											   a_pv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
        {
			goto exit;
        }

		//
		// Ignore the location with no property property.
		//

		if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == L'#'))
        {
            continue;
        }

		if(!bFirstCustomPropertyFound)
		{
			if((eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group])) ||
			   (eMBProperty_IIsConfigObject == *(DWORD*)(a_pv[iMBProperty_Group]))
			  )
			{
				hr = WriteEndWellKnownGroup();
				
				if(FAILED(hr))
                {
					goto exit;
                }

				bFirstCustomPropertyFound = TRUE;

			}
		}
			
		if((eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group])) ||
		   (eMBProperty_IIsConfigObject == *(DWORD*)(a_pv[iMBProperty_Group]))
		  )
        {
			hr = WriteCustomProperty(a_pv,
									 a_cbSize);
        }
        else
        {
            hr = WriteWellKnownProperty(a_pv,
									    a_cbSize);
        }

		if(FAILED(hr))
        {
			goto exit;
        }


	}

	if(!bFirstCustomPropertyFound)
	{
		hr = WriteEndWellKnownGroup();
		
		if(FAILED(hr))
        {
			goto exit;	
        }
	}

	hr = WriteEndLocation();

	if(FAILED(hr))
    {
		goto exit;	
    }

exit:

	if(NULL != aiRowSorted)
	{
		delete [] aiRowSorted;
		aiRowSorted = NULL;
	}

	return hr;

} // CLocationWriter::WriteLocation


/***************************************************************************++
Routine Description:

    This function reurn a sorted array of indicies of the cache containing
    properties. The sort is based on property name.
	Note - the number of wellknowns vs custom properties are counted in 
	AddProperty.

Arguments:

    [in]  Bool - sort location or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::Sort(ULONG** paiRowSorted,
                              ULONG*  pcRowSorted)
{

	HRESULT     hr                 = S_OK;
	ULONG       iCustom            = 0;
	ULONG       iWellKnown         = 0;
	ULONG       iRow               = 0;
	ULONG       i                  = 0;
	MBProperty* aWellKnownProperty = NULL;
	MBProperty*	aCustomProperty    = NULL;

	//
	// Allocate arrays to hold Cusom property / Well known property.
	// 

	if(m_cCustomProperty > 0)
	{
		aCustomProperty = new MBProperty[m_cCustomProperty];
		if(NULL == aCustomProperty)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}

	if(m_cWellKnownProperty > 0)
	{
		aWellKnownProperty = new MBProperty[m_cWellKnownProperty];
		if(NULL == aWellKnownProperty)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}
	
	//
	// Populate the arrays
	//

	for(iRow=0;;iRow++)
	{
	
		DWORD* pdwGroup = NULL;
		ULONG  aCol[] = {iMBProperty_Group,
		                 iMBProperty_Name
						};
		ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
		LPVOID apv[cMBProperty_NumberOfColumns];

		hr = m_pCWriter->m_pISTWrite->GetWriteColumnValues(iRow,
											   cCol,
											   aCol,
											   NULL,
											   NULL,
											   apv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
        {
			goto exit;
        }

		if((eMBProperty_Custom == *(DWORD*)(apv[iMBProperty_Group])) ||
		   (eMBProperty_IIsConfigObject == *(DWORD*)(apv[iMBProperty_Group]))
		  )
		{
			DBG_ASSERT((aCustomProperty != NULL) && (iCustom < m_cCustomProperty));
			aCustomProperty[iCustom].iRow = iRow;
			aCustomProperty[iCustom++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
		}
		else
		{
			DBG_ASSERT((aWellKnownProperty != NULL) && (iWellKnown < m_cWellKnownProperty));
			aWellKnownProperty[iWellKnown].iRow = iRow;
			aWellKnownProperty[iWellKnown++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
		}

	}

	
	//
	// Sort the individual arrays.
	//

	if(m_cCustomProperty > 0)
    {
		DBG_ASSERT(aCustomProperty != NULL);
        qsort((void*)aCustomProperty, m_cCustomProperty, sizeof(MBProperty), MyCompare);
    }
    if(m_cWellKnownProperty > 0)
    {
		DBG_ASSERT(aWellKnownProperty != NULL);
        qsort((void*)aWellKnownProperty, m_cWellKnownProperty, sizeof(MBProperty), MyCompare);
    }

	//
	// Create the new array of indicies. First add well known, then custom
	//

	*paiRowSorted = new ULONG [m_cCustomProperty + m_cWellKnownProperty];
	if(NULL == *paiRowSorted)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	for(i=0, iRow=0; iRow<m_cWellKnownProperty; iRow++, i++)
    {
        (*paiRowSorted)[i] = (aWellKnownProperty[iRow]).iRow;
    }

	for(iRow=0; iRow<m_cCustomProperty; iRow++, i++)
    {
        (*paiRowSorted)[i] = (aCustomProperty[iRow]).iRow;
    }

	*pcRowSorted = m_cCustomProperty + m_cWellKnownProperty;

exit:

	if(NULL != aCustomProperty)
	{
		delete [] aCustomProperty;
		aCustomProperty = NULL;
	}
	if(NULL != aWellKnownProperty)
	{
		delete [] aWellKnownProperty;
		aWellKnownProperty = NULL;
	}

	return hr;

} // CLocationWriter::Sort


/***************************************************************************++
Routine Description:

    This writes comments at the beginning of a location.

    Eg: <!-- Add the user defined comments here. -->

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteComment()
{

	HRESULT hr                = S_OK;
	LPWSTR  wszEscapedComment = NULL;
	ULONG   cchEscapedComment = 0;
	BOOL    bEscapedComment   = FALSE;

	hr = m_pCWriter->WriteToFile((LPVOID)g_BeginComment,
								 g_cchBeginComment);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriterGlobalHelper->EscapeString(m_wszComment,
		                                      wcslen(m_wszComment),
                                              &bEscapedComment,
					                          &wszEscapedComment,
											  &cchEscapedComment);


	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszEscapedComment,
								 cchEscapedComment);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_EndComment,
								 g_cchEndComment);

	if(FAILED(hr))
	{
		goto exit;
	}

exit:

	if(bEscapedComment && (NULL != wszEscapedComment))
	{
		delete [] wszEscapedComment;
		wszEscapedComment = NULL;
	}

	return hr;


} // CLocationWriter::WriteComment


/***************************************************************************++
Routine Description:

    This writes the beginning tag of a location.

    Eg: <IIsWebServer Location="/LM/W3SVC"
    or: <IIsConfigObject Location="/LM/W3SVC/Foo"

Arguments:

    [in]  Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteBeginLocation(LPCWSTR  wszLocation)
{
	HRESULT hr                 = S_OK;
	DWORD   cchLocation        = wcslen(wszLocation);
	DWORD	iLastChar          = cchLocation-1;
	BOOL	bEscapedLocation   = FALSE;
	LPWSTR  wszEscapedLocation = NULL;
	ULONG   cchEscapedLocation = 0;
	
	hr = m_pCWriterGlobalHelper->EscapeString(wszLocation,
		                                      cchLocation,
                                              &bEscapedLocation,
					                          &wszEscapedLocation,
											  &cchEscapedLocation);

	if(FAILED(hr))
    {
		goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_BeginLocation,
								 g_cchBeginLocation);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)m_wszKeyType,
								 wcslen(m_wszKeyType));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_Location,
								 g_cchLocation);

	if(FAILED(hr))
    {
        goto exit;
    }

	if((0 != iLastChar) && (L'/' == wszLocation[iLastChar]))
	{
		cchEscapedLocation--;
	}

	hr = m_pCWriter->WriteToFile((LPVOID)wszEscapedLocation,
								 cchEscapedLocation);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

exit:

	if(bEscapedLocation && (NULL != wszEscapedLocation))
	{
		delete [] wszEscapedLocation;
		wszEscapedLocation = NULL;
	}

	return hr;

} // CLocationWriter::WriteBeginLocation


/***************************************************************************++
Routine Description:

    This writes the end tag of a location.

    Eg: </IIsWebServer>
    or: </IIsConfigObject>

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteEndLocation()
{
	HRESULT hr= S_OK;

	hr = m_pCWriter->WriteToFile((LPVOID)g_EndLocationBegin,
								 g_cchEndLocationBegin);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)m_wszKeyType,
								 wcslen(m_wszKeyType));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_EndLocationEnd,
								 g_cchEndLocationEnd);

	if(FAILED(hr))
    {
        goto exit;
    }

exit:

	return hr;	

} // CLocationWriter::WriteEndLocation


/***************************************************************************++
Routine Description:

    This writes a custom property

    Eg: <Custom
		        Name="LogCustomPropertyName"
		        ID="4501"
		        Value="Process Accounting"
		        Type="STRING"
		        UserType="IIS_MD_UT_SERVER"
		        Attributes="NO_ATTRIBUTES"
	    />


Arguments:

    [in] Buffer containing property value and attributes.
    [in] Count of bytes for data in the buffer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteCustomProperty(LPVOID*  a_pv,
											 ULONG*   a_cbSize)
{

	ULONG	dwBytesWritten   = 0;
	HRESULT hr               = S_OK;
	DWORD	dwType           = *(DWORD*)a_pv[iMBProperty_Type];
	LPWSTR	wszType          = g_T_Unknown;
	DWORD	dwUserType       = *(DWORD*)a_pv[iMBProperty_UserType];
	LPWSTR	wszUserType      = g_UT_Unknown;
	ULONG   cchUserType      = 0;
	BOOL    bAllocedUserType = FALSE;
	LPWSTR	wszValue         = NULL;
	WCHAR   wszID[40];
	LPWSTR  wszAttributes    = NULL;


	ULONG aColSearchType[]   = {iTAGMETA_Table,
					            iTAGMETA_ColumnIndex,
					            iTAGMETA_Value
	};
	ULONG cColSearchType     = sizeof(aColSearchType)/sizeof(ULONG);
	ULONG iColType           = iMBProperty_Type;
	LPVOID apvSearchType[cTAGMETA_NumberOfColumns];
	apvSearchType[iTAGMETA_Table]       = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
	apvSearchType[iTAGMETA_ColumnIndex] = (LPVOID)&iColType;
	apvSearchType[iTAGMETA_Value]       = (LPVOID)&dwType;

	ULONG iRow               = 0;
	ULONG iStartRow          = 0;
	ULONG iColAttributes     = iMBProperty_Attributes;

	_ultow(*(DWORD*)a_pv[iMBProperty_ID], wszID, 10);

	//
	// Get the tag for UserType from meta
	//

	hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(dwUserType,
		                                                 &wszUserType,
														 &cchUserType,
														 &bAllocedUserType);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Get the tag for Type from meta
	//

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndValue)->GetRowIndexBySearch(iStartRow, 
																				                   cColSearchType,
																				                   aColSearchType,
																				                   NULL, 
																				                   apvSearchType,
																				                   &iRow);

	if(E_ST_NOMOREROWS == hr)
	{	
		hr = S_OK;
		wszType = g_T_Unknown;
	}
	else if(FAILED(hr))
    {
        goto exit;	
    }
	else 
	{
		iColType = iTAGMETA_InternalName;

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndValue)->GetColumnValues(iRow,
																				                   1,
																				                   &iColType,
																				                   NULL,
																				                   (LPVOID*)&wszType);

		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			wszType = g_T_Unknown;
		}
		else if(FAILED(hr))
        {
            goto exit;
        }
	}

	//
	// Construct the tag for Attributes from meta
	//

	hr = m_pCWriterGlobalHelper->FlagToString(*(DWORD*)a_pv[iMBProperty_Attributes],
										      &wszAttributes,
											  m_pCWriterGlobalHelper->m_wszTABLE_MBProperty,
											  iColAttributes);
	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
										  a_cbSize[iMBProperty_Value],
										  *(DWORD*)a_pv[iMBProperty_ID],
										  dwType,
										  *(DWORD*)a_pv[iMBProperty_Attributes],
										  &wszValue);

	if(FAILED(hr))
    {
        goto exit;
    }

	//
	// Write all the values.
	//

	hr = m_pCWriter->WriteToFile((LPVOID)g_BeginCustomProperty,
								 g_cchBeginCustomProperty);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_NameEq,
								 g_cchNameEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)(LPWSTR)a_pv[iMBProperty_Name],
								 wcslen((LPWSTR)a_pv[iMBProperty_Name]));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_IDEq,
								 g_cchIDEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)wszID,
								 wcslen(wszID));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_ValueEq,
								 g_cchValueEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	if(NULL != wszValue)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
									 wcslen(wszValue));

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_TypeEq,
								 g_cchTypeEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)wszType,
								 wcslen(wszType));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_UserTypeEq,
								 g_cchUserTypeEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)wszUserType,
								 wcslen(wszUserType));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_AttributesEq,
								 g_cchAttributesEq);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)wszAttributes,
								 wcslen(wszAttributes));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_EndCustomProperty,
								 g_cchEndCustomProperty);

	if(FAILED(hr))
    {
        goto exit;
    }
	
exit:

	if((NULL != wszUserType) && bAllocedUserType)
	{
		delete [] wszUserType;
		wszUserType = NULL;
	}
	cchUserType = NULL;

	if(NULL != wszValue)
	{
		delete [] wszValue;
		wszValue = NULL;
	}

	if(NULL != wszAttributes)
	{
		delete [] wszAttributes;
		wszAttributes = NULL;
	}

	return hr;

} // CLocationWriter::WriteCustomProperty


/***************************************************************************++
Routine Description:

    This writes end of a well known group

    Eg: >

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteEndWellKnownGroup()
{
	return m_pCWriter->WriteToFile((LPVOID)g_EndGroup,
								   wcslen(g_EndGroup));

} // CLocationWriter::WriteEndWellKnownGroup


/***************************************************************************++
Routine Description:

    This writes a well-known property

    Eg: AccessFlags="AccessExecute | AccessRead"

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteWellKnownProperty(LPVOID*   a_pv,
									            ULONG*    a_cbSize)
{
	HRESULT hr       = S_OK;
	LPWSTR	wszValue = NULL;
	
	hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
										  a_cbSize[iMBProperty_Value],
										  *(DWORD*)a_pv[iMBProperty_ID],
										  *(DWORD*)a_pv[iMBProperty_Type],
										  *(DWORD*)a_pv[iMBProperty_Attributes],
										  &wszValue);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_TwoTabs,
								 g_cchTwoTabs);

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)(LPWSTR)a_pv[iMBProperty_Name],
								 wcslen((LPWSTR)a_pv[iMBProperty_Name]));

	if(FAILED(hr))
    {
        goto exit;
    }

	hr = m_pCWriter->WriteToFile((LPVOID)g_EqQuote,
								 g_cchEqQuote);

	if(FAILED(hr))
    {
        goto exit;
    }

	if(NULL != wszValue)
	{
		hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
									 wcslen(wszValue));

		if(FAILED(hr))
		{
			goto exit;
		}

	}

	hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
								 g_cchQuoteRtn);

	if(FAILED(hr))
	{
		goto exit;
	}

exit:

	if(NULL != wszValue)
	{
		delete [] wszValue;
		wszValue = NULL;
	}

	return hr;

} // CLocationWriter::WriteWellKnownProperty


/***************************************************************************++
Routine Description:

    Looks at the group and increments the group count.
	This must be called every time a property is added.

Arguments:

    group.

Return Value:

    Void

--***************************************************************************/
void CLocationWriter::IncrementGroupCount(DWORD i_dwGroup)
{
    if((eMBProperty_Custom == i_dwGroup) ||
       (eMBProperty_IIsConfigObject == i_dwGroup)
      )
    {
        m_cCustomProperty++;
    }
	else
    {
        m_cWellKnownProperty++;
    }

} // CLocationWriter::IncrementGroupCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\registry.cxx ===
#include <mdcommon.hxx>

MDRegKey::MDRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = ERROR_SUCCESS;

    if ( pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, &hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL ;
            SetLastError(err);
        }

    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

//
//  Constructor creating a new key.
//
MDRegKey::MDRegKey (
    LPCTSTR pchSubKey,
    HKEY hKeyBase,
    DWORD dwOptions,
    REGSAM regSam,
    LPSECURITY_ATTRIBUTES pSecAttr,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    DWORD err = 0;

    if (pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, & hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL;
            SetLastError(err);
        }

    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        LPCTSTR szEmpty = TEXT("") ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey, 0, (TCHAR *) szEmpty,
            dwOptions, regSam, pSecAttr, &m_hKey, &m_dwDisposition );
    }
    if (err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
    SetLastError(err);
}

MDRegKey::~MDRegKey()
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}

DWORD
MDRegKey::QueryValue (
    LPTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pdwSize,
    BUFFER *pbufData
    )
{
    DWORD dwReturn = ERROR_SUCCESS;

    *pdwSize = pbufData->QuerySize();

    dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
        0, pdwType, (PBYTE) pbufData->QueryPtr(), pdwSize);

    if (dwReturn == ERROR_MORE_DATA) {
        if (pbufData->Resize(*pdwSize)) {
            *pdwSize = pbufData->QuerySize();
            dwReturn = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
                0, pdwType, (PBYTE)pbufData->QueryPtr(), pdwSize);
        }
    }

    return dwReturn;
}

//
//  Overloaded value setting members.
//
DWORD
MDRegKey::SetValue (
    LPCTSTR pchValueName,
    DWORD dwType,
    DWORD dwSize,
    PBYTE pbData
    )
{
    return ::RegSetValueEx( *this, pchValueName, 0, dwType,
        pbData, dwSize );
}


DWORD
MDRegKey::DeleteValue (
    LPCTSTR pchValueName
    )
{
    return ::RegDeleteValue( *this, (LPTSTR) pchValueName);
}

DWORD
MDRegKey::QueryKeyInfo (
    MDREGKEY_KEY_INFO * pRegKeyInfo
    )
{
    DWORD err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey(*this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );

    return err ;
}

//
// Iteration class
//
MDRegKeyIter::MDRegKeyIter (
    MDRegKey & regKey
    )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    DWORD err = 0 ;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegKeyIter :: ~ MDRegKeyIter ()
{
    delete [] m_p_buffer ;
}

//
// Get the name (and optional last write time) of the next key.
//

DWORD MDRegKeyIter::Next(
    LPTSTR *ppszName,
    FILETIME *pTime,
    DWORD dwIndex
    )
{
    DWORD err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    if (dwIndex != 0xffffffff) {
        m_dw_index = dwIndex;
    }

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer, & dwNameSize,
        NULL, NULL, NULL, & ftDummy ) ;

    if (err == ERROR_SUCCESS)
    {
        ++m_dw_index;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        *ppszName = m_p_buffer;
    }

    return err;
}

MDRegValueIter::MDRegValueIter (
    MDRegKey &regKey
    )
    : m_rk_iter(regKey),
      m_p_buffer(NULL),
      m_cb_buffer(0)
{
    DWORD err = 0;

    MDRegKey::MDREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if (err == ERROR_SUCCESS)
    {
        m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD);
        m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        if (m_p_buffer == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    SetLastError(err);
}

MDRegValueIter::~MDRegValueIter()
{
    delete [] m_p_buffer;
}

DWORD
MDRegValueIter::Next (
    LPTSTR * ppszName,
    DWORD * pdwType
    )
{
    DWORD err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue(m_rk_iter, m_dw_index, m_p_buffer,
        &dwNameLength, NULL, pdwType, NULL, NULL );

    if ( err == ERROR_SUCCESS )
    {
        ++m_dw_index;

        *ppszName = m_p_buffer;
    }

    return err;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\metabase.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metabase.cxx

Abstract:

    IIS MetaBase exported routines.
    Routine comments are in metadata.h.

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/

#include <mdcommon.hxx>

#include <initguid.h>
DEFINE_GUID(IisMetadataGuid, 
0x784d890A, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        if (InterlockedIncrement((long *)&g_dwProcessAttached) > 1) {
            OutputDebugString("Metadata.dll failed to load.\n"
                              "Most likely cause is IISADMIN service is already running.\n"
                              "Do a \"net stop iisadmin\" and stop all instances of inetinfo.exe.\n");
            bReturn = FALSE;
        }
        else {
#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT("Metadata");
            SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT("Metadata", IisMetadataGuid);
#endif
            g_pboMasterRoot = NULL;
            g_phHandleHead = NULL;
            g_ppbdDataHashTable = NULL;
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                g_phEventHandles[i] = NULL;
            }
            g_hReadSaveSemaphore = NULL;
            g_bSaveDisallowed = FALSE;
            g_rMasterResource = new TS_RESOURCE();
            g_rSinkResource = new TS_RESOURCE();
            g_pFactory = new CMDCOMSrvFactory();
            if ((g_pFactory == NULL) || (g_rSinkResource == NULL) || (g_rMasterResource == NULL)){
                bReturn = FALSE;
            }
            if (bReturn) {
                bReturn = InitializeMetabaseSecurity();
            }
        }

        break;

    case DLL_PROCESS_DETACH:
        if (InterlockedDecrement((long *)&g_dwProcessAttached) == 0) {
            if (g_rMasterResource != NULL) {
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                if (g_dwInitialized > 0) {
                    //
                    // Terminate was not called, or did not succeed, so call it
                    //
                    TerminateWorker();
                }
                g_rMasterResource->Unlock();
                delete (g_rMasterResource);
            }
            delete (g_rSinkResource);
            delete (g_pFactory);
            TerminateMetabaseSecurity();
            DELETE_DEBUG_PRINT_OBJECT( );
        }
        break;

    default:
        break;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\readschema.cpp ===
#include <locale.h>
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <malloc.h>
#include <tuneprefix.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>

#include "iisdef.h"
#include "Writer.h"
#include "WriterGlobals.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"
#include "MBSchemaWriter.h"
#include "pudebug.h"
#include "iissynid.h"
#include "ReadSchema.h"

DWORD GetMetabaseFlags(DWORD i_CatalogFlag)
{
	return i_CatalogFlag & 0x00000003;	// First two bits represent metabase flag property.
}


/***************************************************************************++

Routine Description:

    Reads the schema fromthe catalog into the schema tree.

Arguments:

	[in]  Storage pointer.
	[in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadSchema(IIS_CRYPTO_STORAGE*		i_pStorage,
	   			   FILETIME*				i_pFileTime)
{
	HRESULT		        hr						= S_OK;
    CMDBaseObject*	    pboReadSchema			= NULL;

	if(FAILED(hr))
	{
		goto exit;
	}


	hr = ReadMetaObject(pboReadSchema,
						(LPWSTR)g_wszSlashSchema,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = ReadSchemaProperties(pboReadSchema,
							  i_pStorage);

	if(FAILED(hr))
	{
		goto exit;

	}

	hr = ReadProperties(i_pStorage,
						i_pFileTime);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = ReadClasses(i_pStorage,
					 i_pFileTime);

	if(FAILED(hr))
	{
		goto exit;
	}

exit:

	return hr;

} // ReadSchema


/***************************************************************************++

Routine Description:

    Reads the properties in the root of the schema.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadSchemaProperties(CMDBaseObject*           i_pboRead,
							 IIS_CRYPTO_STORAGE*	  i_pStorage)
{
	HRESULT hr = S_OK;

	hr = ReadAdminACL(i_pboRead,
		              i_pStorage);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = ReadLargestMetaID(i_pboRead,
		                   i_pStorage);

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // ReadSchemaProperties


/***************************************************************************++

Routine Description:

    Construct the Admin ACL property

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadAdminACL(CMDBaseObject*       i_pboRead,
 				     IIS_CRYPTO_STORAGE*  i_pStorage)
{
    BOOL                 b                    = FALSE;
    DWORD                dwLength             = 0;

    PSECURITY_DESCRIPTOR pSD                  = NULL;
    PSECURITY_DESCRIPTOR outpSD               = NULL;
    DWORD                cboutpSD             = 0;
    PACL                 pACLNew              = NULL;
    DWORD                cbACL                = 0;
    PSID                 pAdminsSID           = NULL;
	PSID                 pEveryoneSID         = NULL;
    BOOL                 bWellKnownSID        = FALSE;
    HRESULT              hr                   = S_OK;
    DWORD                dwRes                = 0;
	DWORD                dwMetaIDAdminACL     = MD_ADMIN_ACL;
    DWORD                dwAttributesAdminACL = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    DWORD                dwUserTypeAdminACL   = IIS_MD_UT_SERVER;
    DWORD                dwDataTypeAdminACL   = BINARY_METADATA;

	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];

	//
    // Initialize a new security descriptor
	//

    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
		                                    SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!pSD) 
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
    
    InitializeSecurityDescriptor(pSD, 
								 SECURITY_DESCRIPTOR_REVISION);
	//
    // Get Local Admins Sid
	//

    dwRes = GetPrincipalSID (L"Administrators", 
		                     &pAdminsSID, 
					         &bWellKnownSID);

	if(ERROR_SUCCESS != dwRes)
	{
		hr = HRESULT_FROM_WIN32(dwRes);
		goto exit;
	}

    //
	// Get everyone Sid
	//

    GetPrincipalSID (L"Everyone", &pEveryoneSID, &bWellKnownSID);

    //
	// Initialize a new ACL, which only contains 2 aaace
	//

    cbACL = sizeof(ACL) +
            (sizeof(ACCESS_ALLOWED_ACE) + 
			GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
           (sizeof(ACCESS_ALLOWED_ACE) + 
		   GetLengthSid(pEveryoneSID) - sizeof(DWORD));

    pACLNew = (PACL) LocalAlloc(LPTR, 
		                        cbACL);

    if (!pACLNew) 
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

    InitializeAcl(pACLNew, 
				  cbACL, 
				  ACL_REVISION);

    AddAccessAllowedAce(pACLNew,
                        ACL_REVISION,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                        pAdminsSID);

    AddAccessAllowedAce(pACLNew,
                        ACL_REVISION,
                        FILE_GENERIC_READ,
                        pEveryoneSID);

	//
    // Add the ACL to the security descriptor
	//

    b = SetSecurityDescriptorDacl(pSD, 
		                          TRUE, 
								  pACLNew, 
								  FALSE);

	if(!b)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

    b = SetSecurityDescriptorOwner(pSD, 
		                           pAdminsSID, 
								   TRUE);

	if(!b)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

    b = SetSecurityDescriptorGroup(pSD, 
		                           pAdminsSID, 
								   TRUE);

	if(!b)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

	//
	// Security descriptor blob must be self relative
	//

    b = MakeSelfRelativeSD(pSD, 
		                   outpSD, 
						   &cboutpSD);

    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, 
		                                       cboutpSD);

    if (!outpSD) 
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

    b = MakeSelfRelativeSD(pSD, 
		                   outpSD, 
						   &cboutpSD);

	if(!b)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

	//
    // below this modify pSD to outpSD
	//

	//
    // Apply the new security descriptor to the file
	//

    dwLength = GetSecurityDescriptorLength(outpSD);

	//
    // Apply the new security descriptor to the file
	//
	//
	// Read all the property names. If the property is a flag, then read
	// all the flag names as well.
	//

	a_pv[iMBProperty_Name]        = NULL;
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchema;
	a_pv[iMBProperty_ID]          = &dwMetaIDAdminACL;
    a_pv[iMBProperty_Attributes]  = &dwAttributesAdminACL;
    a_pv[iMBProperty_UserType]    = &dwUserTypeAdminACL;
    a_pv[iMBProperty_Type]        = &dwDataTypeAdminACL;
    a_pv[iMBProperty_Value]       = (LPBYTE)outpSD;

    a_Size[iMBProperty_Value]     = dwLength;

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						NULL,			// We should not be passing crypto object here, if we do it will attempt to decrypt it because the attribute is sucure.
						TRUE);


exit :

	//
    //Cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
	//

    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


/***************************************************************************++

Routine Description:

    Helper function to read construct the Admin ACL.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/
DWORD GetPrincipalSID (LPWSTR Principal,
			           PSID *Sid,
					   BOOL *pbWellKnownSID)
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( wcscmp(Principal,L"Administrators") == 0 ) 
	{
		//
        // Administrators group
		//

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;

    } 
	else if ( wcscmp(Principal,L"System") == 0) 
	{
		//
        // SYSTEM
		//

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;

    } 
	else if ( wcscmp(Principal,L"Interactive") == 0) 
	{
        //
		// INTERACTIVE
		//

        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;

    } 
	else if ( wcscmp(Principal,L"Everyone") == 0) 
	{
        //
		// Everyone
		//

        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;

    } 
	else 
	{
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) 
	{
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        WCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountNameW(NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

		if(NULL == *Sid)
		{
			return E_OUTOFMEMORY;
		}
		else if (!LookupAccountNameW(NULL,
                                     Principal,
                                     *Sid,
                                     &sidSize,
                                     refDomain,
                                     &refDomainSize,
                                     &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Reads the largest metabase id available so far from the schema.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadLargestMetaID(CMDBaseObject*             i_pboRead,
		  				  IIS_CRYPTO_STORAGE*		 i_pStorage)
{
	HRESULT		        hr                  = S_OK;
	DWORD*              pdwLargestID        = NULL;
	DWORD               dwLargestIDDefault  = IIS_MD_ADSI_METAID_BEGIN;

	DWORD               dwMetaIDMetaID      = MD_SCHEMA_METAID;
    DWORD               dwAttributesMetaID  = METADATA_NO_ATTRIBUTES;
    DWORD               dwUserTypeMetaID    = IIS_MD_UT_SERVER;
    DWORD               dwDataTypeMetaID    = DWORD_METADATA;
	ULONG               iCol                = iTABLEMETA_ExtendedVersion;  // Largest ID is stored in this column
	ULONG               iRow                = 0;
	LPWSTR              wszTable            = wszTABLE_IIsConfigObject;

	LPVOID		        a_pv[cMBProperty_NumberOfColumns];
	ULONG		        a_Size[cMBProperty_NumberOfColumns];

	hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
															                         (LPVOID*)&wszTable,
																                     &iRow);

	if(SUCCEEDED(hr))
	{
		hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
			                                                                       1,
											                                       &iCol,
											                                       NULL,
											                                       (LPVOID*)&pdwLargestID);
	}

	if(FAILED(hr))
	{

		DBGINFOW((DBG_CONTEXT,
				  L"[SetLargestMetaID] Unable to read largest meta id from the meta tables. GetColumnValues failed with hr = 0x%x. Will default it to %d.\n", 
				  hr,
				  dwLargestIDDefault));

		hr = S_OK;

		pdwLargestID = &dwLargestIDDefault;
	}

	a_pv[iMBProperty_Name]        = NULL;
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchema;
	a_pv[iMBProperty_ID]          = &dwMetaIDMetaID;
    a_pv[iMBProperty_Attributes]  = &dwAttributesMetaID;
    a_pv[iMBProperty_UserType]    = &dwUserTypeMetaID;
    a_pv[iMBProperty_Type]        = &dwDataTypeMetaID;
    a_pv[iMBProperty_Value]       = (LPBYTE)pdwLargestID;

    a_Size[iMBProperty_Value]     = sizeof(DWORD);

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);


	return hr;

}


/***************************************************************************++

Routine Description:

    Reads the properties into the schema tree.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadProperties(IIS_CRYPTO_STORAGE*		i_pStorage,
	   	   			   FILETIME*				i_pFileTime)
{
	HRESULT             hr                  = S_OK;
    CMDBaseObject*      pboReadProperties   = NULL;
    CMDBaseObject*      pboReadNames        = NULL;
    CMDBaseObject*      pboReadTypes        = NULL;
    CMDBaseObject*      pboReadDefaults     = NULL;
	ULONG               i                   = 0;
	ULONG               iColIndex           = 0;
	LPVOID              a_Identity[]        = {(LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject,
											   (LPVOID)&iColIndex
	};
	LPWSTR              wszTable            = NULL;
	LPVOID	            a_pv[cCOLUMNMETA_NumberOfColumns];
	ULONG	            a_Size[cCOLUMNMETA_NumberOfColumns];
	ULONG	            a_iCol[] = {iCOLUMNMETA_Table,
						            iCOLUMNMETA_Index,  
						            iCOLUMNMETA_InternalName,
						            iCOLUMNMETA_Type,
            			            iCOLUMNMETA_MetaFlags,
			            			iCOLUMNMETA_SchemaGeneratorFlags,
            						iCOLUMNMETA_DefaultValue,
                                    iCOLUMNMETA_StartingNumber,
                                    iCOLUMNMETA_EndingNumber,
						            iCOLUMNMETA_ID,  
						            iCOLUMNMETA_UserType,  
						            iCOLUMNMETA_Attributes  
	                                };
	ULONG	            cCol = sizeof(a_iCol)/sizeof(ULONG);

	//
	// Initialize all the meta objects.
	//

	hr = ReadMetaObject(pboReadProperties,
						(LPWSTR)g_wszSlashSchemaSlashProperties,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = ReadMetaObject(pboReadNames,
						(LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = ReadMetaObject(pboReadTypes,
						(LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = ReadMetaObject(pboReadDefaults,
						(LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Get the row index of the first column and then iterate thru the table until
	// e_st_nomorerows or the table difffers
	//

	hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
																	 a_Identity,
																	 &i);

	if(FAILED(hr))
	{
		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
		}
		goto exit;
	}

	//
	// For each property in this table, construct the name, type and default 
	// in the metabase tree
	//

	for(;;i++)
	{
		hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
			                                                       cCol,
											                       a_iCol,
											                       a_Size,
											                       a_pv);


		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			goto exit;
		}
		
		if(NULL == wszTable)
		{
			wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
		}

		if(wszTable != (LPWSTR)a_pv[iCOLUMNMETA_Table])
		{
			//
			// reached another table break
			//
			break;
		}

		MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

		if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
		{
			//
			// Do not read hidden properties. All these properties have the 
			// "HIDDEN" schemagenerator flag set on them.
			//
			continue;
		}

		hr = ReadPropertyNames(pboReadNames,
			                   a_pv,
			                   a_Size,
							   i_pStorage);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = ReadPropertyTypes(pboReadTypes,
			                   a_pv,
			                   a_Size,
							   i_pStorage);

		if(FAILED(hr))
		{
			goto exit;
		}

		if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
		{
			hr = ReadAllFlags(i_pStorage,
			                  pboReadTypes,
							  pboReadNames,
							  pboReadDefaults,
							  *(DWORD*)a_pv[iCOLUMNMETA_Index],
			                  *(DWORD*)a_pv[iCOLUMNMETA_ID],
							  GetMetabaseFlags(*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]),
			                  *(DWORD*)a_pv[iCOLUMNMETA_Attributes],
			                  *(DWORD*)a_pv[iCOLUMNMETA_UserType],
							  (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MULTISTRING);

			if(FAILED(hr))
			{
				goto exit;
			}
		}	 

		hr = ReadPropertyDefaults(pboReadDefaults,
			                      a_pv,
			                      a_Size,
								  i_pStorage);

		if(FAILED(hr))
		{
			goto exit;
		}

	}


exit:

	return hr;
	
} // ReadProperties


/***************************************************************************++

Routine Description:

    Reads names of properties into the schema.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Array that hold catalog schema information about the property.
	[in]  Array that holds count of bytes for the above.
	[in]  Storage pointer.
	

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyNames(CMDBaseObject*			i_pboRead,
						  LPVOID*					i_apv,
						  ULONG*					i_aSize,
			   			  IIS_CRYPTO_STORAGE*		i_pStorage)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
	DWORD       dwType       = STRING_METADATA;
	DWORD       dwUserType   = IIS_MD_UT_SERVER;

	//
	// Read all the property names. If the property is a flag, then read
	// all the flag names as well.
	//

	a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames;
	a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = i_apv[iCOLUMNMETA_InternalName];

    a_Size[iMBProperty_Value]     = i_aSize[iCOLUMNMETA_InternalName];

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	//
	// TODO: If the property is a flag then read all the flag names as well.
	//

	return hr;

} // ReadPropertyNames


/***************************************************************************++

Routine Description:

    Reads names of flags into the schema.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Array that hold catalog schema information about the flags.
	[in]  Array that holds count of bytes for the above.
	[in]  Storage pointer.
	

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagNames(CMDBaseObject*			i_pboRead,
					  LPVOID*					i_apv,
					  ULONG*					i_aSize,
			   		  IIS_CRYPTO_STORAGE*		i_pStorage)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
	DWORD       dwType       = STRING_METADATA;
	DWORD       dwUserType   = IIS_MD_UT_SERVER;

	//
	// Read all the property names. If the property is a flag, then read
	// all the flag names as well.
	//

	a_pv[iMBProperty_Name]        = i_apv[iTAGMETA_InternalName];
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashNames;
	a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = i_apv[iTAGMETA_InternalName];

    a_Size[iMBProperty_Value]     = i_aSize[iTAGMETA_InternalName];

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	//
	// TODO: If the property is a flag then read all the flag names as well.
	//

	return hr;

} // ReadFlagNames


/***************************************************************************++

Routine Description:

    Reads type information about the properties into the schema.

Arguments:

	[in]  Pointer to the metabase object.
	[in]  Array that hold catalog schema information about the property.
	[in]  Array that holds count of bytes for the above.
	[in]  Storage pointer.
	

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyTypes(CMDBaseObject*			i_pboRead,
						  LPVOID*					i_apv,
						  ULONG*					i_aSize,
			   			  IIS_CRYPTO_STORAGE*		i_pStorage)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
	DWORD       dwType       = BINARY_METADATA;
	DWORD       dwUserType   = IIS_MD_UT_SERVER;
	PropValue   propVal;
	DWORD       dwMetaFlagsEx = *(DWORD*)(i_apv[iCOLUMNMETA_SchemaGeneratorFlags]);

	memset(&propVal, 0, sizeof(PropValue));

	//
	// Read all the property type. If the property is a flag, then read
	// all the type for the flag names as well.
	//

    propVal.dwMetaID          = *(DWORD*)(i_apv[iCOLUMNMETA_ID]);
    propVal.dwPropID          = *(DWORD*)(i_apv[iCOLUMNMETA_ID]);						// TODO: This is different from the meta id if it is a flag.
    propVal.dwSynID           = SynIDFromMetaFlagsEx(dwMetaFlagsEx);	
    propVal.dwMetaType        = GetMetabaseType(*(DWORD*)(i_apv[iCOLUMNMETA_Type]),
		                                        *(DWORD*)(i_apv[iCOLUMNMETA_MetaFlags]));

	if(DWORD_METADATA == propVal.dwMetaType)
	{
	    propVal.dwMinRange        = *(DWORD*)(i_apv[iCOLUMNMETA_StartingNumber]);  
		propVal.dwMaxRange        = *(DWORD*)(i_apv[iCOLUMNMETA_EndingNumber]);    
	}
	else
	{
		// 
		// TODO: Ensure that non-DWORDs have no starting/ending numbers
		//

	    propVal.dwMinRange        = 0;  
		propVal.dwMaxRange        = 0;    
	}

    propVal.dwFlags           = GetMetabaseFlags(*(DWORD*)i_apv[iCOLUMNMETA_SchemaGeneratorFlags]);
    propVal.dwMask            = 0;														// TODO: This gets filled in for flag values only.
    propVal.dwMetaFlags       = *(DWORD*)(i_apv[iCOLUMNMETA_Attributes]);
    propVal.dwUserGroup       = *(DWORD*)(i_apv[iCOLUMNMETA_UserType]);
    propVal.fMultiValued      = ((*(DWORD*)i_apv[iCOLUMNMETA_MetaFlags])&fCOLUMNMETA_MULTISTRING)?1:0;	// TODO: Ensure that this gets set in the schema as multivalued
    propVal.dwDefault         = 0;
    propVal.szDefault         = NULL;

	a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes;
	a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = (LPVOID)&propVal;

    a_Size[iMBProperty_Value]     = sizeof(PropValue);

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	//
	// TODO: If the property is a flag then read all the flag names as well.
	//

	return hr;

} // ReadPropertyTypes


/***************************************************************************++

Routine Description:

    Reads all flag properties into the schema.

Arguments:

	[in]  Storage pointer.
	[in]  Pointer to the metabase object that holds the types tree.
	[in]  Pointer to the metabase object that holds the names tree.
	[in]  Pointer to the metabase object that holds the default value tree.
	[in]  Column index of the parent flag property.
	[in]  Meta Id of the parent flag property.
	[in]  Flags of the parent flag property.
	[in]  Attribute of the parent flag property.
	[in]  Usertype of the parent flag property.
	[in]  Multivalued attribute of the parent flag property.	

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadAllFlags(IIS_CRYPTO_STORAGE*		i_pStorage,
					 CMDBaseObject*				i_pboReadType,
					 CMDBaseObject*				i_pboReadName,
					 CMDBaseObject*				i_pboReadDefault,
					 DWORD						i_dwColumnIndex,
					 DWORD						i_dwMetaID,
					 DWORD						i_dwFlags,
					 DWORD						i_dwAttributes,
					 DWORD						i_dwUserType,
					 DWORD						i_dwMultivalued)
{
	ULONG       i                = 0;
	ULONG       iStartRow        = 0;
	HRESULT     hr               = S_OK; 
	LPVOID		a_pvSearch[cTAGMETA_NumberOfColumns];
	ULONG		aColSearch[]	 = {iTAGMETA_Table,
								    iTAGMETA_ColumnIndex
									};
	ULONG		cColSearch		 = sizeof(aColSearch)/sizeof(ULONG);
	LPWSTR      wszTable         = NULL;


	a_pvSearch[iTAGMETA_Table] = g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject;
	a_pvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&i_dwColumnIndex;

	hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow,
		                                                                             cColSearch,
																					 aColSearch,
																					 NULL,
																					 a_pvSearch,
																					 &iStartRow);

	if(E_ST_NOMOREROWS == hr)
	{
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[ReadAllFlags] Unable to read flags. GetRowIndexBySearch failed with hr = 0x%x.\n",
				  hr));
		goto exit;
	}


	for(i=iStartRow;;i++)
	{

		LPVOID	a_pv[cTAGMETA_NumberOfColumns];
		ULONG	a_Size[cTAGMETA_NumberOfColumns];
		ULONG	a_iCol[] = {iTAGMETA_Table,
						    iTAGMETA_ColumnIndex,
						    iTAGMETA_InternalName,
							iTAGMETA_Value,
							iTAGMETA_ID
							};
		ULONG	cCol = sizeof(a_iCol)/sizeof(ULONG);

		hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(i,
			                                                                         cCol,
									                                                 a_iCol,
										                                             a_Size,
										                                             a_pv);

		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			goto exit;
		}

		if(NULL == wszTable)
		{
			// Save the table name from the read cache so that you can do a pointer compare below.
			wszTable = (LPWSTR)a_pv[iTAGMETA_Table];
		}

		if((wszTable != a_pv[iTAGMETA_Table]) || 
			(i_dwColumnIndex != *(DWORD*)a_pv[iTAGMETA_ColumnIndex])
		  )
		{
			//
			// Done with all tags of this column, in this table hence exit.
			//

			goto exit;

		}

		hr = ReadFlagTypes(i_pboReadType,
						   i_pStorage,
						   i_dwMetaID,
						   i_dwFlags,
						   i_dwAttributes,
						   i_dwUserType,
						   i_dwMultivalued,
						   a_pv,
						   a_Size);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = ReadFlagNames(i_pboReadName,
						   a_pv,
						   a_Size,
						   i_pStorage);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = ReadFlagDefaults(i_pboReadDefault,
						      a_pv,
						      a_Size,
						      i_pStorage);

		if(FAILED(hr))
		{
			goto exit;
		}

	}

exit:

	return hr;

} // ReadAllFlagTypes


/***************************************************************************++

Routine Description:

    Reads all flag type information into the schema.

Arguments:

	[in]  Pointer to the metabase object that holds the types tree.
	[in]  Storage pointer.
	[in]  Meta Id of the parent flag property.
	[in]  Flags of the parent flag property.
	[in]  Attribute of the parent flag property.
	[in]  Usertype of the parent flag property.
	[in]  Multivalued attribute of the parent flag property.	
	[in]  Array that hold catalog schema information about the flag.
	[in]  Array that holds count of bytes for the above.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagTypes(CMDBaseObject*			i_pboRead,
		   			  IIS_CRYPTO_STORAGE*		i_pStorage,
					  DWORD						i_dwMetaID,
					  DWORD						i_dwFlags,
					  DWORD						i_dwAttributes,
					  DWORD						i_dwUserType,
					  DWORD						i_dwMultivalued,
					  LPVOID*					i_apv,
					  ULONG*					i_aSize)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
	DWORD       dwType       = BINARY_METADATA;
	DWORD       dwUserType   = IIS_MD_UT_SERVER;
	PropValue   propVal;
	DWORD       dwFlagSynID  = IIS_SYNTAX_ID_BOOL_BITMASK;
	DWORD       dwFlagType	 = DWORD_METADATA;

	memset(&propVal, 0, sizeof(PropValue));

	//
	// Read all the property type. If the property is a flag, then read
	// all the type for the flag names as well.
	//

    propVal.dwMetaID          = i_dwMetaID;
    propVal.dwPropID          = *(DWORD*)(i_apv[iTAGMETA_ID]);					// TODO: This is different from the meta id if it is a flag.
    propVal.dwSynID           = dwFlagSynID;	
    propVal.dwMetaType        = dwFlagType;				

	propVal.dwMaxRange        = 0;												// TODO: Check if OK for flags
	propVal.dwMinRange        = 0;												// TODO: Check if OK for flags
	
    propVal.dwFlags           = i_dwFlags;										// TODO: Check if OK set to parent prop flags
    propVal.dwMask            = *(DWORD*)(i_apv[iTAGMETA_Value]);				// TODO: Check if OK set to parent prop flags
    propVal.dwMetaFlags       = i_dwAttributes;									// TODO: Check if OK set to parent prop flags
    propVal.dwUserGroup       = i_dwUserType;									// TODO: Check if OK set to parent prop flags
    propVal.fMultiValued      = i_dwMultivalued;								// TODO: Ensure that this gets set in the schema as multivalued
    propVal.dwDefault         = 0;
    propVal.szDefault         = NULL;

	a_pv[iMBProperty_Name]        = NULL;
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashTypes;
	a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = (LPVOID)&propVal;

    a_Size[iMBProperty_Value]     = sizeof(PropValue);

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	//
	// TODO: If the property is a flag then read all the flag names as well.
	//

	return hr;

} // ReadFlagTypes


/***************************************************************************++

Routine Description:

    Reads property defaults into the schema.

Arguments:

	[in]  Pointer to the metabase object that holds property defaults.
	[in]  Array that hold catalog schema information about the property.
	[in]  Array that holds count of bytes for the above.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadPropertyDefaults(CMDBaseObject*			i_pboRead,
						     LPVOID*				i_apv,
						     ULONG*					i_aSize,
	 		   			     IIS_CRYPTO_STORAGE*	i_pStorage)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwType       = GetMetabaseType(*(DWORD*)i_apv[iCOLUMNMETA_Type],
											   *(DWORD*)i_apv[iCOLUMNMETA_MetaFlags]);
	LPVOID      pvValue      = NULL;
	ULONG       cbSize       = NULL;
	DWORD       dwZero       = 0;
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;

	//
	// Read all the property names. If the property is a flag, then read
	// all the flag names as well.
	//

	a_pv[iMBProperty_Name]        = i_apv[iCOLUMNMETA_InternalName];
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults;
	a_pv[iMBProperty_ID]          = i_apv[iCOLUMNMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;					//  NO_ATTRIBUTES since it will attempt to decrypt.
    a_pv[iMBProperty_UserType]    = i_apv[iCOLUMNMETA_UserType];
    a_pv[iMBProperty_Type]        = &dwType;

	//
	// TODO: Ask Stephen to add extra null terminator for the multisz defaults.
	//       Also for null string defaults ask to add empty strings
	//
	if((dwType == DWORD_METADATA) && (NULL == i_apv[iCOLUMNMETA_DefaultValue]))
	{
		pvValue = &dwZero;
		cbSize = sizeof(DWORD);
	}
	else if(((dwType == MULTISZ_METADATA) || (dwType == STRING_METADATA) || (dwType == EXPANDSZ_METADATA)) &&
	        ((NULL == i_apv[iCOLUMNMETA_DefaultValue]) || (0 == *(BYTE*)(i_apv[iCOLUMNMETA_DefaultValue])))
	       )
	{
		if(dwType == MULTISZ_METADATA)
		{
			pvValue = g_wszEmptyMultisz;
			cbSize = g_cchEmptyMultisz * sizeof(WCHAR);
		}
		else if((dwType == STRING_METADATA) || (dwType == EXPANDSZ_METADATA))
		{
			pvValue = g_wszEmptyWsz;
			cbSize = g_cchEmptyWsz * sizeof(WCHAR);
		}
	}
	else
	{
	    pvValue    = i_apv[iCOLUMNMETA_DefaultValue];
		cbSize     = i_aSize[iCOLUMNMETA_DefaultValue];
	}

	a_pv[iMBProperty_Value]       = pvValue;
	a_Size[iMBProperty_Value]     = cbSize;

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	//
	// TODO: If the property is a flag then read all the flag names as well.
	//

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[ReadPropertyDefaults] Could not read property %s:%d.\npv=%d.\ncb=%d.\n", 
				  i_apv[iCOLUMNMETA_InternalName],
				  *(DWORD*)i_apv[iCOLUMNMETA_ID],
				  pvValue,
				  cbSize));

		if(NULL != pvValue)
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[ReadPropertyDefaults]*pv=%d.\n", 
					  *(WORD*)pvValue));

		}
	}

	return hr;

} // ReadPropertyDefaults


/***************************************************************************++

Routine Description:

    Reads all flag defaults into the schema.

Arguments:

	[in]  Pointer to the metabase object that holds the defaults.
	[in]  Array that hold catalog schema information about the flag.
	[in]  Array that holds count of bytes for the above.
	[in]  Storage pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadFlagDefaults(CMDBaseObject*			i_pboRead,
					     LPVOID*				i_apv,
					     ULONG*					i_aSize,
			   		     IIS_CRYPTO_STORAGE*	i_pStorage)
{
	HRESULT		hr           = S_OK;
	LPVOID		a_pv[cMBProperty_NumberOfColumns];
	ULONG		a_Size[cMBProperty_NumberOfColumns];
	DWORD       dwAttributes = METADATA_NO_ATTRIBUTES;
	DWORD       dwType       = DWORD_METADATA;

	//
	// TODO: Should we assign the User Type of the parent property?
	//

	DWORD       dwUserType   = IIS_MD_UT_SERVER; 

	//
	// TODO: Is this a correct assumption? I noticed that default values for 
	// flags was being set to 0 or -1. This doesnt make any sense. How can a 
	// flag have a default value other than its own value? This is not 
	//captured in our new schema, so just putting it as 0.
	//

	DWORD       dwFlagDefaults = 0;				 

	//
	// Read all the property names. If the property is a flag, then read
	// all the flag names as well.
	//

	a_pv[iMBProperty_Name]        = i_apv[iTAGMETA_InternalName];
	a_pv[iMBProperty_Location]    = (LPWSTR)g_wszSlashSchemaSlashPropertiesSlashDefaults;
	a_pv[iMBProperty_ID]          = i_apv[iTAGMETA_ID];
    a_pv[iMBProperty_Attributes]  = &dwAttributes;
    a_pv[iMBProperty_UserType]    = &dwUserType;
    a_pv[iMBProperty_Type]        = &dwType;
    a_pv[iMBProperty_Value]       = &dwFlagDefaults;

    a_Size[iMBProperty_Value]     = sizeof(DWORD);

	hr = ReadDataObject(i_pboRead,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	return hr;

} // ReadFlagDefaults


/***************************************************************************++

Routine Description:

    Reads all classes into the schema.

Arguments:

    [in]  Storage pointer.
	[in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadClasses(IIS_CRYPTO_STORAGE*		i_pStorage,
   	   			    FILETIME*				i_pFileTime)
{
	HRESULT             hr              = S_OK;
    CMDBaseObject*      pboReadClasses  = NULL;
	ULONG               i               = 0;
	LPVOID	            a_pv[cTABLEMETA_NumberOfColumns];
	ULONG	            a_Size[cTABLEMETA_NumberOfColumns];
	ULONG	            a_iCol[]        = {iTABLEMETA_InternalName,
						                   iTABLEMETA_MetaFlags,
						                   iTABLEMETA_SchemaGeneratorFlags,
		                                   iTABLEMETA_ContainerClassList
	};
	ULONG	            cCol = sizeof(a_iCol)/sizeof(ULONG);
		
	hr = ReadMetaObject(pboReadClasses,
						(LPWSTR)g_wszSlashSchemaSlashClasses,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	for(i=0;;i++)
	{
		hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(i,
			                                                                       cCol,
										                                           a_iCol,
											                                       a_Size,
											                                       a_pv);

		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			goto exit;
		}

		MD_ASSERT(NULL != (DWORD*)a_pv[iTABLEMETA_MetaFlags]);

		if(fTABLEMETA_HIDDEN == (fTABLEMETA_HIDDEN & (*(DWORD*)a_pv[iTABLEMETA_MetaFlags])))
		{
			//
			// Do not read hidden classes. All these classes have the "HIDDEN" MetaFlag set on them.
			// Eg: IIsConfigObject,MetabaseBaseClass, MBProperty, MBPropertyDiff, IIsInheritedProperties
			//
			continue;
		}

		hr = ReadClass(a_pv,
			           a_Size,
					   i_pStorage,
					   i_pFileTime);

		if(FAILED(hr))
		{
			//
			// TODO: Save hr and continue.
			//

			DBGINFOW((DBG_CONTEXT,
					  L"[ReadClasses] Could not read information for class: %s.\nReadClass failed with hr=0x%x.\n", 
					  a_pv[iTABLEMETA_InternalName],
                      hr));
		}

	}

exit:

	return hr;

} // ReadClasses


/***************************************************************************++

Routine Description:

    Reads a class into the schema.

Arguments:

	[in]  Array that hold catalog schema information about the class.
	[in]  Array that holds count of bytes for the above.
    [in]  Storage pointer.
	[in]  Filetime pointer.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReadClass(LPVOID*					i_apv,
				  ULONG*					i_aSize,
			      IIS_CRYPTO_STORAGE*		i_pStorage,
 	   			  FILETIME*					i_pFileTime)
{
	HRESULT		        hr				= S_OK;
    CMDBaseObject*	    pboReadClass	= NULL;
	WCHAR               wszClassPathFixed[MAX_PATH];
	ULONG               cchClassPath    = 0;
	WCHAR*              wszClassPath    = wszClassPathFixed;
	WCHAR*              wszEnd          = NULL;
	ULONG				cchClassName    = wcslen((LPWSTR)i_apv[iTABLEMETA_InternalName]);
	DWORD               dwID            = 0;
	DWORD				dwType          = DWORD_METADATA;
	DWORD				dwUserType      = IIS_MD_UT_SERVER;
	DWORD				dwAttributes    = METADATA_NO_ATTRIBUTES;
	DWORD				dwValue		    = 0;
	LPVOID				a_pv[cMBProperty_NumberOfColumns];
	ULONG				a_Size[cMBProperty_NumberOfColumns];
	LPWSTR				wszManditory    = NULL;
	LPWSTR				wszOptional		= NULL;
	
	//
	// Construct the ClassPath and read the meta object.
	//

	cchClassPath = g_cchSlashSchemaSlashClasses + 
				   g_cchSlash				   +			
	               cchClassName;

	if((cchClassPath + 1) > MAX_PATH)
	{
		wszClassPath = new WCHAR[cchClassPath + 1];
		if(NULL == wszClassPath)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}

	wszEnd = wszClassPath;
	memcpy(wszEnd, g_wszSlashSchemaSlashClasses, g_cchSlashSchemaSlashClasses*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchSlashSchemaSlashClasses;
	memcpy(wszEnd, g_wszSlash, g_cchSlash*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchSlash;
	memcpy(wszEnd, i_apv[iTABLEMETA_InternalName], cchClassName*sizeof(WCHAR));
	wszEnd = wszEnd + cchClassName;
	*wszEnd = L'\0';

	hr = ReadMetaObject(pboReadClass,
						wszClassPath,
						i_pFileTime,
						TRUE);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[ReadClasses] ReadMetaObject for class: %s failed with hr=0x%x.\n", 
				  wszClassPath,
                  hr));
		goto exit;
	}
	
	//
	// Initialize a_pv to write data objects
	//

	a_pv[iMBProperty_Name]				= NULL;
	a_pv[iMBProperty_ID]				= &dwID;
	a_pv[iMBProperty_Location]			= wszClassPath;
    a_pv[iMBProperty_Attributes]		= &dwAttributes;
    a_pv[iMBProperty_UserType]			= &dwUserType;
    a_pv[iMBProperty_Type]				= &dwType;

	//
	// Read the data object that corresponds to container class property
	//

	dwID						= MD_SCHEMA_CLASS_CONTAINER;
	dwType						= DWORD_METADATA;
	dwValue                     = ((*(DWORD*)(i_apv[iTABLEMETA_SchemaGeneratorFlags])) & fTABLEMETA_CONTAINERCLASS)?1:0; // TODO: Need to set true or false.
    a_pv[iMBProperty_Value]		= &dwValue;
    a_Size[iMBProperty_Value]	= sizeof(DWORD);

	hr = ReadDataObject(pboReadClass,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[ReadClasses] ReadDataObject for class: %s, property: Container failed with hr=0x%x.\n", 
				  wszClassPath,
                  hr));
		goto exit;
	}

	//
	// Read the data object that corresponds to container class list property
	//

	dwID						= MD_SCHEMA_CLASS_CONTAINMENT;
	dwType						= STRING_METADATA;

	if(NULL == i_apv[iTABLEMETA_ContainerClassList])
	{
	    a_pv[iMBProperty_Value]		= g_wszEmptyWsz;							// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (g_cchEmptyWsz)*sizeof(WCHAR);	
	}
	else
	{
	    a_pv[iMBProperty_Value]		= i_apv[iTABLEMETA_ContainerClassList];	// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (wcslen((LPWSTR)i_apv[iTABLEMETA_ContainerClassList])+1)*sizeof(WCHAR);
	}

	hr = ReadDataObject(pboReadClass,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Read properties for this class.
	//

	hr = GetProperties((LPCWSTR)i_apv[iTABLEMETA_InternalName],
					   &wszOptional,
					   &wszManditory);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Read data object that corresponds to optional property list
	//

	dwID						= MD_SCHEMA_CLASS_OPT_PROPERTIES;
	dwType						= STRING_METADATA;

	if(NULL == wszOptional)
	{
	    a_pv[iMBProperty_Value]		= g_wszEmptyWsz;							// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (g_cchEmptyWsz)*sizeof(WCHAR);	
	}
	else
	{
	    a_pv[iMBProperty_Value]		= wszOptional;	// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (wcslen(wszOptional)+1)*sizeof(WCHAR);
	}

//	DBGINFOW((DBG_CONTEXT,
//			  L"[ReadClasses] Class: %s has Optional Properties: %s.\n", 
//			  wszClassPath,
//            a_pv[iMBProperty_Value]));

	hr = ReadDataObject(pboReadClass,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Read data object that corresponds to maditory property list
	//

	dwID						= MD_SCHEMA_CLASS_MAND_PROPERTIES;
	dwType						= STRING_METADATA;

	if(NULL == wszManditory)
	{
	    a_pv[iMBProperty_Value]		= g_wszEmptyWsz;							// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (g_cchEmptyWsz)*sizeof(WCHAR);	
	}
	else
	{
	    a_pv[iMBProperty_Value]		= wszManditory;	// TODO: Need to verify
		a_Size[iMBProperty_Value]	= (wcslen(wszManditory)+1)*sizeof(WCHAR);
	}


//	DBGINFOW((DBG_CONTEXT,
//			  L"[ReadClasses] Class: %s has Manditory Properties: %s.\n", 
//			  wszClassPath,
//            a_pv[iMBProperty_Value]));

	hr = ReadDataObject(pboReadClass,
					    a_pv,
						a_Size,
						i_pStorage,
						TRUE);

	if(FAILED(hr))
	{
		goto exit;
	}

exit:
	
	if(wszClassPathFixed != wszClassPath)
	{
		delete [] wszClassPath;
		wszClassPath = NULL;
	}

	if(NULL != wszManditory)
	{
		delete [] wszManditory;
		wszManditory = NULL;
	}

	if(NULL != wszOptional)
	{
		delete [] wszOptional;
		wszOptional = NULL;
	}

	return hr;

} // ReadClasses


/***************************************************************************++

Routine Description:

    Given a class it constructs the optional and manditory property lists

Arguments:

	[in]  Class name.
	[out] Optional properties.
	[out] Manditory properties.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetProperties(LPCWSTR					i_wszTable,
                      LPWSTR*					o_pwszOptional,
					  LPWSTR*					o_pwszManditory)
{

	HRESULT				hr				= S_OK;
	LPVOID				a_pv[cCOLUMNMETA_NumberOfColumns];
	ULONG				a_iCol[]		= { iCOLUMNMETA_Table,
											iCOLUMNMETA_InternalName,
											iCOLUMNMETA_Index,
											iCOLUMNMETA_MetaFlags,
											iCOLUMNMETA_SchemaGeneratorFlags,
											iCOLUMNMETA_ID
										  };
	ULONG				cCol			= sizeof(a_iCol)/sizeof(ULONG);
	WCHAR*				wszEndOpt       = NULL;
	WCHAR*				wszEndMand      = NULL;
	STQueryCell			QueryCell[2];
	ULONG				cCell		    = sizeof(QueryCell)/sizeof(STQueryCell);
	ULONG               cchOptional     = 0;
	ULONG               cchManditory    = 0;
	ULONG               iColIndex       = 0;
	LPVOID              a_Identity[]    = {(LPVOID)i_wszTable,
										   (LPVOID)&iColIndex
	};
	LPWSTR              wszTable        = NULL;
	ULONG               iStartRow       = 0;
	ULONG               i               = 0;
                      
	MD_ASSERT(NULL != o_pwszOptional);
	MD_ASSERT(NULL != o_pwszManditory);

	*o_pwszOptional = NULL;
	*o_pwszManditory   = NULL;

	//
	// Get the row index of the first column and then iterate thru the table until
	// e_st_nomorerows or the table difffers
	//

	hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
																	 a_Identity,
																	 &iStartRow);

	if(FAILED(hr))
	{
		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
		}
		goto exit;
	}

	//
	// Count the optional and maditory property lengths.
	//

	for(i=iStartRow;;i++)
	{
		ULONG*	pcCh = NULL;
		 
		hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
		                                                           cCol,
											                       a_iCol,
											                       NULL,
											                       a_pv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[GetProperties] GetColumnValues (count) failed with hr = 0x%x. Index: %d\n", 
					  hr, i));
			goto exit;
		}

		if(NULL == wszTable)
		{
			// Save the table name from the read cache so that you can do a pointer compare below.
			wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
		}

		if(wszTable != a_pv[iCOLUMNMETA_Table])
		{
			//
			// reached another table break
			//
			break;
		}

		if(MD_LOCATION == *(DWORD*)a_pv[iCOLUMNMETA_ID])
		{
			//
			// Do NOT read in the location property.
			//

			continue;
		}

		MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

		if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
		{
			//
			// Do not read hidden properties. All these properties have the 
			// "HIDDEN" schemagenerator flag set on them.
			//
			continue;
		}

		if((*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MANDATORY)
		{
			cchManditory = cchManditory + wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]) + 1 ; // For comma
			pcCh = &cchManditory;
		}
		else
		{
			cchOptional = cchOptional + wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]) + 1; // For comma
			pcCh = &cchOptional;
		}

		if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
		{
			hr = AddFlagValuesToPropertyList((LPWSTR)i_wszTable,
				                             *(DWORD*)a_pv[iCOLUMNMETA_Index],
											 pcCh,
											 NULL);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[GetProperties] AddFlagValuesToPropertyList for %s:%s failed with hr = 0x%x.\n",
						  i_wszTable,
						  a_pv[iCOLUMNMETA_InternalName],
						  hr
						  ));
				goto exit;
			}
				                             
		}

	}

	if(cchManditory > 0)
	{
		*o_pwszManditory = new WCHAR[cchManditory+1];
		if(NULL == *o_pwszManditory)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		**o_pwszManditory = 0;
		wszEndMand = *o_pwszManditory;
	}

	if(cchOptional > 0)
	{
		*o_pwszOptional = new WCHAR[cchOptional+1];
		if(NULL == *o_pwszOptional)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		**o_pwszOptional= 0;
		wszEndOpt = *o_pwszOptional;
	}

	//
	// Count the optional and maditory property lengths.
	//

	wszTable = NULL;

	for(i=iStartRow; ;i++)
	{
		ULONG	cchName = 0;
		LPWSTR*	pwszPropertyList = NULL;

		hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(i,
																   cCol,
											 					   a_iCol,
											 					   NULL,
											 					   a_pv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[GetProperties] GetColumnValues (copy) failed with hr = 0x%x. Index: %d\n", 
					  hr, i));
			goto exit;
		}

		if(NULL == wszTable)
		{
			// Save the table name from the read cache so that you can do a pointer compare below.
			wszTable = (LPWSTR)a_pv[iCOLUMNMETA_Table];
		}

		if(wszTable != a_pv[iCOLUMNMETA_Table])
		{
			//
			// reached another table break
			//
			break;
		}

		if(MD_LOCATION == *(DWORD*)a_pv[iCOLUMNMETA_ID])
		{
			//
			// Do NOT read in the location property.
			//

			continue;
		}

		MD_ASSERT(NULL != (DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]);

		if(fCOLUMNMETA_HIDDEN == (fCOLUMNMETA_HIDDEN & (*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags])))
		{
			//
			// Do not read hidden properties. All these properties have the 
			// "HIDDEN" schemagenerator flag set on them.
			//
			continue;
		}

		cchName = wcslen((LPWSTR)a_pv[iCOLUMNMETA_InternalName]);


		if((*(DWORD*)a_pv[iCOLUMNMETA_SchemaGeneratorFlags]) & fCOLUMNMETA_MANDATORY)
		{
            MD_ASSERT(wszEndMand != NULL);
			memcpy(wszEndMand, a_pv[iCOLUMNMETA_InternalName],  cchName*sizeof(WCHAR));
			wszEndMand = wszEndMand + cchName;
			memcpy(wszEndMand, g_wszComma,  g_cchComma*sizeof(WCHAR));
			wszEndMand = wszEndMand + g_cchComma;
			pwszPropertyList = &wszEndMand;
		}
		else
		{
            MD_ASSERT(wszEndOpt != NULL);
			memcpy(wszEndOpt, a_pv[iCOLUMNMETA_InternalName], cchName*sizeof(WCHAR));
			wszEndOpt = wszEndOpt + cchName;
			memcpy(wszEndOpt, g_wszComma,  g_cchComma*sizeof(WCHAR));
			wszEndOpt = wszEndOpt + g_cchComma;
			pwszPropertyList = &wszEndOpt;
		}

		if((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
		{
			LPWSTR wszTest = *pwszPropertyList;

			hr = AddFlagValuesToPropertyList((LPWSTR)i_wszTable,
				                             *(DWORD*)a_pv[iCOLUMNMETA_Index],
											 NULL,
											 pwszPropertyList);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[GetProperties] AddFlagValuesToPropertyList for %s:%s failed with hr = 0x%x.\n",
						  i_wszTable,
						  a_pv[iCOLUMNMETA_InternalName],
						  hr
						  ));
				goto exit;
			}				                             
		}

	}

	if(cchManditory > 0)
	{
		wszEndMand--;
		*wszEndMand = L'\0';
	}

	if(cchOptional > 0)
	{
		wszEndOpt--;
		*wszEndOpt = L'\0';
	}

exit:
	
	return hr;

} // GetProperties


/***************************************************************************++

Routine Description:

    Adds the flag values to the (optional or manditory) property lists

Arguments:

	[in]  Class name.
	[in]  index
	[out] Count of chars.
	[in out] Property list with all flag values added to it.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT AddFlagValuesToPropertyList(LPWSTR					i_wszTable,
				                    ULONG					i_dwIndex,
									ULONG*					io_pcCh,
									LPWSTR*					io_pwszPropertyList)
{

	ULONG				a_iCol[]		= { iTAGMETA_InternalName,
											iTAGMETA_ColumnIndex,
											iTAGMETA_Table
										  };
	ULONG				cCol			= sizeof(a_iCol)/sizeof(ULONG);
	LPVOID				a_pv[cTAGMETA_NumberOfColumns];

	ULONG				aColSearchTag[] = {iTAGMETA_Table,
										   iTAGMETA_ColumnIndex
											};
	ULONG				cColSearchTag   = sizeof(aColSearchTag)/sizeof(ULONG);
	ULONG               iStartRow       = 0;
	LPWSTR              wszEnd          = NULL;
	HRESULT             hr              = S_OK;
	LPWSTR              wszTable        = NULL;

	if(NULL != io_pwszPropertyList && NULL != *io_pwszPropertyList)
	{
		wszEnd = *io_pwszPropertyList;
	}

	a_pv[iTAGMETA_Table]       = i_wszTable;
	a_pv[iTAGMETA_ColumnIndex] = (LPVOID)&i_dwIndex;

	hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow, 
																					 cColSearchTag, 
																					 aColSearchTag,
																					 NULL, 
																					 a_pv,
																					 (ULONG*)&iStartRow);
	if(E_ST_NOMOREROWS == hr)
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[AddFlagValuesToPropertyList] No flags found for  %s:%d.\n",
				  i_wszTable,
				  i_dwIndex));
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[AddFlagValuesToPropertyList] GetRowIndexBySearch for %s failed with hr = 0x%x.\n",
				  wszTABLE_TAGMETA,
				  hr));

		goto exit;
	}

	for(ULONG iRow=iStartRow;;iRow++)
	{
		ULONG cchName = 0;

		hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(iRow,
																					 cCol,
											  										 a_iCol,
											  										 NULL,
                                              										 a_pv);
		if(E_ST_NOMOREROWS == hr) 
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[AddFlagValuesToPropertyList] GetColumnValues for %s index %i failed with hr = 0x%x.\n",
					  wszTABLE_TAGMETA,
					  iRow,
					  hr));
			goto exit;
		}

		if(NULL == wszTable)
		{
			wszTable = (LPWSTR)a_pv[iTAGMETA_Table];
		}

		if((wszTable != (LPWSTR)a_pv[iTAGMETA_Table])           ||
		   (i_dwIndex != *(DWORD*)a_pv[iTAGMETA_ColumnIndex])
		  )
		{
			//
			// Reached another table, done with the tags of this table
			//

			break;
		}

		cchName = wcslen((LPWSTR)a_pv[iTAGMETA_InternalName]);

		if(NULL != io_pcCh)
		{
			*io_pcCh = *io_pcCh + cchName + 1; // for comma
		}

		if(NULL != wszEnd)
		{
			memcpy(wszEnd, a_pv[iTAGMETA_InternalName], cchName*sizeof(WCHAR));
			wszEnd = wszEnd + cchName;
			memcpy(wszEnd, g_wszComma,  g_cchComma*sizeof(WCHAR));
			wszEnd = wszEnd + g_cchComma;
		}
	}

	
	if(NULL != io_pwszPropertyList)
	{
		*io_pwszPropertyList = wszEnd;
	}

exit:

	return hr;

} // AddFlagValuesToPropertyList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\ptrmap.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation
  
    Module Name:
    
      ptrmap.cxx
      
    Abstract:
        
      A helper class for mapping ID to 32 or 64 bit ptr
       
    Author:
      Kestutis Patiejunas (kestutip)        08-Dec-1998
            
              
    Revision History:
                
      Notes:
                  
--*/

#include <mdcommon.hxx>
#include <ptrmap.hxx>




/*++
Routine Description:

  Constructor
  
    Arguments:
    nStartMaps - initial nubmer of possible mappings in table
    nIncreaseMaps - number of increase for table when there is not enought space
    
      Return Value:
      sucess is tored in m_fInitialized
      
--*/
CIdToPointerMapper::CIdToPointerMapper(DWORD nStartMaps,DWORD nIncreaseMaps):
                    m_nStartMaps(nStartMaps),                
                    m_nIncreaseMaps(nIncreaseMaps)
{
    if (!m_nStartMaps)
    {
        m_nStartMaps = DEFAULT_START_NUMBER_OF_MAPS;
    }
    if (!nIncreaseMaps)
    {
        m_nIncreaseMaps = DEFAULT_INCREASE_NUMBER_OF_MAPS;
    }
    
    
    // initial empty list head index
    m_EmptyPlace = 0;
    m_nMappings = 0;
    m_Map = NULL;
    
    // allocate a mem for mapping
    m_pBufferObj = new BUFFER (m_nStartMaps * sizeof(PVOID));
    if( m_pBufferObj )
    {
        m_Map = (PVOID *) m_pBufferObj->QueryPtr();
    }
    
    if (m_Map)
    {
        // initialized mappaing space so the every element point to next one
        for (DWORD i=0; i< m_nStartMaps; i++)
        {
            m_Map[i] = (PVOID) (((UINT_PTR)(i+1)) | MAPPING_MASK_SET);
        }
        
        // just he last has special value
        m_Map [m_nStartMaps-1] = (PVOID)MAPPING_NO_EMPTY_PLACE;
        
        m_fInitialized = TRUE;
    }
    else
    {
        m_fInitialized =FALSE;
    }
}


CIdToPointerMapper::~CIdToPointerMapper()
{
    VerifyOutstandinMappings ();
    if (m_fInitialized)
    {
        delete m_pBufferObj;
    }
}


VOID CIdToPointerMapper::VerifyOutstandinMappings ()
{
    MD_ASSERT (m_nMappings==0);
}




/*++
Routine Description:

  Finds a mapping in mapping table between DWORD ID and pointer associated
  
    Arguments:
    DWORD ID - and ID to which mapping should be deleted. 
    
      Return Value:
      
        DWORD - an ID associated with a given pointer . Starts from 1. 
        Zero indicates  a failure to craete mapping.
        
--*/

PVOID   CIdToPointerMapper::FindMapping (DWORD id)
{
    PVOID retVal = NULL;
    
    if (m_fInitialized)
    {
        id--;
        
        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps)
        {
            // there it's simple: get a ptr from  element [id]
            // check that highest bit isn't on
            retVal = m_Map[id];
            if ( ((UINT_PTR)retVal) & MAPPING_MASK_SET)
            {
                retVal = NULL;
                MD_ASSERT (retVal);
            }
        }
    }
    
    return retVal;
}


/*++
Routine Description:

  Deletes a mapping from mapping table between dword ID and PTR
  
    Arguments:
    DWORD ID - and ID to which mapping should be deleted. 
    
      Return Value:
      
        BOOL TRUE is succeded
--*/

BOOL  CIdToPointerMapper::DeleteMapping (DWORD id)
{
    BOOL retVal = FALSE;    
    PVOID ptr;
    
    if (m_fInitialized)
    {
        id--;
        
        MD_ASSERT (id < m_nStartMaps);
        if (id < m_nStartMaps)
        {
            // get the ptr from element with index [id]
            // check that it has not hihgest bit on
            ptr = m_Map[id];
            if ( ((UINT_PTR)ptr) & MAPPING_MASK_SET)
            {
                MD_ASSERT (0);
            }
            else
            {
                // add elemen to empty elements list  
                m_Map[id] = (PVOID)(((UINT_PTR)(m_EmptyPlace)) | MAPPING_MASK_SET);
                m_EmptyPlace = id;
                MD_ASSERT (m_nMappings);
                m_nMappings--;
                retVal = TRUE;
            }
        }
    }
    
    return retVal;
}


/*++
Routine Description:

  Takes a PVOID pointer and returns a DWORD ID associated,which should be used
  in mapping it back to ptr
  
    Arguments:
    PVOID ptr - a pointer of 32/64 bits which should be mapped into dword
    
      Return Value:
      
        DWORD - an ID associated with a given pointer . Starts from 1. 
        Zero indicates  a failure to craete mapping.
        
--*/
DWORD   CIdToPointerMapper::AddMapping (PVOID ptr)
{
    DWORD retVal=0;
    DWORD newSize, i, n, dwPlace;
    PVOID *tmpPtr;
    
    if (m_fInitialized)
    {
        if ( m_EmptyPlace == MAPPING_NO_EMPTY_PLACE_IDX)
        {
            // case when there is not enough mem , so then try to realloc
            newSize = m_nStartMaps + m_nIncreaseMaps;

            if (!m_pBufferObj->Resize (newSize * sizeof(PVOID)))
            {
                return 0;
            }

            tmpPtr = (PVOID *) m_pBufferObj->QueryPtr();

            if (tmpPtr)
            {
                m_Map = tmpPtr;
                
                // realloc succeded initialize the remainder as free list
                for (i=m_nStartMaps; i<newSize; i++)
                {
                    m_Map[i] = (PVOID)(((UINT_PTR)(i+1)) | MAPPING_MASK_SET);
                }
                m_Map [newSize-1] =  (PVOID)MAPPING_NO_EMPTY_PLACE;
                m_EmptyPlace = m_nStartMaps;
                m_nStartMaps = newSize;
            }
            else
            {
                MD_ASSERT (tmpPtr);
                return retVal;
            }
        }
            
            
            // case when there was at least one empty element in free list
            
            dwPlace = m_EmptyPlace;
            if (m_Map[m_EmptyPlace] != (PVOID)MAPPING_NO_EMPTY_PLACE)
            {
                // there still is another one element free
                // so take it's next->next and clear highest bit
                m_EmptyPlace = (DWORD)( ((UINT_PTR)m_Map[m_EmptyPlace]) & MAPPING_MASK_CLEAR);
            }
            else
            {
                // thsi one was last element so now free list is empty
                m_EmptyPlace = MAPPING_NO_EMPTY_PLACE_IDX;
            }
            
            // add a pointer into array and return associated ID
            // note, that we return dwPlace+1 ,a s we don't use ID zero
            m_Map[dwPlace] = ptr;
            retVal = dwPlace + 1;
            m_nMappings++;
        }
        return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\saveschema.cpp ===
#include <locale.h>
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <malloc.h>
#include <tuneprefix.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>
        
#include "Catalog.h"
#include "Catmeta.h"
#include "iisdef.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "WriterGlobals.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"
#include "MBSchemaWriter.h"
#include "SaveSchema.h"

#define cMaxContainedClass 75
#define cMaxProperty       250

int _cdecl MyCompareStrings(const void *a,
			                const void *b)
{
	return _wcsicmp(*(LPWSTR*)a, *(LPWSTR*)b);
}


/***************************************************************************++

Routine Description:

    Helper function used by qsort. Compares to strings, but compares it only
	up until the first comma.


--***************************************************************************/
int _cdecl MyCompareCommaDelimitedStrings(const void *a,
			                              const void *b)
{
	LPWSTR wszStringAStart = ((DELIMITEDSTRING*)a)->pwszStringStart;
	LPWSTR wszStringBStart = ((DELIMITEDSTRING*)b)->pwszStringStart;
	LPWSTR wszStringAEnd   = ((DELIMITEDSTRING*)a)->pwszStringEnd;
	LPWSTR wszStringBEnd   = ((DELIMITEDSTRING*)b)->pwszStringEnd;
	int    iret            = 0;
	SIZE_T cchA            = wszStringAEnd - wszStringAStart;
	SIZE_T cchB            = wszStringBEnd - wszStringBStart;

	//
	// Do not attempt to null terminate the string because you may be
	// hitting a read-only page.
	//

	iret = _wcsnicmp(wszStringAStart, wszStringBStart, __min(cchA, cchB));

	if((0    == iret) && 
	   (cchA != cchB)
	  )
	{
		iret = cchA < cchB ? -1 : 1;
	}

	return iret;
}


/***************************************************************************++

Routine Description:

    Gets the global helper object that has the pointer to the meta tables.

Arguments:

	[in]  Bool that indicates whether to fail or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeGlobalISTHelper(BOOL	i_bFailIfBinFileAbsent)
{
	return ::GetGlobalHelper(i_bFailIfBinFileAbsent,
		                     &g_pGlobalISTHelper);
}

void ReleaseGlobalISTHelper()
{
	if(NULL != g_pGlobalISTHelper)
	{
		delete g_pGlobalISTHelper;
		g_pGlobalISTHelper = NULL;
	}
}


/***************************************************************************++

Routine Description:

    This function saves the schema only if something has changed in the schema
	since the last save.

Arguments:

	[in]  Schema file name.
	[in]  Security attributes for the file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveSchemaIfNeeded(LPCWSTR	            i_wszSchemaFileName,
						   PSECURITY_ATTRIBUTES i_pSecurityAtrributes)
{
	HRESULT hr = S_OK;

	if(NULL == g_pGlobalISTHelper)
	{
		//
		// g_pGlobalISTHelper will not be initialized if
		// ReadAllDataFromXML is not called. This can happen
		// during an upgrade scneario i.e IIS5.0/5.1 to IIS6.0
		// We attempt to initialize it here. Note that we do
		// not fail if bin file is absent - just go with
		// the shipped schema.
		//

		BOOL bFailIfBinFileAbsent = FALSE;

		hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

	}

	if(g_dwSchemaChangeNumber != g_dwLastSchemaChangeNumber)
	{

		DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchemaIfNeeded] Calling SaveSchema. Last save schema change number: %d. Current schema change number: %d.\n",
				  g_dwLastSchemaChangeNumber,
				  g_dwSchemaChangeNumber));

		hr = SaveSchema(i_wszSchemaFileName,
			            i_pSecurityAtrributes);


		if(SUCCEEDED(hr))
		{
			g_dwLastSchemaChangeNumber = g_dwSchemaChangeNumber;

			//
			// SaveSchema will reinitialize the GlobalISTHelper if the schema has changed.
			//

			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchemaIfNeeded] Done Saving schema. Updating last save schema change number to: %d. Current schema change number: %d.\n",
					  g_dwLastSchemaChangeNumber,
					  g_dwSchemaChangeNumber));

		}
	}
	else
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchemaIfNeeded] No need saving schema because schema has not changed since last save. Last save schema change number: %d. Current schema change number: %d.\n",
				  g_dwLastSchemaChangeNumber,
				  g_dwSchemaChangeNumber));
	}

	return hr;

}


/***************************************************************************++

Routine Description:

    This function saves the schema and compiles schema information into the 
	bin file.

Arguments:

	[in]  Schema file name.
	[in]  Security attributes for the file.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveSchema(LPCWSTR	            i_wszSchemaFileName,
				   PSECURITY_ATTRIBUTES i_pSecurityAtrributes)
{
    HRESULT						hr;
	CMDBaseObject*				pObjSchema         = NULL;
	CMDBaseObject*				pObjNames          = NULL;
	CMDBaseObject*				pObjProperties     = NULL;
	CMDBaseObject*				pObjTypes          = NULL;
	CMDBaseObject*				pObjDefaults       = NULL;
	DWORD						dwEnumIndex        = 0;
    DWORD						i,j,k;
	CMDBaseData*				pObjData           = NULL;
	CWriter*					pCWriter           = NULL; 
	CMBSchemaWriter*			pSchemaWriter      = NULL; 
	size_t						cch                = 0;                 
	WCHAR*                      wszEnd             = NULL;
	LPWSTR						wszSchema		   = L"Schema";
	LPWSTR						wszProperties	   = L"Properties";
	ISimpleTableDispenser2*		pISTDisp		   = NULL;
	IMetabaseSchemaCompiler*	pCompiler		   = NULL;

	//
	// Get a pointer to the compiler to get the bin file name.
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
		goto exit;
	}

	hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
								  (LPVOID*)&pCompiler);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
		goto exit;
	}


	//
	// Get the Properties object
	//

	pObjSchema = g_pboMasterRoot->GetChildObject((LPSTR&)wszSchema,
	                                             &hr,
									             TRUE);

	if(FAILED(hr) || (NULL == pObjSchema))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema. GetChildObject failed with hr = 0x%x.\n",hr));

		goto exit;
	}

	pObjProperties = pObjSchema->GetChildObject((LPSTR&)wszProperties,
	                                            &hr,
							                    TRUE);

	if(FAILED(hr) || (NULL == pObjProperties))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema/Properties. GetChildObject failed with hr = 0x%x.\n",hr));

		goto exit;
	}

	//
	// Create the writer object
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n", 
			  g_wszSchemaExtensionFile,
			  g_pGlobalISTHelper->m_wszBinFileForMeta));

	//
	// Assert the g_GlobalISTHelper are valid
	//

	MD_ASSERT(g_pGlobalISTHelper != NULL);

    pCWriter = new CWriter();
	if(NULL == pCWriter)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = pCWriter->Initialize(g_wszSchemaExtensionFile,
		                          g_pGlobalISTHelper,
								  NULL);
	}
	
	if(FAILED(hr))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Error while saving schema tree. Cannot initialize writer. Failed with hr = 0x%x.\n", hr));
		goto exit;
	}

	//
	// First create the IIsConfigObject collection
	//

	hr = CreateIISConfigObjectCollection(pObjProperties,
										 pCWriter,
	                                     &pSchemaWriter);


	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Create all other collections
	//

	hr = CreateNonIISConfigObjectCollections(pObjSchema,
											 pCWriter,
		                                     &pSchemaWriter);

	if(FAILED(hr))
	{
		goto exit;
	}

	if(pSchemaWriter)
	{
		//
		// If pSchemaWriter has a valid Value, then some extensions were found - write it.
		//

		hr = pCWriter->BeginWrite(eWriter_Schema,
			                      i_pSecurityAtrributes);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Error while saving schema tree. CWriter::BeginWrite failed with hr = 0x%x.\n", hr));
			goto exit;
		}

		hr = pSchemaWriter->WriteSchema();

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Error while saving schema tree. CMBSchemaWriter::WriteSchema. Failed with hr = 0x%x.\n", hr));
			goto exit;
			
		}

		hr = pCWriter->EndWrite(eWriter_Schema);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Error while saving schema tree. CWriter::EndWrite Failed with hr = 0x%x.\n", hr));
			goto exit;
		}

		//
		// Trigger compilation
		//

		//
		// Must close the file prior to calling compile schema, else will get a sharing violation.
		//

		delete pCWriter;
		pCWriter = NULL;

		//
		// Always release the bin file that you've been using so far before a
		// compile.
		//

		ReleaseGlobalISTHelper();

		hr = pCompiler->Compile(g_wszSchemaExtensionFile,
							    i_wszSchemaFileName);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] CompileSchema from %s failed with hr = 0x%x.\n",
					  g_wszSchemaExtensionFile, hr));
		}
		else
		{
			if(!DeleteFileW(g_wszSchemaExtensionFile))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());

				DBGINFOW((DBG_CONTEXT,
						  L"[CompileIfNeeded] Compile from schema extensions file: %s succeeded, but cannot cleanup the extensions file:%s. Delete file failed with hr = 0x%x.\n",
						  g_wszSchemaExtensionFile,
						  g_wszSchemaExtensionFile,
						  hr));

				hr = S_OK;
			}

			goto exit;
		}

	}
	else
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] No extensions found. - Either schema tree was changed, but no extensions added, or all extensions were deleted.\n"));
	}

	//
	// If you reach here it means that:
	// A. Schema changes occured to the in-memory /Schema tree, but either
	//    there were no extensions or all extensions were deleted.
	//    (This is inferred when pSchemaWriter in NULL)
	// or
	// B. Schema compile failed. 
	// For A: Compile from shipped schema.
	// For B: Check for an existing schema file. If found make sure that the 
	// bin file is valid. If bin file is not valid try compiling from the 
	// schema file. If schema file is not found, compile from shipped schema.
	//

	if(pSchemaWriter)
	{
		//
		// This is case B.
		//

		if(-1 != GetFileAttributesW(i_wszSchemaFileName))
		{
			if(NULL == g_pGlobalISTHelper)
			{
				BOOL bFailIfBinFileAbsent = TRUE;

				hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

				if(SUCCEEDED(hr))
				{
					goto exit;
				}			
				else
				{
					DBGINFOW((DBG_CONTEXT,
							  L"[SaveSchema] Unable to get the the bin file name. (Assuming file missing or invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
				}
			}
			else
			{
				//
				// Schema file present and valid - goto exit
				// As long as we have a valid g_pGlobalISTHelper, it holds on
				// to a reference to the bin file and the bin file cannot be 
				// invalidated.
				//

				goto exit;
			}

			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Compiling from schema file %s\n", i_wszSchemaFileName));

			if(CopyFileW(i_wszSchemaFileName,
						 g_wszSchemaExtensionFile,
						 FALSE))
			{

				//
				// Always release the bin file that you've been using so far before a
				// compile.
				//

				ReleaseGlobalISTHelper();

				hr = pCompiler->Compile(g_wszSchemaExtensionFile,
										i_wszSchemaFileName);

				if(SUCCEEDED(hr))
				{
					if(!DeleteFileW(g_wszSchemaExtensionFile))
					{
						hr = HRESULT_FROM_WIN32(GetLastError());

						DBGINFOW((DBG_CONTEXT,
								  L"[CompileIfNeeded] Compile from schema file: %s succeeded, but cannot delete the extsions file: %s into which it was copied. Delete file failed with hr = 0x%x.\n",
								  i_wszSchemaFileName,
								  g_wszSchemaExtensionFile,
								  hr));

						hr = S_OK;
					}
					goto exit;
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());

				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Unable to copy %s to %s. CopyFile failed with hr = 0x%x.\n",
						  i_wszSchemaFileName,
						  g_wszSchemaExtensionFile,
						  hr));
			}

		}
	}

	//
	// If you reach here it is either case A or the last part of case B.
	// Recreate from shipped schema
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[SaveSchema] Schema file not found. Compiling from shipped schema\n"));

	//
	// Always release the bin file that you've been using so far before a
	// compile.
	//

	ReleaseGlobalISTHelper();

	hr = pCompiler->Compile(NULL,
						    i_wszSchemaFileName);
	
exit:
	
	if(SUCCEEDED(hr))
	{
		if(NULL == g_pGlobalISTHelper)
		{
			BOOL bFailIfBinFileAbsent = TRUE;

			hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Unable to get the the bin file name. (Assuming file is invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
			}
		}

		if(SUCCEEDED(hr))
		{
			hr = UpdateTimeStamp((LPWSTR)i_wszSchemaFileName,
				                 g_pGlobalISTHelper->m_wszBinFileForMeta);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
					      L"[CompileIfNeeded] UpdateTimeStamp failed with hr = 0x%x.\n",hr));
			}

		}

	}

	if(NULL != pSchemaWriter)
	{
		delete pSchemaWriter;
	}

	if(NULL != pCWriter)
	{
		delete pCWriter;
	}

	if(NULL != pCompiler)
	{
		pCompiler->Release();
	}

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}

    return hr;
}


/***************************************************************************++

Routine Description:

    This function creates the non-IIsConfigObject collection *extensions* to 
	the schema. 

Arguments:

	[in]     Object that contains the schema tree.
	[in]     The writter object.
	[in,out] The schema object - this gets created if it is not already created

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CreateNonIISConfigObjectCollections(CMDBaseObject*      i_pObjSchema,
											CWriter*			i_pCWriter,
											CMBSchemaWriter**   io_pSchemaWriter)
{
	CMDBaseObject*       pObjClasses        = NULL;
	CMDBaseObject*       pObjClass          = NULL;
	DWORD                dwEnumClassIndex   = 0;
	static LPCWSTR		 wszSeparator		= L",";
	WCHAR *				 pwszProperty		= NULL;
	LPWSTR				 wszClasses			= L"Classes";
	HRESULT              hr                 = S_OK;

	//
	// Open the Classes key
	//

	pObjClasses = i_pObjSchema->GetChildObject((LPSTR&)wszClasses,
                                             &hr,
 					                         TRUE);

	if(FAILED(hr) || (NULL == pObjClasses))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema/Classes. GetChildObject failed with hr = 0x%x.\n",hr));

		return hr;
	}


	for(dwEnumClassIndex=0, 
		pObjClass=pObjClasses->EnumChildObject(dwEnumClassIndex++);
		(SUCCEEDED(hr)) && (pObjClass!=NULL);
		pObjClass=pObjClasses->EnumChildObject(dwEnumClassIndex++))
	{
		//
		// Save all the properties for this class in temp variables
		//

		LPCWSTR					wszOptProp			   = NULL; 
		LPCWSTR					wszMandProp			   = NULL; 
		LPCWSTR					wszContainedClassList  = NULL; 
		BOOL					bContainer             = FALSE;
		BOOL*					pbContainer			   = &bContainer;
		LPCWSTR					wszClassName           = (LPCWSTR)pObjClass->GetName(TRUE);
		CMBCollectionWriter*	pCollectionWriter	   = NULL;
		CMDBaseData*			pObjData			   = NULL;
		DWORD					dwEnumIndex            = 0;

		for(dwEnumIndex=0, 
			pObjData=pObjClass->EnumDataObject(dwEnumIndex++, 
											   0, 
											   ALL_METADATA, 
											   ALL_METADATA);
			(SUCCEEDED(hr)) && (pObjData!=NULL);
			pObjData=pObjClass->EnumDataObject(dwEnumIndex++, 
											   0, 
											   ALL_METADATA, 
											   ALL_METADATA))
		{
			DWORD dwID = pObjData->GetIdentifier();

			if(MD_SCHEMA_CLASS_OPT_PROPERTIES == dwID)
			{
				wszOptProp = (LPCWSTR)pObjData->GetData(TRUE);
			}
			else if(MD_SCHEMA_CLASS_MAND_PROPERTIES == dwID)
			{
				wszMandProp = (LPCWSTR)pObjData->GetData(TRUE);
			}
			else if(dwID == MD_SCHEMA_CLASS_CONTAINER)
			{
				pbContainer = (BOOL*)pObjData->GetData(TRUE);
			}
			else if(dwID == MD_SCHEMA_CLASS_CONTAINMENT)
			{
				wszContainedClassList = (LPCWSTR)pObjData->GetData(TRUE);
			}

		}


		//
		// Get collection writer for IIsConfigObject 
		// 

		//
		// TODO: Assert that pbContainer is non-null.
		//

//		DBGINFOW((DBG_CONTEXT,
//				  L"[CreateNonIISConfigObjectCollections] Class %s Mand Prop:%s. Opt Prop: %s\n",
//				  wszClassName,
//				  wszMandProp,
//				  wszOptProp));

		if(ClassDiffersFromShippedSchema(wszClassName,
			                             *pbContainer,
										 (LPWSTR)wszContainedClassList) || 
		   ClassPropertiesDifferFromShippedSchema(wszClassName,
			                                      (LPWSTR)wszOptProp, 
												  (LPWSTR)wszMandProp)
		   )
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Saving collection: %s.\n",wszClassName));

			hr = GetCollectionWriter(i_pCWriter,
									 io_pSchemaWriter,
									 &pCollectionWriter,
									 wszClassName,
									 *pbContainer,
									 wszContainedClassList);
			if(FAILED(hr))
			{
				return hr;
			}

			hr = ParseAndAddPropertiesToNonIISConfigObjectCollection(wszOptProp,
																	 FALSE,
																	 pCollectionWriter);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving classes tree. Could not add optional properties %s for class %s failed with hr = 0x%x.\n",wszOptProp, wszClassName, hr));
				return hr;
			}

			hr = ParseAndAddPropertiesToNonIISConfigObjectCollection(wszMandProp,
																	 TRUE,
																	 pCollectionWriter);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving classes tree. Could not add manditory properties %s for class %s failed with hr = 0x%x.\n",wszMandProp, wszClassName, hr));
				return hr;
			}
		}

	}

	return hr;

}


/***************************************************************************++

Routine Description:

    It parses the list of properties and adds it to a Non_IIsConfigObject
	collection.

Arguments:

	[in]     List of properties
	[in]     Bool that indicates manditory or optional.
	[in,out] The collection object - this gets created if it is not already created

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
ParseAndAddPropertiesToNonIISConfigObjectCollection(LPCWSTR					i_wszProperties,
												    BOOL					i_bManditory,
												    CMBCollectionWriter*	i_pCollectionWriter)
{
	CMBPropertyWriter	*pProperty        = NULL;
	HRESULT             hr                = S_OK;
	static WCHAR        wchSeparator      = L',';
	WCHAR*				pwszStartProperty = NULL;
	WCHAR*				pwszEndProperty   = NULL;
	WCHAR*              pwszNext          = NULL;

	if(NULL == i_wszProperties || 0 == *i_wszProperties)
	{
		return S_OK;
	}

	pwszStartProperty = (LPWSTR)i_wszProperties;

	do
	{
		pwszEndProperty = wcschr(pwszStartProperty, wchSeparator);

		if(0 != *pwszStartProperty)
		{
			hr = i_pCollectionWriter->GetMBPropertyWriter(pwszStartProperty,
														  i_bManditory,
														  &pProperty);

			if(FAILED(hr))
			{
				return hr;
			}
		}

		if(NULL != pwszEndProperty)
		{
			pwszStartProperty = ++pwszEndProperty;
		}
		else
		{
			break;
		}

	}while(TRUE);

	return hr;		
}	


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a property is in the shipped 
	schema or not.

Arguments:

	[in]     Writer object.
	[in]     property id.

Return Value:

    HRESULT

--***************************************************************************/
BOOL PropertyNotInShippedSchema(CWriter*  i_pCWriter,
                                DWORD     i_dwIdentifier)
{
	
	HRESULT	hr							= S_OK;
	ULONG   aColSearch[]				= {iCOLUMNMETA_Table,
										   iCOLUMNMETA_ID
										};
	ULONG   cColSearch					= sizeof(aColSearch)/sizeof(ULONG);
	LPVOID apvSearch[cCOLUMNMETA_NumberOfColumns];
	apvSearch[iCOLUMNMETA_Table]		= (LPVOID)i_pCWriter->m_pCWriterGlobalHelper->m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID]			= (LPVOID)&i_dwIdentifier;
	BOOL	bPropertyNotInShippedSchema = TRUE;
	ULONG   iRow						= 0;
	ULONG   iStartRow					= 0;
	ULONG   iCol						= iCOLUMNMETA_SchemaGeneratorFlags;
	DWORD*  pdwMetaFlagsEx				= NULL;


	hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow, 
																					           cColSearch, 
																					           aColSearch,
																					           NULL, 
																					           apvSearch,
																					           &iRow);

	if(SUCCEEDED(hr))
	{

		hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
																					           1,
																					           &iCol,
																					           NULL,
																					           (LPVOID*)&pdwMetaFlagsEx);

		if(SUCCEEDED(hr) && (((*pdwMetaFlagsEx)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
		{
			bPropertyNotInShippedSchema = FALSE;
		}
	}

	if(E_ST_NOMOREROWS == hr)
	{
		//
		// See if property is a shipped tag.
		//
		
		bPropertyNotInShippedSchema = TagNotInShippedSchema(i_pCWriter,
															i_dwIdentifier);


	}
	else if(FAILED(hr))
	{
		//
		// TODO: Trace a message saying internal catalog error
		//
	}

	return bPropertyNotInShippedSchema;

} // PropertyNotInShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a tag is in the shipped 
	schema or not.

Arguments:

	[in]     Writer object.
	[in]     property id.

Return Value:

    HRESULT

--***************************************************************************/
BOOL TagNotInShippedSchema(CWriter*	i_pCWriter,
						   DWORD	i_dwIdentifier)
{

	HRESULT		hr									= S_OK;
	ULONG		aColSearch[]						= {iTAGMETA_Table,
													   iTAGMETA_ID
														};
	ULONG		cColSearch							= sizeof(aColSearch)/sizeof(ULONG);
	LPVOID		apvSearch[cCOLUMNMETA_NumberOfColumns];
	BOOL		bTagNotInShippedSchema				= TRUE;
	ULONG		iStartRow							= 0;
	ULONG		iColIndex							= iTAGMETA_ColumnIndex;
	DWORD*		pdwColIndex							= NULL;

	apvSearch[iTAGMETA_Table]						= (LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject;
	apvSearch[iTAGMETA_ID]							= (LPVOID)&i_dwIdentifier;


		
	hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndID->GetRowIndexBySearch(iStartRow, 
																						    cColSearch, 
																						    aColSearch,
																						    NULL, 
																						    apvSearch,
																						    &iStartRow);

	if(SUCCEEDED(hr))
	{

		hr = i_pCWriter->m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndID->GetColumnValues(iStartRow,
																						    1,
																						    &iColIndex,
																						    NULL,
																						    (LPVOID*)&pdwColIndex);
		if(SUCCEEDED(hr))
		{
			//
			// Lookup the property to see if it is shipped.
			//

			LPVOID	a_Identity[] = {(LPVOID)g_pGlobalISTHelper->m_wszTABLE_IIsConfigObject,
									(LPVOID)pdwColIndex
			};
			ULONG   iRow=0;

					                
			hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
																			 a_Identity,
																			 &iRow);

			if(SUCCEEDED(hr))
			{
				DWORD* pdwExtended = NULL;
				ULONG  iColPropertyMetaFlagsEx = iCOLUMNMETA_SchemaGeneratorFlags;

				hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(iRow,	
																		   1,
																		   &iColPropertyMetaFlagsEx,
																		   NULL,
																		   (LPVOID*)&pdwExtended);
				
				if(SUCCEEDED(hr) && (((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
				{
					//
					// Found at least one property that is not in the shipped schema
					//
					bTagNotInShippedSchema = FALSE;
				}
			
				//
				// Else condition means it failed or it was a shipped property
				// if(FAILED(hr) || ( (((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
				//

			}

		}

	} // If GetRowIndexBySearch succeeds

	return bTagNotInShippedSchema;

} // TagNotInShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and determines if a class has any extensions or if it
	an extended (ie new) class.

Arguments:

	[in]     Class name
	[in]     Container class or not.
	[in]     Container class list.

Return Value:

    HRESULT

--***************************************************************************/
BOOL ClassDiffersFromShippedSchema(LPCWSTR i_wszClassName,
								   BOOL	   i_bIsContainer,
								   LPWSTR  i_wszContainedClassList)
{
	HRESULT						hr								 = S_OK;
	BOOL						bClassDiffersFromShippedSchema	 = TRUE;
	ULONG						aiCol [] 						 = {iTABLEMETA_SchemaGeneratorFlags,
																	iTABLEMETA_ContainerClassList
																	};
	ULONG                       cCol                             = sizeof(aiCol)/sizeof(ULONG);
	LPVOID						apv[cTABLEMETA_NumberOfColumns];
	ULONG                       iRow                             = 0;
	
	hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
																                     (LPVOID*)&i_wszClassName,
																                     &iRow);

	if(SUCCEEDED(hr))
	{

		hr = g_pGlobalISTHelper->m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
			                                                                       cCol,
							  		                                               aiCol,
									                                               NULL,
									                                               apv);

		if(SUCCEEDED(hr))
		{
			if(((*(DWORD*)apv[iTABLEMETA_SchemaGeneratorFlags]) & (fTABLEMETA_EXTENDED|fTABLEMETA_USERDEFINED)) == 0)
			{
				if(MatchClass(i_bIsContainer,
							  i_wszContainedClassList,
							  apv)
				  )
				{
					bClassDiffersFromShippedSchema = FALSE;
				}
			}
		}
		else if(E_ST_NOMOREROWS == hr)
		{
			//
			// TODO: Trace a message saying internal catalog error
			//
		}
	}
	else if(E_ST_NOMOREROWS != hr)
	{
		//
		// TODO: Trace a message saying internal catalog error
		//
	}

	return bClassDiffersFromShippedSchema;
	
} // ClassDiffersFromShippedSchema


/***************************************************************************++

Routine Description:

    Looks up the schema and matches a class.

Arguments:

	[in]     Container class or not.
	[in]     Container class list.
	[in]     Class attributes.

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchClass(BOOL	  i_bIsContainer,
				LPWSTR	  i_wszContainedClassList,
				LPVOID*   i_apv)
{
	BOOL	 bMatch = TRUE;
	DWORD    fIsContained = (*(DWORD*)i_apv[iTABLEMETA_SchemaGeneratorFlags]) & fTABLEMETA_CONTAINERCLASS;

	//
	// Compare the container property 1st and only if they equal compare the container class list
	//

	if( i_bIsContainer && 
		(fIsContained != fTABLEMETA_CONTAINERCLASS)
	  )
	{
		bMatch = FALSE;
	}
	else if (!i_bIsContainer &&
		     (fIsContained == fTABLEMETA_CONTAINERCLASS)
	        )
	{
		bMatch = FALSE;
	}
	else 
	{
		bMatch = MatchCommaDelimitedStrings(i_wszContainedClassList,
											(LPWSTR)i_apv[iTABLEMETA_ContainerClassList]);
	}

	return bMatch;

} // MatchClass


/***************************************************************************++

Routine Description:

    Checks to see if two comma delimited strings match.

Arguments:

	[in]     Comma delimited string.
	[in]     Comma delimited string.

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchCommaDelimitedStrings(LPWSTR	i_wszString1,
								LPWSTR	i_wszString2)
{
	BOOL	bMatch = FALSE;

	DELIMITEDSTRING	aStringFixed1[cMaxContainedClass];
	DELIMITEDSTRING	aStringFixed2[cMaxContainedClass];
	DELIMITEDSTRING*	aString1    = aStringFixed1;
	DELIMITEDSTRING*	aString2    = aStringFixed2;
	ULONG               cString1    = cMaxContainedClass;
	ULONG               cString2    = cMaxContainedClass;
	ULONG               iString1    = 0;
	ULONG               iString2    = 0;
	BOOL                bReAlloced1 = FALSE;
	BOOL                bReAlloced2 = FALSE;
	HRESULT             hr          = S_OK;

	if(NULL == i_wszString1 || 0 == *i_wszString1)
	{
		if(NULL == i_wszString2 || 0 == *i_wszString2)
		{
			bMatch = TRUE;
		}
	}
	else if(NULL == i_wszString2 || 0 == *i_wszString2)
	{
		bMatch = FALSE; 		// Means i_wszString1 != NULL and i_wszString2 == NULL
	}
	else if(wcscmp(i_wszString1, i_wszString2) == 0)
	{
		bMatch = TRUE;
	}
	else
	{
		//
		// Construct an array of individual strings
		// and compare the array
		//

		hr = CommaDelimitedStringToArray(i_wszString1,
			                             &aString1,
										 &iString1,
										 &cString1,
										 &bReAlloced1);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = CommaDelimitedStringToArray(i_wszString2,
			                             &aString2,
										 &iString2,
										 &cString2,
										 &bReAlloced2);

		if(FAILED(hr))
		{
			goto exit;
		}

		bMatch = MatchDelimitedStringArray(aString1,
			                               iString1,
								           aString2,
								           iString2);

	}

exit:

	if(aString1 != aStringFixed1)
	{
		delete [] aString1;
	}

	if(aString2 != aStringFixed2)
	{
		delete [] aString2;
	}

	return bMatch;

} // MatchCommaDelimitedStrings


/***************************************************************************++

Routine Description:

    Converts a comma delimited string to an array.

Arguments:

	[in]         Comma delimited string.
	[in,out]     Array.
	[in,out]     Current index in the array.
	[in,out]     Max count of the array. (i.e. max it can hold)
	[in,out]     Bool which indecates if the array has been realloced.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CommaDelimitedStringToArray(LPWSTR		        i_wszString,
                                    DELIMITEDSTRING**	io_apDelimitedString,
									ULONG*              io_piDelimitedString,
									ULONG*		        io_pcMaxDelimitedString,
									BOOL*               io_pbReAlloced)
{
	LPWSTR  wszSubStringStart = NULL;
	LPWSTR  wszSubStringEnd   = NULL;
	HRESULT hr                = S_OK;

	wszSubStringStart = i_wszString;

	while(NULL != wszSubStringStart)
	{
		DELIMITEDSTRING DelimitedString;

		wszSubStringEnd = wcschr(wszSubStringStart, L',');

		DelimitedString.pwszStringStart = wszSubStringStart;

		if(NULL != wszSubStringEnd)
		{
			DelimitedString.pwszStringEnd = wszSubStringEnd;
		}
		else
		{
			// Point to the terminating NULL.

			DelimitedString.pwszStringEnd = wszSubStringStart + wcslen(wszSubStringStart);
		}

		hr = AddDelimitedStringToArray(&DelimitedString,
		                               io_piDelimitedString,
                                       io_pcMaxDelimitedString,
							           io_pbReAlloced,
							           io_apDelimitedString);

		if(FAILED(hr))
		{
			return hr;
		}

		if(wszSubStringEnd != NULL)
		{
			wszSubStringStart = ++wszSubStringEnd;
		}
		else
		{
			wszSubStringStart = wszSubStringEnd;
		}
	}


	return S_OK;

}


/***************************************************************************++

Routine Description:

    Adds the string to the array.

Arguments:

	[in]         String to add.
	[in,out]     Current index in the array.
	[in,out]     Max count of the array. (i.e. max it can hold)
	[in,out]     Bool which indecates if the array has been realloced.
	[in,out]     Array.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT AddDelimitedStringToArray(DELIMITEDSTRING*     i_pDelimitedString,
						          ULONG*		       io_piDelimitedString,
                                  ULONG*		       io_pcMaxDelimitedString,
						          BOOL*		           io_pbReAlloced,
						          DELIMITEDSTRING**	   io_apDelimitedString)
{
	HRESULT hr = S_OK;

	if(*io_piDelimitedString >= *io_pcMaxDelimitedString)
	{
		hr = ReAllocate(*io_piDelimitedString,
				        *io_pbReAlloced,
						io_apDelimitedString,
			            io_pcMaxDelimitedString);

		if(FAILED(hr))
		{
			return hr;
		}

		*io_pbReAlloced = TRUE;
	}

	(*io_apDelimitedString)[(*io_piDelimitedString)++] = (*i_pDelimitedString);

	return hr;

}

HRESULT ReAllocate(ULONG              i_iDelimitedString,
				   BOOL               i_bReAlloced,
				   DELIMITEDSTRING**  io_apDelimitedString,
				   ULONG*             io_pcDelimitedString)
{
	DELIMITEDSTRING*	pSav = NULL;

	pSav = new DELIMITEDSTRING[*io_pcDelimitedString + cMaxContainedClass];
	if(NULL == pSav)
	{
		return E_OUTOFMEMORY;
	}
	*io_pcDelimitedString = *io_pcDelimitedString + cMaxContainedClass;
	memset(pSav, 0, sizeof(DELIMITEDSTRING)*(*io_pcDelimitedString));

	if(NULL != *io_apDelimitedString)
	{
		memcpy(pSav, *io_apDelimitedString, sizeof(DELIMITEDSTRING)*i_iDelimitedString);
		if(i_bReAlloced)
		{
			delete [] *io_apDelimitedString;
			*io_apDelimitedString = NULL;
		}
	}

	*io_apDelimitedString = pSav;

	return S_OK;
}


/***************************************************************************++

Routine Description:

    Compares two string arrays.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/
BOOL MatchDelimitedStringArray(DELIMITEDSTRING* i_aString1,
		                       ULONG            i_cString1,
			                   DELIMITEDSTRING* i_aString2,
					           ULONG            i_cString2)
{
	DBG_ASSERT((i_cString1 > 0) && (i_cString2 >0));

	if(i_cString1 != i_cString2)
	{
		return FALSE;
	}

	qsort((void*)i_aString1, i_cString1, sizeof(DELIMITEDSTRING), MyCompareCommaDelimitedStrings);
	qsort((void*)i_aString2, i_cString2, sizeof(DELIMITEDSTRING), MyCompareCommaDelimitedStrings);

	for(ULONG i=0; i<i_cString1; i++)
	{
		if(0 != MyCompareCommaDelimitedStrings(&(i_aString1[i]),
			                                   &(i_aString2[i]))
		  )
		{
			return FALSE;
		}
	}

	return TRUE;

}
 

/***************************************************************************++

Routine Description:

    Looks at the optinal and manditory properties of a class and determines 
	if ti differs fromt the shipped schema.

Arguments:

	[in]     Class name.
	[in]     Optional properties.
	[in]     Manditory properties.
	[in]     Writer object.

Return Value:

    HRESULT

--***************************************************************************/
BOOL ClassPropertiesDifferFromShippedSchema(LPCWSTR  i_wszClassName,
											LPWSTR   i_wszOptProperties,
											LPWSTR   i_wszMandProperties)
{

	BOOL						bClassPropertiesDifferFromShippedSchema	 = FALSE;
	ULONG                       i	                                     = 0;
	HRESULT                     hr                                       = S_OK;
	DELIMITEDSTRING             aPropertyFixed[cMaxProperty];
	ULONG                       cProperty                                = cMaxProperty;
	ULONG                       iProperty                                = 0;
	DELIMITEDSTRING*            aProperty                                = aPropertyFixed;
	BOOL                        bReAlloced                               = FALSE;
	ULONG                       aCol[]                                  = {iCOLUMNMETA_Index,
		                                                                   iCOLUMNMETA_InternalName,
																		   iCOLUMNMETA_MetaFlags,
																		   iCOLUMNMETA_SchemaGeneratorFlags
																			};
	ULONG                       cCol                                     = sizeof(aCol)/sizeof(ULONG);
	LPVOID                      apv[cCOLUMNMETA_NumberOfColumns];
	

	if( ((NULL == i_wszOptProperties)  || (0 == *i_wszOptProperties)) &&
		((NULL == i_wszMandProperties) || (0 == *i_wszMandProperties))
	  )
	{
		//
		// It is true that you cannot delete all shipped properties from a shipped class,
		// because every shipped class that we know of has at least one location property.
		// But there may be previously added extension that were deleted, so assume something 
		// changed, when there are no properties.
		//
		bClassPropertiesDifferFromShippedSchema = TRUE;
		goto exit;
	}


	//
	// Now create an array of
	// mand + opt properties
	//

	if((NULL != i_wszOptProperties) && (0 != *i_wszOptProperties))
	{

		hr = CommaDelimitedStringToArray(i_wszOptProperties,
										 &aProperty,
										 &iProperty,
										 &cProperty,
										 &bReAlloced);

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	if((NULL != i_wszMandProperties) && (0 != *i_wszMandProperties))
	{
		hr = CommaDelimitedStringToArray(i_wszMandProperties,
										 &aProperty,
										 &iProperty,
										 &cProperty,
										 &bReAlloced);

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	for(i=0; i<iProperty; i++ )
	{
		LPWSTR	wszPropertyName		        = aProperty[i].pwszStringStart;
		LPWSTR	wszEnd				        = aProperty[i].pwszStringEnd;
		WCHAR	wchEndSav;
		ULONG   aColSearchProperty[]        = {iCOLUMNMETA_Table,
										       iCOLUMNMETA_InternalName
												};
		ULONG   cColSearchProperty          = sizeof(aColSearchProperty)/sizeof(ULONG);
		LPVOID  apvSearchProperty[cCOLUMNMETA_NumberOfColumns];
		ULONG   iStartRowProperty           = 0;
		ULONG   iColPropertyMetaFlagsEx     = iCOLUMNMETA_SchemaGeneratorFlags;
		DWORD*  pdwExtended                 = NULL;

		//
		// Null terminate the property name and initialize it.
		// Hence on gotos until you reset it.
		//

		wchEndSav = *wszEnd;
		*wszEnd = L'\0';

		apvSearchProperty[iCOLUMNMETA_Table]        = (LPVOID)i_wszClassName;
		apvSearchProperty[iCOLUMNMETA_InternalName] = (LPVOID)wszPropertyName; 


		//
		// See if the property is found in the class and see if it is shipped
		//

		hr = g_pGlobalISTHelper->m_pISTColumnMetaByTableAndName->GetRowIndexBySearch(iStartRowProperty, 
											                                         cColSearchProperty, 
												                                     aColSearchProperty,
												                                     NULL, 
												                                     apvSearchProperty,
												                                     &iStartRowProperty);

		if(SUCCEEDED(hr))
		{
			hr = g_pGlobalISTHelper->m_pISTColumnMetaByTableAndName->GetColumnValues(iStartRowProperty,
															                         1,
																			         &iColPropertyMetaFlagsEx,
																			         NULL,
																			         (LPVOID*)&pdwExtended);

			if(FAILED(hr) || ( ((*pdwExtended) & (fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
			{
				//
				// Found at least one property that is not in the shipped schema
				//

				bClassPropertiesDifferFromShippedSchema = TRUE;
			}
		
			//
			// Else condition means it succeeded and it was a shipped property
			// if(SUCCEEDED(hr) && ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
			//

		}
		else
		{
			//
			// May be its a tag value. Check if it is in the tag meta
			//

			ULONG   aColSearchTag[]        = {iTAGMETA_Table,
										      iTAGMETA_InternalName
											 };
			ULONG   cColSearchTag          = sizeof(aColSearchTag)/sizeof(ULONG);
			LPVOID  apvSearchTag[cTAGMETA_NumberOfColumns];
			ULONG   iStartRowTag           = 0;
			ULONG   iColIndex              = iTAGMETA_ColumnIndex;
			DWORD*	pdwColumnIndex		   = NULL;

			apvSearchTag[iTAGMETA_Table]        = (LPVOID)i_wszClassName;
			apvSearchTag[iTAGMETA_InternalName] = (LPVOID)wszPropertyName; 

			hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndName->GetRowIndexBySearch(iStartRowTag, 
												                                      cColSearchTag, 
												                                      aColSearchTag,
												                                      NULL, 
												                                      apvSearchTag,
												                                      &iStartRowTag);

			if(FAILED(hr))
			{
				bClassPropertiesDifferFromShippedSchema = TRUE;
			}
			else
			{
				//
				// Check if the parent property of this tag is shipped, if it is not,
				// then this becomes a non-shipped tag
				//

				hr = g_pGlobalISTHelper->m_pISTTagMetaByTableAndName->GetColumnValues(iStartRowTag,
					                                                                  1,
												                                      &iColIndex,
												                                      NULL,
												                                      (LPVOID*)&pdwColumnIndex);

				if(SUCCEEDED(hr))
				{
					LPVOID	a_Identity[] = {(LPVOID)i_wszClassName,
											(LPVOID)pdwColumnIndex
					};
					ULONG   iRow         = 0;

					hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
																					 a_Identity,
																					 &iRow);

					if(SUCCEEDED(hr))
					{
						hr = g_pGlobalISTHelper->m_pISTColumnMeta->GetColumnValues(iRow,	
																	               1,
																	               &iColPropertyMetaFlagsEx,
																	               NULL,
																	               (LPVOID*)&pdwExtended);

						if(FAILED(hr) || ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) != 0))
						{
							//
							// Found at least one property that is not in the shipped schema
							//
							bClassPropertiesDifferFromShippedSchema = TRUE;
						}
					
						//
						// Else condition means it succeeded and it was a shipped property
						// if(SUCCEEDED(hr) && ( ((*pdwExtended)&(fCOLUMNMETA_EXTENDED|fCOLUMNMETA_USERDEFINED)) == 0))
						//				

					}
				}
				else
				{
					bClassPropertiesDifferFromShippedSchema = TRUE;
				}

			}

		}

		//
		// Restore the property name
		//

		*wszEnd = wchEndSav;

		if(FAILED(hr) || bClassPropertiesDifferFromShippedSchema)
		{
			goto exit;
		}

	}


exit:

	if(FAILED(hr))
	{
		bClassPropertiesDifferFromShippedSchema = TRUE;
	}

	if(aProperty != aPropertyFixed)
	{
		delete [] aProperty;
	}

	return bClassPropertiesDifferFromShippedSchema;

} // ClassPropertiesDifferFromShippedSchema


/***************************************************************************++

Routine Description:

    Creates the IIsConfigObject collection - This collection has complete
	definitions of all properties.

Arguments:

	[in]         Properties object.
	[in,out]     Writer object.
	[in,out]     Schema Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT	CreateIISConfigObjectCollection(CMDBaseObject*      i_pObjProperties,
										CWriter*			i_pCWriter,
                                       	CMBSchemaWriter**   io_pSchemaWriter)
{
	HRESULT              hr                 = S_OK;
	CMBCollectionWriter* pCollectionWriter  = NULL;

	hr = SaveNames(i_pObjProperties,
				   i_pCWriter,
				   io_pSchemaWriter,
				   &pCollectionWriter);

	if(FAILED(hr))
	{
		return hr;
	}


	hr = SaveTypes(i_pObjProperties,
				   i_pCWriter,
				   io_pSchemaWriter,
				   &pCollectionWriter);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = SaveDefaults(i_pObjProperties,
				      i_pCWriter,
				      io_pSchemaWriter,
				      &pCollectionWriter);

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty name

Arguments:

	[in]         Metabase properties object.
	[in,out]     Writer object.
	[in,out]     Schema Writer object.
	[in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveNames(CMDBaseObject*	    i_pObjProperties,
				  CWriter*              i_pCWriter,
                  CMBSchemaWriter**	    io_pSchemaWriter,
				  CMBCollectionWriter** io_pCollectionWriter)
{
	HRESULT              hr                 = S_OK;
	CMDBaseObject*       pObjNames          = NULL;
	CMDBaseData*         pObjData           = NULL;
	DWORD                dwEnumIndex        = 0;
	LPWSTR				 wszNames			= L"Names";

	//
	// Get the names object
	//

	pObjNames = i_pObjProperties->GetChildObject((LPSTR&)wszNames,
		                                        &hr,
									            TRUE);

	if(FAILED(hr) || (NULL == pObjNames))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema/Properties/Names. GetChildObject failed with hr = 0x%x.\n",hr));

		return hr;
	}

	//
	// Populate the Column meta array by enumerating the names key.
	//

    for(dwEnumIndex=0, 
		pObjData=pObjNames->EnumDataObject(dwEnumIndex++, 
		                                   0, 
									       ALL_METADATA, 
										   ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjNames->EnumDataObject(dwEnumIndex++, 
			                               0, 
										   ALL_METADATA, 
										   ALL_METADATA)) 
	{
		CMBPropertyWriter	*pProperty = NULL;

        if(pObjData->GetDataType() != STRING_METADATA)
        {
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Encountered non-string data in the names tree of the schema. Ignoring entry for this ID: %d \n",pObjData->GetIdentifier()));
            continue;
        }

		if(PropertyNotInShippedSchema(i_pCWriter, 
									  pObjData->GetIdentifier())
		  )
		{
			if(NULL == *io_pCollectionWriter)
			{
				hr = GetCollectionWriter(i_pCWriter,
										 io_pSchemaWriter,
										 io_pCollectionWriter,
										 wszTABLE_IIsConfigObject,
										 FALSE,
										 NULL);
				if(FAILED(hr))
				{
					return hr;
				}
			}


			hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
														      &pProperty);


			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving names tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

				return hr;
			}

			pProperty->AddNameToProperty((LPCWSTR)(pObjData->GetData(TRUE)));
		}

	}

	// 
	// Must call create index else it will keep adding duplicate property entries.
	//

	return hr;

} // SaveNames


/***************************************************************************++

Routine Description:

    Saves the extended roperty type

Arguments:

	[in]         Metabase properties object.
	[in,out]     Writer object.
	[in,out]     Schema Writer object.
	[in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveTypes(CMDBaseObject*	    i_pObjProperties,
				  CWriter*              i_pCWriter,
                  CMBSchemaWriter**	    io_pSchemaWriter,
				  CMBCollectionWriter** io_pCollectionWriter)
{
	HRESULT              hr                 = S_OK;
	CMDBaseObject*       pObjTypes          = NULL;
	CMDBaseData*         pObjData           = NULL;
	DWORD                dwEnumIndex        = 0;
	LPWSTR				 wszTypes			= L"Types";

	//
	// Get the Types object
	//

	pObjTypes = i_pObjProperties->GetChildObject((LPSTR&)wszTypes,
		                                         &hr,
									             TRUE);

	if(FAILED(hr) || (NULL == pObjTypes))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema/Properties/Types. GetChildObject failed with hr = 0x%x.\n",hr));

		return hr;
	}

    for(dwEnumIndex=0, 
		pObjData=pObjTypes->EnumDataObject(dwEnumIndex++, 
		                                   0, 
									       ALL_METADATA, 
										   ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjTypes->EnumDataObject(dwEnumIndex++, 
			                               0, 
										   ALL_METADATA, 
										   ALL_METADATA)) 
	{
		CMBPropertyWriter	*pProperty = NULL;

        if(pObjData->GetDataType() != BINARY_METADATA  || 
		   pObjData->GetDataLen(TRUE) != sizeof(PropValue))
        {
			DBGINFOW((DBG_CONTEXT,
					  L"[SaveSchema] Encountered non-binary data in the type tree of the schema.\nIgnoring type entry for this ID: %d.\nType: %d.(Expected %d)\nLength: %d(Expected %d).\n",
					  pObjData->GetIdentifier(),
					  pObjData->GetDataType(),
					  BINARY_METADATA,
					  pObjData->GetDataLen(TRUE),
					  sizeof(PropValue)));
			if(pObjData->GetDataType() == STRING_METADATA )
			{
				DBGINFOW((DBG_CONTEXT,
						  L"Data: %s.\n",
						  pObjData->GetData(TRUE)
						  ));
			}

            continue;
        }

		if(PropertyNotInShippedSchema(i_pCWriter,
			                          pObjData->GetIdentifier())
		  )
		{

			if(NULL == *io_pCollectionWriter)
			{
				hr = GetCollectionWriter(i_pCWriter,
										 io_pSchemaWriter,
										 io_pCollectionWriter,
										 wszTABLE_IIsConfigObject,
										 FALSE,
										 NULL);
				if(FAILED(hr))
				{
					return hr;
				}
			}

			hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
														      &pProperty);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving types tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

				return hr;
			}

			hr = pProperty->AddTypeToProperty((PropValue*)(pObjData->GetData(TRUE)));

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving types tree. AddTypeToProperty for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

				return hr;
			}
		}

	}

	return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty default

Arguments:

	[in]         Metabase properties object.
	[in,out]     Writer object.
	[in,out]     Schema Writer object.
	[in,out]     Collection Writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SaveDefaults(CMDBaseObject*	          i_pObjProperties,
				     CWriter*                 i_pCWriter,
                     CMBSchemaWriter**	      io_pSchemaWriter,
				     CMBCollectionWriter**    io_pCollectionWriter)
{
	HRESULT              hr                 = S_OK;
	CMDBaseObject*       pObjDefaults       = NULL;
	CMDBaseData*         pObjData           = NULL;
	DWORD                dwEnumIndex        = 0;
	LPWSTR				 wszDefaults		= L"Defaults";

	//
	// Get the Defaults object
	//

	pObjDefaults = i_pObjProperties->GetChildObject((LPSTR&)wszDefaults,
		                                            &hr,
									                TRUE);

	if(FAILED(hr) || (NULL == pObjDefaults))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] Unable to open /Schema/Properties/Defaults. GetChildObject failed with hr = 0x%x.\n",hr));

		return hr;
	}

    for(dwEnumIndex=0, 
		pObjData=pObjDefaults->EnumDataObject(dwEnumIndex++, 
		                                      0, 
									          ALL_METADATA, 
										      ALL_METADATA);
        (SUCCEEDED(hr)) && (pObjData!=NULL);
        pObjData=pObjDefaults->EnumDataObject(dwEnumIndex++, 
			                                  0, 
										      ALL_METADATA, 
										      ALL_METADATA)) 
	{
		CMBPropertyWriter	*pProperty = NULL;

		if(PropertyNotInShippedSchema(i_pCWriter,
								      pObjData->GetIdentifier())
		  )
		{
			if(NULL == *io_pCollectionWriter)
			{
				hr = GetCollectionWriter(i_pCWriter,
										 io_pSchemaWriter,
										 io_pCollectionWriter,
										 wszTABLE_IIsConfigObject,
										 FALSE,
										 NULL);
				if(FAILED(hr))
				{
					return hr;
				}
			}

			hr = (*io_pCollectionWriter)->GetMBPropertyWriter(pObjData->GetIdentifier(),
														      &pProperty);

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving defaults tree. GetPropertyWriter for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

				return hr;
			}

			hr = pProperty->AddDefaultToProperty((BYTE*)(pObjData->GetData(TRUE)),
												 pObjData->GetDataLen(TRUE));

			if(FAILED(hr))
			{
				DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving types tree. AddDefaultToProperty for ID:%d failed with hr = 0x%x.\n",pObjData->GetIdentifier(),  hr));

				return hr;
			}
		}

	}

	return hr;
}


/***************************************************************************++

Routine Description:

    Saves the extended roperty name

Arguments:

	[in,out]     Writer object.
	[in,out]     Schema Writer object.
	[in,out]     Collection Writer object.
	[in]         Collection name
	[in]         Bool that indicates container
	[in]         Container class list


Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetCollectionWriter(CWriter*			   i_pCWriter,
							CMBSchemaWriter**	   io_pSchemaWriter,
							CMBCollectionWriter**  io_pCollectionWriter,
							LPCWSTR                i_wszCollectionName,
							BOOL                   i_bContainer,
							LPCWSTR                i_wszContainerClassList)
{
	HRESULT hr = S_OK;

	if(NULL != *io_pCollectionWriter)
	{
		return S_OK;
	}

	//
	// Get the schema writer if it has not been created
	//

	if(NULL == *io_pSchemaWriter)
	{
		hr = i_pCWriter->GetMetabaseSchemaWriter(io_pSchemaWriter);

		if(FAILED(hr))
		{
			  DBGINFOW((DBG_CONTEXT,
						  L"[SaveSchema] Error while saving schema tree. Unable to get schema writer failed with hr = 0x%x.\n", hr));
			return hr;
		}

	}

	//
	// Get collection writer for the collection 
	// 

	hr = (*io_pSchemaWriter)->GetCollectionWriter(i_wszCollectionName,
	                                              i_bContainer,
												  i_wszContainerClassList,
												  io_pCollectionWriter);
	if(FAILED(hr))
	{
        DBGINFOW((DBG_CONTEXT,
				  L"[SaveSchema] GetCollectionWriter for %s failed with hr = 0x%x.\n",
				  i_wszCollectionName, hr));

		return hr;
	}

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    IIS MetaBase security routines.

Author:

    Keith Moore (keithmo)       13-Mar-1997

Revision History:

--*/


#include <mdcommon.hxx>


//
// Private data.
//

CRITICAL_SECTION p_SecurityLock;
HCRYPTPROV       p_CryptoProvider  = CRYPT_NULL;
HCRYPTPROV       p_CryptoProvider2 = CRYPT_NULL;


//
// Public functions.
//


BOOL
InitializeMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Initializes metabase security.

Arguments:

    None.

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/
{

    HRESULT result;

    INITIALIZE_CRITICAL_SECTION( &p_SecurityLock );

    result = ::IISCryptoInitialize();

    if( FAILED(result) ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "InitializeMetabaseSecurity: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // InitializeMetabaseSecurity


VOID
TerminateMetabaseSecurity(
    VOID
    )
/*++

Routine Description:

    Terminates metabase security. Basically, undoes anything done in
    InitializeMetabaseSecurity().

Arguments:

    None.

Return Value:

    None.

--*/
{

    HRESULT result;

    if( p_CryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( p_CryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
    }

    if( p_CryptoProvider2 != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( p_CryptoProvider2 );
        DBG_ASSERT( SUCCEEDED(result) );
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    DeleteCriticalSection( &p_SecurityLock );

}   // TerminateMetabaseSecurity


HRESULT
GetCryptoProvider(
    HCRYPTPROV *Provider
    )
/*++

Routine Description:

    This routine returns a handle to the crypto provider we need to
    use, deferring creation of the handle until it is actually needed.

Arguments:

    Provider - Receives the handle to the provider.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // If the handle is already initialized, then just use it. Otherwise,
    // grab the lock and check it again.
    //

    hprov = p_CryptoProvider;
    if( hprov == CRYPT_NULL ) {

        EnterCriticalSection( &p_SecurityLock );

        hprov = p_CryptoProvider;
        if( hprov == CRYPT_NULL ) {

            result = ::IISCryptoGetStandardContainer(
                           &hprov,
                           CRYPT_MACHINE_KEYSET
                           );

            if( SUCCEEDED(result) ) {
                p_CryptoProvider = hprov;
            }

        }

        LeaveCriticalSection( &p_SecurityLock );

    }

    *Provider = hprov;
    return result;

}   // GetCryptoProvider

HRESULT
GetCryptoProvider2(
    HCRYPTPROV *Provider
    )
/*++

Routine Description:

    This routine returns a handle to the crypto provider we need to
    use, deferring creation of the handle until it is actually needed.

Arguments:

    Provider - Receives the handle to the provider.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // If the handle is already initialized, then just use it. Otherwise,
    // grab the lock and check it again.
    //

    hprov = p_CryptoProvider2;
    if( hprov == CRYPT_NULL ) {

        EnterCriticalSection( &p_SecurityLock );

        hprov = p_CryptoProvider2;
        if( hprov == CRYPT_NULL ) {

            result = ::IISCryptoGetStandardContainer2(
                           &hprov
                           );

            if( SUCCEEDED(result) ) {
                p_CryptoProvider2 = hprov;
            }

        }

        LeaveCriticalSection( &p_SecurityLock );

    }

    *Provider = hprov;
    return result;

}   // GetCryptoProvider2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\metasub.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase subroutines to support exported routines

Author:

    Michael W. Thomas            31-May-96

Revision History:

Notes:

    Most routines in this file assume that g_rMasterResource is already taken
    for read or write as appropriate.
--*/

#include <locale.h>
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <malloc.h>
#include <tuneprefix.h>
#include <iiscnfg.h>   
#include <Importer.h>       // For the import ABO command

#if DBG
BOOL g_fShowMetaLocks = FALSE;
#endif DBG

//
// TODO: Put in the header file.
//

#include "Catalog.h"
#include "Catmeta.h"
#include "svcmsg.h"
#include "iisdef.h"
#include "Lock.hxx"
#include "CLock.hxx"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "LocationWriter.h"
#include "WriterGlobals.h"
#include "ListenerController.h"
#include <iadmw.h>
#include "Listener.h"

#include "aclapi.h"

#define _WIDEN(x) L ## x

//
// TODO: Since XML table also uses this cant we reduce to one definition?
//

static WCHAR * kByteToWchar[256] = 
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

typedef struct _METABASE_FILE_DATA
{
    ULONG    ulVersionMinor;
    ULONG    ulVersionMajor;
    FILETIME ftLastWriteTime;

}METABASE_FILE_DATA;

HRESULT
ReadAllDataFromXML(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   LPSTR pszSchemaLocation,
                   BOOL bHaveReadSaveSemaphore
                   );

HRESULT
ReadAllDataFromBin(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   BOOL bHaveReadSaveSemaphore
                   );

HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
               IN LPWSTR              wszPath,
               IN FILETIME*           pFileTime,
               IN BOOL                bUnicode);

HRESULT
SaveMasterRoot(IN CWriter*         pCWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob);

void
LockMetabase(LPWSTR  pwszRealFileName,
             HANDLE* phMetabaseFile);

HRESULT
SaveEntireTree(IN  IIS_CRYPTO_STORAGE*     pCryptoStorage,
               IN  PIIS_CRYPTO_BLOB        pSessionKeyBlob,
               IN  METADATA_HANDLE         hHandle,
               IN  LPWSTR                  pwszSchemaLocation,
               IN  LPWSTR                  pwszSchemaFileName,
               IN  PSECURITY_ATTRIBUTES    psaStorage,
               IN  HANDLE                  hTempFileHandle);

void
DetermineIfMetabaseCanBeRenamed(LPSTR       szRealFileName,
                                HANDLE      hMetabaseFile,
                                BOOL*       pbRenameMetabase);

void
UnlockMetabase(HANDLE*  phMetabaseFile);

HRESULT
SaveMetabaseFile(IN  LPWSTR pwszSchemaFileName,
                 IN  DWORD  ulHistoryMajorVersionNumber,
                 IN  DWORD  dwEnableHistory,
                 IN  DWORD  dwMaxHistoryFiles,
                 IN  DWORD  dwTempLastSaveChangeNumber,
                 IN  BOOL   bRenameMetabase,
                 IN  LPWSTR pwszTempFileName,
                 IN  LPWSTR pwszRealFileName,
                 IN  LPWSTR pwszBackupFileName,
                 IN  LPWSTR pwszBackupLocation,
                 OUT BOOL*  pbDeleteTemp);

HRESULT
SaveTree(IN CWriter*             pCWriter,
         IN CMDBaseObject*       pboRoot,
         IN BUFFER*              pbufParentPath,
         IN IIS_CRYPTO_STORAGE*  pCryptoStorage,
         IN PIIS_CRYPTO_BLOB     pSessionKeyBlob,
         IN BOOL                 bRecurse = TRUE,
         IN BOOL                 bSaveSchema = TRUE,
                 IN BOOL                 bLocalMachine = FALSE);

HRESULT
SaveDataObject(CMDBaseData*        pbdSave,
               CLocationWriter*    pCLocationWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob);

BOOL
DiscontinuousLocation(LPWSTR wszPreviousLocation,
                      LPWSTR wszCurrentLocation);
VOID
SaveGlobalsFromLM(CMDBaseData*  pbdSave);

HRESULT
InitializeGlobalsFromXML(ISimpleTableRead2*    pISTProperty,
                         LPWSTR                wszFileName,
                         IIS_CRYPTO_STORAGE**  ppStorage,
                         LPTSTR                pszPasswd,
                         BOOL                  bSessionKeyOnly = FALSE);

HRESULT
InitializeIIS6GlobalsToDefaults(ULONG  dwPrevSchemaChangeNumber,
                                ULONG  dwSchemaChangeNumber,
                                LPSTR  pszBackupLocation);

HRESULT
SaveGlobalsToXML(CWriter* pCWriter,
                 PIIS_CRYPTO_BLOB    pSessionKeyBlob,
                 bool                bSessionKeyOnly=false);

HRESULT
GetGlobalValue(ISimpleTableRead2*    pISTProperty,
               LPCWSTR               wszName,
               ULONG*                pcbSize,
               LPVOID*               ppVoid);

HRESULT 
GetComputerValue(ISimpleTableRead2* pISTProperty,
                 LPCWSTR            wszName,
                 ULONG*             pcbSize,
                 LPVOID*            ppVoid);

HRESULT
GetValue(ISimpleTableRead2*    pISTProperty,
         LPCWSTR               wszPath,
         DWORD                 dwGroup,
         LPCWSTR               wszName,
         ULONG*                pcbSize,
         LPVOID*               ppVoid);

HRESULT
GetUnicodeNameW(IN  LPWSTR  wszFileName, 
                OUT LPWSTR* pwszFileName);

HRESULT
GetUnicodeNameA(IN  LPSTR   szFileName, 
                OUT LPWSTR* pwszFileName);


HRESULT 
InitEditWhileRunning(ISimpleTableRead2*   pISTProperty);

HRESULT 
InitChangeNumber(ISimpleTableRead2*   pISTProperty);

void
ValidateMaxHistoryFiles();

HRESULT
CreateHistoryFile(LPWSTR               i_wszFileName,
                  LPWSTR               i_wszHistroyFileDir,
                  ULONG                i_cchHistoryFileDir,
                  LPWSTR               i_wszFileNameWithoutPathWithoutExtension,
                  ULONG                i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR               i_wszFileNameExtension,
                  ULONG                i_cchFileNameExtension,
                  ULONG                i_ulHistoryMajorVersionNumber);

HRESULT
CreateHistoryFiles(LPWSTR   wszDataFileName,
                   LPWSTR   wszSchemaFileName,
                   ULONG    ulHistoryMajorVersionNumber,
                   DWORD    dwMaxHistoryFiles);
HRESULT 
CleanupObsoleteHistoryFiles(DWORD i_dwMaxHistoryFiles,
                            ULONG i_ulHistoryMajorVersionNumber);

HRESULT 
DeleteHistoryFile(LPWSTR  i_wszHistroyFileDir,
                  ULONG   i_cchHistoryFileDir,
                  LPWSTR  i_wszFileNameWithoutPathWithoutExtension,
                  ULONG   i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR  i_wszFileNameExtension,
                  ULONG   i_cchFileNameExtension,
                  ULONG   i_ulMajorVersion,
                  ULONG   i_ulMinorVersion);

HRESULT 
SaveSchemaIfNeeded(LPCWSTR              i_wszTempFile,
                   PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

HRESULT 
ReadSchema(IIS_CRYPTO_STORAGE*      i_pStorage,
           FILETIME*                pFileTime);

BOOL 
SchemaTreeInTable(ISimpleTableRead2*    i_pISTProperty);

HRESULT 
CompileIfNeeded(LPWSTR  i_wszDataFileName,
                LPWSTR  i_wszSchemaFileName,
                BOOL*   o_pbSchemaFileNotFound);


HRESULT 
InitializeGlobalISTHelper(BOOL  i_bFailIfBinFileAbsent);

void 
ReleaseGlobalISTHelper();

HRESULT
MatchTimeStamp(LPWSTR i_wszDataFileName,
               LPWSTR i_wszSchemaXMLFileName,
               LPWSTR i_wszSchemaBINFileName,
               BOOL*  o_bMatchTimeStamp);

HRESULT 
ComputeNewHistoryVersionNumber();

BOOL 
WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul);

HRESULT 
UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                LPWSTR i_wszSchemaBinFileName);

HRESULT
GetTimeStamp(LPWSTR    i_wszFile,
             LPWSTR    i_wszPropertyName,
             FILETIME* o_FileTime);

HRESULT 
SetSecurityOnFile(LPWSTR i_wszFileSrc,
                  LPWSTR i_wszFileDest);

void 
ResetMetabaseAttributesIfNeeded(LPTSTR pszMetabaseFile,
                                BOOL   bUnicode);

HRESULT 
LockMetabaseFile(LPWSTR             pwszMetabaseFile,
                 eMetabaseFile      eMetabaseFileType,
                 BOOL               bHaveReadSaveSemaphore);


HRESULT 
UnlockMetabaseFile(eMetabaseFile      eMetabaseFileType,
                   BOOL               bHaveReadSaveSemaphore);

//
// Added By Mohit
//
HRESULT
SaveInheritedOnly(IN CWriter*             i_pCWriter,
                  IN CMDBaseObject*       i_pboRoot,
                  IN BUFFER*              i_pbufParentPath,
                  IN IIS_CRYPTO_STORAGE*  i_pCryptoStorage,
                  IN PIIS_CRYPTO_BLOB     i_pSessionKeyBlob);


#ifdef UNICODE
#define GetUnicodeName  GetUnicodeNameW
#else
#define GetUnicodeName  GetUnicodeNameA
#endif // !UNICODE
 
HRESULT GetObjectFromPath(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. This function just calls GetHandleObject
    and calls the GetObjectFromPathWithHandle function.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    CMDHandle *hHandleObject = GetHandleObject(hHandle);

    if (hHandleObject == NULL) {
        return E_HANDLE;
    }

    return GetObjectFromPathWithHandle(rpboReturn,
                                       hHandle,
                                       hHandleObject,
                                       dwPermissionNeeded,
                                       strPath,
                                       bUnicode);
        
}
             
HRESULT GetObjectFromPathWithHandle(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN CMDHandle       *HandleObject,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. Updates Path to point past the last
    object found if the whole path is not found. If the entire path
    is not found, the last object found is returned.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *pboCurrent, *pboPrevious;
    LPTSTR strCurPath = strPath;
    
    rpboReturn = NULL;

    if ((((dwPermissionNeeded & METADATA_PERMISSION_WRITE) != 0) && (!HandleObject->IsWriteAllowed())) ||
        (((dwPermissionNeeded & METADATA_PERMISSION_READ) != 0) && (!HandleObject->IsReadAllowed()))) {
        hresReturn = E_ACCESSDENIED;
    }
    else {
        pboCurrent = HandleObject->GetObject();
        MD_ASSERT(pboCurrent != NULL);
        strCurPath = strPath;

        if (strCurPath != NULL) {
            SkipPathDelimeter(strCurPath, bUnicode);
            while ((pboCurrent != NULL) &&
                (!IsStringTerminator(strCurPath, bUnicode))) {
                pboPrevious = pboCurrent;
                //
                // GetChildObject increments strCurPath on success
                // and returns NULL if child not found
                //
                pboCurrent = pboCurrent->GetChildObject(strCurPath, &hresReturn, bUnicode);
                if (FAILED(hresReturn)) {
                    break;
                }
                if (pboCurrent != NULL) {
                    SkipPathDelimeter(strCurPath, bUnicode);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ((strCurPath == NULL) ||
                IsStringTerminator(strCurPath, bUnicode)) {  // Found the whole path
                rpboReturn = pboCurrent;
                hresReturn = ERROR_SUCCESS;
            }
            else {           //return last object found and an error code
                rpboReturn = pboPrevious;
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                strPath = strCurPath;
            }
        }
    }

    return (hresReturn);
}

HRESULT AddObjectToDataBase(
         IN METADATA_HANDLE hHandle,
         IN CMDHandle       *hHandleObject,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Creates and adds one or more objects to the metabase. Finds the deepest object
    pointed to by Handle/Path and creates any subobject specified by path.

Arguments:

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_NOT_ENOUGH_MEMORY
             ERROR_INVALID_NAME

Notes:

--*/
{
    HRESULT hresReturn=ERROR_SUCCESS;
    CMDBaseObject *pboParent;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    HRESULT hresExtractRetCode = ERROR_SUCCESS;

    hresReturn = GetObjectFromPathWithHandle(pboParent,
                                             hHandle,
                                             hHandleObject,
                                             METADATA_PERMISSION_WRITE,
                                             strTempPath,
                                             bUnicode);

    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strPath set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) &&
        pboParent) {
        MD_ASSERT(pboParent != NULL);
        for (hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
            SUCCEEDED(hresExtractRetCode);
            hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                break;
            }
            else {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete (pboNew);
                    break;
                }
                else {
                    pboParent = pboNew;
                    PREFIX_ASSUME(GetHandleObject(hHandle) != NULL, "GetHandleObject(hHandle) is guaranteed not to return NULL");
                    GetHandleObject(hHandle)->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }
    if (hresExtractRetCode == RETURNCODETOHRESULT(ERROR_INVALID_NAME)) {
        hresReturn = hresExtractRetCode;
    }
    return(hresReturn);
}

HRESULT RemoveObjectFromDataBase(
         IN METADATA_HANDLE hHandle,
         IN CMDHandle *hHandleObject,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a metaobject and all subobjects from the database.

Arguments:

    Handle - The Meta Data handle. A handle returned by MDOpenMetaObject with write permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND
             ERROR_INVALID_PARAMETER

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboDelete;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    //
    // Make sure that a valid path was specified
    //
    SkipPathDelimeter(strTempPath, bUnicode);
    hresReturn = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
    if (FAILED(hresReturn)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        strTempPath = strPath;
        hresReturn = GetObjectFromPathWithHandle(pboDelete,
                                       hHandle,
                                       hHandleObject,
                                       METADATA_PERMISSION_WRITE,
                                       strTempPath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = (pboDelete->GetParent())->RemoveChildObject(pboDelete);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(GetHandleObject(hHandle) != NULL);
                if (GetHandleObject(hHandle)->SetChangeData(pboDelete, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboDelete);
                }
            }
        }
    }
    return(hresReturn);
}

CMDHandle *GetHandleObject(
         IN METADATA_HANDLE hHandle)
/*++

Routine Description:

    Gets the handle object associated with Handle.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

Return Value:

    CMDHandle * - The handle object, or NULL if not found.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    for (hoCurrent = g_phHandleHead;
        (hoCurrent != NULL) && (hoCurrent->GetHandleIdentifier() != hHandle);
        hoCurrent = hoCurrent->GetNextPtr()) {
    }
    return (hoCurrent);
}

BOOL
PermissionsAvailable(
         IN CMDBaseObject *pboTest,
         IN DWORD dwRequestedPermissions,
         IN DWORD dwReadThreshHold
         )
/*++

Routine Description:

    Checks if the requested handle permissions are available for a meta object.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

    RequestedPermissions - The permissions requested.

    ReadThreshHold - The number of reads allows on a write request. Normally 0.

Return Value:

    BOOL   - TRUE if the permissions are available.

Notes:

--*/
{
    BOOL bResults = TRUE;
    CMDBaseObject *pboCurrent;
    MD_ASSERT(pboTest != NULL);
    if (dwRequestedPermissions & METADATA_PERMISSION_WRITE) {
        if ((pboTest->GetReadPathCounter() != 0) ||
            (pboTest->GetWritePathCounter() != 0)) {
            bResults = FALSE;
        }
        if ((pboTest->GetReadCounter() > dwReadThreshHold) || (pboTest->GetWriteCounter() != 0)) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest->GetParent();bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if ((pboCurrent->GetReadCounter() != 0) || (pboCurrent->GetWriteCounter() != 0)) {
                bResults = FALSE;
            }
        }
    }
    else if (dwRequestedPermissions & METADATA_PERMISSION_READ) {
        if (pboTest->GetWritePathCounter() != 0) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest;bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if (pboCurrent->GetWriteCounter() != 0) {
                bResults = FALSE;
            }
        }
    }
    else {
        MD_ASSERT(FALSE);
    }
    return (bResults);
}

VOID RemovePermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRemovePermissions
         )
/*++

Routine Description:

    Removes the handle permissions from a meta object.

Arguments:

    Affected - The object to remove permissions from.

    RemovePermissions - The permissions to remove.

Return Value:

Notes:

--*/
{
    MD_ASSERT(pboAffected != NULL);
    CMDBaseObject *pboCurrent;
    if ((dwRemovePermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->DecrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementWritePathCounter();
        }
    }
    if ((dwRemovePermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->DecrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementReadPathCounter();
        }
    }
    
#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRemovePermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms releasted (%d) on ");
        cchSz = strlen(szBuf);
    
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
    
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
    
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

VOID
AddPermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRequestedPermissions
         )
/*++

Routine Description:

    Adds handle permissions to a meta object.

Arguments:

    Affected - The object to remove permissions from.

    ReqyestedPermissions - The permissions to add.

Return Value:

Notes:

--*/
{
    CMDBaseObject *pboCurrent;
    if (((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) &&
        ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0)) {
        pboAffected->IncrementWriteCounter();
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
            pboCurrent->IncrementReadPathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->IncrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRequestedPermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms obtained (%d) on ");
        cchSz = strlen(szBuf);
        
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
        
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
        
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

HRESULT
AddHandle(
         IN CMDBaseObject *pboAssociated,
         IN DWORD dwRequestedPermissions,
         IN METADATA_HANDLE &rmhNew,
         IN BOOLEAN bSchemaKey
         )
/*++

Routine Description:

    Creates a handle object and adds it to the handle list.

Arguments:

    Handle - The object the handle is associated with.

    RequestedPermissions - The permissions for the handle.

    New - The handle id.

Return Value:
    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoNew = new CMDHandle(pboAssociated,
                                     dwRequestedPermissions,
                                     g_dwSystemChangeNumber,
                                     g_mhHandleIdentifier++,
                                     bSchemaKey);
    if (hoNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        rmhNew = hoNew->GetHandleIdentifier();
        hoNew->SetNextPtr(g_phHandleHead);
        g_phHandleHead = hoNew;
        AddPermissions(pboAssociated, dwRequestedPermissions);
    }
    return(hresReturn);
}

CMDHandle *
RemoveHandleObject(
         IN METADATA_HANDLE mhHandle
         )
/*++

Routine Description:

    Removes a handle object from the handle list.

Arguments:

    Handle - The handle to be removed.

Return Value:

    CMDHandle * - The Handle object removed.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    CMDHandle *hoReturn;

    if (g_phHandleHead->GetHandleIdentifier() == mhHandle) {
        hoReturn = g_phHandleHead;
        g_phHandleHead = g_phHandleHead->GetNextPtr();
    }
    else {
        for (hoCurrent = g_phHandleHead;(hoCurrent->GetNextPtr() != NULL) &&
            (hoCurrent->GetNextPtr()->GetHandleIdentifier() != mhHandle);
            hoCurrent = hoCurrent->GetNextPtr()) {
        }
        hoReturn = hoCurrent->GetNextPtr();
        if (hoCurrent->GetNextPtr() != NULL) {
            MD_ASSERT (hoCurrent->GetNextPtr()->GetHandleIdentifier() == mhHandle);
            hoCurrent->SetNextPtr(hoCurrent->GetNextPtr()->GetNextPtr());
        }
    }
    return (hoReturn);
}

HRESULT
SaveDataObject(HANDLE hFileHandle,
               CMDBaseData *pbdSave,
               PBYTE pbLineBuf,
               DWORD dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save a data object.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Save       - The data object to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL bGoodData = TRUE;
    int iStringLen;
    PBYTE pbData;
    DWORD dwTemp;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        *pbLineBuf = MD_ID_DATA;

        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            pbLineBuf,
                            pbrNextPtr,
                            1,
                            FALSE);

        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetIdentifier();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetAttributes();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetUserType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetDataType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {
                    PIIS_CRYPTO_BLOB blob;

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData( &blob,
                                                              pbdSave->GetData(TRUE),
                                                              pbdSave->GetDataLen(TRUE),
                                                              0);

                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = WriteLine(hFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE)blob,
                                            pbrNextPtr,
                                            IISCryptoGetBlobLength(blob),
                                            TRUE);

                        ::IISCryptoFreeBlob(blob);
                    }
                } else {
                    hresReturn = WriteLine(hFileHandle,
                                        dwWriteBufSize,
                                        pbWriteBuf,
                                        (PBYTE)pbdSave->GetData(TRUE),
                                        pbrNextPtr,
                                        pbdSave->GetDataLen(TRUE),
                                        TRUE);
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
SaveMasterRoot(HANDLE hFileHandle,
               PBYTE pbLineBuf,
               DWORD  dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

    FileHandle - File handle for use by WriteLine.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    PFILETIME pftTime;

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    *pbLineBuf = MD_ID_ROOT_OBJECT;

    hresReturn = WriteLine(hFileHandle,
                        dwWriteBufSize,
                        pbWriteBuf,
                        pbLineBuf,
                        pbrNextPtr,
                        1,
                        FALSE);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            (PBYTE)pftTime,
                            pbrNextPtr,
                            sizeof(FILETIME),
                            TRUE);
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
        hresReturn = SaveDataObject(hFileHandle,
                                 dataAssociatedData,
                                 pbLineBuf,
                                 dwWriteBufSize,
                                 pbWriteBuf,
                                 pbrNextPtr,
                                 pCryptoStorage
                                 );
    }

    return(hresReturn);
}

HRESULT
SaveTree(
         IN HANDLE hFileHandle,
         IN CMDBaseObject *pboRoot,
         IN PBYTE pbLineBuf,
         IN BUFFER *pbufParentPath,
         IN DWORD  dwWriteBufSize,
         IN PBYTE pbWriteBuf,
         IN OUT PBYTE &pbrNextPtr,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage
         )
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Root       - The root of the tree to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            pftTime = pboRoot->GetLastChangeTime();

            *pbLineBuf = MD_ID_OBJECT;

            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                pbLineBuf,
                                pbrNextPtr,
                                1,
                                FALSE);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE)pftTime,
                                    pbrNextPtr,
                                    sizeof(FILETIME),
                                    FALSE);
            }

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE) strParentPath,
                                    pbrNextPtr,
                                    (dwNewParentPathLen) * sizeof(WCHAR),
                                    TRUE);
            }

            if (SUCCEEDED(hresReturn)) {

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                    hresReturn = SaveDataObject(hFileHandle,
                                             dataAssociatedData,
                                             pbLineBuf,
                                             dwWriteBufSize,
                                             pbWriteBuf,
                                             pbrNextPtr,
                                             pCryptoStorage
                                             );
                }

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hFileHandle,
                                       objChildObject,
                                       pbLineBuf,
                                       pbufParentPath,
                                       dwWriteBufSize,
                                       pbWriteBuf,
                                       pbrNextPtr,
                                       pCryptoStorage
                                       );
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

    return(hresReturn);
}

/*
HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN LPSTR pszBackupLocation,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore
         )
++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBYTE pbLineBuf = NULL;
    PBYTE pbWriteBuf = NULL;
    PBYTE pbNextPtr = NULL;
    BUFFER *pbufParentPath = new BUFFER(0);
    DWORD  dwWriteBufSize = READWRITE_BUFFER_LENGTH;
    HANDLE hTempFileHandle;
    CMDBaseObject *objChildObject;
    DWORD dwEnumObjectIndex;
    DWORD dwStringLen;
    BOOL bDeleteTemp = TRUE;
    DWORD dwTemp = ERROR_SUCCESS;
    DWORD dwTempLastSaveChangeNumber;
    BOOL  bSaveNeeded = FALSE;
    LPTSTR strRealFileName;    
    LPTSTR strTempFileName = g_strTempFileName->QueryStr();
    LPTSTR strBackupFileName = g_strBackupFileName->QueryStr();

    if( !pszBackupLocation )
    {
        strRealFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        strRealFileName = pszBackupLocation;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    if (!g_bSaveDisallowed) {
        g_bSaveDisallowed = bSetSaveDisallowed;
        pbLineBuf = new BYTE[MAX_RECORD_BUFFER];
        for ((pbWriteBuf = new BYTE[dwWriteBufSize]);
            (pbWriteBuf == NULL) && ((dwWriteBufSize/=2) >= MAX_RECORD_BUFFER);
            pbWriteBuf = new BYTE[dwWriteBufSize]) {
        }
        if ((pbWriteBuf == NULL) || (pbLineBuf == NULL)
            || (pbufParentPath == NULL) || (!pbufParentPath->Resize(MD_MAX_PATH_LEN))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // Write to a temp file first in case there are errors.
            //

            SECURITY_ATTRIBUTES saStorage;
            PSECURITY_ATTRIBUTES psaStorage = NULL;

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            hTempFileHandle = CreateFile(strTempFileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         psaStorage,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         0);
            if (hTempFileHandle == INVALID_HANDLE_VALUE) {
                DWORD dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
            else {
                g_rMasterResource->Lock(TSRES_LOCK_READ);

                //
                // Only Save if changes have been made since the last save.
                //

                if ( pszBackupLocation || g_dwLastSaveChangeNumber != g_dwSystemChangeNumber ) 
                {

                    bSaveNeeded = TRUE;

                    if (hHandle != METADATA_MASTER_ROOT_HANDLE) {
                        CMDHandle *phoHandle;
                        phoHandle = GetHandleObject(hHandle);
                        if ((phoHandle == NULL) || (phoHandle->GetObject() != g_pboMasterRoot)) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                        }
                        else if ((!phoHandle->IsReadAllowed()) && (!phoHandle->IsWriteAllowed())) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
                        ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)L'\0';
                        pbNextPtr = pbWriteBuf;
                        hresReturn = WriteLine(hTempFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE) MD_SIGNATURE_STRINGW,
                                            pbNextPtr,
                                            sizeof(MD_SIGNATURE_STRINGW),
                                            TRUE);
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MAJOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMajorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MINOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMinorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf =  MD_ID_CHANGE_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwSystemChangeNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            //
                            // Write the session key blob to the file.
                            //
                            *pbLineBuf =  MD_ID_SESSION_KEY;
                            memcpy((PCHAR)pbLineBuf+1, (PCHAR)pSessionKeyBlob, IISCryptoGetBlobLength(pSessionKeyBlob));
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + IISCryptoGetBlobLength(pSessionKeyBlob),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SaveMasterRoot( hTempFileHandle,
                                                         pbLineBuf,
                                                         dwWriteBufSize,
                                                         pbWriteBuf,
                                                         pbNextPtr,
                                                         pCryptoStorage
                                                         );

                            for(dwEnumObjectIndex=0,objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++);
                                (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                                objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++)) {
                                    hresReturn = SaveTree( hTempFileHandle,
                                                           objChildObject,
                                                           pbLineBuf,
                                                           pbufParentPath,
                                                           dwWriteBufSize,
                                                           pbWriteBuf,
                                                           pbNextPtr,
                                                           pCryptoStorage
                                                           );
                            }
                        }
                        else
                        {
                            // failed to write out session key!
                            // pretty serious.
                            DBGPRINTF(( DBG_CONTEXT, "SaveAllData:Failed to write out Session Key - error 0x%0x\n", hresReturn));
                        }
                    }

                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

                }

                //
                // Release lock before writing to file.
                //

                g_rMasterResource->Unlock();

                if (bSaveNeeded && SUCCEEDED(hresReturn)) {

                    hresReturn = FlushWriteBuf(hTempFileHandle,
                                           pbWriteBuf,
                                           pbNextPtr);
                }


                //
                // FlushFileBuffers was added trying to solve 390968 when metabase
                // sometimes becomes corrupted during resets.  That should ensure that data
                // is already on the disk when doing later MoveFile operations
                //
                
                if (!FlushFileBuffers (hTempFileHandle)) {
                    hresReturn = GetLastError();
                    DBGPRINTF(( DBG_CONTEXT, "Failed FlushFileBuffers - error 0x%0x\n", hresReturn));
                }

                //
                // Always close the file handle
                //

                if (!CloseHandle(hTempFileHandle)) {
                    hresReturn = GetLastError();
                }

            }
            if (SUCCEEDED(hresReturn) && bSaveNeeded) {
                //
                // New data file created successfully
                // Backup real file and copy temp
                // to real
                //
                if (!MoveFile(strTempFileName, strRealFileName)) {
                    if (GetLastError() != ERROR_ALREADY_EXISTS) {
                        dwTemp = GetLastError();
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    //
                    // Real File exists, so back it up
                    //
                    else if (!MoveFile(strRealFileName, strBackupFileName)) {
                        //
                        // backup failed, check for old backup file
                        //
                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            dwTemp = GetLastError();
                        }
                        else if (!DeleteFile(strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        else if (!MoveFile(strRealFileName, strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    if (SUCCEEDED(hresReturn)) {
                        BOOL bDeleteBackup = TRUE;
                        //
                        // Real file is backed up
                        // so move in new file
                        //
                        if (!MoveFile(strTempFileName, strRealFileName)) {
                            dwTemp = GetLastError();
                            hresReturn = RETURNCODETOHRESULT(dwTemp);
                            //
                            // Moved real to backup but
                            // failed to move temp to real
                            // so restore from backup
                            //
                            if (!MoveFile(strBackupFileName, strRealFileName)) {
                                //
                                // Unable to write new file
                                // or restore original file so don't delete backup
                                //
                                bDeleteBackup = FALSE;
                            }
                        }
                        if (bDeleteBackup) {
                            DeleteFile(strBackupFileName);
                        }
                    }
                    if (FAILED(hresReturn)) {
                        //
                        // temp file was created ok but a problem
                        // occurred while moving it to real
                        // so don't delete it
                        //
                        bDeleteTemp = FALSE;
                    }
                    else {

                        //
                        // Update Change Number
                        // Must have ReadSaveSemaphore when accessing this.
                        //

                        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
                    }
                }
            }
            if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) {
                DeleteFile(strTempFileName);
            }
        }
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( pbufParentPath != NULL ) {
        delete(pbufParentPath);
    }

    if ( pbWriteBuf != NULL ) {
        delete(pbWriteBuf);
    }

    if ( pbLineBuf != NULL ) {
        delete(pbLineBuf);
    }

    if ( FAILED( hresReturn )) {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    } else {
        //DBGPRINTF(( DBG_CONTEXT, "Successfully flushed metabase to disk\n" ));
    }

    return hresReturn;
}
*/

DWORD
DeleteKeyFromRegistry(HKEY hkeyParent,
                      LPTSTR pszCurrent)
/*++

Routine Description:

    Deletes a key and all data and subkeys from the registry.

    RECURSIVE ROUTINE! DO NOT USE STACK!

Arguments:

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn;
    LPTSTR pszName;

    MDRegKey *pmdrkCurrent = new MDRegKey(hkeyParent,
                                          pszCurrent);
    if (pmdrkCurrent == NULL) {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        dwReturn = GetLastError();
    }
    if (dwReturn == ERROR_SUCCESS) {
        MDRegKeyIter *pmdrkiCurrent = new MDRegKeyIter(*pmdrkCurrent);
        if (pmdrkiCurrent == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            dwReturn = GetLastError();
        }
        while ((dwReturn == ERROR_SUCCESS) &&
            (dwReturn = pmdrkiCurrent->Next(&pszName, NULL, 0)) == ERROR_SUCCESS) {
            dwReturn = DeleteKeyFromRegistry(*pmdrkCurrent,
                                              pszName);
        }
        delete (pmdrkiCurrent);
        if (dwReturn == ERROR_NO_MORE_ITEMS) {
            dwReturn = ERROR_SUCCESS;
        }
    }
    delete (pmdrkCurrent);

    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(hkeyParent,
                                pszCurrent);
    }
    return dwReturn;
}

HRESULT
ReadMetaObject(
         IN CMDBaseObject *&cboRead,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Read       - Place to return the created object.

    ObjectLine - The object info.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboParent;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    FILETIME ftTime;
    PFILETIME pftParentTime;
    FILETIME ftParentTime;
    PBYTE pbLine = (PBYTE)pbufLine->QueryPtr();
    LPTSTR strObjectName;

    if ((dwLineLen <= BASEMETAOBJECTLENGTH) || (*(pbLine + dwLineLen - 1) != '\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        ftTime = *(UNALIGNED FILETIME *)(pbLine + 1);
        //
        // GetObjectFromPath checks permissions on the handle
        // This only gets called from init so just tell it read.
        //
        strObjectName = (LPTSTR)(pbLine + BASEMETAOBJECTLENGTH);

        if (bUnicode != FALSE) {

            PCUWSTR strObjectNameUnaligned;
            PCWSTR strObjectNameAligned;

            //
            // Generate an aligned copy of the string
            //

            strObjectNameUnaligned = (PCUWSTR)strObjectName;

            WSTR_ALIGNED_STACK_COPY(&strObjectNameAligned,
                                    strObjectNameUnaligned);

            strObjectName = (LPTSTR)strObjectNameAligned;
        }
        hresReturn = GetObjectFromPath(pboParent,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    METADATA_PERMISSION_READ,
                                    strObjectName,
                                    bUnicode);

        //
        // This should return ERROR_PATH_NOT_FOUND and the parent object,
        // with strObjectLine set to the remainder of the path,
        // which should be the child name, without a preceding delimeter.
        //

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            MD_ASSERT(pboParent != NULL);
            if (bUnicode) {
                hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
            }
            else {
                hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
            }
            if (SUCCEEDED(hresReturn)) {
                CMDBaseObject *pboNew;
                if (bUnicode) {
                    pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
                }
                else {
                    pboNew = new CMDBaseObject((LPSTR)strName, NULL);
                }
                if (pboNew == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else if (!pboNew->IsValid()) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    delete (pboNew);
                }
                else {
                    //
                    // InsertChildObject sets the last change time to current time.
                    // This isn't really a change, so save and restore time.
                    //
                    pftParentTime = pboParent->GetLastChangeTime();
                    ftParentTime = *pftParentTime;
                    hresReturn = pboParent->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        pboParent->SetLastChangeTime(&ftParentTime);
                        pboNew->SetLastChangeTime(&ftTime);
                        cboRead = pboNew;
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }
        }
        else if (SUCCEEDED(hresReturn)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
        }
    }
    return (hresReturn);
}

HRESULT
ReadDataObject(
         IN CMDBaseObject *cboAssociated,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    DataLine   - The data info.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataLine = (PBYTE)pbufLine->QueryPtr();
    PBYTE pbDataValue;
    STACK_BUFFER( bufAlignedValue, 256 );
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    if (dwLineLen < DATAOBJECTBASESIZE) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        MD_ASSERT(pbufLine->QuerySize() >= DATAOBJECTBASESIZE);
        mdrData.dwMDIdentifier = *(UNALIGNED DWORD *)(pbDataLine + 1);
        mdrData.dwMDAttributes = *(UNALIGNED DWORD *)(pbDataLine + 1 + sizeof(DWORD));
        mdrData.dwMDUserType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (2 * sizeof(DWORD)));
        mdrData.dwMDDataType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (3 * sizeof(DWORD)));

        pbDataValue = pbDataLine + DATAOBJECTBASESIZE;
        dwDataLength = dwLineLen - DATAOBJECTBASESIZE;

        if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
            pCryptoStorage != NULL) {

            //
            // This is a secure data object, we we'll need to decrypt it
            // before proceeding. Note that we must clone the blob before
            // we can actually use it, as the blob data in the line buffer
            // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
            // the only IISCrypto function that can handle unaligned data.)
            //

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));
                hresReturn = pCryptoStorage->DecryptData(
                                   (PVOID *)&pbDataValue,
                                   &dwDataLength,
                                   &dummyRegType,
                                   blob
                                   );
            }

        } else {

            //
            // The metadata was not secure, so decryption was not required.
            // Nonetheless, it must be copied to an aligned buffer... 
            //

            if( !bufAlignedValue.Resize( dwDataLength ) )
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                memcpy( bufAlignedValue.QueryPtr(), pbDataValue, dwDataLength );
                pbDataValue = ( PBYTE )bufAlignedValue.QueryPtr();
            }
         }

        if (SUCCEEDED(hresReturn)) {
            mdrData.pbMDData = pbDataValue;

            switch (mdrData.dwMDDataType) {
                case DWORD_METADATA: {
                    if (dwDataLength != sizeof(DWORD)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if ((LONG)dwDataLength < 1 ||
                        (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                        (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)L'\0')) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case BINARY_METADATA:
                {
                    mdrData.dwMDDataLen = dwDataLength;
                    break;
                }
                case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        if (dwDataLength < (2 * sizeof(WCHAR)) ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)L'\0' ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)L'\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    else {
                        if (dwDataLength < 2 ||
                            pbDataValue[dwDataLength-1] != '\0' ||
                            pbDataValue[dwDataLength-2] != '\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        mdrData.dwMDDataLen = dwDataLength;
                    }
                    break;
                }
                default: {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}

HRESULT
FlushWriteBuf(HANDLE hWriteFileHandle,
              PBYTE pbWriteBuf,
              PBYTE &pbrNextPtr)
/*++

Routine Description:

    Flush the write buffer to the file.

Arguments:

    FileHandle - File handle to write to.

    WriteBuf   - Buffer to write to file.

    NextPtr    - Pointer past end of buffer.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesWritten;
    if (pbrNextPtr > pbWriteBuf) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       DIFF((BYTE *)pbrNextPtr - (BYTE *)pbWriteBuf),
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

BOOL
CopyLineWithEscapes(PBYTE &pbrFileBuf,
                    DWORD &dwrFileBufLen,
                    PBYTE &pbrLineBuf,
                    DWORD &dwrLineBufLen,
                    BOOL  &brMidEscape)
    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbrFileBuf, dwrFileBufLen, brMidEscape
    // FAILURE: pbrLineBuf, dwrLineBufLen, brMidEscape
    // On FAILURE, it fills to the end of the buffer
    //
{
    BOOL bReturn = TRUE;
    PBYTE pbFileBufEnd = pbrFileBuf + dwrFileBufLen;
    PBYTE pbLineBufEnd = pbrLineBuf + dwrLineBufLen;
    PBYTE pbFileBufIndex = pbrFileBuf;
    PBYTE pbLineBufIndex = pbrLineBuf;

    brMidEscape = FALSE;

    while ((pbLineBufIndex < pbLineBufEnd) && (pbFileBufIndex < (pbFileBufEnd - 1))) {
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
        }
        *pbFileBufIndex++ = *pbLineBufIndex++;
    }
    if ((pbLineBufIndex != pbLineBufEnd) && (pbFileBufIndex < pbFileBufEnd)) {
        MD_ASSERT(pbFileBufIndex == (pbFileBufEnd - 1));
        //
        // file last byte in buffer
        //
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
            brMidEscape = TRUE;
        }
        else {
            *pbFileBufIndex++ = *pbLineBufIndex++;
        }
    }
    if (pbLineBufIndex != pbLineBufEnd) {
        bReturn = FALSE;
        pbrLineBuf = pbLineBufIndex;
        dwrLineBufLen = DIFF(pbLineBufEnd - pbLineBufIndex);
    }
    else {
        pbrFileBuf = pbFileBufIndex;
        dwrFileBufLen = DIFF(pbFileBufEnd - pbFileBufIndex);
    }

    return bReturn;
}


HRESULT
WriteLine(HANDLE hWriteFileHandle,
          DWORD  dwWriteBufSize,
          PBYTE  pbWriteBuf,
          PBYTE  pbLineBuf,
          PBYTE  &pbNextPtr,
          DWORD  dwLineLen,
          BOOL   bTerminate)
/*++

Routine Description:

    Write a line. Performs buffered writes to a file. Does not append \n.
    The string does not need to be terminated with \0.

Arguments:

    FileHandle - File to write to.

    WriteBufSize - Buffer size.

    WriteBuf   - Buffer to store data in.

    LineBuf    - The line buffer with data to write.

    NextPtr    - Pointer to the next unused character in WriteBuf.

    Len        - The number of characters to write.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    PBYTE pbWriteBufEnd = pbWriteBuf + dwWriteBufSize;
    DWORD dwBufferBytesLeft = DIFF(pbWriteBufEnd - pbNextPtr);
    DWORD dwBytesWritten;
    BOOL  bMidEscape;

    MD_ASSERT(pbLineBuf != NULL);
    MD_ASSERT(pbWriteBuf != NULL);
    MD_ASSERT((pbNextPtr >= pbWriteBuf) && (pbNextPtr <= pbWriteBufEnd));

    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbNextPtr, dwBufferBytesLeft
    // FAILURE: pbLineBuf, dwLineLen, bMidEscape
    // On FAILURE, it fills to the end of the buffer
    //

    while ((dwReturn == ERROR_SUCCESS) &&
        (!CopyLineWithEscapes(pbNextPtr, dwBufferBytesLeft, pbLineBuf, dwLineLen, bMidEscape))) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       dwWriteBufSize,
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
        dwBufferBytesLeft = dwWriteBufSize;
        pbNextPtr = pbWriteBuf;
        if (bMidEscape) {
            *pbNextPtr++ = *pbLineBuf++;
            dwBufferBytesLeft--;
            dwLineLen--;
        }
    }
    if (bTerminate && (dwReturn == ERROR_SUCCESS)) {
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_ESCAPE_BYTE;
        dwBufferBytesLeft--;
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_TERMINATE_BYTE;
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

PBYTE
FindEndOfData(PBYTE pbNextPtr,
              PBYTE pbEndReadData,
              BOOL bEscapePending)
{
    PBYTE pbIndex = pbNextPtr;
    BOOL bEndFound = FALSE;

    if ((pbEndReadData > pbIndex) && bEscapePending) {
        if (*pbIndex == MD_TERMINATE_BYTE) {
            bEndFound = TRUE;
        }
        pbIndex++;
    }
    while ((pbEndReadData -1 > pbIndex) && !bEndFound) {
        if (*pbIndex == MD_ESCAPE_BYTE) {
            pbIndex++;
            if (*pbIndex == MD_TERMINATE_BYTE) {
                bEndFound = TRUE;
            }
        }
        pbIndex++;
    }
    if (!bEndFound) {
        MD_ASSERT(pbIndex == pbEndReadData - 1);
        pbIndex++;
    }
    return pbIndex;
}

DWORD
GetLineFromBuffer(PBYTE &pbrNextPtr,
                  PBYTE &pbrEndReadData,
                  BUFFER *pbufLine,
                  DWORD &dwrLineLen,
                  BOOL &brEscapePending)
    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //
{
    DWORD dwReturn = ERROR_HANDLE_EOF;
    PBYTE pbLineIndex;
    DWORD dwBytesToRead;
    PBYTE pbEndReadLine;
    PBYTE pbReadDataIndex = pbrNextPtr;

    DBGINFO((DBG_CONTEXT,
             "Entering GeLineFromBuffer, pbrNextPtr = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    if (pbrNextPtr != pbrEndReadData) {
        //
        // first find out how many bytes we need to read
        //
        pbEndReadLine = FindEndOfData(pbrNextPtr, pbrEndReadData, brEscapePending);
        MD_ASSERT(pbEndReadLine > pbrNextPtr);

        //
        // Actual number of bytes needed may be less than the size of the data
        // but never more, so just resize for the max we might need
        //
        if (!pbufLine->Resize(dwrLineLen + DIFF(pbEndReadLine - pbrNextPtr))) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pbLineIndex = (PBYTE)pbufLine->QueryPtr() + dwrLineLen;
            if (brEscapePending) {
                brEscapePending = FALSE;
                if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                    dwReturn = ERROR_SUCCESS;
                    pbReadDataIndex++;
                }
            }
            while ((dwReturn != ERROR_SUCCESS) && (pbReadDataIndex < pbEndReadLine)) {
                if (*pbReadDataIndex != MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    pbReadDataIndex++;
                    if (pbReadDataIndex == pbEndReadLine) {
                        brEscapePending = TRUE;
                    }
                    else {
                        if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                            *pbLineIndex++ = *pbReadDataIndex++;
                        }
                        else {
                            MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                            pbReadDataIndex++;
                            dwReturn = ERROR_SUCCESS;
                        }
                    }
                }
            }
            dwrLineLen = DIFF(pbLineIndex - (PBYTE)pbufLine->QueryPtr());
            pbrNextPtr = pbReadDataIndex;
        }
    }

    DBGINFO((DBG_CONTEXT,
             "Leaving GeLineFromBuffer, pbrNextPter = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    return dwReturn;
}

HRESULT
GetNextLine(
         IN HANDLE hReadFileHandle,
         IN OUT PBYTE &pbrEndReadData,
         IN BUFFER *pbufRead,
         IN OUT BUFFER *pbufLine,
         IN OUT DWORD &dwrLineLen,
         IN OUT PBYTE &pbrNextPtr)
/*++

Routine Description:

    Get the next line. Performs buffered reads from a file. Only pbrCurPtr may be modified between calls.
    Other variables must be set up before the first call and not changed.

Arguments:

    ReadFileHandle - File to write to.

    EndReadDataPtr - Points past the end of the data in ReadBuf.

    Read       - Buffer for file data.

    Line       - A line buffer which the returned line is stored in.

    LineLen    - The length of the data in line

    NextPtr    - On entry, pointer to the next unread character in ReadBuf.
                 On exit, pointer to the new next unread character in ReadBuf.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_INVALID_DATA
                 Return codes from file system

Notes:
    On EOF, returns ERROR_SUCCESS, dwrLineLen = 0.

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwLineLen = 0;
    BOOL bEscapePending = FALSE;
    DWORD dwGetLineReturn = ERROR_HANDLE_EOF;
    BOOL bEOF = FALSE;

    DBGINFO((DBG_CONTEXT,
             "Entering GetNextLine, pbrNextPtr = %p, pbrEndReadData = %p\n",
             pbrNextPtr,
             pbrEndReadData));

    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //

    while ((dwReturn == ERROR_SUCCESS) && (dwGetLineReturn == ERROR_HANDLE_EOF) && (!bEOF)) {

        DBGINFO((DBG_CONTEXT,
                 "GetNextLine calling GetLineFromBuffer, pbrNextPtr = %p, pbrEndReadData = %p\n",
                 pbrNextPtr,
                 pbrEndReadData));

        dwGetLineReturn = GetLineFromBuffer(pbrNextPtr,
                                            pbrEndReadData,
                                            pbufLine,
                                            dwLineLen,
                                            bEscapePending);

        if (dwGetLineReturn == ERROR_HANDLE_EOF) {
            DBGINFO((DBG_CONTEXT,
                     "GetNextLine calling ReadFile\n"));

            if (!ReadFile(hReadFileHandle,
                          (LPVOID) pbufRead->QueryPtr(),
                          pbufRead->QuerySize(),
                          &dwBytesRead,
                          NULL)) {
                dwReturn = GetLastError();
            }
            else {
                pbrEndReadData = (BYTE *)pbufRead->QueryPtr() + dwBytesRead;
                pbrNextPtr = (PBYTE)pbufRead->QueryPtr();

                DBGINFO((DBG_CONTEXT,
                         "GetNextLine after call to ReadFile, pbrNextPter = %p, pbrEndReadData = %p\n",
                         pbrNextPtr,
                         pbrEndReadData));

                if (dwBytesRead == 0) {
                    bEOF = TRUE;
                }
            }
        }
    }
    if (bEOF) {
        MD_ASSERT(dwGetLineReturn = ERROR_HANDLE_EOF);
        dwLineLen = 0;
    }
    else if (dwGetLineReturn != ERROR_SUCCESS) {
        dwReturn = dwGetLineReturn;
    }

    dwrLineLen = dwLineLen;
    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
GetLineID(
         IN OUT LPTSTR &strCurPtr)
/*++

Routine Description:

    Determines the ID of a line from the metadata file.

Arguments:

    CurPtr     - The line to ID. Updated on successful ID to point past
                 the id string.

Return Value:

    DWORD      - MD_ID_OBJECT
                 MD_ID_DATA
                 MD_ID_REFERENCE
                 MD_ID_ROOT_OBJECT
                 MD_ID_NONE

Notes:

--*/
{
    DWORD dwLineID;
    if (MD_STRNICMP(strCurPtr, MD_OBJECT_ID_STRING, ((sizeof(MD_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_DATA_ID_STRING, ((sizeof(MD_DATA_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_DATA;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_DATA_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_REFERENCE_ID_STRING, ((sizeof(MD_REFERENCE_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_REFERENCE;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_REFERENCE_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_ROOT_OBJECT_ID_STRING, ((sizeof(MD_ROOT_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_ROOT_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_ROOT_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_CHANGE_NUMBER_ID_STRING, ((sizeof(MD_CHANGE_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_CHANGE_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_CHANGE_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MAJOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MAJOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MINOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MINOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else {
        dwLineID = MD_ID_NONE;
    }
    return(dwLineID);
}

HRESULT
GetWarning(
         IN HRESULT hresWarningCode)
/*++

Routine Description:

    Converts error to warnings.

Arguments:

    WarnignCode - The error code to convert.

Return Value:

    DWORD      - MD_WARNING_PATH_NOT_FOUND
                 MD_WARNING_DUP_NAME
                 MD_WARNING_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn;
    switch (hresWarningCode) {
        case (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)):
            hresReturn = MD_WARNING_PATH_NOT_FOUND;
            break;
        case (RETURNCODETOHRESULT(ERROR_DUP_NAME)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        case (RETURNCODETOHRESULT(ERROR_INVALID_DATA)):
            hresReturn = MD_WARNING_INVALID_DATA;
            break;
        case (RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        default:
            hresReturn = hresWarningCode;
    }
    return (hresReturn);
}

BOOL CheckDigits(LPTSTR pszString)
{
    LPTSTR pszTemp;
    BOOL bDigitFound = FALSE;
    BOOL bReturn = FALSE;
    for (pszTemp = pszString;MD_ISDIGIT(*pszTemp); pszTemp++) {
        bDigitFound = TRUE;
    }
    if (bDigitFound && (*pszTemp == (TCHAR)'\0')) {
        bReturn = TRUE;
    }
    return bReturn;
}

HRESULT
InitStorageHelper(
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //

        storage = new IIS_CRYPTO_STORAGE();

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             TRUE,          // fUseMachineKeyset
                             hProv
                             );
                if (FAILED(hresReturn)) 
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[InitStorageHelper] IIS_CRYPTO_STORAGE::Initialize faile with hr = 0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[InitStorageHelper] GetCryptoProvider failed with hr = 0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob(alignedBlob);
    }
    else
    {
        // something failed...
        DBGINFOW((DBG_CONTEXT,
                  L"[InitStorageHelper] IISCryptoCloneBlobFromRawData failed with hr = 0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = storage;
    return hresReturn;

}   // InitStorageHelper


HRESULT
InitStorageHelper2(
    LPSTR pszPasswd,
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.






--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE2 *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    if( ( ( PIIS_CRYPTO_BLOB )RawBlob )->BlobSignature != SALT_BLOB_SIGNATURE )
    {
        return InitStorageHelper( RawBlob, RawBlobLength, NewStorage );
    }

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData2(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //
        storage = new IIS_CRYPTO_STORAGE2;

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider2( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             pszPasswd, 
                             hProv
                             );
                if (FAILED(hresReturn)) 
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[InitStorageHelper2] IIS_CRYPTO_STORAGE::Initialize failed with hr = 0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[InitStorageHelper] GetCryptoProvider failed with hr = 0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob2(alignedBlob);
    }
    else
    {
        // something failed...
        DBGINFOW((DBG_CONTEXT,
                  L"[InitStorageHelper] IISCryptoCloneBlobFromRawData failed with hr = 0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = ( IIS_CRYPTO_STORAGE * )storage;
    return hresReturn;

}   // InitStorageHelper2

    
HRESULT
ReadAllData(LPSTR pszPasswd,
            LPSTR pszBackupLocation,
            LPSTR pszSchemaLocation,
            BOOL bHaveReadSaveSemaphore
            )
/*++

Routine Description:

    Deletgates to correct Reads all meta data from metabase.bin
    or metabase.xml

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 // TODO: Add error codes,

Notes:

--*/
{

    HRESULT hr = ERROR_SUCCESS;

    hr = ReadAllDataFromXML(pszPasswd,
                            pszBackupLocation,
                            pszSchemaLocation,
                            bHaveReadSaveSemaphore
                            );

    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {

    // TODO: Must change the error code to ERROR_PATH_NOT_FOUND.
    //       Stephenr needs to support this.
    //

    //
    // Metabase.xml file was not found. Hence try to load from the 
    // metabase.bin file.
    //

        hr = ReadAllDataFromBin(pszPasswd,
                                pszBackupLocation,
                                bHaveReadSaveSemaphore
                                );
    }

    return hr;

}


HRESULT
ReadAllDataFromXML(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   LPSTR pszSchemaLocation,
                   BOOL bHaveReadSaveSemaphore
                   )
/*++

Routine Description:

    Reads all meta data from the XML file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 Return codes from the catalog

Notes:

--*/
{
    HRESULT                     hr                             = ERROR_SUCCESS;
    HRESULT                     hresWarningCode                = ERROR_SUCCESS;
    
    ISimpleTableDispenser2*     pISTDisp                       = NULL;
    ISimpleTableRead2*          pISTProperty                   = NULL;
    STQueryCell                 QueryCell[2];
    ULONG                       cCell                          = sizeof(QueryCell)/sizeof(STQueryCell);
    ULONG                       i                              = 0;
    LPWSTR                      wszDataFileName                = NULL;
    LPWSTR                      wszSchemaFileName              = NULL;
    LPTSTR                      strReadFileName;
    LPTSTR                      strSchemaFileName;

    CMDBaseObject*              pboRead;
    IIS_CRYPTO_STORAGE*         pStorage                       = NULL;
    DWORD                       dwPreviousLocationID           = -1;
    LPWSTR                      wszPreviousContinuousLocation  = L"/"; // Initialize to the root location
    BOOL                        bLocationDiscontinuous         = FALSE;
    DWORD                       dwTempLastSaveChangeNumber     = 0;
//  WIN32_FILE_ATTRIBUTE_DATA   MBFileAttr;
//  FILETIME                    ftTime;
    FILETIME                    fileTime;
    BOOL                        bSchemaFileNotFound            = FALSE;
    BOOL                        bReadSchemaFromSchemaBin       = TRUE;
        
    if( !pszPasswd && !pszBackupLocation )
    {
        strReadFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        //
        // Restore
        //
        strReadFileName = pszBackupLocation;
    }

    if(!pszPasswd && !pszSchemaLocation )
    {
        strSchemaFileName = g_strSchemaFileName->QueryStr();
    }
    else
    {
        //
        // Restore
        //
        strSchemaFileName = pszSchemaLocation;
    }

    //
    // Get full unicode file name for data file i.e. metabase.xml
    //

    hr = GetUnicodeName(strReadFileName, &wszDataFileName);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetUnicodeName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // Get full file name for schema file i.e. mbschema.xml
    //

    hr = GetUnicodeName(strSchemaFileName, &wszSchemaFileName);

    DBGINFOW((DBG_CONTEXT,
              L"[ReadAllDataFromXML]\nDataFileName:%s\nSchemaFileName:%s\n",
              wszDataFileName,
              wszSchemaFileName));

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetUnicodeName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    
    //
    // The first GetNextLine filled the buffer
    // so we may not need to do any file system stuff
    // with g_rMasterResource locked.
    //

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

    //
    // TODO:
    // g_dwMajorVersionNumber = dwTemp;
    // g_dwMinorVersionNumber = dwTemp;
    // g_dwSystemChangeNumber = dwTemp;
    //

    //
    // Set the global values to their defaults, so that even if they aren't 
    // present in the XML file, they are correctly initialized.
    // Also initializes the dispenser and the bin file path.
    //

    hr = InitializeIIS6GlobalsToDefaults(1,1,pszBackupLocation);

    //
    // Compile the schema bin file if needed and initialize g_pGlobalISTHelper 
    //

    hr = CompileIfNeeded(wszDataFileName, wszSchemaFileName, &bSchemaFileNotFound);

    if(FAILED(hr))
    {
        goto exit;
    }


    if(bSchemaFileNotFound)
    {
        //
        // If schema file is not found, set the schema change numbers to differ
        // so that a compilation is forced. If schema file is not found and the
        // schema tree is in the xml, we will read the schema tree from the xml
        // hence we will need to force a compile during savealldata to merge
        // the xml schema and the shippped schema..
        //

        g_dwLastSchemaChangeNumber = 0;

    }

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Get the property table.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    QueryCell[0].pData     = (LPVOID)g_pGlobalISTHelper->m_wszBinFileForMeta;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_SCHEMAFILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = 0;

    QueryCell[1].pData     = (LPVOID)wszDataFileName;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iST_CELL_FILE;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszDataFileName)+1)*sizeof(WCHAR);
    

    hr = pISTDisp->GetTable(wszDATABASE_METABASE,
                            wszTABLE_MBProperty,
                            (LPVOID)QueryCell,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID *)&pISTProperty);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] GetTable failed with hr = 0x%x.\n",hr));



        goto exit;
    }

    hr = InitializeGlobalsFromXML(pISTProperty,
                                  wszDataFileName,
                                  &pStorage,
                                  pszPasswd);
    if(FAILED(hr))
    {
        goto exit;      
    }

    //
    // Need to determine where to read the schema from.
    // In upgrade scenarios from IIS5.0/5.1 to 6.0 ReadAllDataFromBin is called
    // which reads the schema tree from the metabase.bin file.
    // In upgrade scenarios from IIS6.0 Beta1 builds (where schema is stored in 
    // the metabase.xml file) to IIS6.0 Beta2 builds (where schema is stored in
    // mbschema.XML files) a compile is done, but schema is still read from the 
    // metabase.XML file. 
    // Setup needs to force a save in these scenarios so that the schema that is 
    // read (from either metabase.bin or metabase.xml) can be merged with the 
    // shipped schema to generate a unified mbschema.bin and mbschema.xml file.
    //

    if(bSchemaFileNotFound && SchemaTreeInTable(pISTProperty))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromXML] Should not be reading from schema bin.\n"));

        bReadSchemaFromSchemaBin = FALSE;
    }

    if(bReadSchemaFromSchemaBin)
    {
        //
        // Read the schema tree from the .bin
        //

        hr = ReadSchema(pStorage,
                        &fileTime);

        if(FAILED(hr))
        {
            goto exit;      
        }
    }

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache
    //

    for(i=0; ;i++)
    {
        LPVOID  a_pv[cMBProperty_NumberOfColumns];
        ULONG   a_Size[cMBProperty_NumberOfColumns];
        ULONG   a_iCol[] = {iMBProperty_Name,
                            iMBProperty_Location,
                            iMBProperty_ID,
                            iMBProperty_Attributes,
                            iMBProperty_UserType,
                            iMBProperty_Type,
                            iMBProperty_Value,
                            iMBProperty_LocationID};
        ULONG   cCol = sizeof(a_iCol)/sizeof(ULONG);
        int     iRow = i;
        BOOL    bLocationWithProperty   = TRUE;
        BOOL    bNewLocation            = FALSE;
        BOOL    bIsRoot                 = FALSE;

        hr = pISTProperty->GetColumnValues(i,
                                           cCol,
                                           a_iCol,
                                           a_Size,
                                           a_pv);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReadAllDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%s. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));

            goto exit;
        }
        else if((0 == wcscmp(MD_GLOBAL_LOCATIONW, (LPWSTR)a_pv[iMBProperty_Location])) ||
                (bReadSchemaFromSchemaBin && (0 == _wcsnicmp((LPWSTR)a_pv[iMBProperty_Location], g_wszSlashSchema, g_cchSlashSchema)))
               )    
        {
            //
            // Ignore globals.
            //

            //
            // Ignore the schema tree if it has been read from bin,
            //

            continue;
        }

        if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == MD_CH_LOC_NO_PROPERTYW))
        {
            bLocationWithProperty = FALSE;
        }

        if(dwPreviousLocationID != *(DWORD*)a_pv[iMBProperty_LocationID])
        {
            bNewLocation = TRUE;
            dwPreviousLocationID = *(DWORD*)a_pv[iMBProperty_LocationID];

            bLocationDiscontinuous = DiscontinuousLocation(wszPreviousContinuousLocation,
                                                           (LPWSTR)a_pv[iMBProperty_Location]);

            if(!bLocationDiscontinuous)
            {
                wszPreviousContinuousLocation  = (LPWSTR)a_pv[iMBProperty_Location];
            }
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[ReadAllDataFromXML] Encountered discontinuous location:%s. Ignoring this and all locations below it.\n",           \
                          (LPWSTR)a_pv[iMBProperty_Location]));

                LogEvent(g_pEventLog,
                         MD_WARNING_IGNORING_DISCONTINUOUS_NODE,
                         EVENTLOG_WARNING_TYPE,
                         ID_CAT_CAT,
                         ERROR_INVALID_DATA,
                         (LPWSTR)a_pv[iMBProperty_Location]);
            }
        }

        if(bLocationDiscontinuous)
        {
            //
            // Properties are sorted by location. If you have a discontinous location, the ignore it.
            //

            continue;
        }

        //
        // TODO: Need to assert when bLocationWithProperty == FALSE, then bNewLocation must == TRUE
        //

        if(0 == wcscmp((LPWSTR)a_pv[iMBProperty_Location], L"/"))
        {
            bIsRoot = TRUE;
        }

        if(bNewLocation && (!bIsRoot))  // No need to read meta object for root - g_pboMasterRoot already present.
        {
            hr = ReadMetaObject(pboRead,
                                (LPWSTR)a_pv[iMBProperty_Location],
                                &fileTime,
                                TRUE);

            if(FAILED(hr))
            {
                if (hr == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) 
                {
                    //
                    // Serious error, we're done.
                    //

                    goto exit;                      
                }
                else 
                {
                    //
                    // Just give a warning and go to the next object
                    //

                    hresWarningCode = hr;           
                    continue;
                }
            }
        }

        if(bLocationWithProperty)
        {
            if(!bIsRoot)
            {
                hr = ReadDataObject(pboRead,
                                    a_pv,
                                    a_Size,
                                    pStorage,
                                    TRUE);
            }
            else
            {
                hr = ReadDataObject(g_pboMasterRoot,
                                    a_pv,
                                    a_Size,
                                    pStorage,
                                    TRUE);

            }

            if(FAILED(hr))
            {
                if (hr == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) 
                {
                    //
                    // Serious error, we're done.
                    //

                    goto exit;                      
                }
                else 
                {
                    //
                    // Just give a warning and go to the next object
                    //

                    hresWarningCode = hr;           
                    continue;
                }
            }
        }

    }

exit:

    //
    // Must have MasterResource when accessing SystemChangeNumber
    // so save it away here. Only update LastSaveChangeNumber on success.
    //

    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
    g_rMasterResource->Unlock();
   
    /*
    //
    // File not found is ok
    // Start with MasterRoot only
    //

    if (hr == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND))
    {
        hr = ERROR_SUCCESS;
    }
    */

    //
    // The above assumption is not true anymore. If the file is not found we
    // either read from the bin file (if it is present like in an upgrade
    // scenario, or we fail.
    //

    if ((SUCCEEDED(hr)) && (hresWarningCode != ERROR_SUCCESS))
    {
        hr = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hr)) 
    {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    if((SUCCEEDED(hr))                && 
       (NULL == pszBackupLocation)
      )
    {
        //
        // Note the global handle array is initialized in 
        // InitializeIIS6GlobalsToDefaults
        //

        if(!g_dwEnableEditWhileRunning)
        {
            // Write lock the file only if EWR is disabled and it is a 
            // ReadAllData that is called from service startup and not 
            // from Restore. 
            //

            hr = LockMetabaseFile(wszDataFileName,
                                  eMetabaseDataFile,
                                  TRUE);

            DBGINFOW((DBG_CONTEXT,
                      L"[ReadAllDataFromXML] Locking metabase file %s returned 0x%x.\n",
                      wszDataFileName,
                      hr));

            if(SUCCEEDED(hr))
            {
                hr = LockMetabaseFile(wszSchemaFileName,
                                      eMetabaseSchemaFile,
                                      TRUE);

                DBGINFOW((DBG_CONTEXT,
                          L"[ReadAllDataFromXML] Locking metabase file %s returned 0x%x.\n",
                          wszSchemaFileName,
                          hr));

            }
        }

    }

    //
    // Cleanup
    //

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    if(NULL != wszDataFileName)
    {
        delete [] wszDataFileName;
        wszDataFileName = NULL;
    }

    if(NULL != wszSchemaFileName)
    {
        delete [] wszSchemaFileName;
        wszSchemaFileName = NULL;
    }

    return hr;
}


HRESULT
ReadAllDataFromBin(LPSTR pszPasswd,
                   LPSTR pszBackupLocation,
                   BOOL bHaveReadSaveSemaphore
                   )
/*++

Routine Description:

    Reads all meta data from the original bin file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarningCode = ERROR_SUCCESS;
    PBYTE  pbEndReadData;
    PBYTE  pbNextPtr;
    DWORD  dwLineLen;
    LPTSTR strReadFileName;
    HANDLE hReadFileHandle;
    BYTE   bLineId;
    DWORD  dwTemp;
    CMDBaseObject *pboRead;
    FILETIME ftTime;
    IIS_CRYPTO_STORAGE *pStorage = NULL;
    BOOL bUnicode;
    DWORD dwTempLastSaveChangeNumber = 0;
    STR*  strRealBinFileName = NULL;
    LPWSTR wszFileName = NULL;

    BUFFER *pbufRead = new BUFFER(0);
    if( !pbufRead )
    {
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    BUFFER *pbufLine = new BUFFER(0);
    if( !pbufLine )
    {
        delete pbufRead;
        pbufRead = NULL;

        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    if( !pszPasswd )
    {
        TCHAR*  szBin = NULL;
        TCHAR*  szEnd = NULL;
        TCHAR   chDot = (TCHAR)'.';
        TCHAR*   szBinExtn = (TCHAR*)"bin";

        szBin = new TCHAR[_tcslen(g_strRealFileName->QueryStr())+1];
        if(NULL == szBin)
        {
            delete(pbufRead);
            delete(pbufLine);
            return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            _tcscpy(szBin, (g_strRealFileName->QueryStr()));
            szEnd = _tcsrchr(szBin, chDot);
            *(++szEnd) = (TCHAR)'\0';
            _tcscat(szBin, szBinExtn);
            strRealBinFileName = new STR(szBin);
            delete [] szBin;

            if(NULL == strRealBinFileName)
            {
                delete(pbufRead);
                delete(pbufLine);
                return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
            }
            else
                strReadFileName = strRealBinFileName->QueryStr();           
        }
    }
    else
    {
        strReadFileName = pszBackupLocation;
    }

    hresReturn = GetUnicodeName(strReadFileName, &wszFileName);

    if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromBin] GetUnicodeName failed with hr = 0x%x.\n",hresReturn));
        delete(pbufRead);
        delete(pbufLine);
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    hresReturn = InitializeIIS6GlobalsToDefaults(0,1,pszBackupLocation);

    if(FAILED(hresReturn))
    {
        delete [] wszFileName;
        DBGINFOW((DBG_CONTEXT,
                  L"[ReadAllDataFromBin] InitializeIIS6GlobalsToDefaults failed with hr = 0x%x.\n",hresReturn));
        return hresReturn;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(strReadFileName,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0);

    if (hReadFileHandle == INVALID_HANDLE_VALUE) {
        dwTemp = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwTemp);
    }
    else {
        //
        // Allocate Buffers
        //
        if (!pbufLine->Resize(MAX_RECORD_BUFFER) ||
            !pbufRead->Resize(READWRITE_BUFFER_LENGTH)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            pbEndReadData = (PBYTE)pbufRead->QueryPtr();
            //
            // GetNextLine makes sure that the next line is in the buffer and sets strCurPtr to point to it
            // The line is NULL terminated, no new line. The variables passed in must not be modified outside
            // of GetNextLine.
            //
            dwLineLen = 0;
            pbNextPtr = pbEndReadData;
            hresReturn = GetNextLine(hReadFileHandle,
                                  pbEndReadData,
                                  pbufRead,
                                  pbufLine,
                                  dwLineLen,
                                  pbNextPtr);
            if (SUCCEEDED(hresReturn)) {
                //
                // See if it's our file
                //
                if (dwLineLen == sizeof(MD_SIGNATURE_STRINGA) &&
                    (MD_CMP(MD_SIGNATURE_STRINGA, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = FALSE;
                }
                else if  (dwLineLen == sizeof(MD_SIGNATURE_STRINGW) &&
                    (MD_CMP(MD_SIGNATURE_STRINGW, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = TRUE;
                }
                else {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }

                if (SUCCEEDED(hresReturn)) {
                    //
                    // The first GetNextLine filled the buffer
                    // so we may not need to do any file system stuff
                    // with g_rMasterResource locked.
                    //
                    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

                    while ((SUCCEEDED(hresReturn)) &&
                           (SUCCEEDED(hresReturn = GetNextLine(hReadFileHandle,
                                                   pbEndReadData,
                                                   pbufRead,
                                                   pbufLine,
                                                   dwLineLen,
                                                   pbNextPtr))) &&
                           (dwLineLen > 0) &&
                           (((bLineId = *(BYTE *)(pbufLine->QueryPtr())) == MD_ID_NONE) ||
                               (bLineId == MD_ID_MAJOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_MINOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_CHANGE_NUMBER) ||
                               (bLineId == MD_ID_SESSION_KEY))) {

                        if (bLineId != MD_ID_NONE) {
                            if (bLineId != MD_ID_SESSION_KEY &&
                                dwLineLen != (1 + sizeof(DWORD))) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                            }
                            else {
                                dwTemp = *(UNALIGNED DWORD *)FIRSTDATAPTR(pbufLine);
                                switch (bLineId) {
                                case MD_ID_MAJOR_VERSION_NUMBER:
                                    g_dwMajorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_MINOR_VERSION_NUMBER:
                                    g_dwMinorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_CHANGE_NUMBER:
                                    g_dwSystemChangeNumber = dwTemp;
                                    break;
                                case MD_ID_SESSION_KEY:
                                    {
                                        BOOL    fSecuredRead = TRUE;
                                        HKEY    hkRegistryKey = NULL;
                                        DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

                                            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                                                     SETUP_REG_KEY,
                                                                     &hkRegistryKey);
                                            if (dwRegReturn == ERROR_SUCCESS)
                                            {
                                                dwSize = MAX_PATH * sizeof(TCHAR);
                                                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                                                MD_UNSECUREDREAD_VALUE,
                                                                NULL,
                                                                &dwType,
                                                                (BYTE *)&dwValue,
                                                                &dwSize);
                                                if ( dwRegReturn == ERROR_SUCCESS &&
                                                     dwType == REG_DWORD &&
                                                     dwValue == 1)
                                                {
                                                    hresReturn = NO_ERROR;
                                                    pStorage = NULL;
                                                    fSecuredRead = FALSE;

                                                    DBGPRINTF(( DBG_CONTEXT,
                                                                "Temporary disabling  decryption for metabase read\n"));


                                                    // special indicator for IIS setup that we passed this point
                                                    dwValue = 2;
                                                    dwRegReturn = RegSetValueEx(hkRegistryKey,
                                                                    MD_UNSECUREDREAD_VALUE,
                                                                    0,
                                                                    REG_DWORD,
                                                                    (PBYTE)&dwValue,
                                                                    sizeof(dwValue));
                                                    if (dwRegReturn == ERROR_SUCCESS)
                                                    {
                                                        DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
                                                    }

                                                }
                                                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
                                            }
 
                                        if (fSecuredRead)
                                        {
                                            if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) FIRSTDATAPTR(pbufLine)))
                                            {
                                                    // call special function focibly tell that this machine has no
                                                    // encryption enabled even if it happens to be so
                                                    // that's a special handling for French case with US locale
                                                    IISCryptoInitializeOverride (FALSE);
                                            }

                                            if( !pszPasswd )
                                            {
                                                hresReturn = InitStorageHelper(
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                             else
                                             {
                                                hresReturn = InitStorageHelper2(
                                                               pszPasswd,
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                        }
                                    }
                                    break;
                                default:
                                    MD_ASSERT(FALSE);
                                }
                            }
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {

                        //
                        // This must be the global master object
                        //
                        if ((dwLineLen != 1 + sizeof(FILETIME)) || (bLineId != MD_ID_ROOT_OBJECT)) {
                            //
                            // This file is hosed
                            //
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                        else {
                            //
                            // Got the MasterRoot Object.
                            //

                            ftTime = *(UNALIGNED FILETIME *)FIRSTDATAPTR(pbufLine);
                            g_pboMasterRoot->SetLastChangeTime(&ftTime);
                            //
                            // Read in MasterRoot Data.
                            //
                            for (hresReturn = GetNextLine(hReadFileHandle,
                                                  pbEndReadData,
                                                  pbufRead,
                                                  pbufLine,
                                                  dwLineLen,
                                                  pbNextPtr);
                                ((SUCCEEDED(hresReturn)) && (dwLineLen != 0)
                                && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr)) {
                                if (bLineId == MD_ID_DATA) {

                                    hresReturn = ReadDataObject( g_pboMasterRoot, 
                                                                 pbufLine, 
                                                                 dwLineLen, 
                                                                 pStorage, 
                                                                 bUnicode
                                                                 );
                                }
                            }
                        }
                    }
                    //
                    // All of the required stuff is read in, and the next line is either
                    // NULL or the first normal object.
                    // Loop through all normal objects.
                    //
                    if (SUCCEEDED(hresReturn)) {
                        while ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                            MD_ASSERT(bLineId == MD_ID_OBJECT);
                            for (hresReturn = ReadMetaObject(pboRead,
                                                           pbufLine,
                                                           dwLineLen,
                                                           pStorage,
                                                           bUnicode);
                                (FAILED(hresReturn));
                                hresReturn = ReadMetaObject(pboRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pStorage,
                                                          bUnicode)) {
                                //
                                // This for loop normally shouldn't be executed.
                                // The purpose of the loop is to ignore problems if
                                // the object is bad.
                                //
                                if (hresReturn == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                    //
                                    // Serious error, we're done.
                                    //
                                    break;
                                }
                                else {
                                    //
                                    // Just give a warning and go to the next object
                                    // Ignore everything until we get to the next object
                                    //
                                    hresWarningCode = hresReturn;

                                    for (hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr);
                                        ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                        && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                        hresReturn = GetNextLine(hReadFileHandle,
                                                              pbEndReadData,
                                                              pbufRead,
                                                              pbufLine,
                                                              dwLineLen,
                                                              pbNextPtr)) {

                                    }
                                    if (dwLineLen == 0) {
                                        //
                                        // EOF, we're done
                                        //
                                        break;
                                    }
                                }
                            }
                            if ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                                //
                                // Got an object.
                                // Read in data.
                                //
                                for (hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr);
                                    ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                    //
                                    // GetLineID increments strCurPtr if a match is found
                                    //
                                    && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                    hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr)) {
                                    if (bLineId == MD_ID_DATA) {
                                        hresReturn = ReadDataObject( pboRead,
                                                                     pbufLine,
                                                                     dwLineLen,
                                                                     pStorage,
                                                                     bUnicode
                                                                     );

                                        //
                                        // dwReturn gets blown away by the for loop.
                                        // Most errors we can just ignore anyway, but
                                        // save a warning.
                                        //
                                        if (FAILED(hresReturn)) {
                                            if (hresReturn != RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                                hresWarningCode = hresReturn;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
                    g_rMasterResource->Unlock();
                }
            }
            if (!CloseHandle(hReadFileHandle)) {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
        }
    }
    //
    // File not found is ok
    // Start with MasterRoot only
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    if ((SUCCEEDED(hresReturn)) && (hresWarningCode != ERROR_SUCCESS)) {
        hresReturn = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hresReturn)) {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    //
    // Cleanup
    //
    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    delete(pbufRead);
    delete(pbufLine);
    delete(pStorage);
    if(NULL != wszFileName)
    {
        delete [] wszFileName;
    }
    return hresReturn;
}

HRESULT
InitWorker(
    IN BOOL bHaveReadSaveSemaphore,
    IN LPSTR pszPasswd,
    IN LPSTR pszBackupLocation,
    IN LPSTR pszSchemaLocation
    )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized++ > 0) {
        hresReturn = g_hresInitWarning;
    }
    else {
        g_pboMasterRoot = NULL;
        g_phHandleHead = NULL;
        for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
            g_phEventHandles[i] = NULL;
        }
        g_mhHandleIdentifier = METADATA_MASTER_ROOT_HANDLE;
        g_pboMasterRoot = new CMDBaseObject(MD_MASTER_ROOT_NAME);
        g_ppbdDataHashTable = NULL;
        g_dwSystemChangeNumber = 0;
        g_strRealFileName = NULL;
        g_strTempFileName = NULL;
        g_strBackupFileName = NULL;
        g_pstrBackupFilePath = NULL;
        g_strSchemaFileName = NULL;
        
        memset((LPVOID)&g_XMLSchemaFileTimeStamp, 0, sizeof(FILETIME));
        memset((LPVOID)&g_BINSchemaFileTimeStamp, 0, sizeof(FILETIME));
        memset((LPVOID)&g_MostRecentMetabaseFileLastWriteTimeStamp, 0, sizeof(FILETIME));
        memset((LPVOID)&g_EWRProcessedMetabaseTimeStamp, 0, sizeof(FILETIME));
        g_bSavingMetabaseFileToDisk = FALSE;
        g_ulMostRecentMetabaseVersion = 0;

        InitializeUnicodeGlobalDataFileValues();

        g_pGlobalISTHelper                             = NULL;
        g_pListenerController                          = NULL;
        g_pEventLog                                    = NULL;

        g_psidSystem        = NULL;
        g_psidAdmin         = NULL;
        g_paclDiscretionary = NULL;
        g_psdStorage        = NULL;

        if ((g_pboMasterRoot == NULL) || (!(g_pboMasterRoot->IsValid()))) {

            IIS_PRINTF((buff,"Unable to allocate CMDBaseObject\n"));
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            g_pboMasterRoot->SetParent(NULL);
            g_phHandleHead = new CMDHandle(g_pboMasterRoot,
                                           METADATA_PERMISSION_READ,
                                           g_dwSystemChangeNumber,
                                           g_mhHandleIdentifier++,
                                           FALSE);
            if (g_phHandleHead == NULL) {
                IIS_PRINTF((buff,"Unable to allocate CMDHandle\n"));
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                g_phHandleHead->SetNextPtr(NULL);
                if( ( g_phEventHandles[EVENT_READ_INDEX] = IIS_CREATE_EVENT(
                                                               "g_phEventHandles[EVENT_READ_INDEX]",
                                                               &g_phEventHandles[EVENT_READ_INDEX],
                                                               TRUE,
                                                               FALSE
                                                               ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if( ( g_phEventHandles[EVENT_WRITE_INDEX] = IIS_CREATE_EVENT(
                                                                   "g_phEventHandles[EVENT_WRITE_INDEX]",
                                                                   &g_phEventHandles[EVENT_WRITE_INDEX],
                                                                   TRUE,
                                                                   FALSE
                                                                   ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if ((g_ppbdDataHashTable = new CMDBaseData *[DATA_HASH_TABLE_LEN]) == NULL) {
                    IIS_PRINTF((buff,"Unable to allocate CMDBaseData\n"));
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = InitBufferPool();
                    if (SUCCEEDED(hresReturn)) {
                        for (int i =0; i < DATA_HASH_TABLE_LEN; i++) {
                            g_ppbdDataHashTable[i] = NULL;
                        }
                        //
                        // Code Work:
                        // There is a conceiveable deadlock if ReadAllData is called with g_rMasterResource Locked, 
                        // due to the semaphore used to control file access. Would like to release g_rMasterResource, 
                        // but that could cause duplicate inits.
                        //

                        hresReturn = SetStorageSecurityDescriptor();
                        if (SUCCEEDED(hresReturn)) {

                            // Initialize logging object first

                            ISimpleTableDispenser2* pISTDisp   = NULL;

                            hresReturn = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

                            if(SUCCEEDED(hresReturn))
                            {
                                IAdvancedTableDispenser* pISTAdvanced = NULL;

                                hresReturn = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser,
                                                                      (LPVOID*)&pISTAdvanced);

                                                                pISTDisp->Release();
                                                                pISTDisp = NULL;

                                if(SUCCEEDED(hresReturn))
                                {
                                    hresReturn = pISTAdvanced->GetCatalogErrorLogger(&g_pEventLog);

                                    pISTAdvanced->Release();
                                    pISTAdvanced = NULL;

                                                                        if(SUCCEEDED(hresReturn))
                                                                        {
                                                                                hresReturn = SetDataFile();

                                                                                if (SUCCEEDED(hresReturn)) 
                                                                                {
                                                                                        hresReturn = ReadAllData(pszPasswd, pszBackupLocation, pszSchemaLocation, bHaveReadSaveSemaphore);
                                                                                }
                                                                        }
                                                                }

                            }

//                            if ((RetCode = SetRegistryStoreValues()) == ERROR_SUCCESS) {
//                                RetCode = ReadAllDataFromRegistry();
//                            }
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {

            // Check if the Major/Minor version needs to get updated...
            // if there is a specified version in the registry (set by iis setup during upgrade)
            // then use that new version, if it's not a dword, then use the default for g_dwMajorVersionNumber.
            CheckForNewMetabaseVersion();

            if (!CheckVersionNumber()) {
                IIS_PRINTF((buff,"MD: Invalid version number\n"));
                hresReturn = MD_ERROR_INVALID_VERSION;
            }
        }

        if(SUCCEEDED(hresReturn)) {
            //
            // Initialize the listener controller and depending on whether Edit
            // While running is enabled or disabled, start or stop it.
            //

            hresReturn = InitializeListenerController();

            if(SUCCEEDED(hresReturn))
            {
                if(g_dwEnableEditWhileRunning)
                {
                    hresReturn = g_pListenerController->Start();
                }
                else 
                {
                    hresReturn = g_pListenerController->Stop(iSTATE_STOP_TEMPORARY,
                                                             NULL);
                }
            }
        }

        //
        // Cleanup
        //
        if (FAILED(hresReturn)) {
            g_dwInitialized--;
            delete(g_pboMasterRoot);
            delete(g_phHandleHead);            
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                if (g_phEventHandles[i] != NULL) {
                    CloseHandle(g_phEventHandles[i]);
                }
            }
            DeleteAllRemainingDataObjects();
            ReleaseStorageSecurityDescriptor();

            delete [] g_ppbdDataHashTable;
            g_ppbdDataHashTable = NULL;

            //
            // Allocated in SetDataFile
            //
            delete(g_strRealFileName);
            g_strRealFileName = NULL;
            delete(g_strTempFileName);
            g_strTempFileName = NULL;
            delete(g_strBackupFileName);
            g_strBackupFileName = NULL;
            delete(g_pstrBackupFilePath);
            g_pstrBackupFilePath = NULL;
            delete(g_strSchemaFileName);
            g_strSchemaFileName = NULL;

            UnInitializeUnicodeGlobalDataFileValues();

            //
            // Allocated in ReadAllData
            //
            delete g_pGlobalISTHelper;
            g_pGlobalISTHelper = NULL;

            if(NULL != g_pEventLog)
            {
                g_pEventLog->Release();
                g_pEventLog = NULL;
            }
            UnInitializeListenerController();
            DeleteBufferPool();
        }

        //
        // Save the return code.
        // Secondary init's repeat warnings.
        // If error, the next init will overwrite this.
        // So don't worry about setting this to errors.
        //

        g_hresInitWarning = hresReturn;

    }

    g_rMasterResource->Unlock();

    return hresReturn;
}

HRESULT
TerminateWorker1(
         IN BOOL bHaveReadSaveSemaphore
         )
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;
    HANDLE           hEditWhileRunningThread = NULL;

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {
            if (g_dwInitialized == 1) {

                if(NULL != g_pListenerController)
                {
                    hresReturn = g_pListenerController->Stop(iSTATE_STOP_PERMANENT,
                                                             &hEditWhileRunningThread);
                }

                if (SUCCEEDED(hresReturn)) {
                    hresReturn = SaveAllData(FALSE,
                                             &CryptoStorage,
                                             pSessionKeyBlob,
                                             NULL,
                                             NULL,
                                             METADATA_MASTER_ROOT_HANDLE,
                                             bHaveReadSaveSemaphore,
                                             TRUE);
                }
//                RetCode = SaveAllDataToRegistry();
            }
            if (SUCCEEDED(hresReturn)) {
                if (--g_dwInitialized == 0)
                    TerminateWorker();
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
        
        //
        // Wait for the Edit while running thread to die before terminating
        // Note that we wait after the lock is released.
        //
        if(NULL != hEditWhileRunningThread)
        {
            DWORD dwRes = WaitForSingleObject(hEditWhileRunningThread,
                                              INFINITE);

            if((dwRes == WAIT_ABANDONED) ||
               (dwRes == WAIT_TIMEOUT)
              )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[TerminateWorker1] Wait for Edit while running thread to terminate failed. dwRes=0x%x. Ignoring this event.\n", 
                          dwRes));  
            }

            CloseHandle(hEditWhileRunningThread);
        }
    }
    else
    {
        // pretty serious.
        DBGPRINTF(( DBG_CONTEXT, "TerminateWorker1.InitStorageAndSessionKey:Failed - error 0x%0x\n", hresReturn));
    }

    return hresReturn;
}

VOID
TerminateWorker()
{
/*++

Routine Description:

    Worker routine for termination.

Arguments:

    SaveData   - If true, saves metadata.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

    If SaveData is TRUE and the save fails, the termination code is not executed
    and an error code is returned.

--*/
    CMDHandle *CurHandle, *NextHandle;
    for (CurHandle = g_phHandleHead;CurHandle!=NULL;CurHandle=NextHandle) {
        NextHandle = CurHandle->GetNextPtr();
        delete (CurHandle);
    }
    g_phHandleHead = NULL;

    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        if (g_phEventHandles[i] != NULL) {
            CloseHandle(g_phEventHandles[i]);
        }
    }
    // Perf fix.
    g_pboMasterRoot->CascadingDataCleanup();
    delete(g_pboMasterRoot);

    //
    // All data objects should be deleted by
    // deleting the handles and masterroot
    // but it's possible a client failed
    // to release a data by reference so
    // destroy all remaining data objects
    //

    DeleteAllRemainingDataObjects();
    ReleaseStorageSecurityDescriptor();    

    delete [] g_ppbdDataHashTable;
    delete(g_strRealFileName);
    delete(g_strTempFileName);
    delete(g_strBackupFileName);
    delete(g_pstrBackupFilePath);
    delete(g_strSchemaFileName);
    UnInitializeUnicodeGlobalDataFileValues();
    if(NULL != g_pGlobalISTHelper)
    {
        delete g_pGlobalISTHelper;
        g_pGlobalISTHelper = NULL;
    }
    if(NULL != g_pEventLog)
    {
        g_pEventLog->Release();
        g_pEventLog = NULL;
    }
    UnInitializeListenerController();
    DeleteBufferPool();
}


HRESULT
SetStorageSecurityDescriptor()
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL status;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PLATFORM_TYPE platformType;

    //
    // Verify that globals were initialized correctly.
    //


    MD_ASSERT(g_psidSystem == NULL);
    MD_ASSERT(g_psidAdmin == NULL);
    MD_ASSERT(g_paclDiscretionary == NULL);
    MD_ASSERT(g_psdStorage == NULL);

    //
    // Of course, we only need to do this under NT...
    //

    platformType = IISGetPlatformType();

    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        g_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (g_psdStorage == NULL) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     g_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidSystem)
                       - sizeof(DWORD);

        g_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( g_paclDiscretionary == NULL ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     g_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     g_psdStorage,
                     TRUE,
                     g_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }
    }

fatal:

    if (FAILED(hresReturn)) {
        ReleaseStorageSecurityDescriptor();

    }

    return hresReturn;

}

VOID
ReleaseStorageSecurityDescriptor()
{
    if( g_paclDiscretionary != NULL ) {
        LocalFree( g_paclDiscretionary );
        g_paclDiscretionary = NULL;
    }

    if( g_psidAdmin != NULL ) {
        FreeSid( g_psidAdmin );
        g_psidAdmin = NULL;

    }

    if( g_psidSystem != NULL ) {
        FreeSid( g_psidSystem );
        g_psidSystem = NULL;
    }

    if( g_psdStorage != NULL ) {
        LocalFree( g_psdStorage );
        g_psdStorage = NULL;
    }
}

HRESULT
ExtractNameFromPath(
         IN OUT LPSTR &strPath,
         OUT LPSTR strNameBuffer,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    LPSTR pszIndex;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (bUnicode) {
        LPWSTR wstrPath = (LPWSTR)strPath;
        hresReturn = ExtractNameFromPath(&wstrPath, (LPWSTR)strNameBuffer);
        strPath = (LPSTR) wstrPath;
    }
    else {
        if (strPath != NULL) {
            for (pszIndex = strPath;
                 ((pszIndex - strPath) < METADATA_MAX_NAME_LEN) && (*pszIndex != (TCHAR)'\0') &&
                    (*pszIndex != MD_PATH_DELIMETER) && (*pszIndex != MD_ALT_PATH_DELIMETER);
                 pszIndex = CharNextExA(CP_ACP,
                                        pszIndex,
                                        0)) {
            }
            DWORD dwStrBytes = DIFF(pszIndex - strPath);
            if ((dwStrBytes) >= METADATA_MAX_NAME_LEN) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
            }
            else {
                MD_COPY(strNameBuffer, strPath, dwStrBytes);
                strNameBuffer[dwStrBytes] = (TCHAR)'\0';
                strPath = pszIndex;
                if (*strNameBuffer != (TCHAR)'\0') {
                    //
                    // if a non-null name
                    //
                    SKIP_PATH_DELIMETERA(strPath);
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
ExtractNameFromPath(
         IN OUT LPWSTR *pstrPath,
         OUT LPWSTR strNameBuffer)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    int i;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (*pstrPath != NULL) {
        for (i = 0;
            (i < METADATA_MAX_NAME_LEN) && ((*pstrPath)[i] != (WCHAR)L'\0') &&
                ((*pstrPath)[i] != (WCHAR)MD_PATH_DELIMETER) && ((*pstrPath)[i] != (WCHAR)MD_ALT_PATH_DELIMETER);
            i++) {
            strNameBuffer[i] = (*pstrPath)[i];
        }
        if (i == METADATA_MAX_NAME_LEN) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
        }
        else {
            strNameBuffer[i] = (WCHAR)L'\0';
            *pstrPath += i;
            if (*strNameBuffer != (WCHAR)L'\0') {
                //
                // if a non-null name
                //
                SKIP_PATH_DELIMETERW(*pstrPath);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
    return (hresReturn);
}

BOOL DataMatch(IN CMDBaseData *pbdExisting,
               IN PMETADATA_RECORD pmdrData,
               OUT PBOOL pbError,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Determines if a set of data maches an existing object.

Arguments:

    Existing   - The existing data object.

    Identifier - The Identifier of the data.

    Attributes - The flags for the data.
                      METADATA_INHERIT

    UserType   - The User Type for the data. User Defined.

    DataType   - The Type of the data.
                      DWORD_METADATA
                      STRING_METADATA
                      BINARY_METADATA

    DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.
                 Binary data must not exceed METADATA_MAX_BINARY_LEN bytes.
                 String data must not exceed METADATA_MAX_STRING_LEN characters,
                 include the trailing '\0'.

    Data       - Pointer to the data.


Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    BOOL bReturn = TRUE;
    BOOL bError = FALSE;

    if ((pmdrData->dwMDIdentifier != pbdExisting->GetIdentifier()) ||
        (pmdrData->dwMDAttributes != pbdExisting->GetAttributes()) ||
        (pmdrData->dwMDUserType != pbdExisting->GetUserType()) ||
        (pmdrData->dwMDDataType != pbdExisting->GetDataType())) {
        bReturn = FALSE;
    }
    else {
        if (pbdExisting->GetData(bUnicode) == NULL) {
            bError = TRUE;
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    if (*(DWORD *)(pmdrData->pbMDData) != *(DWORD *)(pbdExisting->GetData())) {
                        bReturn = FALSE;
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszStringData = (LPWSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = L"";
                        }
                        if (wcscmp(pszStringData, (LPWSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    else {
                        LPSTR pszStringData = (LPSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = "";
                        }
                        if (MD_STRCMP(pszStringData, (LPSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                case BINARY_METADATA:
                case MULTISZ_METADATA:
                {
                    if (pmdrData->dwMDDataLen != pbdExisting->GetDataLen(bUnicode)) {
                        bReturn = FALSE;
                    }
                    else {
                        if (MD_CMP(pmdrData->pbMDData, pbdExisting->GetData(bUnicode), pmdrData->dwMDDataLen) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                default: {
                    bReturn = FALSE;
                }
            }
        }
    }
    *pbError = bError;
    return (bReturn);
}

VOID
DeleteDataObject(
         IN CMDBaseData *pbdDelete)
/*++

Routine Description:

    Decrements the reference count of an object and deletes it if the reference count becomes 0.

Arguments:

    Delete      - The data object to delete.

Return Value:

Notes:

--*/
{
    DWORD dwHash = DATA_HASH(pbdDelete->GetIdentifier());
    CMDBaseData *pdataIndex;

    MD_ASSERT(pbdDelete != NULL);
    if (pbdDelete->DecrementReferenceCount() == 0) {
        if (g_ppbdDataHashTable[dwHash] == pbdDelete) {
            g_ppbdDataHashTable[dwHash] = pbdDelete->GetNextPtr();
        }
        else {
            for (pdataIndex=g_ppbdDataHashTable[dwHash];
                pdataIndex->GetNextPtr() != pbdDelete;
                pdataIndex = pdataIndex->GetNextPtr()) {
            }
            pdataIndex->SetNextPtr(pbdDelete->GetNextPtr());
        }
        switch (pbdDelete->GetDataType()) {
        case DWORD_METADATA: {
            delete ((CMDDWData *) pbdDelete);
            break;
        }
        case STRING_METADATA: {
            delete ((CMDSTRData *) pbdDelete);
            break;
        }
        case BINARY_METADATA: {
            delete ((CMDBINData *) pbdDelete);
            break;
        }
        case EXPANDSZ_METADATA: {
            delete ((CMDEXSZData *) pbdDelete);
            break;
        }
        case MULTISZ_METADATA: {
            delete ((CMDMLSZData *) pbdDelete);
            break;
        }
        default: {
            MD_ASSERT(FALSE);
            delete (pbdDelete);
        }
        }
    }
}

VOID
DeleteAllRemainingDataObjects()
{
    DWORD i;
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdSave;

    for (i = 0; i < DATA_HASH_TABLE_LEN; i++) {
        for (pbdIndex=g_ppbdDataHashTable[i];
            pbdIndex != NULL;
            pbdIndex = pbdSave) {
            pbdSave = pbdIndex->GetNextPtr();
            switch (pbdIndex->GetDataType()) {
            case DWORD_METADATA: {
                delete ((CMDDWData *) pbdIndex);
                break;
            }
            case STRING_METADATA: {
                delete ((CMDSTRData *) pbdIndex);
                break;
            }
            case BINARY_METADATA: {
                delete ((CMDBINData *) pbdIndex);
                break;
            }
            case EXPANDSZ_METADATA: {
                delete ((CMDEXSZData *) pbdIndex);
                break;
            }
            case MULTISZ_METADATA: {
                delete ((CMDMLSZData *) pbdIndex);
                break;
            }
            default: {
                MD_ASSERT(FALSE);
                delete (pbdIndex);
            }
            }
        }
    }
}


BOOL
ValidateData(IN PMETADATA_RECORD pmdrData,
             IN BOOL bUnicode)
/*++

Routine Description:

    Checks data values for new metadata.

Arguments:

    Data       - The data structure. All fields must be set.

        Attributes - The flags for the data.
                 METADATA_INHERIT - If set on input, inherited data will be returned.
                                    If not set on input, inherited data will not be returned.

                 METADATA_PARTIAL_PATH - If set on input, this routine will return ERROR_SUCCESS
                                    and the inherited data even if the entire path is not present.
                                    Only valid if METADATA_INHERIT is also set.

        DataType   - The Type of the data.
                 DWORD_METADATA
                 STRING_METADATA
                 BINARY_METADATA

Return Value:

    BOOL       - TRUE if the data values are valid.

Notes:
--*/
{
    BOOL bReturn = TRUE;

    if (((pmdrData->pbMDData == NULL) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) ||
                (((pmdrData->dwMDDataType == BINARY_METADATA) ||
                    (pmdrData->dwMDDataType == MULTISZ_METADATA)) &&
                        (pmdrData->dwMDDataLen > 0)))) ||
        (pmdrData->dwMDDataType <= ALL_METADATA) ||
        (pmdrData->dwMDDataType >= INVALID_END_METADATA) ||
        ((pmdrData->dwMDAttributes &
            ~(METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE | METADATA_VOLATILE | METADATA_INSERT_PATH | METADATA_LOCAL_MACHINE_ONLY))!=0) ||
        (((pmdrData->dwMDAttributes & METADATA_REFERENCE) != 0) &&
            ((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0)) ||
        (((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) || (pmdrData->dwMDDataType == BINARY_METADATA)))) {
        bReturn = FALSE;
    }

    if (bReturn && (pmdrData->dwMDDataType == MULTISZ_METADATA)) {
        if (bUnicode) {
            LPWSTR pszData = (LPWSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
			DWORD cch = dwDataLen / 2;
            if (dwDataLen > 0) {
                if (((cch) <= 1) ||
                    (pszData[(cch) - 1] != (WCHAR)L'\0') ||
                    (pszData[(cch) - 2] != (WCHAR)L'\0')) {
                    bReturn = FALSE;
                }
				else
				{
					for(ULONG i=0; (i<cch-1) &&(bReturn); i++)
					{
						if((pszData[i]   == (WCHAR)L'\0') &&
                           (pszData[i+1] == (WCHAR)L'\0') &&
						   ((i+1)        != (cch-1))
						  )
						{
							// Encountered an embedded NUL string
							bReturn = FALSE;
						}
					}
				}
            }
        }
        else {
            LPSTR pszData = (LPSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
			DWORD cch = dwDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen) == 1) ||
                    (pszData[(dwDataLen) - 1] != '\0') ||
                    (pszData[(dwDataLen) - 2] != '\0')) {
                    bReturn = FALSE;
                }
				else
				{
					for(ULONG i=0; (i<cch-1) &&(bReturn); i++)
					{
						if((pszData[i]   == (CHAR)'\0') &&
                           (pszData[i+1] == (CHAR)'\0') &&
						   ((i+1)        != (cch-1))
						  )
						{
							// Encountered an embedded NUL string
							bReturn = FALSE;
						}
					}
				}
            }
        }
    }

    return (bReturn);
}

CMDBaseData *
MakeDataObject(IN PMETADATA_RECORD pmdrData,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Looks for a data object matching the parameters.
    If found, increments the reference count. If not found, it
    creates it.

Arguments:

    Data - The data for the new object.

        Identifier - The Identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
//    CMDBaseData *pbdIndex;
    CMDBaseData *pbdReturn = NULL;
    CMDBaseData *pbdNew = NULL;
    DWORD dwHash = DATA_HASH(pmdrData->dwMDIdentifier);
//    BOOL bDataMatchError = FALSE;

//    for (pbdIndex = g_ppbdDataHashTable[dwHash];
//        (pbdIndex != NULL) &&
//        !DataMatch(pbdIndex, pmdrData, &bDataMatchError, bUnicode) &&
//        !bDataMatchError;
//        pbdIndex = pbdIndex->GetNextPtr()) {
//    }
//    if (!bDataMatchError) {
//        if (pbdIndex != NULL) {
//            pbdReturn = pbdIndex;
//            pbdReturn->IncrementReferenceCount();
//        }
//        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    pbdNew = new CMDDWData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, *(DWORD *)(pmdrData->pbMDData));
                    break;
                }
                case STRING_METADATA: {
                    pbdNew = new CMDSTRData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case BINARY_METADATA: {
                    pbdNew = new CMDBINData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, pmdrData->dwMDDataLen, pmdrData->pbMDData);
                    break;
                }
                case EXPANDSZ_METADATA: {
                    pbdNew = new CMDEXSZData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case MULTISZ_METADATA: {
                    pbdNew = new CMDMLSZData(pmdrData->dwMDIdentifier,
                                             pmdrData->dwMDAttributes,
                                             pmdrData->dwMDUserType,
                                             pmdrData->dwMDDataLen,
                                             (LPSTR)pmdrData->pbMDData,
                                             bUnicode);
                    break;
                }
                default: {
                    pbdNew = NULL;
                }
            }
            if (pbdNew != NULL) {
                if (!(pbdNew->IsValid())) {
                    delete (pbdNew);
                }
                else {
                    pbdNew->SetNextPtr(g_ppbdDataHashTable[dwHash]);
                    g_ppbdDataHashTable[dwHash] = pbdNew;
                    pbdReturn = pbdNew;
                }
            }
//        }
//    }
    return (pbdReturn);
}

HRESULT
GetHighestVersion(IN OUT STRAU *pstrauBackupLocation,
                  OUT DWORD *pdwVersion)
{
    long lHighestVersion = -1;
    long lVersion;
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathBytes = g_pstrBackupFilePath->QueryCB() + 1;
    DWORD dwNameBytes = pstrauBackupLocation->QueryCBA() - dwPathBytes;
    if (!pstrauBackupLocation->Append("*")) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (pstrauBackupLocation->QueryStrA() == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            hFile = FindFirstFile(pstrauBackupLocation->QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }
            else {
                //
                // Process the first file
                //

                //
                // dwNameBytes could be wrong for this assert in MBCS,
                // so call MBCS strlen. Subtract 1 char for appended '*'
                //

                MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                      wfdFile.cFileName,
                                      MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                if (CheckDigits(wfdFile.cFileName + (dwNameBytes))) {
                    //
                    // One of our files
                    //
                    lVersion = atol(wfdFile.cFileName + dwNameBytes);
                    if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                         (lVersion > lHighestVersion)) {
                        lHighestVersion = lVersion;
                    }
                }
                //
                // Process the remaining files
                //
                while (FindNextFile(hFile, &wfdFile)) {
                    MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                          wfdFile.cFileName,
                                          MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                    if (CheckDigits(wfdFile.cFileName + dwNameBytes)) {
                        //
                        // One of our files
                        //
                        lVersion = atol(wfdFile.cFileName + dwNameBytes);
                        if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                             (lVersion > lHighestVersion)) {
                            lHighestVersion = lVersion;
                        }
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                if (lHighestVersion == -1) {

                    //
                    // May not be an error, but need to indicate that
                    // no backups were found.
                    //

                    hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                }
                else if (lHighestVersion <= MD_BACKUP_MAX_VERSION) {
                        *pdwVersion = lHighestVersion;
                }
                else {
                        hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                }
            }
        }
        pstrauBackupLocation->SetLen(pstrauBackupLocation->QueryCCH() - 1);

    }

    return hresReturn;
}

BOOL
ValidateBackupLocation(LPSTR pszBackupLocation,
                       BOOL bUnicode)
{

    //
    // The main purpose of this routine is to make sure the user
    // is not putting in any file system controls, like .., /, etc.

    //
    // Secondarily, try to eliminate any characters that cannot be
    // used in database names
    //

    BOOL bReturn = TRUE;
    DWORD  dwStringLen;

    MD_ASSERT(pszBackupLocation != NULL);

    char *pszLocSave = setlocale(LC_CTYPE, NULL);    // Save cur locale
    setlocale(LC_CTYPE, "");                        // Set sys locale
    
    //
    // strcspn doesn't have an error return, but will return
    // the index of the terminating NULL if the chars are not found
    //

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (wcscspn((LPWSTR)pszBackupLocation, MD_BACKUP_INVALID_CHARS_W) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = (LPWSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)L'\0') &&
                     (iswprint(*pszIndex));
                 pszIndex++) {
            }
            if (*pszIndex != (WCHAR)L'\0') {
                bReturn = FALSE;

            }
        }
    }
    else {
        dwStringLen = _mbslen((PBYTE)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (_mbscspn((PBYTE)pszBackupLocation, (PBYTE)MD_BACKUP_INVALID_CHARS_A) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = (LPSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)L'\0') &&
                     (_ismbcprint(*pszIndex));
                     pszIndex = CharNextExA(CP_ACP,
                                            pszIndex,
                                            0)) {
            }
            if (*pszIndex != '\0') {
                bReturn = FALSE;

            }
        }
    }

    setlocale(LC_CTYPE, pszLocSave);
    return bReturn;
}

DWORD
GetBackupNameLen(LPSTR pszBackupName)

//
// Get Number of Bytes in name prior to suffix
//

{
    LPSTR pszSubString = NULL;
    LPSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = (LPSTR)MD_STRCHR(pszBackupName, '.')) != NULL);
    while (pszNextSubString != NULL) {

        //
        // In case the suffix happens to be part of the name
        //

        pszSubString = pszNextSubString;
        pszNextSubString = (LPSTR)MD_STRCHR(pszSubString+1, '.');
    }

    if (pszSubString
        && (pszSubString[1] != '\0')
        && (pszSubString[2] != '\0')
        && !IsDBCSLeadByte(pszSubString[1])
        && (toupper(pszSubString[1]) == 'M')
        && (toupper(pszSubString[2]) == 'D')) {
        return DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }

}

DWORD
GetBackupNameLen(LPWSTR pszBackupName)

//
// Get Number of WCHARs in name prior to version Number
//

{
    LPWSTR pszSubString = NULL;
    LPWSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = wcschr(pszBackupName, L'.')) != NULL);
    while (pszNextSubString != NULL) {
        pszSubString = pszNextSubString;
        pszNextSubString = wcschr(pszSubString+1, L'.');
    }
    if (pszSubString
        && (pszSubString[1] != L'\0')
        && (pszSubString[2] != L'\0')
        && (towupper(pszSubString[1]) == L'M')
        && (towupper(pszSubString[2]) == L'D')) {
        return DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }

}

HRESULT CreateBackupFileName(IN LPSTR pszMDBackupLocation,
                             IN DWORD dwMDVersion,
                             IN BOOL  bUnicode,
                             IN OUT STRAU *pstrauBackupLocation,
                             IN OUT STRAU *pstrauSchemaLocation)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszBackupLocation = pszMDBackupLocation;

    if (((dwMDVersion > MD_BACKUP_MAX_VERSION) &&
           (dwMDVersion != MD_BACKUP_NEXT_VERSION) &&
           (dwMDVersion != MD_BACKUP_HIGHEST_VERSION)) ||
        ((pszBackupLocation != NULL) &&
            !ValidateBackupLocation(pszBackupLocation, bUnicode))) {
        hresReturn = E_INVALIDARG;
    }
    else {

        if ((pszBackupLocation == NULL) ||
            (bUnicode && ((*(LPWSTR)pszBackupLocation) == (WCHAR)L'\0')) ||
            (!bUnicode && ((*(LPSTR)pszBackupLocation) == (CHAR)'\0'))) {
            pszBackupLocation = MD_DEFAULT_BACKUP_LOCATION;
            bUnicode = FALSE;
        }

        if (!pstrauBackupLocation->Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pstrauBackupLocation->Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (!pstrauBackupLocation->Append((LPWSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else {
                if (!pstrauBackupLocation->Append((LPSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ( !pstrauSchemaLocation->Copy( (LPWSTR)pstrauBackupLocation->QueryStr(TRUE) ) |
                 !pstrauBackupLocation->Append( MD_BACKUP_SUFFIX )                    |
                 !pstrauSchemaLocation->Append( MD_SCHEMA_SUFFIX )) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                DWORD dwVersion = dwMDVersion;
                if (dwVersion == MD_BACKUP_NEXT_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                    if (SUCCEEDED(hresReturn)) {
                        if (dwVersion < MD_BACKUP_MAX_VERSION) {
                            dwVersion++;
                        }
                        else {
                            hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                        }
                    }
                    else if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {

                        //
                        // Database doesn't exist, so new version is 0
                        //

                        dwVersion = 0;
                        hresReturn = ERROR_SUCCESS;
                    }
                }
                else if (dwVersion == MD_BACKUP_HIGHEST_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                }
                if (SUCCEEDED(hresReturn)) {
                    CHAR pszBuffer[MD_MAX_DWORD_STRING];
                    _ultoa((int)dwVersion, pszBuffer, 10);
                    if (!pstrauBackupLocation->Append(pszBuffer) |
                        !pstrauSchemaLocation->Append(pszBuffer)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Make sure the ANSI buffer is valid
            //
            if ( (pstrauBackupLocation->QueryStrA() == NULL) |
                 (pstrauSchemaLocation->QueryStrA() == NULL) ) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    return hresReturn;
}

HRESULT SetBackupPath(LPSTR pszBackupPath)
{
    DWORD dwReturn = ERROR_DIRECTORY;
    DWORD dwDirectoryAttributes;

    dwDirectoryAttributes = GetFileAttributes(pszBackupPath);

    if (dwDirectoryAttributes == 0xffffffff) {
        //
        // Can't get attributes
        // Path probably doesn't exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else if (!(CreateDirectory(pszBackupPath,
                                  NULL))) {
            dwReturn = GetLastError();
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }
    else if ((dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        //
        // If a directory
        //
        dwReturn = ERROR_SUCCESS;
    }
    if (dwReturn == ERROR_SUCCESS) {
        //
        // Got it! Now set global variable
        //
        MD_ASSERT(g_pstrBackupFilePath == NULL);
        g_pstrBackupFilePath = new STR(pszBackupPath);
        if (g_pstrBackupFilePath == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!(g_pstrBackupFilePath->IsValid())) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            delete g_pstrBackupFilePath;
            g_pstrBackupFilePath = NULL;
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetGlobalDataFileValues(LPTSTR pszFileName)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HANDLE hFileHandle;
    BOOL bMainFileFound = FALSE;
    LPWSTR pwszEnd = NULL;
    LPWSTR pwszStartRealNameWithoutPath = NULL;
    size_t  cch = 0;

    ResetMetabaseAttributesIfNeeded(pszFileName,
                                    FALSE);

    hFileHandle = CreateFile(pszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);
    if (hFileHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
        }
        else {
            hFileHandle = CreateFile(pszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_NEW,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                CloseHandle(hFileHandle);
                DeleteFile(pszFileName);
            }
        }
    }
    else {
        CloseHandle(hFileHandle);
        bMainFileFound = TRUE;
    }
    if (SUCCEEDED(hresReturn)) {
        g_strRealFileName = new STR(pszFileName);
        g_strSchemaFileName = new STR(pszFileName);
        g_strTempFileName = new STR(pszFileName);
        g_strBackupFileName = new STR(pszFileName);
        if( !g_strRealFileName || !g_strSchemaFileName || !g_strTempFileName || !g_strBackupFileName )
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            if (g_strSchemaFileName->IsValid()) {
                LPSTR szRealFileNameBegin = g_strRealFileName->QueryStr();
                LPSTR szEnd = strrchr(szRealFileNameBegin, '\\');
                if(NULL == szEnd) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                }
                else {
                    szEnd++;
                    g_strSchemaFileName->SetLen((DWORD)(szEnd-szRealFileNameBegin));
                }
            }
            if(SUCCEEDED(hresReturn)) {

                if(g_strSchemaFileName->IsValid()) {
                    g_strSchemaFileName->Append(MD_SCHEMA_FILE_NAME);
                }
                if (g_strTempFileName->IsValid()) {
                    g_strTempFileName->Append(MD_TEMP_DATA_FILE_EXT);
                }
                if (g_strBackupFileName->IsValid()) {
                    g_strBackupFileName->Append(MD_BACKUP_DATA_FILE_EXT);
                }
                if (!g_strSchemaFileName->IsValid() || !g_strTempFileName->IsValid() || !g_strBackupFileName->IsValid()) 
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            if(SUCCEEDED(hresReturn)) {

                hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         0);
                if (hFileHandle == INVALID_HANDLE_VALUE) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        hresReturn = RETURNCODETOHRESULT(GetLastError());
                    }
                    else {
                        hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 0);
                        if (hFileHandle == INVALID_HANDLE_VALUE) {
                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                        }
                        else {
                            CloseHandle(hFileHandle);
                            DeleteFile(g_strTempFileName->QueryStr());
                        }
                    }
                }
                else {
                    CloseHandle(hFileHandle);
                }

                if (SUCCEEDED(hresReturn)) {
                    hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                    if (hFileHandle == INVALID_HANDLE_VALUE) {
                        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                        }
                        else {
                            hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                                     GENERIC_READ | GENERIC_WRITE,
                                                     0,
                                                     NULL,
                                                     CREATE_NEW,
                                                     FILE_ATTRIBUTE_NORMAL,
                                                     0);
                            if (hFileHandle == INVALID_HANDLE_VALUE) {
                                hresReturn = RETURNCODETOHRESULT(GetLastError());
                            }
                            else {
                                CloseHandle(hFileHandle);
                                DeleteFile(g_strBackupFileName->QueryStr());
                            }
                        }
                    }
                    else {
                        CloseHandle(hFileHandle);
                        if (!bMainFileFound) {
                            if (!MoveFile(g_strBackupFileName->QueryStr(), pszFileName)) {
                                hresReturn = RETURNCODETOHRESULT(GetLastError());
                            }
                        }
                    }
                }
            }
        }

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = SetUnicodeGlobalDataFileValues();
        }

        if (FAILED(hresReturn)) 
        {
            if( g_strRealFileName )
            {
                delete(g_strRealFileName);
                g_strRealFileName = NULL;
            }
            if(g_strSchemaFileName)
            {
                delete(g_strSchemaFileName);
                g_strSchemaFileName = NULL;
            }
            if( g_strTempFileName )
            {   
                delete(g_strTempFileName);
                g_strRealFileName = NULL;
            }

            if( g_strBackupFileName )
            {
                delete(g_strBackupFileName);
                g_strRealFileName = NULL;
            }
        }
    }
    return hresReturn;
}


HRESULT
SetUnicodeGlobalDataFileValues()
//
//  Create unicode versions of the realfilename, tempfilename, backupfilename
//  metabasedir, historyfiledir, schemaextensions file for use by catalog
//
{
    HRESULT hr      = S_OK;
    LPWSTR  pwsz    = NULL;

    // Temp File name

    hr = GetUnicodeName(g_strTempFileName->QueryStr(), 
                        &g_wszTempFileName);

    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchTempFileName = wcslen(g_wszTempFileName);
    
    // Real File name
    
    hr = GetUnicodeName(g_strRealFileName->QueryStr(), 
                        &g_wszRealFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchRealFileName = wcslen(g_wszRealFileName);
            
    // Backup File name

    hr = GetUnicodeName(g_strBackupFileName->QueryStr(), 
                        &g_wszBackupFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchBackupFileName = wcslen(g_wszBackupFileName);

    // Schema File name

    hr = GetUnicodeName(g_strSchemaFileName->QueryStr(), 
                        &g_wszSchemaFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    g_cchSchemaFileName = wcslen(g_wszSchemaFileName);

    // Position pwsz where real file name begins ie past last backslash.

    pwsz = wcsrchr(g_wszRealFileName, L'\\');
    if(NULL == pwsz)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }
    pwsz++;

    // Real File name without path

    g_cchRealFileNameWithoutPath = wcslen(pwsz);
    g_wszRealFileNameWithoutPath = new WCHAR[g_cchRealFileNameWithoutPath+1];
    if(NULL == g_wszRealFileNameWithoutPath)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    wcscpy(g_wszRealFileNameWithoutPath, pwsz);

    // Create metabase directory, end with backslash

    g_cchMetabaseDir = (ULONG)(pwsz-g_wszRealFileName);
    g_wszMetabaseDir = new WCHAR[g_cchMetabaseDir+1];
    if(NULL == g_wszMetabaseDir)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    memcpy(g_wszMetabaseDir, g_wszRealFileName, g_cchMetabaseDir*sizeof(WCHAR));
    g_wszMetabaseDir[g_cchMetabaseDir] = L'\0';

    // Real File name without path & without extension

    pwsz = wcsrchr(g_wszRealFileNameWithoutPath, MD_CH_EXTN_SEPERATORW);

    g_cchRealFileNameWithoutPathWithoutExtension = g_cchRealFileNameWithoutPath;
    g_wszRealFileNameWithoutPathWithoutExtension = new WCHAR[g_cchRealFileNameWithoutPathWithoutExtension +1];
    if(NULL == g_wszRealFileNameWithoutPathWithoutExtension)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    else if(NULL != pwsz)
    {
        g_cchRealFileNameWithoutPathWithoutExtension = (ULONG)(pwsz - g_wszRealFileNameWithoutPath);
        memcpy(g_wszRealFileNameWithoutPathWithoutExtension, g_wszRealFileNameWithoutPath, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszRealFileNameWithoutPathWithoutExtension[g_cchRealFileNameWithoutPathWithoutExtension] = L'\0';

        // Real File name extension

        g_cchRealFileNameExtension = wcslen(pwsz);
        g_wszRealFileNameExtension = new WCHAR[g_cchRealFileNameExtension+1];
        if(NULL == g_wszRealFileNameExtension)
        {
            hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        memcpy(g_wszRealFileNameExtension, pwsz, g_cchRealFileNameExtension*sizeof(WCHAR));
        g_wszRealFileNameExtension[g_cchRealFileNameExtension] = L'\0';
    }
    else
    {
        memcpy(g_wszRealFileNameWithoutPathWithoutExtension,g_wszRealFileNameWithoutPath,g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszRealFileNameWithoutPathWithoutExtension[g_cchRealFileNameExtension] = L'\0';
    }

    // Position pwsz where schema file name begins ie past last backslash.

    pwsz = wcsrchr(g_wszSchemaFileName, L'\\');
    if(NULL == pwsz)
    {
        hr = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        goto exit;
    }
    pwsz++;

    // Schema File name without path

    g_cchSchemaFileNameWithoutPath = wcslen(pwsz);
    g_wszSchemaFileNameWithoutPath = new WCHAR[g_cchSchemaFileNameWithoutPath+1];
    if(NULL == g_wszSchemaFileNameWithoutPath)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    wcscpy(g_wszSchemaFileNameWithoutPath, pwsz);

    // Schema File name without path & without extension

    pwsz = wcsrchr(g_wszSchemaFileNameWithoutPath, MD_CH_EXTN_SEPERATORW);

    g_cchSchemaFileNameWithoutPathWithoutExtension = g_cchSchemaFileNameWithoutPath;
    g_wszSchemaFileNameWithoutPathWithoutExtension = new WCHAR[g_cchSchemaFileNameWithoutPathWithoutExtension +1];
    if(NULL == g_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    else if(NULL != pwsz)
    {
        g_cchSchemaFileNameWithoutPathWithoutExtension = (ULONG)(pwsz - g_wszSchemaFileNameWithoutPath);
        memcpy(g_wszSchemaFileNameWithoutPathWithoutExtension, g_wszSchemaFileNameWithoutPath, g_cchSchemaFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszSchemaFileNameWithoutPathWithoutExtension[g_cchSchemaFileNameWithoutPathWithoutExtension] = L'\0';

        // Schema File name extension

        g_cchSchemaFileNameExtension = wcslen(pwsz);
        g_wszSchemaFileNameExtension = new WCHAR[g_cchSchemaFileNameExtension+1];
        if(NULL == g_wszSchemaFileNameExtension)
        {
            hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        memcpy(g_wszSchemaFileNameExtension, pwsz, g_cchSchemaFileNameExtension*sizeof(WCHAR));
        g_wszSchemaFileNameExtension[g_cchSchemaFileNameExtension] = L'\0';
    }
    else
    {
        memcpy(g_wszSchemaFileNameWithoutPathWithoutExtension,g_wszSchemaFileNameWithoutPath,g_cchSchemaFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
        g_wszSchemaFileNameWithoutPathWithoutExtension[g_cchSchemaFileNameExtension] = L'\0';
    }

    // Create history file dir, end with backslash

    g_cchHistoryFileDir = g_cchMetabaseDir + MD_CCH_HISTORY_FILE_SUBDIRW;
    g_wszHistoryFileDir = new WCHAR[g_cchHistoryFileDir+1];
    if(NULL == g_wszHistoryFileDir)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    pwsz    = g_wszHistoryFileDir;
    memcpy(pwsz, g_wszMetabaseDir, g_cchMetabaseDir*sizeof(WCHAR));
    pwsz    = pwsz + g_cchMetabaseDir;
    memcpy(pwsz, MD_HISTORY_FILE_SUBDIRW, MD_CCH_HISTORY_FILE_SUBDIRW*sizeof(WCHAR));
    pwsz    = pwsz + MD_CCH_HISTORY_FILE_SUBDIRW; // This contains the backslash
    *pwsz   = L'\0';

    // Create history file seach string Eg: D:\WINNT\System32\inetsrv\History\Metabase_??????????_??????????.XML

    g_cchHistoryFileSearchString = g_cchHistoryFileDir                           + 
                                   g_cchRealFileNameWithoutPathWithoutExtension  + 
                                   MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW         +
                                   g_cchRealFileNameExtension; 

    if((g_cchHistoryFileSearchString + 1) > MAX_PATH)
    {
        g_cchHistoryFileSearchString += MD_CCH_LONG_STRING_PREFIXW;
    }

    g_wszHistoryFileSearchString = new WCHAR[g_cchHistoryFileSearchString + 1];
    if(NULL == g_wszHistoryFileSearchString)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    pwsz = g_wszHistoryFileSearchString;
    if((g_cchHistoryFileSearchString + 1) > MAX_PATH)
    {
        memcpy(pwsz, MD_LONG_STRING_PREFIXW, MD_CCH_LONG_STRING_PREFIXW*sizeof(WCHAR));
        pwsz = pwsz + (MD_CCH_LONG_STRING_PREFIXW);
    }
    memcpy(pwsz, g_wszHistoryFileDir, g_cchHistoryFileDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchHistoryFileDir;
    memcpy(pwsz, g_wszRealFileNameWithoutPathWithoutExtension, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pwsz = pwsz + g_cchRealFileNameWithoutPathWithoutExtension;
    memcpy(pwsz, MD_HISTORY_FILE_SEARCH_EXTENSIONW, MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
    if(NULL != g_wszRealFileNameExtension)
    {
        memcpy(pwsz, g_wszRealFileNameExtension, g_cchRealFileNameExtension*sizeof(WCHAR));
        pwsz = pwsz + g_cchRealFileNameExtension;
    }
    *pwsz = L'\0';

    // Create error file search string Eg: D:\WINNT\System32\inetsrv\History\MetabaseError_??????????.XML

    g_cchErrorFileSearchString = g_cchHistoryFileDir                          +
                                 g_cchRealFileNameWithoutPathWithoutExtension +
                                 MD_CCH_ERROR_FILE_NAME_EXTENSIONW            +
                                 MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW          +
                                 g_cchRealFileNameExtension;

    if((g_cchErrorFileSearchString + 1) > MAX_PATH)
    {
        g_cchErrorFileSearchString += MD_CCH_LONG_STRING_PREFIXW;
    }

    g_wszErrorFileSearchString = new WCHAR[g_cchErrorFileSearchString+1];
    if(NULL == g_wszErrorFileSearchString)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    pwsz = g_wszErrorFileSearchString;
    if((g_cchErrorFileSearchString + 1) > MAX_PATH)
    {
        memcpy(pwsz,MD_LONG_STRING_PREFIXW, MD_CCH_LONG_STRING_PREFIXW*sizeof(WCHAR));
        pwsz = pwsz + MD_CCH_LONG_STRING_PREFIXW;
    }
    memcpy(pwsz, g_wszHistoryFileDir, g_cchHistoryFileDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchHistoryFileDir;
    memcpy(pwsz, g_wszRealFileNameWithoutPathWithoutExtension, g_cchRealFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pwsz = pwsz + g_cchRealFileNameWithoutPathWithoutExtension;
    memcpy(pwsz, MD_ERROR_FILE_NAME_EXTENSIONW, MD_CCH_ERROR_FILE_NAME_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_ERROR_FILE_NAME_EXTENSIONW;
    memcpy(pwsz, MD_ERROR_FILE_SEARCH_EXTENSIONW, MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_ERROR_FILE_SEARCH_EXTENSIONW;
    if(NULL != g_wszRealFileNameExtension)
    {
        memcpy(pwsz, g_wszRealFileNameExtension, g_cchRealFileNameExtension*sizeof(WCHAR));
        pwsz = pwsz + g_cchRealFileNameExtension;
    }
    *pwsz = L'\0';

    // Create schema extensions file. Eg: D:\WINNT\System32\inetsrv\MBSchExt.XML

    g_cchSchemaExtensionFile = g_cchMetabaseDir                  +
                               MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW;
                               
    g_wszSchemaExtensionFile = new WCHAR[g_cchSchemaExtensionFile+1];
    if(NULL == g_wszSchemaExtensionFile)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    pwsz = g_wszSchemaExtensionFile;
    memcpy(pwsz, g_wszMetabaseDir, g_cchMetabaseDir*sizeof(WCHAR));
    pwsz = pwsz + g_cchMetabaseDir;
    memcpy(pwsz, MD_SCHEMA_EXTENSION_FILE_NAMEW, MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW*sizeof(WCHAR));
    pwsz = pwsz + MD_CCH_SCHEMA_EXTENSION_FILE_NAMEW;
    *pwsz = L'\0';

    DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nTempFileName%s:%d\nRealFileName:%s::%d\nBackupFileName:%s::%d\nSchemaFileName:%s::%d\nRealFileNameWithoutPath:%s::%d\nRealFileNameWithoutPathWithoutExtension:%s::%d\nMetabaseDir:%s::%d\nSchemaFileNameWithoutPath:%s::%d\nSchemaFileNameWithoutPathWithoutExtension:%s::%d\nHistoryFileDir:%s::%d\nHistoryFileSearchString:%s::%d\nErrorFileSearchString:%s::%d\nSchemaExtensionFile:%s::%d\n",
              g_wszTempFileName,
              g_cchTempFileName,
              g_wszRealFileName,
              g_cchRealFileName,
              g_wszBackupFileName,
              g_cchBackupFileName,
              g_wszSchemaFileName,
              g_cchSchemaFileName,
              g_wszRealFileNameWithoutPath,
              g_cchRealFileNameWithoutPath,
              g_wszRealFileNameWithoutPathWithoutExtension,
              g_cchRealFileNameWithoutPathWithoutExtension,
              g_wszMetabaseDir,
              g_cchMetabaseDir,
              g_wszSchemaFileNameWithoutPath,
              g_cchSchemaFileNameWithoutPath,
              g_wszSchemaFileNameWithoutPathWithoutExtension,
              g_cchSchemaFileNameWithoutPathWithoutExtension,
              g_wszHistoryFileDir,
              g_cchHistoryFileDir,
              g_wszHistoryFileSearchString,
              g_cchHistoryFileSearchString,
              g_wszErrorFileSearchString,
              g_cchErrorFileSearchString,
              g_wszSchemaExtensionFile,
              g_cchSchemaExtensionFile));

    if(NULL != g_wszRealFileNameExtension)
    {
        DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nRealFileNameExtension:%s::%d\n",
              g_wszRealFileNameExtension,
              g_cchRealFileNameExtension));
    }

    if(NULL != g_wszSchemaFileNameExtension)
    {
        DBGINFOW((DBG_CONTEXT,
              L"[SetUnicodeGlobalDataFileValues]\nSchemaFileNameExtension:%s::%d\n",
              g_wszSchemaFileNameExtension,
              g_cchSchemaFileNameExtension));
    }

exit:

    if(FAILED(hr))
    {
        UnInitializeUnicodeGlobalDataFileValues();
    }
    else
    {
        hr = RETURNCODETOHRESULT(ERROR_SUCCESS);
    }
    
    return hr;

}

void
InitializeUnicodeGlobalDataFileValues()
{
    g_wszTempFileName                               = NULL;
    g_cchTempFileName                               = 0;

    g_wszRealFileName                               = NULL;
    g_cchRealFileName                               = 0;

    g_wszBackupFileName                             = NULL;
    g_cchBackupFileName                             = 0;

    g_wszSchemaFileName                             = NULL;
    g_cchSchemaFileName                             = 0;

    g_wszRealFileNameWithoutPath                    = NULL;
    g_cchRealFileNameWithoutPath                    = 0;

    g_wszMetabaseDir                                = NULL;
    g_cchMetabaseDir                                = 0;

    g_wszRealFileNameWithoutPathWithoutExtension     = NULL;
    g_cchRealFileNameWithoutPathWithoutExtension     = 0;

    g_wszRealFileNameExtension                      = NULL;
    g_cchRealFileNameExtension                      = 0;

    g_wszSchemaFileNameWithoutPath                  = NULL;
    g_cchSchemaFileNameWithoutPath                  = 0;

    g_wszSchemaFileNameWithoutPathWithoutExtension   = NULL;
    g_cchSchemaFileNameWithoutPathWithoutExtension   = 0;

    g_wszSchemaFileNameExtension                    = NULL;
    g_cchSchemaFileNameExtension                    = 0;

    g_wszHistoryFileDir                             = NULL;
    g_cchHistoryFileDir                             = 0;

    g_wszHistoryFileSearchString                    = NULL;
    g_cchHistoryFileSearchString                    = 0;

    g_wszErrorFileSearchString                      = NULL;
    g_cchErrorFileSearchString                      = 0;

    g_wszSchemaExtensionFile                        = NULL;
    g_cchSchemaExtensionFile                        = 0;

    return;
}

void
UnInitializeUnicodeGlobalDataFileValues()
{
    if(NULL != g_wszTempFileName)
    {
        delete [] g_wszTempFileName;
        g_wszTempFileName = NULL;
        g_cchTempFileName = 0;
    }

    if(NULL != g_wszRealFileName)
    {
        delete [] g_wszRealFileName;
        g_wszRealFileName = NULL;
        g_cchRealFileName = 0;

    }

    if(NULL != g_wszBackupFileName)
    {
        delete [] g_wszBackupFileName;
        g_wszBackupFileName = NULL;
        g_cchBackupFileName = 0;

    }

    if(NULL != g_wszSchemaFileName)
    {
        delete [] g_wszSchemaFileName;
        g_wszSchemaFileName = NULL;
        g_cchSchemaFileName = 0;

    }

    if(NULL != g_wszRealFileNameWithoutPath)
    {
        delete [] g_wszRealFileNameWithoutPath;
        g_wszRealFileNameWithoutPath = NULL;
        g_cchRealFileNameWithoutPath = 0;

    }

    if(NULL != g_wszMetabaseDir)
    {
        delete [] g_wszMetabaseDir;
        g_wszMetabaseDir = NULL;
        g_cchMetabaseDir = 0;

    }

    if(NULL != g_wszRealFileNameWithoutPathWithoutExtension)
    {
        delete [] g_wszRealFileNameWithoutPathWithoutExtension;
        g_wszRealFileNameWithoutPathWithoutExtension = NULL;
        g_cchRealFileNameWithoutPathWithoutExtension = 0;

    }

    if(NULL != g_wszRealFileNameExtension)
    {
        delete [] g_wszRealFileNameExtension;
        g_wszRealFileNameExtension = NULL;
        g_cchRealFileNameExtension = 0;

    }

    if(NULL != g_wszSchemaFileNameWithoutPath)
    {
        delete [] g_wszSchemaFileNameWithoutPath;
        g_wszSchemaFileNameWithoutPath = NULL;
        g_cchSchemaFileNameWithoutPath = 0;
    }

    if(NULL != g_wszSchemaFileNameWithoutPathWithoutExtension)
    {
        delete [] g_wszSchemaFileNameWithoutPathWithoutExtension;
        g_wszSchemaFileNameWithoutPathWithoutExtension = NULL;
        g_cchSchemaFileNameWithoutPathWithoutExtension = 0;

    }

    if(NULL != g_wszSchemaFileNameExtension)
    {
        delete [] g_wszSchemaFileNameExtension;
        g_wszSchemaFileNameExtension = NULL;
        g_cchSchemaFileNameExtension = 0;

    }

    if(NULL != g_wszHistoryFileDir)
    {
        delete [] g_wszHistoryFileDir;
        g_wszHistoryFileDir = NULL;
        g_cchHistoryFileDir = 0;

    }

    if(NULL != g_wszHistoryFileSearchString)
    {
        delete [] g_wszHistoryFileSearchString;
        g_wszHistoryFileSearchString = NULL;
        g_cchHistoryFileSearchString = 0;
    }
    if(NULL != g_wszErrorFileSearchString)
    {
        delete [] g_wszErrorFileSearchString;
        g_wszErrorFileSearchString = NULL;
        g_cchErrorFileSearchString = 0;
    }

    if(NULL != g_wszSchemaExtensionFile)
    {
        delete [] g_wszSchemaExtensionFile;
        g_wszSchemaExtensionFile = NULL;
        g_cchSchemaExtensionFile = 0;
    }

    return;
}

HRESULT
SetDataFile()
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    TCHAR pszBuffer[MAX_PATH];
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);
    BOOL bAppendSlash = FALSE;
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             ADMIN_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) {
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                      MD_FILE_VALUE,
                                      NULL,
                                      &dwType,
                                      (BYTE *) pszBuffer,
                                      &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
            hresReturn = SetGlobalDataFileValues(pszBuffer);
        }

        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        hkRegistryKey = NULL;

    }
    if (FAILED(hresReturn)) {
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 SETUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          INSTALL_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                dwSize /= sizeof(TCHAR);
                if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                    (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                    bAppendSlash = TRUE;
                }
                if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                    if (bAppendSlash) {
                        pszBuffer[dwSize-1] = (TCHAR)'\\';
                        pszBuffer[dwSize] = (TCHAR)'\0';
                    }
                    MD_STRCAT(pszBuffer, MD_DEFAULT_DATA_FILE_NAME);
                    hresReturn = SetGlobalDataFileValues(pszBuffer);
                }
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }
        else {
            hresReturn = RETURNCODETOHRESULT(dwRegReturn);
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Now get the backup path.
        //
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 METADATA_BACKUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          MD_BACKUP_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if (dwRegReturn == ERROR_SUCCESS) {
                hresReturn = SetBackupPath(pszBuffer);
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }

        if (FAILED(hresReturn)) {
            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                     SETUP_REG_KEY,
                                     &hkRegistryKey);
            if (dwRegReturn == ERROR_SUCCESS) {
                dwSize = MAX_PATH * sizeof(TCHAR);
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                              INSTALL_PATH_VALUE,
                                              NULL,
                                              &dwType,
                                              (BYTE *) pszBuffer,
                                              &dwSize);
                if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                    dwSize /= sizeof(TCHAR);
                    if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                        (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                        bAppendSlash = TRUE;
                    }
                    if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                        if (bAppendSlash) {
                            pszBuffer[dwSize-1] = (TCHAR)'\\';
                            pszBuffer[dwSize] = (TCHAR)'\0';
                        }
                        MD_STRCAT(pszBuffer, MD_DEFAULT_BACKUP_PATH_NAME);
                        hresReturn = SetBackupPath(pszBuffer);
                    }
                }
                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
            }
            else {
                hresReturn = RETURNCODETOHRESULT(dwRegReturn);
            }
        }
    }

    return hresReturn;
}

DWORD GetObjectPath(CMDBaseObject *pboObject,
                    BUFFER *pbufPath,
                    DWORD &rdwStringLen,
                    CMDBaseObject *pboTopObject,
                    IN BOOL bUnicode)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwOldStringLen;

    MD_ASSERT(pboObject != NULL);
    if (pboObject != pboTopObject) {
        dwReturn = GetObjectPath(pboObject->GetParent(),
                                 pbufPath,
                                 rdwStringLen,
                                 pboTopObject,
                                 bUnicode);
        dwOldStringLen = rdwStringLen;
        if (pboObject->GetName(bUnicode) == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            if (bUnicode) {
                rdwStringLen += (1 + wcslen((LPWSTR)pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(WCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPWSTR lpzStringEnd = (LPWSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERW;
                    wcscpy(lpzStringEnd+1, (LPWSTR)(pboObject->GetName(bUnicode)));
                }
            }
            else {
                rdwStringLen += (1 + MD_STRBYTES(pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(TCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPTSTR lpzStringEnd = (LPTSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERA;
                    MD_STRCPY(lpzStringEnd+1, pboObject->GetName(bUnicode));
                }
            }
        }
    }
    return dwReturn;
}


HRESULT
MakeInsertPathData(STRAU *pstrauNewData,
                   LPTSTR pszPath,
                   LPTSTR pszOldData,
                   DWORD *pdwDataLen,
                   BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (bUnicode) {
        LPWSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = (LPWSTR)pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = wcsstr(pszDataIndex, MD_INSERT_PATH_STRINGW)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGW) / sizeof(WCHAR)) - 1))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append((LPWSTR)pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(WCHAR);
    }
    else {
        LPTSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = MD_STRSTR(pszDataIndex, MD_INSERT_PATH_STRINGA)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGA) - 1)))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append(pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(CHAR);
    }
    return hresReturn;
}

HRESULT
InsertPathIntoData(BUFFER *pbufNewData,
                   STRAU *pstrData,
                   PBYTE *ppbNewData,
                   DWORD *pdwNewDataLen,
                   CMDBaseData *pbdRetrieve,
                   METADATA_HANDLE hHandle,
                   CMDBaseObject *pboDataMetaObject,
                   IN BOOL bUnicode)
{
    //
    // Need to insert path
    //
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathLen = 0;
    BUFFER bufPath;
    CMDHandle * pCMDHandle = GetHandleObject(hHandle);
    PREFIX_ASSUME(pCMDHandle != NULL, "GetHandleObject(hHandle) is guaranteed not to return NULL");
    CMDBaseObject *pboHandleMetaObject = pCMDHandle->GetObject();

    MD_ASSERT((pbdRetrieve->GetDataType() != DWORD_METADATA) &&
        (pbdRetrieve->GetDataType() != BINARY_METADATA));

    if (pboHandleMetaObject->GetObjectLevel() > pboDataMetaObject->GetObjectLevel()) {
        hresReturn = MD_WARNING_PATH_NOT_INSERTED;
    }
    else {
        DWORD dwReturn;
        if ( (dwReturn = GetObjectPath(pboDataMetaObject,
                                       &bufPath,
                                       dwPathLen,
                                       pboHandleMetaObject,
                                       bUnicode)) != ERROR_SUCCESS) {
            hresReturn = RETURNCODETOHRESULT(dwReturn);
        }
        else if (!bufPath.Resize((dwPathLen + 2) * ((bUnicode) ? sizeof(WCHAR) : sizeof(CHAR)))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            LPTSTR pszPath;
            LPTSTR  pszOriginalData;
            DWORD dwDataLen;
            pszPath = (LPTSTR)(bufPath.QueryPtr());
            if (bUnicode) {
                ((LPWSTR)pszPath)[dwPathLen] = MD_PATH_DELIMETERW;
                ((LPWSTR)pszPath)[dwPathLen + 1] = (WCHAR)L'\0';
            }
            else {
                pszPath[dwPathLen] = MD_PATH_DELIMETERA;
                pszPath[dwPathLen + 1] = (TCHAR)'\0';
            }
            //
            // If there was an error in GetData, it would have been
            // caught already.
            //
            MD_ASSERT(pbdRetrieve->GetData(bUnicode) != NULL);
            switch (pbdRetrieve->GetDataType()) {
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                {
                    hresReturn = MakeInsertPathData(pstrData,
                                             (LPTSTR)bufPath.QueryPtr(),
                                             (LPTSTR)pbdRetrieve->GetData(bUnicode),
                                             &dwDataLen,
                                             bUnicode);
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // QueryStr should not fail in this instance
                        // since it was created with the same unicode flag
                        //
                        MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                        *ppbNewData = (PBYTE) pstrData->QueryStr(bUnicode);
                        *pdwNewDataLen = dwDataLen;
                    }
                }
                break;
            case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPWSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (WCHAR)L'\0');
                             pszDataIndex += (wcslen(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                            (LPSTR)bufPath.QueryPtr(),
                                                            (LPSTR)pszDataIndex,
                                                            &dwStringBytes,
                                                            bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen,
                                            pstrData->QueryStr(bUnicode),
                                            dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(WCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(((LPWSTR)(*ppbNewData)) + ((dwDataLen / sizeof(WCHAR)) - 1)) = (WCHAR)L'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                    else {
                        LPSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPTSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (CHAR)'\0');
                             pszDataIndex += (MD_STRBYTES(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                     (LPTSTR)bufPath.QueryPtr(),
                                                     pszDataIndex,
                                                     &dwStringBytes);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStrA() != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen, pstrData->QueryStrA(), dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(TCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(*ppbNewData + (dwDataLen-1)) = (CHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                }
                break;
            default:
                MD_ASSERT(FALSE);
            }
        }
    }
    return hresReturn;
}

HRESULT
MakeTreeCopyWithPath(CMDBaseObject *pboSource,
                     CMDBaseObject *&rpboNew,
                     LPSTR pszPath,
                     IN BOOL bUnicode)
{
    WCHAR pszName[METADATA_MAX_NAME_LEN];
    LPSTR pszTempPath = pszPath;
    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboParent = NULL;
    CMDBaseObject *pboTree = NULL;
    CMDBaseObject *pboRoot = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresExtractReturn;

    while ((SUCCEEDED(hresReturn)) &&
        (SUCCEEDED(hresExtractReturn = ExtractNameFromPath(pszTempPath, (LPSTR)pszName, bUnicode)))) {

        if (bUnicode) {
            pboNew = new CMDBaseObject((LPWSTR)pszName);
        }
        else {
            pboNew = new CMDBaseObject((LPSTR)pszName);
        }
        if (pboNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pboNew->IsValid()) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            delete (pboNew);
        }
        else {
            if (pboParent != NULL) {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete pboNew;
                    pboNew = pboParent;
                }
            }
            pboParent = pboNew;
        }
    }

    if ((SUCCEEDED(hresReturn)) && (hresExtractReturn != (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)))) {
        hresReturn = hresExtractReturn;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Don't really want the leaf object, as MakeTreeCopy will create it.
        //

        LPWSTR pszTreeName = NULL;

        if (pboNew != NULL) {
            pszTreeName = (LPWSTR)pboNew->GetName(TRUE);
            pboParent = pboNew->GetParent();
            if (pszTreeName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            hresReturn = MakeTreeCopy(pboSource, pboTree, (LPSTR)pszTreeName, TRUE);

            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(pboTree != NULL);

                if (pboParent != NULL) {
                    MD_REQUIRE(SUCCEEDED(pboParent->RemoveChildObject(pboNew)));
                    hresReturn = pboParent->InsertChildObject(pboTree);
                    if (FAILED(hresReturn)) {
                        delete(pboTree);
                        pboTree = NULL;
                    }
                }
            }
        }
        delete(pboNew);
        pboNew = NULL;
    }

    if (FAILED(hresReturn)) {
        if (pboParent != NULL) {
            CMDBaseObject *pboTemp;
            MD_ASSERT(pboNew != NULL);
            for (pboTemp = pboParent; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
            }
            //
            // destructor recurses through child objects
            //
            delete pboTemp;
        }
    }
    else {
        MD_ASSERT(pboTree != NULL);
        CMDBaseObject *pboTemp;
        for (pboTemp = pboTree; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
        }
        rpboNew = pboTemp;
    }

    return hresReturn;
}

HRESULT
MakeTreeCopy(CMDBaseObject *pboSource,
             CMDBaseObject *&rpboNew,
             LPSTR pszName,
             IN BOOL bUnicode)
{
    CMDBaseObject *pboTemp = NULL;
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pszName == NULL) {
        if ((pboSource->GetName(TRUE)) != NULL) {
            pboTemp = new CMDBaseObject((LPWSTR)(pboSource->GetName(TRUE)), NULL);
        }
    }
    else {
        if (bUnicode) {
            pboTemp = new CMDBaseObject((LPWSTR)pszName, NULL);
        }
        else {
            pboTemp = new CMDBaseObject((LPSTR)pszName, NULL);
        }
    }
    if (pboTemp == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else if (!pboTemp->IsValid()) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete (pboTemp);
    }
    else {
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
        for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
            pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
            MD_ASSERT(pbdCurrent != NULL);
            hresReturn = pboTemp->SetDataObject(pbdCurrent);
        }
        FreeMainDataBuffer(ppvMainDataBuf);
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild, NULL, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT (pboNewChild != NULL);
                hresReturn = pboTemp->InsertChildObject(pboNewChild);
            }
            i++;
            pboOldChild = pboSource->EnumChildObject(i);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        rpboNew = pboTemp;
    }
    else {
        rpboNew = NULL;
        delete(pboTemp);
    }
    return (hresReturn);
}

void
AddNewChangeData(CMDHandle *phoDestHandle,
                 CMDBaseObject *pboNew)
{
    DWORD i, dwNumDataObjects;
    CMDBaseObject *pboChild;
    CMDBaseData *pbdCurrent;

    MD_ASSERT(pboNew != NULL);

    phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
    if ((pbdCurrent = pboNew->EnumDataObject(0, 0, ALL_METADATA, ALL_METADATA)) != NULL) {
        phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
    }
    i = 0;
    pboChild = pboNew->EnumChildObject(i);
    while (pboChild != NULL) {
        AddNewChangeData(phoDestHandle, pboChild);
        i++;
        pboChild = pboNew->EnumChildObject(i);
    }
}

HRESULT
CopyTree(CMDHandle *phoDestParentHandle,
         CMDBaseObject *pboDest,
         CMDBaseObject *pboSource,
         BOOL &rbChanged)

{
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    LPSTR pszTempName;
    HRESULT hresReturn = ERROR_SUCCESS;

    MD_ASSERT(pboDest != NULL);
    MD_ASSERT(pboSource != NULL);
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
    for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        PREFIX_ASSUME(pbdCurrent != NULL, "pbdCurrent is guaranteed not to NULL here");
        hresReturn = pboDest->SetDataObject(pbdCurrent);
        if (SUCCEEDED(hresReturn)) {
            rbChanged = TRUE;
            phoDestParentHandle->SetChangeData(pboDest, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
        }
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            pszTempName = (pboOldChild->GetName(TRUE));
            if (pszTempName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                pboNewChild = pboDest->GetChildObject(pszTempName, &hresReturn, TRUE);
                if (SUCCEEDED(hresReturn)) {
                    if (pboNewChild != NULL) {
                        hresReturn = CopyTree(phoDestParentHandle, pboNewChild, pboOldChild, rbChanged);
                    }
                    else {
                        hresReturn = MakeTreeCopy(pboOldChild, pboNewChild);
                        if (SUCCEEDED(hresReturn)) {
                            MD_ASSERT (pboNewChild != NULL);
                            hresReturn = pboDest->InsertChildObject(pboNewChild);
                            if (SUCCEEDED(hresReturn)) {
                                rbChanged = TRUE;
                                AddNewChangeData(phoDestParentHandle, pboNewChild);
                            }
                            else {
                                delete(pboNewChild);
                            }
                        }
                    }
                    i++;
                    pboOldChild = pboSource->EnumChildObject(i);
                }
            }
        }
    }
    FreeMainDataBuffer(ppvMainDataBuf);
    return (hresReturn);
}

void CheckForNewMetabaseVersion()
{
    BOOL    bValueWasWrongType = FALSE;
    BOOL    bSomethingChanged = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        // Check for update to major version

        // get the Type of data only first
        // since a string won't fit in &dwValue
        dwValue = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_SETMAJORVERSION_VALUE,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                MD_SETMAJORVERSION_VALUE,
                                NULL,
                                &dwType,
                                (BYTE *)&dwValue,
                                &dwSize);
                if ( dwRegReturn == ERROR_SUCCESS)
                {
                    // default the value with the version that this binary was compiled with
                    if (dwType == REG_DWORD)
                    {
                        if (g_dwMajorVersionNumber != dwValue && dwValue >= 1)
                        {
                            g_dwMajorVersionNumber = dwValue;
                            bSomethingChanged = TRUE;
                        }
                    }
                    else
                    {
                        bValueWasWrongType = TRUE;
                    }
                }
            }
            else
            {
                bValueWasWrongType = TRUE;
            }
        }

        if (FALSE == bValueWasWrongType)
        {
            // Check for update to minor version

            // get the Type of data only first
            // since a string won't fit in &dwValue
            dwValue = 0;
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            MD_SETMINORVERSION_VALUE,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
            if ( dwRegReturn == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                {
                    dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                    MD_SETMINORVERSION_VALUE,
                                    NULL,
                                    &dwType,
                                    (BYTE *)&dwValue,
                                    &dwSize);
                    if ( dwRegReturn == ERROR_SUCCESS)
                    {
                        if (dwType == REG_DWORD)
                        {
                            if (g_dwMinorVersionNumber != dwValue)
                            {
                                g_dwMinorVersionNumber = dwValue;
                                bSomethingChanged = TRUE;
                            }
                        }
                        else
                        {
                            bValueWasWrongType = TRUE;
                        }
                    }
                }
                else
                {
                    bValueWasWrongType = TRUE;
                }
            }
        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (TRUE == bValueWasWrongType)
    {
        // default the value with the version that this binary was compiled with

        if (g_dwMajorVersionNumber != MD_MAJOR_VERSION_NUMBER)
        {
            g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }

        if (g_dwMinorVersionNumber != MD_MINOR_VERSION_NUMBER)
        {
            g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }
    }


    if (TRUE == bSomethingChanged)
    {
        // make sure that we tell the metabase that there was a change made..
        g_dwSystemChangeNumber++;
        IIS_PRINTF((buff,"MD:New Metabase Version:%d.%d\n",g_dwMajorVersionNumber,g_dwMinorVersionNumber));
    }
    return;
}

BOOL
CheckVersionNumber()
{
    BOOL bReturn = FALSE;

    if (g_dwMajorVersionNumber >= 1) {
        // 1 = IIS4
        //     we need to be able to open IIS4 in IIS5 during setup upgrade
        // 2 = IIS5
        bReturn = TRUE;
    }

    // g_dwMinorVersionNumber -- maybe use this for Major service pack releases or something in which
    //                           Metabase has been changed and we need to know the difference?

    return bReturn;
}

HRESULT
InitStorageAndSessionKey(
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider( &hProv );

    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = pCryptoStorage->Initialize(
                         TRUE,                          // fUseMachineKeyset
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = pCryptoStorage->GetSessionKeyBlob( ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey


HRESULT
InitStorageAndSessionKey2(
    IN LPSTR pszPasswd,
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider2( &hProv );
    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->Initialize(
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider2 Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->GetSessionKeyBlob( pszPasswd, ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey2


VOID
SkipPathDelimeter(IN OUT LPSTR &rpszPath,
                    IN BOOL bUnicode)
{
    if (bUnicode) {
        LPWSTR pszPath = (LPWSTR)rpszPath;
        SKIP_PATH_DELIMETERW(pszPath);
        rpszPath = (LPSTR)pszPath;
    }
    else {
        SKIP_PATH_DELIMETERA(rpszPath);
    }
}

BOOL
IsStringTerminator(IN LPTSTR pszString,
                   IN BOOL bUnicode)
{
    if (bUnicode) {
        if (*(LPWSTR)pszString == (WCHAR)L'\0') {
            return TRUE;
        }
    }
    else {
        if (*(LPSTR)pszString == (CHAR)'\0') {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
GetLastHResult() {
    DWORD tmp = GetLastError();
    return RETURNCODETOHRESULT(tmp);
}


HRESULT STDMETHODCALLTYPE  BackupCertificates (LPCWSTR  backupName,PCHAR lpszToPath,PCHAR lpszFromPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    CHAR                *p1,*p2;
    LPSTR               searchMask = "*.mp";
    LPSTR               backupNameSeparator = ".";
    CHAR                strSourcePath[MAX_PATH];
    CHAR                strSearchPattern[MAX_PATH];
    CHAR                strDestPath[MAX_PATH];
    DWORD               dwLenOfBackupName, n1;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FileInfo;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSrcFileName, strDestFileName;

    dwLenOfBackupName = wcslen (backupName) * sizeof (WCHAR);
    p1 = strrchr (lpszFromPath,'\\');
    p2 = strrchr (lpszToPath,'\\');
    if (p1 &&p2)
    {
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        strcpy (strSearchPattern,strSourcePath);

        n1 = min (MAX_PATH-1, DIFF(p2 - lpszToPath)+1);
        strncpy (strDestPath,lpszToPath,n1);
        strDestPath[n1] = 0;

        if (strlen (strSourcePath) +  strlen(searchMask) < MAX_PATH)
        {
            strcat (strSearchPattern,searchMask);
            hFindFile = FindFirstFile( strSearchPattern, &FileInfo);

            if (hFindFile == INVALID_HANDLE_VALUE)
            {
                // no certificate file found
                return ERROR_SUCCESS;
            }

            while (fFoundFile)
            {
                if ( strlen (FileInfo.cFileName) + strlen (strDestPath) + dwLenOfBackupName + 1 < MAX_PATH)
                {

                    fValid = strSrcFileName.Copy (strSourcePath);
                    fValid = fValid && strSrcFileName.Append (FileInfo.cFileName);

                    fValid = fValid && strDestFileName.Copy (strDestPath);
                    fValid = fValid && strDestFileName.Append ((LPWSTR)backupName);
                    fValid = fValid && strDestFileName.Append (backupNameSeparator);
                    fValid = fValid && strDestFileName.Append (FileInfo.cFileName);

                    if (fValid)
                    {
                        if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                        {
                            IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                        }
                    }
                    else
                    {
                        IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
                    }

                }

                fFoundFile = FindNextFile(hFindFile,&FileInfo);
            }
            fFoundFile = FindClose (hFindFile);
            MD_ASSERT (fFoundFile);
        }
        else
        {
            IIS_PRINTF((buff,"CertificateBackup: strSourcePath filename was too long\n"));
        }
    }
    else
    {
        IIS_PRINTF((buff,"CertificateBackup: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE  RestoreCertificates (LPCWSTR  backupName,PCHAR lpszFromPath,PCHAR lpszToPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               n1;
    CHAR                strDestinationPath[MAX_PATH];
    CHAR                strSourcePath[MAX_PATH];
    CHAR                *p1,*p2;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSearchPatttern, strDestFileName, strSrcFileName;
    WIN32_FIND_DATAW    FileInfo;
    LPWSTR              pszSearchPattern = NULL;


    p1 = strrchr (lpszToPath,'\\');
    p2 = strrchr (lpszFromPath,'\\');


    if (p1 &&p2)
    {

        n1 = min (MAX_PATH-1, DIFF(p1 - lpszToPath)+1);
        strncpy (strDestinationPath,lpszToPath,n1);
        strDestinationPath[n1] = 0;

        n1 = min (MAX_PATH-1, DIFF(p2 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;


        strSearchPatttern.Copy (strSourcePath);
        strSearchPatttern.Append ((LPWSTR)backupName);
        strSearchPatttern.Append ((LPWSTR)L".*.mp");

        if( !( pszSearchPattern = strSearchPatttern.QueryStrW() ) )
        {
            return ERROR_SUCCESS;
        }

        hFindFile = FindFirstFileW( pszSearchPattern, &FileInfo);

        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // no certificate file found
            return ERROR_SUCCESS;
        }

        while (fFoundFile)
        {
            fValid = strDestFileName.Copy (strDestinationPath);
            fValid = fValid && strDestFileName.Append ((LPWSTR)(FileInfo.cFileName + wcslen (backupName) +1));

            fValid = fValid && strSrcFileName.Copy (strSourcePath);
            fValid = fValid && strSrcFileName.Append ((LPWSTR)FileInfo.cFileName);

            if (fValid)
            {
                if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                {
                    IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                }
            }
            else
            {
                IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
            }

            fFoundFile = FindNextFileW(hFindFile,&FileInfo);
        }
        fFoundFile = FindClose (hFindFile);
        MD_ASSERT (fFoundFile);
    }
    else
    {
        IIS_PRINTF((buff,"CertificateRestore: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }

    return hresReturn;
    
}



HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
               IN LPWSTR              wszPath,
               IN FILETIME*           pFileTime,
               IN BOOL                bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    // TODO: Write descriptions.

    Read       - Place to return the created object.

    ObjectLine - The object info.


Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT        hresReturn;
    CMDBaseObject* pboParent;
    WCHAR          strName[METADATA_MAX_NAME_LEN];
    FILETIME       ftTime;
    PFILETIME      pftParentTime;
    FILETIME       ftParentTime;
    LPTSTR         strObjectName;

    //
    // This should never be called for the root object.
    // TODO: Need an ASSERT here.
    //

    if(0 == wcscmp(wszPath, L"/"))
        return S_OK;    

    //
    // TODO: What to do about file time?    
    //

    ftTime = *(UNALIGNED FILETIME *)(pFileTime);

    strObjectName = (LPTSTR)wszPath;    // 
                                        // It is OK to cast because we are always passing unicode
                                        // and bUnicode is always set to TRUE when this function 
                                        // is called.
                                        //

    hresReturn = GetObjectFromPath(pboParent,
                                   METADATA_MASTER_ROOT_HANDLE,
                                   METADATA_PERMISSION_READ,
                                   strObjectName,
                                   bUnicode);

    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strObjectLine set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //

    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        MD_ASSERT(pboParent != NULL);
        if (bUnicode) {
            hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
        }
        else {
            hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
        }
        if (SUCCEEDED(hresReturn)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
            }
            else {
                //
                // InsertChildObject sets the last change time to current time.
                // This isn't really a change, so save and restore time.
                //
                pftParentTime = pboParent->GetLastChangeTime();
                ftParentTime = *pftParentTime;
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (SUCCEEDED(hresReturn)) {
                    pboParent->SetLastChangeTime(&ftParentTime);
                    pboNew->SetLastChangeTime(&ftTime);
                    cboRead = pboNew;
                }
                else {
                    delete (pboNew);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }

    return (hresReturn);
}


HRESULT
ReadDataObject(
         IN CMDBaseObject*      cboAssociated,
         LPVOID*                a_pv,
         ULONG*                 a_Size,
         IN IIS_CRYPTO_STORAGE* pCryptoStorage,
         IN BOOL                bUnicode)

/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    // TODO: Define these

    Associated - The associated meta object.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataValue;
    STACK_BUFFER( bufAlignedValue, 256 );
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    //
    // TODO: Assert that these pointers are always valid.
    //
    mdrData.dwMDIdentifier = *(DWORD *)(a_pv[iMBProperty_ID]);
    mdrData.dwMDAttributes = *(DWORD *)(a_pv[iMBProperty_Attributes]);
    mdrData.dwMDUserType   = *(DWORD *)(a_pv[iMBProperty_UserType]);
    //
    // TODO: Assert that data type is the MB data type.
    //
    mdrData.dwMDDataType = *(DWORD *)(a_pv[iMBProperty_Type]);

    pbDataValue = (PBYTE)a_pv[iMBProperty_Value];
    dwDataLength = a_Size[iMBProperty_Value];

    if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
        pCryptoStorage != NULL) {

        //
        // This is a secure data object, we we'll need to decrypt it
        // before proceeding. Note that we must clone the blob before
        // we can actually use it, as the blob data in the line buffer
        // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
        // the only IISCrypto function that can handle unaligned data.)
        //

        hresReturn = ::IISCryptoCloneBlobFromRawData(
                         &blob,
                         pbDataValue,
                         dwDataLength
                         );

        if (SUCCEEDED(hresReturn)) {
            DWORD dummyRegType;

            MD_ASSERT(::IISCryptoIsValidBlob(blob));
            hresReturn = pCryptoStorage->DecryptData(
                                   (PVOID *)&pbDataValue,
                                   &dwDataLength,
                                   &dummyRegType,
                                   blob
                                   );
            }

        } else {

            //
            // The metadata was not secure, so decryption was not required.
            // Nonetheless, it must be copied to an aligned buffer... 
            //

            if( !bufAlignedValue.Resize( dwDataLength ) )
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                memcpy( bufAlignedValue.QueryPtr(), pbDataValue, dwDataLength );
                pbDataValue = ( PBYTE )bufAlignedValue.QueryPtr();
            }
     }

    if (SUCCEEDED(hresReturn)) {
        mdrData.pbMDData = pbDataValue;

        switch (mdrData.dwMDDataType) {
            case DWORD_METADATA: {
                if (dwDataLength != sizeof(DWORD)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    //
                    // TODO: Add an assert condition.
                    //
                }
                break;
            }
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
            {
                if ((LONG)dwDataLength < 1 ||
                    (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                    (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)L'\0')) {

                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);

                    DBGINFOW((DBG_CONTEXT,
                              L"Error: Invalid string. Length %d. Property id: %d. location: %s. hr = 0x%x.\n",
                               dwDataLength,
                               mdrData.dwMDIdentifier,
                               (LPWSTR)a_pv[iMBProperty_Location],
                               hresReturn));

                }
                break;
            }
            case BINARY_METADATA:
            {
                mdrData.dwMDDataLen = dwDataLength;
                break;
            }
            case MULTISZ_METADATA:
            {
                if (bUnicode) {
                    if (dwDataLength < (2 * sizeof(WCHAR)) ||
                        *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)L'\0' ||
                        *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)L'\0') {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);

                        DBGINFOW((DBG_CONTEXT,
                                  L"[ReadDataObject] Error: Invalid multisz. Length %d. Property id: %d. location: %s. hr = 0x%x.\n",
                                  dwDataLength,
                                  mdrData.dwMDIdentifier,
                                  (LPWSTR)a_pv[iMBProperty_Location],
                                  hresReturn));

                    }
                }
                else {
                    if (dwDataLength < 2 ||
                        pbDataValue[dwDataLength-1] != '\0' ||
                        pbDataValue[dwDataLength-2] != '\0') {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    mdrData.dwMDDataLen = dwDataLength;
                }
                break;
            }
            default: {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                //
                // TODO: Add an assert condition.
                //

            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}


/*
HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN LPSTR pszBackupLocation,
         IN LPSTR pszSchemaLocation,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore
         )
*//*++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
/*
{
    HRESULT         hresReturn                             = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER objChildObjectContainer = NULL;
    BUFFER*         pbufParentPath                         = new BUFFER(0);
    HANDLE          hTempFileHandle                        = INVALID_HANDLE_VALUE;
    CMDBaseObject*  objChildObject                         = NULL;
    DWORD           dwEnumObjectIndex                      = 0;
    BOOL            bDeleteTemp                            = TRUE;
    DWORD           dwTemp                                 = ERROR_SUCCESS;
    DWORD           dwTempLastSaveChangeNumber             = 0;
    BOOL            bSaveNeeded                            = FALSE;
    ULONG           ulHistoryMajorVersionNumber            = 0;
    DWORD           dwEnableHistory                        = 0;
    DWORD           dwMaxHistoryFiles                      = 0;
    LPTSTR          strRealFileName;    
    LPTSTR          strSchemaFileName;    
    LPTSTR          strTempFileName                        = g_strTempFileName->QueryStr();
    LPTSTR          strBackupFileName                      = g_strBackupFileName->QueryStr();
    CWriter*        pCWriter                               = NULL; ;
    LPWSTR          wszSchemaFileName                      = NULL;
    HANDLE          hMetabaseFile                          = INVALID_HANDLE_VALUE;
    FILETIME        MostRecentMetabaseFileLastWriteTimeStamp;
    ULONG           ulMostRecentMetabaseVersion            = 0;
    BOOL            bRenameMetabase                        = TRUE;

    if( !pszBackupLocation )
    {
        strRealFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        strRealFileName = pszBackupLocation;
    }

    if( !pszSchemaLocation )
    {
        strSchemaFileName = g_strSchemaFileName->QueryStr();
    }
    else
    {
        strSchemaFileName = pszSchemaLocation;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    if (!g_bSaveDisallowed) {
        g_bSaveDisallowed = bSetSaveDisallowed;

        //
        // Write to a temp file first in case there are errors.
        //

        SECURITY_ATTRIBUTES saStorage;
        PSECURITY_ATTRIBUTES psaStorage = NULL;

        if (g_psdStorage != NULL) {
            saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
            saStorage.lpSecurityDescriptor = g_psdStorage;
            saStorage.bInheritHandle = FALSE;
            psaStorage = &saStorage;
        }

        hTempFileHandle = CreateFile(strTempFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     psaStorage,
                                     OPEN_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                     0);
        if (hTempFileHandle == INVALID_HANDLE_VALUE) {
            DWORD dwTemp = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwTemp);
        }
        else {
            g_rMasterResource->Lock(TSRES_LOCK_READ);

            //
            // Lock the metabase file if edit while running is enabled.
            //

            if(g_dwEnableEditWhileRunning)
            {
                hMetabaseFile = CreateFile(strRealFileName,    // file name
                                           GENERIC_READ,       // access mode
                                           0,                  // share mode
                                           NULL,               // SD
                                           OPEN_EXISTING,      // how to create
                                           0,                  // file attributes
                                           NULL                // handle to template file
                                            );
            }

            //
            // Only Save if changes have been made since the last save.
            //

            if ( pszBackupLocation || g_dwLastSaveChangeNumber != g_dwSystemChangeNumber ) 
            {
                bSaveNeeded = TRUE;

                if (hHandle != METADATA_MASTER_ROOT_HANDLE) {
                    CMDHandle *phoHandle;
                    phoHandle = GetHandleObject(hHandle);
                    if ((phoHandle == NULL) || (phoHandle->GetObject() != g_pboMasterRoot)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                    }
                    else if ((!phoHandle->IsReadAllowed()) && (!phoHandle->IsWriteAllowed())) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
                    ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)L'\0';

                    // TODO: Need to add the following:

                    // MD_SIGNATURE_STRINGW
                    
                    // *pbLineBuf = MD_ID_MAJOR_VERSION_NUMBER;
                    // *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMajorVersionNumber;

                    // *pbLineBuf =  MD_ID_CHANGE_NUMBER;
                    // *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwSystemChangeNumber;

                    // *pbLineBuf =  MD_ID_SESSION_KEY;
                    // memcpy((PCHAR)pbLineBuf+1, (PCHAR)pSessionKeyBlob, IISCryptoGetBlobLength(pSessionKeyBlob));

                    hresReturn = GetUnicodeName(strSchemaFileName, &wszSchemaFileName);

                    if(SUCCEEDED(hresReturn))
                    {
                        if( pszSchemaLocation )
                        {
                            //
                            // Bump up g_dwSchemaChangeNumber to force save MBSchema.XML
                            // This (pszSchemaLocation being non-null) is in 
                            // the case of Restore.
                            //
                            g_dwSchemaChangeNumber++;

                        }

                        hresReturn = SaveSchemaIfNeeded(wszSchemaFileName,
                                                        psaStorage);
                    }

                    if(SUCCEEDED(hresReturn))
                    {
                        //
                        // TODO: Assert g_pGlobalISTHelper is valid.
                        //

                        DBGINFOW((DBG_CONTEXT,
                                  L"[SaveAllData] Initializing writer with write file: %s bin file: %s.\n", 
                                  g_wszTempFileName,
                                  g_pGlobalISTHelper->m_wszBinFileForMeta));

                        pCWriter = new CWriter();
                        if(NULL == pCWriter)
                            hresReturn = E_OUTOFMEMORY;
                        else
                            hresReturn = pCWriter->Initialize(g_wszTempFileName,
                                                              g_pGlobalISTHelper,
                                                              hTempFileHandle);
                    }

                    if(SUCCEEDED(hresReturn))
                    {
                        hresReturn = pCWriter->BeginWrite(eWriter_Metabase);
                    }

                    if(SUCCEEDED(hresReturn))
                    {
                        hresReturn = SaveGlobalsToXML(pCWriter,
                                                      pSessionKeyBlob);
                    }

                    if(SUCCEEDED(hresReturn))
                    {
                        hresReturn = SaveMasterRoot(pCWriter,
                                                    pCryptoStorage,
                                                    pSessionKeyBlob
                                                   );
                    }

                    for(objChildObjectContainer=g_pboMasterRoot->NextChildObject(NULL);
                        (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
                        objChildObjectContainer=g_pboMasterRoot->NextChildObject(objChildObjectContainer)) {
                       
                        if(0 == _wcsnicmp((LPWSTR)objChildObjectContainer->pboMetaObject->GetName(TRUE), g_wszSchema, g_cchSchema))
                        {
                            //
                            // No need to save the schema tree in data file.
                            //

#ifndef _SAVE_SCHEMA_TREE_IN_DATA_FILE_ 
                            continue;
#endif  _SAVE_SCHEMA_TREE_IN_DATA_FILE_ 

                        }

                        hresReturn = SaveTree(pCWriter,
                                              objChildObjectContainer->pboMetaObject,
                                              pbufParentPath,
                                              pCryptoStorage,
                                              pSessionKeyBlob
                                              );

                    }

                    if(SUCCEEDED(hresReturn))
                    {
                        hresReturn = pCWriter->EndWrite(eWriter_Metabase);
                    }

                    if(NULL != pCWriter)
                    {
                        delete pCWriter;
                        pCWriter = NULL;
                    }

                    ulHistoryMajorVersionNumber = g_ulHistoryMajorVersionNumber;
                    dwEnableHistory = g_dwEnableHistory;
                    dwMaxHistoryFiles = g_dwMaxHistoryFiles;
                }

                //
                // Must have MasterResource when accessing SystemChangeNumber
                // so save it away here. Only update LastSaveChangeNumber on success.
                //

                dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

            }

            StartStopEditWhileRunning(iSTATE_STOP_TEMPORARY);

//          DetermineIfMetabaseCanBeRenamed(strRealFileName,
//                                          hMetabaseFile,
//                                          &bRenameMetabase);
//
            //
            // Release lock before writing to file.
            //

            g_rMasterResource->Unlock();

            if(INVALID_HANDLE_VALUE != hMetabaseFile)
            {
                //
                // Unlock the metabase file, if it has been previously locked.
                //

                CloseHandle(hMetabaseFile);
                hMetabaseFile = INVALID_HANDLE_VALUE;
            }

            //
            // Always close the file handle
            //

            if (!CloseHandle(hTempFileHandle)) {
                hresReturn = GetLastError();
            }

        }
        if (SUCCEEDED(hresReturn) && bSaveNeeded) {

            //
            // Save the temp file in the history directory.
            // If we are unable to create a history, then we
            // will not be able to diff if someone makes changes.
            // Hence we will have to error at the time of diffing.
            //

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveAllData] HistoryMajorVersionNumber: 0x%d.\n", g_ulHistoryMajorVersionNumber));

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveAllData] HistoryMajorVersionNumber: 0x%d.\n", ulHistoryMajorVersionNumber));
            
            if(dwEnableHistory)
            {
                CreateHistoryFiles(g_wszTempFileName, 
                                   wszSchemaFileName,
                                   ulHistoryMajorVersionNumber,
                                   dwMaxHistoryFiles);
            }

            //
            // New data file created successfully
            // Backup real file and copy temp
            // to real
            //
            if(g_dwEnableEditWhileRunning && (!bRenameMetabase))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[SaveAllData] Edit while running is enabled and a user has edited the file and the edit hasn't been processed. Meanwhile SaveAllData has been called. Hence SaveAllData is not renaming the file, so that the user edits are not overwrittem.\n"));

            }
            else
            {
                if(g_dwEnableEditWhileRunning)
                {
                    //
                    // Update the  g_MostRecentMetabaseFileCreateTimeStamp and
                    // g_MostRecentMetabaseFileLastWriteTimeStamp to the current
                    // time stamp, just before the move.
                    //

                    WIN32_FILE_ATTRIBUTE_DATA CurrentMetabaseTempFileAttr;
                    BOOL                      bFetchedCurrentMetabaseAttr = TRUE;

                    if(!GetFileAttributesEx(strTempFileName, 
                                            GetFileExInfoStandard,
                                            &CurrentMetabaseTempFileAttr)
                      )
                    {
                        //
                        // Could not fetch the current file attributes for the temporary metabase file.
                        //

                        DWORD dwRes = GetLastError();
                        HRESULT hr = RETURNCODETOHRESULT(dwRes);

                        DBGINFO((DBG_CONTEXT,
                                 "[SaveAllData] Could not fetch the current file attributes for the temporary metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n", 
                                 strTempFileName,
                                 hr));
                        bFetchedCurrentMetabaseAttr = FALSE;
                    }

                    EnterCriticalSection(&g_csEditWhileRunning);
                    MostRecentMetabaseFileLastWriteTimeStamp   = g_MostRecentMetabaseFileLastWriteTimeStamp;
                    ulMostRecentMetabaseVersion                = g_ulMostRecentMetabaseVersion;
                    g_ulMostRecentMetabaseVersion              = ulHistoryMajorVersionNumber;
                    g_bSavingMetabaseFileToDisk              = TRUE;
                    if(bFetchedCurrentMetabaseAttr)
                    {
                        g_MostRecentMetabaseFileLastWriteTimeStamp = CurrentMetabaseTempFileAttr.ftLastWriteTime;
                    }
                    DBGINFO((DBG_CONTEXT,
                             "[SaveAllData] SAVEALLDATA TIMESTAMPS:\nMetabaseFileLastWrite low: %d\nMetabaseFileLastWrite high: %d\n", 
                             g_MostRecentMetabaseFileLastWriteTimeStamp.dwLowDateTime,
                             g_MostRecentMetabaseFileLastWriteTimeStamp.dwHighDateTime));
                    LeaveCriticalSection(&g_csEditWhileRunning);
                }

                if (!MoveFile(strTempFileName, strRealFileName)) 
                {
                    if (GetLastError() != ERROR_ALREADY_EXISTS) {
                        dwTemp = GetLastError();
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    else
                    {
                        DWORD dwRealFileAttributes = 0;

                        //
                        // Real File exists, so back it up
                        //

                        DBGINFO((DBG_CONTEXT,
                                 "[SaveAllData] Real file exists.\n"));
                        //
                        // Bug #260590  If someone had attrib-ed the real file to
                        // be read-only then we could land up in a state where the
                        // backup file is read-only. Hence attrib the real file to
                        // be read-write and then move it to the backup file.
                        //

                        if(-1 == (dwRealFileAttributes = GetFileAttributes(strRealFileName))) {
                            dwTemp = GetLastError();
                        }
                        else if(FILE_ATTRIBUTE_READONLY == (dwRealFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                            if(!SetFileAttributes(strRealFileName,
                                                  FILE_ATTRIBUTE_NORMAL)) {
                                dwTemp = GetLastError();
                            }
                        }
                        if (!MoveFile(strRealFileName, strBackupFileName)) {
                            //
                            // backup failed, check for old backup file
                            //
                            if (GetLastError() != ERROR_ALREADY_EXISTS) {
                                dwTemp = GetLastError();
                            }
                            else if (!DeleteFile(strBackupFileName)) {
                                dwTemp = GetLastError();
                            }
                            else if (!MoveFile(strRealFileName, strBackupFileName)) {
                                dwTemp = GetLastError();
                            }
                        }
                        else
                        {
                            DBGINFO((DBG_CONTEXT,
                                     "[SaveAllData] Backed-up real file.\n"));
                        }

                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    if (SUCCEEDED(hresReturn)) {
                        BOOL bDeleteBackup = TRUE;
                        //
                        // Real file is backed up
                        // so move in new file
                        //
                        if (!MoveFile(strTempFileName, strRealFileName)) {
                            dwTemp = GetLastError();
                            hresReturn = RETURNCODETOHRESULT(dwTemp);
                            //
                            // Moved real to backup but
                            // failed to move temp to real
                            // so restore from backup
                            //
                            if (!MoveFile(strBackupFileName, strRealFileName)) {
                                //
                                // Unable to write new file
                                // or restore original file so don't delete backup
                                //
                                bDeleteBackup = FALSE;
                            }
                        }
                        else
                        {
                            DBGINFO((DBG_CONTEXT,
                                     "[SaveAllData] Moved temp file to real file.\n"));
                        }
                        if (bDeleteBackup) {
                            DeleteFile(strBackupFileName);
                        }
                    }
                    if (FAILED(hresReturn)) {
                    
                        //
                        // temp file was created ok but a problem
                        // occurred while moving it to real
                        // so don't delete it
                        //

                        LogEvent(g_pEventLog,
                                 MD_ERROR_UNABLE_TOSAVE_METABASE,
                                 EVENTLOG_ERROR_TYPE,
                                 ID_CAT_CAT,
                                 hresReturn);

                        bDeleteTemp = FALSE;

                        if(g_dwEnableEditWhileRunning)
                        {
                            //
                            // The previous time stamp would have been updated to 
                            // the current tempfile timestamp just before the move 
                            // is attempted. If the move of the temp file to the
                            // real file fails, then we must reset this time stamp.
                            //

                            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                            g_MostRecentMetabaseFileLastWriteTimeStamp   = MostRecentMetabaseFileLastWriteTimeStamp;
                            g_ulMostRecentMetabaseVersion                = ulMostRecentMetabaseVersion;
                            g_rMasterResource->Unlock();
                        }
                    }
                    else {

                        //
                        // Update Change Number
                        // Must have ReadSaveSemaphore when accessing this.
                        //

                        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
                    }
                }
            }
        }
        if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) {
            DeleteFile(strTempFileName);
        }
  
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( pbufParentPath != NULL ) {
        pbufParentPath->FreeMemory();
        delete(pbufParentPath);
    }

    if ( FAILED( hresReturn )) {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    } else {
        //DBGPRINTF(( DBG_CONTEXT, "Successfully flushed metabase to disk\n" ));
    }

    if(NULL != pCWriter)
    {
        delete pCWriter;
        pCWriter = NULL;
    }

    if(NULL != wszSchemaFileName)
    {
        delete [] wszSchemaFileName;
        wszSchemaFileName = NULL;
    }

    return hresReturn;
}
*/

HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN LPWSTR pwszBackupLocation,
         IN LPWSTR pwszSchemaLocation,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore,
         IN BOOL bTerminating
         )
/*
++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT               hresReturn                             = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER objChildObjectContainer = NULL;
    HANDLE                hTempFileHandle                        = INVALID_HANDLE_VALUE;
    DWORD                 dwEnumObjectIndex                      = 0;
    BOOL                  bDeleteTemp                            = TRUE;
    DWORD                 dwTemp                                 = ERROR_SUCCESS;
    DWORD                 dwTempLastSaveChangeNumber             = 0;
    BOOL                  bSaveNeeded                            = FALSE;
    DWORD                 ulHistoryMajorVersionNumber            = 0;
    DWORD                 dwEnableHistory                        = 0;
    DWORD                 dwMaxHistoryFiles                      = 0;
    LPWSTR                pwszRealFileName                       = NULL;    
    LPWSTR                pwszSchemaFileName                     = NULL;    
    LPWSTR                pwszTempFileName                       = g_wszTempFileName;
    LPWSTR                pwszBackupFileName                     = g_wszBackupFileName;
    SECURITY_ATTRIBUTES   saStorage;
    BOOL                  bRenameMetabase                        = TRUE;
    HANDLE                hMetabaseFile                          = INVALID_HANDLE_VALUE;
    FILETIME              MostRecentMetabaseFileLastWriteTimeStamp;
    ULONG                 ulMostRecentMetabaseVersion            = 0;

    //
    // Figure out the schema and data file names. Note that pwszBackupLocation
    // and pwszSchemaLocation are passed in during backup restore only.
    //

    if( !pwszBackupLocation )
    {
        pwszRealFileName = g_wszRealFileName;
    }
    else
    {
        pwszRealFileName = pwszBackupLocation;
    }

    if( !pwszSchemaLocation )
    {
        pwszSchemaFileName = g_wszSchemaFileName;
    }
    else
    {
        pwszSchemaFileName = pwszSchemaLocation;
    }

    //
    // If ReadSaveSemaphore hasnt been already taken, then take it.
    //

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    if(g_bSaveDisallowed)
    {
        goto exit;
    }

    g_bSaveDisallowed = bSetSaveDisallowed;

    //
    // Write to a temp file first in case there are errors.
    // Create the temp file
    //

    if (g_psdStorage != NULL) 
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = g_psdStorage;
        saStorage.bInheritHandle = FALSE;
    }

    hTempFileHandle = CreateFileW(pwszTempFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,
                                  &saStorage,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                  0);
    
    if (hTempFileHandle == INVALID_HANDLE_VALUE) 
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn);
        goto exit;
    }

    //
    // Lock the in-memory metabase to prevent writes.
    // Lock the metabase file to prevent writes.
    //

    LockMetabase(pwszRealFileName,
                 &hMetabaseFile);

    if ((pwszBackupLocation) || 
        (g_dwLastSaveChangeNumber != g_dwSystemChangeNumber)) 
    {
        //
        // Only Save if changes have been made since the last save.
        //

        bSaveNeeded = TRUE;

        hresReturn = SaveEntireTree(pCryptoStorage,
                                    pSessionKeyBlob,
                                    hHandle,
                                    pwszSchemaLocation,
                                    pwszSchemaFileName,
                                    &saStorage,
                                    hTempFileHandle);                

        //
        // Must have MasterResource when accessing SystemChangeNumber
        // so save it away here. Only update LastSaveChangeNumber on success.
        //

        dwTempLastSaveChangeNumber  = g_dwSystemChangeNumber;
        ulHistoryMajorVersionNumber = g_ulHistoryMajorVersionNumber;
        dwEnableHistory             = g_dwEnableHistory;
        ValidateMaxHistoryFiles();
        dwMaxHistoryFiles           = g_dwMaxHistoryFiles;

//      DetermineIfMetabaseCanBeRenamed(strRealFileName,
//                                      hMetabaseFile,
//                                      &bRenameMetabase);

    }

    if(NULL != g_pListenerController)
    {
        if(g_dwEnableEditWhileRunning)
        {
            hresReturn = g_pListenerController->Start();
        }
        else 
        {
            hresReturn = g_pListenerController->Stop(iSTATE_STOP_TEMPORARY,
                                                     NULL);
        }
    }

    //
    // Unlock the in-memory metabase once it has been saved to the temp file.
    // Unlock the metabase file once the temp file has been created.
    //

    UnlockMetabase(&hMetabaseFile);

    if (!CloseHandle(hTempFileHandle)) 
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn); 
    }

    if(FAILED(hresReturn) || (!bSaveNeeded))
    {
        goto exit;
    }

    if(g_dwEnableEditWhileRunning && bRenameMetabase)
    {
        //
        // Update the  g_MostRecentMetabaseSaveTimeStamp value
        // to the current time stamp, just before the move and rename.
        // Note that if the rename is not happening, then we needn't 
        // update the values because a notification will not be sent.
        //

        WIN32_FILE_ATTRIBUTE_DATA  CurrentMetabaseTempFileAttr;
        BOOL                       bFetchedCurrentMetabaseAttr = TRUE;

        if(!GetFileAttributesExW(pwszTempFileName, 
                                 GetFileExInfoStandard,
                                 &CurrentMetabaseTempFileAttr)
          )
        {
            //
            // Could not fetch the current file attributes for the temporary metabase file.
            //

            DWORD dwRes = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwRes);

            DBGINFOW((DBG_CONTEXT,
                     L"[SaveAllData] CCould not fetch the current file attributes for the temporary metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n", 
                     pwszTempFileName,
                     hresReturn));
            bFetchedCurrentMetabaseAttr = FALSE;
        }

        EnterCriticalSection(&g_csEditWhileRunning);
        MostRecentMetabaseFileLastWriteTimeStamp   = g_MostRecentMetabaseFileLastWriteTimeStamp;
        ulMostRecentMetabaseVersion                = g_ulMostRecentMetabaseVersion;
        g_ulMostRecentMetabaseVersion              = ulHistoryMajorVersionNumber;
        g_bSavingMetabaseFileToDisk              = TRUE;
        if(bFetchedCurrentMetabaseAttr)
        {
            g_MostRecentMetabaseFileLastWriteTimeStamp = CurrentMetabaseTempFileAttr.ftLastWriteTime;
        }
        LeaveCriticalSection(&g_csEditWhileRunning);
    }

    hresReturn = SaveMetabaseFile(pwszSchemaFileName,
                                  ulHistoryMajorVersionNumber,
                                  dwEnableHistory,
                                  dwMaxHistoryFiles,
                                  dwTempLastSaveChangeNumber,
                                  bRenameMetabase,
                                  pwszTempFileName,
                                  pwszRealFileName,
                                  pwszBackupFileName,
                                  pwszBackupLocation,
                                  &bDeleteTemp);

    if (FAILED(hresReturn)) 
    {                  
        if(g_dwEnableEditWhileRunning && bRenameMetabase)
        {
            //
            // The previous time stamp would have been updated to 
            // the current tempfile timestamp just before the move 
            // is attempted. If the move of the temp file to the
            // real file fails, then we must reset this time stamp.
            //

            EnterCriticalSection(&g_csEditWhileRunning);
            g_MostRecentMetabaseFileLastWriteTimeStamp   = MostRecentMetabaseFileLastWriteTimeStamp;
            g_ulMostRecentMetabaseVersion                = ulMostRecentMetabaseVersion;
            LeaveCriticalSection(&g_csEditWhileRunning);
        }
        goto exit;
    }
    else 
    {

        //
        // Update Change Number
        // Must have ReadSaveSemaphore when accessing this.
        //

        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

exit:

    if(bTerminating)
    {
        //
        // Unlock the metabase if terminating - irrespective of failure.
        //

        HRESULT hresReturnSav = S_OK;

        hresReturnSav = UnlockMetabaseFile(eMetabaseDataFile,
                                           TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturnSav));

        if(SUCCEEDED(hresReturnSav))
        {

            hresReturnSav = UnlockMetabaseFile(eMetabaseSchemaFile,
                                               TRUE);

            DBGINFOW((DBG_CONTEXT,
                      L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                      pwszSchemaFileName,
                      hresReturnSav));
        }

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }

    }

    if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) 
    {
        DeleteFileW(pwszTempFileName);
        hTempFileHandle = INVALID_HANDLE_VALUE;
    }

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( FAILED( hresReturn )) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    }

    return hresReturn;

} // SaveAllData


HRESULT
SaveEntireTree(IN  IIS_CRYPTO_STORAGE*     pCryptoStorage,
               IN  PIIS_CRYPTO_BLOB        pSessionKeyBlob,
               IN  METADATA_HANDLE         hHandle,
               IN  LPWSTR                  pwszSchemaLocation,
               IN  LPWSTR                  pwszSchemaFileName,
               IN  PSECURITY_ATTRIBUTES    psaStorage,
               IN  HANDLE                  hTempFileHandle)
/*
++

Routine Description:

    Saves the metabase tree to disk.

Arguments:
    [in] Crypto object for encryption/decryption.
    [in] Session key blob.
    [in] Handle to in-memory metabase.
    [in] Schema location (used only for backup/restore)
    [in] Schema file name.
    [in] Security Attributes to set on the file.
    [in] File handle of the temp file.

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT               hresReturn              = S_OK;
    HRESULT               hresReturnSav           = S_OK;
    BUFFER*               pbufParentPath          = NULL;
    PBASEOBJECT_CONTAINER objChildObjectContainer = NULL;
    CWriter*              pCWriter                = NULL; 

    if (hHandle != METADATA_MASTER_ROOT_HANDLE) 
    {
        CMDHandle *phoHandle;
        phoHandle = GetHandleObject(hHandle);

        if ((phoHandle == NULL) || 
            (phoHandle->GetObject() != g_pboMasterRoot)) 
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else if ((!phoHandle->IsReadAllowed()) && 
                 (!phoHandle->IsWriteAllowed())) 
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
        }
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    pbufParentPath = new BUFFER(4);
    if( pbufParentPath == NULL )
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
    ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)L'\0';

    //
    // TODO: Need to add the following:
    //       MD_ID_MAJOR_VERSION_NUMBER
    //       MD_ID_MINOR_VERSION_NUMBER
    //

    if( pwszSchemaLocation )
    {
        //
        // Bump up g_dwSchemaChangeNumber to force save MBSchema.XML
        // This (pszSchemaLocation being non-null) is in 
        // the case of Restore.
        //
        g_dwSchemaChangeNumber++;

    }

    //
    // Unlock the schema file before compile
    //

    if(NULL == pwszSchemaLocation)
    {
        hresReturn = UnlockMetabaseFile(eMetabaseSchemaFile,
                                        TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Unlocking metabase file %s returned 0x%x.\n",
                  pwszSchemaFileName,
                  hresReturn));

        if(FAILED(hresReturn))
        {
            goto exit;
        }
    }

    hresReturn = SaveSchemaIfNeeded(pwszSchemaFileName,
                                    psaStorage);

    //
    // Lock the metabase file even if compile has failed or even if EWR is
    // enabled - we do not allow users to edit the schema file.
    //

    if(NULL == pwszSchemaLocation)
    {
        hresReturnSav = LockMetabaseFile(pwszSchemaFileName,
                                         eMetabaseSchemaFile,
                                         TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Locking metabase file %s returned 0x%x.\n",
                  pwszSchemaFileName,
                  hresReturnSav));

        if(FAILED(hresReturnSav) && SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // TODO: Assert g_pGlobalISTHelper is valid.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] Initializing writer with write file: %s bin file: %s.\n", 
              g_wszTempFileName,
              g_pGlobalISTHelper->m_wszBinFileForMeta));

    pCWriter = new CWriter();

    if(NULL == pCWriter)
    {
        hresReturn = E_OUTOFMEMORY;
        goto exit;
    }

    hresReturn = pCWriter->Initialize(g_wszTempFileName,
                                      g_pGlobalISTHelper,
                                      hTempFileHandle);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = pCWriter->BeginWrite(eWriter_Metabase);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = SaveGlobalsToXML(pCWriter,
                                  pSessionKeyBlob);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = SaveMasterRoot(pCWriter,
                                pCryptoStorage,
                                pSessionKeyBlob);

    if(FAILED(hresReturn))
    {
        goto exit;
    }


    for(objChildObjectContainer=g_pboMasterRoot->NextChildObject(NULL);
        (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
        objChildObjectContainer=g_pboMasterRoot->NextChildObject(objChildObjectContainer)) 
    {
                BOOL bLocalMachine = FALSE;
   
        if(0 == _wcsnicmp((LPWSTR)objChildObjectContainer->pboMetaObject->GetName(TRUE), g_wszSchema, g_cchSchema))
        {
            //
            // No need to save the schema tree in data file.
            //

            #ifndef _SAVE_SCHEMA_TREE_IN_DATA_FILE_ 
            continue;
            #endif  _SAVE_SCHEMA_TREE_IN_DATA_FILE_ 

        }
                else if(0 == _wcsnicmp((LPWSTR)objChildObjectContainer->pboMetaObject->GetName(TRUE), g_wszLM, g_cchLM))
                {
                        bLocalMachine = TRUE;
                }

        hresReturn = SaveTree(pCWriter,
                              objChildObjectContainer->pboMetaObject,
                              pbufParentPath,
                              pCryptoStorage,
                              pSessionKeyBlob,
                              TRUE,
                                                          TRUE,
                                                          bLocalMachine);

    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = pCWriter->EndWrite(eWriter_Metabase);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

exit:

    if(NULL != pCWriter)
    {
        delete pCWriter;
        pCWriter = NULL;
    }

    if ( pbufParentPath != NULL ) 
    {
        pbufParentPath->FreeMemory();
        delete(pbufParentPath);
    }

    return hresReturn;

} // SaveEntireTree


HRESULT
SaveMetabaseFile(IN  LPWSTR pwszSchemaFileName,
                 IN  ULONG  ulHistoryMajorVersionNumber,
                 IN  DWORD  dwEnableHistory,
                 IN  DWORD  dwMaxHistoryFiles,
                 IN  DWORD  dwTempLastSaveChangeNumber,
                 IN  BOOL   bRenameMetabase,
                 IN  LPWSTR pwszTempFileName,
                 IN  LPWSTR pwszRealFileName,
                 IN  LPWSTR pwszBackupFileName,
                 IN  LPWSTR pwszBackupLocation,
                 OUT BOOL*  pbDeleteTemp)
/*
++

Routine Description:

    Creates the history file and moves the temp file to the
    real xml file.

Arguments:
    [in] Schema file name.
    [in] History major version number.
    [in] Enable history.
    [in] Max history files.
    [in] Last save change number.
    [in] Bool to indicate rename temp file to xml file or not.
    [in] Temp file name.
    [in] Real file name.
    [in] Schema file name.
    [in] Backup file name.
    [in] Backup location.
    [out] Bool to indicate delete temp or not.

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = S_OK;
    DWORD   dwTemp     = 0;
    BOOL    bUnlocked  = FALSE;

    //
    // Save the temp file in the history directory.
    // If we are unable to create a history, then we
    // will not be able to diff if someone makes changes.
    // Hence we will have to error at the time of diffing.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] HistoryMajorVersionNumber: %d.\n", g_ulHistoryMajorVersionNumber));

    DBGINFOW((DBG_CONTEXT,
              L"[SaveAllData] HistoryMajorVersionNumber: %d.\n", ulHistoryMajorVersionNumber));
    
    if(dwEnableHistory)
    {
        CreateHistoryFiles(g_wszTempFileName, 
                           pwszSchemaFileName,
                           ulHistoryMajorVersionNumber,
                           dwMaxHistoryFiles);
    }

    //
    // New data file created successfully
    // Backup real file and copy temp
    // to real
    //
    if(g_dwEnableEditWhileRunning && (!bRenameMetabase))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveAllData] Edit while running is enabled and a user has edited the file and the edit hasn't been processed. Meanwhile SaveAllData has been called. Hence SaveAllData is not renaming the file, so that the user edits are not overwrittem.\n"));
        goto exit;

    }

    //
    // Unlock the metabase file just before the rename and if is not called from
    // backup.
    //

    if(NULL == pwszBackupLocation)
    {
        hresReturn = UnlockMetabaseFile(eMetabaseDataFile,
                                        TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveMetabaseFile] Unlocking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturn));

        if(FAILED(hresReturn))
        {
            goto exit;
        }

        bUnlocked = TRUE;
    }


    //
    // Rename the temp file to the real file
    //

    if (!MoveFileW(pwszTempFileName, pwszRealFileName)) 
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS) 
        {
            dwTemp = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwTemp);
            goto exit;
        }
        
        //
        // Real File exists, so back it up
        //

        //
        // Bug #260590  If someone had attrib-ed the real file to
        // be read-only then we could land up in a state where the
        // backup file is read-only. Hence attrib the real file to
        // be read-write and then move it to the backup file.
        //

        ResetMetabaseAttributesIfNeeded((LPTSTR)pwszRealFileName,
                                        TRUE);

        if (!MoveFileW(pwszRealFileName, pwszBackupFileName)) 
        {
            //
            // backup failed, check for old backup file
            //
            if (GetLastError() != ERROR_ALREADY_EXISTS) 
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
            else if (!DeleteFileW(pwszBackupFileName)) 
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
            else if (!MoveFileW(pwszRealFileName, pwszBackupFileName)) 
            {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
                goto exit;
            }
        }

        //
        // Real file is backed up
        // so move in new file
        //

        if (!MoveFileW(pwszTempFileName, pwszRealFileName)) 
        {
            dwTemp = GetLastError();
            hresReturn = RETURNCODETOHRESULT(dwTemp);
            //
            // Moved real to backup but
            // failed to move temp to real
            // so restore from backup
            //
            if (!MoveFileW(pwszBackupFileName, pwszRealFileName)) 
            {
                //
                // Unable to write new file
                // or restore original file so don't delete backup
                //
                goto exit;
            }
        }

        DeleteFileW(pwszBackupFileName);
    }

exit:

    //
    // Lock the metabase file if edit while running is disabled and if it is
    // not called from backup and if it was unlocked above.
    //

    if((NULL == pwszBackupLocation) && (!g_dwEnableEditWhileRunning) && (bUnlocked))
    {
        HRESULT hresReturnSav = S_OK;

        hresReturnSav = LockMetabaseFile(pwszRealFileName,
                                         eMetabaseDataFile,
                                         TRUE);

        DBGINFOW((DBG_CONTEXT,
                  L"[SaveMetabaseFile] Locking metabase file %s returned 0x%x.\n",
                  pwszRealFileName,
                  hresReturn));

        if(SUCCEEDED(hresReturn))
        {
            hresReturn = hresReturnSav;
        }

    }

    if (FAILED(hresReturn)) 
    {
        //
        // temp file was created ok but a problem
        // occurred while moving it to real
        // so don't delete it
        //

        LogEvent(g_pEventLog,
                 MD_ERROR_UNABLE_TOSAVE_METABASE,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 hresReturn);

        *pbDeleteTemp = FALSE;

    }
    else
    {

        //
        // Update Change Number
        // Must have ReadSaveSemaphore when accessing this.
        //

        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    return hresReturn;
}


void
LockMetabase(LPWSTR  pwszRealFileName,
             HANDLE* phMetabaseFile)
/*
++

Routine Description:

    Helper function to lock the metabase. Takes the global resource lock as 
    well as a read lock on the metabase file so that nobody edits the file
    while the save is in progress, that way we dont miss any user edits.

Arguments:
    [in] Metabase file name.
    [in] Handle to metabase file.

Return Value:

    HRESULT    

Notes:

--*/
{

    //
    // Lock the master resource
    //

    g_rMasterResource->Lock(TSRES_LOCK_READ);

/*  if(g_dwEnableEditWhileRunning)
    {
        //
        // Lock the metabase file.
        //

        *phMetabaseFile = CreateFileW(pwszRealFileName,    // file name
                                      GENERIC_READ,       // access mode
                                      0,                  // share mode
                                      NULL,               // SD
                                      OPEN_EXISTING,      // how to create
                                      0,                  // file attributes
                                      NULL                // handle to template file
                                      );

        if((INVALID_HANDLE_VALUE == *phMetabaseFile) || 
           (NULL                 == *phMetabaseFile)
          )
        {
            DWORD dwRes = GetLastError();

            HRESULT hr = RETURNCODETOHRESULT(dwRes);

            DBGINFO((DBG_CONTEXT,
                    "[LockMetabase] Coud not lock the metabase file. CreateFile on %s failed with hr = 0x%x.\n", 
                    szRealFileName,
                    hr));

        }
    }
*/
    return;
}


void
UnlockMetabase(HANDLE*  phMetabaseFile)
/*
++

Routine Description:

    Helper function to unlock the metabase. Releases the global 
    resource lock as well as a read lock on the metabase file.

Arguments:
    [in] Handle to the locked metabase file.

Return Value:

    HRESULT    

Notes:

--*/
{

    //
    // Unlock the master resource
    //

    g_rMasterResource->Unlock(); 

    if(INVALID_HANDLE_VALUE != *phMetabaseFile)
    {
        //
        // Unlock the metabase file.
        //

        CloseHandle(*phMetabaseFile);
        *phMetabaseFile = INVALID_HANDLE_VALUE;
    }

    return;
}


void
DetermineIfMetabaseCanBeRenamed(LPWSTR      pwszRealFileName,
                                HANDLE      hMetabaseFile,
                                BOOL*       pbRenameMetabase)
/*
++

Routine Description:

    Helper function to determine if the metabase can be renamed.
    It compares the current filetime with that of the last save
    and if not equal it tries to match it with the last processed
    edit while running timestamp.

Arguments:
    [in] Real file name.
    [in] Metabase file.
    [out] Bool to iondicate rename or not.

Return Value:

    HRESULT    

Notes:

--*/
{
    //
    // This function assumes that the g_masterResourceLock has been taken
    // and that the metabase file has been write locked so that no one
    // can be writing at this time.
    //

    HRESULT                     hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   CurrentAttr;

    if(!g_dwEnableEditWhileRunning)
    {
        *pbRenameMetabase = TRUE;
        return;
    }

    *pbRenameMetabase = FALSE;

    if(INVALID_HANDLE_VALUE == hMetabaseFile)
    {
        //
        // This means that the metabase file was not write locked. Assume that
        // the metabase cannot be renamed.
        //

        return;
    }

    if(!GetFileAttributesExW(pwszRealFileName, 
                             GetFileExInfoStandard,
                             &CurrentAttr)
      )
    {
        //
        // Could not fetch the current file attributes for the metabase file.
        // Assume that it cannot be renamed.
        //

        DWORD dwRes = GetLastError();

        hr = RETURNCODETOHRESULT(dwRes);

        DBGINFOW((DBG_CONTEXT,
                 L"[DetermineIfMetabaseCanBeRenamed] Coud not fetch file attributes of the metabase file. GetFileAttributesEx on %s failed with hr = 0x%x.\n", 
                 pwszRealFileName,
                 hr));

        return; 
    }

    if((0 == CompareFileTime(&(CurrentAttr.ftLastWriteTime), &g_MostRecentMetabaseFileLastWriteTimeStamp)) ||
       (0 == CompareFileTime(&(CurrentAttr.ftLastWriteTime), &g_EWRProcessedMetabaseTimeStamp))
      )
    {
        *pbRenameMetabase                = TRUE;
        return;
    }

    return;

} // DetermineIfMetabaseCanBeRenamed


HRESULT
SaveMasterRoot(CWriter*            pCWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob
)
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

     CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT          hresReturn           = ERROR_SUCCESS;
    CMDBaseData*     dataAssociatedData   = NULL;
    DWORD            dwEnumObjectIndex;
    PFILETIME        pftTime;
    ULONG            i                    = 0;
    ULONG            j                    = 0;
    BOOL             bFoundKeyType        = FALSE;
    LPWSTR             wszKeyType         = NULL;
    ULONG             iGroup              = 0;
    CLocationWriter* pCLocationWriter     = NULL;
    LPWSTR           wszRootLocation      = L"/";
    DWORD            dwAttributes         = 0;
    DWORD            dwUserType           = 0;
    DWORD            dwDataType           = 0;
    ULONG            cbData               = 0;

    //
    // TODO: What to do about change time at node level?
    //

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    //
    // Fetch the Location writer.
    //

    hresReturn = pCWriter->GetLocationWriter(&pCLocationWriter,
                                             wszRootLocation);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // Figure out the KeyType of this node. 
    //

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

            if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
            {
                wszKeyType = (LPWSTR)dataAssociatedData->GetData(TRUE);
                dwAttributes = dataAssociatedData->GetAttributes();
                dwUserType =  dataAssociatedData->GetUserType();
                dwDataType =  dataAssociatedData->GetDataType();
                cbData = dataAssociatedData->GetDataLen(TRUE);
                break;
            }
    }


    hresReturn = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                                     dwAttributes,
                                                     dwUserType,
                                                     dwDataType,
                                                     (PBYTE)wszKeyType,
                                                     cbData);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

        hresReturn = SaveDataObject(dataAssociatedData,
                                    pCLocationWriter,
                                    pCryptoStorage,
                                    pSessionKeyBlob);
    }

    if(FAILED(hresReturn))
    {
        goto exit;
    }

    hresReturn = pCLocationWriter->WriteLocation(TRUE);

    if(FAILED(hresReturn))
    {
        goto exit;
    }

exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return(hresReturn);
}

void SaveGlobalsFromLM(CMDBaseData*  pbSave)
{
    if(pbSave->GetDataType() == DWORD_METADATA)
    {
        switch(pbSave->GetIdentifier())
        {
        case MD_ROOT_ENABLE_HISTORY:
            g_dwEnableHistory  = *(DWORD*)pbSave->GetData(TRUE);
            break;

        case MD_ROOT_MAX_HISTORY_FILES:
            g_dwMaxHistoryFiles = *(DWORD*)pbSave->GetData(TRUE);
            break;

        case MD_ROOT_ENABLE_EDIT_WHILE_RUNNING:
            g_dwEnableEditWhileRunning = *(DWORD*)pbSave->GetData(TRUE);
            break;
        }
    }

    return;
}

/*
HRESULT
SaveTree(IN HANDLE               hTempFileHandle,
         IN CMDBaseObject*       pboRoot,
         IN BUFFER*              pbufParentPath,
         IN IIS_CRYPTO_STORAGE*  pCryptoStorage,
         IN PIIS_CRYPTO_BLOB     pSessionKeyBlob)
/

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    Root       - The root of the tree to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;
    ULONG i = 0, j=0;
    BOOL bFoundKeyType = FALSE;
    WCHAR    wszGroup[MAX_GROUP];
    ULONG iGroup =0;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            pftTime = pboRoot->GetLastChangeTime();

            // TODO: MD_ID_OBJECT
            //       pftFileTIme?

             if (SUCCEEDED(hresReturn)) {

                for(i=0; i<MAX_GROUP; i++)
                    g_Group[i].cMBRec = 0;
                g_cGroup = 0;

                //
                // Figure out the kyetype of this node. If keytype not pressent, then assume
                // it is IIsConfigObject.
                //

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

                        if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
                        {
                            bFoundKeyType = TRUE;

                            hresReturn = ValidateKeyType(dataAssociatedData->GetAttributes(),
                                                         dataAssociatedData->GetUserType(),
                                                         dataAssociatedData->GetDataType(),
                                                         (PBYTE)dataAssociatedData->GetData(TRUE),
                                                         dataAssociatedData->GetDataLen(TRUE));

                            if(SUCCEEDED(hresReturn))
                                wcscpy(wszGroup, (LPWSTR)(PBYTE)dataAssociatedData->GetData(TRUE));
                            else if(hresReturn == RETURNCODETOHRESULT(ERROR_INVALID_DATA))
                            {
                                wcscpy(wszGroup, g_wszIIsConfigObject);
                                hresReturn = ERROR_SUCCESS;
                            }
                            else
                                break;

                            break;

                        }
                }

                if(SUCCEEDED(hresReturn))
                {
                    if(!bFoundKeyType)
                        wcscpy(wszGroup, g_wszIIsConfigObject);

                    hresReturn = AddGroup(wszGroup,
                                          &iGroup);

                    if(SUCCEEDED(hresReturn))
                    {


                        for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                            (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                            dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                            hresReturn = SaveDataObject(dataAssociatedData,
                                                        wszGroup,
                                                        pCryptoStorage,
                                                        pSessionKeyBlob);
                        }

                        if(SUCCEEDED(hresReturn))
                            hresReturn = WriteToFile(hTempFileHandle,
                                                     strParentPath);
                    }
                }

                // Cleanup
                for(i=0; i<g_cGroup; i++)
                {
                    for(j=0; j<g_Group[i].cMBRec; j++)
                    {
                        if(NULL != g_Group[i].aMBRec[j].wszValue)
                        {
                            delete [] g_Group[i].aMBRec[j].wszValue;
                            g_Group[i].aMBRec[j].wszValue = NULL;
                        }
                    }
                    g_Group[i].cMBRec = 0;
                }
                g_cGroup = 0;

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hTempFileHandle,
                                          objChildObject,
                                          pbufParentPath,
                                          pCryptoStorage,
                                          pSessionKeyBlob);
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

    return(hresReturn);
}
*/


HRESULT
SaveTree(IN CWriter*             pCWriter,
         IN CMDBaseObject*       pboRoot,
         IN BUFFER*              pbufParentPath,
         IN IIS_CRYPTO_STORAGE*  pCryptoStorage,
         IN PIIS_CRYPTO_BLOB     pSessionKeyBlob,
         IN BOOL                 bRecurse,   /* default = TRUE */
         IN BOOL                 bSaveSchema, /* default = TRUE */
         IN BOOL                 bLocalMachine /* default = FALSE */)
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    Root          - The root of the tree to save.

    CryptoStorage - Used to encrypt secure data.

    bRecurse      - Save Children as well.

    bSaveSchema   - If we end up at /schema node, call SaveTree on /schema.

    bLocalMachine - True if it is the /LM node. 

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER objChildObjectContainer = NULL;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;
    ULONG i = 0, j=0;
    BOOL bFoundKeyType = FALSE;
    ULONG iGroup =0;
    CLocationWriter*  pCLocationWriter = NULL;
    LPWSTR wszKeyType = NULL;
    DWORD dwAttributes = 0;
    DWORD dwUserType = 0;
    DWORD dwDataType = 0;
    DWORD cbData = 0;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            if(pboRoot != g_pboMasterRoot) {
                wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
                strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
                strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            }
            pftTime = pboRoot->GetLastChangeTime();

            // TODO: MD_ID_OBJECT
            //       pftFileTIme?


            //
            // Fetch the Location writer.
            //

            hresReturn = pCWriter->GetLocationWriter(&pCLocationWriter,
                                                     strParentPath);

//            if(FAILED(hresReturn))
//                goto exit;

            //
            // Figure out the KeyType of this node. 
            //

            for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

                    if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
                    {
                        wszKeyType = (LPWSTR)dataAssociatedData->GetData(TRUE);
                        dwAttributes = dataAssociatedData->GetAttributes();
                        dwUserType =  dataAssociatedData->GetUserType();
                        dwDataType =  dataAssociatedData->GetDataType();
                        cbData = dataAssociatedData->GetDataLen(TRUE);
                        break;
                    }
            }

            if(SUCCEEDED(hresReturn))
            {
                hresReturn = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                                                 dwAttributes,
                                                                 dwUserType,
                                                                 dwDataType,
                                                                 (PBYTE)wszKeyType,
                                                                 cbData);
            }

            for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                hresReturn = SaveDataObject(dataAssociatedData,
                                            pCLocationWriter,
                                            pCryptoStorage,
                                            pSessionKeyBlob);
                                if(bLocalMachine)
                                {
                                        SaveGlobalsFromLM(dataAssociatedData);
                                }
            }

            if(SUCCEEDED(hresReturn))
            {
                hresReturn = pCLocationWriter->WriteLocation(TRUE);
            }

            if(bRecurse) {
                for(objChildObjectContainer=pboRoot->NextChildObject(NULL);
                    (SUCCEEDED(hresReturn)) && (objChildObjectContainer!=NULL);
                    objChildObjectContainer=pboRoot->NextChildObject(objChildObjectContainer)) {
               
                    if(bSaveSchema || 
                       !(pboRoot == g_pboMasterRoot &&
                         _wcsicmp((LPWSTR)objChildObjectContainer->pboMetaObject->GetName(TRUE), g_wszSchema) == 0) )
                    hresReturn = SaveTree(pCWriter,
                                          objChildObjectContainer->pboMetaObject,
                                          pbufParentPath,
                                          pCryptoStorage,
                                          pSessionKeyBlob,
                                          bRecurse,
                                          true);
                    }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

//exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }
    return(hresReturn);
}

/*
HRESULT
SaveDataObject(CMDBaseData*        pbdSave,
               LPWSTR               wszGroup,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob)
++

Routine Description:

    Save a data object.

Arguments:

    Save       - The data object to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL    bGoodData  = TRUE;
    int     iStringLen;
    PBYTE   pbData;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {
    
        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {

                PIIS_CRYPTO_BLOB blob = NULL;
                PBYTE            pbData = NULL;
                DWORD            cbData = 0;

                pbData = (PBYTE)pbdSave->GetData(TRUE);
                cbData = pbdSave->GetDataLen(TRUE);

                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData(&blob,
                                                          pbData,
                                                          cbData,
                                                          0);
                    if (SUCCEEDED(hresReturn)) {
                        pbData = (PBYTE)blob;
                        cbData = IISCryptoGetBlobLength(blob);
                    }

                } 

                if (SUCCEEDED(hresReturn)) {                    
                    hresReturn = AddProperty(pbdSave->GetIdentifier(),
                                             pbdSave->GetAttributes(),
                                             pbdSave->GetUserType(),
                                             pbdSave->GetDataType(),
                                             wszGroup,
                                             (PBYTE)pbData,
                                             cbData);

                    if(NULL != blob) {
                        ::IISCryptoFreeBlob(blob);
                    }
                }

            }
        }
    }
    return (hresReturn);
}
*/

HRESULT
SaveDataObject(CMDBaseData*        pbdSave,
               CLocationWriter*       pCLocationWriter,
               IIS_CRYPTO_STORAGE* pCryptoStorage,
               PIIS_CRYPTO_BLOB    pSessionKeyBlob)
/*++

Routine Description:

    Save a data object.

Arguments:

    Save       - The data object to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL    bGoodData  = TRUE;
    int     iStringLen;
    PBYTE   pbData;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {
    
        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {

                PIIS_CRYPTO_BLOB blob = NULL;
                PBYTE            pbData = NULL;
                DWORD            cbData = 0;

                pbData = (PBYTE)pbdSave->GetData(TRUE);
                cbData = pbdSave->GetDataLen(TRUE);

                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData(&blob,
                                                          pbData,
                                                          cbData,
                                                          0);
                    if (SUCCEEDED(hresReturn)) {
                        pbData = (PBYTE)blob;
                        cbData = IISCryptoGetBlobLength(blob);
                    }
                    else
                    {
                        DBGINFOW((DBG_CONTEXT,
                                  L"[SaveDataObject] Unable to encrypt data. Failed with hr = 0x%x. Property id: %d Location %s.\n", 
                                  hresReturn,
                                  pbdSave->GetIdentifier(),
                                  pCLocationWriter->m_wszLocation));
                    }

                } 

                if (SUCCEEDED(hresReturn)) {    
                    hresReturn = pCLocationWriter->AddProperty(pbdSave->GetIdentifier(),
                                                               pbdSave->GetAttributes(),
                                                               pbdSave->GetUserType(),
                                                               pbdSave->GetDataType(),
                                                               (PBYTE)pbData,
                                                               cbData);

                    if(NULL != blob) {
                        ::IISCryptoFreeBlob(blob);
                    }
                }

            }
        }
    }
    return (hresReturn);
}


BOOL
DiscontinuousLocation(LPWSTR wszPreviousLocation,
                      LPWSTR wszCurrentLocation)
{
    LPWSTR wszStartCurrent    = wszCurrentLocation;
    LPWSTR wszEndCurrent      = NULL;
    BOOL   bNeedRestore       = FALSE;
    ULONG  cchCurrentLocation = 0;
    BOOL   bReturn;
    ULONG  cchCompare         = 0;

    if(NULL == wszPreviousLocation || 0 == *wszPreviousLocation ||
       NULL == wszCurrentLocation  || 0 == *wszCurrentLocation)
    {
        bReturn = TRUE;
    }
    else
    {
                cchCurrentLocation = wcslen(wszCurrentLocation);

        if((wszCurrentLocation[cchCurrentLocation-1] == L'/') &&
           (1 != cchCurrentLocation)
          )
        {
            //
            // If the location ends in a "/" and is not the root location, 
            // then null it out for the purpose of comparison.
            //

            wszCurrentLocation[cchCurrentLocation-1] = 0;
            bNeedRestore = TRUE;
        }
            
        wszEndCurrent = wcsrchr(wszCurrentLocation, L'/');

        if(wszEndCurrent == wszCurrentLocation)
        {
            //
            // This is the root location
            //
            cchCompare = 1;
        }
        else
        {
            cchCompare = (ULONG)(wszEndCurrent-wszCurrentLocation);
        }

        if(0 == _wcsnicmp(wszPreviousLocation, wszCurrentLocation, cchCompare))
        {
            bReturn = FALSE;
        }
        else
        {
            bReturn = TRUE;
        }

        if(bNeedRestore)
        {
            wszCurrentLocation[cchCurrentLocation-1] = L'/';
        }

    }

    return bReturn;
}


HRESULT 
InitSessionKey(ISimpleTableRead2*   pISTProperty,
               IIS_CRYPTO_STORAGE** ppStorage,
               LPSTR                pszPasswd)
{
    HRESULT hresReturn = 0;
    BOOL    fSecuredRead = TRUE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) 
    {
        dwSize = MAX_PATH * sizeof(TCHAR);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_UNSECUREDREAD_VALUE,
                        NULL,
                        &dwType,
                        (BYTE *)&dwValue,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS && 
             dwType == REG_DWORD &&
             dwValue == 1)
        {
            hresReturn = NO_ERROR;
            *ppStorage = NULL;
            fSecuredRead = FALSE;

            DBGPRINTF(( DBG_CONTEXT,
                        "Temporary disabling  decryption for metabase read\n"));


            // special indicator for IIS setup that we passed this point
            dwValue = 2;
            dwRegReturn = RegSetValueEx(hkRegistryKey,
                            MD_UNSECUREDREAD_VALUE,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwValue,
                            sizeof(dwValue));
            if (dwRegReturn == ERROR_SUCCESS) 
            {
                DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
            }

        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (fSecuredRead)
    {
        ULONG   cbSessionKey = 0;
        BYTE*   pbSessionKey = NULL;

        hresReturn = GetGlobalValue(pISTProperty,
                                    MD_SESSION_KEYW,
                                    &cbSessionKey,
                                    (LPVOID*)&pbSessionKey);

        if(FAILED(hresReturn))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[InitSessionKey] Error: Session key could not be fetched. GetGlobalValue failed with hr = 0x%x.\n",
                      hresReturn));
            return MD_ERROR_NO_SESSION_KEY;
        }

        if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) pbSessionKey))
        {
                // call special function focibly tell that this machine has no 
                // encryption enabled even if it happens to be so
                // that's a special handling for French case with US locale
                IISCryptoInitializeOverride (FALSE);
        }

        if( !pszPasswd )
        {
            hresReturn = InitStorageHelper(pbSessionKey,
                                           cbSessionKey, // dwLineLen-1
                                           ppStorage);
        }
        else
        {
            hresReturn = InitStorageHelper2(pszPasswd,
                                            pbSessionKey,
                                            cbSessionKey, // dwLineLen-1
                                            ppStorage);
        }

        if(FAILED(hresReturn))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[InitSessionKey] InitStorageHelper? failed with hr = 0x%x.\n",hresReturn));
        }

    }

    return hresReturn;

}


HRESULT
GetUnicodeNameW(IN  LPWSTR  wszFileName, 
                OUT LPWSTR* pwszFileName)
{
    *pwszFileName = new WCHAR[wcslen(wszFileName)+1];
    if(NULL == *pwszFileName)
        return E_OUTOFMEMORY;

    wcscpy(*pwszFileName, wszFileName);

    return S_OK;

}

HRESULT
GetUnicodeNameA(IN  LPSTR   szFileName, 
                OUT LPWSTR* pwszFileName)
{

    ULONG cchOut = 0;

    cchOut = MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                 0,                              
                                 szFileName,
                                 (strlen(szFileName) + 1)*sizeof(char),
                                 NULL,
                                 0);

    if(!cchOut)
        return HRESULT_FROM_WIN32(GetLastError());

    *pwszFileName = new WCHAR[cchOut+1];
    if(NULL == *pwszFileName)
        return E_OUTOFMEMORY;

    cchOut = MultiByteToWideChar(CP_ACP,       // XXX Consider: make any cp?
                                 0,                              
                                 szFileName,
                                 (strlen(szFileName) + 1)*sizeof(char),
                                 *pwszFileName,
                                 cchOut);

    if(!cchOut)
    {
        delete *pwszFileName;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;

}


HRESULT 
InitEditWhileRunning(ISimpleTableRead2*   pISTProperty)
{
    HRESULT hresReturn       = S_OK;

    DWORD   dwDisable        = 0;
    DWORD*  pdwEnable        = &dwDisable;
    ULONG*  pulVersionMajor  = NULL;
    ULONG*  pulVersionMinor  = NULL;

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_ENABLE_EDIT_WHILE_RUNNINGW,
                                  NULL,
                                  (LPVOID*)&pdwEnable);

    if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not determine if edit while running was enabled. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n",
                  g_dwEnableEditWhileRunning, hresReturn));

    }
    else
    {
        g_dwEnableEditWhileRunning = *pdwEnable;
    }


    //
    // Init Edit while running version number irrespective of whether edit 
    // while running is enabled, because they are used to create history files.
    //

    hresReturn = GetGlobalValue(pISTProperty,
                                MD_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBERW,
                                NULL,
                                (LPVOID*)&pulVersionMajor);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        //
        // TODO: Search through history dir and get the highest version number
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not fetch history major version number. Defaulting to 0x%x. GetGlobalValue failed with hr = 0x%x.\n",
                  g_ulHistoryMajorVersionNumber, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEditWhileRunning] Could not fetch history major version number. Defaulting to 0x%x. GetGlobalValue failed with hr = 0x%x.\n",
                  g_ulHistoryMajorVersionNumber, hresReturn));

        hresReturn = S_OK;
    }
    else
    {
        g_ulHistoryMajorVersionNumber = (*(ULONG*)pulVersionMajor);

        DBGINFOW((DBG_CONTEXT,
                   L"[InitEditWhileRunning] Read history major version number as 0x%x.\n", 
                   g_ulHistoryMajorVersionNumber));
    }

    return hresReturn;
}


HRESULT InitEnableHistory(ISimpleTableRead2*   pISTProperty)
{

    HRESULT hresReturn        = S_OK;
    DWORD   dwEnableHistory   = FALSE;
    DWORD*  pdwEnableHistory  = &dwEnableHistory;
    DWORD   dwMaxHistoryFiles  = 0;
    DWORD*  pdwMaxHistoryFiles = &dwMaxHistoryFiles;

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_ENABLE_HISTORYW,
                                  NULL,
                                  (LPVOID*)&pdwEnableHistory);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch enable history. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n", 
                    g_dwEnableHistory, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch enable history. GetGlobalValue failed with hr = 0x%x.\n", 
                  hresReturn));

        return hresReturn;
    }
    else 
    {
        g_dwEnableHistory = *pdwEnableHistory;
    }

    if((g_dwEnableEditWhileRunning) && (0 == g_dwEnableHistory))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Warning! Edit while running is enabled, while Enable history is disabled. Forcibly enabling history.\n"));

        g_dwEnableHistory = 1;
    }

    hresReturn = GetComputerValue(pISTProperty,
                                  MD_MAX_HISTORY_FILESW,
                                  NULL,
                                  (LPVOID*)&pdwMaxHistoryFiles);

    if(E_ST_NOMOREROWS == hresReturn)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch max history files. Defaulting to %d. GetComputerValue failed with hr = 0x%x.\n", 
                  g_dwMaxHistoryFiles, hresReturn));

        hresReturn = S_OK;
    }
    else if(FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch max history files. GetComputerValue with hr = 0x%x.\n", 
                  hresReturn));

        return hresReturn;
    }
    else
    {
        g_dwMaxHistoryFiles = *pdwMaxHistoryFiles;
    }

    ValidateMaxHistoryFiles();

    if(g_dwEnableHistory)
    {
        hresReturn = CreateHistoryFiles(g_wszRealFileName,
                                        g_wszSchemaFileName,
                                        g_ulHistoryMajorVersionNumber,
                                        g_dwMaxHistoryFiles);
    }

    return hresReturn;
}


void
ValidateMaxHistoryFiles()
{

    if((0 == g_dwMaxHistoryFiles) && (g_dwEnableEditWhileRunning))
    {
        g_dwMaxHistoryFiles = MD_COUNT_MAX_HISTORY_FILES;

        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Warning! Edit while running is enable, while max history files is zero. Defaulting to %d.\n", 
                  g_dwMaxHistoryFiles, HRESULT_FROM_WIN32(ERROR_INVALID_DATA)));

        LogEvent(g_pEventLog,
                 MD_ERROR_DAFAULTING_MAX_HISTORY_FILES,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 S_OK);


    }
    else if((0 == g_dwMaxHistoryFiles) && (g_dwEnableHistory))
    {
        g_dwMaxHistoryFiles = MD_COUNT_MAX_HISTORY_FILES;

        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Warning! History is enabled, while max history files is zero. Defaulting to %d.\n", 
                  g_dwMaxHistoryFiles, HRESULT_FROM_WIN32(ERROR_INVALID_DATA)));

        LogEvent(g_pEventLog,
                 MD_ERROR_DAFAULTING_MAX_HISTORY_FILES,
                 EVENTLOG_ERROR_TYPE,
                 ID_CAT_CAT,
                 HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }

    return;
}


HRESULT 
InitChangeNumber(ISimpleTableRead2*   pISTProperty)
{
    HRESULT hresReturn        = S_OK;
    DWORD*  pdwChangeNumber    = NULL;

    hresReturn = GetGlobalValue(pISTProperty,
                                MD_CHANGE_NUMBERW,
                                NULL,
                                (LPVOID*)&pdwChangeNumber);

    if(FAILED(hresReturn))
    {
        //
        // TODO: Lookup the version on the backed up files 
        // to determine the max version number.
        //
        g_dwSystemChangeNumber = 0;

        DBGINFOW((DBG_CONTEXT,
                  L"[InitEnableHistory] Could not fetch change number. Defaulting to %d. GetGlobalValue failed with hr = 0x%x.\n",
                    g_dwSystemChangeNumber, hresReturn));

    }
    else
    {
        g_dwSystemChangeNumber = *pdwChangeNumber;
    }

    return S_OK;
}


HRESULT
CreateHistoryFiles(LPWSTR   i_wszDataFileName,
                   LPWSTR   i_wszSchemaFileName,
                   ULONG    i_ulHistoryMajorVersionNumber,
                   DWORD    i_dwMaxHistoryFiles)

{
    WCHAR*               wszHistoryDataFileName     = NULL;
    WCHAR*               wszHistorySchemaFileName   = NULL;
    HRESULT              hr                         = S_OK;
    DWORD                dwMinorVersion             = 0;

    //
    // Create the history directory, if it is not present.
    //

    if(-1 == GetFileAttributesW(g_wszHistoryFileDir))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if((hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))|| 
           (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
          )
        {
            SECURITY_ATTRIBUTES  saStorage;
            PSECURITY_ATTRIBUTES psaStorage  = NULL;

            //
            // Initialize the security attributes & create the file
            //

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            if(!CreateDirectoryW(g_wszHistoryFileDir, psaStorage))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                DBGINFOW((DBG_CONTEXT,
                          L"[CreateHistoryFile] Unable to create history directory. CreateDirectoryW failed with hr = 0x%x. \n", 
                          hr));

                return hr;
            }
            else 
            {
                hr = S_OK;
            }
        }
        else
        {
            return hr;
        }
    }

    //
    // Create the data file before the schema file. Under stress data files 
    // can grow and if the creation of data files fail, then you do not want
    // to create the schema file.
    //

    //
    // Create the data history file first
    //

    hr = CreateHistoryFile(i_wszDataFileName,
                           g_wszHistoryFileDir,
                           g_cchHistoryFileDir,
                           g_wszRealFileNameWithoutPathWithoutExtension,
                           g_cchRealFileNameWithoutPathWithoutExtension,
                           g_wszRealFileNameExtension,
                           g_cchRealFileNameExtension,
                           i_ulHistoryMajorVersionNumber);

    if(SUCCEEDED(hr))
    {
        //
        // Create the schema history file next
        //

        hr = CreateHistoryFile(i_wszSchemaFileName,
                               g_wszHistoryFileDir,
                               g_cchHistoryFileDir,
                               g_wszSchemaFileNameWithoutPathWithoutExtension,
                               g_cchSchemaFileNameWithoutPathWithoutExtension,
                               g_wszSchemaFileNameExtension,
                               g_cchSchemaFileNameExtension,
                               i_ulHistoryMajorVersionNumber);
    }


    //
    // Cleanup the obsolete history files.
    //

    hr = CleanupObsoleteHistoryFiles(i_dwMaxHistoryFiles,
                                     i_ulHistoryMajorVersionNumber);

    return hr;
}


HRESULT
CreateHistoryFile(LPWSTR               i_wszFileName,
                  LPWSTR               i_wszHistroyFileDir,
                  ULONG                i_cchHistoryFileDir,
                  LPWSTR               i_wszFileNameWithoutPathWithoutExtension,
                  ULONG                i_cchFileNameWithoutPathWithoutExtension,
                  LPWSTR               i_wszFileNameExtension,
                  ULONG                i_cchFileNameExtension,
                  DWORD                i_ulHistoryMajorVersionNumber)
{
    WCHAR*              wszHistoryFileName      = NULL;
    HRESULT             hr                      = S_OK;
    DWORD               dwMinorVersion          = 0;

    //
    // Construct the history data file name
    //

    hr = ConstructHistoryFileName(&wszHistoryFileName,
                                  i_wszHistroyFileDir,
                                  i_cchHistoryFileDir,
                                  i_wszFileNameWithoutPathWithoutExtension,
                                  i_cchFileNameWithoutPathWithoutExtension,
                                  i_wszFileNameExtension,
                                  i_cchFileNameExtension,
                                  i_ulHistoryMajorVersionNumber,
                                  dwMinorVersion);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Unable to construct history file name. ConstructHistoryFileName failed with hr = 0x%x\n.", 
                  hr));
        goto exit;
    }

    //
    // Create the history file
    //

    DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Copying history file from %s to %s.\n", 
                  i_wszFileName, 
                  wszHistoryFileName));

    if(!CopyFileW(i_wszFileName,
                      wszHistoryFileName,
                      FALSE)                  // Overwrite if it exists.
          )             
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[CreateHistoryFile] Unable to create history file. CopyFileW from %s to %s failed with hr = 0x%x\n.", 
                  i_wszFileName,
                  wszHistoryFileName,
                  hr));

        goto exit;

    }
    else
    {
        SetSecurityOnFile(i_wszFileName,
                          wszHistoryFileName);
    }

exit:
    
    if(NULL != wszHistoryFileName)
    {
        delete [] wszHistoryFileName;
        wszHistoryFileName = NULL;
    }

    return hr;
}

int _cdecl MyCompareFileData(const void *a,
                             const void *b)
{
    return CompareFileTime(&(((METABASE_FILE_DATA*)a)->ftLastWriteTime), &(((METABASE_FILE_DATA*)b)->ftLastWriteTime));
}


HRESULT ConstructHistoryFileName(LPWSTR*  o_wszHistoryFile,
                                 LPWSTR   i_wszHistroyFileDir,
                                 ULONG    i_cchHistoryFileDir,
                                 LPWSTR   i_wszFileNameWithoutPathWithoutExtension,
                                 ULONG    i_cchFileNameWithoutPathWithoutExtension,
                                 LPWSTR   i_wszFileNameExtension,
                                 ULONG    i_cchFileNameExtension,
                                 ULONG    i_ulMajorVersion,
                                 ULONG    i_ulMinorVersion)
{
    ULONG   cch            = 0;
    LPWSTR  pEnd           = NULL;
    int     res            = 0;
    HRESULT hr             = S_OK;
    WCHAR   wszVersion[MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW+1];
    
    *o_wszHistoryFile = NULL;

    res = _snwprintf(wszVersion, 
                     MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW+1, 
                     L"_%010lu_%010lu", 
                     i_ulMajorVersion, 
                     i_ulMinorVersion);
    if(res < 0)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ConstructHistoryFileName] _snwprintf returned a negative value. This should never happen.\n"));
        MD_ASSERT(0);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;

    }

    cch = i_cchHistoryFileDir + 
          1 + // For backslash if it doesn't end in one 
          i_cchFileNameWithoutPathWithoutExtension + 
          MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW + 
          i_cchFileNameExtension;

    *o_wszHistoryFile= new WCHAR[cch+1];
    if(NULL == *o_wszHistoryFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pEnd = *o_wszHistoryFile;
    memcpy(pEnd, i_wszHistroyFileDir, i_cchHistoryFileDir*sizeof(WCHAR));
    pEnd = pEnd + i_cchHistoryFileDir;
    if(i_wszHistroyFileDir[i_cchHistoryFileDir-1] != L'\\')
    {
        *pEnd = L'\\';
        pEnd++;
    }
    memcpy(pEnd, i_wszFileNameWithoutPathWithoutExtension, i_cchFileNameWithoutPathWithoutExtension*sizeof(WCHAR));
    pEnd = pEnd + i_cchFileNameWithoutPathWithoutExtension;
    memcpy(pEnd, wszVersion, MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW*sizeof(WCHAR));
    pEnd = pEnd + MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW;
    if(0 != i_cchFileNameExtension)
    {
        memcpy(pEnd, i_wszFileNameExtension, i_cchFileNameExtension*sizeof(WCHAR));
        pEnd = pEnd + i_cchFileNameExtension;
    }
    *(pEnd) = L'\0';

exit:    
    return hr;

}

HRESULT ConstructHistoryFileNameWithoutMinorVersion(LPWSTR*  o_wszHistoryFileNameWithoutMinorVersion,
                                                    ULONG*   o_iStartMinorVersion,
                                                    LPWSTR   i_wszHistroyFileSearchString,
                                                    ULONG    i_cchHistoryFileSearchString,
                                                    LPWSTR   i_wszFileNameExtension,
                                                    ULONG    i_cchFileNameExtension,
                                                    ULONG    i_ulMajorVersion)
/*
++

Routine Description:

    Constructs the history file search string, given the following:
    History file search string 
      (This would look like:
           D:\Winnt\system32\inetsrv\History\Metabase_??????????_??????????.XML
           or if the path is long (greater that MAX_PATH):
           \\?\D:\Winnt\system32\inetsrv\History\Metabase_??????????_??????????.XML
      )
    Major history version number

    The resulting string would look something like:
    D:\Winnt\system32\inetsrv\History\Metabase_0000000001_??????????.XML
    or if the path is long (greater that MAX_PATH):
    \\?\D:\Winnt\system32\inetsrv\History\Metabase_0000000001_??????????.XML


Arguments:

    Return - The full path of the history file search string.
    Return - The start index of where the minor version would begin.

    History file search string 
    History file search string count of characters
    History file extension, if any (Eg: ".XML")
    History file extension character count
    Major history version number

Return Value:

    HRESULT  - S_OK
               HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
               E_OUTOFMEMORY

Notes:

--*/
{
    ULONG       cch      = 0;
    ULONG       cchFile  = 0;
    LPWSTR      pEnd     = NULL;
    int         res      = 0;
    HRESULT     hr       = S_OK;
    WCHAR       wszVersionNumber[MD_CCH_MAX_ULONG+1];
    
    res = _snwprintf(wszVersionNumber, 
                     MD_CCH_MAX_ULONG+1, 
                     L"%010lu", 
                     i_ulMajorVersion);
    if(res < 0)
    {
        //
        // TODO: This is an assert condition. Add an assert.
        //
        DBGINFOW((DBG_CONTEXT,
                  L"[ConstructHistoryFileNameWithoutMinorVersion] _snwprintf returned a negative value. This should never happen.\n"));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;

    }

    *o_wszHistoryFileNameWithoutMinorVersion = new WCHAR[i_cchHistoryFileSearchString+1];
    if(NULL == *o_wszHistoryFileNameWithoutMinorVersion)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pEnd = *o_wszHistoryFileNameWithoutMinorVersion;
    memcpy(pEnd, i_wszHistroyFileSearchString, i_cchHistoryFileSearchString*sizeof(WCHAR));
    pEnd = pEnd + i_cchHistoryFileSearchString;
    *pEnd = 0;

    pEnd = ((*o_wszHistoryFileNameWithoutMinorVersion) + i_cchHistoryFileSearchString) - 
           i_cchFileNameExtension                - 
           MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW  + 
           MD_CCH_UNDERSCOREW;

    memcpy(pEnd, wszVersionNumber, MD_CCH_MAX_ULONG*sizeof(WCHAR));


    if(NULL != o_iStartMinorVersion)
    {
        *o_iStartMinorVersion = i_cchHistoryFileSearchString          -
                                i_cchFileNameExtension                -
                                MD_CCH_HISTORY_FILE_SEARCH_EXTENSIONW +
                                MD_CCH_UNDERSCOREW                    +
                                MD_CCH_MAX_ULONG                      +
                                MD_CCH_UNDERSCOREW;
    }

exit:
    
    return hr;

} // ConstructHistoryFileNameWithoutMinorVersion


HRESULT ReAllocateFileData(ULONG                i_iFileData,
                           METABASE_FILE_DATA** io_aFileData,
                           ULONG*               io_pcFileData,
                           BOOL*                io_pbReAlloced)
{
    METABASE_FILE_DATA* aTemp = NULL;
    HRESULT             hr    = S_OK;

    aTemp = new METABASE_FILE_DATA[*io_pcFileData + MD_MAX_HISTORY_FILES_ALLOC_SIZE];
    if(NULL == aTemp)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    *io_pcFileData = *io_pcFileData + MD_MAX_HISTORY_FILES_ALLOC_SIZE;

    memset(aTemp, 0, (*io_pcFileData)*sizeof(METABASE_FILE_DATA));

    if((NULL != *io_aFileData))
    {
        memcpy(aTemp, *io_aFileData, i_iFileData*sizeof(METABASE_FILE_DATA));

        if(*io_pbReAlloced)
        {
            delete [] *io_aFileData;
            *io_aFileData = NULL;
        }
    }

    *io_pbReAlloced = TRUE;
        *io_aFileData = aTemp;

    return hr;
}

HRESULT CleanupObsoleteHistoryFiles(DWORD i_dwMaxHistoryFiles,
                                    ULONG i_ulHistoryMajorVersionNumber)
{
    HANDLE              hFind         = INVALID_HANDLE_VALUE;   
    WIN32_FIND_DATAW    FileData;   
    FILETIME            ftLastWriteTime;
    HRESULT             hr            = S_OK;
    ULONG               iVersion      = 0;
    METABASE_FILE_DATA  aOldVersionsFixed[MD_MAX_HISTORY_FILES_ALLOC_SIZE];
    METABASE_FILE_DATA* aOldVersions  = (METABASE_FILE_DATA*)&(aOldVersionsFixed[0]);
    BOOL                bReAlloced    = FALSE;
    ULONG               cVersions     = MD_MAX_HISTORY_FILES_ALLOC_SIZE;
    ULONG               ulVersionMajor;
    ULONG               ulVersionMinor;

    //
    // We also cleanup the stale (non-zero) backedup minor versions, that
    // correspond to the major version we just created.This can happen if 
    // someone is restoring to an old version, & restarting IIS.
    //
    // Delete old history files based on timestamp rather than version number.
    // Because if you start by restoring an old version, you dont  
    // want to delete it. Save as soon as you load the old version so
    // that it is re-backed up.
    //
    // We search for all the data history files only, then we sort them
    // in ascending order, then we delete the old ones along with their 
    // schema files. 
    //

    //
    // Search for all the data history files.
    //

    hFind = FindFirstFileW(g_wszHistoryFileSearchString, &FileData);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[CleanupObsoleteHistoryFiles] Unable find any old history files. FindFirstFileW on %s failed with hr = 0x%x.\n", 
                   g_wszHistoryFileSearchString, hr));

        goto exit;
    }

    do
    {
        //
        // Extract the version number from the file name.
        //

        hr = ParseVersionNumber(FileData.cFileName,
                                g_cchRealFileNameWithoutPathWithoutExtension,
                                &ulVersionMinor,
                                &ulVersionMajor);

        if(FAILED(hr))
        {
            //
            // Assume invalid file and continue
            //

            DBGINFOW((DBG_CONTEXT,
                      L"[CleanupObsoleteHistoryFiles] Unable to parse version number from file name %s. This file will not be cleaned up.\n", 
                       FileData.cFileName));
            hr = S_OK;
            continue;
        }

        //
        // Save the last write timestamp.
        //

        ftLastWriteTime = FileData.ftLastWriteTime;

        //
        // Save the version number.
        //

        if(iVersion >= cVersions)
        {
            hr = ReAllocateFileData(iVersion,
                                    &aOldVersions,
                                    &cVersions,
                                    &bReAlloced);

            if(FAILED(hr))
            {
                goto exit;
            }
        }

        aOldVersions[iVersion].ulVersionMinor   = ulVersionMinor;
        aOldVersions[iVersion].ulVersionMajor   = ulVersionMajor;
        aOldVersions[iVersion].ftLastWriteTime  = ftLastWriteTime;

        iVersion++;

    }while (FindNextFileW(hFind, &FileData));

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    //
    // Check to see if there are any history files with the same major version and a 
    // non-zero minor version, if so delete the non-zero minor versions. This 
    // can happen when someone restores from an old history file. Make sure
    // this cleanup happens first so that we are in a state where timestamps
    // of all non-zero minor versions are greater that the zero minor versions.
    //

    for (ULONG i=0; i< iVersion; i++ )
    {
        if((aOldVersions[i].ulVersionMajor == i_ulHistoryMajorVersionNumber) &&
           (aOldVersions[i].ulVersionMinor != 0)
          )
        {
            //
            // Delete data history file first. We create a data file with a 
            // non-zero minor number when a text edit takes place and we
            // have successfully applied the text edit to memory.
            //

            hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                   g_cchHistoryFileDir,
                                   g_wszRealFileNameWithoutPathWithoutExtension,
                                   g_cchRealFileNameWithoutPathWithoutExtension,
                                   g_wszRealFileNameExtension,
                                   g_cchRealFileNameExtension,
                                   aOldVersions[i].ulVersionMajor,
                                   aOldVersions[i].ulVersionMinor);


            if(SUCCEEDED(hr))
            {
                //
                // Delete schema file next
                //
                hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                       g_cchHistoryFileDir,
                                       g_wszSchemaFileNameWithoutPathWithoutExtension,
                                       g_cchSchemaFileNameWithoutPathWithoutExtension,
                                       g_wszSchemaFileNameExtension,
                                       g_cchSchemaFileNameExtension,
                                       aOldVersions[i].ulVersionMajor,
                                       aOldVersions[i].ulVersionMinor);
            }
        }
    }

    if ( iVersion > i_dwMaxHistoryFiles )
    {
        ULONG cDeleted     = 0;
        ULONG cNeedDeleted = iVersion-i_dwMaxHistoryFiles;

        //
        // Exceeded max history files -
        // Delete old history files i.e. the first dwMaxHistoryFiles - cFile
        //

        qsort((void*)aOldVersions, iVersion, sizeof(METABASE_FILE_DATA), MyCompareFileData);

        for (ULONG i=0; cDeleted<cNeedDeleted && i<iVersion ; i++ )
        {
            if(aOldVersions[i].ulVersionMajor == i_ulHistoryMajorVersionNumber)
            {
                //
                // Do not cleanup the file you just created.
                //

                continue;
            }
            else
            {
                //
                // Delete data history file first
                //

                hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                       g_cchHistoryFileDir,
                                       g_wszRealFileNameWithoutPathWithoutExtension,
                                       g_cchRealFileNameWithoutPathWithoutExtension,
                                       g_wszRealFileNameExtension,
                                       g_cchRealFileNameExtension,
                                       aOldVersions[i].ulVersionMajor,
                                       aOldVersions[i].ulVersionMinor);

                if(SUCCEEDED(hr))
                {
                    //
                    // Delete schema file next
                    //

                    cDeleted++;

                    hr = DeleteHistoryFile(g_wszHistoryFileDir,
                                           g_cchHistoryFileDir,
                                           g_wszSchemaFileNameWithoutPathWithoutExtension,
                                           g_cchSchemaFileNameWithoutPathWithoutExtension,
                                           g_wszSchemaFileNameExtension,
                                           g_cchSchemaFileNameExtension,
                                           aOldVersions[i].ulVersionMajor,
                                           aOldVersions[i].ulVersionMinor);
                }
            }
        } // End loop for all history files, delete the oldest (see rules in comment)
    } // End if the number of histor files exceeds the max history file count.


exit:

    if((aOldVersionsFixed != aOldVersions) && (NULL != aOldVersions))
    {
        delete [] aOldVersions;
        aOldVersions = NULL;
        cVersions = 0;
    }

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return hr;

} // CleanupObsoleteHistoryFiles


HRESULT ParseVersionNumber(LPWSTR  i_wszFileName,
                           ULONG   i_cchFileNameUntilFirstUnderscore,
                           ULONG*  o_ulVersionMinor, 
                           ULONG*  o_ulVersionMajor)
/*
++

Routine Description:

    Parses the major and minor history version numbers from the file name.
    The file name can be the full path to the hisory file or the file name 
    only.
    Eg: 
    D:\Winnt\system32\inetsrv\History\Metabase_0000000001_0000000001.XML
    Metabase_0000000001_0000000001.XML

Arguments:

    History file name (full path to file name or just file name). The file 
    name cannot contain wild chars ?????????? for version numbers.

    Count of chars in the history file name upto the fist underscore.

    Return - Major history version number
    Return - Minor history version number

Return Value:

    HRESULT  - S_OK
               HRESULT_FROM_WIN32(ERROR_INVALID_NAME)

Notes:

--*/
{
    int     res              = 0;
    HRESULT hr               = S_OK;
    ULONG   ulVersionMinor   = 0; 
    ULONG   ulVersionMajor   = 0;

    //
    // Look for the first underscore
    //

    if(i_wszFileName[i_cchFileNameUntilFirstUnderscore]  != MD_CH_UNDERSCOREW)  
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        goto exit;
    }

    LPWSTR pCur = &(i_wszFileName[i_cchFileNameUntilFirstUnderscore]);

    for(ULONG i = 0; i < 2; i++)
    {
        pCur = wcschr(pCur, L'_');
        if(pCur == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            goto exit;
        }
        pCur++;
        if( !WstrToUl(
                pCur, 
                (i == 0) ? L'_'            : L'.',
                (i == 0) ? &ulVersionMajor : &ulVersionMinor) )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            goto exit;
        }        
    }

    if(NULL !=  o_ulVersionMinor)
    {
        *o_ulVersionMinor = ulVersionMinor;
    }

    if(NULL !=  o_ulVersionMajor)
    {
        *o_ulVersionMajor = ulVersionMajor;
    }

exit:

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ParseVersionNumber] Invalid file name %s.\n",
                  i_wszFileName));
    }

    return hr;

}

HRESULT
ParseVersionNumber(IN     LPWSTR i_wszFileName, 
                   IN OUT DWORD* io_pdwMinor,
                   IN OUT DWORD* io_pdwMajor)
/*++

Synopsis: 
    Overloaded version of ParseVersionNumber that will figure out
    i_cchFileNameUntilFirstUnderscore,

Arguments: [i_wszFileName] - filename formatted as blah_major_minor.xml
           [io_pdwMinor] - 
           [io_pdwMajor] - 
           
Return Value: 

--*/
{
    MD_ASSERT(i_wszFileName);
    MD_ASSERT(io_pdwMinor);
    MD_ASSERT(io_pdwMajor);

    ULONG  iNrUnderscoresSeen = 0;
    LPWSTR pEnd               = i_wszFileName + wcslen(i_wszFileName);

    for(; pEnd >= i_wszFileName; pEnd--)
    {
        if(*pEnd == L'_')
        {
            iNrUnderscoresSeen++;
        }
        if(iNrUnderscoresSeen == 2)
        {
            break;
        }
    }

    if(iNrUnderscoresSeen != 2)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    return ParseVersionNumber(
        i_wszFileName,
        (ULONG)(pEnd - i_wszFileName),
        io_pdwMinor,
        io_pdwMajor);
}


HRESULT DeleteHistoryFile(LPWSTR  i_wszHistroyFileDir,
                          ULONG   i_cchHistoryFileDir,
                          LPWSTR  i_wszFileNameWithoutPathWithoutExtension,
                          ULONG   i_cchFileNameWithoutPathWithoutExtension,
                          LPWSTR  i_wszFileNameExtension,
                          ULONG   i_cchFileNameExtension,
                          ULONG   i_ulVersionMajor,
                          ULONG   i_ulVersionMinor)
{
    LPWSTR  wszDeleteFileName = NULL;
    HRESULT hr               = S_OK;

    hr = ConstructHistoryFileName(&wszDeleteFileName,
                                  i_wszHistroyFileDir,
                                  i_cchHistoryFileDir,
                                  i_wszFileNameWithoutPathWithoutExtension,
                                  i_cchFileNameWithoutPathWithoutExtension,
                                  i_wszFileNameExtension,
                                  i_cchFileNameExtension,
                                  i_ulVersionMajor,
                                  i_ulVersionMinor);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[DeleteHistoryFile] Unable to cleanup history files. ConstructHistoryFileName failed with hr = 0x%x.\n",
                  hr));
        return hr;          
    }

    if(!DeleteFileW(wszDeleteFileName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[DeleteHistoryFile] Unable to cleanup history file: %s. DeleteFileW failed with hr = 0x%x.\n",
                  wszDeleteFileName, hr));

    }

    delete [] wszDeleteFileName;
    wszDeleteFileName = NULL;

    return hr;
}


HRESULT
GetGlobalValue(ISimpleTableRead2*    pISTProperty,
               LPCWSTR               wszName,
               ULONG*                pcbSize,
               LPVOID*               ppVoid)
{

    LPWSTR  wszPath = L".";
    DWORD   dwGroup = eMBProperty_IIS_Global; 

    return GetValue(pISTProperty,
                    wszPath,
                    dwGroup,
                    wszName,
                    pcbSize,
                    ppVoid);
}


HRESULT
GetComputerValue(ISimpleTableRead2*    pISTProperty,
                 LPCWSTR               wszName,
                 ULONG*                pcbSize,
                 LPVOID*               ppVoid)
{
    LPWSTR  wszPath = L"/LM";
    DWORD   dwGroup = eMBProperty_IIsComputer; 

    return GetValue(pISTProperty,
                    wszPath,
                    dwGroup,
                    wszName,
                    pcbSize,
                    ppVoid);
}

HRESULT
GetValue(ISimpleTableRead2*    pISTProperty,
         LPCWSTR               wszPath,
         DWORD                 dwGroup,
         LPCWSTR               wszName,
         ULONG*                pcbSize,
         LPVOID*               ppVoid)
{

    HRESULT hr          = S_OK;
    ULONG   iRow        = 0;
    ULONG   iColumn     = iMBProperty_Value;
    LPVOID  aIdentity[] = {(LPVOID)(LPWSTR)wszName,
                           (LPVOID)(LPWSTR)wszPath,
                           &dwGroup};

    *ppVoid = NULL;

    hr = pISTProperty->GetRowIndexByIdentity(NULL,
                                             aIdentity,
                                             &iRow);

    if(E_ST_NOMOREROWS == hr)
    {
        //
        // Perhaps key type was not present and hence it may be custom
        //

        dwGroup = eMBProperty_Custom;

        hr = pISTProperty->GetRowIndexByIdentity(NULL,
                                                 aIdentity,
                                                 &iRow);
		if(E_ST_NOMOREROWS == hr)
		{
			dwGroup = eMBProperty_IIsConfigObject;

			hr = pISTProperty->GetRowIndexByIdentity(NULL,
													 aIdentity,
													 &iRow);

		}
    }

    if(FAILED(hr))
    {
        return hr;
    }

    hr = pISTProperty->GetColumnValues(iRow,
                                       1,
                                       &iColumn,
                                       pcbSize,
                                       (LPVOID*)ppVoid);

    return hr;

}

HRESULT
InitializeIIS6GlobalsToDefaults(ULONG dwPrevSchemaChangeNumber,
                                ULONG dwSchemaChangeNumber,
                                LPSTR pszBackupLocation)
{
    ISimpleTableDispenser2*     pISTDisp           = NULL;
    IMetabaseSchemaCompiler*    pCompiler          = NULL;
    HRESULT                     hr                 = S_OK;

    //
    // This is used to initialize the following global properties to their
    // defaults. Note that these are global properties that were introduced
    // in IIS60. Hence this function needs to be called from ReadAllDataFromBin
    // else these properties will not be initialized during an upgrade scenario
    // ie. from IIS50/51 to IIS60 when you read from a bin file, in the absence
    // of the XML file. It ned to be called from ReadAllDataFromXML as well so
    // that they can be initialized correctly.
    //

    g_dwEnableEditWhileRunning              = 0;
    g_ulHistoryMajorVersionNumber           = 0;
    g_dwEnableHistory                       = TRUE;
    g_dwMaxHistoryFiles                     = MD_COUNT_MAX_HISTORY_FILES;
    g_dwSchemaChangeNumber                  = dwSchemaChangeNumber;
    g_dwLastSchemaChangeNumber              = dwPrevSchemaChangeNumber;

    if(NULL == pszBackupLocation)
    {
        //
        // Initialize the global array containing file handles. The 
        // initialization is done here (one time only) because this if 
        // condition will evaluate one time only during service startup.
        // Other times when this function is invoked is during restore
        // - you can tell when restore is calling by checking  
        // pszBackupLocation which will be non null.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] Initializing global file handle array.\n"));

        for(ULONG i=0; i<cMetabaseFileTypes; i++)
        {
            g_ahMetabaseFile[i] = INVALID_HANDLE_VALUE;
        }

    }

    //
    // No need to initilize dispenser (InitializeSimpleTableDispenser()), 
    // because we now specify USE_CRT=1 in sources, which means that 
    // globals will be initialized.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // Always set the Bin path to point to the metabase directory.
    // Even if ReadAllData* gets called with a different filename during restore,
    // SetBinPath should always be set to the metabase directory
    //

    hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                  (LPVOID*)&pCompiler);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    hr = pCompiler->SetBinPath(g_wszMetabaseDir);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeIIS6GlobalsToDefaults] SetBinPath failed with hr = 0x%x.\n",hr));
        goto exit;
    }

exit:

    if(NULL != pCompiler)
    {
        pCompiler->Release();
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    return hr;

}

HRESULT 
InitializeGlobalsFromXML(ISimpleTableRead2*     pISTProperty,
                         LPWSTR                 wszFileName,
                         IIS_CRYPTO_STORAGE**   ppStorage,
                         LPTSTR                 pszPasswd,
                         BOOL                   bSessionKeyOnly)
{
    HRESULT                     hr                         = S_OK;
    static BOOL                 bInitializedGlobalsFromXML = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA    MBFileAttr;
    FILETIME                    ftTime;
    FILETIME                    fileTime;

    if(bInitializedGlobalsFromXML)
    {
        return S_OK;
    }

    //
    // TODO: Need to read this from the XML file.
    //

    if(!GetFileAttributesExW(wszFileName,
                             GetFileExInfoStandard,
                             &MBFileAttr))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DBGINFOW((DBG_CONTEXT,
                  L"[InitializeGlobalsFromXML] GetFileAttributesExW failed with hr = 0x%x.\n",
                  hr));

        return hr;
    }
    else
    {
        fileTime.dwLowDateTime    = (MBFileAttr.ftLastWriteTime).dwLowDateTime;
        fileTime.dwHighDateTime    = (MBFileAttr.ftLastWriteTime).dwHighDateTime;

        //
        // TODO: Is it sufficient if we only set the root filetime?
        //
        
        ftTime = fileTime;
        g_pboMasterRoot->SetLastChangeTime(&ftTime);
    }    

    //
    // Initialize session key before you read stuff in. 
    //
    
    hr = InitSessionKey(pISTProperty,
                        ppStorage,
                        pszPasswd);
    if(FAILED(hr) || bSessionKeyOnly)
    {
        return hr;
    }

    //
    // Initialize enable edit while running before you read stuff in. 
    //

    InitEditWhileRunning(pISTProperty);

    //
    // Initialize change number before you read stuff in. 
    // TODO: Should we migrate the change number when we migrate from .bin to .xml?
    //

    InitChangeNumber(pISTProperty);

    //
    // Initialize enable history - Should be called after InitEditWhileRunning
    //

    InitEnableHistory(pISTProperty);

    return hr; // Return failure code only if you want to exit.

}


HRESULT
SaveGlobalsToXML(CWriter*            pCWriter,
                 PIIS_CRYPTO_BLOB    pSessionKeyBlob,
                 bool                bSessionKeyOnly)
{

    HRESULT             hr                  = S_OK;
    CLocationWriter*    pCLocationWriter    = NULL;
    LPWSTR              wszGlobalLocation   = L".";
    LPWSTR              wszKeyType          = L"IIS_Global";
    DWORD               dwIdentifier;
    DWORD               dwDataType;
    DWORD               dwAttributes;
    DWORD                dwNumber;
    DWORD               dwUserType          = IIS_MD_UT_SERVER;

    hr = pCWriter->GetLocationWriter(&pCLocationWriter,
                                     wszGlobalLocation);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] GetLocationWriter failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }

    //
    // TODO: Remove after debugging
    //

    DBGINFOW((DBG_CONTEXT,
              L"[WriteLocation] KeyType: %s Location: %s.\n",wszKeyType, wszGlobalLocation));

    hr = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                             METADATA_NO_ATTRIBUTES,
                                             IIS_MD_UT_SERVER,
                                             STRING_METADATA,
                                             (PBYTE)wszKeyType,
                                             (wcslen(wszKeyType)+1)*sizeof(WCHAR)
                                             );

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] InitializeKeyType failed with hr = 0x%x.\n",
                  hr));
        goto exit;
    }

    if(!bSessionKeyOnly)
    {
        //
        // Change Number
        //

        dwIdentifier = MD_GLOBAL_CHANGE_NUMBER;
        dwDataType = DWORD_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_dwSystemChangeNumber,
                                           sizeof(DWORD));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }

        //
        // HistoryMajorVersionNumber
        //

        ComputeNewHistoryVersionNumber();


        dwIdentifier = MD_GLOBAL_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBER;
        dwDataType   = DWORD_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;
        dwNumber     = g_ulHistoryMajorVersionNumber;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&dwNumber,
                                           sizeof(DWORD));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }
    }

    //
    // Add SessionKey
    //

    dwIdentifier = MD_GLOBAL_SESSIONKEY;
    dwDataType = BINARY_METADATA;
    dwAttributes = METADATA_NO_ATTRIBUTES;

    hr = pCLocationWriter->AddProperty(dwIdentifier,
                                       dwAttributes,
                                       dwUserType,
                                       dwDataType,
                                       (PBYTE)pSessionKeyBlob,
                                       IISCryptoGetBlobLength(pSessionKeyBlob));

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                  dwIdentifier, hr));
        goto exit;
    }

    if(!bSessionKeyOnly)
    {

        //
        // Add XML Schema timestamp
        //

        dwIdentifier = MD_GLOBAL_XMLSCHEMATIMESTAMP;
        dwDataType   = BINARY_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_XMLSchemaFileTimeStamp,
                                           sizeof(FILETIME));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }

        //
        // Add XML Schema timestamp
        //

        dwIdentifier = MD_GLOBAL_BINSCHEMATIMESTAMP;
        dwDataType   = BINARY_METADATA;
        dwAttributes = METADATA_NO_ATTRIBUTES;

        hr = pCLocationWriter->AddProperty(dwIdentifier,
                                           dwAttributes,
                                           dwUserType,
                                           dwDataType,
                                           (PBYTE)&g_BINSchemaFileTimeStamp,
                                           sizeof(FILETIME));

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[SaveGlobalsToXML] AddProperty for ID: %d failed with hr = 0x%x.\n",
                      dwIdentifier, hr));
            goto exit;
        }
    }

    hr = pCLocationWriter->WriteLocation(TRUE);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[SaveGlobalsToXML] WriteLocation failed with hr = 0x%x.\n", 
                  hr));
        goto exit;
    }

exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }

    return hr;
}

//
// Added by Mohit (10/00)
//

//********** Utilities **********//

HRESULT
RemoveLastPartOfPath(
        IN OUT LPWSTR io_wszPath,
        IN     int    i_iLen)
/*++

Routine Description:

    Removes last part of absolute path.
    Ex: "/LM/w3svc/" -> "/LM/"
        "/LM/w3svc"  -> "/LM/"
        "/LM"        -> "/"
        "/"          -> "/"

Arguments:

    wszPath       - The absolute path (null terminated).

    iLen          - The length of the string in chars
                    (not including null termination)

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_INVALID_NAME

Notes:

--*/
{
    MD_ASSERT(io_wszPath != NULL);

    bool bCharSeen = false;
    HRESULT hr = RETURNCODETOHRESULT(ERROR_INVALID_NAME);

    for(int i = i_iLen-1; i>=0; i--) 
    {
        if(io_wszPath[i] == MD_PATH_DELIMETERW)
        {
            hr = RETURNCODETOHRESULT(ERROR_SUCCESS);
            if(bCharSeen)
                break;
        }
        else
        {
            bCharSeen = true;
        }
        io_wszPath[i] = L'\0';
    }

    if(io_wszPath[0] == L'\0' && i_iLen > 0) 
    {
        io_wszPath[0] = MD_PATH_DELIMETERW;
        io_wszPath[1] = L'\0';
    }

    return hr;
}

HRESULT 
GetMostRecentHistoryFile(
    LPCWSTR i_wszPattern,
    DWORD*  io_pdwMajor,
    DWORD*  io_pdwMinor)
{
    MD_ASSERT(i_wszPattern != NULL);
    MD_ASSERT(io_pdwMajor  != NULL);
    MD_ASSERT(io_pdwMinor  != NULL);

    HRESULT          hr        = S_OK;
    HANDLE           hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW fdCur;
    WIN32_FIND_DATAW fdMostRecent;

    DWORD            dwMajor = 0;
    DWORD            dwMinor = 0;

    bool             bMatch  = false;

    hFindFile = FindFirstFileW(i_wszPattern, &fdCur);
    if(hFindFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        hr = RETURNCODETOHRESULT(hr);
        // printf("[%s: Line %d] hr=0x%x\n", __FILE__, __LINE__, hr);
        goto exit;
    }

    do
    {
        if( !bMatch ||
            (bMatch && CompareFileTime(&fdCur.ftLastWriteTime, &fdMostRecent.ftLastWriteTime) > 0) )
        {
            hr = ParseVersionNumber(
                fdCur.cFileName, 
                &dwMinor, 
                &dwMajor);
            if(SUCCEEDED(hr))
            {
                bMatch = true;
                memcpy(&fdMostRecent, &fdCur, sizeof(WIN32_FIND_DATA));
            }
            hr = S_OK;
        }
    }
    while(FindNextFileW(hFindFile, &fdCur));

    if(!bMatch)
    {
        hr = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    hr = ParseVersionNumber(
        fdMostRecent.cFileName,
        &dwMinor,
        &dwMajor);
    if(FAILED(hr))
    {
        goto exit;
    }

    *io_pdwMajor = dwMajor;
    *io_pdwMinor = dwMinor;

exit:
    if(hFindFile != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindFile);
    }

    return hr;
}

//******** Meat *********//

HRESULT
SaveInheritedOnly(IN CWriter*             i_pCWriter,
                  IN CMDBaseObject*       i_pboRoot,
                  IN BUFFER*              i_pbufParentPath,
                  IN IIS_CRYPTO_STORAGE*  i_pCryptoStorage,
                  IN PIIS_CRYPTO_BLOB     i_pSessionKeyBlob)
/*++

Routine Description:

    Save a node, either with or w/o inherited properties.

Arguments:

    Root       - The root of the tree to save.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;
    CLocationWriter*  pCLocationWriter = NULL;
    LPWSTR wszKeyType = NULL;
    DWORD dwAttributes = 0;
    DWORD dwUserType = 0;
    DWORD dwDataType = 0;
    DWORD cbData = 0;

    dwParentPathLen = wcslen((LPWSTR)i_pbufParentPath->QueryPtr());
    if (i_pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)i_pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!i_pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)i_pbufParentPath->QueryPtr();
            if(i_pboRoot != g_pboMasterRoot) {
                wcscat(strParentPath, (LPWSTR)i_pboRoot->GetName(TRUE));
                strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
                strParentPath[dwNewParentPathLen - 1] = (WCHAR)L'\0';
            }
            pftTime = i_pboRoot->GetLastChangeTime();

            // TODO: MD_ID_OBJECT
            //       pftFileTIme?


            //
            // Fetch the Location writer.
            //

            hresReturn = i_pCWriter->GetLocationWriter(&pCLocationWriter,
                                                     strParentPath);

            //
            // Figure out the KeyType of this node. 
            //
            for(dwEnumObjectIndex=0,dataAssociatedData=i_pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                dataAssociatedData=i_pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {

                    if(MD_KEY_TYPE == dataAssociatedData->GetIdentifier())
                    {
                        wszKeyType = (LPWSTR)dataAssociatedData->GetData(TRUE);
                        dwAttributes = dataAssociatedData->GetAttributes();
                        dwUserType =  dataAssociatedData->GetUserType();
                        dwDataType =  dataAssociatedData->GetDataType();
                        cbData = dataAssociatedData->GetDataLen(TRUE);
                        break;
                    }
            }

            if(SUCCEEDED(hresReturn))
            {
                /*hresReturn = pCLocationWriter->InitializeKeyType(MD_KEY_TYPE,
                                                                 dwAttributes,
                                                                 dwUserType,
                                                                 dwDataType,
                                                                 (PBYTE)wszKeyType,
                                                                 cbData);*/
                hresReturn = pCLocationWriter->InitializeKeyTypeAsInherited();
            }

            /*for(dwEnumObjectIndex=0,dataAssociatedData=i_pboRoot->EnumInheritableDataObject(dwEnumObjectIndex++, ALL_METADATA, ALL_METADATA);
                (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                dataAssociatedData=i_pboRoot->EnumInheritableDataObject(dwEnumObjectIndex++, ALL_METADATA, ALL_METADATA)) {
                hresReturn = SaveDataObject(dataAssociatedData,
                                            pCLocationWriter,
                                            i_pCryptoStorage,
                                            i_pSessionKeyBlob);
            }*/

            for(dwEnumObjectIndex=0; SUCCEEDED(hresReturn); dwEnumObjectIndex++) {
                CMDBaseObject *pboTemp = NULL;
                DWORD dwTemp = dwEnumObjectIndex;

                dataAssociatedData=
                    i_pboRoot->EnumInheritableDataObject(dwTemp, ALL_METADATA, ALL_METADATA, &pboTemp);

                //
                // No more data
                //
                if(dataAssociatedData == NULL) break;

                //
                // Only save property if it's inherited
                //
                if(pboTemp != i_pboRoot) {
                    hresReturn = SaveDataObject(dataAssociatedData,
                                                pCLocationWriter,
                                                i_pCryptoStorage,
                                                i_pSessionKeyBlob);
                }
            }

            if(SUCCEEDED(hresReturn))
            {
                hresReturn = pCLocationWriter->WriteLocation(TRUE);
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)i_pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)L'\0';
        }
    }

//exit:

    if(NULL != pCLocationWriter)
    {
        delete pCLocationWriter;
        pCLocationWriter = NULL;
    }
    return(hresReturn);
}

HRESULT
SaveSomeData(
         IN BOOL                i_bSaveInherited,
         IN BOOL                i_bSaveNodeOnly,
         IN BOOL                i_bOverwriteFile,
         IN IIS_CRYPTO_STORAGE* i_pCryptoStorage,
         IN PIIS_CRYPTO_BLOB    i_pSessionKeyBlob,
         IN LPCWSTR             i_wszBackupLocation,
         IN METADATA_HANDLE     i_hHandle,
         IN LPCWSTR             i_wszSourcePath,
         IN BOOL                i_bHaveReadSaveSemaphore
         )
/*++

Routine Description:

    Saves some meta data (used by export).

Arguments:

    i_wszSourcePath - This is absolute (not relative to handle).  We need
        it for SaveTree()

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    MD_ASSERT(i_wszBackupLocation != NULL);
    if(!i_bOverwriteFile)
    {
        return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }

    HRESULT         hresReturn         = ERROR_SUCCESS;

    //
    // Stores i_wszSourcePath as unicode (i.e. /LM/w3svc/1)
    // Passed to SaveTree
    //
    BUFFER          bufParentPath;

    //
    // Handle of the source path
    //
    CMDHandle*      phoHandle          = NULL;

    HANDLE          hTempFile          = INVALID_HANDLE_VALUE;
    LPWSTR          wszTempFile        = NULL;
    
    BOOL            bTempFileOpen      = false;
    BOOL            bMRLock            = false;

    if(!i_bHaveReadSaveSemaphore)
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    if(wcschr(i_wszBackupLocation, L'\\') == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_FILE_INVALID);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    g_rMasterResource->Lock(TSRES_LOCK_READ);
    bMRLock = true;
    
    hresReturn = GetUnicodeName(g_strTempFileName->QueryStr(), &wszTempFile);
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // TODO: Investigate if I actually need to check this.
    //
    if(g_bSaveDisallowed)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_SHUTDOWN_IN_PROGRESS);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Write to a temp file first in case there are errors.
    //
    SECURITY_ATTRIBUTES saStorage;

    if (g_psdStorage != NULL) 
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = g_psdStorage;
        saStorage.bInheritHandle = FALSE;
    }

    hTempFile = CreateFileW(
        wszTempFile,
        GENERIC_READ | GENERIC_WRITE,
        0,
        &saStorage,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        0);
    if (hTempFile == INVALID_HANDLE_VALUE) 
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    bTempFileOpen = true;

    //
    // Validate source handle
    //
    phoHandle = GetHandleObject(i_hHandle);
    if(phoHandle == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else if(!phoHandle->IsReadAllowed() && !phoHandle->IsWriteAllowed()) 
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
    }
    else if(phoHandle->IsSchemaHandle())
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

    //
    // Doctor up i_wszSourcePath and put it in pbufParentPath
    //
    int cchSourcePath = wcslen(i_wszSourcePath);
    if( !bufParentPath.Resize( sizeof(WCHAR)*(cchSourcePath+2)) )
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    LPWSTR wszPathNew = (LPWSTR)bufParentPath.QueryPtr();
    if(i_wszSourcePath[0] == L'\0')
    {
        wszPathNew[0] = MD_PATH_DELIMETERW;
        wszPathNew[1] = L'\0';
    }
    else
    {
        bool bLastSlash = false;
        for(int i = 0; i < cchSourcePath; i++)
        {
            wszPathNew[i] = (i_wszSourcePath[i] == MD_ALT_PATH_DELIMETERW) ? 
                MD_PATH_DELIMETERW : i_wszSourcePath[i];
        }
        wszPathNew[i] = L'\0';
    
        hresReturn = RemoveLastPartOfPath((LPWSTR)bufParentPath.QueryPtr(), cchSourcePath);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }
    }

    //
    // Walk thru metabase and actually do the writing
    //
    DBGINFOW((DBG_CONTEXT,
        L"[SaveSchema] Initializing writer with write file: %s bin file: %s.\n", 
        g_wszTempFileName,
        g_pGlobalISTHelper->m_wszBinFileForMeta));

    {
        //
        // Inside {} because we need to call CWriter's destructor to flush the file.
        //
        CWriter writer;
        hresReturn = writer.Initialize(
            wszTempFile,
            g_pGlobalISTHelper,
            hTempFile);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = writer.BeginWrite(eWriter_Metabase);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = SaveGlobalsToXML(
            &writer, 
            i_pSessionKeyBlob, 
            true);      // session key only
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = SaveTree(&writer,
            phoHandle->GetObject(),
            &bufParentPath,
            i_pCryptoStorage,
            i_pSessionKeyBlob,
            !i_bSaveNodeOnly,
            false /* do not save schema node */);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        if(i_bSaveInherited)
        {
            hresReturn = SaveInheritedOnly(&writer,
                phoHandle->GetObject(),
                &bufParentPath,
                i_pCryptoStorage,
                i_pSessionKeyBlob);
        }
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }

        hresReturn = writer.EndWrite(eWriter_Metabase);
        if(FAILED(hresReturn))
        {
            DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
            goto exit;
        }
    }

    g_rMasterResource->Unlock();
    bMRLock = false;

    if(!CloseHandle(hTempFile)) 
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn);
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    bTempFileOpen = false;

    //
    // Temp file created successfully.  Finally, move temp to real
    // Real may be on another machine, so we need to impersonate.
    //
    hresReturn = CoImpersonateClient();
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }
    if(!MoveFileExW(wszTempFile, i_wszBackupLocation, 
                   MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
    {
        hresReturn = GetLastError();
        hresReturn = RETURNCODETOHRESULT(hresReturn);
    }
    CoRevertToSelf();
    if(FAILED(hresReturn))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hresReturn));
        goto exit;
    }

exit:
    if(bMRLock)
    {
        g_rMasterResource->Unlock();
        bMRLock = false;
    }
    if(bTempFileOpen)
    {
        MD_ASSERT(hTempFile != INVALID_HANDLE_VALUE);
        CloseHandle(hTempFile);

        //
        // Only set failure code if we don't already have another failure.
        //
        if(SUCCEEDED(hresReturn))
        {
            hresReturn = GetLastError();
            hresReturn = RETURNCODETOHRESULT(hresReturn);
        }
    }
    if(hTempFile != INVALID_HANDLE_VALUE) 
    {
        DeleteFileW(wszTempFile);
    }
    if(!i_bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    bufParentPath.FreeMemory();

    delete [] wszTempFile;
    wszTempFile = NULL;

    return hresReturn;
}

HRESULT
ReadSomeDataFromXML(
             IN LPSTR            i_pszPasswd,
             IN LPWSTR           i_wszFileName,
             IN LPWSTR           i_wszSourcePath,
             IN LPCWSTR          i_wszKeyType,
             IN DWORD            i_dwMDFlags,
             IN BOOL             i_bHaveReadSaveSemaphore,
             OUT CMDBaseObject** o_ppboNew)
/*++

Routine Description:

    Used by import.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system
                 // TODO: Add error codes,

Notes:

--*/
{
    MD_ASSERT(i_wszKeyType != NULL);
    MD_ASSERT(o_ppboNew    != NULL);

    HRESULT   hr                   = S_OK;
    bool      bImpersonatingClient = false;
    CImporter Importer(i_wszFileName, i_pszPasswd);

    //
    // TODO: Determine if we need this
    //
    if (!i_bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }
    bImpersonatingClient = true;

    hr = Importer.Init();
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }

    hr = Importer.DoIt(i_wszSourcePath, i_wszKeyType, i_dwMDFlags, o_ppboNew);
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "hr=0x%x\n", hr));
        goto exit;
    }

exit:
    if (!i_bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (bImpersonatingClient)
    {
        CoRevertToSelf();
        bImpersonatingClient = false;
    }

    return hr;
}

HRESULT
EnumFiles(IN LPWSTR i_wszPattern,                  
          IN DWORD i_dwMDEnumIndex,
          OUT DWORD *o_pdwMajor,
          OUT DWORD *o_pdwMinor,
          OUT PFILETIME o_pftMDBackupTime)
/*++

Routine Description:

    Given a pattern, will enum the corresponding files, filling in the
    out params.  Used as a helper routine for EnumHistory.

    TODO: Have EnumBackups use this as well to eliminate duplicate code.

Arguments:
    
Return Value:

Notes:

    Out parameters may be set even though the function fails.  Caller should
    deal with this.    

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;

    //
    // TODO: Assert that params are not null.
    //       (This is checked by caller)
    //

    if(i_wszPattern == NULL) {
        hresReturn = E_INVALIDARG;
        return hresReturn;
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Enumerate files
        //
        HANDLE hFile = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATAW wfdFile;
        DWORD dwEnumIndex = (DWORD) -1;
        hFile = FindFirstFileW(i_wszPattern,
                               &wfdFile);
        if (hFile == INVALID_HANDLE_VALUE) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
        }
        else {
            /*if (CheckDigits(wfdFile.cFileName +
                            GetBackupNameLen(wfdFile.cFileName) +
                            (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                dwEnumIndex++;
            }*/
            hresReturn = ParseVersionNumber(wfdFile.cFileName, o_pdwMinor, o_pdwMajor);
            if (SUCCEEDED(hresReturn)) 
            {
                dwEnumIndex++;
            }
            else
            {
                hresReturn = S_OK;
            }
            while (SUCCEEDED(hresReturn) && (dwEnumIndex != i_dwMDEnumIndex)) {
                //
                // Process the remaining files
                //
                if (FindNextFileW(hFile, &wfdFile)) {
                    /*if (CheckDigits(wfdFile.cFileName +
                                    GetBackupNameLen(wfdFile.cFileName) +
                                    (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                        //
                        // One of our files
                        //
                        dwEnumIndex++;
                    }*/
                    if (SUCCEEDED(ParseVersionNumber(wfdFile.cFileName, o_pdwMinor, o_pdwMajor))) {
                        dwEnumIndex++;
                    }
                }
                else {
                    hresReturn = GetLastHResult();
                }
            }
            FindClose(hFile);
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Found the file
            //
            int iLen = wcslen(wfdFile.cFileName);
            if(iLen > MD_BACKUP_MAX_LEN-1) {
                hresReturn = E_INVALIDARG;
            }
            else {
                MD_COPY(o_pftMDBackupTime,
                        &(wfdFile.ftLastWriteTime),
                        sizeof(FILETIME));
            }
        }
        else {
            if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
    }

    return hresReturn;        
}

HRESULT
ReplaceMasterRoot(
    CMDBaseObject* i_pboNew,
    CMDHandle*     i_phoRootHandle)
/*++

Synopsis: 
    Replaces g_pboMasterRoot with a copy of i_pboNew.  The exception is that the
    schema node from g_pboMasterRoot is maintained.

    Caller must have g_rMasterResourceLock(TSRES_LOCK_WRITE)

Arguments: [i_pboNew] - The pbo to become the new root.  Does NOT contain schema
                        schema node.
           [i_phoRootHandle] - An open write handle to the existing root.
           
Return Value: 

--*/
{
    MD_ASSERT(i_pboNew        != NULL);
    MD_ASSERT(i_phoRootHandle != NULL);

    HRESULT        hr        = S_OK;
    BOOL           bChanged  = false;

    //
    // For child nodes
    //
    CMDBaseObject* pboChild  = NULL;
    CMDBaseObject* pboSchema = NULL;

    //
    // For data
    //
    PVOID*         ppvMainDataBuf   = NULL;
    CMDBaseData*   pbdCurrent       = NULL;
    DWORD          dwNumDataObjects = 0;
    DWORD          dwCurrentDataID  = 0;

    //
    // Remove all the data from g_pboMastRoot
    //
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumDataObjects = g_pboMasterRoot->GetAllDataObjects(
        ppvMainDataBuf,
        0,
        ALL_METADATA,
        ALL_METADATA,
        FALSE);
    for (ULONG i = 0; i < dwNumDataObjects ; i++) 
    {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        dwCurrentDataID = pbdCurrent->GetIdentifier();
        MD_REQUIRE(g_pboMasterRoot->RemoveDataObject(pbdCurrent, TRUE) == S_OK);
        i_phoRootHandle->SetChangeData(g_pboMasterRoot, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
    }
    if (dwNumDataObjects > 0) 
    {
        bChanged = true;
    }
    FreeMainDataBuffer(ppvMainDataBuf);

    //
    // Remove all the child data nodes except schema node.
    //
    ULONG idxFirstNonSchema = 0;
    while((pboChild = g_pboMasterRoot->EnumChildObject(idxFirstNonSchema)) != NULL)
    {
        if(_wcsicmp(WSZSCHEMA_KEY_NAME1, (LPWSTR)pboChild->GetName(true)) == 0)
        {
            MD_ASSERT(idxFirstNonSchema == 0);
            idxFirstNonSchema++;
            pboSchema = pboChild;
        }
        else
        {
            bChanged = true;
            MD_REQUIRE(g_pboMasterRoot->RemoveChildObject(pboChild) == S_OK);
            if(i_phoRootHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != S_OK)
            {
                delete(pboChild);
            }
        }
    }
    MD_ASSERT(idxFirstNonSchema <= 1);

    //
    // Do the copying of data and child nodes
    //
    hr = CopyTree(
        i_phoRootHandle,
        g_pboMasterRoot,
        i_pboNew,
        bChanged);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(bChanged)
    {
        g_dwSystemChangeNumber++;
    }
    return hr;
}

HRESULT
CopyMetaObject(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        BOOL bUseSourceHandle,
        CMDBaseObject* pboSourceIn,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    CMDHandle *phoDestHandle, *phoSourceHandle;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL, *pboExisting = NULL, *pboIndex = NULL, *pboNew = NULL, *pboDestParent = NULL;
    LPSTR pszTempPath;
    LPSTR pszRemainingDestPath;
    BOOL bChanged = FALSE;
    WCHAR strName[METADATA_MAX_NAME_LEN];

    if(!bUseSourceHandle)
    {
        MD_ASSERT(pboSourceIn != NULL);
    }

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {

        //
        // check if pszDestPath is a valid parameter (non-NULL)
        //

        if (pszDestPath == NULL) {
            hresReturn = E_INVALIDARG;
        }
        else {

            //
            // Must have access to Dest parent to add it.
            // Make sure that a valid path was specified, ie. handle
            // points to ancestor.
            //
            pszTempPath = pszDestPath;
            SkipPathDelimeter(pszTempPath, bUnicode);
            if(bUseSourceHandle)
            {
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
            }
            if (FAILED(hresReturn)) {
                hresReturn = E_INVALIDARG;
            }
            if (!bMDCopyFlag) {
                //
                // Must have access to source parent to remove it.
                // Make sure that a valid path was specified, ie. handle
                // points to ancestor.
                //
                pszTempPath = pszSourcePath;
                SkipPathDelimeter(pszTempPath, bUnicode);
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
                if (FAILED(hresReturn)) {
                    hresReturn = E_INVALIDARG;
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        if(bUseSourceHandle)
        {
            hresReturn = GetObjectFromPath(pboSource, hMDSourceHandle, 
                (bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE,
                (LPSTR)pszSourcePath, bUnicode);
        }
        else
        {
            pboSource = pboSourceIn;
        }
        if (SUCCEEDED(hresReturn)) {
            //
            // GetObjectFromPath updates path, need both original and remainder
            //
            pszRemainingDestPath = pszDestPath;

            phoDestHandle = GetHandleObject(hMDDestHandle);

            if(phoDestHandle != NULL)
            {
                hresReturn = GetObjectFromPathWithHandle(pboDest, 
                                                         hMDDestHandle,
                                                         phoDestHandle,
                                                         METADATA_PERMISSION_WRITE, 
                                                         (LPSTR)pszRemainingDestPath, 
                                                         bUnicode);
            }
            else
            {
                hresReturn = E_HANDLE;
            }

            if ((SUCCEEDED(hresReturn)) ||
                ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL))) {
                //
                // Make sure dest is not descendant of source
                //
                for (pboIndex = pboDest; pboIndex != NULL; pboIndex = pboIndex->GetParent()) {
                    if (pboIndex == pboSource) {
                        hresReturn = E_INVALIDARG;
                        break;
                    }
                }
            }

            //
            // I don't think we need this call, since we have already called 
            // GetHandleObject Above.
            //
            // phoDestHandle = GetHandleObject(hMDDestHandle);

            if (SUCCEEDED(hresReturn)) {
                //
                // Object already exists
                //
                if (pboDest == pboSource) {
                    //
                    // Copy to self
                    //
                }
                else {
                    MD_ASSERT (phoDestHandle != NULL);
                    if (bMDOverwriteFlag) {
                        if (pboDest->GetName(bUnicode) == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                        else if(pboDest == g_pboMasterRoot) {
                            hresReturn = ReplaceMasterRoot(pboSource, phoDestHandle);
                        }
                        else {
                            pboDestParent = pboDest->GetParent();
                            hresReturn = MakeTreeCopy(pboSource, pboNew, pboDest->GetName(bUnicode), bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                MD_REQUIRE(SUCCEEDED(pboDestParent->RemoveChildObject(pboDest->GetName(bUnicode), bUnicode)));
                                hresReturn = pboDestParent->InsertChildObject(pboNew);
                                if (SUCCEEDED(hresReturn)) {
                                    g_dwSystemChangeNumber++;

                                    INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                                   phoDestHandle,
                                                                   pszDestPath,
                                                                   bUnicode);


                                    if (phoDestHandle->SetChangeData(
                                        pboDest, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                                        delete(pboDest);
                                    }
                                    AddNewChangeData(phoDestHandle, pboNew);
                                }
                                else {
                                    delete (pboNew);
                                    pboDestParent->InsertChildObject(pboDest);
                                }
                            }
                        }
                    }
                    else {
                        //
                        // Object exists at destination and not overwrite.
                        // Add in missing objects and data.
                        //
                        hresReturn = CopyTree(phoDestHandle, pboDest, pboSource, bChanged);
                        if (bChanged) {
                            g_dwSystemChangeNumber++;

                            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                           phoDestHandle,
                                                           pszDestPath,
                                                           bUnicode);
                        }
                    }
                }
            }
            else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL)) {

                //
                // Full destination path doesn't exist, so create it
                //

                hresReturn = MakeTreeCopyWithPath(pboSource,
                                               pboNew,
                                               pszRemainingDestPath,
                                               bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    MD_ASSERT(pboDest != NULL);
                    hresReturn = pboDest->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        g_dwSystemChangeNumber++;
                        INCREMENT_SCHEMA_CHANGE_NUMBER(hMDDestHandle,
                                                       phoDestHandle,
                                                       pszDestPath,
                                                       bUnicode);
                        AddNewChangeData(phoDestHandle, pboNew);
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }

            if ((SUCCEEDED(hresReturn)) && (!bMDCopyFlag)) {
                MD_REQUIRE(SUCCEEDED(pboSource->GetParent()->RemoveChildObject(pboSource)));
                phoSourceHandle = GetHandleObject(hMDSourceHandle);
                MD_ASSERT (phoSourceHandle != NULL);
                if (phoSourceHandle->SetChangeData(pboSource, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboSource);
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

BOOL WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul)
/*++

Synopsis: 
    Converts a WstrToUl.
    We need this because neither swscanf nor atoi indicate error cases correctly.

Arguments: [i_wszSrc]       - The str to be converted
           [i_wcTerminator] - At what char we should stop searching
           [o_pul]          - The result, only set on success.
           
Return Value: 
    BOOL - true if succeeded, false otherwise

--*/
{
    MD_ASSERT(o_pul);
    MD_ASSERT(i_wszSrc);

    static const ULONG  ulMax  = 0xFFFFFFFF;
    ULONG               ulCur  = 0;
    _int64              i64Out = 0;

    for(LPCWSTR pCur = i_wszSrc; *pCur != L'\0' && *pCur != i_wcTerminator; pCur++)
    {
        ulCur = *pCur - L'0';
        if(ulCur > 9)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Invalid char encountered\n"));
            return false;
        }

        i64Out = i64Out*10 + ulCur;
        if(i64Out > ulMax)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Number is too big\n"));
            return false;
        }
    }

    MD_ASSERT(i64Out <= ulMax);
    *o_pul = (ULONG)i64Out;
    return true;
}

BOOL SchemaTreeInTable(ISimpleTableRead2*    i_pISTProperty)
{
    HRESULT     hr           = S_OK;
    DWORD       dwGroup      = eMBProperty_Custom;
    LPWSTR      wszName      = L"AdminACL";
    LPWSTR      wszLocation  = L"/Schema";
    LPVOID      a_Identity[] = {(LPVOID)wszName,
                                (LPVOID)wszLocation,
                                (LPVOID)&dwGroup
    };
    ULONG       iRow         = 0;

    //
    // Assumption here is that AdminACL is always present at /Schema
    // If we find it, we assume that the schema tree is in the table.
    //

    hr = i_pISTProperty->GetRowIndexByIdentity(NULL,
                                               a_Identity,
                                               &iRow);

    DBGINFOW((DBG_CONTEXT,
              L"[SchemaTreeInTable] GetRowIndexByIdentity returned hr=0x%x\n",hr));


    if(FAILED(hr))
    {
        dwGroup = eMBProperty_IIsConfigObject;

        hr = i_pISTProperty->GetRowIndexByIdentity(NULL,
                                                   a_Identity,
                                                   &iRow);

        if(FAILED(hr))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}


HRESULT CompileIfNeeded(LPWSTR  i_wszDataFileName,
                        LPWSTR  i_wszSchemaFileName,
                        BOOL*   o_pbSchemaFileNotFound)
{
    HRESULT                     hr        = S_OK;
    ISimpleTableDispenser2*     pISTDisp  = NULL;
    IMetabaseSchemaCompiler*    pCompiler = NULL;

    //
    // Get a pointer to the compiler to get the bin file name.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                  (LPVOID*)&pCompiler);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    if(-1 != GetFileAttributesW(i_wszSchemaFileName))
    {
        BOOL bMatchTimeStamp = FALSE;

        //
        // Schema file present. Check if it has a corresponding valid bin file.
        //

        *o_pbSchemaFileNotFound = FALSE;

        if(NULL == g_pGlobalISTHelper)
        {
            BOOL bFailIfBinFileAbsent = TRUE;

            hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

            if(SUCCEEDED(hr))
            {
                hr = MatchTimeStamp(i_wszDataFileName,
                                    i_wszSchemaFileName,
                                    g_pGlobalISTHelper->m_wszBinFileForMeta,
                                    &bMatchTimeStamp);

                if(FAILED(hr))
                {
                    goto exit;
                }

                if(bMatchTimeStamp)
                {
                    //
                    // Bin file found and time stamp matched, no need to compile
                    //

                    DBGINFOW((DBG_CONTEXT,
                              L"[CompileIfNeeded] Schema file: %s found. Schema bin file: %s is valid, and its timestamp matches what is stored in data file %s. No compilation reqired.\n",
                              i_wszSchemaFileName,
                              g_pGlobalISTHelper->m_wszBinFileForMeta,
                              g_wszRealFileName));

                    goto exit;
                }
            }           
            else
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Unable to get the the bin file name. (Assuming file is missing or invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
            }
        }
        else
        {
            hr = MatchTimeStamp(i_wszDataFileName,
                                i_wszSchemaFileName,
                                g_pGlobalISTHelper->m_wszBinFileForMeta,
                                &bMatchTimeStamp);

            if(FAILED(hr))
            {
                goto exit;
            }

            if(bMatchTimeStamp)
            {
                //
                // Bin file found and time stamp matched, no need to compile
                //

                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Schema file: %s found. Schema bin file: %s is valid, and its timestamp matches what is stored in data file %s. No compilation reqired.\n",
                          i_wszSchemaFileName,
                          g_pGlobalISTHelper->m_wszBinFileForMeta,
                          g_wszRealFileName));

                goto exit;
            }
        }

        //
        // If you reach here it means that the schema file was found and either
        // a. the bin file was invalid
        // b. the bin file was missing
        // c. the bin file had a timestamp mistmatch
        // Hence try compiling from the schema file.
        //

        DBGINFOW((DBG_CONTEXT,
                  L"[CompileIfNeeded] Compiling from schema file %s\n", i_wszSchemaFileName));

        if(CopyFileW(i_wszSchemaFileName,
                     g_wszSchemaExtensionFile,
                     FALSE))
        {

            //
            // Always release the bin file that you've been using so far before a
            // compile.
            //

            ReleaseGlobalISTHelper();

            hr = pCompiler->Compile(g_wszSchemaExtensionFile,
                                    i_wszSchemaFileName);

            if(SUCCEEDED(hr))
            {
                if(!DeleteFileW(g_wszSchemaExtensionFile))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    DBGINFOW((DBG_CONTEXT,
                              L"[CompileIfNeeded] Compile from schema file: %s succeeded, but cannot delete the extsions file: %s into which it was copied. Delete file failed with hr = 0x%x.\n",
                              i_wszSchemaFileName,
                              g_wszSchemaExtensionFile,
                              hr));

                    hr = S_OK;
                }
                goto exit;
            }

            DBGINFOW((DBG_CONTEXT,
                      L"[CompileIfNeeded] Compile from schema file failed with hr = 0x%x.\n",
                      hr));

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBGINFOW((DBG_CONTEXT,
                      L"[CompileIfNeeded] Unable to copy %s to %s. CopyFile failed with hr = 0x%x.\n",
                      i_wszSchemaFileName,
                      g_wszSchemaExtensionFile,
                      hr));
        }

    }
    else
    {
        *o_pbSchemaFileNotFound = TRUE;
    }

    //
    // Recreate from shipped schema
    //

    DBGINFOW((DBG_CONTEXT,
              L"[CompileIfNeeded] Schema file not found or compile from it failed. Compiling from shipped schema\n"));

    //
    // Always release the bin file that you've been using so far before a
    // compile.
    //

    ReleaseGlobalISTHelper();

    hr = pCompiler->Compile(NULL,
                            i_wszSchemaFileName);

exit:

    if(SUCCEEDED(hr))
    {
        if(NULL == g_pGlobalISTHelper)
        {
            BOOL bFailIfBinFileAbsent = TRUE;

            hr = InitializeGlobalISTHelper(bFailIfBinFileAbsent);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] Unable to get the the bin file name. (Assuming file is invalid). InitializeGlobalISTHelper failed with hr = 0x%x.\n",hr));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = UpdateTimeStamp(i_wszSchemaFileName,
                                 g_pGlobalISTHelper->m_wszBinFileForMeta);

            if(FAILED(hr))
            {
                DBGINFOW((DBG_CONTEXT,
                          L"[CompileIfNeeded] UpdateTimeStamp failed with hr = 0x%x.\n",hr));
            }

        }

    }

    if(NULL != pCompiler)
    {
        pCompiler->Release();
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    return hr;

}

HRESULT MatchTimeStamp(LPWSTR i_wszDataFileName,
                       LPWSTR i_wszSchemaXMLFileName,
                       LPWSTR i_wszSchemaBINFileName,
                       BOOL*  o_bMatchTimeStamp)
{
    HRESULT                   hr                      = S_OK;
    LPWSTR                    wszSchemaXMLTimeStamp   = MD_XML_SCHEMA_TIMESTAMPW;
    LPWSTR                    wszSchemaBINTimeStamp   = MD_BIN_SCHEMA_TIMESTAMPW;
    FILETIME                  XMLSchemaTimeStamp;
    FILETIME                  BINSchemaTimeStamp;
    ULONG                     cbXMLSchemaTimeStamp;
    ULONG                     cbBINSchemaTimeStamp;
    WIN32_FILE_ATTRIBUTE_DATA XMLSchema;
    WIN32_FILE_ATTRIBUTE_DATA BINSchema;

    *o_bMatchTimeStamp = FALSE;

    hr = GetTimeStamp(i_wszDataFileName,
                      wszSchemaXMLTimeStamp,
                      &XMLSchemaTimeStamp);

    if(FAILED(hr))
    {
        if(E_ST_INVALIDTABLE == hr)
        {
            return hr;
        }
        else
        {
            return S_OK;
        }
    }

    if(!GetFileAttributesExW(i_wszSchemaXMLFileName,
                             GetFileExInfoStandard,
                             (LPVOID)&XMLSchema))
    {
        return S_OK;
    }

    if(0 != CompareFileTime(&XMLSchemaTimeStamp,
                            &XMLSchema.ftLastWriteTime))
    {
        return S_OK;
    }

    hr = GetTimeStamp(i_wszDataFileName,
                      wszSchemaBINTimeStamp,
                      &BINSchemaTimeStamp);

    if(FAILED(hr))
    {
        if(E_ST_INVALIDTABLE == hr)
        {
            return hr;
        }
        else
        {
            return S_OK;
        }
    }
                      
    if(!GetFileAttributesExW(i_wszSchemaBINFileName,
                             GetFileExInfoStandard,
                             (LPVOID)&BINSchema))
    {
        return S_OK;
    }

    if(0 != CompareFileTime(&BINSchemaTimeStamp,
                            &BINSchema.ftLastWriteTime))
    {
        return S_OK;
    }

    *o_bMatchTimeStamp = TRUE;

    return S_OK;
}

HRESULT UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                        LPWSTR i_wszSchemaBinFileName)
{
    WIN32_FILE_ATTRIBUTE_DATA XMLSchema;
    WIN32_FILE_ATTRIBUTE_DATA BINSchema;

    if(!GetFileAttributesExW(i_wszSchemaXMLFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)&XMLSchema))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    memcpy(&g_XMLSchemaFileTimeStamp, &(XMLSchema.ftLastWriteTime), sizeof(FILETIME));

    if(!GetFileAttributesExW(i_wszSchemaBinFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)&BINSchema))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    memcpy(&g_BINSchemaFileTimeStamp, &(BINSchema.ftLastWriteTime), sizeof(FILETIME));

    return S_OK;

}

HRESULT ComputeNewHistoryVersionNumber()
{
    ULONG               ulCurrentVersionNumber = g_ulHistoryMajorVersionNumber;
    ULONG               ulNextVersionNumber    = 0;
    WIN32_FIND_DATAW    FileData;    
    HRESULT             hr                     = S_OK;
    HANDLE              hFind                  = INVALID_HANDLE_VALUE;    
    LPWSTR              wszSearchString        = NULL;
    ULONG               i                      = 0;

    //
    // Compute a new version number and make sure that no history files
    // exist with that major version number.
    //

    do
    {
        if(ulCurrentVersionNumber != 0xFFFFFFFF)
        {
            ulNextVersionNumber = ulCurrentVersionNumber + 1;
        }
        else
        {
            ulNextVersionNumber = 0;
        }
    
        if((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL))
        {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }

        hr = ConstructHistoryFileNameWithoutMinorVersion(&wszSearchString,
                                                         NULL,
                                                         g_wszHistoryFileSearchString,
                                                         g_cchHistoryFileSearchString,
                                                         g_wszRealFileNameExtension,
                                                         g_cchRealFileNameExtension,
                                                         ulNextVersionNumber);

        if(FAILED(hr))
        {
            goto exit;
        }

        hFind = FindFirstFileW(wszSearchString, &FileData);

        if(NULL != wszSearchString)
        {
            delete [] wszSearchString;
            wszSearchString = NULL;
        }

        ulCurrentVersionNumber = ulNextVersionNumber;
    }
    while((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL) && (++i < 0xFFFFFFFF));

    g_ulHistoryMajorVersionNumber = ulNextVersionNumber;

exit:

    if((hFind != INVALID_HANDLE_VALUE) && (hFind != NULL))
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return hr;

} // ComputeNewHistoryVersionNumber


/***************************************************************************++

Routine Description:

    Utility function to fetch the timestamp of the file. It maps a view of
    the file and looks for the timestamp

Arguments:

    [in] File name
    [out] Count of bytes for version number
    [out] Version number


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
GetTimeStamp(LPWSTR    i_wszFile,
             LPWSTR    i_wszPropertyName,
             FILETIME* o_FileTime)
{
    HRESULT                 hr                = S_OK;
    ISimpleTableDispenser2* pISTDisp          = NULL;
    ISimpleTableRead2*      pISTProperty      = NULL;
    STQueryCell             QueryCell[2];
    ULONG                   cCell             = sizeof(QueryCell)/sizeof(STQueryCell);
    LPWSTR                  wszGlobalLocation = MD_GLOBAL_LOCATIONW;
    ULONG                   cbFileTime        = sizeof(FILETIME);
    DWORD                   cb                = 0;
    FILETIME*               pFileTime         = NULL;

    //
    // Get only the root location - that where the timestamps are stored.
    //

    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // No need to specify the schema file because we are getting a shipped
    // property from a global location.
    //

    QueryCell[0].pData     = (LPVOID)i_wszFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszFile)+1)*sizeof(WCHAR);
    
    QueryCell[1].pData     = (LPVOID)wszGlobalLocation;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iMBProperty_Location;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszGlobalLocation)+1)*sizeof(WCHAR);

    hr = pISTDisp->GetTable(wszDATABASE_METABASE,
                            wszTABLE_MBProperty,
                            (LPVOID)QueryCell,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID *)&pISTProperty);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] GetTable on %s failed with hr = 0x%x.\n",
                  wszTABLE_MBProperty,
                  hr));

        goto exit;
    }


    //
    // Get the timestamps.
    //

    hr = GetGlobalValue(pISTProperty,
                        i_wszPropertyName,
                        &cb,
                        (LPVOID*)&pFileTime);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] Unable to read %s. GetGlobalValue failed with hr = 0x%x.\n",
                  i_wszPropertyName,
                  hr));

        goto exit;

    }
    else if(cbFileTime != cb)
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetTimeStamp] GetGlobalValue returns incorrect count of bytes %d for %s. Expected %d.\n",
                  cb,
                  i_wszPropertyName,
                  cbFileTime));

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    *o_FileTime = *(FILETIME*)pFileTime;

exit:

    if(NULL != pISTProperty)
    {
        pISTProperty->Release();
        pISTProperty = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Sets the security on the the given file to system and administrators.

Arguments:

    [in] File name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT SetSecurityOnFile(LPWSTR i_wszFileSrc,
                          LPWSTR i_wszFileDest)

{
    DWORD                   dwRes;
    PACL                    pDACL = NULL;
    PSECURITY_DESCRIPTOR    pSD   = NULL;
    HRESULT                 hr    = S_OK;

    //
    // Get the DACL of the original file.
    //

    dwRes = GetNamedSecurityInfoW(i_wszFileSrc,
                                  SE_FILE_OBJECT,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pDACL,
                                  NULL,
                                  &pSD);
    if (dwRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRes);
        DBGINFOW((DBG_CONTEXT,
                  L"[SetSecurityOnFile] Unable to set security on %s. GetNamedSecurityInfo on %s failed with hr = 0x%x\n.", 
                  i_wszFileDest,
                  i_wszFileSrc,
                  hr));
        hr = S_OK;
    }       
    else 
    {
        //
        // Set the DACL of the original file to the copy.
        //

        dwRes = SetNamedSecurityInfoW(i_wszFileDest,
                                      SE_FILE_OBJECT,
                                      DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pDACL,
                                      NULL); 
        if (dwRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwRes);
            DBGINFOW((DBG_CONTEXT,
                      L"[SetSecurityOnFile] Unable to set security on %s. SetNamedSecurityInfo failed with hr = 0x%x\n.", 
                      i_wszFileDest,
                      hr));
            hr = S_OK;
        }
    }

    //
    // Cleanup the security descriptor.
    //

    if (NULL != pSD)
    {
        LocalFree(pSD);
    }

    return hr;

} // SetSecurityOnFile


void ResetMetabaseAttributesIfNeeded(LPTSTR pszMetabaseFile,
                                     BOOL   bUnicode)
{
    DWORD dwRealFileAttributes;
    
    if(bUnicode)
    {
        dwRealFileAttributes = GetFileAttributesW((LPWSTR)pszMetabaseFile);
    }
    else 
    {
        dwRealFileAttributes = GetFileAttributes(pszMetabaseFile);
    }

    if((-1 != dwRealFileAttributes) &&
       (FILE_ATTRIBUTE_READONLY == (dwRealFileAttributes & FILE_ATTRIBUTE_READONLY)))
    {
        DWORD dwRes = 0;

        if(bUnicode)
        {
            dwRes = SetFileAttributesW((LPWSTR)pszMetabaseFile,
                                       FILE_ATTRIBUTE_NORMAL);
        }
        else
        {
            dwRes = SetFileAttributes(pszMetabaseFile,
                                      FILE_ATTRIBUTE_NORMAL);
        }

        if(dwRes)
        {
            LogEvent(g_pEventLog,
                     MD_WARNING_RESETTING_READ_ONLY_ATTRIB,
                     EVENTLOG_WARNING_TYPE,
                     ID_CAT_CAT,
                     S_OK);

        }
        else
        {
            HRESULT hr = GetLastError();
            hr = RETURNCODETOHRESULT(hr);
            DBGINFOW((DBG_CONTEXT,
                      L"[ResetMetabaseAttributesIfNeeded] Unable to reset metabase file attributes. SetFileAttributes failed with hr=0x%x", hr));
        }
    }

} // ResetMetabaseAttributesIfNeeded


//
// The following two functions LockMetabaseFiles and UnlockMetabaseFiles are used to 
// write lock the metabase files when edit while running is disabled and unlock it 
// when edit while running is enabled. This change was necessary for full volume 
// restore to work. Backup vendors have been told that they need not change their  
// scripts for the whistler release. Eg: When they do a full volume restore, 
// they will overwrite metabase.xml and a competing save can overwrite the 
// metabase.xml that has just been restored, thus invalidating the restore. 
// Vendors have been told that if a file is in use, they must use MoveFileEx with
// the delay until reboot option. Hence by write locking the file, their copy will 
// fail and they will be forced to use MoveFileEx with the delay until reboot option
// for the metabase files. Once that happens we're safe because on a reboot we will 
// read from their new files.
//
// Note1: We are going to document that full volume restore is not going to work when
// edit while running is enabled. This is because we do not lock the file. Also note
// that when they transition from edit while running enabled/disable state and vice
// versa, they must always force a flush (SaveAllData) for any of these changes,
// because we look at the enabled/disable value only in SaveAllData
//
// Note2: There is a window where the file will not be write locked. For Eg: When
// we rename metabase.xml.tmp to metabase.xml, we have to unlock the metabase.xml,
// rename it to metabase.xml and relock metabase,xml. Similarly when invoking compile,
// we will have to unlock mbschema.xml invoke compile (that will regenerate mbschema.xml)
// and relock mbschema.xml. But these windows are very small.
//
// Note3: The g_ahMetabaseFile is protected by the read/sve semaphore.
//

HRESULT LockMetabaseFile(LPWSTR             pwszMetabaseFile,
                         eMetabaseFile      eMetabaseFileType,
                         BOOL               bHaveReadSaveSemaphore)
{
    HRESULT hr = S_OK;

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }

    MD_ASSERT(INVALID_HANDLE_VALUE == g_ahMetabaseFile[eMetabaseFileType]);

    g_ahMetabaseFile[eMetabaseFileType] = CreateFileW(pwszMetabaseFile, 
                                                      GENERIC_READ, 
                                                      FILE_SHARE_READ,  
                                                      NULL, 
                                                      OPEN_EXISTING, 
                                                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
                                                      NULL);

    if(INVALID_HANDLE_VALUE == g_ahMetabaseFile[eMetabaseFileType])
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
    }

    if (!bHaveReadSaveSemaphore) 
    {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hr;

}


HRESULT UnlockMetabaseFile(eMetabaseFile      eMetabaseFileType,
                           BOOL               bHaveReadSaveSemaphore)
{
    HRESULT hr = S_OK;

    if(INVALID_HANDLE_VALUE != g_ahMetabaseFile[eMetabaseFileType])
    {
        if (!bHaveReadSaveSemaphore) 
        {
            MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        }
        
        if(!CloseHandle(g_ahMetabaseFile[eMetabaseFileType]))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
        }

        g_ahMetabaseFile[eMetabaseFileType] = INVALID_HANDLE_VALUE;

        if (!bHaveReadSaveSemaphore) 
        {
            MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
        }

    }
    
    return hr;
}

/*
    This is a wrapper function that logs the appropriate event

  //-----------------Columns as Struct---------------   
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;
         WCHAR *     pDescription;
         WCHAR *     pDate;
         WCHAR *     pTime;
         WCHAR *     pSourceModuleName;
         WCHAR *     pMessageString;
         WCHAR *     pCategoryString;
         WCHAR *     pSource;
         ULONG *     pType;
         ULONG *     pCategory;
         WCHAR *     pUser;
         WCHAR *     pComputer;
 unsigned char *     pData;
         ULONG *     pEvent;
         WCHAR *     pString1;
         WCHAR *     pString2;
         WCHAR *     pString3;
         WCHAR *     pString4;
         WCHAR *     pString5;
         ULONG *     pErrorCode;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorSource;
         ULONG *     pOperationType;
         WCHAR *     pTable;
         WCHAR *     pConfigurationSource;
         ULONG *     pRow;
         ULONG *     pColumn;
         ULONG *     pMajorVersion;
         ULONG *     pMinorVersion;
};


*/
HRESULT LogEvent(ICatalogErrorLogger2*  pLogger,
                 DWORD                  dwError,
                 DWORD                  dwErrorType,
                 DWORD                  dwErrorCategory,
                 DWORD                  dwHr,         
                 WCHAR*                 pString1, /* Default = NULL */
                 WCHAR*                 pString2, /* Default = NULL */
                 WCHAR*                 pString3, /* Default = NULL */
                 WCHAR*                 pString4, /* Default = NULL */
                 WCHAR*                 pString5) /* Default = NULL */
{
        static LPCWSTR wszSource = L"IIS Config";
        struct tDETAILEDERRORSRow sErr;
        memset(&sErr, 0, sizeof(struct tDETAILEDERRORSRow ));
        
        sErr.pSource    = (WCHAR*)wszSource;
        sErr.pType      = &dwErrorType;
    sErr.pCategory  = &dwErrorCategory;
        sErr.pEvent     = &dwError;
        sErr.pErrorCode = &dwHr;
        sErr.pString1   = pString1;
        sErr.pString2   = pString2;
        sErr.pString3   = pString3;
        sErr.pString4   = pString4;
        sErr.pString5   = pString5;

        return pLogger->ReportError(BaseVersion_DETAILEDERRORS,
                                    ExtendedVersion_DETAILEDERRORS,
                                    cDETAILEDERRORS_NumberOfColumns,
                                    NULL,
                                    (LPVOID*)&sErr);

}


//
// Given a catalog type, returns the corresponding metabase type.
//

DWORD GetMetabaseType(DWORD             i_dwType,
                                          DWORD         i_dwMetaFlags)
{
        if(i_dwType < INVALID_END_METADATA)
        {
                return i_dwType;  // Already metabase type.
        }

        switch(i_dwType)
        {
                case eCOLUMNMETA_UI4:
                        return DWORD_METADATA;
                case eCOLUMNMETA_BYTES:
                        return BINARY_METADATA;
                case eCOLUMNMETA_WSTR:
                        if(0 != (i_dwMetaFlags & fCOLUMNMETA_MULTISTRING))
                        {
                                return MULTISZ_METADATA;
                        }
                        else if(0 != (i_dwMetaFlags & fCOLUMNMETA_EXPANDSTRING))
                        {
                                return EXPANDSZ_METADATA;
                        }
                        else
                        {
                                return STRING_METADATA;
                        }
                default:
                        MD_ASSERT(0 && "Invalid Type");
                        break;
        }

        return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\sources.inc ===
#   sources
#   Author: Charles E. Grant (cgrant)
#   Date:   19-February-1997
#
#   This file is used for compiling Proxy web server from code
#    for generic web server
#
#   Describes the macros used for building using NT 'build' command
#

TARGETPATH=obj
TARGETTYPE=DYNLINK


INCLUDES=$(IISBASEDIR)\inc;

#
# these are the files that are common between IIS 5.1 & IIS 6.0
#

SOURCES=\
        ..\cbin.cxx     \
        ..\connect.cxx  \
        ..\gbuf.cxx     \
        ..\handle.cxx   \
        ..\loadmd.cxx   \
        ..\memalloc.cxx \
        ..\ptrmap.cxx   \
        ..\registry.cxx \
        ..\security.cxx \
        ..\metabase.rc

TARGETLIBS=\
            $(SDK_LIB_PATH)\user32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib  \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\uuid.lib      \
            $(SDK_LIB_PATH)\kernel32.lib  \
            $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib \
            $(IISBASEDIR)\svcs\lib\$(O)\iiscrypt.lib  \
            $(IISBASEDIR)\svcs\lib\$(O)\icrypt.lib    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\writerglobals.cpp ===
LPCWSTR	g_wszBeginFile					= L"<?xml version =\"1.0\"?>\r\n<configuration xmlns=\"urn:microsoft-catalog:null-placeholder\">\r\n<MBProperty>\r\n";
ULONG	g_cchBeginFile					= wcslen(g_wszBeginFile);
LPCWSTR	g_wszEndFile					= L"</MBProperty>\r\n</configuration>\r\n";
ULONG	g_cchEndFile					= wcslen(g_wszEndFile);
LPCWSTR	g_BeginLocation					= L"<";
ULONG	g_cchBeginLocation				= wcslen(g_BeginLocation);
LPCWSTR	g_Location						= L"\tLocation =\"";
ULONG	g_cchLocation					= wcslen(g_Location);
LPCWSTR	g_EndLocationBegin				= L"</";
ULONG	g_cchEndLocationBegin			= wcslen(g_EndLocationBegin);
LPCWSTR	g_EndLocationEnd				= L">\r\n";
ULONG	g_cchEndLocationEnd				= wcslen(g_EndLocationEnd);
LPCWSTR g_CloseQuoteBraceRtn			= L"\">\r\n";
ULONG	g_cchCloseQuoteBraceRtn			= wcslen(g_CloseQuoteBraceRtn);
LPCWSTR g_Rtn							= L"\r\n";
ULONG	g_cchRtn						= wcslen(g_Rtn);
LPCWSTR g_EqQuote						= L"=\"";
ULONG	g_cchEqQuote					= wcslen(g_EqQuote);
LPCWSTR g_QuoteRtn						= L"\"\r\n";
ULONG	g_cchQuoteRtn					= wcslen(g_QuoteRtn);
LPCWSTR g_TwoTabs						= L"\t\t";
ULONG	g_cchTwoTabs					= wcslen(g_TwoTabs);
LPCWSTR	g_NameEq						= L"\t\tName=\"";
ULONG	g_cchNameEq						= wcslen(g_NameEq);
LPCWSTR	g_IDEq							= L"\t\tID=\"";
ULONG	g_cchIDEq						= wcslen(g_IDEq);
LPCWSTR	g_ValueEq						= L"\t\tValue=\"";
ULONG	g_cchValueEq					= wcslen(g_ValueEq);
LPCWSTR	g_TypeEq						= L"\t\tType=\"";
ULONG	g_cchTypeEq						= wcslen(g_TypeEq);
LPCWSTR	g_UserTypeEq					= L"\t\tUserType=\"";
ULONG	g_cchUserTypeEq					= wcslen(g_UserTypeEq);
LPCWSTR	g_AttributesEq					= L"\t\tAttributes=\"";
ULONG	g_cchAttributesEq				= wcslen(g_AttributesEq);
LPCWSTR	g_BeginGroup					= L"\t<";
ULONG	g_cchBeginGroup					= wcslen(g_BeginGroup);
LPCWSTR	g_EndGroup						= L"\t>\r\n";
ULONG	g_cchEndGroup					= wcslen(g_EndGroup);
LPCWSTR	g_BeginCustomProperty			= L"\t<Custom\r\n";
ULONG	g_cchBeginCustomProperty		= wcslen(g_BeginCustomProperty);
LPCWSTR	g_EndCustomProperty				= L"\t/>\r\n";
ULONG	g_cchEndCustomProperty			= wcslen(g_EndCustomProperty);
LPCWSTR	g_ZeroHex						= L"0x00000000";
ULONG	g_cchZeroHex					= wcslen(g_ZeroHex);
LPCWSTR	g_wszIIsConfigObject			= L"IIsConfigObject";
LPCWSTR g_BeginComment                  = L"<!--";
ULONG   g_cchBeginComment               = wcslen(g_BeginComment);
LPCWSTR g_EndComment                    = L"-->\r\n";
ULONG   g_cchEndComment                 = wcslen(g_EndComment);

WORD    BYTE_ORDER_MASK                 = 0xFEFF;
DWORD	UTF8_SIGNATURE                  = 0x00BFBBEF;

LPWSTR  g_wszByID	                    = L"ByID";
LPWSTR  g_wszByName	                    = L"ByName";
LPWSTR  g_wszByTableAndColumnIndexOnly        = L"ByTableAndColumnIndexOnly";
LPWSTR  g_wszByTableAndColumnIndexAndNameOnly = L"ByTableAndColumnIndexAndNameOnly";
LPWSTR  g_wszByTableAndColumnIndexAndValueOnly = L"ByTableAndColumnIndexAndValueOnly";
LPWSTR  g_wszByTableAndTagNameOnly             = L"ByTableAndTagNameOnly";
LPWSTR  g_wszByTableAndTagIDOnly			   = L"ByTableAndTagIDOnly";
LPWSTR  g_wszUnknownName                = L"UnknownName_";
ULONG   g_cchUnknownName                = wcslen(g_wszUnknownName);
LPWSTR  g_UT_Unknown                    = L"UNKNOWN_UserType";
ULONG   g_cchUT_Unknown                 = wcslen(g_UT_Unknown);
LPWSTR  g_T_Unknown                     = L"Unknown_Type";
LPWSTR  g_wszTrue						= L"TRUE";
ULONG   g_cchTrue                       = wcslen(g_wszTrue);
LPWSTR  g_wszFalse						= L"FALSE";
ULONG   g_cchFalse                      = wcslen(g_wszFalse);
ULONG   g_cchMaxBoolStr					= wcslen(g_wszFalse);

LPCWSTR g_wszHistorySlash              = L"History\\";
ULONG   g_cchHistorySlash			   = wcslen(g_wszHistorySlash);
LPCWSTR g_wszMinorVersionExt			= L"??????????";
ULONG   g_cchMinorVersionExt			= wcslen(g_wszMinorVersionExt);
LPCWSTR g_wszDotExtn					= L".";
ULONG   g_cchDotExtn					= wcslen(g_wszDotExtn);
WCHAR   g_wchBackSlash					= L'\\';
WCHAR   g_wchFwdSlash                   = L'/';
WCHAR   g_wchDot                        = L'.';

ULONG   g_cchTemp                       = 1024;
WCHAR   g_wszTemp[1024];
LPCWSTR g_wszBeginSchema				= L"<?xml version =\"1.0\"?>\r\n<MetaData xmlns=\"x-schema:CatMeta.xms\">\r\n\r\n\t<DatabaseMeta               InternalName =\"METABASE\">\r\n\t\t<ServerWiring           Interceptor  =\"Core_XMLInterceptor\"/>\r\n\t\t<Collection         InternalName =\"MetabaseBaseClass\"    MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\">\r\n\t\t\t<Property       InternalName =\"Location\"                                    Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\r\n\t\t</Collection>\r\n";
ULONG   g_cchBeginSchema                = wcslen(g_wszBeginSchema);
LPCWSTR g_wszEndSchema				    = L"\t</DatabaseMeta>\r\n</MetaData>\r\n";
ULONG   g_cchEndSchema                  = wcslen(g_wszEndSchema);
LPCWSTR g_wszBeginCollection            = L"\t\t<Collection         InternalName =\"";
ULONG   g_cchBeginCollection            = wcslen(g_wszBeginCollection);
LPCWSTR g_wszSchemaGen                  = L"\"  MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\">\r\n";
ULONG   g_cchSchemaGen                  = wcslen(g_wszSchemaGen);
LPCWSTR g_wszInheritsFrom               = L"\"    InheritsPropertiesFrom=\"MetabaseBaseClass\" >\r\n";
ULONG   g_cchInheritsFrom               = wcslen(g_wszInheritsFrom);
LPCWSTR g_wszEndCollection              = L"\t\t</Collection>\r\n";
ULONG   g_cchEndCollection              = wcslen(g_wszEndCollection);
LPCWSTR g_wszBeginPropertyShort         = L"\t\t\t<Property       InheritsPropertiesFrom =\"IIsConfigObject:";
ULONG   g_cchBeginPropertyShort         = wcslen(g_wszBeginPropertyShort);
LPCWSTR g_wszMetaFlagsExEq              = L"\"  MetaFlagsEx=\"";
ULONG   g_cchMetaFlagsExEq              = wcslen(g_wszMetaFlagsExEq);
LPCWSTR g_wszEndPropertyShort           = L"\"/>\r\n";
ULONG   g_cchEndPropertyShort           = wcslen(g_wszEndPropertyShort);
LPCWSTR g_wszBeginPropertyLong          = L"\t\t\t<Property       InternalName =\"";
ULONG   g_cchBeginPropertyLong          = wcslen(g_wszBeginPropertyLong);
LPCWSTR g_wszPropIDEq                   = L"\"\t\t\tID=\"";
ULONG   g_cchPropIDEq                   = wcslen(g_wszPropIDEq);
LPCWSTR g_wszPropTypeEq                 = L"\"\t\t\tType=\"";
ULONG   g_cchPropTypeEq                 = wcslen(g_wszPropTypeEq);
LPCWSTR g_wszPropUserTypeEq             = L"\"\t\t\tUserType=\"";
ULONG   g_cchPropUserTypeEq             = wcslen(g_wszPropUserTypeEq);
LPCWSTR g_wszPropAttributeEq            = L"\"\t\t\tAttributes=\"";
ULONG   g_cchPropAttributeEq            = wcslen(g_wszPropAttributeEq);

LPWSTR  g_wszPropMetaFlagsEq            = L"\"\t\t\tMetaFlags=\"";
ULONG   g_cchPropMetaFlagsEq            = wcslen(g_wszPropMetaFlagsEq);
LPWSTR  g_wszPropMetaFlagsExEq          = L"\"\t\t\tMetaFlagsEx=\"";
ULONG   g_cchPropMetaFlagsExEq          = wcslen(g_wszPropMetaFlagsExEq);
LPWSTR  g_wszPropDefaultEq              = L"\"\t\t\tDefaultValue=\"";
ULONG   g_cchPropDefaultEq              = wcslen(g_wszPropDefaultEq);
LPWSTR  g_wszPropMinValueEq             = L"\"\t\t\tStartingNumber=\"";
ULONG   g_cchPropMinValueEq             = wcslen(g_wszPropMinValueEq);
LPWSTR  g_wszPropMaxValueEq             = L"\"\t\t\tEndingNumber=\"";
ULONG   g_cchPropMaxValueEq             = wcslen(g_wszPropMaxValueEq);
LPWSTR  g_wszEndPropertyLongNoFlag      = L"\"/>\r\n";
ULONG   g_cchEndPropertyLongNoFlag      = wcslen(g_wszEndPropertyLongNoFlag);
LPWSTR  g_wszEndPropertyLongBeforeFlag  = L"\">\r\n";
ULONG   g_cchEndPropertyLongBeforeFlag  = wcslen(g_wszEndPropertyLongBeforeFlag);
LPWSTR  g_wszEndPropertyLongAfterFlag   = L"\t\t\t</Property>\r\n";
ULONG   g_cchEndPropertyLongAfterFlag   = wcslen(g_wszEndPropertyLongAfterFlag);
LPCWSTR g_wszBeginFlag                  = L"\t\t\t\t<Flag       InternalName =\"";
ULONG   g_cchBeginFlag                  = wcslen(g_wszBeginFlag);
LPCWSTR g_wszFlagValueEq                = L"\"\t\tValue=\"";
ULONG   g_cchFlagValueEq                = wcslen(g_wszFlagValueEq);
LPCWSTR g_wszEndFlag                    = L"\"\t/>\r\n";
ULONG   g_cchEndFlag                    = wcslen(g_wszEndFlag);

LPCWSTR g_wszOr                         = L"| ";
ULONG   g_cchOr              			= wcslen(g_wszOr);
LPCWSTR g_wszOrManditory                = L"| MANDATORY";
ULONG   g_cchOrManditory				= wcslen(g_wszOrManditory);
LPCWSTR g_wszFlagIDEq					= L"\"\t\tID=\"";
ULONG   g_cchFlagIDEq			        = wcslen(g_wszFlagIDEq);
LPCWSTR g_wszContainerClassListEq       = L"\"    ContainerClassList=\"";
ULONG   g_cchContainerClassListEq       = wcslen(g_wszContainerClassListEq);

LPCWSTR g_wszSlash										= L"/";
ULONG   g_cchSlash										= wcslen(g_wszSlash);
LPCWSTR g_wszLM 						                = L"LM";
ULONG   g_cchLM								            = wcslen(g_wszLM);
LPCWSTR g_wszSchema								        = L"Schema";
ULONG   g_cchSchema								        = wcslen(g_wszSchema);
LPCWSTR g_wszSlashSchema								= L"/Schema";
ULONG   g_cchSlashSchema								= wcslen(g_wszSlashSchema);
LPCWSTR g_wszSlashSchemaSlashProperties					= L"/Schema/Properties";
ULONG   g_cchSlashSchemaSlashProperties					= wcslen(g_wszSlashSchemaSlashProperties);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashNames		= L"/Schema/Properties/Names";
ULONG   g_cchSlashSchemaSlashPropertiesSlashNames		= wcslen(g_wszSlashSchemaSlashPropertiesSlashNames);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashTypes		= L"/Schema/Properties/Types";
ULONG   g_cchSlashSchemaSlashPropertiesSlashTypes		= wcslen(g_wszSlashSchemaSlashPropertiesSlashTypes);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashDefaults	= L"/Schema/Properties/Defaults";
ULONG   g_cchSlashSchemaSlashPropertiesSlashDefaults	= wcslen(g_wszSlashSchemaSlashPropertiesSlashDefaults);
LPCWSTR g_wszSlashSchemaSlashClasses					= L"/Schema/Classes";
ULONG   g_cchSlashSchemaSlashClasses					= wcslen(g_wszSlashSchemaSlashClasses);
WCHAR*  g_wszEmptyMultisz                               = L"\0\0";
ULONG   g_cchEmptyMultisz								= 2;
WCHAR*  g_wszEmptyWsz		                            = L"";
ULONG   g_cchEmptyWsz									= 1;
LPCWSTR g_wszComma										= L",";
ULONG   g_cchComma										= wcslen(g_wszComma);
LPCWSTR g_wszMultiszSeperator                           = L"\r\n\t\t\t";
ULONG   g_cchMultiszSeperator                           = wcslen(g_wszMultiszSeperator);

LPCWSTR g_aSynIDToWszType []                            ={NULL,
														  L"DWORD",
														  L"STRING",
														  L"EXPANDSZ",
														  L"MULTISZ",
														  L"BINARY",
														  L"BOOL",
														  L"BOOL_BITMASK",
														  L"MIMEMAP",
														  L"IPSECLIST",
														  L"NTACL",
														  L"HTTPERRORS",
														  L"HTTPHEADERS"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\writerglobalhelper.cpp ===
#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "WriterGlobals.cpp"
#include "mddefw.h"
#include "iiscnfg.h"
#include "wchar.h"
#include "pudebug.h"

#define  MAX_FLAG_STRING_CHARS 1024

//
// TODO: Since XML table also uses this, cant we reduce to one definition?
//

static WCHAR * kByteToWchar[256] = 
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static eESCAPE kWcharToEscape[256] = 
{
  /* 00-0F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 10-1F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 20-2F */ eNoESCAPE,            eNoESCAPE,            eESCAPEquote,         eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPEamp,           eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 30-3F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPElt,            eNoESCAPE,            eESCAPEgt,            eNoESCAPE,
  /* 40-4F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 50-5F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 60-6F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 70-7F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE, 
  /* 80-8F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* 90-9F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* A0-AF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* B0-BF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* C0-CF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* D0-DF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* E0-EF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* F0-FF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE
};

#define IsSecureMetadata(id,att) (((DWORD)(att) & METADATA_SECURE) != 0)

/***************************************************************************++

Routine Description:

    Gets the bin file name by querying the compiler. The compiler hands out
    the latest valid bin file. Once we get the bin file name from the complier
    we can assume that it is valid until we call release bin file on it.

Arguments:

    [in, optional] Compiler interface
    [out]          Bin file name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetBinFile(IMetabaseSchemaCompiler*	i_pCompiler,
				   LPWSTR*                  o_wszBinFile)
{
	HRESULT						hr			= S_OK;
	ULONG						cch			= 0;
	ISimpleTableDispenser2*		pISTDisp	= NULL;
	IMetabaseSchemaCompiler*	pCompiler	= i_pCompiler;
	
	*o_wszBinFile = NULL;

	//
	// GetBinFile relies on the fact that SetBinFile has been called at ReadAllData 
	// See InitializeIISGlobalsToDefaults
	//

	if(NULL == i_pCompiler)
	{
		//
		// Get a pointer to the compiler to get the bin file name.
		//

		hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[ReleaseBinFile] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
			goto exit;
		}

		hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
									  (LPVOID*)&pCompiler);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[ReleaseBinFile] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
			goto exit;
		}

	}

	hr = pCompiler->GetBinFileName(NULL,
		                           &cch);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[GetBinFile] Unable to get the count of chars in the bin file name. IMetabaseSchemaCompiler::GetBinFileName failed with hr = 0x%x.\n",hr));
		goto exit;
	}

	*o_wszBinFile = new WCHAR[cch+1];
	if(NULL == *o_wszBinFile)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	hr = pCompiler->GetBinFileName(*o_wszBinFile,
		                           &cch);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				  L"[GetBinFile] Unable to get the bin file name. IMetabaseSchemaCompiler::GetBinFileName failed with hr = 0x%x.\n",hr));
		goto exit;
	}

	//
	// If there is no bin file, GetBinFileName returns a null string i.e. L""
	//

exit:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}

	if((NULL == i_pCompiler) && (NULL != pCompiler))
	{
        //
        // We created it - release it.
        //

		pCompiler->Release();
	}

	if(FAILED(hr) && (NULL != *o_wszBinFile))
	{
		delete [] *o_wszBinFile;
		*o_wszBinFile = NULL;

	}

	return hr;

} // GeBinFile


/***************************************************************************++

Routine Description:

    Releases the bin file name by from the compiler. Once release is called
    on the bin file, the compiler releases locks on it, and is free to clean
    it up and we cannot make the assumption that it will be valid.
    The function also release the bin file name, which we assume has been 
    allocated in GetBinFile

Arguments:

    [in, optional] Compiler interface
    [in,out]       Bin file name

Return Value:

    HRESULT

--***************************************************************************/
void ReleaseBinFile(IMetabaseSchemaCompiler*	i_pCompiler,
					LPWSTR*						io_wszBinFileName)
{
	ISimpleTableDispenser2*		pISTDisp   = NULL;
	IMetabaseSchemaCompiler*	pCompiler  = i_pCompiler;
	HRESULT                     hr         = S_OK; 

	if(NULL == *io_wszBinFileName)
	{
		goto exit;
	}

	if(NULL == i_pCompiler)
	{
		//
		// Get a pointer to the compiler to get the bin file name.
		//

		hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[ReleaseBinFile] GetSimpleTableDispenser failed with hr = 0x%x.\n",hr));
			goto exit;
		}

		hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
									  (LPVOID*)&pCompiler);

		if(FAILED(hr))
		{
			DBGINFOW((DBG_CONTEXT,
					  L"[ReleaseBinFile] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
			goto exit;
		}

	}

	pCompiler->ReleaseBinFileName(*io_wszBinFileName);

exit:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}

	if((NULL != pCompiler) && (NULL == i_pCompiler))
	{
        //
        // We created it - release it.
        //
		pCompiler->Release();
	}

	if(NULL != 	*io_wszBinFileName)
	{
		delete [] 	*io_wszBinFileName;
		*io_wszBinFileName = NULL;
	}

	return;

} // ReleaseBinFile


/***************************************************************************++

Routine Description:

    Convert unsigned long to a sting.

Arguments:

    [in]   ULONG to convert to string
    [out]  New stringised ULONG

Return Value:

    HRESULT

--***************************************************************************/
HRESULT UnsignedLongToNewString(ULONG    i_ul,
                                LPWSTR*  o_wszUl)
{
	WCHAR wszBufferDW[40];

	_ultow(i_ul, wszBufferDW, 10);

	*o_wszUl = new WCHAR[wcslen(wszBufferDW)+1];
	if(NULL == *o_wszUl)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy(*o_wszUl, wszBufferDW);

	return S_OK;

} // UnsignedLongToString


/***************************************************************************++

Routine Description:

    Copy String

Arguments:

    [in]   String to copy
    [out]  New string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT StringToNewString(LPWSTR   i_wsz,
						  ULONG    i_cch,
                          LPWSTR*  o_wsz)
{
    ULONG cb  = (i_cch+1)*sizeof(WCHAR);

    *o_wsz = new WCHAR[i_cch+1];
    if(NULL == *o_wsz)
    {
        return E_OUTOFMEMORY;
    }
	memcpy(*o_wsz, i_wsz, cb);

    return S_OK;

} // StringToNewString


/***************************************************************************++

Routine Description:

    Create a new String and NULL terminate it.

Arguments:

    [in]   Count of chars (assume without null terminator) 
    [out]  New string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT NewString(ULONG    cch,
                  LPWSTR*  o_wsz)
{
	*o_wsz = new WCHAR[cch+1];
	if(NULL == *o_wsz)
	{
		return E_OUTOFMEMORY;
	}
	**o_wsz = L'\0';

	return S_OK;

} // NewString


/***************************************************************************++

Routine Description:

    Reallocate more buffer for the string and copy old contents.

Arguments:

    [in]       Count of chars to grow (assume without null terminator) 
    [in,out]   Current count of chars, gets updated to the new current count.
    [out]      New string with extra allocation

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReAllocateString(ULONG   i_chhToGrow,
                         ULONG*  io_cchCurrent,
						 LPWSTR* io_wsz)
{
	LPWSTR  wszTemp = NULL;
	ULONG   cch     = *io_cchCurrent + i_chhToGrow;
	HRESULT hr      = S_OK;

    hr = NewString(cch,
	               &wszTemp);

	if(FAILED(hr))
	{
	    return hr;
	}

	if(NULL != *io_wsz)
	{
	    wcscpy(wszTemp, *io_wsz);
		delete [] (*io_wsz);
	}

	*io_wsz = wszTemp;
	*io_cchCurrent = cch;

    return S_OK;

} // ReAllocateString


/***************************************************************************++

Routine Description:

    Constructor for CWriterGlobalHelper

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriterGlobalHelper::CWriterGlobalHelper()
{
	m_pISTTagMetaByTableAndColumnIndexAndName	= NULL;
	m_pISTTagMetaByTableAndColumnIndexAndValue  = NULL;
	m_pISTTagMetaByTableAndColumnIndex	        = NULL;
	m_pISTTagMetaByTableAndID                   = NULL;
	m_pISTTagMetaByTableAndName                 = NULL;
	m_pISTColumnMeta				            = NULL;
	m_pISTColumnMetaByTableAndID	            = NULL;
	m_pISTColumnMetaByTableAndName	            = NULL;
	m_pISTTableMetaForMetabaseTables			= NULL;
	m_cColKeyTypeMetaData			            = cCOLUMNMETA_NumberOfColumns;
	m_wszTABLE_IIsConfigObject                  = wszTABLE_IIsConfigObject;
	m_wszTABLE_MBProperty                       = wszTABLE_MBProperty;
	m_iStartRowForAttributes                    = -1;
	m_wszBinFileForMeta				            = NULL;
	m_cchBinFileForMeta                         = 0;
	m_wszIIS_MD_UT_SERVER                       = NULL;
	m_cchIIS_MD_UT_SERVER                       = 0;
	m_wszIIS_MD_UT_FILE                         = NULL;
	m_cchIIS_MD_UT_FILE                         = 0;
	m_wszIIS_MD_UT_WAM                          = NULL;
	m_cchIIS_MD_UT_WAM                          = 0;
	m_wszASP_MD_UT_APP                          = NULL;
	m_cchASP_MD_UT_APP                          = 0;

} // Constructor


/***************************************************************************++

Routine Description:

    Destructor for CWriterGlobalHelper

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriterGlobalHelper::~CWriterGlobalHelper()
{
	if(NULL != m_pISTTagMetaByTableAndColumnIndexAndName)
	{
		m_pISTTagMetaByTableAndColumnIndexAndName->Release();
		m_pISTTagMetaByTableAndColumnIndexAndName = NULL;
	}
	if(NULL != m_pISTTagMetaByTableAndColumnIndexAndValue)
	{
		m_pISTTagMetaByTableAndColumnIndexAndValue->Release();
		m_pISTTagMetaByTableAndColumnIndexAndValue = NULL;
	}
	if(NULL != m_pISTTagMetaByTableAndColumnIndex)
	{
		m_pISTTagMetaByTableAndColumnIndex->Release();
		m_pISTTagMetaByTableAndColumnIndex = NULL;
	}
	if(NULL != m_pISTTagMetaByTableAndID)
	{
		m_pISTTagMetaByTableAndID->Release();
		m_pISTTagMetaByTableAndID = NULL;
	}
	if(NULL != m_pISTTagMetaByTableAndName)
	{
		m_pISTTagMetaByTableAndName->Release();
		m_pISTTagMetaByTableAndName = NULL;
	}
	if(NULL != m_pISTColumnMeta)
	{
		m_pISTColumnMeta->Release();
		m_pISTColumnMeta = NULL;
	}
	if(NULL != m_pISTColumnMetaByTableAndID)
	{
		m_pISTColumnMetaByTableAndID->Release();
		m_pISTColumnMetaByTableAndID = NULL;
	}
	if(NULL != m_pISTColumnMetaByTableAndName)
	{
		m_pISTColumnMetaByTableAndName->Release();
		m_pISTColumnMetaByTableAndName = NULL;
	}
	if(NULL != m_pISTTableMetaForMetabaseTables)
	{
		m_pISTTableMetaForMetabaseTables->Release();
		m_pISTTableMetaForMetabaseTables = NULL;
	}
	if(NULL != m_wszBinFileForMeta)
	{
		ReleaseBinFile(NULL,
			           &m_wszBinFileForMeta);
	}
	if(NULL != m_wszIIS_MD_UT_SERVER)
	{
		delete [] m_wszIIS_MD_UT_SERVER;
		m_wszIIS_MD_UT_SERVER           = NULL;
	}
	m_cchIIS_MD_UT_SERVER               = 0;
	if(NULL != m_wszIIS_MD_UT_FILE)
	{
		delete [] m_wszIIS_MD_UT_FILE;
		m_wszIIS_MD_UT_FILE             = NULL;
	}
	m_cchIIS_MD_UT_FILE                 = 0;
	if(NULL != m_wszIIS_MD_UT_WAM)
	{
		delete [] m_wszIIS_MD_UT_WAM;
		m_wszIIS_MD_UT_WAM              = NULL;
	}
	m_cchIIS_MD_UT_WAM                  = 0;
	if(NULL != m_wszASP_MD_UT_APP)
	{
		delete [] m_wszASP_MD_UT_APP;
		m_wszASP_MD_UT_APP              = NULL;
	}
	m_cchASP_MD_UT_APP                  = 0;

} // Destructor


/***************************************************************************++

Routine Description:

    Initializes the object with all the metatable ISTs that are needed during
    write.

Arguments:

    [in]   Bool indicating if we should fail if the bin file is absent.
           There are some scenarios in which we can tolerate this, and some
           where we dont - hence the distinction.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::InitializeGlobals(BOOL i_bFailIfBinFileAbsent)
{
	ISimpleTableDispenser2*	pISTDisp      = NULL;
	HRESULT                 hr            = S_OK;
	STQueryCell				Query[2];
	ULONG					cCell         = sizeof(Query)/sizeof(STQueryCell);
	ULONG                   iStartRow     = 0;
	DWORD					dwKeyTypeID   = MD_KEY_TYPE;
	ULONG                   aColSearch [] = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG                   cColSearch    = sizeof(aColSearch)/sizeof(ULONG);
	ULONG                   iRow          = 0;
	ULONG                   iCol          = iMBProperty_Attributes;
	LPVOID                  apvSearch[cCOLUMNMETA_NumberOfColumns];
	ULONG                   aColSearchFlags[] = {iTAGMETA_Table,
	                                             iTAGMETA_ColumnIndex
	};
	ULONG                   cColSearchFlags = sizeof(aColSearchFlags)/sizeof(ULONG);
	LPVOID                  apvSearchFlags[cTAGMETA_NumberOfColumns];
	apvSearchFlags[iTAGMETA_ColumnIndex] = (LPVOID)&iCol;

	//
	// Save the bin file name
	//

	hr = GetBinFile(NULL,
					&m_wszBinFileForMeta);

	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT,
				 L"[InitializeGlobals] Unable to get the the bin file name. GetBinFileName failed with hr = 0x%x.\n",
				 hr));
		goto exit;
	}

	if(( i_bFailIfBinFileAbsent)  &&
	   ((NULL == m_wszBinFileForMeta) || (0 == *m_wszBinFileForMeta))
	  )
	{
		DBGINFOW((DBG_CONTEXT,
				 L"[InitializeGlobals] Expected to find a valid schema bin file. GetBinFileName returned a null file name. Bin file is either invalid or not found.\n"));

		hr = HRESULT_FROM_WIN32(ERROR_FILE_INVALID);
		goto exit;
	}

	//
	// Get the dispenser
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Initialize the in file name in the query.
	//

	Query[0].pData     = (LPVOID)m_wszBinFileForMeta;
    Query[0].eOperator = eST_OP_EQUAL;
    Query[0].iCell     = iST_CELL_FILE;
    Query[0].dbType    = DBTYPE_WSTR;
    Query[0].cbSize    = m_cchBinFileForMeta*sizeof(WCHAR);

	//
	// m_pISTTableMetaForMetabaseTables
	// Save pointer to tablemeta for all tables in the metabase database.
	// This is used for fetching tablemeta of a table from the metabase 
	// database, given its internal name.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_COLUMNMETA,
			  g_wszByID,
              m_wszBinFileForMeta));

	Query[1].pData		= (void*)wszDATABASE_METABASE;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iTABLEMETA_Database;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TABLEMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTableMetaForMetabaseTables);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Fetch the internal pointers to relevant table names. This is a perf
	// optimization. When you use internal pointers to strings in 
	// GetRowIndexBySearch, then you avoid a string compare
	//

	hr = GetInternalTableName(pISTDisp,
		                      wszTABLE_IIsConfigObject,
							  &m_wszTABLE_IIsConfigObject);

	if(FAILED(hr))
	{
	    //
	    // TODO: Must we fail? We could log and ignore, it would 
	    // just be slower.

		goto exit;
	}

	hr = GetInternalTableName(pISTDisp,
		                      wszTABLE_MBProperty,
							  &m_wszTABLE_MBProperty);

	if(FAILED(hr))
	{
	    //
	    // TODO: Must we fail? We could log and ignore, it would 
	    // just be slower.

		goto exit;
	}
	
	//
	// m_pISTTagMetaByTableAndColumnIndexAndName
	// Save pointer to TagMeta table with ByTableAndColumnIndexAndName index hint.
	// This is used for fetching tagmeta of a tag, given its tagname, columnindex
	// and table.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_TAGMETA,
			  g_wszByTableAndColumnIndexAndNameOnly,
              m_wszBinFileForMeta));

	Query[1].pData		= (void*)g_wszByTableAndColumnIndexAndNameOnly;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaByTableAndColumnIndexAndName);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTTagMetaByTableAndColumnIndexAndValue
	// Save pointer to TagMeta table with ByTableAndColumnIndexAndValue index hint.
	// This is used for fetching tagmeta of a tag, given its value, columnindex
	// and table.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_TAGMETA,
			  g_wszByTableAndColumnIndexAndValueOnly,
              m_wszBinFileForMeta));


	Query[1].pData		= (void*)g_wszByTableAndColumnIndexAndValueOnly;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaByTableAndColumnIndexAndValue);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTTagMetaByTableAndColumnIndex
	// Save pointer to TagMeta table with ByTableAndColumnIndex index hint.
	// This is used for fetching tagmeta for all tags of a column, given 
	// columnindex and table.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_TAGMETA,
			  g_wszByTableAndColumnIndexOnly,
              m_wszBinFileForMeta));


	Query[1].pData		= (void*)g_wszByTableAndColumnIndexOnly;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaByTableAndColumnIndex);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTTagMetaByTableAndID
	// Save pointer to TagMeta table with ByTableAndColumnIndex index hint.
	// This is used for fetching tagmeta for a tag, given the table and 
	// metabase tag ID. The assumption here is that the tag ID is unique
	// for every tag in a table.
	//

	Query[1].pData		= (void*)g_wszByTableAndTagIDOnly;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaByTableAndID);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTTagMetaByTableAndName
	// Save pointer to TagMeta table with ByTableAndTagName index hint.
	// This is used for fetching tagmeta for a tag, given the table and
	// tag name. The Asumption here is that the tagname is unique
	// for every tag in a table.
	//

	Query[1].pData		= (void*)g_wszByTableAndTagNameOnly;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaByTableAndName);
	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTColumnMeta
	// This is used for:
	// A. Fetching columnmeta of a given table - Using GetRowIndexByIndentity with table name, starting with index 0.
	// B. Getting columnmeta of a given table + column index - Using GetRowIndexByIndentity with table name and index.
	//

	cCell = cCell-1;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_COLUMNMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTColumnMeta);

	cCell = cCell+1;

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTColumnMetaByTableAndID
	// Save pointer to ColumnMeta table with ByTableAndID index hint.
	// This is used for fetching columnmeta of a column, given its metabase id.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_COLUMNMETA,
			  g_wszByID,
              m_wszBinFileForMeta));

	Query[1].pData		= (void*)g_wszByID;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_COLUMNMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTColumnMetaByTableAndID);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// m_pISTColumnMetaByTableAndName
	// Save pointer to ColumnMeta table with ByTableAndName index hint.
	// This is used for fetching columnmeta of a column, given its internal 
	// name and the table to which it belongs.
	//

	DBGINFOW((DBG_CONTEXT,
			  L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n", 
			  wszTABLE_COLUMNMETA,
			  g_wszByID,
              m_wszBinFileForMeta));

	Query[1].pData		= (void*)g_wszByName;
	Query[1].eOperator	= eST_OP_EQUAL;
	Query[1].iCell		= iST_CELL_INDEXHINT;
	Query[1].dbType		= DBTYPE_WSTR;
	Query[1].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_COLUMNMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTColumnMetaByTableAndName);

	if(FAILED(hr))
	{
		goto exit;
	}


	//
	// Save meta information about the KeyType property.
	//

	apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwKeyTypeID;

	hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow, 
		                                                   cColSearch, 
											               aColSearch,
											               NULL, 
											               apvSearch,
											               &iRow);

	if(FAILED(hr))
	{
		goto exit;
	}


	hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
		                                               m_cColKeyTypeMetaData,
										               NULL,
										               NULL,
										               m_apvKeyTypeMetaData);

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Save start row index in tagmeta table for the attributes column 
	// in MBproperty table.
	//

	apvSearchFlags[iTAGMETA_Table] = m_wszTABLE_MBProperty;

	hr = m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow, 
												                 cColSearchFlags, 
												                 aColSearchFlags,
												                 NULL, 
												                 apvSearchFlags,
												                 (ULONG*)&m_iStartRowForAttributes);
	
	if(FAILED(hr))
	{
	    //
	    // TODO: Must we fail? We could log and ignore, it would 
	    // just be slower.

		goto exit;
	}

exit:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}

	return hr;


	
} // CWriterGlobalHelper::InitializeGlobals


/***************************************************************************++

Routine Description:

    This function gets pointers to the internal table names so that it can be 
    used as part of queries later on. The advantage of getting an internal 
    pointer is the fact that Stephen does a pointer comapare instead of
    string compare.

Arguments:

    [in]   Dispenser
    [in]   Table name
    [out]  Internal pointer to table name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetInternalTableName(ISimpleTableDispenser2*  i_pISTDisp,
												  LPCWSTR                  i_wszTableName,
												  LPWSTR*                  o_wszInternalTableName)
{
	HRESULT               hr            = S_OK;
	ULONG                 iCol          = iTABLEMETA_InternalName;
	ULONG                 iRow          = 0;

	if(NULL == m_pISTTableMetaForMetabaseTables)
	{
		return E_INVALIDARG;
	}

	DBGINFOW((DBG_CONTEXT,
			  L"[GetInternalTableName] Reading table: %s from file: %s.\n", 
			  wszTABLE_TABLEMETA,
              m_wszBinFileForMeta));


	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
											                    (LPVOID*)&i_wszTableName,
											                    &iRow);

	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
		                                                   1,
										                   &iCol,
										                   NULL,
										                   (LPVOID*)o_wszInternalTableName);

	if(FAILED(hr))
	{
	    //
	    // TODO: Must we fail? We could log and ignore, it would 
	    // just be slower.

		return hr;
	}

	return hr;

} // CWriterGlobalHelper::GetInternalTableName


/***************************************************************************++

Routine Description:

    This function converts a given flag value to its string representation.
    The flags bits are delimited by | and if we encounter an unknown bit/bits
    we just spit out a stringized ULONG.

    Eg: dwValue == 3  => ACCESS_READ | ACCESS_WRITE
        dwValue == 88 => 88

Arguments:

    [in]   flag numeric value
    [out]  String representation for the flag
    [in]  Meta table name to search for flag meta
    [in]  Meta table column to search for flag meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::FlagToString(DWORD      dwValue,
								          LPWSTR*    pwszData,
									      LPWSTR     wszTable,
									      ULONG      iColFlag)
{

	DWORD	dwAllFlags = 0;
	HRESULT hr         = S_OK;
	ULONG   iStartRow  = 0;
	ULONG   iRow       = 0;
	ULONG   iCol       = 0;
	LPWSTR	wszFlag	   = NULL;

	ULONG   aCol[]     = {iTAGMETA_Value,
					      iTAGMETA_InternalName,
						  iTAGMETA_Table,
						  iTAGMETA_ColumnIndex
				         };
	ULONG   cCol       = sizeof(aCol)/sizeof(ULONG);
	LPVOID  apv[cTAGMETA_NumberOfColumns];
	ULONG   cch        = 0;
	LPVOID  apvIdentity [] = {(LPVOID)wszTable,
							  (LPVOID)&iColFlag
	};
	ULONG   iColFlagMask = iCOLUMNMETA_FlagMask;
	DWORD*  pdwFlagMask = NULL;

	DWORD   dwZero = 0;
	ULONG   aColSearchByValue[] = {iTAGMETA_Table,
							       iTAGMETA_ColumnIndex,
							       iTAGMETA_Value
	};
	ULONG   cColSearchByValue = sizeof(aColSearchByValue)/sizeof(ULONG);
	LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
	apvSearchByValue[iTAGMETA_Table]       = (LPVOID)wszTable;
	apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;
	apvSearchByValue[iTAGMETA_Value]       = (LPVOID)&dwZero;


	//
	// Make one pass and compute all flag values for this property.
	//

	hr = m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
		                                         apvIdentity,
								 			     &iRow);

	if(SUCCEEDED(hr))
	{
		hr = m_pISTColumnMeta->GetColumnValues(iRow,
											   1,
											   &iColFlagMask,
											   NULL,
											   (LPVOID*)&pdwFlagMask);

		if(FAILED(hr))
		{
			return hr;
		}
	}
	else if(E_ST_NOMOREROWS != hr)
	{
		return hr;
	}

	if((E_ST_NOMOREROWS == hr) || 
	   (0 != (dwValue & (~(dwValue & (*pdwFlagMask))))))
	{
		//
		//	There was no mask associated with this property, or there are one
		//  or more unknown bits set. Spit out a regular number.
		//

		return UnsignedLongToNewString(dwValue,
		                               pwszData);

	}
	else if(0 == dwValue)
	{
		//
		// See if there is a flag with 0 as its value.
		//

		hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetRowIndexBySearch(iStartRow, 
																	         cColSearchByValue, 
																			 aColSearchByValue,
																			 NULL, 
																			 apvSearchByValue,
																			 &iRow);

		if(E_ST_NOMOREROWS == hr)
		{
			//
			// There was no flag associated with the value zero. Spit out a 
			// regular number
			//

		    return UnsignedLongToNewString(dwValue,
		                                   pwszData);

		}
		else if(FAILED(hr))
		{
			return hr;
		}
		else
		{
			iCol = iTAGMETA_InternalName;

			hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetColumnValues(iRow,
																		     1,
																			 &iCol,
																			 NULL,
																			 (LPVOID*)&wszFlag);
			if(FAILED(hr))
			{
				return hr;
			}

            return StringToNewString(wszFlag,
				                     wcslen(wszFlag),
			                         pwszData);

		}
	}
	else 
	{
		//
		// Make another pass, and convert flag to string.
		//

		ULONG  cchMaxFlagString  = MAX_FLAG_STRING_CHARS;
		LPWSTR wszExtension      = L" | ";
		ULONG  cchExtension      = wcslen(wszExtension);
		ULONG  cchFlagStringUsed = 0;

        hr = NewString(cchMaxFlagString,
		               pwszData);

		if(FAILED(hr))
		{
            return hr;
		}
		
		hr = GetStartRowIndex(wszTable,
			                  iColFlag,
							  &iStartRow);

		if(FAILED(hr) || (iStartRow == -1))
		{
			return hr;
		}

		for(iRow=iStartRow;;iRow++)
		{
			hr = m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(iRow,
												                     cCol,
															         aCol,
															         NULL,
															         apv);
			if((dwValue  == 0)         ||
			   (E_ST_NOMOREROWS == hr) ||
			   (iColFlag != *(DWORD*)apv[iTAGMETA_ColumnIndex]) ||
			   (0 != wcscmp(wszTable, (LPWSTR)apv[iTAGMETA_Table])) // OK to do case sensitive compare because all callers pass well known table names
			  )
			{
				hr = S_OK;
				break;
			}
			else if(FAILED(hr))
			{
				return hr;
			}

			if(0 != (dwValue & (*(DWORD*)apv[iTAGMETA_Value])))
			{
				ULONG strlen = wcslen((LPWSTR)apv[iTAGMETA_InternalName]);

				if(cchFlagStringUsed + cchExtension + strlen > cchMaxFlagString)
				{
				    hr = ReAllocateString(MAX_FLAG_STRING_CHARS + cchExtension + strlen,
					                      &cchMaxFlagString,
					                      pwszData);

					if(FAILED(hr))
					{
						return hr;
					}

				}

				if(**pwszData != 0)
				{
					wcscat(*pwszData, wszExtension);
					cchFlagStringUsed = cchFlagStringUsed + cchExtension;
				}

				wcscat(*pwszData, (LPWSTR)apv[iTAGMETA_InternalName]);
				cchFlagStringUsed = cchFlagStringUsed + strlen;

                //
				// Clear out that bit
				//

				dwValue = dwValue & (~(*(DWORD*)apv[iTAGMETA_Value]));
			}

		} // End for

	}

	return S_OK;

} // CWriterGlobalHelper::FlagToString


/***************************************************************************++

Routine Description:

    This function converts a given enum value to its string representation.
    If we encounter an unknown bit/bits we just spit out a stringized ULONG.

    Eg: dwValue == 101  => IIS_MD_UT_SERVER
        dwValue == 88 => 88

Arguments:

    [in]   Enum numeric value
    [out]  String representation for the flag
    [in]  Meta table name to search for flag meta
    [in]  Meta table column to search for flag meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::EnumToString(DWORD      dwValue,
								          LPWSTR*    pwszData,
									      LPWSTR     wszTable,
									      ULONG      iColEnum)
{

	HRESULT hr             = S_OK;
	ULONG   iStartRow      = 0;
	ULONG   iRow           = 0;
	ULONG   iColEnumString = iTAGMETA_InternalName;
	LPWSTR  wszEnum        = NULL;
	ULONG   aColSearch[]   = {iTAGMETA_Table,
		                      iTAGMETA_ColumnIndex,
							  iTAGMETA_Value};
	ULONG   cColSearch     = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
    apvSearch[iTAGMETA_Table]       = (LPVOID)wszTable;
    apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColEnum;
	apvSearch[iTAGMETA_Value]       = (LPVOID)&dwValue;
	

	hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetRowIndexBySearch(iStartRow,
		                                                                 cColSearch,
		                                                                 aColSearch,
		                                                                 NULL,
		                                                                 apvSearch,
		                                                                 &iRow);

	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Convert to a number
		//
		WCHAR	wszBufferDW[20];
		_ultow(dwValue, wszBufferDW, 10);
		*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
		if(NULL == *pwszData)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy(*pwszData, wszBufferDW);
		return S_OK;

	}
	else if(FAILED(hr))
	{
		return hr;
	}
	else
	{
		hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetColumnValues(iRow,
														                 1,
														                 &iColEnumString,
														                 NULL,
														                 (LPVOID*)&wszEnum);
		if(FAILED(hr))
		{
			return hr;
		}

		*pwszData = new WCHAR[wcslen(wszEnum)+1];
		if(NULL == *pwszData)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy(*pwszData, wszEnum);
	}

	return S_OK;

} // CWiterGlobalHelper::EnumToString

  
/***************************************************************************++

Routine Description:

    This function converts a given data value to its string representation,
    taking into account the type of the data.   

Arguments:

    [in]   Pointer to data
    [in]   Count of bytes of data
    [in]   Metabase id of the property
    [in]   Type of the property
    [in]   Attibutes of the property
    [out]  String representation of the value. 

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::ToString(PBYTE   pbData,
								      DWORD   cbData,
								      DWORD   dwIdentifier,
								      DWORD   dwDataType,
								      DWORD   dwAttributes,
								      LPWSTR* pwszData)
{
	HRESULT hr              = S_OK;
	ULONG	i				= 0;
	ULONG	j				= 0;
	WCHAR*	wszTemp			= NULL;
	BYTE*	a_Bytes			= NULL;
	WCHAR*	wszMultisz      = NULL;
	ULONG   cMultisz        = 0;
	ULONG   cchMultisz      = 0;
	ULONG   cchBuffer       = 0;
	ULONG   cchSubsz        = 0;
	DWORD	dwValue			= 0;
	WCHAR	wszBufferDW[40];
	WCHAR	wszBufferDWTemp[40];
	
	ULONG   aColSearch[]    = {iCOLUMNMETA_Table,
							   iCOLUMNMETA_ID
						      };
	ULONG   cColSearch      = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cCOLUMNMETA_NumberOfColumns];
	apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwIdentifier; 

	ULONG   iRow            = 0;
	ULONG   iStartRow       = 0;
	LPWSTR  wszEscaped      = NULL;
	ULONG   cchEscaped      = 0;
	BOOL    bEscaped        = FALSE;

	*pwszData = NULL;

	if(NULL == pbData)	
	{
		goto exit;
	}

	if(IsSecureMetadata(dwIdentifier, dwAttributes))
	{
		dwDataType = BINARY_METADATA;
	}

	switch(dwDataType)
	{
		case BINARY_METADATA:

            //
			// Each byte is represented by 2 chars. 
			//

			hr  = NewString(cbData*2,
			                pwszData);

			if(FAILED(hr))
			{
				goto exit;
			}

			wszTemp			= *pwszData;
			a_Bytes			= (BYTE*)(pbData);

			for(i=0; i<cbData; i++)
			{
                wszTemp[0] = kByteToWchar[a_Bytes[i]][0];
                wszTemp[1] = kByteToWchar[a_Bytes[i]][1];
                wszTemp += 2;
			}

			*wszTemp	= 0; // Add the terminating NULL

			break;

		case DWORD_METADATA :

			//
			// TODO: After Stephen supports hex, convert these to hex.
			//

			dwValue = *(DWORD*)(pbData);

			//
			// First check to see if it is a flag or bool type.
			//

			hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow, 
													               cColSearch, 
													               aColSearch,
													               NULL, 
													               apvSearch,
													               &iRow);

			if(SUCCEEDED(hr))
			{
			    ULONG  aCol [] = {iCOLUMNMETA_Index,
				                 iCOLUMNMETA_MetaFlags
							    };
				ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
				LPVOID apv[cCOLUMNMETA_NumberOfColumns];

				hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
									                               cCol,
													               aCol,
													               NULL,
													               apv);

				if(FAILED(hr))
				{
					goto exit;
				}
				
				if(0 != (fCOLUMNMETA_FLAG & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a flag property convert it.
					//

					hr = FlagToString(dwValue,
								      pwszData,
								      m_wszTABLE_IIsConfigObject,
							          *(ULONG*)apv[iCOLUMNMETA_Index]);
	
					goto exit;
				}
				else if(0 != (fCOLUMNMETA_BOOL & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a bool property
					//

					hr = BoolToString(dwValue,
					                  pwszData);

					goto exit;
				}
				
			}
			else if((E_ST_NOMOREROWS != hr) && FAILED(hr))
			{
				goto exit;
			}

			hr = UnsignedLongToNewString(dwValue,
			                             pwszData);

			if(FAILED(hr))
			{
			    goto exit;
			}

			break;

		case MULTISZ_METADATA :

			//
			// Count the number of multisz
			//

			wszMultisz = (WCHAR*)(pbData);
			cchSubsz   = wcslen(wszMultisz);

			hr = EscapeString(wszMultisz,
				              cchSubsz,
							  &bEscaped,
							  &wszEscaped,
							  &cchEscaped);

			if(FAILED(hr))
			{
				goto exit;
			}

			cMultisz++;
			cchMultisz = cchMultisz + cchEscaped;
			wszMultisz = wszMultisz + cchSubsz + 1;

			while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))			
			{

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

			    cchSubsz   = wcslen(wszMultisz);

				hr = EscapeString(wszMultisz,
					              cchSubsz,
								  &bEscaped,
								  &wszEscaped,
								  &cchEscaped);

				if(FAILED(hr))
				{
					goto exit;
				}

				cMultisz++;
				cchMultisz = cchMultisz + cchEscaped;
				wszMultisz = wszMultisz + cchSubsz + 1;
			}

			cchBuffer = cchMultisz + (5*(cMultisz-1)) + 1;    // (5*(cMultisz-1) => \r\n\t\t\t. 

			//
			// Allocate new string
			//

            hr = NewString(cchBuffer,
			               pwszData);

			if(FAILED(hr))
			{
			    goto exit;
			}

			//
			// Create the string
			//

			wszMultisz = (WCHAR*)(pbData);
		    cchSubsz   = wcslen(wszMultisz);
			wszTemp = *pwszData;

			hr = EscapeString(wszMultisz,
				              cchSubsz,
							  &bEscaped,
							  &wszEscaped,
							  &cchEscaped);

			if(FAILED(hr))
			{
				goto exit;
			}

//			wcscat(wszTemp, wszEscaped);
			memcpy(wszTemp, wszEscaped, (cchEscaped*sizeof(WCHAR)));
			wszTemp = wszTemp + cchEscaped;
			*wszTemp = L'\0';
			wszMultisz = wszMultisz + cchSubsz + 1;

			while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))			
			{
//				wcscat(wszTemp, L"\r\n\t\t\t");
				memcpy(wszTemp, g_wszMultiszSeperator, (g_cchMultiszSeperator*sizeof(WCHAR)));
				wszTemp = wszTemp + g_cchMultiszSeperator;
				*wszTemp = L'\0';

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

			    cchSubsz   = wcslen(wszMultisz);

				hr = EscapeString(wszMultisz,
					              cchSubsz,
								  &bEscaped,
								  &wszEscaped,
								  &cchEscaped);

				if(FAILED(hr))
				{
					goto exit;
				}

//				wcscat(wszTemp, wszEscaped);
				memcpy(wszTemp, wszEscaped, (cchEscaped*sizeof(WCHAR)));
				wszTemp = wszTemp + cchEscaped;
				*wszTemp = L'\0';
				wszMultisz = wszMultisz + cchSubsz + 1;
			}

			break;

		case EXPANDSZ_METADATA :
		case STRING_METADATA :

			hr = EscapeString((WCHAR*)pbData,
				              wcslen((WCHAR*)pbData),
							  &bEscaped,
							  &wszEscaped,
							  &cchEscaped);

			if(FAILED(hr))
			{
				goto exit;
			}

            hr = StringToNewString(wszEscaped,
				                   cchEscaped,
			                       pwszData);

			if(FAILED(hr))
			{
				goto exit;
			}

			break;

		default:
			DBGINFOW((DBG_CONTEXT,
					  L"[ToString] Unknown data type %d for ID: %d.\n", 
					  dwDataType,
					  dwIdentifier));
			hr = E_INVALIDARG;
			break;
			
	}

exit:

	if(bEscaped && (NULL != wszEscaped))
	{
		delete [] wszEscaped;
		wszEscaped = NULL;
		bEscaped = FALSE;
	}

	return hr;

} // CWriterGlobalHelper::ToString


/***************************************************************************++

Routine Description:

    This function converts a given boolean its string representation,

Arguments:

    [in]   Bool value
    [out]  String representation of the Bool. 

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::BoolToString(DWORD      dwValue,
                                          LPWSTR*    pwszData)
{
	HRESULT hr = S_OK;

	if(dwValue)
	{
	    hr = StringToNewString(g_wszTrue,
			                   g_cchTrue,
		                       pwszData);
	}
	else
	{
	    hr = StringToNewString(g_wszFalse,
			                   g_cchFalse,
		                       pwszData);
	}

	return hr;

} // CWriterGlobalHelper::BoolToString


/***************************************************************************++

Routine Description:

    Helper funciton that return the start row index in the metatable for
    the flag concerned

Arguments:

    [in]   Table to which the flag property belongs
    [in]   Column index of the flag property
    [out]  Start row index of the flag meta in the metatable for this flag.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetStartRowIndex(LPWSTR    wszTable,
			                                  ULONG     iColFlag,
							                  ULONG*    piStartRow)
{
	HRESULT hr = S_OK;
	ULONG   aColSearch[] = {iTAGMETA_Table,
	                        iTAGMETA_ColumnIndex
						   };
	ULONG   cColSearch = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
	apvSearch[iTAGMETA_Table] = (LPVOID)wszTable;
	apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;

	*piStartRow = 0;

	if((0 == wcscmp(wszTable, m_wszTABLE_MBProperty)) && // OK to do case sensitive compare because all callers pass well known table names
	   (iMBProperty_Attributes == iColFlag))
	{
		*piStartRow = m_iStartRowForAttributes;
	}
	else
	{
		hr = m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(*piStartRow, 
															         cColSearch, 
															         aColSearch,
															         NULL, 
															         apvSearch,
														             piStartRow);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			*piStartRow = -1;
		}
	}

	return hr;

} // CWriterGlobalHelper::GetStartRowIndex


/***************************************************************************++

Routine Description:

    Function that escapes a string according to the following ruules:

    ************************************************************************
    ESCAPING LEGAL XML
    ************************************************************************

    Following characters are legal in XML:
    #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | 
    [#x10000-#x10FFFF] 

    Out of this legal set, following need special escaping:
    Quote         => " => 34 => Escaped as: &quot;	
    Ampersand     => & => 38 => Escaped as: &amp;	
    Less than     => < => 60 => Escaped as: &lt;
    Gretater than => > => 62 => Escaped as: &gt;

    Note there may be chars in the legal set that may appear legal in certain 
	languages and not in others. All such chars are not escaped. We could 
	escape them as hex numbers Eg 0xA as &#x000A, but we do not want to 
	do this because editors may be able to render these chars, when we change 
	the language.
    Following are the hex values of such chars.

    #x9 | #xA | #xD | [#x7F-#xD7FF] | [#xE000-#xFFFD]

    Note we disregard the range [#x10000-#x10FFFF] because it is not 2 bytes

    ************************************************************************
    ESCAPING ILLEGAL XML
    ************************************************************************

    Illegal XML is also escaped in the following manner

    We add 0x10000 to the char value and escape it as hex. the XML 
    interceptor will render these chars correctly. Note that we are using
    the fact unicode chars are not > 0x10000 and hence we can make this 
    assumption.

Arguments:

    [in]   String to be escaped
	[in]   Count of characters in the string
    [out]  Bool indicating if escaping happened
    [out]  Escaped string - If no escaping occured, it will just point to
           the original string. If escaping occured it will point to a newly
           allocated string that the caller needs to free. The caller can 
           use the bool to determine what action he needs to take.
	[out]  Count of characters in the escaped string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::EscapeString(LPCWSTR wszString,
			                              ULONG   cchString,
                                          BOOL*   pbEscaped,
									      LPWSTR* pwszEscaped,
										  ULONG*  pcchEscaped)
{

	ULONG              cchAdditional        = 0;
	HRESULT            hr                   = S_OK;
	WORD               wChar                = 0;
    eESCAPE            eEscapeType          = eNoESCAPE;
	const ULONG        cchLegalCharAsHex    = (sizeof(WCHAR)*2) + 4; // Each byte is represented as 2 WCHARs plus 4 additional escape chars (&#x;)
	WCHAR              wszLegalCharAsHex[cchLegalCharAsHex];			
	const ULONG        cchIllegalCharAsHex  = cchLegalCharAsHex + 1; // illegal xml has an extra char because we are adding 0x10000 to it.
	WCHAR              wszIllegalCharAsHex[cchIllegalCharAsHex];		
	DWORD              dwIllegalChar        = 0;
	static WCHAR       wszQuote[]           = L"&quot;";
	static const ULONG  cchQuote            = (sizeof(wszQuote)/sizeof(WCHAR))-1;
	static WCHAR       wszAmp[]             = L"&amp;";
	static const ULONG  cchAmp              = (sizeof(wszAmp)/sizeof(WCHAR))-1;
	static WCHAR       wszlt[]              = L"&lt;";
	static const ULONG  cchlt               = (sizeof(wszlt)/sizeof(WCHAR))-1;
	static WCHAR       wszgt[]              = L"&gt;";
	static const ULONG  cchgt               = (sizeof(wszgt)/sizeof(WCHAR))-1;

	*pbEscaped = FALSE;

	//
	// Go through each char and compute the addtional chars needed to escape
	//

	for(ULONG i=0; i<cchString; i++)
	{
		eEscapeType = GetEscapeType(wszString[i]);

		switch(eEscapeType)
		{
		case eNoESCAPE:
			break;
		case eESCAPEgt:
			cchAdditional = cchAdditional + cchgt;
			*pbEscaped = TRUE;
			break;
		case eESCAPElt:
			cchAdditional = cchAdditional + cchlt;
			*pbEscaped = TRUE;
			break;
		case eESCAPEquote:
			cchAdditional = cchAdditional + cchQuote;
			*pbEscaped = TRUE;
			break;
		case eESCAPEamp:
			cchAdditional = cchAdditional + cchAmp;
			*pbEscaped = TRUE;
			break;
		case eESCAPEashex:
			cchAdditional = cchAdditional + cchLegalCharAsHex;
			*pbEscaped = TRUE;
			break;
		case eESCAPEillegalxml:
			cchAdditional = cchAdditional + cchIllegalCharAsHex;
			*pbEscaped = TRUE;
			break;
		default:
			return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			break;
		}
	}

	if(*pbEscaped)
	{
		//
		// String needs to be escaped, allocate the extra memory
		//

        hr = NewString(cchString+cchAdditional,
		               pwszEscaped);

		if(FAILED(hr))
		{
		    return hr;
		}

		*pcchEscaped = cchString+cchAdditional;

		//
		// Escape string
		//

		for(ULONG i=0; i<cchString; i++)
		{
			eEscapeType = GetEscapeType(wszString[i]);

			switch(eEscapeType)
			{
			case eNoESCAPE:
			    wcsncat(*pwszEscaped, (WCHAR*)&(wszString[i]), 1);
				break;
			case eESCAPEgt:
			    wcsncat(*pwszEscaped, wszgt, cchgt);
				break;
			case eESCAPElt:
			    wcsncat(*pwszEscaped, wszlt, cchlt);
				break;
			case eESCAPEquote:
			    wcsncat(*pwszEscaped, wszQuote, cchQuote);
				break;
			case eESCAPEamp:
			    wcsncat(*pwszEscaped, wszAmp, cchAmp);
				break;
			case eESCAPEashex:
				_snwprintf(wszLegalCharAsHex, cchLegalCharAsHex, L"&#x%04hX;", wszString[i]);
				wcsncat(*pwszEscaped, (WCHAR*)wszLegalCharAsHex, cchLegalCharAsHex);
				break;
			case eESCAPEillegalxml:
				dwIllegalChar = 0x10000 + wszString[i];
				_snwprintf(wszIllegalCharAsHex, cchIllegalCharAsHex, L"&#x%05X;", dwIllegalChar);
				wcsncat(*pwszEscaped, (WCHAR*)wszIllegalCharAsHex, cchIllegalCharAsHex);
				break;
			default:
				return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				break;
			}
		}

	}
	else
	{
		//
		// String need not be escaped, just pass the string out.
		//

		*pwszEscaped = (LPWSTR)wszString;
		*pcchEscaped = cchString;
	}

	return S_OK;

} // CWriterGlobalHelper::EscapeString


/***************************************************************************++

Routine Description:

    Returns the escape type of a character

Arguments:

    [in]   Char

Return Value:

    Escape type

--***************************************************************************/
eESCAPE CWriterGlobalHelper::GetEscapeType(WCHAR i_wChar)
{
	WORD    wChar       = i_wChar;
	eESCAPE eEscapeType = eNoESCAPE;

	if(wChar <= 0xFF)
	{
		eEscapeType = kWcharToEscape[wChar];
	}
	else if( (wChar <= 0xD7FF) ||
		     ((wChar >= 0xE000) && (wChar <= 0xFFFD))
		   )
	{
		eEscapeType = eNoESCAPE;
	}
	else
	{
		eEscapeType = eESCAPEillegalxml;
	}

	return eEscapeType;

} // CWriterGlobalHelper::GetEscapeType


/***************************************************************************++

Routine Description:

    Returns the user type

Arguments:

    [in]   user type
	[out]  user type
	[out]  count of chars in user type
	[out]  alloced or not

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetUserType(DWORD   i_dwUserType,
				                         LPWSTR* o_pwszUserType,
										 ULONG*  o_cchUserType,
										 BOOL*   o_bAllocedUserType)
{
	HRESULT hr            = S_OK;
	DWORD	iColUserType  = iCOLUMNMETA_UserType;

	*o_bAllocedUserType = FALSE;

	switch(i_dwUserType)
	{

	case IIS_MD_UT_SERVER:

		if(NULL == m_wszIIS_MD_UT_SERVER)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_SERVER,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_SERVER = wcslen(m_wszIIS_MD_UT_SERVER);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_SERVER;
		*o_cchUserType  = m_cchIIS_MD_UT_SERVER;

		break;

	case IIS_MD_UT_FILE:

		if(NULL == m_wszIIS_MD_UT_FILE)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_FILE,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_FILE = wcslen(m_wszIIS_MD_UT_FILE);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_FILE;
		*o_cchUserType  = m_cchIIS_MD_UT_FILE;

		break;

	case IIS_MD_UT_WAM:

		if(NULL == m_wszIIS_MD_UT_WAM)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_WAM,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_WAM = wcslen(m_wszIIS_MD_UT_WAM);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_WAM;
		*o_cchUserType  = m_cchIIS_MD_UT_WAM;

		break;

	case ASP_MD_UT_APP:

		if(NULL == m_wszASP_MD_UT_APP)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszASP_MD_UT_APP,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchASP_MD_UT_APP = wcslen(m_wszASP_MD_UT_APP);
		}

		*o_pwszUserType = m_wszASP_MD_UT_APP;
		*o_cchUserType  = m_cchASP_MD_UT_APP;

		break;

	default:

		hr = EnumToString(i_dwUserType,
				          o_pwszUserType,
			              wszTABLE_COLUMNMETA,
				          iColUserType);
		if(FAILED(hr))
		{
			return hr;
		}

		*o_cchUserType = wcslen(*o_pwszUserType);
		*o_bAllocedUserType = TRUE;

		break;

	}

	return S_OK;

} // CWriterGlobalHelper::GetUserType


/***************************************************************************++

Routine Description:

    Given the property id this routine contructs the name. If the name is not
	found in the schema, it creates a name of the form Unknown_XXXX where XXX
	is the ID.

Arguments:

    [in]   property id
	[out]  name
	[out]  alloced or not

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetPropertyName(ULONG      i_dwPropertyID,
											 LPWSTR*    o_wszName,
											 BOOL*      o_bAlloced)
{
	HRESULT             hr                = S_OK;
	ULONG               iStartRow         = 0;
	ULONG               iRow              = 0;
	ULONG               iColColumnMeta    = iCOLUMNMETA_InternalName;
	LPWSTR              wszUnknownName    = NULL;
	LPWSTR              wszColumnName     = NULL;
	ULONG               aColSearchName[]  = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG               cColSearchName    = sizeof(aColSearchName)/sizeof(ULONG);
	LPVOID              apvSearchName[cCOLUMNMETA_NumberOfColumns];

	apvSearchName[iCOLUMNMETA_Table]      = (LPVOID)m_wszTABLE_IIsConfigObject;
	apvSearchName[iCOLUMNMETA_ID]         = (LPVOID)&i_dwPropertyID;

	*o_wszName = NULL;
	*o_bAlloced = FALSE;

	//
	// Fetch the Name for this ID
	//

	hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow, 
													       cColSearchName, 
													       aColSearchName,
		 										           NULL, 
														   apvSearchName,
														   &iRow);

	if(E_ST_NOMOREROWS == hr)
	{
		hr  = CreateUnknownName(i_dwPropertyID,
								&wszUnknownName);

		if(FAILED(hr))
		{
			goto exit;
		}

		*o_wszName = wszUnknownName;
		*o_bAlloced = TRUE;

	}
	else if(FAILED(hr))
	{
		goto exit;
	}
	else
	{
		hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
												           1,
														   &iColColumnMeta,
														   NULL,
														  (LPVOID*)&wszColumnName);

		if(E_ST_NOMOREROWS == hr)
		{
			hr  = CreateUnknownName(i_dwPropertyID,
									&wszUnknownName);

			if(FAILED(hr))
			{
				goto exit;
			}

			*o_wszName = wszUnknownName;
			*o_bAlloced = TRUE;

		}
		else if(FAILED(hr))
		{
			goto exit;
		}
		else
		{
			*o_wszName = wszColumnName;
		}
	}

exit:

	if(FAILED(hr) && (NULL != wszUnknownName))
	{
		delete [] wszUnknownName;
		wszUnknownName = NULL;
	}

	return hr;

}  // CWriterGlobalHelper::GetPropertyName


/***************************************************************************++
Routine Description:

    This function is invoked when the name for a given property is missing.
    We create a name of the follwoing form: Unknown_NameXXXX

Arguments:

    [in]  ID
    [out] Name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::CreateUnknownName(DWORD    dwID,
										   LPWSTR*	pwszUnknownName)
{
	WCHAR wszID[40];
	ULONG cchID = 0;
	WCHAR* wszEnd = NULL;

	_ultow(dwID, wszID, 10);

	cchID = wcslen(wszID);

	*pwszUnknownName = new WCHAR[cchID+g_cchUnknownName+1];
	if(NULL == *pwszUnknownName)
    {
		return E_OUTOFMEMORY;
    }

	wszEnd = *pwszUnknownName;
	memcpy(wszEnd, g_wszUnknownName, ((g_cchUnknownName+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchUnknownName;
	memcpy(wszEnd, wszID, ((cchID+1)*sizeof(WCHAR)));

	return S_OK;

} // CWriterGlobalHelper::CreateUnknownName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\baseobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Basic Object Class for IIS MetaBase.

Author:

    Michael W. Thomas            20-May-96

Revision History:

--*/

#include <mdcommon.hxx>


CMDBaseObject::CMDBaseObject(
    LPSTR strName,
    LPSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::CMDBaseObject(
    LPWSTR strName,
    LPWSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();  
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::~CMDBaseObject()
/*++

Routine Description:

    Destructor for an object. Deletes all data and recursively deletes
    all child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            DeleteDataObject(pdcIndex->pbdDataObject);
            delete(pdcIndex);
        }
    }

    if (m_phtChildren)
        delete(m_phtChildren);

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        delete(pbocIndex->pboMetaObject);
        delete(pbocIndex);
    }
}



BOOL
CMDBaseObject::SetName(
    LPSTR strName,
    BOOL bUnicode
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

     BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    if (bUnicode)
        fRet = m_strMDName.SafeCopy((LPWSTR)strName);
    else
        fRet = m_strMDName.SafeCopy((LPSTR)strName);

    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



BOOL
CMDBaseObject::SetName(
    LPWSTR strName
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

    BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    fRet = m_strMDName.SafeCopy(strName);
    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



HRESULT
CMDBaseObject::InsertChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Inserts a child object into the list of child objects.

Arguments:

    Child - the object to insert.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME
--*/

{
    MD_ASSERT(pboChild != NULL);
    MD_ASSERT(pboChild->m_bufKey.QuerySize() > 0);

    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER pbocNew = new BASEOBJECT_CONTAINER;

    // Bail if not enough memory.
    if (pbocNew == NULL)
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

    pbocNew->pboMetaObject = pboChild;
    pbocNew->NextPtr = NULL;
    pboChild->SetParent(this);


    hresReturn = AddChildObjectToHash(pboChild,
                                      pbocNew);

    // Attach to the chain at the end (to keep enumeration ordering)
    if (SUCCEEDED(hresReturn))
    {
        if (m_pbocChildHead == NULL)
            m_pbocChildHead = pbocNew;
        else
            m_pbocChildTail->NextPtr = pbocNew;
        m_pbocChildTail = pbocNew;

        m_cbo++;
        SetLastChangeTime();
    }
    else
        delete pbocNew;

    return(hresReturn);
}

CMDBaseObject *
CMDBaseObject::GetChildObject(
    IN OUT LPSTR &strName,
    OUT HRESULT *phresReturn,
    IN BOOL bUnicode
    )
/*++

Routine Description:

    Gets a child object by name. Updates strName to point past the end of the Name if found.

Arguments:

    Name - name of the object. End delimeter can be '\0', '\\', or '/'.

Return Value:

    CBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent = NULL;
    CMDBaseObject *pboReturn = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pchDelimiter = strName;

    // Find the delimiter.  Change to terminate character.
    if (bUnicode)
    {
        LPWSTR pchDelimiterW = (LPWSTR) pchDelimiter;
        WCHAR chW;

        while ((chW = *pchDelimiterW) != MD_ALT_PATH_DELIMETERW &&
                                  chW != MD_PATH_DELIMETERW &&
                                  chW != (WCHAR) '\0')
            {
            pchDelimiterW++;
            }
        pchDelimiter = (LPSTR) pchDelimiterW;
    }
    else
    {
        CHAR chA;

        while ((chA = *(LPSTR) pchDelimiter) != MD_ALT_PATH_DELIMETERA &&
                                         chA != MD_PATH_DELIMETERA &&
                                         chA != (CHAR) '\0')
            {
            (LPSTR) pchDelimiter = CharNextExA(CP_ACP,
                                               (LPSTR) pchDelimiter,
                                               0);
            }
    }

    // Find the child.
    pboReturn = FindChild(strName, DIFF(pchDelimiter-strName), bUnicode, phresReturn);

    // If we found the name, move up the pointer to the delimiter
    if (pboReturn != NULL)
    {
        MD_ASSERT(*phresReturn == ERROR_SUCCESS);

        strName = pchDelimiter;
    }

#if 0    // SAB
    // If we didn't find the name, return the "not found" error.
    else if (*phresReturn == ERROR_SUCCESS)
    {
        *phresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }
#endif

    return(pboReturn);
}



CMDBaseObject *
CMDBaseObject::EnumChildObject(
         IN DWORD dwEnumObjectIndex
         )
/*++

Routine Description:

    Gets a child object by index.

Arguments:

    EnumObjectIndex - The 0 based index of the object to get.

Return Value:

    CMDBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent;
    CMDBaseObject *pboReturn;
    DWORD i;

    for (pbocCurrent = m_pbocChildHead, i=0;
        (pbocCurrent!=NULL) && (i < dwEnumObjectIndex);
        pbocCurrent=pbocCurrent->NextPtr, i++) {
    }
    if (pbocCurrent != NULL) {
        pboReturn = pbocCurrent->pboMetaObject;
    }
    else {
        pboReturn = NULL;
    }
    return (pboReturn);
}


HRESULT
CMDBaseObject::RemoveChildObject(
         IN LPTSTR strName,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (strName != NULL);

    CMDBaseObject*          pboCurrent;
    BASEOBJECT_CONTAINER*   pbocPrev;
    HRESULT hresReturn;

    // Find the object, including the previous container.
    pboCurrent = FindChild(strName,
                           /* Length */ -1,
                           bUnicode,
                           &hresReturn,
                           /* fUseHash */ FALSE,
                           &pbocPrev);

    if (hresReturn == ERROR_SUCCESS)
    {   // Either we found it, or it's not there.  But no errors occurred.
        if (pboCurrent != NULL)
        {   // We found it.
            BASEOBJECT_CONTAINER* pbocCurrent;

            RemoveChildObjectFromHash(pboCurrent);

            // Remove from the container chain, keeping a pointer to the container to delete.
            if (pbocPrev == NULL)
            {
                pbocCurrent = m_pbocChildHead;
                MD_ASSERT(pbocCurrent != NULL);
                m_pbocChildHead = pbocCurrent->NextPtr;
                // If tail pointed to pbocCurrent, then head will become NULL,
                // in which case tail will be ignored.
            }
            else
            {
                pbocCurrent = pbocPrev->NextPtr;
                MD_ASSERT(pbocCurrent != NULL);
                pbocPrev->NextPtr = pbocCurrent->NextPtr;
                if (m_pbocChildTail == pbocCurrent)
                {
                    MD_ASSERT(pbocPrev->NextPtr == NULL);
                    m_pbocChildTail = pbocPrev;
                }
            }

            // Delete the container.  The base object itself is deleted as part of
            // CMDHandle::RemoveNotifications.
            delete pbocCurrent;

            MD_ASSERT(m_cbo != 0);
            m_cbo--;

            SetLastChangeTime();
        }

        // If FindChild() succeeded but didn't find anything, return the error.
        else
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        }
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::AddChildObjectToHash(
         IN CMDBaseObject *pboChild,
         IN BASEOBJECT_CONTAINER* pbocChild
         )
/*++

Routine Description:

    Add child object from the hash table.

Arguments:

    Child       - The object to remove.
    pbocChild   - The container for the child object. If NULL,
                  the child must already be on the child list.
                  This routine will find the child container, and will
                  not check the child list for ERROR_DUP_NAME.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME

--*/
{
    HRESULT hresReturn = NO_ERROR;
    BOOL bCheckForDups = (pbocChild == NULL) ? FALSE : TRUE;

    // Should we create the hash table now?
    if (m_phtChildren == NULL && m_cbo >= cboCreateHashThreashold)
    {   // Time to create hash table
        // Just skip if we can't create table for some reason.

        m_phtChildren = new CChildNodeHashTable;
        if (m_phtChildren != NULL)
        {   // Create successful.  Let's fill this.
            BASEOBJECT_CONTAINER* pboc = m_pbocChildHead;
            while (pboc != NULL)
            {
                LK_RETCODE ret;

                MD_ASSERT(pboc->pboMetaObject != NULL);
                MD_ASSERT(pboc->pboMetaObject->m_bufKey.QuerySize() > 0);

                ret = m_phtChildren->InsertRecord(pboc,
                                                  /* fOverwrite */ FALSE);
                MD_ASSERT(ret == LK_SUCCESS);
                if (ret != LK_SUCCESS)
                {
                    delete m_phtChildren;
                    m_phtChildren = NULL;
                    break;
                }

                pboc = pboc->NextPtr;
            }
        }
    }

    // Use hash table if it exists.
    if (m_phtChildren != NULL)
    {
        LK_RETCODE ret;

        if (pbocChild == NULL) {

            //
            // Need container for insert function.
            // If it came in as NULL, then the node is not
            // really new (ie. rename) and should already be
            // on the list, so find it.
            //


            BASEOBJECT_CONTAINER* pbocIndex = m_pbocChildHead;
            while ((pbocIndex != NULL) && (pbocIndex->pboMetaObject != pboChild)) {
                pbocIndex = pbocIndex->NextPtr;
            }

            DBG_ASSERT((pbocIndex != NULL) && (pbocIndex->pboMetaObject == pboChild));
            pbocChild = pbocIndex;
        }


        // Put in hash table.  This looks for dups.
        ret = m_phtChildren->InsertRecord(pbocChild,
                                         /* fOverwrite */ FALSE);
        if (ret == LK_KEY_EXISTS)
        {
            DBG_ASSERT(!"Duplicate entry in hash table");
            return RETURNCODETOHRESULT(ERROR_DUP_NAME);
        }
        if (ret != LK_SUCCESS)
        {
            MD_ASSERT(ret == LK_SUCCESS);   // Put up debug assert now.
            delete m_phtChildren;
            m_phtChildren = NULL;
            goto NoHashTable;
        }
    }

    // If hash table doesn't exist, check for duplicate by searching chain.
    else
    {
NoHashTable:
        if (m_pbocChildHead != NULL && bCheckForDups)
        {
            LPSTR strChildName;

            // Check for duplicates
            strChildName = pboChild->GetName(/* bUnicode */ TRUE);
            if (strChildName == NULL)
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            else if (FindChild(strChildName,
                              /* Length */ -1,
                              /* bUnicode */ TRUE,
                              &hresReturn,
                              /* fUseHash */ FALSE,
                              NULL) != NULL)
            {
                hresReturn = RETURNCODETOHRESULT(ERROR_DUP_NAME);
            }
        }
    }

    return hresReturn;
}

VOID
CMDBaseObject::RemoveChildObjectFromHash(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the hash table.

Arguments:

    Child       - The object to remove.

Return Value:

    none

--*/
{
    // Delete from the hash table.
    if (m_phtChildren != NULL)
    {
        m_phtChildren->DeleteKey(&pboChild->m_bufKey);

        // Delete the hash table if we've gone below the threashold.
        if (m_cbo <= cboDeleteHashThreashold)
        {
            delete m_phtChildren;
            m_phtChildren = NULL;
        }
    }
}

HRESULT
CMDBaseObject::RemoveChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (pboChild != NULL);

    BASEOBJECT_CONTAINER* pbocCurrent;
    BASEOBJECT_CONTAINER* pbocPrev;
    HRESULT hresReturn;

    // Find the object in the container chain.
    pbocPrev = NULL;
    pbocCurrent = m_pbocChildHead;
    while (pbocCurrent != NULL && pbocCurrent->pboMetaObject != pboChild)
    {
        pbocPrev = pbocCurrent;
        pbocCurrent = pbocCurrent->NextPtr;
    }

    if (pbocCurrent != NULL)
    {    // Found it
        MD_ASSERT (pbocCurrent->pboMetaObject == pboChild);

        RemoveChildObjectFromHash(pboChild);

        // Remove from the container chain.
        if (pbocPrev == NULL)
        {
            m_pbocChildHead = pbocCurrent->NextPtr;
            // If tail pointed to pbocCurrent, then head will become NULL,
            // in which case tail will be ignored.
        }
        else
        {
            pbocPrev->NextPtr = pbocCurrent->NextPtr;
            if (m_pbocChildTail == pbocCurrent)
            {
                MD_ASSERT(pbocPrev->NextPtr == NULL);
                m_pbocChildTail = pbocPrev;
            }
        }

        // Delete it.  Actual base object is deleted as part of
        // CMDHandle::RemoveNotifications.
        delete pbocCurrent;
        hresReturn = ERROR_SUCCESS;

        MD_ASSERT(m_cbo != 0);

        m_cbo--;

        SetLastChangeTime();
    }
    else {
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::InsertDataObject(
         IN CMDBaseData *pbdInsert
         )
/*++

Routine Description:

    Inserts a data object into the list of data objects of that type.

Arguments:

    Data    - The data object to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_INTERNAL_ERROR

Notes:

    Does not check for duplicates. This should be checked by the calling routine.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    MD_ASSERT (pbdInsert != NULL);
    PDATA_CONTAINER *pdcHead;
    PDATA_CONTAINER pdcNew;

    pdcNew = new (DATA_CONTAINER);
    if (pdcNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        pdcHead = &(m_pdcarrayDataHead[pbdInsert->GetDataType()]);
        pdcNew->NextPtr = NULL;
        pdcNew->pbdDataObject = pbdInsert;
        if (*pdcHead == NULL) {
            *pdcHead = pdcNew;
        }
        else {
            //
            // It seems likely that the first paths read in will be the most common
            // paths, so insert at end of list
            //
            PDATA_CONTAINER pdcIndex;
            for (pdcIndex = *pdcHead;
                pdcIndex->NextPtr != NULL;
                pdcIndex = pdcIndex->NextPtr) {
            }
            MD_ASSERT(pdcIndex!=NULL);
            MD_ASSERT(pdcIndex->NextPtr==NULL);
            pdcIndex->NextPtr = pdcNew;
            if ((pbdInsert->GetAttributes() & METADATA_INHERIT) == 0) {
                m_dwNumNonInheritableData++;
            }
        }
    }
    if (SUCCEEDED(hresReturn)) {
        SetLastChangeTime();
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN CMDBaseData *pbdNew
         )
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data       - The data to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdNew != NULL);
    CMDBaseData *pbdOld = GetDataObject(pbdNew->GetIdentifier(), METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if (pbdOld == pbdNew) {
        //
        // It's already there, leave it alone.
        //
        hresReturn = ERROR_SUCCESS;
    }
    else {
        //
        // Insert the new first so if there's a problem leave the old.
        //
        hresReturn = InsertDataObject(pbdNew);
        if (SUCCEEDED(hresReturn)) {
            pbdNew->IncrementReferenceCount();
            if (pbdOld != NULL) {
                hresReturn = RemoveDataObject(pbdOld, TRUE);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN PMETADATA_RECORD pmdrMDData,
         IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data - The data to set.

        Identifier - The identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdNew;

    CMDBaseData *pbdOld = GetDataObject(pmdrMDData->dwMDIdentifier, METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if ((pbdOld != NULL) &&
        ((pbdOld->GetAttributes() & METADATA_SECURE) != 0) &&
        ((pmdrMDData->dwMDAttributes & METADATA_SECURE) == 0)) {
        hresReturn = MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE;
    }
    else {

        pbdNew = MakeDataObject(pmdrMDData, bUnicode);

        if (pbdNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (pbdOld == pbdNew) {
                //
                // It's already there, just correct the ref count,
                // which MakeDataObject incremented.
                //
                DeleteDataObject(pbdNew);
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = InsertDataObject(pbdNew);
                if (FAILED(hresReturn)) {
                    DeleteDataObject(pbdNew);
                    pbdNew = NULL;
                }
                else {
                    if (pbdOld!=NULL) {
                        //
                        // Data exists with same name.
                        // Need to delete old data.
                        //
                        hresReturn = RemoveDataObject(pbdOld, TRUE);
                        MD_ASSERT(SUCCEEDED(hresReturn));
                    }
                }
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::RemoveDataObject(
         IN CMDBaseData *pbdRemove,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Remove      - The data object to remove.

    Delete      - If true, the object is deleted.

Return Value:

    BOOL        - TRUE if the data was successfully removed.
                  FALSE if the data object is not associated with this metaobject.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdRemove != NULL);
    PDATA_CONTAINER *ppdcHead;
    PDATA_CONTAINER pdcSave;

    ppdcHead = &(m_pdcarrayDataHead[pbdRemove->GetDataType()]);
    if (*ppdcHead == NULL) {
        hresReturn = MD_ERROR_DATA_NOT_FOUND;
    }
    else {
        if ((*ppdcHead)->pbdDataObject == pbdRemove) {
            pdcSave = *ppdcHead;
            *ppdcHead = (*ppdcHead)->NextPtr;
            delete pdcSave;
            hresReturn = ERROR_SUCCESS;
        }
        else {
            PDATA_CONTAINER ppdcIndex;
            for (ppdcIndex = *ppdcHead;
                (ppdcIndex->NextPtr!=NULL) && (ppdcIndex->NextPtr->pbdDataObject!=pbdRemove);
                ppdcIndex=ppdcIndex->NextPtr) {
            }
            if (ppdcIndex->NextPtr==NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                MD_ASSERT(ppdcIndex->NextPtr->pbdDataObject == pbdRemove);
                pdcSave = ppdcIndex->NextPtr;
                ppdcIndex->NextPtr = pdcSave->NextPtr;
                delete (pdcSave);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        if ((pbdRemove->GetAttributes() & METADATA_INHERIT) == 0) {
            m_dwNumNonInheritableData--;
        }
        if (bDelete) {
            DeleteDataObject(pbdRemove);
        }
        SetLastChangeTime();
    }
    return (hresReturn);
}

CMDBaseData *
CMDBaseObject::RemoveDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Name        - The name of the data to remove.

    DataType    - Optional type of the data to remove. If specified, only data of that
                  type will be removed.

    bDelete  - If true, the object is deleted.

Return Value:

    CMDBaseData * - Pointer to the data object removed. If bDelete == TRUE, the pointer will still be
                    returned, but will not be valid.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdRemove;
    pbdRemove=GetDataObject(dwIdentifier, METADATA_NO_ATTRIBUTES, dwDataType);
    if (pbdRemove != NULL) {
        MD_REQUIRE(RemoveDataObject(pbdRemove, bDelete) == ERROR_SUCCESS);
    }
    return(pbdRemove);
}



bool
CMDBaseObject::GenerateKey()
{
    LPSTR       pstr = (LPSTR) m_strMDName.QueryStrW();

    if (pstr == NULL)
        return FALSE;

    return GenerateBufFromStr(pstr,
                              /* cch */ -1,
                              /* fUnicode */ TRUE,
                              &m_bufKey);
}



bool
CMDBaseObject::GenerateBufFromStr(
    IN const char*     pstr,
    IN int             cch,
    IN BOOL            fUnicode,
    OUT CMDKeyBuffer*  pbuf)

/*++

Routine Description:

    Fills the given buffer with the object key based on the given string.

Arguments:

    str         - The string to convert into the key.
    fUnicode    - TRUE if the string is unicode, FALSE if ansi.
    pbuf        - Pointer to the buffer that will contain the new key.

Return Value:

    BOOL        - FALSE if out-of-memory allocating the buffer.

--*/
{
    BUFFER  bufUnicode;     // Use this to hold unicode string if needed.
    int     cchRet;         // Length of actual converted string.

    MD_ASSERT(cch != 0);    // Must either be -1 or a non-null string length.

    // If not unicode, convert to unicode now.
    if (!fUnicode)
    {
        // If we know the size, guess at the unicode size.
        if (cch > 0)
            if (!bufUnicode.Resize(cch*2+50))
                return FALSE;


        // Loop until we have big enough buffer to hold unicode string
        while(TRUE)
        {
            // Buffer length can't be zero, or MultiByteToWideChar() will
            // interpret this by returning "required buffer length" and do
            // no conversion.
            MD_ASSERT(bufUnicode.QuerySize() > 1);

            cchRet = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         pstr,
                                         cch,
                                         (LPWSTR) bufUnicode.QueryPtr(),
                                         bufUnicode.QuerySize()/2);

            // Handle error during conversion.
            if (cchRet == 0)
            {
                // If error wasn't lack of buffer, fail.
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    return FALSE;

                // Otherwise, make the buffer larger and try again.
                /* else */
                    if (!bufUnicode.Resize(bufUnicode.QuerySize()+50))
                        return FALSE;
            }

            // Succeed, continue.
            else
                break;
        }

        // Point to the buffer now.
        pstr = (char *) bufUnicode.QueryPtr();
        cch = cchRet * 2;
    }

    // If we know the length, guess at the destination length.
    if (cch > 0)
    {
        if (!pbuf->Resize(cch))
            return FALSE;
    }

    // Otherwise, reset the length to whatever is allocated.
    else
        pbuf->SyncSize();

    // Loop until we have a buffer large enough.
    while (TRUE)
    {
        // Buffer size can't be 0, because LCMapString will interpret
        // this by returning "required buffer length" and not actually
        // converting the string.
        MD_ASSERT(pbuf->QuerySize() > 0);
        cchRet = LCMapStringW(LOCALE_SYSTEM_DEFAULT,
                             LCMAP_UPPERCASE,
                             (LPWSTR) pstr,
                             (cch < 0) ? cch : cch/2,
                             (LPWSTR) pbuf->QueryPtr(),
                             pbuf->QuerySize()/2);

        // Handle errors
        if (cchRet == 0)
        {
            // If error wasn't lack of buffer, fail.
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                return FALSE;

            // Otherwise, make the buffer larger and try again.
            /* else */
                if (!pbuf->Resize(pbuf->QuerySize() + 50))
                    return FALSE;
        }
        else
            break;
    }

    // If last character is a null-terminator, remove it in the key.
    if (*((LPWSTR) pbuf->QueryPtr() + cchRet - 1) == (WCHAR) '\0')
        cchRet--;

    // Resize the buffer to the final length.  Length includes null-terminator.
    if (!pbuf->Resize(cchRet*2))
    {
        return FALSE;
    }

    return TRUE;
}



CMDBaseData *
CMDBaseObject::GetDataObjectByType(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    Identifier  - The identifier of the data to get.

    ListHead    - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    for (pdcIndex=m_pdcarrayDataHead[dwDataType];pdcIndex!=NULL;pdcIndex=pdcIndex->NextPtr) {
        if (dwIdentifier == pdcIndex->pbdDataObject->GetIdentifier()) {
            break;
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwAttributes,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) &&
        (dwAttributes & METADATA_INHERIT) &&
        (GetParent()!=NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetInheritableDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }

    if ((pbdReturn != NULL) &&
        ((pbdReturn->GetAttributes() & METADATA_INHERIT) == 0)) {
        pbdReturn = NULL;
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) && (GetParent() != NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *dataReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL) && dwEnumDataIndex != 0;
            pdcIndex=pdcIndex->NextPtr, dwEnumDataIndex--) {
        }
    }
    else {
        for (pdcIndex=m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        dataReturn = pdcIndex->pbdDataObject;
    }
    return (dataReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObject(
         IN DWORD dwEnumDataIndex,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Enumerates a data object.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    PVOID *ppvMainDataBuf;
    DWORD dwNumBufferEntries;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, i);
        }
    }
    else {
        pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, dwDataType);
    }

    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }

    if ((pbdReturn == NULL) && (dwAttributes & METADATA_INHERIT) && (GetParent() != NULL)) {
        //
        // Not in current object and inherited data is specified.
        // Build list of data objects in current meta object,
        // and call parent for inherited data.
        //
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumBufferEntries = 0;
        CopyDataObjectsToBuffer(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, FALSE);
        pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                           dwUserType,
                                                           dwDataType,
                                                           ppvMainDataBuf,
                                                           dwNumBufferEntries,
                                                           ppboAssociated);
        FreeMainDataBuffer(ppvMainDataBuf);
    }

    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries)
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

    MainDataBuf   - The buffer filled with previously enumerated values.

    NumBufferEntries - The number of entries in MainDataBuf.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType() &&
                ((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         DWORD &dwEnumDataIndex,
         DWORD dwUserType,
         DWORD dwDataType,
         CMDBaseObject **ppboAssociated)
{
    PVOID *ppvMainDataBuf = GetMainDataBuffer();
    DWORD dwNumBufferEntries = 0;
    CMDBaseData *pbdReturn;

    MD_ASSERT(ppvMainDataBuf != NULL);
    pbdReturn = EnumInheritableDataObject(dwEnumDataIndex,
                                            dwUserType,
                                            dwDataType,
                                            ppvMainDataBuf,
                                            dwNumBufferEntries,
                                            ppboAssociated);
    FreeMainDataBuffer(ppvMainDataBuf);

    return(pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         IN OUT DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         CMDBaseObject **ppboAssociated)
{
   CMDBaseData *pbdReturn = NULL;
   DWORD i;

   if (dwDataType == ALL_METADATA) {
       for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
           pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                       dwUserType,
                                                       i,
                                                       ppvMainDataBuf,
                                                       dwNumBufferEntries);
       }
   }
   else {
       pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                   dwUserType,
                                                   dwDataType,
                                                   ppvMainDataBuf,
                                                   dwNumBufferEntries);
   }

   if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
       //
       // Found data in this object
       //
       *ppboAssociated = this;
   }
   if ((pbdReturn == NULL) && (GetParent() != NULL)) {
       //
       // Not in current object.
       // Call parent for inherited data.
       //
       pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                            dwUserType,
                                                            dwDataType,
                                                            ppvMainDataBuf,
                                                            dwNumBufferEntries,
                                                            ppboAssociated);
   }

   return (pbdReturn);
}

VOID
CMDBaseObject::CopyDataObjectsToBufferByType(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)
/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    ListHead      - The list of data objects.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/

{
    PDATA_CONTAINER pdcIndex;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if ((!bInheritableOnly) ||
                (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                    MD_ASSERT(FALSE);
                    break;
                }
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if ((!bInheritableOnly) ||
                    (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                    !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
            }
        }
    }
}

VOID
CMDBaseObject::CopyDataObjectsToBuffer(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)

/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    DataType      - Optional UserType of the data to copy.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/
{
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; i < INVALID_END_METADATA; i++) {
            CopyDataObjectsToBufferByType(dwUserType, i, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
        }
    }
    else {
        CopyDataObjectsToBufferByType(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
    }
}

DWORD
CMDBaseObject::GetAllDataObjects(
         OUT PVOID *ppvMainDataBuf,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN BOOL bInheritableOnly
         )
/*++

Routine Description:

    Gets all data objects which match the criteria specified by the parameters.

Arguments:

    MainDataBuf   - The buffer to store the data objects in.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

    bInheritableOnly - If TRUE, only gets data objects that are
                       inheritable and not already in the buffer.

Return Value:

    DWORD         - Number of Data Objects in Buffer.

--*/
{
    DWORD dwNumBufferEntries;
    CMDBaseObject *objIndex;

    //
    // Not in current object and inherited data is specified.
    // Build list of data objects in current meta object,
    // and call parent for inherited data.
    //
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumBufferEntries = 0;
    CopyDataObjectsToBuffer(dwUserType,
                            dwDataType,
                            ppvMainDataBuf,
                            dwNumBufferEntries,
                            bInheritableOnly);
    if (dwAttributes & METADATA_INHERIT) {
        for (objIndex = GetParent(); objIndex != NULL; objIndex = objIndex->GetParent()) {
            objIndex->CopyDataObjectsToBuffer(dwUserType,
                                              dwDataType,
                                              ppvMainDataBuf,
                                              dwNumBufferEntries,
                                              TRUE);
        }
    }
    return (dwNumBufferEntries);
}

HRESULT
CMDBaseObject::GetDataRecursive(
         IN OUT BUFFER *pbufMainDataBuf,
         IN DWORD dwMDIdentifier,
         IN DWORD dwMDDataType,
         IN OUT DWORD &rdwNumMetaObjects)
{
    CMDBaseObject *pboChild;
    DWORD i;
    MD_ASSERT (pbufMainDataBuf != NULL);
    HRESULT hresReturn = ERROR_SUCCESS;


    if (GetDataObject(dwMDIdentifier,
                      METADATA_NO_ATTRIBUTES,
                      dwMDDataType,
                      NULL) != NULL) {
        DWORD dwSize = sizeof(CMDBaseObject *) * (rdwNumMetaObjects + 1);
        if (pbufMainDataBuf->QuerySize() < dwSize) {
            if (!pbufMainDataBuf->Resize(dwSize + (sizeof(CMDBaseObject *) * 1000))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            ((CMDBaseObject **)(pbufMainDataBuf->QueryPtr()))[rdwNumMetaObjects++] = (CMDBaseObject *)this;
        }
    }

    for (i = 0;
         SUCCEEDED(hresReturn) &&
             (pboChild = EnumChildObject(i)) != NULL;
         i++) {
        hresReturn = pboChild->GetDataRecursive(pbufMainDataBuf,
                                                dwMDIdentifier,
                                                dwMDDataType,
                                                rdwNumMetaObjects);
    }

    return hresReturn;
}

VOID
CMDBaseObject::SetLastChangeTime(PFILETIME pftLastChangeTime)
{
    if (pftLastChangeTime != NULL) {
        m_ftLastChangeTime = *pftLastChangeTime;
    }
    else {
        GetSystemTimeAsFileTime(&m_ftLastChangeTime);
    }
}

PFILETIME
CMDBaseObject::GetLastChangeTime()
{
    return &m_ftLastChangeTime;
}

DWORD
CMDBaseObject::GetObjectLevel()
{
    DWORD dwLevel = 0;

    if (m_pboParent != NULL) {
        dwLevel = m_pboParent->GetObjectLevel() + 1;
    }

    return dwLevel;
}

BOOL
CMDBaseObject::IsDataInBuffer(
         IN DWORD dwIdentifier,
         IN PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Checks if the buffer contains an object with the specified id.

Arguments:

    Identifier    - The id to check for.

    MainDataBuf   - The buffer to search.

Return Value:

    BOOL          - TRUE if the buffer contains data with the specified id.

--*/
{
    BOOL bReturn = FALSE;
    DWORD i;
    CMDBaseData *pbdDataObject;
    for (i = 0;
        (pbdDataObject = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i)) != NULL;
        i++) {
        if (pbdDataObject->GetIdentifier() == dwIdentifier) {
            bReturn = TRUE;
            break;
        }
    }
    return (bReturn);
}

#if 0   // No longer used.  /SAB

BOOL
CMDBaseObject::CompareDelimitedString(
         IN LPTSTR strNonDelimitedString,
         IN OUT LPTSTR &strDelimitedString,
         IN BOOL bUnicode)
/*++

Routine Description:

    Compared a nondelimeted string to a delimeted string.
    Updates Delimited String on success to point past the string.

Arguments:

    NonDelimiterString - The nondelimited string.

    DelimiterString - The delimited string.

Return Value:

    BOOL          - TRUE if strings are the same.

--*/
{
    LPTSTR i,j;
    BOOL RetCode = FALSE;
    j = strDelimitedString;
    DWORD dwStringLen;

/*

    //
    // Change in semantics. To differentiate between "/" and "//",
    // the leading delimeter is skipped before we get here.
    //
    // Skip leading delimeter, if any
    //
    if ((*j == MD_PATH_DELIMETER) || (*j == MD_ALT_PATH_DELIMETER)) {
        j++;
    }
*/

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (_wcsnicmp((LPWSTR)strDelimitedString, (LPWSTR)strNonDelimitedString, dwStringLen) == 0) {
            if (((*((LPWSTR)strDelimitedString + dwStringLen)==MD_ALT_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)==MD_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)== (WCHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStringLen * sizeof(WCHAR);    //Point to next section or \0
            }
        }
    }
    else {
        dwStringLen = MD_STRLEN(strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (MD_STRNICMP(strDelimitedString, strNonDelimitedString, dwStringLen) == 0) {
            DWORD dwStrBytes = MD_STRBYTES(strNonDelimitedString);
            if (((*(strDelimitedString + dwStrBytes)==MD_ALT_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)==MD_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)== (CHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStrBytes;    //Point to next section or \0
            }
        }
    }
    return (RetCode);
}

#endif


CMDBaseObject*
CMDBaseObject::FindChild(
LPSTR                   szName,     // Name of child to find.
int                     cchName,    // Length of the name.
BOOL                    fUnicode,   // TRUE if unicode name.
HRESULT*                phresult,   // Result code.
BOOL                    fUseHash,   // Allow use of hash table
BASEOBJECT_CONTAINER**  ppbocPrev)  // If non-NULL & !fUseHash, prev. object container in list.
{
    UCHAR                   localBufferForBufKey[SIZE_FOR_ON_STACK_BUFFER];
    CMDKeyBuffer            bufKey (localBufferForBufKey,SIZE_FOR_ON_STACK_BUFFER);
    BASEOBJECT_CONTAINER*   pbocCurrent = NULL;

    MD_ASSERT(phresult != NULL);

    //
    // Trap case of being called with an empty path segment.
    // GenerateBufFromStr should not be called with cch == 0
    //
    if( cchName == 0 )
    {
        *phresult = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        return NULL;
    }

    // Convert the given string to a key.
    if (!GenerateBufFromStr(szName, cchName, fUnicode, &bufKey))
    {
        *phresult = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // Use hash table if it exists and we are allowed to.
    if (fUseHash && m_phtChildren != NULL)
    {
        m_phtChildren->FindKey(&bufKey, &pbocCurrent);
    }

    // Otherwise use brute force linear search.
    else
    {
        BASEOBJECT_CONTAINER* pbocPrev = NULL;

        pbocCurrent = m_pbocChildHead;
        while (pbocCurrent != NULL &&
               !FCompareKeys(&bufKey, &pbocCurrent->pboMetaObject->m_bufKey))
        {
            pbocPrev = pbocCurrent;
            pbocCurrent = pbocCurrent->NextPtr;
        }

        if (ppbocPrev != NULL)
            *ppbocPrev = pbocPrev;
    }

    *phresult = ERROR_SUCCESS;

    if (pbocCurrent != NULL)
        return pbocCurrent->pboMetaObject;
    /* else */
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\sink.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS MetaBase connection point container code for sinks

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
#include <mdcommon.hxx>


/*---------------------------------------------------------------------------
  CMDCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CMDCOM* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CMDCOM::CImpIConnectionPointContainer::Init(CMDCOM *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
  HRESULT hr = E_NOINTERFACE;
  IConnectionPoint* pIConnPt;
  g_rSinkResource->Lock(TSRES_LOCK_READ);
    // NULL the output variable.
    *ppConnPt = NULL;

    if (riid == IID_IMDCOMSINK_A) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }
    else if (riid == IID_IMDCOMSINK_W) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }

  g_rSinkResource->Unlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* aConnPts[MAX_CONNECTION_POINTS];
  COEnumConnectionPoints* pCOEnum;
  UINT i;

  g_rSinkResource->Lock(TSRES_LOCK_READ);
  // Zero the output interface pointer.
  *ppIEnum = NULL;

  // Make a copy on the stack of the array of connection point
  // interfaces. The copy is used below in the creation of the new
  // Enumerator object.
  for (i=0; i<MAX_CONNECTION_POINTS; i++)
    aConnPts[i] = (IConnectionPoint*)m_pBackObj->m_aConnectionPoints[i];

  // Create a Connection Point enumerator COM object for the connection
  // points offered by this CMDCOM object. Pass 'this' to be used to
  // hook the lifetime of the host object to the life time of this
  // enumerator object.
  pCOEnum = new COEnumConnectionPoints(this);
  if (NULL != pCOEnum)
  {
    // Use the array copy to Init the new Enumerator COM object.
    // Set the initial Enumerator index to 0.
    hr = pCOEnum->Init(MAX_CONNECTION_POINTS, aConnPts, 0);
    if ( SUCCEEDED(hr) )
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      hr = pCOEnum->QueryInterface(
                      IID_IEnumConnectionPoints,
                      (PPVOID)ppIEnum);
    }
    
    if( FAILED( hr ) )
    {
      delete pCOEnum;
      pCOEnum = NULL;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  g_rSinkResource->Unlock();

  return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\cofact.cxx ===
#include <mdcommon.hxx>

// {BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}
//DEFINE_GUID(CLSID_MDCOM, 0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
// {BA4E57F1-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOMSRVFACTORY =
//{ 0xba4e57f1, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

// {C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOM =
//{ 0xc1aa48c0, 0xfacc, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

CMDCOMSrvFactory::CMDCOMSrvFactory()
    :m_mdcObject()
{
    m_dwRefCount=0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_mdcObject.AddRef();
}

CMDCOMSrvFactory::~CMDCOMSrvFactory()
{
    m_mdcObject.Release();
}
HRESULT
CMDCOMSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_mdcObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CMDCOMSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CMDCOMSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        if (SUCCEEDED(m_mdcObject.GetConstructorError())) {
            *ppObject = (IClassFactory *) this;
        }
        else {
            return m_mdcObject.GetConstructorError();
        }
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CMDCOMSrvFactory::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOMSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
//    if (dwRefCount == 0) {
//        delete this;
//    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if ((rclsid != CLSID_MDCOM)    && 
        (rclsid != CLSID_MDCOMEXE)) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_pFactory->QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}

STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("MD COM Server"),
                                 sizeof(TEXT("MD COM Server")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("METADATA.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    return RETURNCODETOHRESULT(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;

#if 0
    if ( IISGetPlatformType() != PtWindows95 ) {

        //
        // Delete Crypto Keys
        //

        HRESULT hres;
        hres = IISCryptoInitialize();

        if (SUCCEEDED(hres)) {

            IISCryptoDeleteStandardContainer(0);

            IISCryptoDeleteStandardContainer(CRYPT_MACHINE_KEYSET);

            IISCryptoTerminate();

        }
    }
#endif

    dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}\\InprocServer32"));
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"));
    }

    return RETURNCODETOHRESULT(dwReturn);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\writer.cpp ===
#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "LocationWriter.h"
#include "MBPropertyWriter.h"
#include "MBCollectionWriter.h"
#include "MBSchemaWriter.h"
#include "WriterGlobals.h"

#define MAX_BUFFER	2048

/***************************************************************************++

Routine Description:

    Initializes global lengths.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeLengths()
{
	g_cchBeginFile					= wcslen(g_wszBeginFile);
	g_cchEndFile					= wcslen(g_wszEndFile);
	g_cchBeginLocation				= wcslen(g_BeginLocation);
	g_cchLocation					= wcslen(g_Location);
	g_cchEndLocationBegin			= wcslen(g_EndLocationBegin);
	g_cchEndLocationEnd				= wcslen(g_EndLocationEnd);
	g_cchCloseQuoteBraceRtn			= wcslen(g_CloseQuoteBraceRtn);
	g_cchRtn						= wcslen(g_Rtn);
	g_cchEqQuote					= wcslen(g_EqQuote);
	g_cchQuoteRtn					= wcslen(g_QuoteRtn);
	g_cchTwoTabs					= wcslen(g_TwoTabs);
	g_cchNameEq						= wcslen(g_NameEq);
	g_cchIDEq						= wcslen(g_IDEq);
	g_cchValueEq					= wcslen(g_ValueEq);
	g_cchTypeEq						= wcslen(g_TypeEq);
	g_cchUserTypeEq					= wcslen(g_UserTypeEq);
	g_cchAttributesEq				= wcslen(g_AttributesEq);
	g_cchBeginGroup					= wcslen(g_BeginGroup);
	g_cchEndGroup					= wcslen(g_EndGroup);
	g_cchBeginCustomProperty		= wcslen(g_BeginCustomProperty);
	g_cchEndCustomProperty			= wcslen(g_EndCustomProperty);
	g_cchZeroHex					= wcslen(g_ZeroHex);
    g_cchBeginComment               = wcslen(g_BeginComment);
    g_cchEndComment                 = wcslen(g_EndComment);


	BYTE_ORDER_MASK =	0xFEFF;
	UTF8_SIGNATURE = 0x00BFBBEF;

	g_cchUnknownName                = wcslen(g_wszUnknownName);
	g_cchUT_Unknown                 = wcslen(g_UT_Unknown);
	g_cchMaxBoolStr					= wcslen(g_wszFalse);

	g_cchHistorySlash			    = wcslen(g_wszHistorySlash);
	g_cchMinorVersionExt			= wcslen(g_wszMinorVersionExt);
	g_cchDotExtn					= wcslen(g_wszDotExtn);

    g_cchTrue                       = wcslen(g_wszTrue);
    g_cchFalse                      = wcslen(g_wszFalse);

	g_cchTemp                       = 1024;
	g_cchBeginSchema                = wcslen(g_wszBeginSchema);
	g_cchEndSchema                  = wcslen(g_wszEndSchema);
	g_cchBeginCollection            = wcslen(g_wszBeginCollection);
	g_cchSchemaGen                  = wcslen(g_wszSchemaGen);
	g_cchInheritsFrom               = wcslen(g_wszInheritsFrom);
	g_cchEndCollection              = wcslen(g_wszEndCollection);
	g_cchBeginPropertyShort         = wcslen(g_wszBeginPropertyShort);
	g_cchMetaFlagsExEq              = wcslen(g_wszMetaFlagsExEq);
	g_cchEndPropertyShort           = wcslen(g_wszEndPropertyShort);
	g_cchBeginPropertyLong          = wcslen(g_wszBeginPropertyLong);
	g_cchPropIDEq                   = wcslen(g_wszPropIDEq);
	g_cchPropTypeEq                 = wcslen(g_wszPropTypeEq);
	g_cchPropUserTypeEq             = wcslen(g_wszPropUserTypeEq);
	g_cchPropAttributeEq            = wcslen(g_wszPropAttributeEq);

	g_cchPropMetaFlagsEq            = wcslen(g_wszPropMetaFlagsEq);
	g_cchPropMetaFlagsExEq          = wcslen(g_wszPropMetaFlagsExEq);
	g_cchPropDefaultEq              = wcslen(g_wszPropDefaultEq);
	g_cchPropMinValueEq             = wcslen(g_wszPropMinValueEq);
	g_cchPropMaxValueEq             = wcslen(g_wszPropMaxValueEq);
	g_cchEndPropertyLongNoFlag      = wcslen(g_wszEndPropertyLongNoFlag);
	g_cchEndPropertyLongBeforeFlag  = wcslen(g_wszEndPropertyLongBeforeFlag);
	g_cchEndPropertyLongAfterFlag   = wcslen(g_wszEndPropertyLongAfterFlag);
	g_cchBeginFlag                  = wcslen(g_wszBeginFlag);
	g_cchFlagValueEq                = wcslen(g_wszFlagValueEq);
	g_cchEndFlag                    = wcslen(g_wszEndFlag);

    g_cchOr              			= wcslen(g_wszOr);
	g_cchOrManditory				= wcslen(g_wszOrManditory);
	g_cchFlagIDEq			        = wcslen(g_wszFlagIDEq);
	g_cchContainerClassListEq       = wcslen(g_wszContainerClassListEq);

	g_cchSlash										= wcslen(g_wszSlash);
    g_cchLM								            = wcslen(g_wszLM);
	g_cchSchema								        = wcslen(g_wszSchema);
	g_cchSlashSchema								= wcslen(g_wszSlashSchema);
	g_cchSlashSchemaSlashProperties					= wcslen(g_wszSlashSchemaSlashProperties);
	g_cchSlashSchemaSlashPropertiesSlashNames		= wcslen(g_wszSlashSchemaSlashPropertiesSlashNames);
	g_cchSlashSchemaSlashPropertiesSlashTypes		= wcslen(g_wszSlashSchemaSlashPropertiesSlashTypes);
	g_cchSlashSchemaSlashPropertiesSlashDefaults	= wcslen(g_wszSlashSchemaSlashPropertiesSlashDefaults);
	g_cchSlashSchemaSlashClasses					= wcslen(g_wszSlashSchemaSlashClasses);
	g_cchEmptyMultisz								= 2;
	g_cchEmptyWsz									= 1;
	g_cchComma										= wcslen(g_wszComma);
    g_cchMultiszSeperator                           = wcslen(g_wszMultiszSeperator);

	return S_OK;

} // InitializeLengths


/***************************************************************************++

Routine Description:

    Creates the CWriterGlobalHelper object - the object that has all the ISTs
    to the meta tables - and initializess it.

Arguments:

    [in]   Bool indicating if we should fail if the bin file is absent.
           There are some scenarios in which we can tolerate this, and some
           where we dont - hence the distinction.

    [out]  new CWriterGlobalHelper object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent,
						CWriterGlobalHelper**	ppCWriterGlobalHelper)
{
	HRESULT					hr						= S_OK;
	static  BOOL			bInitializeLengths		= FALSE;
	CWriterGlobalHelper*	pCWriterGlobalHelper	= NULL;

	*ppCWriterGlobalHelper = NULL;

	if(!bInitializeLengths)
	{
		//
		// Initialize lengths once.
		//

		::InitializeLengths();
		bInitializeLengths = TRUE;
	}

    //
	// TODO: Is this an in-out parameter?
	//

	if(NULL != *ppCWriterGlobalHelper)
	{
		delete *ppCWriterGlobalHelper;
		*ppCWriterGlobalHelper = NULL;
	}

	pCWriterGlobalHelper = new CWriterGlobalHelper();
	if(NULL == pCWriterGlobalHelper)
	{
		return E_OUTOFMEMORY;
	}

	hr = pCWriterGlobalHelper->InitializeGlobals(i_bFailIfBinFileAbsent);

	if(FAILED(hr))
	{
		delete pCWriterGlobalHelper;
		pCWriterGlobalHelper = NULL;
		return hr;
	}

	*ppCWriterGlobalHelper = pCWriterGlobalHelper;

	return S_OK;

} // GetGlobalHelper


/***************************************************************************++

Routine Description:

    Constructor for CWriter

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriter::CWriter()
{
	m_wszFile              = NULL;
	m_hFile                = INVALID_HANDLE_VALUE;
	m_bCreatedFile         = FALSE;
	m_pCWriterGlobalHelper = NULL;
	m_pISTWrite            = NULL;
	m_cbBufferUsed         = 0;
		
} // Constructor  CWriter


/***************************************************************************++

Routine Description:

    Destructor for CWriter

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriter::~CWriter()
{
	if(NULL != m_wszFile)
	{	
		delete [] m_wszFile;
		m_wszFile = NULL;
	}
	if(m_bCreatedFile && 
	   (INVALID_HANDLE_VALUE != m_hFile || NULL != m_hFile)
	  )
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	else
	{
		m_hFile = INVALID_HANDLE_VALUE;
	}

	if(NULL != m_pISTWrite)
	{
		m_pISTWrite->Release();
		m_pISTWrite = NULL;
	}

	//
	// Global helper is created externally, no need to delete here
	//

} // Constructor  CWriter


/***************************************************************************++

Routine Description:

    Initialization for CWriter.

Arguments:

    [in]   FileName.
    [in]   Pointer to the CWriterGlobalHelper object that has all the meta 
           table information. We assume that this pointer is valid for the 
           duration of the writer object being initialized.
    [in]   Filehandle.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::Initialize(LPCWSTR				 wszFile,
							CWriterGlobalHelper* i_pCWriterGlobalHelper,
							HANDLE				 hFile)
{

	HRESULT                     hr            = S_OK;
	ISimpleTableDispenser2*		pISTDisp      = NULL;
	IAdvancedTableDispenser*	pISTAdvanced  = NULL;

	//
	// TODO: Assert that everything is NULL
	//

	//
	// Save file name and handle.
	//

	m_wszFile = new WCHAR[wcslen(wszFile)+1];
	if(NULL == m_wszFile)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	wcscpy(m_wszFile, wszFile);

	m_hFile = hFile;

    //
	// Initialized the used buffer count to zero.
	//

	m_cbBufferUsed = 0;

    //
	// Save the global helper object that has all the ISTs to all the meta
	// tables. Assumption: i_pCWriterGlobalHelper will be valid for the 
	// lifetime of the writer object.
	//

	m_pCWriterGlobalHelper = i_pCWriterGlobalHelper;

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser, (LPVOID*)&pISTAdvanced);
	
	if(FAILED(hr))
	{
		goto exit;
	}

    //
	// This IST is used as a cache to save the contents of a location. It 
	// used to be local to the location writer object (locationwriter.cpp).
	// But it was moved to the writer object for perf because location 
	// writer is created for each location. The cache is cleared for each
	// location by calling TODO
	//

	hr = pISTAdvanced->GetMemoryTable(wszDATABASE_METABASE, 
		                              wszTABLE_MBProperty, 
								      0, 
								      NULL, 
								      NULL, 
								      eST_QUERYFORMAT_CELLS, 
								      fST_LOS_READWRITE, 
								      &m_pISTWrite);

	if (FAILED(hr))
	{
		goto exit;
	}

exit:

	if(NULL != pISTAdvanced)
	{
		pISTAdvanced->Release();
		pISTAdvanced = NULL;
	}

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}

	return hr;

} // CWriter::Initialize


/***************************************************************************++

Routine Description:

    Creates the file.

Arguments:

    [in]   Security attributes.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::ConstructFile(PSECURITY_ATTRIBUTES pSecurityAtrributes)
{
	m_hFile = CreateFileW(m_wszFile, 
						  GENERIC_WRITE,
						  0,
						  pSecurityAtrributes, 
						  CREATE_ALWAYS, 
						  FILE_ATTRIBUTE_NORMAL, 
						  NULL);

	if(INVALID_HANDLE_VALUE == m_hFile)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	m_bCreatedFile = TRUE;

	return S_OK;

} // CWriter::ConstructFile


/***************************************************************************++

Routine Description:

    Writes the begin tags depending on whats being written (schema or data)

Arguments:

    [in]   Writer type - schema or metabase data.
    [in]   Security attributes.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::BeginWrite(eWriter              eType,
							PSECURITY_ATTRIBUTES pSecurityAtrributes)
{
	ULONG	dwBytesWritten = 0;
	HRESULT hr             = S_OK;

	if((NULL == m_hFile) || (INVALID_HANDLE_VALUE == m_hFile))
	{
		hr = ConstructFile(pSecurityAtrributes);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	if(!WriteFile(m_hFile,
				  (LPVOID)&UTF8_SIGNATURE,
				  sizeof(BYTE)*3,
				  &dwBytesWritten,
				  NULL))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if(eWriter_Metabase == eType)
	{
		hr = WriteToFile((LPVOID)g_wszBeginFile,
					     g_cchBeginFile);
	}
	else if(eWriter_Schema == eType)
	{
		hr = WriteToFile((LPVOID)g_wszBeginSchema,
					     g_cchBeginSchema);
	}

	return hr;

} // CWriter::BeginWrite


/***************************************************************************++

Routine Description:

    Writes the end tags depending on whats being written (schema or data)
    Or if the write is being aborted, and the file has been created by the
    writer, it cleans up the file.

Arguments:

    [in]   Writer type - schema or metabase data or abort

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::EndWrite(eWriter eType)
{
	HRESULT hr = S_OK;

	switch(eType)
	{
		case eWriter_Abort:

  		    //
		    // Abort the write and return
		    //

		    if(m_bCreatedFile && 
		       ((INVALID_HANDLE_VALUE != m_hFile) && (NULL != m_hFile))
		      )
		    {
		        //
			    // We created the file - delete it.
			    //

			    CloseHandle(m_hFile);
			    m_hFile = INVALID_HANDLE_VALUE;

			    if(NULL != m_wszFile)
			    {
				    if(!DeleteFileW(m_wszFile))
					{
					    hr= HRESULT_FROM_WIN32(GetLastError());
					}    
			    }
			}
			return hr;
		    break;

		case eWriter_Metabase:

		    hr = WriteToFile((LPVOID)g_wszEndFile,
			   			     g_cchEndFile,
						     TRUE);
		    break;

		case eWriter_Schema:

		    hr = WriteToFile((LPVOID)g_wszEndSchema,
						     g_cchEndSchema,
						     TRUE);
		    break;

		default:

		    return E_INVALIDARG;
	}

	if(SUCCEEDED(hr))
	{
		if(SetEndOfFile(m_hFile))
		{
			if(!FlushFileBuffers(m_hFile))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;

} // CWriter::EndWrite


/***************************************************************************++

Routine Description:

    Writes the data to the buffer. If the buffer is full, it forces a flush
    to disk. It also forces a flush to disk if it is told to do so.

Arguments:

    [in]   Data
    [in]   Count of bytes to write
    [in]   Bool to indicate force flush or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::WriteToFile(LPVOID	pvData,
						     DWORD	cchData,
							 BOOL   bForceFlush)
{
	HRESULT	hr           = S_OK;
	ULONG   cbData       = cchData *sizeof(WCHAR);
	ULONG   cchRemaining = cchData;

	//
	// TODO: Assert m_hFile is non-null
	//

	if((m_cbBufferUsed + cbData) > g_cbMaxBuffer)
	{
		ULONG iData = 0;
		//
		// If the data cannot be put in the global buffer, flush the contents
		// of the global buffer to disk.
		//

		hr = FlushBufferToDisk();

		if(FAILED(hr))
		{
			goto exit;
		}

		//
		// m_cbBufferUsed should be zero now. If you still cannot accomodate 
		// the data split it up write into buffer.
		//

		while( cbData > g_cbMaxBuffer)
		{

			hr = WriteToFile(&(((LPWSTR)pvData)[iData]),
							 g_cchMaxBuffer,
							 bForceFlush);

			if(FAILED(hr))
			{
				goto exit;
			}

			iData = iData + g_cchMaxBuffer;
			cbData = cbData - g_cbMaxBuffer;
			cchRemaining = cchRemaining - g_cchMaxBuffer;
							 
		}

		hr = WriteToFile(&(((LPWSTR)pvData)[iData]),
						 cchRemaining,
						 bForceFlush);

		if(FAILED(hr))
		{
			goto exit;
		}

//		memcpy( (&(g_Buffer[g_cbBufferUsed])), &(((LPWSTR)pvData)[iData]), cbData);
//		g_cbBufferUsed = g_cbBufferUsed + cbData;

	}
	else
	{
		memcpy( (&(m_Buffer[m_cbBufferUsed])), pvData, cbData);
		m_cbBufferUsed = m_cbBufferUsed + cbData;

		if(TRUE == bForceFlush)
		{
			hr = FlushBufferToDisk();

			if(FAILED(hr))
			{
				goto exit;
			}
		}

	}


exit:

	return hr;

} // CWriter::WriteToFile


/***************************************************************************++

Routine Description:

    Converts the data in the buffer (UNICODE) to UTF8 and writes the contents
    to the file.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::FlushBufferToDisk()
{
	DWORD	dwBytesWritten	= 0;
	int		cb				= 0;
	HRESULT	hr				= S_OK;

	cb = WideCharToMultiByte(CP_UTF8,						// Convert to UTF8
							 NULL,							// Must be NULL
							 LPWSTR(m_Buffer),				// Unicode string to convert.
							 m_cbBufferUsed/sizeof(WCHAR),	// cch in string.
							 (LPSTR)m_BufferMultiByte,		// buffer for new string
							 g_cbMaxBufferMultiByte,		// size of buffer
							 NULL,
							 NULL);
	if(!cb)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	if(!WriteFile(m_hFile,
				  (LPVOID)m_BufferMultiByte,
				  cb,
				  &dwBytesWritten,
				  NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	m_cbBufferUsed = 0;

exit:

	return hr;

} // CWriter::FlushBufferToDisk


/***************************************************************************++

Routine Description:

    Creates a new location writer, initializes it and hands it out.

Arguments:

    [out] Location Writer
    [in]  Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::GetLocationWriter(CLocationWriter** ppCLocationWriter,
								   LPCWSTR            wszLocation)
{
	HRESULT hr = S_OK;

	*ppCLocationWriter = new CLocationWriter();
	if(NULL == *ppCLocationWriter)
	{
		return E_OUTOFMEMORY;
	}

	hr = (*ppCLocationWriter)->Initialize((CWriter*)(this),
	                                      wszLocation);

	return hr;

} // CWriter::GetLocationWriter


/***************************************************************************++

Routine Description:

    Creates a new schema writer, initializes it and hands it out.

Arguments:

    [out] Schema Writer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::GetMetabaseSchemaWriter(CMBSchemaWriter** ppSchemaWriter)
{
	*ppSchemaWriter = new CMBSchemaWriter((CWriter*)(this));
	if(NULL == *ppSchemaWriter)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;

} // CWriter::GetMetabaseSchemaWriter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\comobj.cxx ===
#define INITGUID
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <issched.hxx>
#include <mbs.hxx>
#include <ptrmap.hxx>
#include <tuneprefix.h>



CIdToPointerMapper  *g_PointerMapper = NULL;


CMDCOM::CMDCOM():
    m_ImpIConnectionPointContainer(),
    m_hresConstructorError(ERROR_SUCCESS)
{
    UINT i;
    HRESULT hRes;

    m_dwRefCount = 0;
    g_hReadSaveSemaphore = NULL;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    fFlusherInitialized = FALSE;
    dwMBFlushCookie = 0;
    msMBFlushTime = INETA_MB_FLUSH_DEFAULT;
    INITIALIZE_CRITICAL_SECTION( &csFlushLock );


    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
      m_aConnectionPoints[i] = NULL;

    HRESULT hr = NOERROR;

    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE(
                               "g_hReadSaveSemaphore",
                               &g_hReadSaveSemaphore,
                               1,
                               1
                               );

    if( g_hReadSaveSemaphore == NULL ) {
        hr = GetLastHResult();
        IIS_PRINTF((buff,"CreateSemaphore Failed with %x\n",hr));
    }
    else {

        COConnectionPoint* pCOConnPt;

        m_ImpIConnectionPointContainer.Init(this);
        // Rig this COPaper COM object to be connectable. Assign the connection
        // point array. This object's connection points are determined at
        // compile time--it currently has 2 connection points, one for ANSI,
        // one for UNICODE. Create a connection
        // point object for these and assign them into the array. This array could
        // easily grow to support additional connection points in the future.

        // First try creating a new connection point object. Pass 'this' as the
        // pHostObj pointer used by the connection point to pass its AddRef and
        // Release calls back to the host connectable object.
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_A);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_W);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
    }
    m_hresConstructorError = hr;
}

CMDCOM::~CMDCOM()
{
//    SetEvent(hevtDone);
    UINT i;
    IConnectionPoint* pIConnectionPoint;
    // Do final release of the connection point objects.
    // If this isn't the final release, then the client has an outstanding
    // unbalanced reference to a connection point and a memory leak may
    // likely result because the host COPaper object is now going away yet
    // a connection point for this host object will not end up deleting
    // itself (and its connections array).
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
    {
      pIConnectionPoint = m_aConnectionPoints[i];
      RELEASE_INTERFACE(pIConnectionPoint);
    }

    if (g_hReadSaveSemaphore != NULL) {
        CloseHandle(g_hReadSaveSemaphore);
    }
   DeleteCriticalSection( &csFlushLock );
   MD_ASSERT(g_PointerMapper);
   delete g_PointerMapper;

}

HRESULT
CMDCOM::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOM) {
        *ppObject = (IMDCOM *) this;
        AddRef();
    }
    else if ( IID_IMDCOM2 == riid )
    {
        *ppObject = (IMDCOM2 *) this;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
      *ppObject = &m_ImpIConnectionPointContainer;
      AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG
CMDCOM::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOM::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT
CMDCOM::ComMDInitialize()
/*++

Routine Description:

    Initializes the metadata database. This must be called before any other API.
    Reads in the existing database, if found. If errors occur reading in the
    existing database, warnings are returned and the metabase is initialized
    with not data.

Arguments:

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            ERROR_ALREADY_INITIALIZED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_INVALID_DATA
            MD_WARNING_PATH_NOT_FOUND
            MD_WARNING_DUP_NAME
            MD_WARNING_INVALID_DATA

Notes:
    This could take a long time to process, as it may load in a large amount of data.
    If a warning code is returned, the database has been successfully initialized, but
    some data in the database was not loaded successfully.

--*/
{
    InitializeFlusher ();
    return InitWorker(FALSE, NULL, NULL);
}

HRESULT
CMDCOM::ComMDTerminate(IN BOOL bSaveData)
/*++

Routine Description:

    DeInitailizes the metadata database. This must be before the application terminates
    or dunloads the dll.

Arguments:

    SaveData      - If TRUE, the metadata is saved before terminating.
                    If the save fails, the metadata is not terminated.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_NOT_ENOUGH_MEMORY
              Errors from the file system.

Notes:
    This could take a long time to process, as it may save a large amount of data.

--*/
{

    return TerminateWorker1(FALSE);
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDShutdown( void)
{
    HRESULT hresReturn;
    BOOL bSaveData;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    TerminateFlusher ();
    SendShutdownNotifications();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    //

    //
    // Note, there are four references to the CMDCOM object that
    // are allowed to be active after this point.
    // 1)  The reference taken in dllmain ( cleans up in dllmain ).
    // 2)  The reference owned by COADMIN itself 
    //     ( this is called as part of it's shutdown )
    // 3)  The reference owned by the MDWriter for backup and restore 
    //     ( it is released after TerminateComAdmindata is called )
    // 4)  The reference owned by the Metabase holder, 
    //     which is used to validate that the metabase is up
    //     and working if iisadmin is started.  
    //     ( it is also released after the TerminateComAdmindata is called )
    //

    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 5) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {

        //
        // Need to hold a read lock here to make sure
        // Terminate doesn't occur during SaveAllData.
        //
        // Cannot hold a write lock, as SaveAllData gets
        // a read lock after getting ReadSaveSemaphore
        //

        g_rMasterResource->Lock(TSRES_LOCK_READ);

        if (g_dwInitialized > 0) {
            hresReturn = SaveAllData(TRUE, &CryptoStorage, pSessionKeyBlob);
        }
        else {
            if (g_dwInitialized > 0) {
                MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
                g_bSaveDisallowed = TRUE;
                MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
            }
            else {
                g_bSaveDisallowed = TRUE;
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               pszMDPath,
                               FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               (PBYTE) pszMDPath,
                               TRUE);
}

HRESULT
CMDCOM::ComMDAddMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Creates a meta object and adds it to the list of child objects for the object specified by Path.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path  - Path of the object to be added, relative to the path of Handle.
            Must not be NULL.
            eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME
            ERROR_INVALID_NAME

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        WCHAR strPath[METADATA_MAX_NAME_LEN];
        LPSTR pszTempPath = (LPSTR)pszMDPath;

        //
        // ExtractNameFromPath assumes no preceding delimeter
        //

        if (pszTempPath != NULL) {
            SkipPathDelimeter(pszTempPath, bUnicode);
        }

        //
        // Make sure at least one new object was specified
        //

        hresReturn = ExtractNameFromPath(pszTempPath,
                                         (LPSTR)strPath,
                                         bUnicode);

        if (FAILED(hresReturn)) {
            hresReturn = E_INVALIDARG;
        }
        else {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            hresReturn = AddObjectToDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  TRUE);
}

HRESULT
CMDCOM::ComMDDeleteMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a meta object and all of its data. Recursively deletes all descendants.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of object to be deleted, relative to the path of Handle.
           Must not be NULL.
           eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDPath == NULL) {
       hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = RemoveObjectFromDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        pszMDPath,
                                        FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        (PBYTE)pszMDPath,
                                        TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data. Recursively deletes all descendants of the child objects.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of the parent of the objects to be deleted, relative to the path of Handle.
           eg. "Root Object/Child"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    CMDBaseObject *pboParent;
    CMDBaseObject *pboChild;
    CMDHandle *phoHandle;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboParent, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            phoHandle = GetHandleObject(hMDHandle);
            MD_ASSERT (phoHandle != NULL);
            while ((pboChild = pboParent->EnumChildObject(0)) != NULL) {
                MD_REQUIRE(pboParent->RemoveChildObject(pboChild) == ERROR_SUCCESS);
                if (phoHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                    delete(pboChild);
                }
            }
            g_dwSystemChangeNumber++;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 pszMDPath,
                                 pszMDName,
                                 dwMDEnumObjectIndex,
                                 FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 (PBYTE)pszMDPath,
                                 (PBYTE)pszMDName,
                                 dwMDEnumObjectIndex,
                                 TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
        /* [in] */ DWORD dwMDEnumObjectIndex,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all child metaobjects once per call. Child Objects are numbers from 0 to NumObjects - 1, where
    NumObjects is the number of current child objects. If EnumObjectIndex is >= NumObjects, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path - Path of parent object, relative to the path of Handle.
           eg. "Root Object/Child/GrandChild"
    Name - Buffer where the Name of the object is returned. Must be at least METADATA_MAX_NAME_LEN characters long.

    EnumObjectIndex - Index of the value to be retrieved. The caller is expected to set this to 0 before the first call and increment
           it by 1 on each successive call until ERROR_NO_MORE_ITEMS is returned.
Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_PATH_NOT_FOUND
            ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDName == NULL) {
        hresReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected, *pboChild;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboChild = pboAffected->EnumChildObject(dwMDEnumObjectIndex);
            if (pboChild != NULL) {
                PVOID pvName = (PVOID)pboChild->GetName(bUnicode);
                if (pvName == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (bUnicode) {
                        wcscpy((LPWSTR)pszMDName, (LPWSTR)pvName);
                    }
                    else {
                        MD_STRCPY((LPSTR)pszMDName, (LPSTR)pvName);
                    }
                }
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                pszMDSourcePath,
                                hMDDestHandle,
                                pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                (PBYTE)pszMDSourcePath,
                                hMDDestHandle,
                                (PBYTE)pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    CMDHandle *phoDestHandle, *phoSourceHandle;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL, *pboExisting = NULL, *pboIndex = NULL, *pboNew = NULL, *pboDestParent = NULL;
    LPSTR pszTempPath;
    LPSTR pszRemainingDestPath;
    BOOL bChanged = FALSE;
    WCHAR strName[METADATA_MAX_NAME_LEN];

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {

        //
        // check if pszDestPath is a valid parameter (non-NULL)
        //

        if (pszDestPath == NULL) {
            hresReturn = E_INVALIDARG;
        }
        else {

            //
            // Must have access to Dest parent to add it.
            // Make sure that a valid path was specified, ie. handle
            // points to ancestor.
            //
            pszTempPath = pszDestPath;
            SkipPathDelimeter(pszTempPath, bUnicode);
            hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
            if (FAILED(hresReturn)) {
                hresReturn = E_INVALIDARG;
            }
            if (!bMDCopyFlag) {
                //
                // Must have access to source parent to remove it.
                // Make sure that a valid path was specified, ie. handle
                // points to ancestor.
                //
                pszTempPath = pszSourcePath;
                SkipPathDelimeter(pszTempPath, bUnicode);
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
                if (FAILED(hresReturn)) {
                    hresReturn = E_INVALIDARG;
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboSource, hMDSourceHandle,
                                    (bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE,
                                     (LPSTR)pszSourcePath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            //
            // GetObjectFromPath updates path, need both original and remainder
            //
            pszRemainingDestPath = pszDestPath;
            hresReturn = GetObjectFromPath(pboDest, hMDDestHandle, METADATA_PERMISSION_WRITE,
                                        (LPSTR)pszRemainingDestPath, bUnicode);
            if ((SUCCEEDED(hresReturn)) ||
                ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL))) {
                //
                // Make sure dest is not descendant of source
                //
                for (pboIndex = pboDest; pboIndex != NULL; pboIndex = pboIndex->GetParent()) {
                    if (pboIndex == pboSource) {
                        hresReturn = E_INVALIDARG;
                        break;
                    }
                }
            }

            phoDestHandle = GetHandleObject(hMDDestHandle);
            if (SUCCEEDED(hresReturn)) {
                //
                // Object already exists
                //
                if (pboDest == pboSource) {
                    //
                    // Copy to self
                    //
                }
                else {
                    MD_ASSERT (phoDestHandle != NULL);
                    if (bMDOverwriteFlag) {
                        if (pboDest->GetName(bUnicode) == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                        else {
                            pboDestParent = pboDest->GetParent();
                            hresReturn = MakeTreeCopy(pboSource, pboNew, pboDest->GetName(bUnicode), bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                MD_REQUIRE(SUCCEEDED(pboDestParent->RemoveChildObject(pboDest->GetName(bUnicode), bUnicode)));
                                hresReturn = pboDestParent->InsertChildObject(pboNew);
                                if (SUCCEEDED(hresReturn)) {
                                    g_dwSystemChangeNumber++;
                                    if (phoDestHandle->SetChangeData(
                                        pboDest, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                                        delete(pboDest);
                                    }
                                    AddNewChangeData(phoDestHandle, pboNew);
                                }
                                else {
                                    delete (pboNew);
                                    pboDestParent->InsertChildObject(pboDest);
                                }
                            }
                        }
                    }
                    else {
                        //
                        // Object exists at destination and not overwrite.
                        // Add in missing objects and data.
                        //
                        hresReturn = CopyTree(phoDestHandle, pboDest, pboSource, bChanged);
                        if (bChanged) {
                            g_dwSystemChangeNumber++;
                        }
                    }
                }
            }
            else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL)) {

                //
                // Full destination path doesn't exist, so create it
                //

                hresReturn = MakeTreeCopyWithPath(pboSource,
                                               pboNew,
                                               pszRemainingDestPath,
                                               bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    MD_ASSERT(pboDest != NULL);
                    hresReturn = pboDest->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        g_dwSystemChangeNumber++;
                        AddNewChangeData(phoDestHandle, pboNew);
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }

            if ((SUCCEEDED(hresReturn)) && (!bMDCopyFlag)) {
                MD_REQUIRE(SUCCEEDED(pboSource->GetParent()->RemoveChildObject(pboSource)));
                phoSourceHandle = GetHandleObject(hMDSourceHandle);
                MD_ASSERT (phoSourceHandle != NULL);
                if (phoSourceHandle->SetChangeData(pboSource, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboSource);
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  pszMDNewName,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  (PBYTE)pszMDNewName,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName,
        IN BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((LPSTR)pszMDNewName == NULL) ||

        //
        // ExtractNameFromPath, below, checks name length so don't need to
        // check that here.
        //

        (bUnicode &&
            ((wcschr((LPWSTR)pszMDNewName, MD_PATH_DELIMETERW) != NULL) ||
             (wcschr((LPWSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL))) ||
        (!bUnicode &&
            ((MD_STRCHR((LPSTR)pszMDNewName, MD_PATH_DELIMETERA) != NULL) ||
             (MD_STRCHR((LPSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL)))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        WCHAR strName[METADATA_MAX_NAME_LEN];
        LPSTR pszNewName = (LPSTR)pszMDNewName;
        LPSTR pszTempName = pszNewName;

        hresReturn = ExtractNameFromPath(pszTempName, (LPSTR)strName, bUnicode);

        if (SUCCEEDED(hresReturn)) {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            CMDBaseObject *pboAffected, *pboParent;
            hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                pboParent = pboAffected->GetParent();
                if ( pboParent == NULL) {
                    //
                    // Can't rename MasterRoot
                    //
                    hresReturn = E_INVALIDARG;

                }
                else {
                    if (pboAffected->GetParent()->GetChildObject(pszNewName, &hresReturn, bUnicode) != NULL) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
                    }
                    if (SUCCEEDED(hresReturn)) {

                        BUFFER OriginalKeyName;
                        DWORD  dwStringLen = 0;

                        hresReturn= GetObjectPath(pboAffected,
                                                 &OriginalKeyName,
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 bUnicode);

                        if (SUCCEEDED(hresReturn)) {
                            //
                            // First Remove the object, to get it out of the hash table.
                            //

                            pboParent->RemoveChildObjectFromHash( pboAffected );

                            //
                            // Must use pszMDNewName, as this does not include delimeters
                            //

                            if (!pboAffected->SetName((LPSTR)pszMDNewName, bUnicode)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

                                //
                                // Attempt to reinsert the object
                                // Preserve previous error code by ignoreing this one.
                                //

                                pboParent->AddChildObjectToHash(pboAffected);
                            }
                            else {

                                //
                                // Reinsert the object with the new name.
                                //

                                hresReturn = pboParent->AddChildObjectToHash( pboAffected );

                                g_dwSystemChangeNumber++;
                                MD_ASSERT(GetHandleObject(hMDHandle) != NULL);
                                GetHandleObject(hMDHandle)->SetChangeData(pboAffected, MD_CHANGE_TYPE_RENAME_OBJECT, 0,
                                                                          (LPWSTR)OriginalKeyName.QueryPtr ());
                            }
                        }


                    }

                }
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PMETADATA_RECORD pmdrMDData,
        IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist, it creates and
    inserts a data object into the list of data objects of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data to set. See IMD.H.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.
    Duplicate data names are not allowed, even for different types.
--*/
{
    HRESULT hresReturn;
    CMDHandle * phMDHandle;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (!ValidateData(pmdrMDData, bUnicode)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *AffectedObject = NULL;
        hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            pszPath = (LPSTR)pszMDPath;
            MD_ASSERT(pszMDPath != NULL);
            hresReturn = AddObjectToDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;
                hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }

        if (SUCCEEDED(hresReturn)) {
            hresReturn = AffectedObject->SetDataObject(pmdrMDData, bUnicode);
        }
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;
            phMDHandle = GetHandleObject(hMDHandle);
            if( phMDHandle == NULL )
            {
                hresReturn = E_FAIL;
            }
            else
            {
                phMDHandle->SetChangeData(AffectedObject, MD_CHANGE_TYPE_SET_DATA, pmdrMDData->dwMDIdentifier);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets one metadata value.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_ACCESS_DENIED
              ERROR_PATH_NOT_FOUND
              MD_ERROR_DATA_NOT_FOUND
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by
    ComMDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            //
            // Found the object, get the data.
            //
            pbdRetrieve = pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                     pmdrMDData->dwMDAttributes,
                                                     pmdrMDData->dwMDDataType,
                                                     &pboAssociated);
        }
        else if ((hresReturn == (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            //
            // Object not found, get inheritable data.
            //
            pbdRetrieve = pboAffected->GetInheritableDataObject(pmdrMDData->dwMDIdentifier,
                                                                pmdrMDData->dwMDDataType,
                                                                &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE) pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              (PBYTE)pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [in] */ DWORD dwMDEnumDataIndex,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all metadata values once per call. Values are numbered from 0 to NumValues - 1, where
    NumValues is the number of current valules. If EnumDataIndex is >= NumValues, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, , relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_INVALID_PARAMETER
                 ERROR_PATH_NOT_FOUND
                 ERROR_ACCESS_DENIED
                 ERROR_INSUFFICIENT_BUFFER
                 ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pbdRetrieve = pboAffected->EnumDataObject(dwMDEnumDataIndex,
                                                      pmdrMDData->dwMDAttributes,
                                                      pmdrMDData->dwMDUserType,
                                                      pmdrMDData->dwMDDataType,
                                                      &pboAssociated);
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            pbdRetrieve = pboAffected->EnumInheritableDataObject(dwMDEnumDataIndex,
                                                                 pmdrMDData->dwMDUserType,
                                                                 pmdrMDData->dwMDDataType,
                                                                 &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE)pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pbdRetrieve->GetIdentifier(),
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDIdentifier = pbdRetrieve->GetIdentifier();
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDIdentifier,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a data object.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Identifier - The identifier of the data to remove.

    DataType   - Optional type of the data to remove. If specified, only data of that
                 type will be removed. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              MD_ERROR_DATA_NOT_FOUND

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
       g_rMasterResource->Lock(TSRES_LOCK_WRITE);
       CMDBaseObject *pboAffected;
       hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
       if (SUCCEEDED(hresReturn)) {
           if (pboAffected->RemoveDataObject(dwMDIdentifier, dwMDDataType, TRUE) != NULL) {
               CMDHandle * phoHandle = GetHandleObject(hMDHandle);
               MD_ASSERT(phoHandle != NULL);
               if( phoHandle != NULL ) {
                   hresReturn = ERROR_SUCCESS;
                   g_dwSystemChangeNumber++;
                   phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwMDIdentifier);
               }
               else {
                   hresReturn = MD_ERROR_DATA_NOT_FOUND;
               }
           }
           else {
               hresReturn = MD_ERROR_DATA_NOT_FOUND;
           }
       }
       g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        /* [in] */ DWORD dwMDBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all data associated with a Meta Object.

Arguments:

    Handle     - METADATA_MASTER_ROOT_HANDLE or a handle returned by ComMDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be returned. Se imd.h.

    DataType   - The Type of the data. If not set to ALL_METADATA only metadata
                 of the specified Data Type will be returned. See imd.h.

    NumDataEntries - On successful output, specifes the number of entries copied to Buffer.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if ERROR_SUCCESS or ERROR_INSUFFICIENT_BUFFER is returned. See ComMDGetDataSetNumber.

    BufferSize     - The size in bytes of buffer. If the return code is ERROR_INSUFFICIENT_BUFFER, this contains
                     the number of bytes needed.

    Buffer         - Buffer to store the data. On successful return it will
                     contain an array of METADATA_GETALL_RECORD.

    RequiredBufferSize - If ERROR_INSUFFICIENT_BUFFER is returned, This contains
        the required buffer length, in bytes.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use
    a handle returned by ComMDOpenMetaObject.

    DWORD data is aligned on non-Intel platforms. This may not hold true on remote clients.
--*/
{
    BOOL fUseInternalStructure = !!(dwMDAttributes & METADATA_REFERENCE);
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDataSetNumber();
            }
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboAffected != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDescendantDataSetNumber();
            }
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              dwMDAttributes,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              bInheritableOnly);
            PBYTE pbEnd = pbBuffer + dwMDBufferSize;
            PBYTE pbDataStart;
            if (fUseInternalStructure)
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_INTERNAL_RECORD));
            }
            else
            {
                pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_RECORD));
            }
            PBYTE pbNextDataStart = pbDataStart;

            for (i = 0;
                 (i < dwNumDataObjects) ;
                 i++, pbDataStart = pbNextDataStart) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                DWORD dwDataLen = pbdCurrent->GetDataLen(bUnicode);
                PBYTE pbData = (PBYTE)(pbdCurrent->GetData(bUnicode));
                CMDBaseObject *pboAssociated;
                BUFFER bufData;
                STRAU strData;
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                    METADATA_REFERENCE) == 0) {
                    if ((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) != 0) {
                        //
                        // First do a get to get the metaobject associated with this data object
                        //
                        if (bInheritableOnly) {
                            MD_REQUIRE(pboAffected->GetInheritableDataObject(pbdCurrent->GetIdentifier(),
                                                                               pbdCurrent->GetDataType(),
                                                                               &pboAssociated) != NULL);
                        }
                        else {
                            MD_REQUIRE(pboAffected->GetDataObject(pbdCurrent->GetIdentifier(),
                                                                  dwMDAttributes,
                                                                  pbdCurrent->GetDataType(),
                                                                  &pboAssociated) != NULL);
                        }

                        hresReturn= InsertPathIntoData(&bufData,
                                                       &strData,
                                                       &pbData,
                                                       &dwDataLen,
                                                       pbdCurrent,
                                                       hMDHandle,
                                                       pboAssociated,
                                                       bUnicode);
                    }
                    pbNextDataStart = (pbDataStart + dwDataLen);

                    // The following will ensure that the pointer remains on a DWORD boundary.

                    pbNextDataStart = (PBYTE)(((DWORD_PTR)pbNextDataStart + 3) & ~((DWORD_PTR)(3)));

                }
                if (SUCCEEDED(hresReturn)) {
                    if (pbEnd < pbNextDataStart) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else {
                        if (fUseInternalStructure)
                        {
                            if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                                METADATA_REFERENCE) == 0) {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                                MD_COPY(pbDataStart, pbData, dwDataLen);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            }
                            else {
                                MD_ASSERT((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) == 0);
                                MD_ASSERT(pbdCurrent->GetData(bUnicode) != NULL);
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].pbMDData = (PBYTE)pbdCurrent->GetData(bUnicode);
                                pbdCurrent->IncrementReferenceCount();
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataTag = pbdCurrent->GetMappingId();
                            }
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                        else
                        {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                            MD_COPY(pbDataStart, pbData, dwDataLen);
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                        }
                    }
                }
            }
            FreeMainDataBuffer(ppvMainDataBuf);
            if (SUCCEEDED(hresReturn)) {
                *pdwMDNumDataEntries = dwNumDataObjects;
                if ((dwNumDataObjects > 0) &&
                    (dwMDAttributes & METADATA_ISINHERITED) &&
                    (dwMDAttributes & METADATA_INHERIT)) {
                    //
                    // Set the ISINHERITED flag
                    //
                    if (bInheritableOnly) {
                        for (i = 0; i < dwNumDataObjects; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }
                    }
                    else {

                        ppvMainDataBuf = GetMainDataBuffer();

                        dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                                          dwMDAttributes & ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                                          dwMDUserType,
                                                                          dwMDDataType,
                                                                          bInheritableOnly);

                        //
                        // Current implementation puts the local items first
                        // So just set the rest to inherited
                        //
                        // DBG loop asserts that the implementation has not changed.
                        //

                        #if DBG
                        for (i = 0; i < dwNumDataObjects ; i++) {
                            pbdCurrent = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                            MD_ASSERT(pbdCurrent != NULL);
                            if (fUseInternalStructure)
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                            else
                            {
                                MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier);
                            }
                        }
                        #endif //DBG

                        for (i = dwNumDataObjects; i < *pdwMDNumDataEntries; i++) {
                            if (fUseInternalStructure)
                            {
                                ((PMETADATA_GETALL_INTERNAL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                            else
                            {
                                ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                            }
                        }

                        FreeMainDataBuffer(ppvMainDataBuf);
                    }
                }
            }
            *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - pbBuffer);
            #ifndef _X86_
            //
            // Alignment fluff. Alignment could cause up to 3 bytes to be added to
            // the total needed if the buffer size ends in a different modulo 4
            // than the one passed in.
            //
            if (FAILED(hresReturn)) {
                *pdwMDRequiredBufferSize +=3;
            }
            #endif
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
{
    HRESULT hresReturn;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDHandle *phoHandle;
    CMDBaseObject *pboAffected;
    DWORD dwCurrentDataID;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            MD_REQUIRE((phoHandle = GetHandleObject(hMDHandle)) != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              METADATA_NO_ATTRIBUTES,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              FALSE);
            for (i = 0; i < dwNumDataObjects ; i++) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                dwCurrentDataID = pbdCurrent->GetIdentifier();
                MD_REQUIRE(pboAffected->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
            }
            if (dwNumDataObjects > 0) {
                g_dwSystemChangeNumber++;
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              pszMDSourcePath,
                              hMDDestHandle,
                              pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              (PBYTE)pszMDSourcePath,
                              hMDDestHandle,
                              (PBYTE)pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination object.
    Optionally copies inherited data based on the value of Attributes.

Arguments:

    SrcHandle  - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    SrcPath    - The path of the meta object with which then source data is associated, relative to the
                 path of SrcHandle.

    DestHandle - A handle returned by MDOpenMetaObject with write permission.

    DestPath   - The path of the meta object for data to be copied to, relative to the path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be copied. See imd.h.

    DataType   - Optional type of the data to copy. If not set to ALL_METADATA,
                 only data of that type will be copied.

    CopyFlag   - If true, data will be copied. If false, data will be moved.
                 Must be true if METADATA_INHERIT is set.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid source handle if CopyFlag == TRUE,
        but provides no gaurantee that other threads will not also change
        things. If a consistent data state is desired, use a handle returned by
        MDOpenMetaObject. METADATA_MASTER_ROOT_HANDLE is not a valid destination
        handle.

    If inherited data is copied, it will be copied to the destination object,
        not the corresponding ancestor objects.
--*/
{
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseObject *pboSource = NULL, *pboDest = NULL;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        hresReturn = E_INVALIDARG;
    }
    else {
        //
        // Lock for source object. If copying, just get read lock. If moving,
        // Need write lock.
        //
        g_rMasterResource->Lock((bMDCopyFlag) ? TSRES_LOCK_READ : TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboSource,
                                       hMDSourceHandle,
                                       ((bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE),
                                       (LPSTR)pszSourcePath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboSource != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf,
                                                            dwMDAttributes,
                                                            dwMDUserType,
                                                            dwMDDataType,
                                                            bInheritableOnly);
            g_rMasterResource->Convert(TSRES_CONV_WRITE);
            hresReturn = GetObjectFromPath(pboDest,
                                           hMDDestHandle,
                                           METADATA_PERMISSION_WRITE,
                                           (LPSTR)pszDestPath,
                                           bUnicode);
            if (SUCCEEDED(hresReturn)) {
                for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
                    pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                    MD_ASSERT(pbdCurrent != NULL);
                    hresReturn = pboDest->SetDataObject(pbdCurrent);
                    if (SUCCEEDED(hresReturn)) {
                        MD_ASSERT(GetHandleObject(hMDDestHandle) != NULL);
                        GetHandleObject(hMDDestHandle)->SetChangeData(pboDest,
                                                                      MD_CHANGE_TYPE_SET_DATA,
                                                                      pbdCurrent->GetIdentifier());
                    }
                }
                if ((!bMDCopyFlag) && (SUCCEEDED(hresReturn))) {
                    for (i = 0; i < dwNumDataObjects; i++) {
                        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                        MD_ASSERT(pbdCurrent != NULL);
                        MD_REQUIRE(pboSource->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                        MD_ASSERT(GetHandleObject(hMDSourceHandle) != NULL);
                        GetHandleObject(hMDSourceHandle)->SetChangeData(pboSource,
                                                                        MD_CHANGE_TYPE_DELETE_DATA,
                                                                        pbdCurrent->GetIdentifier());
                    }
                }
                g_dwSystemChangeNumber++;
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{

    return ComMDGetMetaDataPathsD(hMDHandle,
                                  pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetMetaDataPathsD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  (PBYTE)pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsD(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    IN BOOL bUnicode)
{
    HRESULT hresReturn = S_OK;
    CMDHandle * phMDHandle;
    CMDBaseObject *pboAssociated;
    CMDBaseObject *pboHandle;
    LPSTR pszPath = (LPSTR)pszMDPath;
    DWORD i, dwNumMetaObjects;
    DWORD dwBytesPerChar = ((bUnicode) ? sizeof(WCHAR) : sizeof(char));

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDBufferSize != 0) && (pszMDBuffer == NULL)) ||
             (dwMDDataType >= INVALID_END_METADATA) ||
             (pdwMDRequiredBufferSize == NULL)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        hresReturn = GetObjectFromPath(pboAssociated, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            PBYTE pbDataStart = pszMDBuffer;
            PBYTE pbNextDataStart = pbDataStart;
            PBYTE pbDataEnd = pszMDBuffer + (dwMDBufferSize * dwBytesPerChar);
            CMDBaseObject *pboCurrent;
            BUFFER bufPath;
            BUFFER bufMainDataBuf;
            DWORD dwReturn;

            phMDHandle = GetHandleObject(hMDHandle);
            if( !phMDHandle )
            {
                return E_FAIL;
            } 

            pboHandle = phMDHandle->GetObject();
            MD_ASSERT(pboHandle != NULL);
            dwNumMetaObjects = 0;

            hresReturn = pboAssociated->GetDataRecursive(&bufMainDataBuf,
                                                         dwMDIdentifier,
                                                         dwMDDataType,
                                                         dwNumMetaObjects);

            if (SUCCEEDED(hresReturn)) {

                if (dwNumMetaObjects != 0) {


                    CMDBaseObject **ppboList = (CMDBaseObject **)bufMainDataBuf.QueryPtr();

                    for (i = 0;
                         (i < dwNumMetaObjects) &&
                             ( SUCCEEDED(hresReturn) ||
                               hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
                         i++, pbDataStart = pbNextDataStart) {
                        pboCurrent=ppboList[i];
                        MD_ASSERT(pboCurrent != NULL);
                        DWORD dwStringLen = 0;

                        dwReturn = GetObjectPath(pboCurrent,
                                                 &bufPath,
                                                 dwStringLen,
                                                 pboHandle,
                                                 bUnicode);
                        if (dwReturn != ERROR_SUCCESS) {
                            //
                            // Only blow away previous hresReturn if this failed.
                            //
                            hresReturn = RETURNCODETOHRESULT(dwReturn);
                        }
                        else {

                            //
                            // Need 2 extra characters for "/"
                            //

                            pbNextDataStart = pbDataStart + ((dwStringLen + 2) * dwBytesPerChar);
                            if (pbDataEnd < pbNextDataStart) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                            }
                            else {
                                MD_COPY(pbDataStart,
                                        bufPath.QueryPtr(),
                                        dwStringLen * dwBytesPerChar);
                                if (bUnicode) {
                                    *(((LPWSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETERW;
                                    *(((LPWSTR)pbDataStart) + (dwStringLen + 1)) = (WCHAR)'\0';
                                }
                                else {
                                    *(((LPSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETER;
                                    *(((LPSTR)pbDataStart) + (dwStringLen + 1)) = (CHAR)'\0';
                                }
                            }
                        }
                    }
                    //
                    // Append a final 0 for double NULL termination
                    //
                    pbNextDataStart = pbDataStart + dwBytesPerChar;
                    if (SUCCEEDED(hresReturn)) {
                        if ((pbDataStart + dwBytesPerChar) <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                else {
                    if (pszMDBuffer != NULL) {
                        //
                        // If NULL, just return success
                        // No strings, need to append 2 0's for double NULL termination
                        //

                        pbNextDataStart = pbDataStart + (dwBytesPerChar * 2);
                        if (pbNextDataStart <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)'\0';
                                *(((LPWSTR)pbDataStart) + 1) = (WCHAR)'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                                *(((LPSTR)pbDataStart) + 1) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                    *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - (PBYTE)pszMDBuffer) / dwBytesPerChar;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAccessRequested,
        /* [in] */ DWORD dwMDTimeOut,
        /* [out] */ PMETADATA_HANDLE phMDNewHandle,
        IN BOOL bUnicode)
/*++

Routine Description:

    Opens a meta object for read and/or write access. The returned handle is
        used by several of the other API's. Opening an object for Read access
        guarantees that that view of the data will not change while the object
        is open. Opening an object for write gaurantees that no other objects
        will read or write any changed data until the handle is closed.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject.

    Path            - The path of the object to be opened.

    AccessRequested - The permissions requested. See imd.h.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    NewHandle - The handled to be passed to other MD routines.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_PATH_BUSY

Notes:
    Multiple read handles or a single  write handle can be open on any given
    object.
    Opens for read will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for write.
    Opens for write will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for read and/or write.

    If the request is for write access or Handle has write access, Handle must be closed before
    this request can succeed, unless Handle = METADATA_MASTER_ROOT_HANDLE.
    Handles should be closed as quickly as possible, as open handles can cause other requests to block.
--*/
{
    HRESULT hresReturn;
    DWORD WaitRetCode;
    METADATA_HANDLE mhTemp;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((phMDNewHandle == NULL) ||
             ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        CMDBaseObject *pboOpen = NULL;
        GetSystemTimeAsFileTime(&TempTime);
        ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) +
                      (_int64)TempTime.dwLowDateTime +
                      ((_int64)dwMDTimeOut * 10000);
        TimeLeft = dwMDTimeOut;
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
        }
        //
        // Spin loop waiting for permissions. Events get pulsed whenever a handle is closed.
        // Use a wait interval in case the close comes between the Unlock and the Wait.
        //
        while ((SUCCEEDED(hresReturn)) && (!bPermissionsAvailable) && (TimeLeft > 0)) {
            g_rMasterResource->Unlock();
            if (dwMDAccessRequested & METADATA_PERMISSION_WRITE) {
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            else {
                WaitRetCode = WaitForSingleObject(g_phEventHandles[EVENT_WRITE_INDEX], LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            GetSystemTimeAsFileTime(&TempTime);

            CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
            TimeLeft = ((ExpireTime - CurrentTime) / 10000);
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            //
            // Get object again to make sure the object hasn't been deleted
            // Should probably put an exception handler PermissionsAvailable and use
            // the current object
            //
            hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
            }
        }
        if (SUCCEEDED(hresReturn))  {
            if (bPermissionsAvailable) {
                hresReturn = AddHandle(pboOpen, dwMDAccessRequested, mhTemp);
                if (SUCCEEDED(hresReturn)) {
                    *phMDNewHandle = mhTemp;
                }
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Closes a handle to a meta object. If the handle was opened with write
    permission and changes have been made via this handle, this will cause all
    registered callback functions to be called.

Arguments:

    Handle  - The handle returned by MDOpenMetaObject.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE

--*/
{
    HRESULT hresReturn;
    CMDHandle *hoTemp = NULL;
    BOOL bPulseWrite = FALSE;
    BOOL bPulseRead = FALSE;
    BOOL bSendNotifications = FALSE;
    BOOL bDeleteChangeData = FALSE;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) ||
        ((hoTemp = RemoveHandleObject(hMDHandle)) == NULL)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        if (hoTemp->IsWriteAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            bPulseWrite = TRUE;
            bSendNotifications = TRUE;
            bDeleteChangeData = TRUE;
        }
        if (hoTemp->IsReadAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            bPulseRead = TRUE;
        }
        if (bPulseWrite) {
            bPulseWrite = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
        }
        if (bPulseRead && !bPulseWrite) {
            //
            // A write pulse activates everyone, so only do this if we didn't already do a write pulse
            //
            bPulseRead = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
        }
        if (bSendNotifications) {
            g_rMasterResource->Convert(TSRES_CONV_READ);
            if (FAILED(CreateNotifications(hoTemp,
                                           &dwNumChangeEntries,
                                           &pcoBuffer,
                                           &ppbufStorageArray))) {
                bSendNotifications = FALSE;
            }
        }

        hresReturn = ERROR_SUCCESS;
    }
    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                          dwNumChangeEntries,
                          pcoBuffer,
                          ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);
    }

    if (bDeleteChangeData) {

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    }

    delete (hoTemp);

    if (bDeleteChangeData) {
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle. If the handle had write permission and is being changed
    to read only, this will cause all registered callback functions to be called.

Arguments:

    Handle  - The handle to be modified.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    AccessRequested - The requested permissions. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
              ERROR_PATH_BUSY

Notes:
    Success or failure when adding permissions follows the same rules as OpenMetaObject.
    TimeOut values should be short for this call, as it is quite possible for 2 threads
    with read permission on the same data to attempt to update to write at the same time.
    Both will block until one read handle is closed.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoTemp;
    DWORD WaitRetCode;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    BOOL bAddRead, bAddWrite, bRemoveRead, bRemoveWrite;
    BOOL bEventPulsed = FALSE;
    BOOL bSendNotifications = FALSE;
    CMDHandle *phoNotifyHandle;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) || ((hoTemp = GetHandleObject(hMDHandle)) == NULL) ||
        ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else if ((hoTemp = GetHandleObject(hMDHandle)) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        bAddRead = (!(hoTemp->IsReadAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_READ));
        bAddWrite = (!(hoTemp->IsWriteAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_WRITE));
        bRemoveRead = ((hoTemp->IsReadAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_READ));
        bRemoveWrite = ((hoTemp->IsWriteAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_WRITE));

        MD_ASSERT(!(bAddRead && bAddWrite));
        MD_ASSERT(!(bRemoveRead && bRemoveWrite));
        MD_ASSERT(!(bAddRead && bRemoveRead));
        MD_ASSERT(!(bAddWrite && bRemoveWrite));

        //
        // Add permissions first, because if delete comes first, another
        // object could open a handle to this in the interim, and the
        // object could get deleted.
        // Also, AddWrite can fail so it must be before RemoveRead
        // to avoid partial completion.
        //

        if (bAddWrite) {
            MD_ASSERT(hoTemp->IsReadAllowed());
            GetSystemTimeAsFileTime(&TempTime);
            ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime + ((_int64)dwMDTimeOut * 10000);
            TimeLeft = dwMDTimeOut;
            bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
            while ((!bPermissionsAvailable) && (TimeLeft > 0) && (hoTemp!=NULL)) {
                g_rMasterResource->Unlock();
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
                GetSystemTimeAsFileTime(&TempTime);
                CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
                TimeLeft = ((ExpireTime - CurrentTime) / 10000);
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                //
                // The meta object could not have been deleted while the handle is open
                // but the handle object could have been deleted, so get it again.
                //
                hoTemp = GetHandleObject(hMDHandle);
                if (hoTemp != NULL) {
                    bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
                }
            }
            if (hoTemp == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
            }
            else if (!bPermissionsAvailable) {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
            else {
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (bAddRead) {
                MD_ASSERT(hoTemp->IsWriteAllowed());
                //
                // Must already have write access
                // Just add read access
                //
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            }
            if (bRemoveRead) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
            }
            if (bRemoveWrite) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
            }
            hoTemp->SetPermissions(dwMDAccessRequested);
        }
    }
    if ((SUCCEEDED(hresReturn)) && bRemoveWrite) {
        if (SUCCEEDED(CreateNotifications(hoTemp,
                                          &dwNumChangeEntries,
                                          &pcoBuffer,
                                          &ppbufStorageArray))) {
            phoNotifyHandle = new CMDHandle(hoTemp);
            if (phoNotifyHandle == NULL) {
                DeleteNotifications(dwNumChangeEntries,
                                    pcoBuffer,
                                    ppbufStorageArray);
            }
            else {
                bSendNotifications = TRUE;
                hoTemp->ZeroChangeList();
            }
        }
        hoTemp->RemoveNotifications();
    }
    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                  dwNumChangeEntries,
                  pcoBuffer,
                  ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        delete (phoNotifyHandle);
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSaveData(
            IN METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              Errors returned by the file system.
Notes:
    If the main file has been modified by other applications, this call will overwrite them.

--*/
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        hresReturn = InitStorageAndSessionKey(
                         &CryptoStorage,
                         &pSessionKeyBlob
                         );

        if( SUCCEEDED(hresReturn) ) {
            if (g_dwInitialized == 0) {
                hresReturn = MD_ERROR_NOT_INITIALIZED;
            }
            else {
                hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, NULL, hMDHandle);
//                RetCode = SaveAllDataToRegistry();
            }
            ::IISCryptoFreeBlob(pSessionKeyBlob);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo)
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    Handle  - The handle to get information about.

    Info    - Structure filled in with the information. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
Notes:
    pmdhiInfo->dwMDSystemChangeNumber will correspond to the System Change Number at the time
    the handle was created. It will not change if writes are done via this handle, or any other
    handle. A client can compare this number with the value returned by MDGetSystemChangeNumber
    to see if any writes have been done since the handle was opened.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *HandleObject;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pmdhiInfo == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        HandleObject = GetHandleObject(hMDHandle);
        if (HandleObject == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else {
            HandleObject->GetHandleInfo(pmdhiInfo);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber)
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    SystemChangeNumber - The system change number. This is incremented every time the metadata is updated.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwSystemChangeNumber == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        *pdwSystemChangeNumber = g_dwSystemChangeNumber;
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  pszMDPath,
                                  pdwMDDataSetNumber,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  pdwMDDataSetNumber,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if successful.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
All paths with the same data set number have identical data if inherited data is included.
The inverse is not true, eg. there may be paths with identical data but different data set numbers.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwMDDataSetNumber == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            *pdwMDDataSetNumber=pboQueried->GetDataSetNumber();
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL)) {
            *pdwMDDataSetNumber=pboQueried->GetDescendantDataSetNumber();
            hresReturn = ERROR_SUCCESS;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddRefReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    AddRefs data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        #if DBG
            //
            // Make sure this is in the table
            //
            CMDBaseData *pbdAddRef = (CMDBaseData *)g_PointerMapper->FindMapping(dwMDDataTag);

            DWORD dwHash = DATA_HASH(pbdAddRef->GetIdentifier());
            CMDBaseData *pbdIndex;
            BOOL bFound = FALSE;

            if (g_ppbdDataHashTable[dwHash] == pbdAddRef) {
                bFound = TRUE;
            }
            else {
                for (pbdIndex=g_ppbdDataHashTable[dwHash];
                    (pbdIndex != NULL ) && (pbdIndex->GetNextPtr() != pbdAddRef);
                    pbdIndex = pbdIndex->GetNextPtr()) {
                }
                if (pbdIndex != NULL) {
                    bFound = TRUE;
                }
            }
            if (!bFound) {
                MD_ASSERT(FALSE);
            }
        #endif

        ((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)))->IncrementReferenceCount();

        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDReleaseReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    Releases data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        DeleteDataObject((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)));
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - The new change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboAffected->SetLastChangeTime(pftMDLastChangeTime);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - Place to return the change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    PFILETIME pftTemp;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if ((SUCCEEDED(hresReturn)) ||
            ((hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL))) {
            pftTemp = pboQueried->GetLastChangeTime();
            *pftMDLastChangeTime = *pftTemp;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        FALSE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupWithPasswdW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd)
{
    STRAU strauPasswd;
        
    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE,
                        strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupD(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL bUnicode,
            /* [in] */ LPSTR pszPasswd)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarning = ERROR_SUCCESS;
    IIS_CRYPTO_STORAGE * pCryptoStorage = NULL;
    PIIS_CRYPTO_BLOB pSessionKeyBlob = NULL;
    OFSTRUCT ReOpenBuff;

    STRAU strauBackupLocation;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDFlags & !(MD_BACKUP_OVERWRITE |
                           MD_BACKUP_SAVE_FIRST |
                           MD_BACKUP_FORCE_BACKUP)) != 0) ||
             (((dwMDFlags & MD_BACKUP_SAVE_FIRST) == 0) &&
                 ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        if( dwMDFlags == 0 )
        {
            dwMDFlags = MD_BACKUP_SAVE_FIRST;
        }

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation);
        if( FAILED( hresReturn ) )
        {
            return hresReturn;
        }

        MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

        if( ( ( dwMDFlags & MD_BACKUP_OVERWRITE ) == 0 ) &&
            ( HFILE_ERROR != OpenFile( strauBackupLocation.QueryStr(FALSE),
                                       &ReOpenBuff,
                                       OF_EXIST ) ) )
        {
            return HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        } 

        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0 || pszPasswd != NULL) {

            if( !pszPasswd )
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey(
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }
            else
            {
                pCryptoStorage = new IIS_CRYPTO_STORAGE2;
                if( !pCryptoStorage )
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    hresReturn = InitStorageAndSessionKey2(
                                     pszPasswd,
                                     pCryptoStorage,
                                     &pSessionKeyBlob
                                     );
                }
            }

            if( SUCCEEDED(hresReturn) ) {
                if (g_dwInitialized == 0) {
                    hresReturn = MD_ERROR_NOT_INITIALIZED;
                }
                else {
                    if( !pszPasswd )
                    {
                        hresReturn = SaveAllData(FALSE, 
                                                 pCryptoStorage, 
                                                 pSessionKeyBlob, 
                                                 NULL,
                                                 hMDHandle, 
                                                 TRUE 
                                                 );
                    }
                    else
                    {
                        hresReturn = SaveAllData(FALSE, 
                                                 pCryptoStorage, 
                                                 pSessionKeyBlob, 
                                                 strauBackupLocation.QueryStr(FALSE),
                                                 hMDHandle, 
                                                 TRUE
                                                 );
                    }
                }

                if( !pszPasswd )
                {
                    ::IISCryptoFreeBlob(pSessionKeyBlob);
                }
                else
                {
                    ::IISCryptoFreeBlob2(pSessionKeyBlob);
                }
            }
            if (FAILED(hresReturn)) {
                hresWarning = MD_WARNING_SAVE_FAILED;
            }
        }

        if (SUCCEEDED(hresReturn) || ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0)) {

            //
            // Copy the file
            //

            if ( !pszPasswd ) {
                BOOL bFailIfExists = ((dwMDFlags & MD_BACKUP_OVERWRITE) == 0) ? TRUE : FALSE;

                //
                // Copy the file
                //
                if (!CopyFile(g_strRealFileName->QueryStr(),
                              strauBackupLocation.QueryStr(FALSE),
                              bFailIfExists)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hresReturn)) {

                HANDLE hTempFileHandle;

                hTempFileHandle = CreateFile(strauBackupLocation.QueryStr(FALSE),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                if (hTempFileHandle != INVALID_HANDLE_VALUE) {
                    FILETIME ftCurrent;
                    GetSystemTimeAsFileTime(&ftCurrent);
                    SetFileTime(hTempFileHandle,
                                NULL,   // Creation Time
                                &ftCurrent,   // Last AccessTime
                                &ftCurrent); // Last Change Time
                    CloseHandle(hTempFileHandle);
                }

                hresReturn = BackupCertificates ((LPCWSTR)pszMDBackupLocation,
                                                    strauBackupLocation.QueryStr(FALSE),
                                                    g_strRealFileName->QueryStr());
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }

    if( pCryptoStorage )
    {
        delete pCryptoStorage;
        pCryptoStorage = NULL;
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         FALSE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         NULL);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreWithPasswdW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd
            )
{
    STRAU strauPasswd;
        
    if( !strauPasswd.Copy( (LPWSTR)pszPasswd ) )
    {
        return E_OUTOFMEMORY;
    }

    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE,
                         strauPasswd.QueryStrA());
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL  bUnicode,
            /* [in] */ LPSTR pszPasswd
            )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((dwMDVersion == MD_BACKUP_NEXT_VERSION) ||
        (dwMDFlags != 0)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {

        //
        // Send notifications before we grab locks in case users
        // try to access metabase. It would be nice to check the
        // file name before doing this but that requires ReadSaveSemaphore.
        //
        // Send Shutdown Notification since we don't have a Restore
        // Notification and it's close enough.
        //

        SendShutdownNotifications();

        //
        // Give applications some time to close their interfaces,
        // but don't wait too long, user is waiting.
        // Wait until references are closed, unless they take too long.
        // IISADMIN and factory both have refences we do not wait for.
        //
        // We don't actually need to wait during restore, since
        // interfaces are preserved, but waiting will allow clients
        // to cleanup properly.
        //

        for (int i = 0;
             (InterlockedIncrement((long *)&m_dwRefCount) > 3) &&
                 (i < MD_SHUTDOWN_WAIT_SECONDS);
             i++) {
            InterlockedDecrement((long *)&m_dwRefCount);
            Sleep(1000);
        }

        InterlockedDecrement((long *)&m_dwRefCount);

        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation);

        if (SUCCEEDED(hresReturn)) {
            //
            // Got a valid name
            // See if the file exists
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            STR   strCopyOfMetabaseFileName (*g_strRealFileName);

            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                FindClose(hFile);
                //
                // File actually exists,
                // Go ahead and restore.
                //
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                //
                // Need to do the file copy before Terminate
                // so the global variables are still set.
                // Also good to not terminate if it fails.
                //
                if (!pszPasswd && !CopyFile(strauBackupLocation.QueryStr(FALSE),
                                            g_strRealFileName->QueryStr(),
                                            FALSE)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
                else {
                    //
                    // Prevent saves during termination.
                    //
                    BOOL bPrevSaveDisallowed = g_bSaveDisallowed;
                    g_bSaveDisallowed = TRUE;
                    static DWORD dwInitializedSave = 0;
                    if( g_dwInitialized != 0 )
                    {
                        dwInitializedSave = g_dwInitialized;

                        while (g_dwInitialized > 0) {
                            TerminateWorker1(TRUE);
                        }
                    }

                    g_bSaveDisallowed = bPrevSaveDisallowed;

                    while (SUCCEEDED(hresReturn) && (g_dwInitialized < dwInitializedSave))
                    {
                        hresReturn = InitWorker(TRUE, 
                                                pszPasswd, 
                                                strauBackupLocation.QueryStr(FALSE));
                    }

                    if( SUCCEEDED(hresReturn) )
                    {
                        RestoreCertificates ((LPCWSTR)pszMDBackupLocation,
                                              strauBackupLocation.QueryStr(FALSE),
                                              strCopyOfMetabaseFileName.QueryStr());
                    }
                }

                if( pszPasswd )
                {
                    //
                    // Need to flush the newly restored data out
                    //
                    g_dwSystemChangeNumber++;
                }

                g_rMasterResource->Unlock();

                //
                // At this point all old handles are invalidated
                // and all no new handles have been opened.
                // So tell clients to invalidate any open handles now.
                //

                if (SUCCEEDED(hresReturn)) {
                    SendEventNotifications(MD_EVENT_MID_RESTORE);
                }
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

        //
        // Try to load metadata from metabase.bin file on failure        
        //
        if( FAILED( hresReturn ) )
        {
            InitWorker(FALSE, NULL, NULL);
        }
        else if( pszPasswd )
        {
            //
            // Need to flush newly restored data to Metabase.bin file 
            //
            hresReturn = ComMDSaveData( METADATA_MASTER_ROOT_HANDLE );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsD(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((pszMDBackupLocation == NULL) ||
        (pdwMDVersion == NULL)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        if (!strauBackupLocation.Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!strauBackupLocation.Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (*(LPWSTR)pszMDBackupLocation == (WCHAR)'\0') {
                    if (!strauBackupLocation.Append(L"*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPWSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
            else {
                if (*(LPSTR)pszMDBackupLocation == '\0') {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }
        if (SUCCEEDED(hresReturn)) {
            if (SUCCEEDED(hresReturn)) {
                if (!strauBackupLocation.Append(MD_BACKUP_SUFFIX)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else {

                        //
                        // Make sure MultiByte string is valid
                        //

                        if (strauBackupLocation.QueryStrA() == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Successfully created the search name
            // Enumerate files
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            DWORD dwEnumIndex = (DWORD) -1;
            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                if (CheckDigits(wfdFile.cFileName +
                                GetBackupNameLen(wfdFile.cFileName) +
                                (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                    dwEnumIndex++;
                }
                while (SUCCEEDED(hresReturn) && (dwEnumIndex != dwMDEnumIndex)) {
                    //
                    // Process the remaining files
                    //
                    if (FindNextFile(hFile, &wfdFile)) {
                        if (CheckDigits(wfdFile.cFileName +
                                        GetBackupNameLen(wfdFile.cFileName) +
                                        (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                            //
                            // One of our files
                            //
                            dwEnumIndex++;
                        }
                    }
                    else {
                        hresReturn = GetLastHResult();
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                //
                // Found the file
                // File name is in wfdFile.cFileName
                // Time is in wfdFile.ftLastWriteTime
                // Need to separate the name and version
                // Reuse strauBackupLocation
                //

                DWORD dwNameLen;
                if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                    (strauBackupLocation.QueryStrW() == NULL))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    //
                    // ANSI bytes might not equal characters, so use unicode
                    //
                    dwNameLen = GetBackupNameLen(strauBackupLocation.QueryStrW());
                    strauBackupLocation.SetLen(dwNameLen);
                    if (strauBackupLocation.QueryCB(bUnicode) >
                        (MD_BACKUP_MAX_LEN * ((bUnicode) ? sizeof(WCHAR) : sizeof(char)))) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                    }
                    else {
                        MD_COPY(pszMDBackupLocation,
                                strauBackupLocation.QueryStr(bUnicode),
                                strauBackupLocation.QueryCB(bUnicode) +
                                    ((bUnicode) ? sizeof(WCHAR) : sizeof(char)));
                        *pdwMDVersion = atol(wfdFile.cFileName +

                                             //
                                             // dwNameLen is # characters
                                             // Need to add # bytes, so
                                             // Get it from STRAU
                                             //

                                             strauBackupLocation.QueryCBA() +
                                             (sizeof(MD_BACKUP_SUFFIX) - 1));
                        MD_COPY(pftMDBackupTime,
                                &(wfdFile.ftLastWriteTime),
                                sizeof(FILETIME));
                    }
                }
            }
            else {
                if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                    (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
                }
            }
        }

        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (dwMDVersion == MD_BACKUP_NEXT_VERSION) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation);

        if (SUCCEEDED(hresReturn)) {
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

            //
            // Delete the file
            //

            if (!DeleteFile(strauBackupLocation.QueryStr(FALSE))) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDExportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags)
{
    return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDImportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszDestPath,
            /* [string][in][unique] */ LPCWSTR pszKeyType,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags)
{
    return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreHistoryW(
            /* [unique][in][string] */ LPCWSTR pszMDHistoryLocation,
            /* [in] */ DWORD dwMDMajorVersion,
            /* [in] */ DWORD dwMDMinorVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumHistoryW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDHistoryLocation,
            /* [out] */ DWORD *pdwMDMajorVersion,
            /* [out] */ DWORD *pdwMDMinorVersion,
            /* [out] */ PFILETIME pftMDHistoryTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CMDCOM::NotifySinks(METADATA_HANDLE hHandle,
                    PMD_CHANGE_OBJECT pcoChangeList,
                    DWORD dwNumEntries,
                    BOOL bUnicode,
                    DWORD dwNotificationType,
                    DWORD dwEvent)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* pIConnectionPoint;
  IEnumConnections* pIEnum;
  CONNECTDATA ConnData;
  HRESULT hrTemp;


  FlushSomeData ();

  //
  // Correct broken connections.
  // It's not likely to be a high number so
  // save a memory allocation by using an array.
  //
  DWORD pdwLostConnections[10];
  DWORD dwNumLostConnections = 0;

  // If there was a paper event, broadcast appropriate notifications to
  // all Sinks connected to each connection point.
//  if (PAPER_EVENT_NONE != PaperEvent)
  {
      if (bUnicode) {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
      }
      else {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
      }
      if (NULL != pIConnectionPoint)
      {
          pIConnectionPoint->AddRef();
          g_rSinkResource->Lock(TSRES_LOCK_READ);
          hr = pIConnectionPoint->EnumConnections(&pIEnum);
          if (SUCCEEDED(hr)) {
              // Loop thru the connection point's connections and if the
              // listening connection supports IPaperSink (ie, PaperSink events)
              // then dispatch the PaperEvent event notification to that sink.
              while (NOERROR == pIEnum->Next(1, &ConnData, NULL))
              {
                IMDCOMSINK* pIMDCOMSINK;

                if (bUnicode) {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_W,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                else {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_A,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                if (SUCCEEDED(hr))
                {
                    switch (dwNotificationType) {
                        case MD_SINK_MAIN: {
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_W)pcoChangeList);
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_A)pcoChangeList);
                            }
                        }
                        break;
                        case MD_SINK_SHUTDOWN: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                        }
                        break;
                        case MD_SINK_EVENT: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDEventNotify(dwEvent);
                            }
                            else {
                                DBG_ASSERT(FALSE);
                            }
                        }
                        break;
                        default: {
                            DBG_ASSERT(FALSE);
                        }
                    }

                    pIMDCOMSINK->Release();
                    if (FAILED(hrTemp)) {
                        if ((HRESULT_CODE(hrTemp) == RPC_S_SERVER_UNAVAILABLE) ||
                            ((HRESULT_CODE(hrTemp) >= RPC_S_NO_CALL_ACTIVE) &&
                                (HRESULT_CODE(hrTemp) <= RPC_S_CALL_FAILED_DNE))) {
                            if (dwNumLostConnections < 10) {
                                pdwLostConnections[dwNumLostConnections++] = ConnData.dwCookie;
                            }
                        }
                    }
                }
                ConnData.pUnk->Release();
              }
              pIEnum->Release();
          }
          g_rSinkResource->Unlock();
          while (dwNumLostConnections > 0) {
              pIConnectionPoint->Unadvise(pdwLostConnections[--dwNumLostConnections]);
          }
          pIConnectionPoint->Release();
      }
  }

  return hr;
}

HRESULT
CMDCOM::ConvertNotificationsToDBCS(DWORD dwNumChangeEntries,
                                   BUFFER **ppbufStorageArray)
{
    HRESULT hresReturn = S_OK;
    //
    // ppbufStorageArray is an array of buffer pointers,
    // where each buffer contains a UNICODE path string
    // which needs to be converted to a Local System path string
    //

    STRAU strauPath;
    STRAU strauPathOptional;
    LPSTR pszDBCSPath;
    LPSTR pszDBCSPathOptional;
    LPSTR pmultiszTarget;
    DWORD dwStrLen1,dwStrLen2 = 0;

    for (DWORD i = 0; i < dwNumChangeEntries; i++) {
        MD_ASSERT(ppbufStorageArray[i] != NULL);

        pmultiszTarget = (LPSTR) ppbufStorageArray[i]->QueryPtr();
        if (!strauPath.Copy((LPWSTR)pmultiszTarget))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            if ((PWORD)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR)))
            {
                if (!strauPathOptional.Copy((LPWSTR)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR))))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    pszDBCSPathOptional = strauPathOptional.QueryStrA();
                    if (pszDBCSPathOptional == NULL)
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else
                    {
                        dwStrLen2 = strauPathOptional.QueryCBA() + 1 ;
                    }
                }
            }

            if (hresReturn == S_OK)
            {
                pszDBCSPath = strauPath.QueryStrA();
                if (pszDBCSPath == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    dwStrLen1 = strauPath.QueryCBA() + 1 ;

                    MD_ASSERT(ppbufStorageArray[i]->QuerySize() >= (dwStrLen1 + dwStrLen2 + sizeof(char)));

                    MD_COPY(pmultiszTarget, pszDBCSPath, dwStrLen1 );
                    if ( dwStrLen2 >0 )
                    {
                        MD_COPY(pmultiszTarget + dwStrLen1 , pszDBCSPathOptional, dwStrLen2 );
                    }
                    *(pmultiszTarget + dwStrLen1 + dwStrLen2) = '\0';
                }
            }
        }
    }
    return hresReturn;
}

VOID
CMDCOM::SendShutdownNotifications()
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_SHUTDOWN);
    NotifySinks(0,
                NULL,
                0,
                FALSE,
                MD_SINK_SHUTDOWN);
}

VOID
CMDCOM::SendEventNotifications(DWORD dwEvent)
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_EVENT,
                dwEvent);
}

VOID
CMDCOM::SendNotifications(METADATA_HANDLE hHandle,
                          DWORD dwTotalNumChangeEntries,
                          PMD_CHANGE_OBJECT_W pcoBuffer,
                          BUFFER **ppbufStorageArray
                          )
{

    DWORD dwNumChangeEntries;
    DWORD dwRemainingNumChangeEntries = dwTotalNumChangeEntries;


    MD_ASSERT(sizeof(MD_CHANGE_OBJECT_A) == sizeof(MD_CHANGE_OBJECT_W));

    while (dwRemainingNumChangeEntries != 0) {
        dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
        NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                    dwNumChangeEntries,
                    TRUE,
                    MD_SINK_MAIN);
        dwRemainingNumChangeEntries -= dwNumChangeEntries;
    }

    if (SUCCEEDED(ConvertNotificationsToDBCS(dwTotalNumChangeEntries,
                                             ppbufStorageArray))) {
        dwRemainingNumChangeEntries = dwTotalNumChangeEntries;
        while (dwRemainingNumChangeEntries != 0) {
            dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
            NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                        dwNumChangeEntries,
                        FALSE,
                        MD_SINK_MAIN);
            dwRemainingNumChangeEntries -= dwNumChangeEntries;
        }
    }
}

VOID
CMDCOM::DeleteNotifications(DWORD dwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W pcoBuffer,
                            BUFFER **ppbufStorageArray
                            )
{
    if (dwNumChangeEntries != 0 ) 
    {
        if( ppbufStorageArray != NULL )
        {
            for( DWORD i = 0; i < dwNumChangeEntries; i++ )
            {
                if (ppbufStorageArray[i] != NULL) 
                {
                    delete ppbufStorageArray[i];
                    ppbufStorageArray[i] = NULL;
                }
            }

            delete [] ppbufStorageArray;
        }

        delete pcoBuffer;
    }
}


HRESULT
CMDCOM::CreateNotifications(CMDHandle *phoHandle,
                            DWORD *pdwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W *ppcoBuffer,
                            BUFFER ***pppbufStorageArray
                            )
{
    HRESULT hRes = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    PCHANGE_ENTRY pceChange;
    DWORD i,j;
    BUFFER **ppbufStorageArray = NULL;
    DWORD dwStringLen, dwStringOldNameLen;
    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;

    dwNumChangeEntries = phoHandle->GetNumChangeEntries();
    if (dwNumChangeEntries != 0) {
        ppbufStorageArray = new BUFFER *[dwNumChangeEntries];

        if (ppbufStorageArray == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            for ( i = 0; i < dwNumChangeEntries; i++ )
            {
                ppbufStorageArray[i] = NULL;
            }

            for (i = 0; i < dwNumChangeEntries; i++) {
                ppbufStorageArray[i] = new BUFFER();
                if (ppbufStorageArray[i] == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                //
                // Create UNICODE callbacks
                //
                pcoBuffer = new MD_CHANGE_OBJECT_W[dwNumChangeEntries];
                if (pcoBuffer == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    for (i = 0;
                        (dwReturn == ERROR_SUCCESS) && (i < dwNumChangeEntries);
                         i++) {
                        MD_REQUIRE((pceChange = phoHandle->EnumChangeEntries(i)) != NULL);
                        dwStringLen = 0;
                        dwReturn = GetObjectPath(pceChange->pboChanged,
                                                 ppbufStorageArray[i],
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 TRUE);
                        if (dwReturn == ERROR_SUCCESS) {
                            dwStringOldNameLen = 0;
                            if ( pceChange->pStrOrigName !=NULL) {
                                dwStringOldNameLen = pceChange->pStrOrigName->QueryCCH ();
                            }

                            // we adding 5, because: 1 for path_delimiter first line 1 for term-zero for first line
                            // 1 for path_delimiter second line 1 for term-zero for second line
                            // and last 1 for multisz term-zero
                            if (!ppbufStorageArray[i]->Resize((dwStringLen + dwStringOldNameLen + 5 ) * sizeof(WCHAR))) {
                                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else {
                                pcoBuffer[i].dwMDChangeType = pceChange->dwChangeType;
                                pcoBuffer[i].pszMDPath = (LPWSTR)(ppbufStorageArray[i]->QueryPtr());
                                pcoBuffer[i].pszMDPath[dwStringLen] = MD_PATH_DELIMETERW;
                                pcoBuffer[i].pszMDPath[dwStringLen + 1] = (WCHAR)'\0';
                                pcoBuffer[i].pszMDPath[dwStringLen + 2] = (WCHAR)'\0';
                                if ( dwStringOldNameLen )
                                {
                                    memcpy (&(pcoBuffer[i].pszMDPath[dwStringLen + 2]),
                                            pceChange->pStrOrigName->QueryStrW(),
                                            dwStringOldNameLen * sizeof(WCHAR) );
                                    pcoBuffer[i].pszMDPath[dwStringLen + 2 + dwStringOldNameLen] = MD_PATH_DELIMETERW;
                                    pcoBuffer[i].pszMDPath[dwStringLen + 3 + dwStringOldNameLen] = (WCHAR)'\0';
                                }
                                pcoBuffer[i].dwMDNumDataIDs = pceChange->dwNumDataIDs;
                                if (pceChange->dwNumDataIDs != 0) {
                                    MD_ASSERT(pceChange->pbufDataIDs != NULL);
                                    pcoBuffer[i].pdwMDDataIDs = (DWORD *)(pceChange->pbufDataIDs->QueryPtr());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (dwReturn != ERROR_SUCCESS) {
        //
        // Free Buffers
        //
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    else {
        //
        // Pass back info
        // DeleteNotifications will be called later
        //
        *pdwNumChangeEntries = dwNumChangeEntries;
        *pppbufStorageArray = ppbufStorageArray;
        *ppcoBuffer = pcoBuffer;
    }

    if (dwReturn != ERROR_SUCCESS) {
        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    return hRes;
}






VOID CMDCOM::InitializeFlusher (VOID)
{
    if (!fFlusherInitialized)
    {
        fFlusherInitialized = TRUE;

        EnterCriticalSection( &csFlushLock );
        dwFlushCnt = 0;
        dwFlushPeriodExtensions = 0;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
        LeaveCriticalSection( &csFlushLock );

    }

}

// The algorithm for flushing changes of emtabase to ahrd disk is the following:
// when change to metabase is made, and SlushSomeData is called from NotifySinks
// counter which counts the number of changes in metabase is incremented  and first time
// the change happens work item is schedulled for scheduller to flush a metabase after 60seconds
// if during 60 seconds more than INETA_MB_FLUSH_TRESHOLD changes will happen , then metabase will not
// flush cahnges to disk, but will extend flushing period for another 60 seconds. If during another 60 secs
// number of changes will be higer than INETA_MB_FLUSH_TRESHOLD agian period will be extended
// but no more times than INETA_MB_FLUSH_PERIODS_EXTENSION
// if in some period number of changes in metabase will be less than INETA_MB_FLUSH_TRESHOLD then
// peirod will not be extended and metabase will be saved to disk


VOID WINAPI CMDCOM::MetabaseLazyFlush(
    VOID * pv
    )
/*++

    Description:

        Scheduler callback for flushing the metabase

--*/
{
    BOOL fExtendPeriod =FALSE;
    CMDCOM *pMasterObject = (CMDCOM *)pv;

    MD_ASSERT(pMasterObject != NULL);

    EnterCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized)
    {
        pMasterObject->dwMBFlushCookie = 0;
        if ( pMasterObject->dwFlushCnt > INETA_MB_FLUSH_TRESHOLD)
        {
            if ( pMasterObject->dwFlushPeriodExtensions < INETA_MB_FLUSH_PERIODS_EXTENSION)
            {
                fExtendPeriod = TRUE;
                pMasterObject->dwFlushPeriodExtensions ++;
            }
        }

        pMasterObject->dwFlushCnt = 0;
        if (!fExtendPeriod)
        {
            pMasterObject->dwFlushPeriodExtensions = 0;
        }
        else
        {
            pMasterObject->dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                               pv, //context,
                                                               pMasterObject->msMBFlushTime);
        }
    }

    LeaveCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized && !fExtendPeriod)
    {
        MB mb(pMasterObject);
        mb.Save();
    }

}

VOID CMDCOM::FlushSomeData (VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        dwFlushCnt++;
        if ( !dwMBFlushCookie )
        {
            dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                this, //context,
                                                msMBFlushTime,
                                                FALSE);
        }
    }
    LeaveCriticalSection( &csFlushLock );
}


VOID CMDCOM::TerminateFlusher(VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        fFlusherInitialized = FALSE;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
    }
    LeaveCriticalSection( &csFlushLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\globals.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS MetaBase global variables

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/
#include <mdcommon.hxx>

//
// Access to global data structures is synchronized by
// acquiring g_rMasterResource with read or write
// permission.
//

CMDCOMSrvFactory    *g_pFactory = NULL;

ULONG                g_dwRefCount = 0;

CMDBaseObject       *g_pboMasterRoot;

TS_RESOURCE         *g_rMasterResource;

TS_RESOURCE         *g_rSinkResource;

CMDHandle           *g_phHandleHead;

METADATA_HANDLE      g_mhHandleIdentifier;

DWORD                g_dwSystemChangeNumber = 0;

DWORD                g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;

DWORD                g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;

HANDLE               g_phEventHandles[EVENT_ARRAY_LENGTH];

HANDLE               g_hReadSaveSemaphore;

DWORD                g_dwInitialized = 0;

HRESULT              g_hresInitWarning = ERROR_SUCCESS;

CMDBaseData        **g_ppbdDataHashTable;

DWORD                g_dwWriteNumber;

DWORD                g_dwLastSaveChangeNumber;

BOOL                 g_bSaveDisallowed;

//
// Data Buffer
// Access to these is synchronized via
// g_csDataBufferCritSec
//

PBUFFER_CONTAINER    g_pbcDataFreeBufHead;

PBUFFER_CONTAINER    g_pbcDataUsedBufHead;

PVOID               *g_ppvDataBufferBlock;

PBUFFER_CONTAINER    g_pbcDataContainerBlock;

HANDLE               g_hDataBufferSemaphore;

CRITICAL_SECTION     g_csDataBufferCritSec;

//
// Data File
//

STR                  *g_strRealFileName;
STR                  *g_strTempFileName;
STR                  *g_strBackupFileName;

STR                  *g_pstrBackupFilePath;

PSID                 g_psidSystem;
PSID                 g_psidAdmin;
PACL                 g_paclDiscretionary;
PSECURITY_DESCRIPTOR g_psdStorage;

//
// Debugging stuff
//

    DECLARE_DEBUG_VARIABLE();
    DECLARE_DEBUG_PRINTS_OBJECT();

DWORD           g_dwProcessAttached = 0;



DWORD g_dwCMDBaseObjectNextUniqueDataSetNumber = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dlltest\makefile.inc ===
#
# Supplemental rules for generating message file.
#

#inetimsg.h inetimsg.rc msg00001.bin: inetimsg.mc
    #mc -v inetimsg.mc

#clean::
    #-del inetimsg.h inetimsg.rc msg00001.bin


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dlltest\main.c ===
#include <windows.h>
#include <stdio.h>
#include <metadata.h>

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=PD; \
            }

#define TIMEOUT_VALUE      1000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5
#define DWORD_DATA_NAME_NO_INHERIT 6

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((METADATA_MAX_STRING_LEN * sizeof(TCHAR)), METADATA_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPTSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen);
    if (bPrintData) {
        printf(", Data = ");
        switch (pmdrData->dwMDDataType) {
        case DWORD_METADATA:
            printf("%x", *(DWORD *)(pmdrData->pbMDData));
            break;
        case STRING_METADATA:
            printf("%s", (LPTSTR)(pmdrData->pbMDData));
            break;
        case BINARY_METADATA:
            for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
            }
            break;
        }
    }
    printf("\n");
}
VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen);
    if (bPrintData) {
        printf(", Data = ");
        switch (pmdrData->dwMDDataType) {
        case DWORD_METADATA:
            printf("%x", *(DWORD *)(pbBase + (DWORD)(pmdrData->pbMDData)));
            break;
        case STRING_METADATA:
            printf("%s", (LPTSTR)(pbBase + (DWORD)(pmdrData->pbMDData)));
            break;
        case BINARY_METADATA:
            for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                printf("%.2x ", ((PBYTE)(pbBase + (DWORD)(pmdrData->pbMDData)))[i]);
            }
            break;
        }
    }
    printf("\n");
}

DWORD
APIENTRY
MDCallBack(DWORD dwCallBackType, PCHANGE_OBJECT_LIST pChangeObjectList, PVOID pvUserData)
{
    printf("Callback routine called , CallBackType = %X, ChangeObjectList = %X, UserData = %X",
        dwCallBackType, (DWORD) pChangeObjectList, (DWORD) pvUserData);
    return(ERROR_SUCCESS);
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}


DWORD __cdecl main()
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;


    RetCode = MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
    printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
        ConvertReturnCodeToString(RetCode));

    RetCode = MDInitialize();
    printf("MDInitialize(); Returns %s\n", ConvertReturnCodeToString(RetCode));

    if (SUCCEEDED(RetCode)) {

        RetCode = MDAddCallBack(&MDCallBack, NULL);
        printf("MDAddCallBack(&MDCallBack, NULL); Returns %s\n", ConvertReturnCodeToString(RetCode));

        RetCode = MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertReturnCodeToString(RetCode));

        if (RetCode == ERROR_SUCCESS) {

            RetCode = MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("junk 1/junk 2/junk 3/junk 4"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"junk 1/junk 2/junk 3/junk 4\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle,
                TEXT("junk 1/This is a very long name for a metaobject and should generate an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"junk 1/This is a very long name for a metaobject and should generate an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Child Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Child Object2"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Child Object2"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Reference Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDAddMetaObject(RootHandle, TEXT("Root Object/Subject Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDSetReferenceObject(RootHandle, TEXT("Root Object/Reference Object1"),
                RootHandle, TEXT("Root Object/Reference Object1"));
            printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PVOID) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, 0, (PBYTE)&TestDword);
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, 0, (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, 0, (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, 0, (PBYTE)TEXT("STRING Data"))
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertReturnCodeToString(RetCode));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, 0, (PBYTE)TEXT("STRING Data for Binary Name"))
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));


            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
            RetCode = MDSetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), STRING_DATA_NAME,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (RetCode == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", ReturnDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (RetCode == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", ReturnDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            RetCode = MDGetMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            RetCode = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;RetCode == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                RetCode = MDEnumMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData, i);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertReturnCodeToString(RetCode));
                if (RetCode == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }


            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, NULL);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, NULL)); Returns %s\n", ConvertReturnCodeToString(RetCode));
            printf("dwBufferSize = %d\n", dwBufferSize);

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 101;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, NULL)); Returns %s\n", ConvertReturnCodeToString(RetCode));
            printf("dwBufferSize = %d\n", dwBufferSize);

            //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, structDataEntries); Returns %s\n", ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            RetCode = ERROR_SUCCESS;
            printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;RetCode == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PVOID) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                RetCode = MDEnumMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &mdrData, i);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertReturnCodeToString(RetCode));
                if (RetCode == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, structDataEntries); Returns %s\n", ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            RetCode = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;RetCode == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PVOID) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                RetCode = MDEnumMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData, i);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertReturnCodeToString(RetCode));
                if (RetCode == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"),
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, structDataEntries); Returns %s\n", ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            RetCode = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
            for (i=0;RetCode == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PVOID) ReturnBuf);
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                RetCode = MDEnumMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"), &mdrData, i);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertReturnCodeToString(RetCode));
                if (RetCode == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
            RetCode = MDGetAllMetaData(RootHandle, TEXT("Root Object/Doesn't Exist"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwBufferSize, pbBuffer);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, structDataEntries); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
            if (RetCode == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            RetCode = MDCopyMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), RootHandle,
                TEXT("Root Object/Child Object1"), METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
            printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
            printf("MDChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDOpenMetaObject(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("MDOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                ConvertReturnCodeToString(RetCode));

            if (RetCode == ERROR_SUCCESS) {
                for (i=0;RetCode == ERROR_SUCCESS;i++) {
                    RetCode = MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i);
                    printf("MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertReturnCodeToString(RetCode));
                }

                RetCode = MDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertReturnCodeToString(RetCode));

                RetCode = MDChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertReturnCodeToString(RetCode));

                RetCode = MDCloseMetaObject(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                    ConvertReturnCodeToString(RetCode));
            }

            for (i=0;RetCode == ERROR_SUCCESS;i++) {
                RetCode = MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i);
                printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                    ConvertReturnCodeToString(RetCode));
                if (RetCode == ERROR_SUCCESS) {
                    printf("Object Name = %s\n", NameBuf);
                }
            }

            RetCode = MDSaveData();
            printf("\nMDSaveData(); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
            printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                ConvertReturnCodeToString(RetCode));

// RetCode = MDTerminate(FALSE);
// RetCode = MDInitialize();
            RetCode = MDDeleteMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), BINARY_DATA_NAME, BINARY_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDDeleteMetaData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), BINARY_DATA_NAME, STRING_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDDeleteMetaData(RootHandle, TEXT("Root Object"), BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDDeleteMetaData(RootHandle, TEXT("Root Object/Trash"), BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDDeleteMetaObject(RootHandle, TEXT("Root Object/Child Object1"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDDeleteMetaObject(RootHandle, TEXT("Root Object"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertReturnCodeToString(RetCode));

            RetCode = MDCloseMetaObject(RootHandle);
            printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                ConvertReturnCodeToString(RetCode));
        }

        RetCode = MDRemoveCallBack(&MDCallBack);
        printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
            ConvertReturnCodeToString(RetCode));
    }
    RetCode = MDTerminate(FALSE);
    printf("\nMDTerminate(FALSE); Returns %s\n",
        ConvertReturnCodeToString(RetCode));
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\sink.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS MetaBase connection point container code for sinks

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
#include <mdcommon.hxx>


/*---------------------------------------------------------------------------
  CMDCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CMDCOM* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CMDCOM::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CMDCOM::CImpIConnectionPointContainer::Init(CMDCOM *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CMDCOM::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
  HRESULT hr = E_NOINTERFACE;
  IConnectionPoint* pIConnPt;
  g_rSinkResource->Lock(TSRES_LOCK_READ);
    // NULL the output variable.
    *ppConnPt = NULL;

    if (riid == IID_IMDCOMSINK_A) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }
    else if (riid == IID_IMDCOMSINK_W) {
        pIConnPt = m_pBackObj->m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
        if (NULL != pIConnPt)
        {
          // This connectable CMDCOM object currently has only the Paper Sink
          // connection point. If the associated interface is requested,
          // use QI to get the Connection Point interface and perform the
          // needed AddRef.
            hr = pIConnPt->QueryInterface(IID_IConnectionPoint,
                                          (PPVOID)ppConnPt);
        }
    }

  g_rSinkResource->Unlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CMDCOM::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* aConnPts[MAX_CONNECTION_POINTS];
  COEnumConnectionPoints* pCOEnum;
  UINT i;

  g_rSinkResource->Lock(TSRES_LOCK_READ);
  // Zero the output interface pointer.
  *ppIEnum = NULL;

  // Make a copy on the stack of the array of connection point
  // interfaces. The copy is used below in the creation of the new
  // Enumerator object.
  for (i=0; i<MAX_CONNECTION_POINTS; i++)
    aConnPts[i] = (IConnectionPoint*)m_pBackObj->m_aConnectionPoints[i];

  // Create a Connection Point enumerator COM object for the connection
  // points offered by this CMDCOM object. Pass 'this' to be used to
  // hook the lifetime of the host object to the life time of this
  // enumerator object.
  pCOEnum = new COEnumConnectionPoints(this);
  if (NULL != pCOEnum)
  {
    // Use the array copy to Init the new Enumerator COM object.
    // Set the initial Enumerator index to 0.
    hr = pCOEnum->Init(MAX_CONNECTION_POINTS, aConnPts, 0);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      hr = pCOEnum->QueryInterface(
                        IID_IEnumConnectionPoints,
                        (PPVOID)ppIEnum);
    }
    
    if( FAILED( hr ) )  
    {
      delete pCOEnum;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

  g_rSinkResource->Unlock();

  return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\connect.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.h

Abstract:

    defines for event/sink interface for IIS MetaBase.

Author:

    Michael W. Thomas            04-Oct-96

Revision History:

--*/

#if !defined(CONNECT_H)
#define CONNECT_H

#ifdef __cplusplus

// Types that should be in OLE2.H
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

// Convenient macros.

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}




























// An enumeration giving symbol names for the connection
// points offered by the DllPaper component in this server.
enum
{
  MD_CONNPOINT_WRITESINK_A = 0,
  MD_CONNPOINT_WRITESINK_W
};

enum
{
  // The maximum number of connection points offered by the DllPaper
  // component in this STOSERVE server.  The number of items in the
  // connection point enumeration above.
  MAX_CONNECTION_POINTS = 2,

  // A constant for the number of connections to add to the allocation
  // of the dynamic connection array.
  ALLOC_CONNECTIONS = 8,

  // The start value for the connection key (cookie) counter.
  COOKIE_START_VALUE = 500
};


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnectionPoints

  Summary:     COM object class for enumerating the Connection Points
               offered by a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnectionPoints
                 Interface for connection point enumeration.

  Aggregation: COEnumConnectionPoints COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnectionPoints : public IEnumConnectionPoints
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnectionPoints(IUnknown* pHostObj);
    ~COEnumConnectionPoints(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnPts,
              IConnectionPoint** paConnPts,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnectionPoints methods.
    STDMETHODIMP         Next(ULONG, IConnectionPoint**, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnectionPoints**);

  private:
    // Private data of COEnumConnectionPoints COM objects.

    // Main Object reference count.
    ULONG              m_cRefs;

    // IUnknown pointer to host COM object being enumerated.
    IUnknown*          m_pHostObj;

    // Connection Point index variable.
    ULONG              m_iEnumIndex;

    // Number of Connection Points being enumerated.
    ULONG              m_cConnPts;

    // Allocated array of Connection Point interface pointers.
    IConnectionPoint** m_paConnPts;
};

typedef COEnumConnectionPoints* PCOEnumConnectionPoints;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COConnectionPoint

  Summary:     Connection Point COM object class. Implements a native
               IConnectionPoint interface. The Advise, Unadvise, and
               EnumConnections methods use the CThreaded OwnThis mechanism
               to provide thread-safe mutually exclusive access to this
               connection point object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IConnectionPoint
                 Interface for connection point features.

  Aggregation: COConnectionPoint COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COConnectionPoint : public IConnectionPoint
{
  public:
    // Main Object Constructor & Destructor.
    COConnectionPoint(IUnknown* pHostObj);
    ~COConnectionPoint(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(REFIID riid);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IConnectionPoint methods.
    STDMETHODIMP GetConnectionInterface(IID*);
    STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer**);
    STDMETHODIMP Advise(IUnknown*, DWORD*);
    STDMETHODIMP Unadvise(DWORD);
    STDMETHODIMP EnumConnections(IEnumConnections**);

  private:
    // Private utility methods of COConnectionPoint.
    HRESULT GetSlot(UINT* puiFreeSlot);
    HRESULT FindSlot(DWORD dwCookie, UINT* puiSlot);

    // Private data of COConnectionPoint COM objects.

    // Main Object reference count.
    ULONG          m_cRefs;

    // IUnknown pointer to host COM object offering this connection point.
    IUnknown*      m_pHostObj;

    // The IID of the sink interface associated with this connection point.
    IID            m_iidSink;

    // The current connection cookie (key) counter.
    DWORD          m_dwNextCookie;

    // The current number of live sink connections to this connection point.
    UINT           m_cConnections;

    // The current maximum index into the dynamic connection array.
    UINT           m_uiMaxIndex;

    // The dynamic array of sink connections to this connection point.
    CONNECTDATA*   m_paConnections;
};

typedef COConnectionPoint* PCOConnectionPoint;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnections

  Summary:     COM object class for enumerating the connections of a
               connection point of a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnections
                 Interface for connection enumeration features.

  Aggregation: COEnumConnections COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnections : public IEnumConnections
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnections(IUnknown* pHostObj);
    ~COEnumConnections(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnections,
              CONNECTDATA* paConnections,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods.
    STDMETHODIMP         Next(ULONG, CONNECTDATA*, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnections**);

  private:
    // Private data of COEnumConnections COM objects.

    // Main Object reference count.
    ULONG            m_cRefs;

    // IUnknown pointer to host connection point COM object being
    // enumerated.
    IUnknown*        m_pHostObj;

    // Connection index variable.
    ULONG            m_iEnumIndex;

    // Number of Connections being enumerated.
    ULONG            m_cConnections;

    // Allocated array of live Connections only.
    CONNECTDATA*     m_paConnections;
};

typedef COEnumConnections* PCOEnumConnections;

#endif // __cplusplus


#endif // CONNECT_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\metasub.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase subroutines to support exported routines

Author:

    Michael W. Thomas            31-May-96

Revision History:

Notes:

    Most routines in this file assume that g_rMasterResource is already taken
    for read or write as appropriate.
--*/

#include <locale.h>
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <malloc.h>
#include <tuneprefix.h>


#if DBG

BOOL g_fShowMetaLocks = FALSE;

#endif DBG

HRESULT GetObjectFromPath(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. Updates Path to point past the last
    object found if the whole path is not found. If the entire path
    is not found, the last object found is returned.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *pboCurrent, *pboPrevious;
    LPTSTR strCurPath = strPath;

    CMDHandle *HandleObject = GetHandleObject(hHandle);
    if (HandleObject == NULL) {
        hresReturn = E_HANDLE;
    }
    else if ((((dwPermissionNeeded & METADATA_PERMISSION_WRITE) != 0) && (!HandleObject->IsWriteAllowed())) ||
        (((dwPermissionNeeded & METADATA_PERMISSION_READ) != 0) && (!HandleObject->IsReadAllowed()))) {
        hresReturn = E_ACCESSDENIED;
    }
    else {
        pboCurrent = HandleObject->GetObject();
        MD_ASSERT(pboCurrent != NULL);
        strCurPath = strPath;

        if (strCurPath != NULL) {
            SkipPathDelimeter(strCurPath, bUnicode);
            while ((pboCurrent != NULL) &&
                (!IsStringTerminator(strCurPath, bUnicode))) {
                pboPrevious = pboCurrent;
                //
                // GetChildObject increments strCurPath on success
                // and returns NULL if child not found
                //
                pboCurrent = pboCurrent->GetChildObject(strCurPath, &hresReturn, bUnicode);
                if (FAILED(hresReturn)) {
                    break;
                }
                if (pboCurrent != NULL) {
                    SkipPathDelimeter(strCurPath, bUnicode);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ((strCurPath == NULL) ||
                IsStringTerminator(strCurPath, bUnicode)) {  // Found the whole path
                rpboReturn = pboCurrent;
                hresReturn = ERROR_SUCCESS;
            }
            else {           //return last object found and an error code
                rpboReturn = pboPrevious;
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                strPath = strCurPath;
            }
        }
    }

    return (hresReturn);
}

HRESULT AddObjectToDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Creates and adds one or more objects to the metabase. Finds the deepest object
    pointed to by Handle/Path and creates any subobject specified by path.

Arguments:

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_NOT_ENOUGH_MEMORY
             ERROR_INVALID_NAME

Notes:

--*/
{
    HRESULT hresReturn=ERROR_SUCCESS;
    CMDBaseObject *pboParent;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    HRESULT hresExtractRetCode = ERROR_SUCCESS;

    hresReturn = GetObjectFromPath(pboParent,
                                hHandle,
                                METADATA_PERMISSION_WRITE,
                                strTempPath,
                                bUnicode);
    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strPath set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        MD_ASSERT(pboParent != NULL);
        for (hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
            SUCCEEDED(hresExtractRetCode);
            hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                break;
            }
            else {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete (pboNew);
                    break;
                }
                else {
                    pboParent = pboNew;
                    PREFIX_ASSUME(GetHandleObject(hHandle) != NULL, "GetHandleObject(hHandle) is guaranteed not to return NULL");
                    GetHandleObject(hHandle)->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }
    if (hresExtractRetCode == RETURNCODETOHRESULT(ERROR_INVALID_NAME)) {
        hresReturn = hresExtractRetCode;
    }
    return(hresReturn);
}

HRESULT RemoveObjectFromDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a metaobject and all subobjects from the database.

Arguments:

    Handle - The Meta Data handle. A handle returned by MDOpenMetaObject with write permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND
             ERROR_INVALID_PARAMETER

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboDelete;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    //
    // Make sure that a valid path was specified
    //
    SkipPathDelimeter(strTempPath, bUnicode);
    hresReturn = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
    if (FAILED(hresReturn)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        strTempPath = strPath;
        hresReturn = GetObjectFromPath(pboDelete,
                                       hHandle,
                                       METADATA_PERMISSION_WRITE,
                                       strTempPath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = (pboDelete->GetParent())->RemoveChildObject(pboDelete);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(GetHandleObject(hHandle) != NULL);
                if (GetHandleObject(hHandle)->SetChangeData(pboDelete, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboDelete);
                }
            }
        }
    }
    return(hresReturn);
}

CMDHandle *GetHandleObject(
         IN METADATA_HANDLE hHandle)
/*++

Routine Description:

    Gets the handle object associated with Handle.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

Return Value:

    CMDHandle * - The handle object, or NULL if not found.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    for (hoCurrent = g_phHandleHead;
        (hoCurrent != NULL) && (hoCurrent->GetHandleIdentifier() != hHandle);
        hoCurrent = hoCurrent->GetNextPtr()) {
    }
    return (hoCurrent);
}

BOOL
PermissionsAvailable(
         IN CMDBaseObject *pboTest,
         IN DWORD dwRequestedPermissions,
         IN DWORD dwReadThreshHold
         )
/*++

Routine Description:

    Checks if the requested handle permissions are available for a meta object.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

    RequestedPermissions - The permissions requested.

    ReadThreshHold - The number of reads allows on a write request. Normally 0.

Return Value:

    BOOL   - TRUE if the permissions are available.

Notes:

--*/
{
    BOOL bResults = TRUE;
    CMDBaseObject *pboCurrent;
    MD_ASSERT(pboTest != NULL);
    if (dwRequestedPermissions & METADATA_PERMISSION_WRITE) {
        if ((pboTest->GetReadPathCounter() != 0) ||
            (pboTest->GetWritePathCounter() != 0)) {
            bResults = FALSE;
        }
        if ((pboTest->GetReadCounter() > dwReadThreshHold) || (pboTest->GetWriteCounter() != 0)) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest->GetParent();bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if ((pboCurrent->GetReadCounter() != 0) || (pboCurrent->GetWriteCounter() != 0)) {
                bResults = FALSE;
            }
        }
    }
    else if (dwRequestedPermissions & METADATA_PERMISSION_READ) {
        if (pboTest->GetWritePathCounter() != 0) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest;bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if (pboCurrent->GetWriteCounter() != 0) {
                bResults = FALSE;
            }
        }
    }
    else {
        MD_ASSERT(FALSE);
    }
    return (bResults);
}

VOID RemovePermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRemovePermissions
         )
/*++

Routine Description:

    Removes the handle permissions from a meta object.

Arguments:

    Affected - The object to remove permissions from.

    RemovePermissions - The permissions to remove.

Return Value:

Notes:

--*/
{
    MD_ASSERT(pboAffected != NULL);
    CMDBaseObject *pboCurrent;
    if ((dwRemovePermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->DecrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementWritePathCounter();
        }
    }
    if ((dwRemovePermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->DecrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRemovePermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms releasted (%d) on ");
        cchSz = strlen(szBuf);

        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);

        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';

        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

VOID
AddPermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRequestedPermissions
         )
/*++

Routine Description:

    Adds handle permissions to a meta object.

Arguments:

    Affected - The object to remove permissions from.

    ReqyestedPermissions - The permissions to add.

Return Value:

Notes:

--*/
{
    CMDBaseObject *pboCurrent;
    if (((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) &&
        ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0)) {
        pboAffected->IncrementWriteCounter();
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
            pboCurrent->IncrementReadPathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->IncrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRequestedPermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms obtained (%d) on ");
        cchSz = strlen(szBuf);

        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);

        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';

        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

HRESULT
AddHandle(
         IN CMDBaseObject *pboAssociated,
         IN DWORD dwRequestedPermissions,
         IN METADATA_HANDLE &rmhNew
         )
/*++

Routine Description:

    Creates a handle object and adds it to the handle list.

Arguments:

    Handle - The object the handle is associated with.

    RequestedPermissions - The permissions for the handle.

    New - The handle id.

Return Value:
    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoNew = new CMDHandle(pboAssociated,
                                     dwRequestedPermissions,
                                     g_dwSystemChangeNumber,
                                     g_mhHandleIdentifier++);
    if (hoNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        rmhNew = hoNew->GetHandleIdentifier();
        hoNew->SetNextPtr(g_phHandleHead);
        g_phHandleHead = hoNew;
        AddPermissions(pboAssociated, dwRequestedPermissions);
    }
    return(hresReturn);
}

CMDHandle *
RemoveHandleObject(
         IN METADATA_HANDLE mhHandle
         )
/*++

Routine Description:

    Removes a handle object from the handle list.

Arguments:

    Handle - The handle to be removed.

Return Value:

    CMDHandle * - The Handle object removed.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    CMDHandle *hoReturn;

    if (g_phHandleHead->GetHandleIdentifier() == mhHandle) {
        hoReturn = g_phHandleHead;
        g_phHandleHead = g_phHandleHead->GetNextPtr();
    }
    else {
        for (hoCurrent = g_phHandleHead;(hoCurrent->GetNextPtr() != NULL) &&
            (hoCurrent->GetNextPtr()->GetHandleIdentifier() != mhHandle);
            hoCurrent = hoCurrent->GetNextPtr()) {
        }
        hoReturn = hoCurrent->GetNextPtr();
        if (hoCurrent->GetNextPtr() != NULL) {
            MD_ASSERT (hoCurrent->GetNextPtr()->GetHandleIdentifier() == mhHandle);
            hoCurrent->SetNextPtr(hoCurrent->GetNextPtr()->GetNextPtr());
        }
    }
    return (hoReturn);
}

HRESULT
SaveDataObject(HANDLE hFileHandle,
               CMDBaseData *pbdSave,
               PBYTE pbLineBuf,
               DWORD dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save a data object.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Save       - The data object to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL bGoodData = TRUE;
    int iStringLen;
    PBYTE pbData;
    DWORD dwTemp;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        *pbLineBuf = MD_ID_DATA;

        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            pbLineBuf,
                            pbrNextPtr,
                            1,
                            FALSE);

        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetIdentifier();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetAttributes();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetUserType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetDataType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {
                    PIIS_CRYPTO_BLOB blob;

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData( &blob,
                                                              pbdSave->GetData(TRUE),
                                                              pbdSave->GetDataLen(TRUE),
                                                              0);

                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = WriteLine(hFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE)blob,
                                            pbrNextPtr,
                                            IISCryptoGetBlobLength(blob),
                                            TRUE);

                        ::IISCryptoFreeBlob(blob);
                    }
                } else {
                    hresReturn = WriteLine(hFileHandle,
                                        dwWriteBufSize,
                                        pbWriteBuf,
                                        (PBYTE)pbdSave->GetData(TRUE),
                                        pbrNextPtr,
                                        pbdSave->GetDataLen(TRUE),
                                        TRUE);
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
SaveMasterRoot(HANDLE hFileHandle,
               PBYTE pbLineBuf,
               DWORD  dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage
               )
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

    FileHandle - File handle for use by WriteLine.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    PFILETIME pftTime;

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    *pbLineBuf = MD_ID_ROOT_OBJECT;

    hresReturn = WriteLine(hFileHandle,
                        dwWriteBufSize,
                        pbWriteBuf,
                        pbLineBuf,
                        pbrNextPtr,
                        1,
                        FALSE);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            (PBYTE)pftTime,
                            pbrNextPtr,
                            sizeof(FILETIME),
                            TRUE);
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
        hresReturn = SaveDataObject(hFileHandle,
                                 dataAssociatedData,
                                 pbLineBuf,
                                 dwWriteBufSize,
                                 pbWriteBuf,
                                 pbrNextPtr,
                                 pCryptoStorage
                                 );
    }

    return(hresReturn);
}

HRESULT
SaveTree(
         IN HANDLE hFileHandle,
         IN CMDBaseObject *pboRoot,
         IN PBYTE pbLineBuf,
         IN BUFFER *pbufParentPath,
         IN DWORD  dwWriteBufSize,
         IN PBYTE pbWriteBuf,
         IN OUT PBYTE &pbrNextPtr,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage
         )
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Root       - The root of the tree to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)'\0';
            pftTime = pboRoot->GetLastChangeTime();

            *pbLineBuf = MD_ID_OBJECT;

            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                pbLineBuf,
                                pbrNextPtr,
                                1,
                                FALSE);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE)pftTime,
                                    pbrNextPtr,
                                    sizeof(FILETIME),
                                    FALSE);
            }

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE) strParentPath,
                                    pbrNextPtr,
                                    (dwNewParentPathLen) * sizeof(WCHAR),
                                    TRUE);
            }

            if (SUCCEEDED(hresReturn)) {

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                    hresReturn = SaveDataObject(hFileHandle,
                                             dataAssociatedData,
                                             pbLineBuf,
                                             dwWriteBufSize,
                                             pbWriteBuf,
                                             pbrNextPtr,
                                             pCryptoStorage
                                             );
                }

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hFileHandle,
                                       objChildObject,
                                       pbLineBuf,
                                       pbufParentPath,
                                       dwWriteBufSize,
                                       pbWriteBuf,
                                       pbrNextPtr,
                                       pCryptoStorage
                                       );
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)'\0';
        }
    }

    return(hresReturn);
}

HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN LPSTR pszBackupLocation,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore
         )
/*++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBYTE pbLineBuf = NULL;
    PBYTE pbWriteBuf = NULL;
    PBYTE pbNextPtr = NULL;
    BUFFER *pbufParentPath = new BUFFER(0);
    DWORD  dwWriteBufSize = READWRITE_BUFFER_LENGTH;
    HANDLE hTempFileHandle;
    CMDBaseObject *objChildObject;
    DWORD dwEnumObjectIndex;
    DWORD dwStringLen;
    BOOL bDeleteTemp = TRUE;
    DWORD dwTemp = ERROR_SUCCESS;
    DWORD dwTempLastSaveChangeNumber;
    BOOL  bSaveNeeded = FALSE;
    LPTSTR strRealFileName;    
    LPTSTR strTempFileName = g_strTempFileName->QueryStr();
    LPTSTR strBackupFileName = g_strBackupFileName->QueryStr();

    if( !pszBackupLocation )
    {
        strRealFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        strRealFileName = pszBackupLocation;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    if (!g_bSaveDisallowed) {
        g_bSaveDisallowed = bSetSaveDisallowed;
        pbLineBuf = new BYTE[MAX_RECORD_BUFFER];
        for ((pbWriteBuf = new BYTE[dwWriteBufSize]);
            (pbWriteBuf == NULL) && ((dwWriteBufSize/=2) >= MAX_RECORD_BUFFER);
            pbWriteBuf = new BYTE[dwWriteBufSize]) {
        }
        if ((pbWriteBuf == NULL) || (pbLineBuf == NULL)
            || (pbufParentPath == NULL) || (!pbufParentPath->Resize(MD_MAX_PATH_LEN))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // Write to a temp file first in case there are errors.
            //

            SECURITY_ATTRIBUTES saStorage;
            PSECURITY_ATTRIBUTES psaStorage = NULL;

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            hTempFileHandle = CreateFile(strTempFileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         psaStorage,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         0);
            if (hTempFileHandle == INVALID_HANDLE_VALUE) {
                DWORD dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
            else {
                g_rMasterResource->Lock(TSRES_LOCK_READ);

                //
                // Only Save if changes have been made since the last save.
                //

                if ( pszBackupLocation || g_dwLastSaveChangeNumber != g_dwSystemChangeNumber ) 
                {
                    bSaveNeeded = TRUE;

                    if (hHandle != METADATA_MASTER_ROOT_HANDLE) {
                        CMDHandle *phoHandle;
                        phoHandle = GetHandleObject(hHandle);
                        if ((phoHandle == NULL) || (phoHandle->GetObject() != g_pboMasterRoot)) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                        }
                        else if ((!phoHandle->IsReadAllowed()) && (!phoHandle->IsWriteAllowed())) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
                        ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)'\0';
                        pbNextPtr = pbWriteBuf;
                        hresReturn = WriteLine(hTempFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE) MD_SIGNATURE_STRINGW,
                                            pbNextPtr,
                                            sizeof(MD_SIGNATURE_STRINGW),
                                            TRUE);
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MAJOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMajorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MINOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMinorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf =  MD_ID_CHANGE_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwSystemChangeNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            //
                            // Write the session key blob to the file.
                            //
                            *pbLineBuf =  MD_ID_SESSION_KEY;
                            memcpy((PCHAR)pbLineBuf+1, (PCHAR)pSessionKeyBlob, IISCryptoGetBlobLength(pSessionKeyBlob));
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + IISCryptoGetBlobLength(pSessionKeyBlob),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {

                            hresReturn = SaveMasterRoot( hTempFileHandle,
                                                         pbLineBuf,
                                                         dwWriteBufSize,
                                                         pbWriteBuf,
                                                         pbNextPtr,
                                                         pCryptoStorage
                                                         );

                            for(dwEnumObjectIndex=0,objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++);
                                (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                                objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++)) {

                                    hresReturn = SaveTree( hTempFileHandle,
                                                           objChildObject,
                                                           pbLineBuf,
                                                           pbufParentPath,
                                                           dwWriteBufSize,
                                                           pbWriteBuf,
                                                           pbNextPtr,
                                                           pCryptoStorage
                                                           );
                            }
                        }
                        else
                        {
                            // failed to write out session key!
                            // pretty serious.
                            DBGPRINTF(( DBG_CONTEXT, "SaveAllData:Failed to write out Session Key - error 0x%0x\n", hresReturn));
                        }
                    }

                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

                }

                //
                // Release lock before writing to file.
                //

                g_rMasterResource->Unlock();

                if (bSaveNeeded && SUCCEEDED(hresReturn)) {

                    hresReturn = FlushWriteBuf(hTempFileHandle,
                                           pbWriteBuf,
                                           pbNextPtr);
                }


                //
                // FlushFileBuffers was added trying to solve 390968 when metabase
                // sometimes becomes corrupted during resets.  That should ensure that data
                // is already on the disk when doing later MoveFile operations
                //

                if (!FlushFileBuffers (hTempFileHandle)) {
                    hresReturn = GetLastError();
    			    DBGPRINTF(( DBG_CONTEXT, "Failed FlushFileBuffers - error 0x%0x\n", hresReturn));
                }

                //
                // Always close the file handle
                //

                if (!CloseHandle(hTempFileHandle)) {
                    hresReturn = GetLastError();
                }

            }
            if (SUCCEEDED(hresReturn) && bSaveNeeded) {
                //
                // New data file created successfully
                // Backup real file and copy temp
                // to real
                //
                if (!MoveFile(strTempFileName, strRealFileName)) {
                    if (GetLastError() != ERROR_ALREADY_EXISTS) {
                        dwTemp = GetLastError();
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    //
                    // Real File exists, so back it up
                    //
                    else if (!MoveFile(strRealFileName, strBackupFileName)) {
                        //
                        // backup failed, check for old backup file
                        //
                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            dwTemp = GetLastError();
                        }
                        else if (!DeleteFile(strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        else if (!MoveFile(strRealFileName, strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    if (SUCCEEDED(hresReturn)) {
                        BOOL bDeleteBackup = TRUE;
                        //
                        // Real file is backed up
                        // so move in new file
                        //
                        if (!MoveFile(strTempFileName, strRealFileName)) {
                            dwTemp = GetLastError();
                            hresReturn = RETURNCODETOHRESULT(dwTemp);
                            //
                            // Moved real to backup but
                            // failed to move temp to real
                            // so restore from backup
                            //
                            if (!MoveFile(strBackupFileName, strRealFileName)) {
                                //
                                // Unable to write new file
                                // or restore original file so don't delete backup
                                //
                                bDeleteBackup = FALSE;
                            }
                        }
                        if (bDeleteBackup) {
                            DeleteFile(strBackupFileName);
                        }
                    }
                    if (FAILED(hresReturn)) {
                        //
                        // temp file was created ok but a problem
                        // occurred while moving it to real
                        // so don't delete it
                        //
                        bDeleteTemp = FALSE;
                    }
                    else {

                        //
                        // Update Change Number
                        // Must have ReadSaveSemaphore when accessing this.
                        //

                        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
                    }
                }
            }
            if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) {
                DeleteFile(strTempFileName);
            }
        }
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( pbufParentPath != NULL ) {
        delete(pbufParentPath);
    }

    if ( pbWriteBuf != NULL ) {
        delete(pbWriteBuf);
    }

    if ( pbLineBuf != NULL ) {
        delete(pbLineBuf);
    }

    if ( FAILED( hresReturn )) {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    } else {
        //DBGPRINTF(( DBG_CONTEXT, "Successfully flushed metabase to disk\n" ));
    }

    return hresReturn;
}

DWORD
DeleteKeyFromRegistry(HKEY hkeyParent,
                      LPTSTR pszCurrent)
/*++

Routine Description:

    Deletes a key and all data and subkeys from the registry.

    RECURSIVE ROUTINE! DO NOT USE STACK!

Arguments:

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn;
    LPTSTR pszName;

    MDRegKey *pmdrkCurrent = new MDRegKey(hkeyParent,
                                          pszCurrent);
    if (pmdrkCurrent == NULL) {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        dwReturn = GetLastError();
    }
    if (dwReturn == ERROR_SUCCESS) {
        MDRegKeyIter *pmdrkiCurrent = new MDRegKeyIter(*pmdrkCurrent);
        if (pmdrkiCurrent == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            dwReturn = GetLastError();
        }
        while ((dwReturn == ERROR_SUCCESS) &&
            (dwReturn = pmdrkiCurrent->Next(&pszName, NULL, 0)) == ERROR_SUCCESS) {
            dwReturn = DeleteKeyFromRegistry(*pmdrkCurrent,
                                              pszName);
        }
        delete (pmdrkiCurrent);
        if (dwReturn == ERROR_NO_MORE_ITEMS) {
            dwReturn = ERROR_SUCCESS;
        }
    }
    delete (pmdrkCurrent);

    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(hkeyParent,
                                pszCurrent);
    }
    return dwReturn;
}

HRESULT
ReadMetaObject(
         IN CMDBaseObject *&cboRead,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Read       - Place to return the created object.

    ObjectLine - The object info.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboParent;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    FILETIME ftTime;
    PFILETIME pftParentTime;
    FILETIME ftParentTime;
    PBYTE pbLine = (PBYTE)pbufLine->QueryPtr();
    LPTSTR strObjectName;

    if ((dwLineLen <= BASEMETAOBJECTLENGTH) || (*(pbLine + dwLineLen - 1) != '\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        ftTime = *(UNALIGNED FILETIME *)(pbLine + 1);
        //
        // GetObjectFromPath checks permissions on the handle
        // This only gets called from init so just tell it read.
        //
        strObjectName = (LPTSTR)(pbLine + BASEMETAOBJECTLENGTH);

        if (bUnicode != FALSE) {

            PCUWSTR strObjectNameUnaligned;
            PCWSTR strObjectNameAligned;

            //
            // Generate an aligned copy of the string
            //

            strObjectNameUnaligned = (PCUWSTR)strObjectName;

            WSTR_ALIGNED_STACK_COPY(&strObjectNameAligned,
                                    strObjectNameUnaligned);

            strObjectName = (LPTSTR)strObjectNameAligned;
        }
        hresReturn = GetObjectFromPath(pboParent,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    METADATA_PERMISSION_READ,
                                    strObjectName,
                                    bUnicode);

        //
        // This should return ERROR_PATH_NOT_FOUND and the parent object,
        // with strObjectLine set to the remainder of the path,
        // which should be the child name, without a preceding delimeter.
        //

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            MD_ASSERT(pboParent != NULL);
            if (bUnicode) {
                hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
            }
            else {
                hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
            }
            if (SUCCEEDED(hresReturn)) {
                CMDBaseObject *pboNew;
                if (bUnicode) {
                    pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
                }
                else {
                    pboNew = new CMDBaseObject((LPSTR)strName, NULL);
                }
                if (pboNew == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else if (!pboNew->IsValid()) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    delete (pboNew);
                }
                else {
                    //
                    // InsertChildObject sets the last change time to current time.
                    // This isn't really a change, so save and restore time.
                    //
                    pftParentTime = pboParent->GetLastChangeTime();
                    ftParentTime = *pftParentTime;
                    hresReturn = pboParent->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        pboParent->SetLastChangeTime(&ftParentTime);
                        pboNew->SetLastChangeTime(&ftTime);
                        cboRead = pboNew;
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }
        }
        else if (SUCCEEDED(hresReturn)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
        }
    }
    return (hresReturn);
}

HRESULT
ReadDataObject(
         IN CMDBaseObject *cboAssociated,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    DataLine   - The data info.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataLine = (PBYTE)pbufLine->QueryPtr();
    PBYTE pbDataValue;
    STACK_BUFFER( bufAlignedValue, 256 );
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    if (dwLineLen < DATAOBJECTBASESIZE) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        MD_ASSERT(pbufLine->QuerySize() >= DATAOBJECTBASESIZE);
        mdrData.dwMDIdentifier = *(UNALIGNED DWORD *)(pbDataLine + 1);
        mdrData.dwMDAttributes = *(UNALIGNED DWORD *)(pbDataLine + 1 + sizeof(DWORD));
        mdrData.dwMDUserType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (2 * sizeof(DWORD)));
        mdrData.dwMDDataType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (3 * sizeof(DWORD)));

        pbDataValue = pbDataLine + DATAOBJECTBASESIZE;
        dwDataLength = dwLineLen - DATAOBJECTBASESIZE;

        if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
            pCryptoStorage != NULL) {

            //
            // This is a secure data object, we we'll need to decrypt it
            // before proceeding. Note that we must clone the blob before
            // we can actually use it, as the blob data in the line buffer
            // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
            // the only IISCrypto function that can handle unaligned data.)
            //

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));

                hresReturn = pCryptoStorage->DecryptData(
                                   (PVOID *)&pbDataValue,
                                   &dwDataLength,
                                   &dummyRegType,
                                   blob
                                   );
            }

        } else {

            //
            // The metadata was not secure, so decryption was not required.
            // Nonetheless, it must be copied to an aligned buffer... 
            //

            if( !bufAlignedValue.Resize( dwDataLength ) )
            {
                hresReturn = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                memcpy( bufAlignedValue.QueryPtr(), pbDataValue, dwDataLength );
                pbDataValue = ( PBYTE )bufAlignedValue.QueryPtr();
            }
        }

        if (SUCCEEDED(hresReturn)) {
            mdrData.pbMDData = pbDataValue;

            switch (mdrData.dwMDDataType) {
                case DWORD_METADATA: {
                    if (dwDataLength != sizeof(DWORD)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if ((LONG)dwDataLength < 1 ||
                        (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                        (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)'\0')) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case BINARY_METADATA:
                {
                    mdrData.dwMDDataLen = dwDataLength;
                    break;
                }
                case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        if (dwDataLength < (2 * sizeof(WCHAR)) ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)'\0' ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)'\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    else {
                        if (dwDataLength < 2 ||
                            pbDataValue[dwDataLength-1] != '\0' ||
                            pbDataValue[dwDataLength-2] != '\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        mdrData.dwMDDataLen = dwDataLength;
                    }
                    break;
                }
                default: {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}

HRESULT
FlushWriteBuf(HANDLE hWriteFileHandle,
              PBYTE pbWriteBuf,
              PBYTE &pbrNextPtr)
/*++

Routine Description:

    Flush the write buffer to the file.

Arguments:

    FileHandle - File handle to write to.

    WriteBuf   - Buffer to write to file.

    NextPtr    - Pointer past end of buffer.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesWritten;
    if (pbrNextPtr > pbWriteBuf) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       DIFF((BYTE *)pbrNextPtr - (BYTE *)pbWriteBuf),
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

BOOL
CopyLineWithEscapes(PBYTE &pbrFileBuf,
                    DWORD &dwrFileBufLen,
                    PBYTE &pbrLineBuf,
                    DWORD &dwrLineBufLen,
                    BOOL  &brMidEscape)
    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbrFileBuf, dwrFileBufLen, brMidEscape
    // FAILURE: pbrLineBuf, dwrLineBufLen, brMidEscape
    // On FAILURE, it fills to the end of the buffer
    //
{
    BOOL bReturn = TRUE;
    PBYTE pbFileBufEnd = pbrFileBuf + dwrFileBufLen;
    PBYTE pbLineBufEnd = pbrLineBuf + dwrLineBufLen;
    PBYTE pbFileBufIndex = pbrFileBuf;
    PBYTE pbLineBufIndex = pbrLineBuf;

    brMidEscape = FALSE;

    while ((pbLineBufIndex < pbLineBufEnd) && (pbFileBufIndex < (pbFileBufEnd - 1))) {
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
        }
        *pbFileBufIndex++ = *pbLineBufIndex++;
    }
    if ((pbLineBufIndex != pbLineBufEnd) && (pbFileBufIndex < pbFileBufEnd)) {
        MD_ASSERT(pbFileBufIndex == (pbFileBufEnd - 1));
        //
        // file last byte in buffer
        //
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
            brMidEscape = TRUE;
        }
        else {
            *pbFileBufIndex++ = *pbLineBufIndex++;
        }
    }
    if (pbLineBufIndex != pbLineBufEnd) {
        bReturn = FALSE;
        pbrLineBuf = pbLineBufIndex;
        dwrLineBufLen = DIFF(pbLineBufEnd - pbLineBufIndex);
    }
    else {
        pbrFileBuf = pbFileBufIndex;
        dwrFileBufLen = DIFF(pbFileBufEnd - pbFileBufIndex);
    }

    return bReturn;
}


HRESULT
WriteLine(HANDLE hWriteFileHandle,
          DWORD  dwWriteBufSize,
          PBYTE  pbWriteBuf,
          PBYTE  pbLineBuf,
          PBYTE  &pbNextPtr,
          DWORD  dwLineLen,
          BOOL   bTerminate)
/*++

Routine Description:

    Write a line. Performs buffered writes to a file. Does not append \n.
    The string does not need to be terminated with \0.

Arguments:

    FileHandle - File to write to.

    WriteBufSize - Buffer size.

    WriteBuf   - Buffer to store data in.

    LineBuf    - The line buffer with data to write.

    NextPtr    - Pointer to the next unused character in WriteBuf.

    Len        - The number of characters to write.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    PBYTE pbWriteBufEnd = pbWriteBuf + dwWriteBufSize;
    DWORD dwBufferBytesLeft = DIFF(pbWriteBufEnd - pbNextPtr);
    DWORD dwBytesWritten;
    BOOL  bMidEscape;

    MD_ASSERT(pbLineBuf != NULL);
    MD_ASSERT(pbWriteBuf != NULL);
    MD_ASSERT((pbNextPtr >= pbWriteBuf) && (pbNextPtr <= pbWriteBufEnd));

    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbNextPtr, dwBufferBytesLeft
    // FAILURE: pbLineBuf, dwLineLen, bMidEscape
    // On FAILURE, it fills to the end of the buffer
    //

    while ((dwReturn == ERROR_SUCCESS) &&
        (!CopyLineWithEscapes(pbNextPtr, dwBufferBytesLeft, pbLineBuf, dwLineLen, bMidEscape))) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       dwWriteBufSize,
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
        dwBufferBytesLeft = dwWriteBufSize;
        pbNextPtr = pbWriteBuf;
        if (bMidEscape) {
            *pbNextPtr++ = *pbLineBuf++;
            dwBufferBytesLeft--;
            dwLineLen--;
        }
    }
    if (bTerminate && (dwReturn == ERROR_SUCCESS)) {
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_ESCAPE_BYTE;
        dwBufferBytesLeft--;
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_TERMINATE_BYTE;
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

PBYTE
FindEndOfData(PBYTE pbNextPtr,
              PBYTE pbEndReadData,
              BOOL bEscapePending)
{
    PBYTE pbIndex = pbNextPtr;
    BOOL bEndFound = FALSE;

    if ((pbEndReadData > pbIndex) && bEscapePending) {
        if (*pbIndex == MD_TERMINATE_BYTE) {
            bEndFound = TRUE;
        }
        pbIndex++;
    }
    while ((pbEndReadData -1 > pbIndex) && !bEndFound) {
        if (*pbIndex == MD_ESCAPE_BYTE) {
            pbIndex++;
            if (*pbIndex == MD_TERMINATE_BYTE) {
                bEndFound = TRUE;
            }
        }
        pbIndex++;
    }
    if (!bEndFound) {
        MD_ASSERT(pbIndex == pbEndReadData - 1);
        pbIndex++;
    }
    return pbIndex;
}

DWORD
GetLineFromBuffer(PBYTE &pbrNextPtr,
                  PBYTE &pbrEndReadData,
                  BUFFER *pbufLine,
                  DWORD &dwrLineLen,
                  BOOL &brEscapePending)
    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //
{
    DWORD dwReturn = ERROR_HANDLE_EOF;
    PBYTE pbLineIndex;
    DWORD dwBytesToRead;
    PBYTE pbEndReadLine;
    PBYTE pbReadDataIndex = pbrNextPtr;

    if (pbrNextPtr != pbrEndReadData) {
        //
        // first find out how many bytes we need to read
        //
        pbEndReadLine = FindEndOfData(pbrNextPtr, pbrEndReadData, brEscapePending);
        MD_ASSERT(pbEndReadLine > pbrNextPtr);

        //
        // Actual number of bytes needed may be less than the size of the data
        // but never more, so just resize for the max we might need
        //
        if (!pbufLine->Resize(dwrLineLen + DIFF(pbEndReadLine - pbrNextPtr))) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pbLineIndex = (PBYTE)pbufLine->QueryPtr() + dwrLineLen;
            if (brEscapePending) {
                brEscapePending = FALSE;
                if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                    dwReturn = ERROR_SUCCESS;
                    pbReadDataIndex++;
                }
            }
            while ((dwReturn != ERROR_SUCCESS) && (pbReadDataIndex < pbEndReadLine)) {
                if (*pbReadDataIndex != MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    pbReadDataIndex++;
                    if (pbReadDataIndex == pbEndReadLine) {
                        brEscapePending = TRUE;
                    }
                    else {
                        if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                            *pbLineIndex++ = *pbReadDataIndex++;
                        }
                        else {
                            MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                            pbReadDataIndex++;
                            dwReturn = ERROR_SUCCESS;
                        }
                    }
                }
            }
            dwrLineLen = DIFF(pbLineIndex - (PBYTE)pbufLine->QueryPtr());
            pbrNextPtr = pbReadDataIndex;
        }
    }
    return dwReturn;
}

HRESULT
GetNextLine(
         IN HANDLE hReadFileHandle,
         IN OUT PBYTE &pbrEndReadData,
         IN BUFFER *pbufRead,
         IN OUT BUFFER *pbufLine,
         IN OUT DWORD &dwrLineLen,
         IN OUT PBYTE &pbrNextPtr)
/*++

Routine Description:

    Get the next line. Performs buffered reads from a file. Only pbrCurPtr may be modified between calls.
    Other variables must be set up before the first call and not changed.

Arguments:

    ReadFileHandle - File to write to.

    EndReadDataPtr - Points past the end of the data in ReadBuf.

    Read       - Buffer for file data.

    Line       - A line buffer which the returned line is stored in.

    LineLen    - The length of the data in line

    NextPtr    - On entry, pointer to the next unread character in ReadBuf.
                 On exit, pointer to the new next unread character in ReadBuf.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_INVALID_DATA
                 Return codes from file system

Notes:
    On EOF, returns ERROR_SUCCESS, dwrLineLen = 0.

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwLineLen = 0;
    BOOL bEscapePending = FALSE;
    DWORD dwGetLineReturn = ERROR_HANDLE_EOF;
    BOOL bEOF = FALSE;

    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //

    while ((dwReturn == ERROR_SUCCESS) && (dwGetLineReturn == ERROR_HANDLE_EOF) && (!bEOF)) {

        dwGetLineReturn = GetLineFromBuffer(pbrNextPtr,
                                            pbrEndReadData,
                                            pbufLine,
                                            dwLineLen,
                                            bEscapePending);

        if (dwGetLineReturn == ERROR_HANDLE_EOF) {
            if (!ReadFile(hReadFileHandle,
                          (LPVOID) pbufRead->QueryPtr(),
                          pbufRead->QuerySize(),
                          &dwBytesRead,
                          NULL)) {
                dwReturn = GetLastError();
            }
            else {
                pbrEndReadData = (BYTE *)pbufRead->QueryPtr() + dwBytesRead;
                pbrNextPtr = (PBYTE)pbufRead->QueryPtr();
                if (dwBytesRead == 0) {
                    bEOF = TRUE;
                }
            }
        }
    }
    if (bEOF) {
        MD_ASSERT(dwGetLineReturn = ERROR_HANDLE_EOF);
        dwLineLen = 0;
    }
    else if (dwGetLineReturn != ERROR_SUCCESS) {
        dwReturn = dwGetLineReturn;
    }

    dwrLineLen = dwLineLen;
    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
GetLineID(
         IN OUT LPTSTR &strCurPtr)
/*++

Routine Description:

    Determines the ID of a line from the metadata file.

Arguments:

    CurPtr     - The line to ID. Updated on successful ID to point past
                 the id string.

Return Value:

    DWORD      - MD_ID_OBJECT
                 MD_ID_DATA
                 MD_ID_REFERENCE
                 MD_ID_ROOT_OBJECT
                 MD_ID_NONE

Notes:

--*/
{
    DWORD dwLineID;
    if (MD_STRNICMP(strCurPtr, MD_OBJECT_ID_STRING, ((sizeof(MD_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_DATA_ID_STRING, ((sizeof(MD_DATA_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_DATA;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_DATA_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_REFERENCE_ID_STRING, ((sizeof(MD_REFERENCE_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_REFERENCE;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_REFERENCE_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_ROOT_OBJECT_ID_STRING, ((sizeof(MD_ROOT_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_ROOT_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_ROOT_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_CHANGE_NUMBER_ID_STRING, ((sizeof(MD_CHANGE_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_CHANGE_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_CHANGE_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MAJOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MAJOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MINOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MINOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else {
        dwLineID = MD_ID_NONE;
    }
    return(dwLineID);
}

HRESULT
GetWarning(
         IN HRESULT hresWarningCode)
/*++

Routine Description:

    Converts error to warnings.

Arguments:

    WarnignCode - The error code to convert.

Return Value:

    DWORD      - MD_WARNING_PATH_NOT_FOUND
                 MD_WARNING_DUP_NAME
                 MD_WARNING_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn;
    switch (hresWarningCode) {
        case (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)):
            hresReturn = MD_WARNING_PATH_NOT_FOUND;
            break;
        case (RETURNCODETOHRESULT(ERROR_DUP_NAME)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        case (RETURNCODETOHRESULT(ERROR_INVALID_DATA)):
            hresReturn = MD_WARNING_INVALID_DATA;
            break;
        case (RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        default:
            hresReturn = hresWarningCode;
    }
    return (hresReturn);
}

BOOL CheckDigits(LPTSTR pszString)
{
    LPTSTR pszTemp;
    BOOL bDigitFound = FALSE;
    BOOL bReturn = FALSE;
    for (pszTemp = pszString;MD_ISDIGIT(*pszTemp); pszTemp++) {
        bDigitFound = TRUE;
    }
    if (bDigitFound && (*pszTemp == (TCHAR)'\0')) {
        bReturn = TRUE;
    }
    return bReturn;
}

HRESULT
InitStorageHelper(
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //
        storage = new IIS_CRYPTO_STORAGE();

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             TRUE,          // fUseMachineKeyset
                             hProv
                             );
                if (FAILED(hresReturn)) 
                {
                    DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:(IIS_CRYPTO_STORAGE) storage->Initialize() Failed err=0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:GetCryptoProvider Failed err=0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob(alignedBlob);
    }
    else
    {
        // something failed...
        DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:IISCryptoCloneBlobFromRawData Failed err=0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = storage;
    return hresReturn;

}   // InitStorageHelper

HRESULT
InitStorageHelper2(
    LPSTR pszPasswd,
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE2 *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData2(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {

        if (alignedBlob->BlobSignature != SALT_BLOB_SIGNATURE )
        {
            ::IISCryptoFreeBlob2(alignedBlob);
            return InitStorageHelper( RawBlob, RawBlobLength, NewStorage );
        }

        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //
        storage = new IIS_CRYPTO_STORAGE2;

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider2( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             pszPasswd, 
                             hProv
                             );
                if (FAILED(hresReturn)) 
                {
                    DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:(IIS_CRYPTO_STORAGE) storage->Initialize() Failed err=0x%x.\n",hresReturn));
                }
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:GetCryptoProvider Failed err=0x%x. (Crypto problem)\n",hresReturn));
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob2(alignedBlob);
    }
    else
    {
        // something failed...
        DBGPRINTF(( DBG_CONTEXT,"InitStorageHelper:IISCryptoCloneBlobFromRawData Failed err=0x%x. (Crypto problem).\n",hresReturn));
    }

    *NewStorage = ( IIS_CRYPTO_STORAGE * )storage;
    return hresReturn;

}   // InitStorageHelper2


HRESULT
ReadAllData(LPSTR pszPasswd,
            LPSTR pszBackupLocation,
            BOOL bHaveReadSaveSemaphore
            )
/*++

Routine Description:

    Reads all meta data from a file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarningCode = ERROR_SUCCESS;
    PBYTE  pbEndReadData;
    PBYTE  pbNextPtr;
    DWORD  dwLineLen;
    LPTSTR strReadFileName;
    HANDLE hReadFileHandle;
    BYTE   bLineId;
    DWORD  dwTemp;
    CMDBaseObject *pboRead;
    FILETIME ftTime;
    IIS_CRYPTO_STORAGE *pStorage = NULL;
    BOOL bUnicode;
    DWORD dwTempLastSaveChangeNumber = 0;

    BUFFER *pbufRead = new BUFFER(0);
    if( !pbufRead )
    {
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    BUFFER *pbufLine = new BUFFER(0);
    if( !pbufLine )
    {
        delete pbufRead;
        pbufRead = NULL;

        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    if( !pszPasswd )
    {
        strReadFileName = g_strRealFileName->QueryStr();
    }
    else
    {
        strReadFileName = pszBackupLocation;
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(strReadFileName,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0);

    if (hReadFileHandle == INVALID_HANDLE_VALUE) {
        dwTemp = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwTemp);
    }
    else {
        //
        // Allocate Buffers
        //
        if (!pbufLine->Resize(MAX_RECORD_BUFFER) ||
            !pbufRead->Resize(READWRITE_BUFFER_LENGTH)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            pbEndReadData = (PBYTE)pbufRead->QueryPtr();
            //
            // GetNextLine makes sure that the next line is in the buffer and sets strCurPtr to point to it
            // The line is NULL terminated, no new line. The variables passed in must not be modified outside
            // of GetNextLine.
            //
            dwLineLen = 0;
            pbNextPtr = pbEndReadData;
            hresReturn = GetNextLine(hReadFileHandle,
                                  pbEndReadData,
                                  pbufRead,
                                  pbufLine,
                                  dwLineLen,
                                  pbNextPtr);
            if (SUCCEEDED(hresReturn)) {
                //
                // See if it's our file
                //
                if (dwLineLen == sizeof(MD_SIGNATURE_STRINGA) &&
                    (MD_CMP(MD_SIGNATURE_STRINGA, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = FALSE;
                }
                else if  (dwLineLen == sizeof(MD_SIGNATURE_STRINGW) &&
                    (MD_CMP(MD_SIGNATURE_STRINGW, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = TRUE;
                }
                else {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }

                if (SUCCEEDED(hresReturn)) {
                    //
                    // The first GetNextLine filled the buffer
                    // so we may not need to do any file system stuff
                    // with g_rMasterResource locked.
                    //
                    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

                    while ((SUCCEEDED(hresReturn)) &&
                           (SUCCEEDED(hresReturn = GetNextLine(hReadFileHandle,
                                                   pbEndReadData,
                                                   pbufRead,
                                                   pbufLine,
                                                   dwLineLen,
                                                   pbNextPtr))) &&
                           (dwLineLen > 0) &&
                           (((bLineId = *(BYTE *)(pbufLine->QueryPtr())) == MD_ID_NONE) ||
                               (bLineId == MD_ID_MAJOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_MINOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_CHANGE_NUMBER) ||
                               (bLineId == MD_ID_SESSION_KEY))) {

                        if (bLineId != MD_ID_NONE) {
                            if (bLineId != MD_ID_SESSION_KEY &&
                                dwLineLen != (1 + sizeof(DWORD))) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                            }
                            else {
                                dwTemp = *(UNALIGNED DWORD *)FIRSTDATAPTR(pbufLine);
                                switch (bLineId) {
                                case MD_ID_MAJOR_VERSION_NUMBER:
                                    g_dwMajorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_MINOR_VERSION_NUMBER:
                                    g_dwMinorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_CHANGE_NUMBER:
                                    g_dwSystemChangeNumber = dwTemp;
                                    break;
                                case MD_ID_SESSION_KEY:
                                    {
                                        BOOL    fSecuredRead = TRUE;
                                        HKEY    hkRegistryKey = NULL;
                                        DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

                                            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                                                     SETUP_REG_KEY,
                                                                     &hkRegistryKey);
                                            if (dwRegReturn == ERROR_SUCCESS)
                                            {
                                                dwSize = MAX_PATH * sizeof(TCHAR);
                                                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                                                MD_UNSECUREDREAD_VALUE,
                                                                NULL,
                                                                &dwType,
                                                                (BYTE *)&dwValue,
                                                                &dwSize);
                                                if ( dwRegReturn == ERROR_SUCCESS &&
                                                     dwType == REG_DWORD &&
                                                     dwValue == 1)
                                                {
                                                    hresReturn = NO_ERROR;
                                                    pStorage = NULL;
                                                    fSecuredRead = FALSE;

                                                    DBGPRINTF(( DBG_CONTEXT,
                                                                "Temporary disabling  decryption for metabase read\n"));


                                                    // special indicator for IIS setup that we passed this point
                                                    dwValue = 2;
                                                    dwRegReturn = RegSetValueEx(hkRegistryKey,
                                                                    MD_UNSECUREDREAD_VALUE,
                                                                    0,
                                                                    REG_DWORD,
                                                                    (PBYTE)&dwValue,
                                                                    sizeof(dwValue));
                                                    if (dwRegReturn == ERROR_SUCCESS)
                                                    {
                                                        DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
                                                    }

                                                }
                                                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
                                            }

                                        if (fSecuredRead)
                                        {
                                            if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) FIRSTDATAPTR(pbufLine)))
                                            {
                                                    // call special function focibly tell that this machine has no
                                                    // encryption enabled even if it happens to be so
                                                    // that's a special handling for French case with US locale
                                                    IISCryptoInitializeOverride (FALSE);
                                            }

                                            if( !pszPasswd )
                                            {
                                                hresReturn = InitStorageHelper(
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                             else
                                             {
                                                hresReturn = InitStorageHelper2(
                                                               pszPasswd,
                                                               FIRSTDATAPTR(pbufLine),
                                                               dwLineLen-1,
                                                               &pStorage
                                                               );
                                             }
                                        }
                                    }
                                    break;
                                default:
                                    MD_ASSERT(FALSE);
                                }
                            }
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {

                        //
                        // This must be the global master object
                        //
                        if ((dwLineLen != 1 + sizeof(FILETIME)) || (bLineId != MD_ID_ROOT_OBJECT)) {
                            //
                            // This file is hosed
                            //
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                        else {
                            //
                            // Got the MasterRoot Object.
                            //

                            ftTime = *(UNALIGNED FILETIME *)FIRSTDATAPTR(pbufLine);
                            g_pboMasterRoot->SetLastChangeTime(&ftTime);
                            //
                            // Read in MasterRoot Data.
                            //
                            for (hresReturn = GetNextLine(hReadFileHandle,
                                                  pbEndReadData,
                                                  pbufRead,
                                                  pbufLine,
                                                  dwLineLen,
                                                  pbNextPtr);
                                ((SUCCEEDED(hresReturn)) && (dwLineLen != 0)
                                && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr)) {
                                if (bLineId == MD_ID_DATA) {

                                    hresReturn = ReadDataObject( g_pboMasterRoot, 
                                                                 pbufLine, 
                                                                 dwLineLen, 
                                                                 pStorage, 
                                                                 bUnicode
                                                                 );
                                }
                            }
                        }
                    }
                    //
                    // All of the required stuff is read in, and the next line is either
                    // NULL or the first normal object.
                    // Loop through all normal objects.
                    //
                    if (SUCCEEDED(hresReturn)) {
                        while ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                            MD_ASSERT(bLineId == MD_ID_OBJECT);

                            for (hresReturn = ReadMetaObject(pboRead,
                                                           pbufLine,
                                                           dwLineLen,
                                                           pStorage,
                                                           bUnicode);
                                (FAILED(hresReturn));
                                hresReturn = ReadMetaObject(pboRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pStorage,
                                                          bUnicode)) {

                                //
                                // This for loop normally shouldn't be executed.
                                // The purpose of the loop is to ignore problems if
                                // the object is bad.
                                //
                                if (hresReturn == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                    //
                                    // Serious error, we're done.
                                    //
                                    break;
                                }
                                else {
                                    //
                                    // Just give a warning and go to the next object
                                    // Ignore everything until we get to the next object
                                    //
                                    hresWarningCode = hresReturn;

                                    for (hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr);
                                        ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                        && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                        hresReturn = GetNextLine(hReadFileHandle,
                                                              pbEndReadData,
                                                              pbufRead,
                                                              pbufLine,
                                                              dwLineLen,
                                                              pbNextPtr)) {

                                    }
                                    if (dwLineLen == 0) {
                                        //
                                        // EOF, we're done
                                        //
                                        break;
                                    }
                                }
                            }
                            if ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                                //
                                // Got an object.
                                // Read in data.
                                //
                                for (hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr);
                                    ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                    //
                                    // GetLineID increments strCurPtr if a match is found
                                    //
                                    && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                    hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr)) {
                                    if (bLineId == MD_ID_DATA) {
                                        hresReturn = ReadDataObject( pboRead,
                                                                     pbufLine,
                                                                     dwLineLen,
                                                                     pStorage,
                                                                     bUnicode
                                                                     );

                                        //
                                        // dwReturn gets blown away by the for loop.
                                        // Most errors we can just ignore anyway, but
                                        // save a warning.
                                        //
                                        if (FAILED(hresReturn)) {
                                            if (hresReturn != RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                                hresWarningCode = hresReturn;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
                    g_rMasterResource->Unlock();
                }
            }
            if (!CloseHandle(hReadFileHandle)) {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
        }
    }
    //
    // File not found is ok
    // Start with MasterRoot only
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    if ((SUCCEEDED(hresReturn)) && (hresWarningCode != ERROR_SUCCESS)) {
        hresReturn = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hresReturn)) {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    //
    // Cleanup
    //
    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    delete(pbufRead);
    delete(pbufLine);
    delete(pStorage);
    return hresReturn;
}

HRESULT
InitWorker(
    IN BOOL bHaveReadSaveSemaphore,
    IN LPSTR pszPasswd,
    IN LPSTR pszBackupLocation
    )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized++ > 0) {
        hresReturn = g_hresInitWarning;
    }
    else {
        g_pboMasterRoot = NULL;
        g_phHandleHead = NULL;
        for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
            g_phEventHandles[i] = NULL;
        }
        g_mhHandleIdentifier = METADATA_MASTER_ROOT_HANDLE;
        g_pboMasterRoot = new CMDBaseObject(MD_MASTER_ROOT_NAME);
        g_ppbdDataHashTable = NULL;
        g_dwSystemChangeNumber = 0;
        g_strRealFileName = NULL;
        g_strTempFileName = NULL;
        g_strBackupFileName = NULL;
        g_pstrBackupFilePath = NULL;

        g_psidSystem = NULL;
        g_psidAdmin = NULL;
        g_paclDiscretionary = NULL;
        g_psdStorage = NULL;

        if ((g_pboMasterRoot == NULL) || (!(g_pboMasterRoot->IsValid()))) {

            IIS_PRINTF((buff,"Unable to allocate CMDBaseObject\n"));
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            g_pboMasterRoot->SetParent(NULL);
            g_phHandleHead = new CMDHandle(g_pboMasterRoot,
                                           METADATA_PERMISSION_READ,
                                           g_dwSystemChangeNumber,
                                           g_mhHandleIdentifier++);
            if (g_phHandleHead == NULL) {
                IIS_PRINTF((buff,"Unable to allocate CMDHandle\n"));
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                g_phHandleHead->SetNextPtr(NULL);
                if( ( g_phEventHandles[EVENT_READ_INDEX] = IIS_CREATE_EVENT(
                                                               "g_phEventHandles[EVENT_READ_INDEX]",
                                                               &g_phEventHandles[EVENT_READ_INDEX],
                                                               TRUE,
                                                               FALSE
                                                               ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if( ( g_phEventHandles[EVENT_WRITE_INDEX] = IIS_CREATE_EVENT(
                                                                   "g_phEventHandles[EVENT_WRITE_INDEX]",
                                                                   &g_phEventHandles[EVENT_WRITE_INDEX],
                                                                   TRUE,
                                                                   FALSE
                                                                   ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if ((g_ppbdDataHashTable = new CMDBaseData *[DATA_HASH_TABLE_LEN]) == NULL) {
                    IIS_PRINTF((buff,"Unable to allocate CMDBaseData\n"));
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = InitBufferPool();
                    if (SUCCEEDED(hresReturn)) {
                        for (int i =0; i < DATA_HASH_TABLE_LEN; i++) {
                            g_ppbdDataHashTable[i] = NULL;
                        }

                        //
                        // Code Work:
                        // There is a conceiveable deadlock if ReadAllData is called with g_rMasterResource Locked, 
                        // due to the semaphore used to control file access. Would like to release g_rMasterResource, 
                        // but that could cause duplicate inits.
                        //

                        hresReturn = SetStorageSecurityDescriptor();
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetDataFile();
                            if (SUCCEEDED(hresReturn)) {
                                hresReturn = ReadAllData(pszPasswd, pszBackupLocation, bHaveReadSaveSemaphore);
                            }
//                            if ((RetCode = SetRegistryStoreValues()) == ERROR_SUCCESS) {
//                                RetCode = ReadAllDataFromRegistry();
//                            }
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {

            // Check if the Major/Minor version needs to get updated...
            // if there is a specified version in the registry (set by iis setup during upgrade)
            // then use that new version, if it's not a dword, then use the default for g_dwMajorVersionNumber.
            CheckForNewMetabaseVersion();

            if (!CheckVersionNumber()) {
                IIS_PRINTF((buff,"MD: Invalid version number\n"));
                hresReturn = MD_ERROR_INVALID_VERSION;
            }
        }

        if (FAILED(hresReturn)) {
            g_dwInitialized--;
            delete(g_pboMasterRoot);
            delete(g_phHandleHead);
            delete(g_ppbdDataHashTable);
            DeleteBufferPool();
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                if (g_phEventHandles[i] != NULL) {
                    CloseHandle(g_phEventHandles[i]);
                }
            }
            ReleaseStorageSecurityDescriptor();
        }
        //
        // Save the return code.
        // Secondary init's repeat warnings.
        // If error, the next init will overwrite this.
        // So don't worry about setting this to errors.
        //
        g_hresInitWarning = hresReturn;
    }
    g_rMasterResource->Unlock();
    return hresReturn;
}

HRESULT
TerminateWorker1(
         IN BOOL bHaveReadSaveSemaphore
         )
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {
            if (g_dwInitialized == 1) {
                hresReturn = SaveAllData(FALSE,
                                         &CryptoStorage,
                                         pSessionKeyBlob,
                                         NULL,
                                         METADATA_MASTER_ROOT_HANDLE,
                                         bHaveReadSaveSemaphore);
//                RetCode = SaveAllDataToRegistry();
            }
            if (SUCCEEDED(hresReturn)) {
                if (--g_dwInitialized == 0)
                    TerminateWorker();
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }
    else
    {
        // pretty serious.
        DBGPRINTF(( DBG_CONTEXT, "TerminateWorker1.InitStorageAndSessionKey:Failed - error 0x%0x\n", hresReturn));
    }

    return hresReturn;
}

VOID
TerminateWorker()
{
/*++

Routine Description:

    Worker routine for termination.

Arguments:

    SaveData   - If true, saves metadata.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

    If SaveData is TRUE and the save fails, the termination code is not executed
    and an error code is returned.

--*/
    CMDHandle *CurHandle, *NextHandle;
    for (CurHandle = g_phHandleHead;CurHandle!=NULL;CurHandle=NextHandle) {
        NextHandle = CurHandle->GetNextPtr();
        delete (CurHandle);
    }

    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        if (g_phEventHandles[i] != NULL) {
            CloseHandle(g_phEventHandles[i]);
        }
    }
    delete(g_pboMasterRoot);

    //
    // All data objects should be deleted by
    // deleting the handles and masterroot
    // but it's possible a client failed
    // to release a data by reference so
    // destroy all remaining data objects
    //

    DeleteAllRemainingDataObjects();
    ReleaseStorageSecurityDescriptor();

    delete (g_ppbdDataHashTable);
    delete(g_strRealFileName);
    delete(g_strTempFileName);
    delete(g_strBackupFileName);
    delete(g_pstrBackupFilePath);
    DeleteBufferPool();
}

HRESULT
SetStorageSecurityDescriptor()
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL status;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PLATFORM_TYPE platformType;

    //
    // Verify that globals were initialized correctly.
    //


    MD_ASSERT(g_psidSystem == NULL);
    MD_ASSERT(g_psidAdmin == NULL);
    MD_ASSERT(g_paclDiscretionary == NULL);
    MD_ASSERT(g_psdStorage == NULL);

    //
    // Of course, we only need to do this under NT...
    //

    platformType = IISGetPlatformType();

    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        g_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (g_psdStorage == NULL) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     g_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidSystem)
                       - sizeof(DWORD);

        g_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( g_paclDiscretionary == NULL ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     g_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     g_psdStorage,
                     TRUE,
                     g_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }
    }

fatal:

    if (FAILED(hresReturn)) {
        ReleaseStorageSecurityDescriptor();

    }

    return hresReturn;

}

VOID
ReleaseStorageSecurityDescriptor()
{
    if( g_paclDiscretionary != NULL ) {
        LocalFree( g_paclDiscretionary );
        g_paclDiscretionary = NULL;
    }

    if( g_psidAdmin != NULL ) {
        FreeSid( g_psidAdmin );
        g_psidAdmin = NULL;

    }

    if( g_psidSystem != NULL ) {
        FreeSid( g_psidSystem );
        g_psidSystem = NULL;
    }

    if( g_psdStorage != NULL ) {
        LocalFree( g_psdStorage );
        g_psdStorage = NULL;
    }
}

HRESULT
ExtractNameFromPath(
         IN OUT LPSTR &strPath,
         OUT LPSTR strNameBuffer,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    LPSTR pszIndex;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (bUnicode) {
        LPWSTR wstrPath = (LPWSTR)strPath;
        hresReturn = ExtractNameFromPath(&wstrPath, (LPWSTR)strNameBuffer);
        strPath = (LPSTR) wstrPath;
    }
    else {
        if (strPath != NULL) {
            for (pszIndex = strPath;
                 ((pszIndex - strPath) < METADATA_MAX_NAME_LEN) && (*pszIndex != (TCHAR)'\0') &&
                    (*pszIndex != MD_PATH_DELIMETER) && (*pszIndex != MD_ALT_PATH_DELIMETER);
                 pszIndex = CharNextExA(CP_ACP,
                                        pszIndex,
                                        0)) {
            }
            DWORD dwStrBytes = DIFF(pszIndex - strPath);
            if ((dwStrBytes) >= METADATA_MAX_NAME_LEN) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
            }
            else {
                MD_COPY(strNameBuffer, strPath, dwStrBytes);
                strNameBuffer[dwStrBytes] = (TCHAR)'\0';
                strPath = pszIndex;
                if (*strNameBuffer != (TCHAR)'\0') {
                    //
                    // if a non-null name
                    //
                    SKIP_PATH_DELIMETERA(strPath);
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
ExtractNameFromPath(
         IN OUT LPWSTR *pstrPath,
         OUT LPWSTR strNameBuffer)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    int i;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (*pstrPath != NULL) {
        for (i = 0;
            (i < METADATA_MAX_NAME_LEN) && ((*pstrPath)[i] != (WCHAR)'\0') &&
                ((*pstrPath)[i] != (WCHAR)MD_PATH_DELIMETER) && ((*pstrPath)[i] != (WCHAR)MD_ALT_PATH_DELIMETER);
            i++) {
            strNameBuffer[i] = (*pstrPath)[i];
        }
        if (i == METADATA_MAX_NAME_LEN) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
        }
        else {
            strNameBuffer[i] = (WCHAR)'\0';
            *pstrPath += i;
            if (*strNameBuffer != (WCHAR)'\0') {
                //
                // if a non-null name
                //
                SKIP_PATH_DELIMETERW(*pstrPath);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
    return (hresReturn);
}

BOOL DataMatch(IN CMDBaseData *pbdExisting,
               IN PMETADATA_RECORD pmdrData,
               OUT PBOOL pbError,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Determines if a set of data maches an existing object.

Arguments:

    Existing   - The existing data object.

    Identifier - The Identifier of the data.

    Attributes - The flags for the data.
                      METADATA_INHERIT

    UserType   - The User Type for the data. User Defined.

    DataType   - The Type of the data.
                      DWORD_METADATA
                      STRING_METADATA
                      BINARY_METADATA

    DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.
                 Binary data must not exceed METADATA_MAX_BINARY_LEN bytes.
                 String data must not exceed METADATA_MAX_STRING_LEN characters,
                 include the trailing '\0'.

    Data       - Pointer to the data.


Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    BOOL bReturn = TRUE;
    BOOL bError = FALSE;

    if ((pmdrData->dwMDIdentifier != pbdExisting->GetIdentifier()) ||
        (pmdrData->dwMDAttributes != pbdExisting->GetAttributes()) ||
        (pmdrData->dwMDUserType != pbdExisting->GetUserType()) ||
        (pmdrData->dwMDDataType != pbdExisting->GetDataType())) {
        bReturn = FALSE;
    }
    else {
        if (pbdExisting->GetData(bUnicode) == NULL) {
            bError = TRUE;
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    if (*(DWORD *)(pmdrData->pbMDData) != *(DWORD *)(pbdExisting->GetData())) {
                        bReturn = FALSE;
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszStringData = (LPWSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = L"";
                        }
                        if (wcscmp(pszStringData, (LPWSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    else {
                        LPSTR pszStringData = (LPSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = "";
                        }
                        if (MD_STRCMP(pszStringData, (LPSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                case BINARY_METADATA:
                case MULTISZ_METADATA:
                {
                    if (pmdrData->dwMDDataLen != pbdExisting->GetDataLen(bUnicode)) {
                        bReturn = FALSE;
                    }
                    else {
                        if (MD_CMP(pmdrData->pbMDData, pbdExisting->GetData(bUnicode), pmdrData->dwMDDataLen) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                default: {
                    bReturn = FALSE;
                }
            }
        }
    }
    *pbError = bError;
    return (bReturn);
}

VOID
DeleteDataObject(
         IN CMDBaseData *pbdDelete)
/*++

Routine Description:

    Decrements the reference count of an object and deletes it if the reference count becomes 0.

Arguments:

    Delete      - The data object to delete.

Return Value:

Notes:

--*/
{
    DWORD dwHash = DATA_HASH(pbdDelete->GetIdentifier());
    CMDBaseData *pdataIndex;

    MD_ASSERT(pbdDelete != NULL);
    if (pbdDelete->DecrementReferenceCount() == 0) {
        if (g_ppbdDataHashTable[dwHash] == pbdDelete) {
            g_ppbdDataHashTable[dwHash] = pbdDelete->GetNextPtr();
        }
        else {
            for (pdataIndex=g_ppbdDataHashTable[dwHash];
                pdataIndex->GetNextPtr() != pbdDelete;
                pdataIndex = pdataIndex->GetNextPtr()) {
            }
            pdataIndex->SetNextPtr(pbdDelete->GetNextPtr());
        }
        switch (pbdDelete->GetDataType()) {
        case DWORD_METADATA: {
            delete ((CMDDWData *) pbdDelete);
            break;
        }
        case STRING_METADATA: {
            delete ((CMDSTRData *) pbdDelete);
            break;
        }
        case BINARY_METADATA: {
            delete ((CMDBINData *) pbdDelete);
            break;
        }
        case EXPANDSZ_METADATA: {
            delete ((CMDEXSZData *) pbdDelete);
            break;
        }
        case MULTISZ_METADATA: {
            delete ((CMDMLSZData *) pbdDelete);
            break;
        }
        default: {
            MD_ASSERT(FALSE);
            delete (pbdDelete);
        }
        }
    }
}

VOID
DeleteAllRemainingDataObjects()
{
    DWORD i;
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdSave;

    for (i = 0; i < DATA_HASH_TABLE_LEN; i++) {
        for (pbdIndex=g_ppbdDataHashTable[i];
            pbdIndex != NULL;
            pbdIndex = pbdSave) {
            pbdSave = pbdIndex->GetNextPtr();
            switch (pbdIndex->GetDataType()) {
            case DWORD_METADATA: {
                delete ((CMDDWData *) pbdIndex);
                break;
            }
            case STRING_METADATA: {
                delete ((CMDSTRData *) pbdIndex);
                break;
            }
            case BINARY_METADATA: {
                delete ((CMDBINData *) pbdIndex);
                break;
            }
            case EXPANDSZ_METADATA: {
                delete ((CMDEXSZData *) pbdIndex);
                break;
            }
            case MULTISZ_METADATA: {
                delete ((CMDMLSZData *) pbdIndex);
                break;
            }
            default: {
                MD_ASSERT(FALSE);
                delete (pbdIndex);
            }
            }
        }
    }
}


BOOL
ValidateData(IN PMETADATA_RECORD pmdrData,
             IN BOOL bUnicode)
/*++

Routine Description:

    Checks data values for new metadata.

Arguments:

    Data       - The data structure. All fields must be set.

        Attributes - The flags for the data.
                 METADATA_INHERIT - If set on input, inherited data will be returned.
                                    If not set on input, inherited data will not be returned.

                 METADATA_PARTIAL_PATH - If set on input, this routine will return ERROR_SUCCESS
                                    and the inherited data even if the entire path is not present.
                                    Only valid if METADATA_INHERIT is also set.

        DataType   - The Type of the data.
                 DWORD_METADATA
                 STRING_METADATA
                 BINARY_METADATA

Return Value:

    BOOL       - TRUE if the data values are valid.

Notes:
--*/
{
    BOOL bReturn = TRUE;

    if (((pmdrData->pbMDData == NULL) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) ||
                (((pmdrData->dwMDDataType == BINARY_METADATA) ||
                    (pmdrData->dwMDDataType == MULTISZ_METADATA)) &&
                        (pmdrData->dwMDDataLen > 0)))) ||
        (pmdrData->dwMDDataType <= ALL_METADATA) ||
        (pmdrData->dwMDDataType >= INVALID_END_METADATA) ||
        ((pmdrData->dwMDAttributes &
            ~(METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE | METADATA_VOLATILE | METADATA_INSERT_PATH | METADATA_LOCAL_MACHINE_ONLY))!=0) ||
        (((pmdrData->dwMDAttributes & METADATA_REFERENCE) != 0) &&
            ((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0)) ||
        (((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) || (pmdrData->dwMDDataType == BINARY_METADATA)))) {
        bReturn = FALSE;
    }

    if (bReturn && (pmdrData->dwMDDataType == MULTISZ_METADATA)) {
        if (bUnicode) {
            LPWSTR pszData = (LPWSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen / 2) <= 1) ||
                    (pszData[(dwDataLen / 2) - 1] != (WCHAR)'\0') ||
                    (pszData[(dwDataLen / 2) - 2] != (WCHAR)'\0')) {
                    bReturn = FALSE;
                }
            }
        }
        else {
            LPSTR pszData = (LPSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen) == 1) ||
                    (pszData[(dwDataLen) - 1] != '\0') ||
                    (pszData[(dwDataLen) - 2] != '\0')) {
                    bReturn = FALSE;
                }
            }
        }
    }

    return (bReturn);
}

CMDBaseData *
MakeDataObject(IN PMETADATA_RECORD pmdrData,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Looks for a data object matching the parameters.
    If found, increments the reference count. If not found, it
    creates it.

Arguments:

    Data - The data for the new object.

        Identifier - The Identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdReturn = NULL;
    CMDBaseData *pbdNew = NULL;
    DWORD dwHash = DATA_HASH(pmdrData->dwMDIdentifier);
    BOOL bDataMatchError = FALSE;

    for (pbdIndex = g_ppbdDataHashTable[dwHash];
        (pbdIndex != NULL) &&
        !DataMatch(pbdIndex, pmdrData, &bDataMatchError, bUnicode) &&
        !bDataMatchError;
        pbdIndex = pbdIndex->GetNextPtr()) {
    }
    if (!bDataMatchError) {
        if (pbdIndex != NULL) {
            pbdReturn = pbdIndex;
            pbdReturn->IncrementReferenceCount();
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    pbdNew = new CMDDWData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, *(DWORD *)(pmdrData->pbMDData));
                    break;
                }
                case STRING_METADATA: {
                    pbdNew = new CMDSTRData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case BINARY_METADATA: {
                    pbdNew = new CMDBINData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, pmdrData->dwMDDataLen, pmdrData->pbMDData);
                    break;
                }
                case EXPANDSZ_METADATA: {
                    pbdNew = new CMDEXSZData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, (LPTSTR) (pmdrData->pbMDData), bUnicode);
                    break;
                }
                case MULTISZ_METADATA: {
                    pbdNew = new CMDMLSZData(pmdrData->dwMDIdentifier,
                                             pmdrData->dwMDAttributes,
                                             pmdrData->dwMDUserType,
                                             pmdrData->dwMDDataLen,
                                             (LPSTR)pmdrData->pbMDData,
                                             bUnicode);
                    break;
                }
                default: {
                    pbdNew = NULL;
                }
            }
            if (pbdNew != NULL) {
                if (!(pbdNew->IsValid())) {
                    delete (pbdNew);
                }
                else {
                    pbdNew->SetNextPtr(g_ppbdDataHashTable[dwHash]);
                    g_ppbdDataHashTable[dwHash] = pbdNew;
                    pbdReturn = pbdNew;
                }
            }
        }
    }
    return (pbdReturn);
}

HRESULT
GetHighestVersion(IN OUT STRAU *pstrauBackupLocation,
                  OUT DWORD *pdwVersion)
{
    long lHighestVersion = -1;
    long lVersion;
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwPathBytes = g_pstrBackupFilePath->QueryCB() + 1;
    DWORD dwNameBytes = pstrauBackupLocation->QueryCBA() - dwPathBytes;
    if (!pstrauBackupLocation->Append("*")) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        if (pstrauBackupLocation->QueryStrA() == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            hFile = FindFirstFile(pstrauBackupLocation->QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }
            else {
                //
                // Process the first file
                //

                //
                // dwNameBytes could be wrong for this assert in MBCS,
                // so call MBCS strlen. Subtract 1 char for appended '*'
                //

                MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                      wfdFile.cFileName,
                                      MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                if (CheckDigits(wfdFile.cFileName + (dwNameBytes))) {
                    //
                    // One of our files
                    //
                    lVersion = atol(wfdFile.cFileName + dwNameBytes);
                    if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                         (lVersion > lHighestVersion)) {
                        lHighestVersion = lVersion;
                    }
                }
                //
                // Process the remaining files
                //
                while (FindNextFile(hFile, &wfdFile)) {
                    MD_ASSERT(MD_STRNICMP(pstrauBackupLocation->QueryStrA() + dwPathBytes,
                                          wfdFile.cFileName,
                                          MD_STRLEN(pstrauBackupLocation->QueryStrA() + dwPathBytes) - 1) == 0);
                    if (CheckDigits(wfdFile.cFileName + dwNameBytes)) {
                        //
                        // One of our files
                        //
                        lVersion = atol(wfdFile.cFileName + dwNameBytes);
                        if ((lVersion <= MD_BACKUP_MAX_VERSION) &&
                             (lVersion > lHighestVersion)) {
                            lHighestVersion = lVersion;
                        }
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                if (lHighestVersion == -1) {

                    //
                    // May not be an error, but need to indicate that
                    // no backups were found.
                    //

                    hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                }
                else if (lHighestVersion <= MD_BACKUP_MAX_VERSION) {
                        *pdwVersion = lHighestVersion;
                }
                else {
                        hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                }
            }
        }
        pstrauBackupLocation->SetLen(pstrauBackupLocation->QueryCCH() - 1);

    }

    return hresReturn;
}

BOOL
ValidateBackupLocation(LPSTR pszBackupLocation,
                       BOOL bUnicode)
{

    //
    // The main purpose of this routine is to make sure the user
    // is not putting in any file system controls, like .., /, etc.

    //
    // Secondarily, try to eliminate any characters that cannot be
    // used in database names
    //

    BOOL bReturn = TRUE;
    DWORD  dwStringLen;

    MD_ASSERT(pszBackupLocation != NULL);

	char *pszLocSave = setlocale(LC_CTYPE, NULL);	// Save cur locale
	setlocale(LC_CTYPE, "");						// Set sys locale
	
    //
    // strcspn doesn't have an error return, but will return
    // the index of the terminating NULL if the chars are not found
    //

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (wcscspn((LPWSTR)pszBackupLocation, MD_BACKUP_INVALID_CHARS_W) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = (LPWSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (iswprint(*pszIndex));
                 pszIndex++) {
            }
            if (*pszIndex != (WCHAR)'\0') {
                bReturn = FALSE;

            }
        }
    }
    else {
        dwStringLen = _mbslen((PBYTE)pszBackupLocation);
        if ((dwStringLen >= MD_BACKUP_MAX_LEN) ||
            (_mbscspn((PBYTE)pszBackupLocation, (PBYTE)MD_BACKUP_INVALID_CHARS_A) !=
            dwStringLen)) {
            bReturn = FALSE;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = (LPSTR)pszBackupLocation;
                 (*pszIndex != (WCHAR)'\0') &&
                     (_ismbcprint(*pszIndex));
                     pszIndex = CharNextExA(CP_ACP,
                                            pszIndex,
                                            0)) {
            }
            if (*pszIndex != '\0') {
                bReturn = FALSE;

            }
        }
    }

	setlocale(LC_CTYPE, pszLocSave);
    return bReturn;
}

DWORD
GetBackupNameLen(LPSTR pszBackupName)

//
// Get Number of Bytes in name prior to suffix
//

{
    LPSTR pszSubString = NULL;
    LPSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = (LPSTR)MD_STRCHR(pszBackupName, '.')) != NULL);
    while (pszNextSubString != NULL) {

        //
        // In case the suffix happens to be part of the name
        //

        pszSubString = pszNextSubString;
        pszNextSubString = (LPSTR)MD_STRCHR(pszSubString+1, '.');
    }

    if (pszSubString
        && (pszSubString[1] != '\0')
        && (pszSubString[2] != '\0')
        && !IsDBCSLeadByte(pszSubString[1])
        && (toupper(pszSubString[1]) == 'M')
        && (toupper(pszSubString[2]) == 'D')) {
        return DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }
}

DWORD
GetBackupNameLen(LPWSTR pszBackupName)

//
// Get Number of WCHARs in name prior to version Number
//

{
    LPWSTR pszSubString = NULL;
    LPWSTR pszNextSubString;
    MD_REQUIRE((pszNextSubString = wcschr(pszBackupName, L'.')) != NULL);
    while (pszNextSubString != NULL) {
        pszSubString = pszNextSubString;
        pszNextSubString = wcschr(pszSubString+1, L'.');
    }
    if (pszSubString
        && (pszSubString[1] != L'\0')
        && (pszSubString[2] != L'\0')
        && (towupper(pszSubString[1]) == L'M')
        && (towupper(pszSubString[2]) == L'D')) {
        return DIFF(pszSubString - pszBackupName);
    }
    else {
        return 0;
    }
}

HRESULT CreateBackupFileName(IN LPSTR pszMDBackupLocation,
                             IN DWORD dwMDVersion,
                             IN BOOL  bUnicode,
                             IN OUT STRAU *pstrauBackupLocation)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszBackupLocation = pszMDBackupLocation;

    if (((dwMDVersion > MD_BACKUP_MAX_VERSION) &&
           (dwMDVersion != MD_BACKUP_NEXT_VERSION) &&
           (dwMDVersion != MD_BACKUP_HIGHEST_VERSION)) ||
        ((pszBackupLocation != NULL) &&
            !ValidateBackupLocation(pszBackupLocation, bUnicode))) {
        hresReturn = E_INVALIDARG;
    }
    else {

        if ((pszBackupLocation == NULL) ||
            (bUnicode && ((*(LPWSTR)pszBackupLocation) == (WCHAR)'\0')) ||
            (!bUnicode && ((*(LPSTR)pszBackupLocation) == (CHAR)'\0'))) {
            pszBackupLocation = MD_DEFAULT_BACKUP_LOCATION;
            bUnicode = FALSE;
        }

        if (!pstrauBackupLocation->Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pstrauBackupLocation->Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (!pstrauBackupLocation->Append((LPWSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else {
                if (!pstrauBackupLocation->Append((LPSTR)pszBackupLocation)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (!pstrauBackupLocation->Append(MD_BACKUP_SUFFIX)) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                DWORD dwVersion = dwMDVersion;
                if (dwVersion == MD_BACKUP_NEXT_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                    if (SUCCEEDED(hresReturn)) {
                        if (dwVersion < MD_BACKUP_MAX_VERSION) {
                            dwVersion++;
                        }
                        else {
                            hresReturn =  RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                        }
                    }
                    else if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {

                        //
                        // Database doesn't exist, so new version is 0
                        //

                        dwVersion = 0;
                        hresReturn = ERROR_SUCCESS;
                    }
                }
                else if (dwVersion == MD_BACKUP_HIGHEST_VERSION) {
                    hresReturn = GetHighestVersion(pstrauBackupLocation, &dwVersion);
                }
                if (SUCCEEDED(hresReturn)) {
                    CHAR pszBuffer[MD_MAX_DWORD_STRING];
                    _ultoa((int)dwVersion, pszBuffer, 10);
                    if (!pstrauBackupLocation->Append(pszBuffer)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Make sure the ANSI buffer is valid
            //
            if (pstrauBackupLocation->QueryStrA() == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    return hresReturn;
}

HRESULT SetBackupPath(LPSTR pszBackupPath)
{
    DWORD dwReturn = ERROR_DIRECTORY;
    DWORD dwDirectoryAttributes;

    dwDirectoryAttributes = GetFileAttributes(pszBackupPath);

    if (dwDirectoryAttributes == 0xffffffff) {
        //
        // Can't get attributes
        // Path probably doesn't exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else if (!(CreateDirectory(pszBackupPath,
                                  NULL))) {
            dwReturn = GetLastError();
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }
    else if ((dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        //
        // If a directory
        //
        dwReturn = ERROR_SUCCESS;
    }
    if (dwReturn == ERROR_SUCCESS) {
        //
        // Got it! Now set global variable
        //
        MD_ASSERT(g_pstrBackupFilePath == NULL);
        g_pstrBackupFilePath = new STR(pszBackupPath);
        if (g_pstrBackupFilePath == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (!(g_pstrBackupFilePath->IsValid())) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            delete g_pstrBackupFilePath;
            g_pstrBackupFilePath = NULL;
        }
        else {
            dwReturn = ERROR_SUCCESS;
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetGlobalDataFileValues(LPTSTR pszFileName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    HANDLE hFileHandle;
    BOOL bMainFileFound = FALSE;

    hFileHandle = CreateFile(pszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0);
    if (hFileHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            dwReturn = GetLastError();
        }
        else {
            hFileHandle = CreateFile(pszFileName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_NEW,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0);
            if (hFileHandle == INVALID_HANDLE_VALUE) {
                dwReturn = GetLastError();
            }
            else {
                CloseHandle(hFileHandle);
                DeleteFile(pszFileName);
            }
        }
    }
    else {
        CloseHandle(hFileHandle);
        bMainFileFound = TRUE;
    }
    if (dwReturn == ERROR_SUCCESS) {
        g_strRealFileName = new STR(pszFileName);
        g_strTempFileName = new STR(pszFileName);
        g_strBackupFileName = new STR(pszFileName);
        if( !g_strRealFileName || !g_strTempFileName || !g_strBackupFileName )
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if (g_strTempFileName->IsValid()) {
                g_strTempFileName->Append(MD_TEMP_DATA_FILE_EXT);
            }
            if (g_strBackupFileName->IsValid()) {
                g_strBackupFileName->Append(MD_BACKUP_DATA_FILE_EXT);
            }
            if (!g_strTempFileName->IsValid() || !g_strBackupFileName->IsValid()) 
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {

                hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         0);
                if (hFileHandle == INVALID_HANDLE_VALUE) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        dwReturn = GetLastError();
                    }
                    else {
                        hFileHandle = CreateFile(g_strTempFileName->QueryStr(),
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 0);
                        if (hFileHandle == INVALID_HANDLE_VALUE) {
                            dwReturn = GetLastError();
                        }
                        else {
                            CloseHandle(hFileHandle);
                            DeleteFile(g_strTempFileName->QueryStr());
                        }
                    }
                }
                else {
                    CloseHandle(hFileHandle);
                }

                if (dwReturn == ERROR_SUCCESS) {
                    hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                    if (hFileHandle == INVALID_HANDLE_VALUE) {
                        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                            dwReturn = GetLastError();
                        }
                        else {
                            hFileHandle = CreateFile(g_strBackupFileName->QueryStr(),
                                                     GENERIC_READ | GENERIC_WRITE,
                                                     0,
                                                     NULL,
                                                     CREATE_NEW,
                                                     FILE_ATTRIBUTE_NORMAL,
                                                     0);
                            if (hFileHandle == INVALID_HANDLE_VALUE) {
                                dwReturn = GetLastError();
                            }
                            else {
                                CloseHandle(hFileHandle);
                                DeleteFile(g_strBackupFileName->QueryStr());
                            }
                        }
                    }
                    else {
                        CloseHandle(hFileHandle);
                        if (!bMainFileFound) {
                            if (!MoveFile(g_strBackupFileName->QueryStr(), pszFileName)) {
                                dwReturn = GetLastError();
                            }
                        }
                    }
                }
            }
        }
        if (dwReturn != ERROR_SUCCESS) 
        {
            if( g_strRealFileName )
            {
                delete(g_strRealFileName);
                g_strRealFileName = NULL;
            }
            
            if( g_strTempFileName )
            {   
                delete(g_strTempFileName);
                g_strRealFileName = NULL;
            }

            if( g_strBackupFileName )
            {
                delete(g_strBackupFileName);
                g_strRealFileName = NULL;
            }
        }
    }
    return RETURNCODETOHRESULT(dwReturn);
}

HRESULT
SetDataFile()
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    TCHAR pszBuffer[MAX_PATH];
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);
    BOOL bAppendSlash = FALSE;
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             ADMIN_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) {
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                      MD_FILE_VALUE,
                                      NULL,
                                      &dwType,
                                      (BYTE *) pszBuffer,
                                      &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
            hresReturn = SetGlobalDataFileValues(pszBuffer);
        }

        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        hkRegistryKey = NULL;

    }
    if (FAILED(hresReturn)) {
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 SETUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          INSTALL_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                dwSize /= sizeof(TCHAR);
                if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                    (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                    bAppendSlash = TRUE;
                }
                if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                    if (bAppendSlash) {
                        pszBuffer[dwSize-1] = (TCHAR)'\\';
                        pszBuffer[dwSize] = (TCHAR)'\0';
                    }
                    MD_STRCAT(pszBuffer, MD_DEFAULT_DATA_FILE_NAME);
                    hresReturn = SetGlobalDataFileValues(pszBuffer);
                }
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }
        else {
            hresReturn = RETURNCODETOHRESULT(dwRegReturn);
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // Now get the backup path.
        //
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                 METADATA_BACKUP_REG_KEY,
                                 &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          MD_BACKUP_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) pszBuffer,
                                          &dwSize);
            if (dwRegReturn == ERROR_SUCCESS) {
                hresReturn = SetBackupPath(pszBuffer);
            }
            MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
        }

        if (FAILED(hresReturn)) {
            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                     SETUP_REG_KEY,
                                     &hkRegistryKey);
            if (dwRegReturn == ERROR_SUCCESS) {
                dwSize = MAX_PATH * sizeof(TCHAR);
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                              INSTALL_PATH_VALUE,
                                              NULL,
                                              &dwType,
                                              (BYTE *) pszBuffer,
                                              &dwSize);
                if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) {
                    dwSize /= sizeof(TCHAR);
                    if ((pszBuffer[dwSize-2] != (TCHAR)'/') &&
                        (pszBuffer[dwSize-2] != (TCHAR)'\\')) {
                        bAppendSlash = TRUE;
                    }
                    if ((dwSize + MD_STRBYTES(MD_DEFAULT_DATA_FILE_NAME) + ((bAppendSlash) ? 1 : 0)) <= MAX_PATH) {
                        if (bAppendSlash) {
                            pszBuffer[dwSize-1] = (TCHAR)'\\';
                            pszBuffer[dwSize] = (TCHAR)'\0';
                        }
                        MD_STRCAT(pszBuffer, MD_DEFAULT_BACKUP_PATH_NAME);
                        hresReturn = SetBackupPath(pszBuffer);
                    }
                }
                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
            }
            else {
                hresReturn = RETURNCODETOHRESULT(dwRegReturn);
            }
        }
    }

    return hresReturn;
}

DWORD GetObjectPath(CMDBaseObject *pboObject,
                    BUFFER *pbufPath,
                    DWORD &rdwStringLen,
                    CMDBaseObject *pboTopObject,
                    IN BOOL bUnicode)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwOldStringLen;

    MD_ASSERT(pboObject != NULL);
    if (pboObject != pboTopObject) {
        dwReturn = GetObjectPath(pboObject->GetParent(),
                                 pbufPath,
                                 rdwStringLen,
                                 pboTopObject,
                                 bUnicode);
        dwOldStringLen = rdwStringLen;
        if (pboObject->GetName(bUnicode) == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            if (bUnicode) {
                rdwStringLen += (1 + wcslen((LPWSTR)pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(WCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPWSTR lpzStringEnd = (LPWSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERW;
                    wcscpy(lpzStringEnd+1, (LPWSTR)(pboObject->GetName(bUnicode)));
                }
            }
            else {
                rdwStringLen += (1 + MD_STRBYTES(pboObject->GetName(bUnicode)));
                if (!pbufPath->Resize((rdwStringLen + 1) * sizeof(TCHAR))) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    LPTSTR lpzStringEnd = (LPTSTR)(pbufPath->QueryPtr()) + dwOldStringLen;
                    *lpzStringEnd = MD_PATH_DELIMETERA;
                    MD_STRCPY(lpzStringEnd+1, pboObject->GetName(bUnicode));
                }
            }
        }
    }
    return dwReturn;
}


HRESULT
MakeInsertPathData(STRAU *pstrauNewData,
                   LPTSTR pszPath,
                   LPTSTR pszOldData,
                   DWORD *pdwDataLen,
                   BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (bUnicode) {
        LPWSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = (LPWSTR)pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = wcsstr(pszDataIndex, MD_INSERT_PATH_STRINGW)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGW) / sizeof(WCHAR)) - 1))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append((LPWSTR)pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(WCHAR);
    }
    else {
        LPTSTR pszDataIndex, pszNextDataIndex;

        pstrauNewData->SetLen(0);
        for (pszDataIndex = pszOldData;
             SUCCEEDED(hresReturn) && ((pszNextDataIndex = MD_STRSTR(pszDataIndex, MD_INSERT_PATH_STRINGA)) != NULL);
             pszDataIndex = pszNextDataIndex + ((sizeof(MD_INSERT_PATH_STRINGA) - 1)))  {
    //         *pszNextDataIndex = (TCHAR)'\0';
             if (!(pstrauNewData->Append(pszDataIndex, DIFF(pszNextDataIndex - pszDataIndex)))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
             if (!(pstrauNewData->Append(pszPath))) {
                 hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
             }
        }
        if (!(pstrauNewData->Append(pszDataIndex))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        *pdwDataLen = pstrauNewData->QueryCB(bUnicode) + sizeof(CHAR);
    }
    return hresReturn;
}

HRESULT
InsertPathIntoData(BUFFER *pbufNewData,
                   STRAU *pstrData,
                   PBYTE *ppbNewData,
                   DWORD *pdwNewDataLen,
                   CMDBaseData *pbdRetrieve,
                   METADATA_HANDLE hHandle,
                   CMDBaseObject *pboDataMetaObject,
                   IN BOOL bUnicode)
{
    //
    // Need to insert path
    //
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle * phMDHandle;
    DWORD dwPathLen = 0;
    BUFFER bufPath;
    
    phMDHandle = GetHandleObject(hHandle);
    if( !phMDHandle )
    {
        return MD_WARNING_PATH_NOT_INSERTED;
    }

    CMDBaseObject *pboHandleMetaObject = phMDHandle->GetObject();

    MD_ASSERT((pbdRetrieve->GetDataType() != DWORD_METADATA) &&
        (pbdRetrieve->GetDataType() != BINARY_METADATA));

    if (pboHandleMetaObject->GetObjectLevel() > pboDataMetaObject->GetObjectLevel()) {
        hresReturn = MD_WARNING_PATH_NOT_INSERTED;
    }
    else {
        DWORD dwReturn;
        if ( (dwReturn = GetObjectPath(pboDataMetaObject,
                                       &bufPath,
                                       dwPathLen,
                                       pboHandleMetaObject,
                                       bUnicode)) != ERROR_SUCCESS) {
            hresReturn = RETURNCODETOHRESULT(dwReturn);
        }
        else if (!bufPath.Resize((dwPathLen + 2) * ((bUnicode) ? sizeof(WCHAR) : sizeof(CHAR)))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            LPTSTR pszPath;
            LPTSTR  pszOriginalData;
            DWORD dwDataLen;
            pszPath = (LPTSTR)(bufPath.QueryPtr());
            if (bUnicode) {
                ((LPWSTR)pszPath)[dwPathLen] = MD_PATH_DELIMETERW;
                ((LPWSTR)pszPath)[dwPathLen + 1] = (WCHAR)'\0';
            }
            else {
                pszPath[dwPathLen] = MD_PATH_DELIMETERA;
                pszPath[dwPathLen + 1] = (TCHAR)'\0';
            }
            //
            // If there was an error in GetData, it would have been
            // caught already.
            //
            MD_ASSERT(pbdRetrieve->GetData(bUnicode) != NULL);
            switch (pbdRetrieve->GetDataType()) {
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                {
                    hresReturn = MakeInsertPathData(pstrData,
                                             (LPTSTR)bufPath.QueryPtr(),
                                             (LPTSTR)pbdRetrieve->GetData(bUnicode),
                                             &dwDataLen,
                                             bUnicode);
                    if (SUCCEEDED(hresReturn)) {
                        //
                        // QueryStr should not fail in this instance
                        // since it was created with the same unicode flag
                        //
                        MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                        *ppbNewData = (PBYTE) pstrData->QueryStr(bUnicode);
                        *pdwNewDataLen = dwDataLen;
                    }
                }
                break;
            case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPWSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (WCHAR)'\0');
                             pszDataIndex += (wcslen(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                            (LPSTR)bufPath.QueryPtr(),
                                                            (LPSTR)pszDataIndex,
                                                            &dwStringBytes,
                                                            bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStr(bUnicode) != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen,
                                            pstrData->QueryStr(bUnicode),
                                            dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(WCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(((LPWSTR)(*ppbNewData)) + ((dwDataLen / sizeof(WCHAR)) - 1)) = (WCHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                    else {
                        LPSTR pszDataIndex;
                        DWORD dwStringBytes;
                        dwDataLen = 0;
                        //
                        // Loop through all strings
                        //
                        for (pszDataIndex = (LPTSTR)pbdRetrieve->GetData(bUnicode);
                             SUCCEEDED(hresReturn) && (*pszDataIndex != (CHAR)'\0');
                             pszDataIndex += (MD_STRBYTES(pszDataIndex) + 1)) {
                            hresReturn = MakeInsertPathData(pstrData,
                                                     (LPTSTR)bufPath.QueryPtr(),
                                                     pszDataIndex,
                                                     &dwStringBytes);
                            if (SUCCEEDED(hresReturn)) {
                                if (!pbufNewData->Resize(dwDataLen + dwStringBytes)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    //
                                    // QueryStr should not fail in this instance
                                    // since it was created with the same unicode flag
                                    //
                                    MD_ASSERT(pstrData->QueryStrA() != NULL);
                                    MD_COPY((PBYTE)(pbufNewData->QueryPtr()) + dwDataLen, pstrData->QueryStrA(), dwStringBytes);
                                    dwDataLen += dwStringBytes;
                                }
                            }
                        }
                        if (SUCCEEDED(hresReturn)) {
                            dwDataLen += sizeof(TCHAR);
                            if (!pbufNewData->Resize(dwDataLen)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            }
                            else {
                                *ppbNewData = (PBYTE)(pbufNewData->QueryPtr());
                                *(*ppbNewData + (dwDataLen-1)) = (CHAR)'\0';
                                *pdwNewDataLen = dwDataLen;
                            }
                        }
                    }
                }
                break;
            default:
                MD_ASSERT(FALSE);
            }
        }
    }
    return hresReturn;
}

HRESULT
MakeTreeCopyWithPath(CMDBaseObject *pboSource,
                     CMDBaseObject *&rpboNew,
                     LPSTR pszPath,
                     IN BOOL bUnicode)
{
    WCHAR pszName[METADATA_MAX_NAME_LEN];
    LPSTR pszTempPath = pszPath;
    CMDBaseObject *pboNew = NULL;
    CMDBaseObject *pboParent = NULL;
    CMDBaseObject *pboTree = NULL;
    CMDBaseObject *pboRoot = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresExtractReturn;

    while ((SUCCEEDED(hresReturn)) &&
        (SUCCEEDED(hresExtractReturn = ExtractNameFromPath(pszTempPath, (LPSTR)pszName, bUnicode)))) {

        if (bUnicode) {
            pboNew = new CMDBaseObject((LPWSTR)pszName);
        }
        else {
            pboNew = new CMDBaseObject((LPSTR)pszName);
        }
        if (pboNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!pboNew->IsValid()) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            delete (pboNew);
        }
        else {
            if (pboParent != NULL) {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete pboNew;
                    pboNew = pboParent;
                }
            }
            pboParent = pboNew;
        }
    }

    if ((SUCCEEDED(hresReturn)) && (hresExtractReturn != (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)))) {
        hresReturn = hresExtractReturn;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Don't really want the leaf object, as MakeTreeCopy will create it.
        //

        LPWSTR pszTreeName = NULL;

        if (pboNew != NULL) {
            pszTreeName = (LPWSTR)pboNew->GetName(TRUE);
            pboParent = pboNew->GetParent();
            if (pszTreeName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            hresReturn = MakeTreeCopy(pboSource, pboTree, (LPSTR)pszTreeName, TRUE);

            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(pboTree != NULL);

                if (pboParent != NULL) {
                    MD_REQUIRE(SUCCEEDED(pboParent->RemoveChildObject(pboNew)));
                    hresReturn = pboParent->InsertChildObject(pboTree);
                    if (FAILED(hresReturn)) {
                        delete(pboTree);
                        pboTree = NULL;
                    }
                }
            }
        }
        delete(pboNew);
        pboNew = NULL;
    }

    if (FAILED(hresReturn)) {
        if (pboParent != NULL) {
            CMDBaseObject *pboTemp;
            MD_ASSERT(pboNew != NULL);
            for (pboTemp = pboParent; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
            }
            //
            // destructor recurses through child objects
            //
            delete pboTemp;
        }
    }
    else {
        MD_ASSERT(pboTree != NULL);
        CMDBaseObject *pboTemp;
        for (pboTemp = pboTree; pboTemp->GetParent() != NULL; pboTemp = pboTemp->GetParent()) {
        }
        rpboNew = pboTemp;
    }

    return hresReturn;
}

HRESULT
MakeTreeCopy(CMDBaseObject *pboSource,
             CMDBaseObject *&rpboNew,
             LPSTR pszName,
             IN BOOL bUnicode)
{
    CMDBaseObject *pboTemp = NULL;
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pszName == NULL) {
        if ((pboSource->GetName(TRUE)) != NULL) {
            pboTemp = new CMDBaseObject((LPWSTR)(pboSource->GetName(TRUE)), NULL);
        }
    }
    else {
        if (bUnicode) {
            pboTemp = new CMDBaseObject((LPWSTR)pszName, NULL);
        }
        else {
            pboTemp = new CMDBaseObject((LPSTR)pszName, NULL);
        }
    }
    if (pboTemp == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else if (!pboTemp->IsValid()) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        delete (pboTemp);
    }
    else {
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
        for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
            pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
            MD_ASSERT(pbdCurrent != NULL);
            hresReturn = pboTemp->SetDataObject(pbdCurrent);
        }
        FreeMainDataBuffer(ppvMainDataBuf);
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            hresReturn = MakeTreeCopy(pboOldChild, pboNewChild, NULL, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT (pboNewChild != NULL);
                hresReturn = pboTemp->InsertChildObject(pboNewChild);
            }
            i++;
            pboOldChild = pboSource->EnumChildObject(i);
        }
    }
    if (SUCCEEDED(hresReturn)) {
        rpboNew = pboTemp;
    }
    else {
        rpboNew = NULL;
        delete(pboTemp);
    }
    return (hresReturn);
}

void
AddNewChangeData(CMDHandle *phoDestHandle,
                 CMDBaseObject *pboNew)
{
    DWORD i, dwNumDataObjects;
    CMDBaseObject *pboChild;
    CMDBaseData *pbdCurrent;

    MD_ASSERT(pboNew != NULL);

    phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
    if ((pbdCurrent = pboNew->EnumDataObject(0, 0, ALL_METADATA, ALL_METADATA)) != NULL) {
        phoDestHandle->SetChangeData(pboNew, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
    }
    i = 0;
    pboChild = pboNew->EnumChildObject(i);
    while (pboChild != NULL) {
        AddNewChangeData(phoDestHandle, pboChild);
        i++;
        pboChild = pboNew->EnumChildObject(i);
    }
}

HRESULT
CopyTree(CMDHandle *phoDestParentHandle,
         CMDBaseObject *pboDest,
         CMDBaseObject *pboSource,
         BOOL &rbChanged)

{
    CMDBaseObject *pboOldChild, *pboNewChild;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseData *pbdCurrent;
    LPSTR pszTempName;
    HRESULT hresReturn = ERROR_SUCCESS;

    MD_ASSERT(pboDest != NULL);
    MD_ASSERT(pboSource != NULL);
    ppvMainDataBuf = GetMainDataBuffer();
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf, 0, ALL_METADATA, ALL_METADATA, FALSE);
    for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
        MD_ASSERT(pbdCurrent != NULL);
        hresReturn = pboDest->SetDataObject(pbdCurrent);
        if (SUCCEEDED(hresReturn)) {
            rbChanged = TRUE;
            phoDestParentHandle->SetChangeData(pboDest, MD_CHANGE_TYPE_SET_DATA, pbdCurrent->GetIdentifier());
        }
    }
    if (SUCCEEDED(hresReturn)) {
        i = 0;
        pboOldChild = pboSource->EnumChildObject(i);
        while ((SUCCEEDED(hresReturn)) && (pboOldChild != NULL)) {
            pszTempName = (pboOldChild->GetName(TRUE));
            if (pszTempName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                pboNewChild = pboDest->GetChildObject(pszTempName, &hresReturn, TRUE);
                if (SUCCEEDED(hresReturn)) {
                    if (pboNewChild != NULL) {
                        hresReturn = CopyTree(phoDestParentHandle, pboNewChild, pboOldChild, rbChanged);
                    }
                    else {
                        hresReturn = MakeTreeCopy(pboOldChild, pboNewChild);
                        if (SUCCEEDED(hresReturn)) {
                            MD_ASSERT (pboNewChild != NULL);
                            hresReturn = pboDest->InsertChildObject(pboNewChild);
                            if (SUCCEEDED(hresReturn)) {
                                rbChanged = TRUE;
                                AddNewChangeData(phoDestParentHandle, pboNewChild);
                            }
                            else {
                                delete(pboNewChild);
                            }
                        }
                    }
                    i++;
                    pboOldChild = pboSource->EnumChildObject(i);
                }
            }
        }
    }
    FreeMainDataBuffer(ppvMainDataBuf);
    return (hresReturn);
}

void CheckForNewMetabaseVersion()
{
    BOOL    bValueWasWrongType = FALSE;
    BOOL    bSomethingChanged = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwValue,dwType,dwSize = sizeof(DWORD);

    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                             SETUP_REG_KEY,
                             &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        // Check for update to major version

        // get the Type of data only first
        // since a string won't fit in &dwValue
        dwValue = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        MD_SETMAJORVERSION_VALUE,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize);
        if ( dwRegReturn == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                MD_SETMAJORVERSION_VALUE,
                                NULL,
                                &dwType,
                                (BYTE *)&dwValue,
                                &dwSize);
                if ( dwRegReturn == ERROR_SUCCESS)
                {
                    // default the value with the version that this binary was compiled with
                    if (dwType == REG_DWORD)
                    {
                        if (g_dwMajorVersionNumber != dwValue && dwValue >= 1)
                        {
                            g_dwMajorVersionNumber = dwValue;
                            bSomethingChanged = TRUE;
                        }
                    }
                    else
                    {
                        bValueWasWrongType = TRUE;
                    }
                }
            }
            else
            {
                bValueWasWrongType = TRUE;
            }
        }

        if (FALSE == bValueWasWrongType)
        {
            // Check for update to minor version

            // get the Type of data only first
            // since a string won't fit in &dwValue
            dwValue = 0;
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            MD_SETMINORVERSION_VALUE,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
            if ( dwRegReturn == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                {
                    dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                    MD_SETMINORVERSION_VALUE,
                                    NULL,
                                    &dwType,
                                    (BYTE *)&dwValue,
                                    &dwSize);
                    if ( dwRegReturn == ERROR_SUCCESS)
                    {
                        if (dwType == REG_DWORD)
                        {
                            if (g_dwMinorVersionNumber != dwValue)
                            {
                                g_dwMinorVersionNumber = dwValue;
                                bSomethingChanged = TRUE;
                            }
                        }
                        else
                        {
                            bValueWasWrongType = TRUE;
                        }
                    }
                }
                else
                {
                    bValueWasWrongType = TRUE;
                }
            }
        }
        MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
    }

    if (TRUE == bValueWasWrongType)
    {
        // default the value with the version that this binary was compiled with

        if (g_dwMajorVersionNumber != MD_MAJOR_VERSION_NUMBER)
        {
            g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }

        if (g_dwMinorVersionNumber != MD_MINOR_VERSION_NUMBER)
        {
            g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;
            bSomethingChanged = TRUE;
        }
    }


    if (TRUE == bSomethingChanged)
    {
        // make sure that we tell the metabase that there was a change made..
        g_dwSystemChangeNumber++;
        IIS_PRINTF((buff,"MD:New Metabase Version:%d.%d\n",g_dwMajorVersionNumber,g_dwMinorVersionNumber));
    }
    return;
}

BOOL
CheckVersionNumber()
{
    BOOL bReturn = FALSE;

    if (g_dwMajorVersionNumber >= 1) {
        // 1 = IIS4
        //     we need to be able to open IIS4 in IIS5 during setup upgrade
        // 2 = IIS5
        bReturn = TRUE;
    }

    // g_dwMinorVersionNumber -- maybe use this for Major service pack releases or something in which
    //                           Metabase has been changed and we need to know the difference?

    return bReturn;
}

HRESULT
InitStorageAndSessionKey(
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider( &hProv );
    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = pCryptoStorage->Initialize(
                         TRUE,                          // fUseMachineKeyset
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = pCryptoStorage->GetSessionKeyBlob( ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey

HRESULT
InitStorageAndSessionKey2(
    IN LPSTR pszPasswd,
    IN IIS_CRYPTO_STORAGE *pCryptoStorage,
    OUT PIIS_CRYPTO_BLOB *ppSessionKeyBlob
    )
{
    HRESULT hresReturn;
    HCRYPTPROV hProv;

    //
    // Get a handle to the crypto provider, init the storage object,
    // then export the session key blob.
    //

    hresReturn = GetCryptoProvider2( &hProv );
    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->Initialize(
                         hProv
                         );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->Initialize Failed - error 0x%0x\n", hresReturn));
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: GetCryptoProvider2 Failed - error 0x%0x\n", hresReturn));
    }

    if( SUCCEEDED(hresReturn) ) 
    {
        hresReturn = ((IIS_CRYPTO_STORAGE2*)pCryptoStorage)->GetSessionKeyBlob( pszPasswd, ppSessionKeyBlob );
        if (FAILED(hresReturn))
        {
            DBGPRINTF(( DBG_CONTEXT, "InitStorageAndSessionKey: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hresReturn));
        }
    }

    return hresReturn;

}   // InitStorageAndSessionKey2


VOID
SkipPathDelimeter(IN OUT LPSTR &rpszPath,
                    IN BOOL bUnicode)
{
    if (bUnicode) {
        LPWSTR pszPath = (LPWSTR)rpszPath;
        SKIP_PATH_DELIMETERW(pszPath);
        rpszPath = (LPSTR)pszPath;
    }
    else {
        SKIP_PATH_DELIMETERA(rpszPath);
    }
}

BOOL
IsStringTerminator(IN LPTSTR pszString,
                   IN BOOL bUnicode)
{
    if (bUnicode) {
        if (*(LPWSTR)pszString == (WCHAR)'\0') {
            return TRUE;
        }
    }
    else {
        if (*(LPSTR)pszString == (CHAR)'\0') {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
GetLastHResult() {
    DWORD tmp = GetLastError();
    return RETURNCODETOHRESULT(tmp);
}


HRESULT STDMETHODCALLTYPE  BackupCertificates (LPCWSTR  backupName,PCHAR lpszToPath,PCHAR lpszFromPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    CHAR                *p1,*p2;
    LPSTR               searchMask = "*.mp";
    LPSTR               backupNameSeparator = ".";
    CHAR                strSourcePath[MAX_PATH];
    CHAR                strSearchPattern[MAX_PATH];
    CHAR                strDestPath[MAX_PATH];
    DWORD               dwLenOfBackupName, n1;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FileInfo;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSrcFileName, strDestFileName;

    dwLenOfBackupName = wcslen (backupName) * sizeof (WCHAR);
    p1 = strrchr (lpszFromPath,'\\');
    p2 = strrchr (lpszToPath,'\\');
    if (p1 &&p2)
    {
        n1 = min (MAX_PATH-1, DIFF(p1 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;
        strcpy (strSearchPattern,strSourcePath);

        n1 = min (MAX_PATH-1, DIFF(p2 - lpszToPath)+1);
        strncpy (strDestPath,lpszToPath,n1);
        strDestPath[n1] = 0;

        if (strlen (strSourcePath) +  strlen(searchMask) < MAX_PATH)
        {
            strcat (strSearchPattern,searchMask);
            hFindFile = FindFirstFile( strSearchPattern, &FileInfo);

            if (hFindFile == INVALID_HANDLE_VALUE)
            {
                // no certificate file found
                return ERROR_SUCCESS;
            }

            while (fFoundFile)
            {
                if ( strlen (FileInfo.cFileName) + strlen (strDestPath) + dwLenOfBackupName + 1 < MAX_PATH)
                {

                    fValid = strSrcFileName.Copy (strSourcePath);
                    fValid = fValid && strSrcFileName.Append (FileInfo.cFileName);

                    fValid = fValid && strDestFileName.Copy (strDestPath);
                    fValid = fValid && strDestFileName.Append ((LPWSTR)backupName);
                    fValid = fValid && strDestFileName.Append (backupNameSeparator);
                    fValid = fValid && strDestFileName.Append (FileInfo.cFileName);

                    if (fValid)
                    {
                        if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                        {
                            IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                        }
                    }
                    else
                    {
                        IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
                    }

                }

                fFoundFile = FindNextFile(hFindFile,&FileInfo);
            }
            fFoundFile = FindClose (hFindFile);
            MD_ASSERT (fFoundFile);
        }
        else
        {
            IIS_PRINTF((buff,"CertificateBackup: strSourcePath filename was too long\n"));
        }
    }
    else
    {
        IIS_PRINTF((buff,"CertificateBackup: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE  RestoreCertificates (LPCWSTR  backupName,PCHAR lpszFromPath,PCHAR lpszToPath)
{
    HRESULT             hresReturn = ERROR_SUCCESS;
    DWORD               n1;
    CHAR                strDestinationPath[MAX_PATH];
    CHAR                strSourcePath[MAX_PATH];
    CHAR                *p1,*p2;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFoundFile = TRUE, fValid;
    STRAU               strSearchPatttern, strDestFileName, strSrcFileName;
    WIN32_FIND_DATAW    FileInfo;
    LPWSTR              pszSearchPattern = NULL;


    p1 = strrchr (lpszToPath,'\\');
    p2 = strrchr (lpszFromPath,'\\');


    if (p1 &&p2)
    {

        n1 = min (MAX_PATH-1, DIFF(p1 - lpszToPath)+1);
        strncpy (strDestinationPath,lpszToPath,n1);
        strDestinationPath[n1] = 0;

        n1 = min (MAX_PATH-1, DIFF(p2 - lpszFromPath)+1);
        strncpy (strSourcePath,lpszFromPath,n1);
        strSourcePath[n1] = 0;


        strSearchPatttern.Copy (strSourcePath);
        strSearchPatttern.Append ((LPWSTR)backupName);
        strSearchPatttern.Append ((LPWSTR)L".*.mp");

        if( !( pszSearchPattern = strSearchPatttern.QueryStrW() ) )
        {
            return ERROR_SUCCESS;
        }

        hFindFile = FindFirstFileW( pszSearchPattern, &FileInfo);

        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // no certificate file found
            return ERROR_SUCCESS;
        }

        while (fFoundFile)
        {
            fValid = strDestFileName.Copy (strDestinationPath);
            fValid = fValid && strDestFileName.Append ((LPWSTR)(FileInfo.cFileName + wcslen (backupName) +1));

            fValid = fValid && strSrcFileName.Copy (strSourcePath);
            fValid = fValid && strSrcFileName.Append ((LPWSTR)FileInfo.cFileName);

            if (fValid)
            {
                if (!CopyFileW (strSrcFileName.QueryStrW(),strDestFileName.QueryStrW(),FALSE))
                {
                    IIS_PRINTF((buff,"CertificateBackup: CopyFileW error 0x%0X \n",GetLastError()));
                }
            }
            else
            {
                IIS_PRINTF((buff,"CertificateBackup: Failure in STRAU manipulation \n"));
            }

            fFoundFile = FindNextFileW(hFindFile,&FileInfo);
        }
        fFoundFile = FindClose (hFindFile);
        MD_ASSERT (fFoundFile);
    }
    else
    {
        IIS_PRINTF((buff,"CertificateRestore: can't find last back slash in one of these strings %s %s\n",lpszToPath,lpszFromPath));
    }

    return hresReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\iis51\metabase.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metabase.cxx

Abstract:

    IIS MetaBase exported routines.
    Routine comments are in metadata.h.

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/

#include <mdcommon.hxx>

#include <initguid.h>
DEFINE_GUID(IisMetadataGuid, 
0x784d890A, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        if (InterlockedIncrement((long *)&g_dwProcessAttached) > 1) {
            OutputDebugString("Metadata.dll failed to load.\n"
                              "Most likely cause is IISADMIN service is already running.\n"
                              "Do a \"net stop iisadmin\" and stop all instances of inetinfo.exe.\n");
            bReturn = FALSE;
        }
        else {
#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT("Metadata");
            SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT("Metadata", IisMetadataGuid);
#endif
            g_pboMasterRoot = NULL;
            g_phHandleHead = NULL;
            g_ppbdDataHashTable = NULL;
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                g_phEventHandles[i] = NULL;
            }
            g_hReadSaveSemaphore = NULL;
            g_bSaveDisallowed = FALSE;
            g_rMasterResource = new TS_RESOURCE();
            g_rSinkResource = new TS_RESOURCE();
            g_pFactory = new CMDCOMSrvFactory();
            if ((g_pFactory == NULL) || (g_rSinkResource == NULL) || (g_rMasterResource == NULL)){
                bReturn = FALSE;
            }
            if (bReturn) {
                bReturn = InitializeMetabaseSecurity();
            }
        }

        break;

    case DLL_PROCESS_DETACH:
        if (InterlockedDecrement((long *)&g_dwProcessAttached) == 0) {
            if (g_rMasterResource != NULL) {
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                if (g_dwInitialized > 0) {
                    //
                    // Terminate was not called, or did not succeed, so call it
                    //
                    TerminateWorker();
                }
                g_rMasterResource->Unlock();
                delete (g_rMasterResource);
            }
            delete (g_rSinkResource);
            delete (g_pFactory);
            TerminateMetabaseSecurity();
            DELETE_DEBUG_PRINT_OBJECT( );
        }
        break;

    default:
        break;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\listener.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Listner.h

Abstract:

	Class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)			30-Nov-1999

Revision History:

--*/

#ifndef _LISTNER_H_
#define _LISTNER_H_


enum eUNSUBSCRIBE_ACTION
{
	eACTION_UNSUBSCRIBE_ALL =0,
	eACTION_UNSUBSCRIBE_OBSOLETE,
	cUNSUBSCRIBE_ACTION
};

enum eFILE_NOTIFICATION
{
	eFILE_CREATE = 0,
	eFILE_MODIFY,
	eFILE_DELETE,
	cFILE_NOTIFCATION
};


class CFileListener : 
public ISimpleTableFileChange
{

public:

	CFileListener();

	~CFileListener();

private:

	DWORD                               m_cRef;

	DWORD                               m_dwNotificationCookie;

	ULONG                               m_cRequestedFileNotification;

	ISimpleTableDispenser2*             m_pISTDisp;

	ISimpleTableFileAdvise*             m_pISTFileAdvise;

	LPWSTR                              m_wszHistoryFileDir;

	DWORD                               m_cchHistoryFileDir;

	LPWSTR                              m_wszRealFileName;

	DWORD                               m_cchRealFileName;

	LPWSTR                              m_wszRealFileNameWithoutPath;

	DWORD                               m_cchRealFileNameWithoutPath;

	LPWSTR                              m_wszRealFileNameWithoutPathWithoutExtension;

	DWORD                               m_cchRealFileNameWithoutPathWithoutExtension;

	LPWSTR                              m_wszRealFileNameExtension;

	DWORD                               m_cchRealFileNameExtension;

    LPWSTR                              m_wszSchemaFileName;

    DWORD                               m_cchSchemaFileName;

	LPWSTR                              m_wszSchemaFileNameWithoutPath;

	DWORD                               m_cchSchemaFileNameWithoutPath;

	LPWSTR                              m_wszSchemaFileNameWithoutPathWithoutExtension;

	DWORD                               m_cchSchemaFileNameWithoutPathWithoutExtension;

	LPWSTR                              m_wszSchemaFileNameExtension;

	DWORD                               m_cchSchemaFileNameExtension;

	LPWSTR                              m_wszErrorFileSearchString;

	DWORD                               m_cchErrorFileSearchString;

	LPWSTR                              m_wszMetabaseDir;

	DWORD                               m_cchMetabaseDir;

	LPWSTR                              m_wszHistoryFileSearchString;

	DWORD                               m_cchHistoryFileSearchString;

	LPWSTR                              m_wszEditWhileRunningTempDataFile;

	DWORD                               m_cchEditWhileRunningTempDataFile;

	LPWSTR                              m_wszEditWhileRunningTempSchemaFile;

	DWORD                               m_cchEditWhileRunningTempSchemaFile;

	LPWSTR                              m_wszEditWhileRunningTempDataFileWithAppliedEdits;

	DWORD                               m_cchEditWhileRunningTempDataFileWithAppliedEdits;

	BOOL                                m_bIsTempSchemaFile;

	CListenerController*                m_pCListenerController;

	IMSAdminBase*                       m_pAdminBase;

public:

	// Initialize

	HRESULT Init(CListenerController* i_pListenerController);

	// IUnknown

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);

	STDMETHOD_(ULONG,AddRef)		();

	STDMETHOD_(ULONG,Release)		();

	// ISimpleTableFileChange

	STDMETHOD (OnFileCreate)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	STDMETHOD (OnFileModify)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	STDMETHOD (OnFileDelete)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	HRESULT Subscribe();											// Subscribe for file change notifications on 
	                                                                // the metabase file.
																	

	HRESULT UnSubscribe();											// Unsubscribe for file change notifications on
																	// the metabase file.
	HRESULT ProcessChanges();

private:

	HRESULT AddReceivedNotification(LPCWSTR i_wszFile, 
									DWORD i_eNotificationStatus);	// Adds to recd array

	HRESULT GetTable(LPCWSTR	i_wszDatabase,
					 LPCWSTR	i_wszTable,
					 LPVOID	    i_QueryData,	
					 LPVOID	    i_QueryMeta,	
					 ULONG	    i_eQueryFormat,
					 DWORD	    i_fServiceRequests,
					 LPVOID*    o_ppIST);


	HRESULT ProcessChangesFromFile(LPWSTR i_wszHistoryFile,
								   ULONG  i_ulMajorVersion,
								   ULONG  i_ulMaxMinorVersion,
								   BOOL*  o_bGetTableFailed);

	HRESULT OpenParentKeyAndGetChildKey(LPWSTR           i_wszLocation,
	                                    IMSAdminBase*    i_pAdminBase,
				                        METADATA_HANDLE* o_pHandle,
				                        WCHAR**          o_wszChildKey);

	HRESULT OpenKey(LPWSTR           i_wszLocation,
                    IMSAdminBase*    i_pAdminBase,
					BOOL             i_bAddIfMissing,
                    METADATA_HANDLE* o_pHandle,
				    BOOL*            o_bInsertedKey);

	HRESULT GetVersionNumber(LPWSTR    i_wszDataFile,
							 DWORD*    o_pdwVersionNumber,
							 BOOL*     o_bGetTableFailed);						    // Gets the version number.

	HRESULT GetVersionNumberSubset(LPSTR  szVersion,
							       int*   piVersion,
								   LPVOID lpMapAddressBegin,
								   LPVOID lpMapAddressEnd);

	HRESULT ApplyChangeToHistoryFile(CWriterGlobalHelper*       pISTHelper,
                                     ISimpleTableWrite2*        pISTDiff,
                                     LPWSTR                     wszHistoryFile,
                                     ULONG                      i_dwMajorVersion,
                                     ULONG					    i_dwMinorVersion);	// Apply changes to the history file.

	HRESULT CopyErrorFile(BOOL            i_bGetTableFailed);

	HRESULT MergeLocation(CWriter*                pCWriter,
                          ISimpleTableRead2*      pISTHistory,
			              ULONG*                  piReadRowHistory,
			              ULONG                   LocationIDHistory,
			              ISimpleTableWrite2*     pISTDiff,
			              ULONG*                  piWriteRowDiff,
			              ULONG                   LocationIDDiff,
			              LPCWSTR				  wszLocation);		            // Merges the location (found in both diff and history)

	HRESULT MergeLocation(CWriter*                pCWriter,
			              ISimpleTableRead2*      pISTRead,
                          BOOL                    bMBPropertyTable,
						  ULONG*                  piRow,
						  ULONG				      LocationID,
						  LPCWSTR                 wszLocation);					// Merges location from diff or history.

	HRESULT MergeRemainingLocations(CWriter*                pCWriter,
									ISimpleTableRead2*		pISTRead,
                                    BOOL                    bMBPropertyTable,
									ULONG*					piRow);				// Merge remaining locations from diff or history.

	HRESULT MergeProperties(CLocationWriter*        pCLocationWriter,
				            ISimpleTableRead2*      pISTHistory,
				            ULONG*                  piReadRowHistory,
				            ULONG                   LocationIDHistory,
				            ISimpleTableWrite2*     pISTDiff,
				            ULONG*                  piWriteRowDiff,
				            ULONG                   LocationIDDiff);			// Merge properties from a given location from diff and history tables.

	HRESULT MergeRemainingProperties(CLocationWriter*    pCLocationWriter,
				                     ISimpleTableRead2*  pISTRead,
                                     BOOL                bMBPropertyTable,
						         	 ULONG*              piRow,
							         ULONG			     LocationID);			// Merge properties from a given location in diff or history table.

	HRESULT SaveChange(ULONG				i_iRow,
					   ISimpleTableWrite2*	i_pISTDiff);

	HRESULT SaveChangeAsNodeWithNoPropertyAdded(LPVOID*                i_apvDiff,
						                        ISimpleTableWrite2*    i_pISTDiff);

	HRESULT	GetChangeNumber(LPWSTR	wszChangedFile,
					        DWORD*  pdwChangeNumber);

	LPVOID 	FindStr(LPSTR  wszStr,
			 	    LPVOID lpBegin,
					LPVOID lpEnd);

	int Cmp(char* s1, LPVOID pvEnd, char* s2);

	BOOL ProgrammaticMetabaseSaveNotification();

	HRESULT GetMetabaseAttributes(WIN32_FIND_DATAW* pCurrentMetabaseAttr,
                                  DWORD*            pdwCurrentMetabaseVersion);

	BOOL CompareMetabaseAttributes(FILETIME* pPreviousMetabaseFileLastWriteTimeStamp,
							       DWORD	 dwPreviousMetabaseVersion,
								   FILETIME* pCurrentMetabaseFileLastWriteTimeStamp,
								   DWORD	 dwCurrentMetabaseVersion);

	HRESULT GetGlobalHelperAndCopySchemaFile(CWriterGlobalHelper** o_pISTHelper);

	void DeleteTempFiles();


}; // CFileListner

#endif _LISTNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\importer.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ImpExpUtils.h

Abstract:

    IIS MetaBase subroutines to support Import

Author:

    Mohit Srivastava            04-April-01

Revision History:

Notes:

--*/

#ifndef _impexputils_h_
#define _impexputils_h_

#include <windows.h>
#include <catalog.h>
#include <atlbase.h>

class CImporter
{
public:
    CImporter(
        LPCWSTR i_wszFileName,
        LPCSTR  i_pszPassword);

    ~CImporter();

    HRESULT Init();

    HRESULT DoIt(
        LPWSTR          i_wszSourcePath,
        LPCWSTR         i_wszKeyType,
        DWORD           i_dwMDFlags,
        CMDBaseObject** o_ppboNew);

private:
    //
    // This is the relation of the current
    // location being read from the XML file to the source path.
    //
    enum Relation
    {
        eREL_SELF, eREL_CHILD, eREL_PARENT, eREL_NONE
    };

    HRESULT InitIST();

    Relation GetRelation(
        LPCWSTR i_wszSourcePath,
        LPCWSTR i_wszCheck);

    BOOL IsChild(
        LPCWSTR i_wszParent, 
        LPCWSTR i_wszCheck,
        BOOL    *o_pbSamePerson);

    HRESULT ReadMetaObject(
        IN LPCWSTR i_wszAbsParentPath,
        IN CMDBaseObject *i_pboParent,
        IN LPCWSTR i_wszAbsChildPath,
        OUT CMDBaseObject **o_ppboChild);

    BOOL EnumMDPath(
        LPCWSTR i_wszFullPath,
        LPWSTR  io_wszPath,
        int*    io_iStartIndex);

    CComPtr<ISimpleTableDispenser2> m_spISTDisp;
    CComPtr<ISimpleTableWrite2>     m_spISTProperty;

    CComPtr<ISimpleTableRead2>      m_spISTError;
    CComPtr<ICatalogErrorLogger2>   m_spILogger;
    ULONG                           m_iRowDuplicateLocation;

    LPCWSTR                         m_wszFileName;
    LPCSTR                          m_pszPassword;

    bool                            m_bInitCalled;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\locationwriter.h ===
#ifndef _LOCATIONWRITER_H
#define _LOCATIONWRITER_H


class CLocationWriter
{
	public:

		CLocationWriter();
		~CLocationWriter();

		//
		// Both SaveAllData and ApplyChangesToHistoryFile use this.
		//

		HRESULT	WriteLocation(BOOL bSort);

		HRESULT Initialize(CWriter* pCWriter,
						   LPCWSTR   wszLocation);

		//
		// SaveAllData uses these interfaces
		//

		HRESULT	InitializeKeyType(DWORD	dwKeyTypeIdentifier,
								  DWORD	dwKeyTypeAttributes,
								  DWORD	dwKeyTypeUserType,
								  DWORD	dwKeyTypeDataType,
								  PBYTE	pbKeyTypeData,
								  DWORD	cbKeyTypeData);

        HRESULT InitializeKeyTypeAsInherited();

		HRESULT AddProperty(DWORD	dwIdentifier,
							DWORD	dwAttributes,
							DWORD	dwUserType,
							DWORD	dwDataType,
							PBYTE	pbData,
							DWORD   cbData);	// Computes Name and Group (For which keytype needs to be initialized)

		//
		// ApplyChangesToHistoryFile uses these interfaces
		//

		HRESULT AddProperty(BOOL     bMBPropertyTable,
                            LPVOID*	 a_pvProperty,
							ULONG*   a_cbSize);	

	private:

		HRESULT AssignKeyType(LPWSTR wszKeyType);

		HRESULT SaveComment(DWORD  i_dwDataType,
			                LPWSTR i_wszComment);

		HRESULT WriteComment();

		HRESULT GetGroupEnum(LPWSTR             wszGroup,
							 eMBProperty_Group* peGroup,
						     LPWSTR*            pwszGroup);

		HRESULT Sort(ULONG** paiRowSorted,
                     ULONG*  pcRowSorted);

		HRESULT WriteBeginLocation(LPCWSTR  wszLocation);

		HRESULT WriteEndLocation();

		HRESULT WriteCustomProperty(LPVOID*  a_pv,
									ULONG*   a_cbSize);

		HRESULT WriteEndWellKnownGroup();

		HRESULT WriteWellKnownProperty(LPVOID*   a_pv,
						               ULONG*    a_cbSize);

		void IncrementGroupCount(DWORD i_dwGroup);

	public:

		LPWSTR                      m_wszLocation;

	private:
	
		LPWSTR						m_wszKeyType;
		eMBProperty_Group			m_eKeyTypeGroup;
		CWriter*					m_pCWriter;
		CWriterGlobalHelper*		m_pCWriterGlobalHelper;
		LPWSTR                      m_wszComment;
		ULONG                       m_cCustomProperty;
		ULONG                       m_cWellKnownProperty;

}; // class CLocationWriter

#endif // _LOCATIONWRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\listenercontroller.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ListnerController.h

Abstract:

	Class that starts and stops the Listener

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:

--*/


#ifndef _LISTENERCONTROLLER_H_
#define _LISTENERCONTROLLER_H_

#include	"iisdef.h"
#include	"Lock.hxx"
#include	"CLock.hxx"
#include    "Eventlog.hxx"

enum eEVENTS{
	iEVENT_MANAGELISTENING = 0,		// Stop should be before processnotifications, because if both happen at the same time, you want stop to win.
	iEVENT_PROCESSNOTIFICATIONS,	
	cmaxLISTENERCONTROLLER_EVENTS
};

enum eSTATE{
	iSTATE_STOP_TEMPORARY = 0,
	iSTATE_STOP_PERMANENT,
	iSTATE_START,
	cmaxSTATE
};

// Fwd declaration
class CFileListener;

class CListenerController:
public IUnknown 
{

public:

	CListenerController();

	~CListenerController();

private:

	eSTATE							m_eState;

	HANDLE							m_aHandle[cmaxLISTENERCONTROLLER_EVENTS];

	LOCK							m_LockStartStop;

	DWORD							m_cRef;

	ICatalogErrorLogger2*            m_pEventLog;

	HANDLE	                        m_hListenerThread;

	BOOL                            m_bDoneWaitingForListenerToTerminate;

public:

	// IUnknown

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);

	STDMETHOD_(ULONG,AddRef)		();

	STDMETHOD_(ULONG,Release)		();

	HRESULT CreateListener(CFileListener** o_pListener);

	void Listen();

	HRESULT Start();				// Start the listener.

	HRESULT Stop(eSTATE   i_eState,
			     HANDLE*  o_hListenerThread);	// Stop the listener.

	HRESULT Init();					// Initializes the events and CriticalSection

	HANDLE* Event();				// Accessor function that returns a ptr to the event handle array

	ICatalogErrorLogger2* EventLog();

};

HRESULT InitializeListenerController();
HRESULT UnInitializeListenerController();

#endif _LISTENERCONTROLLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\mbcollectionwriter.h ===
#ifndef _MBCOLLECTIONWRITER_H_
#define _MBCOLLECTIONWRITER_H_


class CMBCollectionWriter
{
	public:
		
		CMBCollectionWriter();
		~CMBCollectionWriter();

		void Initialize(LPCWSTR	    i_wszCollection,
			            BOOL		i_bContainer,
                        LPCWSTR	    i_wszContainerClassList,
				        CWriter*	i_pcWriter);

		HRESULT GetMBPropertyWriter(DWORD				   i_dwID,
								    CMBPropertyWriter**    o_pMBPropertyWriter);

		HRESULT GetMBPropertyWriter(LPCWSTR				 i_wszName,
                                    BOOL                 i_bMandatory,
							        CMBPropertyWriter**  o_pProperty);


		HRESULT CreateIndex();
		HRESULT WriteCollection();

		LPCWSTR Name(){ return m_wszMBClass;}

	private:

		HRESULT ReAllocate();
		HRESULT ReAllocateIndex(DWORD i_dwLargestID);
		HRESULT GetNewMBPropertyWriter(DWORD 				i_dwID,
									   CMBPropertyWriter**  o_pProperty);
		HRESULT BeginWriteCollection();
		HRESULT EndWriteCollection();


		CWriter*					m_pCWriter;
		LPCWSTR                     m_wszMBClass;
		LPCWSTR                     m_wszContainerClassList;
		BOOL						m_bContainer;
		CMBPropertyWriter**			m_apProperty;
		ULONG						m_cProperty;
		ULONG						m_iProperty;
		CMBPropertyWriter**         m_aIndexToProperty;
		DWORD						m_dwLargestID;

}; // CMBCollectionWriter


#endif // _MBCOLLECTIONWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\mbschemawriter.h ===
#ifndef _MBSCHEMAWRITER_H_
#define _MBSCHEMAWRITER_H_

class CMBSchemaWriter
{
	public:
		
		CMBSchemaWriter(CWriter* pcWriter);
		~CMBSchemaWriter();

		HRESULT GetCollectionWriter(LPCWSTR					i_wszCollection,
									BOOL					i_bContainer,
									LPCWSTR					i_wszContainerClassList,
									CMBCollectionWriter**	o_pMBCollectionWriter);

		HRESULT WriteSchema();

	private:

		HRESULT ReAllocate();

		CMBCollectionWriter**	m_apCollection;
		ULONG					m_cCollection;
		ULONG					m_iCollection;
		CWriter*				m_pCWriter;

}; // CMBSchemaWriter

#endif _MBSCHEMAWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\mbpropertywriter.h ===
#ifndef _MBPROPERTYWRITER_H_
#define _MBPROPERTYWRITER_H_

struct PropValue {
    DWORD dwMetaID;
    DWORD dwPropID;
    DWORD dwSynID;
    DWORD dwMaxRange;
    DWORD dwMinRange;
    DWORD dwMetaType;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwMetaFlags;
    DWORD dwUserGroup;
    BOOL fMultiValued;
    DWORD dwDefault;
    LPWSTR szDefault;
};

class CMBCollectionWriter;

class CMBPropertyWriter
{
	public:
		
		CMBPropertyWriter();
		~CMBPropertyWriter();

		void Initialize(DWORD							i_dwID,
					    BOOL							i_bMandatory,
					    CMBCollectionWriter*			i_pCollection,
                        CWriter*						i_pcWriter);

		HRESULT AddNameToProperty(LPCWSTR				i_wszName);
		HRESULT AddTypeToProperty(PropValue*			i_wszType);
		HRESULT AddDefaultToProperty(BYTE*				i_bDefault,
		                             ULONG				i_cbDefault);
		HRESULT AddFlagToProperty(CMBPropertyWriter*	i_pFlag);
		HRESULT WriteProperty();

		HRESULT WriteFlag(ULONG i_iFlag);
		LPCWSTR Name() {return m_wszName;}
		DWORD   ID() {return m_dwID;}
		DWORD   FlagValue() {return m_pType->dwMask;}

	private:

		HRESULT ReAllocate();
		void    CreateUnknownName(LPWSTR    io_wszUnknownName,
                                  DWORD     i_dwID);
		HRESULT GetMetaFlagsExTag(LPWSTR* o_pwszMetaFlagsEx);
		HRESULT WritePropertyLong();
		HRESULT WritePropertyShort();
		HRESULT BeginWritePropertyLong();
		HRESULT EndWritePropertyLong();
		BOOL    IsPropertyFlag(BOOL	i_bLog);

		CWriter*					m_pCWriter;
		LPCWSTR						m_wszName;
		PropValue*					m_pType;
		BYTE*						m_bDefault;
		ULONG                       m_cbDefault;
		DWORD                       m_dwID;
		CMBPropertyWriter**			m_apFlag;
		DWORD                       m_iFlag;
		DWORD                       m_cFlag;
		BOOL						m_IsProperty;
		BOOL						m_bMandatory;
		CMBCollectionWriter*		m_pCollection;
		
}; // CMBPropertyWriter

#endif // _MBPROPERTYWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\cbin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    cbin.cxx

    This module contains a light weight binary class


    FILE HISTORY:
        MichTh      17-May-1996 Created, based on string.cxx
*/


//
// Normal includes only for this module to be active
//
# include <cbin.hxx>
# include "dbgutil.h"

# include <tchar.h>

//
//  Private Definations
//

/*******************************************************************

    NAME:       CBIN::CBIN

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/


CBIN::CBIN( DWORD cbLen, const PVOID pbInit )
{
    AuxInit(cbLen, pbInit);
}

CBIN::CBIN( const CBIN & cbin )
{
    AuxInit(cbin.QueryCB(), cbin.QueryPtr());
}

VOID CBIN::AuxInit( DWORD cbLen, PVOID pbInit)
{
    BOOL fRet;

    _fValid   = TRUE;

    if ( pbInit )
    {
        fRet = Resize( cbLen );


        if ( !fRet )
        {
            _fValid = FALSE;
            return;
        }

        SetCB(cbLen);
        ::memcpy( QueryPtr(), pbInit, cbLen );
    }
    else {
        SetCB(0);
    }
}

/*******************************************************************

    NAME:       CBIN::Append

    SYNOPSIS:   Appends the buffer onto this one.

    ENTRY:      Object to append

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Append( DWORD cbLen, const PVOID pbBuf )
{
    if ( pbBuf )
    {

        return AuxAppend(pbBuf, cbLen);
    }

    return TRUE;
}

BOOL CBIN::Append( const CBIN   & cbin )
{
        return Append(cbin.QueryCB(), cbin.QueryPtr());
}

BOOL CBIN::AuxAppend( PVOID pbBuf, UINT cbLen, BOOL fAddSlop )
{
    DBG_ASSERT( pbBuf != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbLen)
    {
        if ( !Resize( cbThis + cbLen) )
            return FALSE;
    }

    SetCB(cbThis + cbLen);
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pbBuf,
            cbLen);

    return TRUE;
}

/*******************************************************************

    NAME:       CBIN::Copy

    SYNOPSIS:   Copies the string into this one.

    ENTRY:      Object to Copy

    NOTES:      A copy is a special case of Append so we just zero terminate
                *this and append the string.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Copy( DWORD cbLen, const PVOID pbBuf )
{
    SetCB(0);

    if ( pbBuf )
    {
        return AuxAppend( pbBuf, cbLen, FALSE );
    }

    return TRUE;
}

BOOL CBIN::Copy( const CBIN   & cbin )
{
    if ( cbin.IsEmpty()) {
        // To avoid pathological allocation of small chunk of memory
        SetCB(0);
        return ( TRUE);
    }

    return Copy( cbin.QueryCB(), cbin.QueryPtr() );
}

/*******************************************************************

    NAME:       CBIN::Resize

    SYNOPSIS:   Resizes or allocates string memory, NULL terminating
                if necessary

    ENTRY:      cbNewRequestedSize - New string size

    NOTES:

    HISTORY:
        Johnl   12-Sep-1994     Created

********************************************************************/

BOOL CBIN::Resize( UINT cbNewRequestedSize )
{
    if ( !BUFFER::Resize( cbNewRequestedSize ))
        return FALSE;

    return TRUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\readschema.h ===
extern HRESULT
ReadMetaObject(IN CMDBaseObject*&     cboRead,
			   IN LPWSTR		      wszPath,
			   IN FILETIME*           pFileTime,
			   IN BOOL		          bUnicode);

extern HRESULT
ReadDataObject(IN CMDBaseObject*      cboAssociated,
		       IN LPVOID*             a_pv,
		       IN ULONG*              a_Size,
               IN IIS_CRYPTO_STORAGE* pCryptoStorage,
               IN BOOL                bUnicode);

extern HRESULT 
ReadSchema(IIS_CRYPTO_STORAGE*		i_pStorage,
		   FILETIME*				pFileTime);

extern HRESULT 
ReadSchemaProperties(CMDBaseObject*           i_pboRead,
  				     IIS_CRYPTO_STORAGE*	  i_pStorage);

extern HRESULT 
ReadAdminACL(CMDBaseObject*       i_pboRead,
		     IIS_CRYPTO_STORAGE*  i_pStorage);

extern DWORD 
GetPrincipalSID (LPWSTR Principal,
	             PSID*  Sid,
				 BOOL*  pbWellKnownSID);

extern HRESULT 
ReadLargestMetaID(CMDBaseObject*             i_pboRead,
  				  IIS_CRYPTO_STORAGE*		 i_pStorage);

extern HRESULT 
ReadProperties(IIS_CRYPTO_STORAGE*		i_pStorage,
   			   FILETIME*				i_pFileTime);

extern HRESULT 
ReadPropertyNames(CMDBaseObject*			i_pboRead,
				  LPVOID*					i_apv,
				  ULONG*					i_aSize,
	   			  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadFlagNames(CMDBaseObject*			i_pboRead,
			  LPVOID*					i_apv,
			  ULONG*					i_aSize,
	   		  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadPropertyTypes(CMDBaseObject*			i_pboRead,
				  LPVOID*					i_apv,
				  ULONG*					i_aSize,
	   			  IIS_CRYPTO_STORAGE*		i_pStorage);

extern HRESULT 
ReadAllFlags(IIS_CRYPTO_STORAGE*		i_pStorage,
			 CMDBaseObject*				i_pboReadType,
			 CMDBaseObject*				i_pboReadName,
			 CMDBaseObject*				i_pboReadDefault,
			 DWORD						i_dwColumnIndex,
			 DWORD						i_dwMetaID,
			 DWORD						i_dwFlags,
			 DWORD						i_dwAttributes,
			 DWORD						i_dwUserType,
			 DWORD						i_dwMultivalued);

extern HRESULT 
ReadFlagTypes(CMDBaseObject*			i_pboRead,
   			  IIS_CRYPTO_STORAGE*		i_pStorage,
			  DWORD						i_dwMetaID,
			  DWORD						i_dwFlags,
			  DWORD						i_dwAttributes,
			  DWORD						i_dwUserType,
			  DWORD						i_dwMultivalued,
			  LPVOID*					i_apv,
			  ULONG*					i_aSize);

extern HRESULT 
ReadFlagDefaults(CMDBaseObject*			i_pboRead,
			     LPVOID*				i_apv,
			     ULONG*					i_aSize,
	   		     IIS_CRYPTO_STORAGE*	i_pStorage);

extern HRESULT 
ReadPropertyDefaults(CMDBaseObject*			i_pboRead,
				     LPVOID*				i_apv,
				     ULONG*					i_aSize,
	   			     IIS_CRYPTO_STORAGE*	i_pStorage);

extern HRESULT 
ReadClasses(IIS_CRYPTO_STORAGE*		i_pStorage,
 			FILETIME*				i_pFileTime);

extern HRESULT 
ReadClass(LPVOID*					i_apv,
		  ULONG*					i_aSize,
	      IIS_CRYPTO_STORAGE*		i_pStorage,
 		  FILETIME*					i_pFileTime);

extern HRESULT 
GetProperties(LPCWSTR					i_wszTable,
              LPWSTR*					o_pwszOptional,
			  LPWSTR*					o_pManditory);

extern HRESULT 
AddFlagValuesToPropertyList(LPWSTR					i_wszTable,
		                    ULONG					i_dwIndex,
							ULONG*					io_pcCh,
							LPWSTR*					io_pwszPropertyList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\saveschema.h ===
typedef struct _DELIMITEDSTRING
{
	LPWSTR pwszStringStart;
	LPWSTR pwszStringEnd;

} DELIMITEDSTRING;


extern HRESULT 
SaveSchemaIfNeeded(LPCWSTR	            i_wszTempFile,
				   PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

extern HRESULT 
SaveSchema(LPCWSTR	            i_wszTempFile,
		   PSECURITY_ATTRIBUTES i_pSecurityAtrributes);

extern HRESULT 
CreateNonIISConfigObjectCollections(CMDBaseObject*     i_pObjSchema,
								    CWriter*		   i_pCWriter,
									CMBSchemaWriter**  io_pSchemaWriter);

extern HRESULT 
ParseAndAddPropertiesToNonIISConfigObjectCollection(LPCWSTR					i_wszProperties,
													BOOL					i_bManditory,
													CMBCollectionWriter*	i_pCollectionWriter);

extern HRESULT	
CreateIISConfigObjectCollection(CMDBaseObject*     i_pObjProperties,
								CWriter*		   i_pCWriter,
								CMBSchemaWriter**  io_pSchemaWriter);

extern HRESULT 
SaveNames(CMDBaseObject*	    i_pObjProperties,
		  CWriter*			    i_pCWriter,
          CMBSchemaWriter**	    i_pSchemaWriter,
	      CMBCollectionWriter** i_pCollectionWriter);

extern HRESULT 
SaveTypes(CMDBaseObject*	   i_pObjProperties,
		  CWriter*			   i_pCWriter,
          CMBSchemaWriter**	   i_pSchemaWriter,
		  CMBCollectionWriter** i_pCollectionWriter);

extern HRESULT 
SaveDefaults(CMDBaseObject*	       i_pObjProperties,
		     CWriter*			   i_pCWriter,
             CMBSchemaWriter**	   i_pSchemaWriter,
		     CMBCollectionWriter**  i_pCollectionWriter);

extern BOOL 
PropertyNotInShippedSchema(CWriter*  i_pCWriter,
						   DWORD     i_dwIdentifier);

extern BOOL 
TagNotInShippedSchema(CWriter*	i_pCWriter,
				      DWORD	    i_dwIdentifier);

extern HRESULT 
GetCollectionWriter(CWriter*			   i_pCWriter,
					CMBSchemaWriter**	   io_pSchemaWriter,
					CMBCollectionWriter**  io_pCollectionWriter,
					LPCWSTR                i_wszCollectionName,
					BOOL                   i_bContainer,
					LPCWSTR                i_wszContainerClassList);

extern BOOL 
ClassDiffersFromShippedSchema(LPCWSTR i_wszClassName,
						      BOOL	  i_bIsContainer,
						      LPWSTR  i_wszContainedClassList);

extern BOOL 
MatchClass(BOOL	    i_bIsContainer,
		   LPWSTR	i_wszContainedClassList,
		   LPVOID*  i_apv);

extern BOOL 
MatchCommaDelimitedStrings(LPWSTR	i_wszString1,
						   LPWSTR	i_wszString2);

extern HRESULT 
CommaDelimitedStringToArray(LPWSTR		        i_wszString,
                            DELIMITEDSTRING**	io_apDelimitedString,
							ULONG*              io_piDelimitedString,
							ULONG*		        io_pcMaxDelimitedString,
							BOOL*               io_pbReAlloced);

extern HRESULT 
AddDelimitedStringToArray(DELIMITEDSTRING*     i_pDelimitedString,
				          ULONG*		       io_piDelimitedString,
                          ULONG*		       io_pcMaxDelimitedString,
				          BOOL*		           io_pbReAlloced,
				          DELIMITEDSTRING**	   io_apDelimitedString);

extern HRESULT 
ReAllocate(ULONG              i_iDelimitedString,
		   BOOL               i_bReAlloced,
		   DELIMITEDSTRING**  io_apDelimitedString,
		   ULONG*             io_pcDelimitedString);

extern BOOL 
MatchDelimitedStringArray(DELIMITEDSTRING* i_aString1,
                          ULONG            i_cString1,
			              DELIMITEDSTRING* i_aString2,
					      ULONG            i_cString2);

extern BOOL 
ClassPropertiesDifferFromShippedSchema(LPCWSTR i_wszClassName,
									   LPWSTR  i_wszOptProperties,
									   LPWSTR  i_wszMandProperties);


extern HRESULT 
GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent, 
				CWriterGlobalHelper**	ppCWriterGlobalHelper);

extern HRESULT 
UpdateTimeStamp(LPWSTR i_wszSchemaXMLFileName,
                LPWSTR i_wszSchemaBinFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\writerglobals.h ===
extern LPCWSTR	g_wszBeginFile;					
extern ULONG	g_cchBeginFile;					
extern LPCWSTR	g_wszEndFile;					
extern ULONG	g_cchEndFile;					
extern LPCWSTR	g_BeginLocation;
extern ULONG	g_cchBeginLocation;				
extern LPCWSTR	g_Location;						
extern ULONG	g_cchLocation;					
extern LPCWSTR	g_EndLocationBegin;				
extern ULONG	g_cchEndLocationBegin;			
extern LPCWSTR	g_EndLocationEnd;				
extern ULONG	g_cchEndLocationEnd;				
extern LPCWSTR  g_CloseQuoteBraceRtn;			
extern ULONG	g_cchCloseQuoteBraceRtn;			
extern LPCWSTR  g_Rtn;							
extern ULONG	g_cchRtn;						
extern LPCWSTR  g_EqQuote;						
extern ULONG	g_cchEqQuote;					
extern LPCWSTR  g_QuoteRtn;						
extern ULONG	g_cchQuoteRtn;					
extern LPCWSTR  g_TwoTabs;						
extern ULONG	g_cchTwoTabs;					
extern LPCWSTR	g_NameEq;						
extern ULONG	g_cchNameEq;						
extern LPCWSTR	g_IDEq;							
extern ULONG	g_cchIDEq;						
extern LPCWSTR	g_ValueEq;						
extern ULONG	g_cchValueEq;					
extern LPCWSTR	g_TypeEq;						
extern ULONG	g_cchTypeEq;						
extern LPCWSTR	g_UserTypeEq;					
extern ULONG	g_cchUserTypeEq;					
extern LPCWSTR	g_AttributesEq;					
extern ULONG	g_cchAttributesEq;				
extern LPCWSTR	g_BeginGroup;					
extern ULONG	g_cchBeginGroup;					
extern LPCWSTR	g_EndGroup;						
extern ULONG	g_cchEndGroup;					
extern LPCWSTR	g_BeginCustomProperty;			
extern ULONG	g_cchBeginCustomProperty;		
extern LPCWSTR	g_EndCustomProperty;				
extern ULONG	g_cchEndCustomProperty;			
extern LPCWSTR	g_ZeroHex;						
extern ULONG	g_cchZeroHex;
extern LPCWSTR	g_wszIIsConfigObject;
extern LPCWSTR  g_BeginComment;
extern ULONG    g_cchBeginComment;
extern LPCWSTR  g_EndComment;
extern ULONG    g_cchEndComment;

extern WORD    BYTE_ORDER_MASK;
extern DWORD	UTF8_SIGNATURE;

extern LPWSTR  g_wszByID;
extern LPWSTR  g_wszByName;
extern LPWSTR  g_wszByTableAndColumnIndexOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndNameOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndValueOnly;
extern LPWSTR  g_wszByTableAndTagNameOnly;
extern LPWSTR  g_wszByTableAndTagIDOnly;
extern LPWSTR  g_wszUnknownName;
extern ULONG   g_cchUnknownName;             
extern LPWSTR  g_UT_Unknown;
extern ULONG   g_cchUT_Unknown;
extern LPWSTR  g_T_Unknown;
extern LPWSTR  g_wszTrue;
extern ULONG   g_cchTrue;
extern LPWSTR  g_wszFalse;
extern ULONG   g_cchFalse;
extern ULONG   g_cchMaxBoolStr;

extern LPCWSTR g_wszHistorySlash;
extern ULONG   g_cchHistorySlash;
extern LPCWSTR g_wszMinorVersionExt;
extern ULONG   g_cchMinorVersionExt;
extern LPCWSTR g_wszDotExtn;
extern ULONG   g_cchDotExtn;
extern WCHAR   g_wchBackSlash;
extern WCHAR   g_wchFwdSlash;
extern WCHAR   g_wchDot;

extern ULONG  g_cchTemp;
extern WCHAR  g_wszTemp[];
extern LPCWSTR g_wszBeginSchema;
extern ULONG   g_cchBeginSchema;
extern LPCWSTR g_wszEndSchema;
extern ULONG   g_cchEndSchema;
extern LPCWSTR g_wszBeginCollection;
extern ULONG   g_cchBeginCollection;
extern LPCWSTR g_wszSchemaGen;
extern ULONG   g_cchSchemaGen;
extern LPCWSTR g_wszInheritsFrom;
extern ULONG   g_cchInheritsFrom;
extern LPCWSTR g_wszEndCollection;
extern ULONG   g_cchEndCollection;
extern LPCWSTR g_wszBeginPropertyShort; 
extern ULONG   g_cchBeginPropertyShort;
extern LPCWSTR g_wszMetaFlagsExEq;
extern ULONG   g_cchMetaFlagsExEq;
extern LPCWSTR g_wszEndPropertyShort; 
extern ULONG   g_cchEndPropertyShort; 
extern LPCWSTR g_wszBeginPropertyLong;
extern ULONG   g_cchBeginPropertyLong;
extern LPCWSTR g_wszPropIDEq;
extern ULONG   g_cchPropIDEq;
extern LPCWSTR g_wszPropTypeEq;
extern ULONG   g_cchPropTypeEq;
extern LPCWSTR g_wszPropUserTypeEq;
extern ULONG   g_cchPropUserTypeEq;
extern LPCWSTR g_wszPropAttributeEq;
extern ULONG   g_cchPropAttributeEq;
extern LPWSTR  g_wszPropMetaFlagsEq; 
extern ULONG   g_cchPropMetaFlagsEq; 
extern LPWSTR  g_wszPropMetaFlagsExEq;
extern ULONG   g_cchPropMetaFlagsExEq;
extern LPWSTR  g_wszPropDefaultEq;    
extern ULONG   g_cchPropDefaultEq;    
extern LPWSTR  g_wszPropMinValueEq;   
extern ULONG   g_cchPropMinValueEq;   
extern LPWSTR  g_wszPropMaxValueEq;   
extern ULONG   g_cchPropMaxValueEq;  
extern LPWSTR  g_wszEndPropertyLongNoFlag;
extern ULONG   g_cchEndPropertyLongNoFlag;
extern LPWSTR  g_wszEndPropertyLongBeforeFlag;
extern ULONG   g_cchEndPropertyLongBeforeFlag;
extern LPWSTR  g_wszEndPropertyLongAfterFlag;
extern ULONG   g_cchEndPropertyLongAfterFlag; 
extern LPCWSTR g_wszBeginFlag; 
extern ULONG   g_cchBeginFlag; 
extern LPCWSTR g_wszFlagValueEq;   
extern ULONG   g_cchFlagValueEq;   
extern LPCWSTR g_wszEndFlag;
extern ULONG   g_cchEndFlag;
extern LPCWSTR g_wszEndPropertyShort;

extern LPCWSTR g_wszOr;
extern ULONG   g_cchOr;
extern LPCWSTR g_wszOrManditory;
extern ULONG    g_cchOrManditory;
extern LPCWSTR g_wszFlagIDEq;
extern ULONG   g_cchFlagIDEq;
extern LPCWSTR g_wszContainerClassListEq;
extern ULONG   g_cchContainerClassListEq;

extern LPCWSTR g_wszSlash;
extern ULONG   g_cchSlash;
extern LPCWSTR g_wszLM;
extern ULONG   g_cchLM;
extern LPCWSTR g_wszSchema;
extern ULONG   g_cchSchema;
extern LPCWSTR g_wszSlashSchema;
extern ULONG   g_cchSlashSchema;
extern LPCWSTR g_wszSlashSchema;
extern ULONG   g_cchSlashSchema;
extern LPCWSTR g_wszSlashSchemaSlashProperties;
extern ULONG   g_cchSlashSchemaSlashProperties;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashNames;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashNames;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashTypes;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashTypes;
extern LPCWSTR g_wszSlashSchemaSlashPropertiesSlashDefaults;
extern ULONG   g_cchSlashSchemaSlashPropertiesSlashDefaults;
extern LPCWSTR g_wszSlashSchemaSlashClasses;
extern ULONG   g_cchSlashSchemaSlashClasses;
extern LPWSTR  g_wszEmptyMultisz;
extern ULONG   g_cchEmptyMultisz;
extern LPWSTR  g_wszEmptyWsz;
extern ULONG   g_cchEmptyWsz;
extern LPCWSTR g_wszComma;
extern ULONG   g_cchComma;
extern LPCWSTR g_wszMultiszSeperator;
extern ULONG   g_cchMultiszSeperator;


extern LPCWSTR g_aSynIDToWszType[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\writer.h ===
#ifndef _WRITER_H
#define _WRITER_H

//
// Forward declaration 
//
class CLocationWriter;
class CCatalogSchemaWriter;
class CMBSchemaWriter;

enum eWriter
{
	eWriter_Schema,
	eWriter_Metabase,
	eWriter_Abort,
};

#define g_cbMaxBuffer			32768		
#define g_cchMaxBuffer			g_cbMaxBuffer/sizeof(WCHAR)
#define g_cbMaxBufferMultiByte  32768

class CWriter
{

	public:

		CWriter();

		~CWriter();

		HRESULT Initialize(LPCWSTR				 wszFile,
						   CWriterGlobalHelper*  i_pCWriterGlobalHelper,
						   HANDLE				 hFile);

		HRESULT WriteToFile(LPVOID	pvData,
							DWORD	cchData,
							BOOL    bForceFlush = FALSE);

		HRESULT BeginWrite(eWriter              eType,
                                   PSECURITY_ATTRIBUTES pSecurityAtrributes = NULL);

		HRESULT GetLocationWriter(CLocationWriter** ppLocationWriter,
								  LPCWSTR           wszLocation);

		HRESULT GetCatalogSchemaWriter(CCatalogSchemaWriter** ppSchemaWriter);

		HRESULT GetMetabaseSchemaWriter(CMBSchemaWriter** ppSchemaWriter);

		HRESULT EndWrite(eWriter eType);

	private:
		HRESULT FlushBufferToDisk();
		HRESULT ConstructFile(PSECURITY_ATTRIBUTES pSecurityAtrributes);

	private:
		LPWSTR				m_wszFile;
		BOOL				m_bCreatedFile;
        ULONG               m_cbBufferUsed;
        BYTE                m_Buffer[g_cbMaxBuffer];
        BYTE                m_BufferMultiByte[g_cbMaxBufferMultiByte];


	public:
		HANDLE					m_hFile;
		CWriterGlobalHelper*	m_pCWriterGlobalHelper;
		ISimpleTableWrite2*	    m_pISTWrite;

}; // Class CWriter

#endif // _WRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\handle.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase handle routines

Author:

    Michael W. Thomas            04-Oct-96

Revision History:

Notes:

--*/

#include <mdcommon.hxx>

DWORD
CMDHandle::SetChangeData(CMDBaseObject *pboChanged,
         DWORD          dwChangeType,
         DWORD          dwDataID,
         LPWSTR         pszOldName)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    DWORD dwReturn = ERROR_SUCCESS;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceIndex->NextPtr) {
        if (pceIndex->pboChanged == pboChanged) {
            break;
        }
    }
    if (pceIndex == NULL) {
        pceIndex = new(CHANGE_ENTRY);
        if (pceIndex == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pceIndex->dwNumDataIDs = 0;
            pceIndex->pbufDataIDs = NULL;
            pceIndex->dwChangeType = 0;
            pceIndex->pboChanged = pboChanged;
            pceIndex->NextPtr = m_pceChangeList;
            pceIndex->pStrOrigName = NULL;
            m_pceChangeList = pceIndex;
        }
    }
    if (dwReturn == ERROR_SUCCESS) {
        MD_ASSERT(pceIndex != NULL);
        pceIndex->dwChangeType |= dwChangeType;
        if ((dwChangeType == MD_CHANGE_TYPE_SET_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_DELETE_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_RENAME_OBJECT && pszOldName != NULL )) {
            if (pceIndex->pbufDataIDs == NULL) {
                pceIndex->pbufDataIDs = new BUFFER();
                if (pceIndex->pbufDataIDs == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS && pceIndex->pStrOrigName == NULL && pszOldName !=NULL) {
                pceIndex->pStrOrigName = new STRAU();
                if (pceIndex->pStrOrigName == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    // sucess 
                    // we are taking the old name of metabase key only once. 
                    // so if subsequent renames will happen we will return the oldest one
                    pceIndex->pStrOrigName->Copy (pszOldName);
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                for (i = 0; i < pceIndex->dwNumDataIDs; i++) {
                    if (((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[i] == dwDataID) {
                        break;
                    }
                }
                if (i == pceIndex->dwNumDataIDs) {
                    if (!pceIndex->pbufDataIDs->Resize((pceIndex->dwNumDataIDs + 1) * sizeof(DWORD))) {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else {
                        ((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[pceIndex->dwNumDataIDs] = dwDataID;
                        pceIndex->dwNumDataIDs++;
                    }
                }
            }
        }
    }
    return dwReturn;
}

CMDHandle::~CMDHandle()
{
    RemoveNotifications();
}


PCHANGE_ENTRY
CMDHandle::EnumChangeEntries(DWORD dwIndex)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    for (i = 0, pceIndex = m_pceChangeList;
         pceIndex != NULL && i < dwIndex;
         i++, pceIndex = pceIndex->NextPtr) {
    }
    return pceIndex;
}

DWORD
CMDHandle::GetNumChangeEntries()
{
    DWORD dwCount = 0;
    PCHANGE_ENTRY pceIndex;

    for (pceIndex = m_pceChangeList;
        pceIndex !=NULL;
        pceIndex = pceIndex->NextPtr) {
        dwCount++;
    }

    return dwCount;
}

VOID
CMDHandle::RemoveNotifications()
{
    PCHANGE_ENTRY pceIndex, pceNext;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceNext) {
        pceNext = pceIndex->NextPtr;
        delete(pceIndex->pbufDataIDs);
        delete(pceIndex->pStrOrigName);
        if ((pceIndex->dwChangeType & MD_CHANGE_TYPE_DELETE_OBJECT) != 0) {
            delete(pceIndex->pboChanged);
        }
        delete(pceIndex);
    }
    m_pceChangeList = NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\globals.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS MetaBase global variables

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/
#include <mdcommon.hxx>

//
// Access to global data structures is synchronized by
// acquiring g_rMasterResource with read or write
// permission.
//

CMDCOMSrvFactory    *g_pFactory = NULL;

ULONG                g_dwRefCount = 0;

CMDBaseObject       *g_pboMasterRoot;

TS_RESOURCE         *g_rMasterResource;

TS_RESOURCE         *g_rSinkResource;

CMDHandle           *g_phHandleHead;

METADATA_HANDLE      g_mhHandleIdentifier;

DWORD                g_dwSystemChangeNumber = 0;

DWORD                g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;

DWORD                g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;

HANDLE               g_phEventHandles[EVENT_ARRAY_LENGTH];

HANDLE               g_hReadSaveSemaphore;

DWORD                g_dwInitialized = 0;

HRESULT              g_hresInitWarning = ERROR_SUCCESS;

CMDBaseData        **g_ppbdDataHashTable;

DWORD                g_dwWriteNumber;

DWORD                g_dwLastSaveChangeNumber;

BOOL                 g_bSaveDisallowed;

//
// Data Buffer
// Access to these is synchronized via
// g_csDataBufferCritSec
//

PBUFFER_CONTAINER    g_pbcDataFreeBufHead;

PBUFFER_CONTAINER    g_pbcDataUsedBufHead;

PVOID               *g_ppvDataBufferBlock;

PBUFFER_CONTAINER    g_pbcDataContainerBlock;

HANDLE               g_hDataBufferSemaphore;

CRITICAL_SECTION     g_csDataBufferCritSec;

//
// Data File
//

STR                  *g_strRealFileName;
STR                  *g_strTempFileName;
STR                  *g_strBackupFileName;

STR                  *g_pstrBackupFilePath;

PSID                 g_psidSystem;
PSID                 g_psidAdmin;
PACL                 g_paclDiscretionary;
PSECURITY_DESCRIPTOR g_psdStorage;

//
// Debugging stuff
//

    DECLARE_DEBUG_VARIABLE();
    DECLARE_DEBUG_PRINTS_OBJECT();

DWORD           g_dwProcessAttached = 0;



DWORD g_dwCMDBaseObjectNextUniqueDataSetNumber = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\baseobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Basic Object Class for IIS MetaBase.

Author:

    Michael W. Thomas            20-May-96

Revision History:

--*/

#include <mdcommon.hxx>


CMDBaseObject::CMDBaseObject(
    LPSTR strName,
    LPSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey(); // BUGBUG:  This could fail.  Shouldn't be in constructor.
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::CMDBaseObject(
    LPWSTR strName,
    LPWSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();   // BUGBUG:  This could fail.  Shouldn't be in constructor.
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::~CMDBaseObject()
/*++

Routine Description:

    Destructor for an object. Deletes all data and recursively deletes
    all child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            DeleteDataObject(pdcIndex->pbdDataObject);
            delete(pdcIndex);
        }
    }

    if (m_phtChildren)
        delete(m_phtChildren);

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        delete(pbocIndex->pboMetaObject);
        delete(pbocIndex);
    }
}



BOOL
CMDBaseObject::SetName(
    LPSTR strName,
    BOOL bUnicode
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

     BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    if (bUnicode)
        fRet = m_strMDName.SafeCopy((LPWSTR)strName);
    else
        fRet = m_strMDName.SafeCopy((LPSTR)strName);

    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



BOOL
CMDBaseObject::SetName(
    LPWSTR strName
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

    BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    fRet = m_strMDName.SafeCopy(strName);
    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



HRESULT
CMDBaseObject::InsertChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Inserts a child object into the list of child objects.

Arguments:

    Child - the object to insert.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME
--*/

{
    MD_ASSERT(pboChild != NULL);
    MD_ASSERT(pboChild->m_bufKey.QuerySize() > 0);

    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER pbocNew = new BASEOBJECT_CONTAINER;

    // Bail if not enough memory.
    if (pbocNew == NULL)
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

    pbocNew->pboMetaObject = pboChild;
    pbocNew->NextPtr = NULL;
    pboChild->SetParent(this);


    hresReturn = AddChildObjectToHash(pboChild,
                                      pbocNew);

    // Attach to the chain at the end (to keep enumeration ordering)
    if (SUCCEEDED(hresReturn))
    {
        if (m_pbocChildHead == NULL)
            m_pbocChildHead = pbocNew;
        else
            m_pbocChildTail->NextPtr = pbocNew;
        m_pbocChildTail = pbocNew;

        m_cbo++;
        SetLastChangeTime();
    }
    else
        delete pbocNew;

    return(hresReturn);
}

CMDBaseObject *
CMDBaseObject::GetChildObject(
    IN OUT LPSTR &strName,
    OUT HRESULT *phresReturn,
    IN BOOL bUnicode
    )
/*++

Routine Description:

    Gets a child object by name. Updates strName to point past the end of the Name if found.

Arguments:

    Name - name of the object. End delimeter can be '\0', '\\', or '/'.

Return Value:

    CBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent = NULL;
    CMDBaseObject *pboReturn = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pchDelimiter = strName;

    // Find the delimiter.  Change to terminate character.
    if (bUnicode)
    {
        LPWSTR pchDelimiterW = (LPWSTR) pchDelimiter;
        WCHAR chW;

        while ((chW = *pchDelimiterW) != MD_ALT_PATH_DELIMETERW &&
                                  chW != MD_PATH_DELIMETERW &&
                                  chW != (WCHAR) '\0')
            {
            pchDelimiterW++;
            }
        pchDelimiter = (LPSTR) pchDelimiterW;
    }
    else
    {
        CHAR chA;

        while ((chA = *(LPSTR) pchDelimiter) != MD_ALT_PATH_DELIMETERA &&
                                         chA != MD_PATH_DELIMETERA &&
                                         chA != (CHAR) '\0')
            {
            (LPSTR) pchDelimiter = CharNextExA(CP_ACP,
                                               (LPSTR) pchDelimiter,
                                               0);
            }
    }

    // Find the child.
    pboReturn = FindChild(strName, DIFF(pchDelimiter-strName), bUnicode, phresReturn);

    // If we found the name, move up the pointer to the delimiter
    if (pboReturn != NULL)
    {
        MD_ASSERT(*phresReturn == ERROR_SUCCESS);

        strName = pchDelimiter;
    }

#if 0    // SAB
    // If we didn't find the name, return the "not found" error.
    else if (*phresReturn == ERROR_SUCCESS)
    {
        *phresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }
#endif

    return(pboReturn);
}



CMDBaseObject *
CMDBaseObject::EnumChildObject(
         IN DWORD dwEnumObjectIndex
         )
/*++

Routine Description:

    Gets a child object by index.

Arguments:

    EnumObjectIndex - The 0 based index of the object to get.

Return Value:

    CMDBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent;
    CMDBaseObject *pboReturn;
    DWORD i;

    for (pbocCurrent = m_pbocChildHead, i=0;
        (pbocCurrent!=NULL) && (i < dwEnumObjectIndex);
        pbocCurrent=pbocCurrent->NextPtr, i++) {
    }
    if (pbocCurrent != NULL) {
        pboReturn = pbocCurrent->pboMetaObject;
    }
    else {
        pboReturn = NULL;
    }
    return (pboReturn);
}


HRESULT
CMDBaseObject::RemoveChildObject(
         IN LPTSTR strName,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (strName != NULL);

    CMDBaseObject*          pboCurrent;
    BASEOBJECT_CONTAINER*   pbocPrev;
    HRESULT hresReturn;

    // Find the object, including the previous container.
    pboCurrent = FindChild(strName,
                           /* Length */ -1,
                           bUnicode,
                           &hresReturn,
                           /* fUseHash */ FALSE,
                           &pbocPrev);

    if (hresReturn == ERROR_SUCCESS)
    {   // Either we found it, or it's not there.  But no errors occurred.
        if (pboCurrent != NULL)
        {   // We found it.
            BASEOBJECT_CONTAINER* pbocCurrent;

            RemoveChildObjectFromHash(pboCurrent);

            // Remove from the container chain, keeping a pointer to the container to delete.
            if (pbocPrev == NULL)
            {
                pbocCurrent = m_pbocChildHead;
                MD_ASSERT(pbocCurrent != NULL);
                m_pbocChildHead = pbocCurrent->NextPtr;
                // If tail pointed to pbocCurrent, then head will become NULL,
                // in which case tail will be ignored.
            }
            else
            {
                pbocCurrent = pbocPrev->NextPtr;
                MD_ASSERT(pbocCurrent != NULL);
                pbocPrev->NextPtr = pbocCurrent->NextPtr;
                if (m_pbocChildTail == pbocCurrent)
                {
                    MD_ASSERT(pbocPrev->NextPtr == NULL);
                    m_pbocChildTail = pbocPrev;
                }
            }

            // Delete the container.  The base object itself is deleted as part of
            // CMDHandle::RemoveNotifications.
            delete pbocCurrent;

            m_cbo--;
            MD_ASSERT(m_cbo >= 0);
            SetLastChangeTime();
        }

        // If FindChild() succeeded but didn't find anything, return the error.
        else
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        }
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::AddChildObjectToHash(
         IN CMDBaseObject *pboChild,
         IN BASEOBJECT_CONTAINER* pbocChild
         )
/*++

Routine Description:

    Add child object from the hash table.

Arguments:

    Child       - The object to remove.
    pbocChild   - The container for the child object. If NULL,
                  the child must already be on the child list.
                  This routine will find the child container, and will
                  not check the child list for ERROR_DUP_NAME.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME

--*/
{
    HRESULT hresReturn = NO_ERROR;
    BOOL bCheckForDups = (pbocChild == NULL) ? FALSE : TRUE;

    // Should we create the hash table now?
    if (m_phtChildren == NULL && m_cbo >= cboCreateHashThreashold)
    {   // Time to create hash table
        // Just skip if we can't create table for some reason.

        m_phtChildren = new CChildNodeHashTable;
        if (m_phtChildren != NULL)
        {   // Create successful.  Let's fill the sucker.
            BASEOBJECT_CONTAINER* pboc = m_pbocChildHead;
            while (pboc != NULL)
            {
                LK_RETCODE ret;

                MD_ASSERT(pboc->pboMetaObject != NULL);
                MD_ASSERT(pboc->pboMetaObject->m_bufKey.QuerySize() > 0);

                ret = m_phtChildren->InsertRecord(pboc,
                                                  /* fOverwrite */ FALSE);
                MD_ASSERT(ret == LK_SUCCESS);
                if (ret != LK_SUCCESS)
                {
                    delete m_phtChildren;
                    m_phtChildren = NULL;
                    break;
                }

                pboc = pboc->NextPtr;
            }
        }
    }

    // Use hash table if it exists.
    if (m_phtChildren != NULL)
    {
        LK_RETCODE ret;

        if (pbocChild == NULL) {

            //
            // Need container for insert function.
            // If it came in as NULL, then the node is not
            // really new (ie. rename) and should already be
            // on the list, so find it.
            //


            BASEOBJECT_CONTAINER* pbocIndex = m_pbocChildHead;
            while ((pbocIndex != NULL) && (pbocIndex->pboMetaObject != pboChild)) {
                pbocIndex = pbocIndex->NextPtr;
            }

            DBG_ASSERT((pbocIndex != NULL) && (pbocIndex->pboMetaObject == pboChild));
            pbocChild = pbocIndex;
        }


        // Put in hash table.  This looks for dups.
        ret = m_phtChildren->InsertRecord(pbocChild,
                                         /* fOverwrite */ FALSE);
        if (ret == LK_KEY_EXISTS)
        {
            DebugBreak();
            return RETURNCODETOHRESULT(ERROR_DUP_NAME);
        }
        if (ret != LK_SUCCESS)
        {
            MD_ASSERT(ret == LK_SUCCESS);   // Put up debug assert now.
            delete m_phtChildren;
            m_phtChildren = NULL;
            goto NoHashTable;
        }
    }

    // If hash table doesn't exist, check for duplicate by searching chain.
    else
    {
NoHashTable:
        if (m_pbocChildHead != NULL && bCheckForDups)
        {
            LPSTR strChildName;

            // Check for duplicates
            strChildName = pboChild->GetName(/* bUnicode */ TRUE);
            if (strChildName == NULL)
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            else if (FindChild(strChildName,
                              /* Length */ -1,
                              /* bUnicode */ TRUE,
                              &hresReturn,
                              /* fUseHash */ FALSE,
                              NULL) != NULL)
            {
                hresReturn = RETURNCODETOHRESULT(ERROR_DUP_NAME);
            }
        }
    }

    return hresReturn;
}

VOID
CMDBaseObject::RemoveChildObjectFromHash(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the hash table.

Arguments:

    Child       - The object to remove.

Return Value:

    none

--*/
{
    // Delete from the hash table.
    if (m_phtChildren != NULL)
    {
        m_phtChildren->DeleteKey(&pboChild->m_bufKey);

        // Delete the hash table if we've gone below the threashold.
        if (m_cbo <= cboDeleteHashThreashold)
        {
            delete m_phtChildren;
            m_phtChildren = NULL;
        }
    }
}

HRESULT
CMDBaseObject::RemoveChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (pboChild != NULL);

    BASEOBJECT_CONTAINER* pbocCurrent;
    BASEOBJECT_CONTAINER* pbocPrev;
    HRESULT hresReturn;

    // Find the object in the container chain.
    pbocPrev = NULL;
    pbocCurrent = m_pbocChildHead;
    while (pbocCurrent != NULL && pbocCurrent->pboMetaObject != pboChild)
    {
        pbocPrev = pbocCurrent;
        pbocCurrent = pbocCurrent->NextPtr;
    }

    if (pbocCurrent != NULL)
    {    // Found it
        MD_ASSERT (pbocCurrent->pboMetaObject == pboChild);

        RemoveChildObjectFromHash(pboChild);

        // Remove from the container chain.
        if (pbocPrev == NULL)
        {
            m_pbocChildHead = pbocCurrent->NextPtr;
            // If tail pointed to pbocCurrent, then head will become NULL,
            // in which case tail will be ignored.
        }
        else
        {
            pbocPrev->NextPtr = pbocCurrent->NextPtr;
            if (m_pbocChildTail == pbocCurrent)
            {
                MD_ASSERT(pbocPrev->NextPtr == NULL);
                m_pbocChildTail = pbocPrev;
            }
        }

        // Delete it.  Actual base object is deleted as part of
        // CMDHandle::RemoveNotifications.
        delete pbocCurrent;
        hresReturn = ERROR_SUCCESS;

        m_cbo--;
        MD_ASSERT(m_cbo >= 0);
        SetLastChangeTime();
    }
    else {
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::InsertDataObject(
         IN CMDBaseData *pbdInsert
         )
/*++

Routine Description:

    Inserts a data object into the list of data objects of that type.

Arguments:

    Data    - The data object to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_INTERNAL_ERROR

Notes:

    Does not check for duplicates. This should be checked by the calling routine.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    MD_ASSERT (pbdInsert != NULL);
    PDATA_CONTAINER *pdcHead;
    PDATA_CONTAINER pdcNew;

    pdcNew = new (DATA_CONTAINER);
    if (pdcNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        pdcHead = &(m_pdcarrayDataHead[pbdInsert->GetDataType()]);
        pdcNew->NextPtr = NULL;
        pdcNew->pbdDataObject = pbdInsert;
        if (*pdcHead == NULL) {
            *pdcHead = pdcNew;
        }
        else {
            //
            // It seems likely that the first paths read in will be the most common
            // paths, so insert at end of list
            //
            PDATA_CONTAINER pdcIndex;
            for (pdcIndex = *pdcHead;
                pdcIndex->NextPtr != NULL;
                pdcIndex = pdcIndex->NextPtr) {
            }
            MD_ASSERT(pdcIndex!=NULL);
            MD_ASSERT(pdcIndex->NextPtr==NULL);
            pdcIndex->NextPtr = pdcNew;
            if ((pbdInsert->GetAttributes() & METADATA_INHERIT) == 0) {
                m_dwNumNonInheritableData++;
            }
        }
    }
    if (SUCCEEDED(hresReturn)) {
        SetLastChangeTime();
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN CMDBaseData *pbdNew
         )
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data       - The data to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdNew != NULL);
    CMDBaseData *pbdOld = GetDataObject(pbdNew->GetIdentifier(), METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if (pbdOld == pbdNew) {
        //
        // It's already there, leave it alone.
        //
        hresReturn = ERROR_SUCCESS;
    }
    else {
        //
        // Insert the new first so if there's a problem leave the old.
        //
        hresReturn = InsertDataObject(pbdNew);
        if (SUCCEEDED(hresReturn)) {
            pbdNew->IncrementReferenceCount();
            if (pbdOld != NULL) {
                hresReturn = RemoveDataObject(pbdOld, TRUE);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN PMETADATA_RECORD pmdrMDData,
         IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data - The data to set.

        Identifier - The identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdNew;

    CMDBaseData *pbdOld = GetDataObject(pmdrMDData->dwMDIdentifier, METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if ((pbdOld != NULL) &&
        ((pbdOld->GetAttributes() & METADATA_SECURE) != 0) &&
        ((pmdrMDData->dwMDAttributes & METADATA_SECURE) == 0)) {
        hresReturn = MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE;
    }
    else {

        pbdNew = MakeDataObject(pmdrMDData, bUnicode);

        if (pbdNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (pbdOld == pbdNew) {
                //
                // It's already there, just correct the ref count,
                // which MakeDataObject incremented.
                //
                DeleteDataObject(pbdNew);
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = InsertDataObject(pbdNew);
                if (FAILED(hresReturn)) {
                    DeleteDataObject(pbdNew);
                    pbdNew = NULL;
                }
                else {
                    if (pbdOld!=NULL) {
                        //
                        // Data exists with same name.
                        // Need to delete old data.
                        //
                        hresReturn = RemoveDataObject(pbdOld, TRUE);
                        MD_ASSERT(SUCCEEDED(hresReturn));
                    }
                }
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::RemoveDataObject(
         IN CMDBaseData *pbdRemove,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Remove      - The data object to remove.

    Delete      - If true, the object is deleted.

Return Value:

    BOOL        - TRUE if the data was successfully removed.
                  FALSE if the data object is not associated with this metaobject.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdRemove != NULL);
    PDATA_CONTAINER *ppdcHead;
    PDATA_CONTAINER pdcSave;

    ppdcHead = &(m_pdcarrayDataHead[pbdRemove->GetDataType()]);
    if (*ppdcHead == NULL) {
        hresReturn = MD_ERROR_DATA_NOT_FOUND;
    }
    else {
        if ((*ppdcHead)->pbdDataObject == pbdRemove) {
            pdcSave = *ppdcHead;
            *ppdcHead = (*ppdcHead)->NextPtr;
            delete pdcSave;
            hresReturn = ERROR_SUCCESS;
        }
        else {
            PDATA_CONTAINER ppdcIndex;
            for (ppdcIndex = *ppdcHead;
                (ppdcIndex->NextPtr!=NULL) && (ppdcIndex->NextPtr->pbdDataObject!=pbdRemove);
                ppdcIndex=ppdcIndex->NextPtr) {
            }
            if (ppdcIndex->NextPtr==NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                MD_ASSERT(ppdcIndex->NextPtr->pbdDataObject == pbdRemove);
                pdcSave = ppdcIndex->NextPtr;
                ppdcIndex->NextPtr = pdcSave->NextPtr;
                delete (pdcSave);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        if ((pbdRemove->GetAttributes() & METADATA_INHERIT) == 0) {
            m_dwNumNonInheritableData--;
        }
        if (bDelete) {
            DeleteDataObject(pbdRemove);
        }
        SetLastChangeTime();
    }
    return (hresReturn);
}

CMDBaseData *
CMDBaseObject::RemoveDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Name        - The name of the data to remove.

    DataType    - Optional type of the data to remove. If specified, only data of that
                  type will be removed.

    bDelete  - If true, the object is deleted.

Return Value:

    CMDBaseData * - Pointer to the data object removed. If bDelete == TRUE, the pointer will still be
                    returned, but will not be valid.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdRemove;
    pbdRemove=GetDataObject(dwIdentifier, METADATA_NO_ATTRIBUTES, dwDataType);
    if (pbdRemove != NULL) {
        MD_REQUIRE(RemoveDataObject(pbdRemove, bDelete) == ERROR_SUCCESS);
    }
    return(pbdRemove);
}



bool
CMDBaseObject::GenerateKey()
{
    LPSTR       pstr = (LPSTR) m_strMDName.QueryStrW();

    if (pstr == NULL)
        return FALSE;

    return GenerateBufFromStr(pstr,
                              /* cch */ -1,
                              /* fUnicode */ TRUE,
                              &m_bufKey);
}



bool
CMDBaseObject::GenerateBufFromStr(
    IN const char*     pstr,
    IN int             cch,
    IN BOOL            fUnicode,
    OUT CMDKeyBuffer*  pbuf)

/*++

Routine Description:

    Fills the given buffer with the object key based on the given string.

Arguments:

    str         - The string to convert into the key.
    fUnicode    - TRUE if the string is unicode, FALSE if ansi.
    pbuf        - Pointer to the buffer that will contain the new key.

Return Value:

    BOOL        - FALSE if out-of-memory allocating the buffer.

--*/
{
    BUFFER  bufUnicode;     // Use this to hold unicode string if needed.
    int     cchRet;         // Length of actual converted string.

    MD_ASSERT(cch != 0);    // Must either be -1 or a non-null string length.

    // If not unicode, convert to unicode now.
    if (!fUnicode)
    {
        // If we know the size, guess at the unicode size.
        if (cch > 0)
            if (!bufUnicode.Resize(cch*2+50))
                return FALSE;


        // Loop until we have big enough buffer to hold unicode string
        while(TRUE)
        {
            // Buffer length can't be zero, or MultiByteToWideChar() will
            // interpret this by returning "required buffer length" and do
            // no conversion.
            MD_ASSERT(bufUnicode.QuerySize() > 1);

            cchRet = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         pstr,
                                         cch,
                                         (LPWSTR) bufUnicode.QueryPtr(),
                                         bufUnicode.QuerySize()/2);

            // Handle error during conversion.
            if (cchRet == 0)
            {
                // If error wasn't lack of buffer, fail.
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    return FALSE;

                // Otherwise, make the buffer larger and try again.
                /* else */
                    if (!bufUnicode.Resize(bufUnicode.QuerySize()+50))
                        return FALSE;
            }

            // Succeed, continue.
            else
                break;
        }

        // Point to the buffer now.
        pstr = (char *) bufUnicode.QueryPtr();
        cch = cchRet * 2;
    }

    // If we know the length, guess at the destination length.
    if (cch > 0)
    {
        if (!pbuf->Resize(cch))
            return FALSE;
    }

    // Otherwise, reset the length to whatever is allocated.
    else
        pbuf->SyncSize();

    // Loop until we have a buffer large enough.
    while (TRUE)
    {
        // Buffer size can't be 0, because LCMapString will interpret
        // this by returning "required buffer length" and not actually
        // converting the string.
        MD_ASSERT(pbuf->QuerySize() > 0);
        cchRet = LCMapStringW(LOCALE_SYSTEM_DEFAULT,
                             LCMAP_UPPERCASE,
                             (LPWSTR) pstr,
                             (cch < 0) ? cch : cch/2,
                             (LPWSTR) pbuf->QueryPtr(),
                             pbuf->QuerySize()/2);

        // Handle errors
        if (cchRet == 0)
        {
            // If error wasn't lack of buffer, fail.
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                return FALSE;

            // Otherwise, make the buffer larger and try again.
            /* else */
                if (!pbuf->Resize(pbuf->QuerySize() + 50))
                    return FALSE;
        }
        else
            break;
    }

    // If last character is a null-terminator, remove it in the key.
    if (*((LPWSTR) pbuf->QueryPtr() + cchRet - 1) == (WCHAR) '\0')
        cchRet--;

    // Resize the buffer to the final length.  Length includes null-terminator.
    pbuf->Resize(cchRet*2);
    return TRUE;
}



CMDBaseData *
CMDBaseObject::GetDataObjectByType(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    Identifier  - The identifier of the data to get.

    ListHead    - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    for (pdcIndex=m_pdcarrayDataHead[dwDataType];pdcIndex!=NULL;pdcIndex=pdcIndex->NextPtr) {
        if (dwIdentifier == pdcIndex->pbdDataObject->GetIdentifier()) {
            break;
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwAttributes,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) &&
        (dwAttributes & METADATA_INHERIT) &&
        (GetParent()!=NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetInheritableDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }

    if ((pbdReturn != NULL) &&
        ((pbdReturn->GetAttributes() & METADATA_INHERIT) == 0)) {
        pbdReturn = NULL;
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) && (GetParent() != NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *dataReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL) && dwEnumDataIndex != 0;
            pdcIndex=pdcIndex->NextPtr, dwEnumDataIndex--) {
        }
    }
    else {
        for (pdcIndex=m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        dataReturn = pdcIndex->pbdDataObject;
    }
    return (dataReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObject(
         IN DWORD dwEnumDataIndex,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Enumerates a data object.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    PVOID *ppvMainDataBuf;
    DWORD dwNumBufferEntries;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, i);
        }
    }
    else {
        pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, dwDataType);
    }

    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }

    if ((pbdReturn == NULL) && (dwAttributes & METADATA_INHERIT) && (GetParent() != NULL)) {
        //
        // Not in current object and inherited data is specified.
        // Build list of data objects in current meta object,
        // and call parent for inherited data.
        //
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumBufferEntries = 0;
        CopyDataObjectsToBuffer(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, FALSE);
        pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                           dwUserType,
                                                           dwDataType,
                                                           ppvMainDataBuf,
                                                           dwNumBufferEntries,
                                                           ppboAssociated);
        FreeMainDataBuffer(ppvMainDataBuf);
    }

    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries)
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

    MainDataBuf   - The buffer filled with previously enumerated values.

    NumBufferEntries - The number of entries in MainDataBuf.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType() &&
                ((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         DWORD &dwEnumDataIndex,
         DWORD dwUserType,
         DWORD dwDataType,
         CMDBaseObject **ppboAssociated)
{
    PVOID *ppvMainDataBuf = GetMainDataBuffer();
    DWORD dwNumBufferEntries = 0;
    CMDBaseData *pbdReturn;

    MD_ASSERT(ppvMainDataBuf != NULL);
    pbdReturn = EnumInheritableDataObject(dwEnumDataIndex,
                                            dwUserType,
                                            dwDataType,
                                            ppvMainDataBuf,
                                            dwNumBufferEntries,
                                            ppboAssociated);
    FreeMainDataBuffer(ppvMainDataBuf);

    return(pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         IN OUT DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         CMDBaseObject **ppboAssociated)
{
   CMDBaseData *pbdReturn = NULL;
   DWORD i;

   if (dwDataType == ALL_METADATA) {
       for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
           pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                       dwUserType,
                                                       i,
                                                       ppvMainDataBuf,
                                                       dwNumBufferEntries);
       }
   }
   else {
       pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                   dwUserType,
                                                   dwDataType,
                                                   ppvMainDataBuf,
                                                   dwNumBufferEntries);
   }

   if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
       //
       // Found data in this object
       //
       *ppboAssociated = this;
   }
   if ((pbdReturn == NULL) && (GetParent() != NULL)) {
       //
       // Not in current object.
       // Call parent for inherited data.
       //
       pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                            dwUserType,
                                                            dwDataType,
                                                            ppvMainDataBuf,
                                                            dwNumBufferEntries,
                                                            ppboAssociated);
   }

   return (pbdReturn);
}

VOID
CMDBaseObject::CopyDataObjectsToBufferByType(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)
/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    ListHead      - The list of data objects.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/

{
    PDATA_CONTAINER pdcIndex;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if ((!bInheritableOnly) ||
                (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                    MD_ASSERT(FALSE);
                    break;
                }
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if ((!bInheritableOnly) ||
                    (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                    !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
            }
        }
    }
}

VOID
CMDBaseObject::CopyDataObjectsToBuffer(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)

/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    DataType      - Optional UserType of the data to copy.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/
{
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; i < INVALID_END_METADATA; i++) {
            CopyDataObjectsToBufferByType(dwUserType, i, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
        }
    }
    else {
        CopyDataObjectsToBufferByType(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
    }
}

DWORD
CMDBaseObject::GetAllDataObjects(
         OUT PVOID *ppvMainDataBuf,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN BOOL bInheritableOnly
         )
/*++

Routine Description:

    Gets all data objects which match the criteria specified by the parameters.

Arguments:

    MainDataBuf   - The buffer to store the data objects in.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

    bInheritableOnly - If TRUE, only gets data objects that are
                       inheritable and not already in the buffer.

Return Value:

    DWORD         - Number of Data Objects in Buffer.

--*/
{
    DWORD dwNumBufferEntries;
    CMDBaseObject *objIndex;

    //
    // Not in current object and inherited data is specified.
    // Build list of data objects in current meta object,
    // and call parent for inherited data.
    //
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumBufferEntries = 0;
    CopyDataObjectsToBuffer(dwUserType,
                            dwDataType,
                            ppvMainDataBuf,
                            dwNumBufferEntries,
                            bInheritableOnly);
    if (dwAttributes & METADATA_INHERIT) {
        for (objIndex = GetParent(); objIndex != NULL; objIndex = objIndex->GetParent()) {
            objIndex->CopyDataObjectsToBuffer(dwUserType,
                                              dwDataType,
                                              ppvMainDataBuf,
                                              dwNumBufferEntries,
                                              TRUE);
        }
    }
    return (dwNumBufferEntries);
}

HRESULT
CMDBaseObject::GetDataRecursive(
         IN OUT BUFFER *pbufMainDataBuf,
         IN DWORD dwMDIdentifier,
         IN DWORD dwMDDataType,
         IN OUT DWORD &rdwNumMetaObjects)
{
    CMDBaseObject *pboChild;
    DWORD i;
    MD_ASSERT (pbufMainDataBuf != NULL);
    HRESULT hresReturn = ERROR_SUCCESS;


    if (GetDataObject(dwMDIdentifier,
                      METADATA_NO_ATTRIBUTES,
                      dwMDDataType,
                      NULL) != NULL) {
        DWORD dwSize = sizeof(CMDBaseObject *) * (rdwNumMetaObjects + 1);
        if (pbufMainDataBuf->QuerySize() < dwSize) {
            if (!pbufMainDataBuf->Resize(dwSize + (sizeof(CMDBaseObject *) * 1000))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            ((CMDBaseObject **)(pbufMainDataBuf->QueryPtr()))[rdwNumMetaObjects++] = (CMDBaseObject *)this;
        }
    }

    for (i = 0;
         SUCCEEDED(hresReturn) &&
             (pboChild = EnumChildObject(i)) != NULL;
         i++) {
        hresReturn = pboChild->GetDataRecursive(pbufMainDataBuf,
                                                dwMDIdentifier,
                                                dwMDDataType,
                                                rdwNumMetaObjects);
    }

    return hresReturn;
}

VOID
CMDBaseObject::SetLastChangeTime(PFILETIME pftLastChangeTime)
{
    if (pftLastChangeTime != NULL) {
        m_ftLastChangeTime = *pftLastChangeTime;
    }
    else {
        GetSystemTimeAsFileTime(&m_ftLastChangeTime);
    }
}

PFILETIME
CMDBaseObject::GetLastChangeTime()
{
    return &m_ftLastChangeTime;
}

DWORD
CMDBaseObject::GetObjectLevel()
{
    DWORD dwLevel = 0;

    if (m_pboParent != NULL) {
        dwLevel = m_pboParent->GetObjectLevel() + 1;
    }

    return dwLevel;
}

BOOL
CMDBaseObject::IsDataInBuffer(
         IN DWORD dwIdentifier,
         IN PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Checks if the buffer contains an object with the specified id.

Arguments:

    Identifier    - The id to check for.

    MainDataBuf   - The buffer to search.

Return Value:

    BOOL          - TRUE if the buffer contains data with the specified id.

--*/
{
    BOOL bReturn = FALSE;
    DWORD i;
    CMDBaseData *pbdDataObject;
    for (i = 0;
        (pbdDataObject = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i)) != NULL;
        i++) {
        if (pbdDataObject->GetIdentifier() == dwIdentifier) {
            bReturn = TRUE;
            break;
        }
    }
    return (bReturn);
}

#if 0   // No longer used.  /SAB

BOOL
CMDBaseObject::CompareDelimitedString(
         IN LPTSTR strNonDelimitedString,
         IN OUT LPTSTR &strDelimitedString,
         IN BOOL bUnicode)
/*++

Routine Description:

    Compared a nondelimeted string to a delimeted string.
    Updates Delimited String on success to point past the string.

Arguments:

    NonDelimiterString - The nondelimited string.

    DelimiterString - The delimited string.

Return Value:

    BOOL          - TRUE if strings are the same.

--*/
{
    LPTSTR i,j;
    BOOL RetCode = FALSE;
    j = strDelimitedString;
    DWORD dwStringLen;

/*

    //
    // Change in semantics. To differentiate between "/" and "//",
    // the leading delimeter is skipped before we get here.
    //
    // Skip leading delimeter, if any
    //
    if ((*j == MD_PATH_DELIMETER) || (*j == MD_ALT_PATH_DELIMETER)) {
        j++;
    }
*/

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (_wcsnicmp((LPWSTR)strDelimitedString, (LPWSTR)strNonDelimitedString, dwStringLen) == 0) {
            if (((*((LPWSTR)strDelimitedString + dwStringLen)==MD_ALT_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)==MD_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)== (WCHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStringLen * sizeof(WCHAR);    //Point to next section or \0
            }
        }
    }
    else {
        dwStringLen = MD_STRLEN(strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (MD_STRNICMP(strDelimitedString, strNonDelimitedString, dwStringLen) == 0) {
            DWORD dwStrBytes = MD_STRBYTES(strNonDelimitedString);
            if (((*(strDelimitedString + dwStrBytes)==MD_ALT_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)==MD_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)== (CHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStrBytes;    //Point to next section or \0
            }
        }
    }
    return (RetCode);
}

#endif


CMDBaseObject*
CMDBaseObject::FindChild(
LPSTR                   szName,     // Name of child to find.
int                     cchName,    // Length of the name.
BOOL                    fUnicode,   // TRUE if unicode name.
HRESULT*                phresult,   // Result code.
BOOL                    fUseHash,   // Allow use of hash table
BASEOBJECT_CONTAINER**  ppbocPrev)  // If non-NULL & !fUseHash, prev. object container in list.
{
    UCHAR                   localBufferForBufKey[SIZE_FOR_ON_STACK_BUFFER];
    CMDKeyBuffer            bufKey (localBufferForBufKey,SIZE_FOR_ON_STACK_BUFFER);
    BASEOBJECT_CONTAINER*   pbocCurrent = NULL;

    MD_ASSERT(phresult != NULL);

    // Convert the given string to a key.
    if (!GenerateBufFromStr(szName, cchName, fUnicode, &bufKey))
        {
        *phresult = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
        }

    // Use hash table if it exists and we are allowed to.
    if (fUseHash && m_phtChildren != NULL)
    {
        m_phtChildren->FindKey(&bufKey, &pbocCurrent);
    }

    // Otherwise use brute force linear search.
    else
    {
        BASEOBJECT_CONTAINER* pbocPrev = NULL;

        pbocCurrent = m_pbocChildHead;
        while (pbocCurrent != NULL &&
               !FCompareKeys(&bufKey, &pbocCurrent->pboMetaObject->m_bufKey))
        {
            pbocPrev = pbocCurrent;
            pbocCurrent = pbocCurrent->NextPtr;
        }

        if (ppbocPrev != NULL)
            *ppbocPrev = pbocPrev;
    }

    *phresult = ERROR_SUCCESS;

    if (pbocCurrent != NULL)
        return pbocCurrent->pboMetaObject;
    /* else */
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\interfac\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME2  = mddefw
INCS            = -I. -I$(SDK_INC_PATH)
HEADER_FILE2    = $(PROJECT_ROOT)\iis\inc\$(O)\$(IDL_FILE_NAME2).h
TARGETS         = $(HEADER_FILE) $(HEADER_FILE2) $(HEADER_FILE3)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#

$(PROJECT_ROOT)\iis\inc\$(O)\mdmsg.h ..\inc\$(O)\mdmsg.rc ..\inc\$(O)\msg00001.bin: mdmsg.mc
    -mkdir $(PROJECT_ROOT)\iis\inc\$(O)
    -mkdir ..\inc\$(O)
    mc -o -h $(PROJECT_ROOT)\iis\inc\$(O) -r ..\inc\$(O) -v mdmsg.mc


!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

#
#  MIDL Compile stuff
#

$(HEADER_FILE2): .\$(IDL_FILE_NAME2).idl
    midl -no_stamp -Oi -error allocation -error ref -h $(HEADER_FILE2) $(INCS) .\$(IDL_FILE_NAME2).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\inc\writerglobalhelper.h ===
#ifndef _WRITER_GLOBAL_HELPER_H_
#define _WRITER_GLOBAL_HELPER_H_

enum eESCAPE{
	eNoESCAPE=0,
	eESCAPEgt,
	eESCAPElt,
	eESCAPEquote,
	eESCAPEamp,
	eESCAPEashex,
	eESCAPEillegalxml
};

class CWriterGlobalHelper
{
	public:

		CWriterGlobalHelper();
		~CWriterGlobalHelper();
		HRESULT InitializeGlobals(BOOL i_bFailIfBinFileAbsent);//LPCWSTR	i_wszBinFileForMeta);

	private:
		
		HRESULT GetInternalTableName(ISimpleTableDispenser2*  i_pISTDisp,
								     LPCWSTR                  i_wszTableName,
									 LPWSTR*                  o_wszInternalTableName);

	public:

		HRESULT ToString(PBYTE   pbData,
						 DWORD   cbData,
						 DWORD   dwIdentifier,
						 DWORD   dwDataType,
						 DWORD   dwAttributes,
						 LPWSTR* pwszData);

		HRESULT FlagToString(DWORD      dwValue,
					         LPWSTR*    pwszData,
						     LPWSTR     wszTable,
						     ULONG      iColFlag);

		HRESULT EnumToString(DWORD      dwValue,
				             LPWSTR*    pwszData,
					         LPWSTR     wszTable,
					         ULONG      iColEnum);

		HRESULT EscapeString(LPCWSTR wszString,
			                 ULONG   cchString,
                             BOOL*   pbEscaped,
							 LPWSTR* pwszEscapedString,
						     ULONG*  pcchEscaped);

		HRESULT GetUserType(DWORD   i_dwUserType,
                            LPWSTR* o_pwszUserType,
						    ULONG*  o_cchUserType,
						    BOOL*   o_bAllocedUserType);

		HRESULT GetPropertyName(ULONG      i_dwPropertyID,
								LPWSTR*    o_wszName,
								BOOL*      o_bAlloced);

	private:

		HRESULT BoolToString(DWORD      dwValue,
			                 LPWSTR*    pwszData);


		HRESULT GetStartRowIndex(LPWSTR    wszTable,
                                 ULONG     iColFlag,
							     ULONG*    piStartRow);

		inline int  StringInsensitiveCompare(LPCWSTR wsz1, LPCWSTR wsz2) const {if(wsz1 == wsz2) return 0; else return _wcsicmp(wsz1, wsz2);}

		eESCAPE GetEscapeType(WCHAR i_wChar);

		HRESULT CreateUnknownName(DWORD    dwID,
						          LPWSTR*	pwszUnknownName);


	public:
		
		ISimpleTableRead2*	m_pISTTagMetaByTableAndColumnIndexAndName;
		ISimpleTableRead2*	m_pISTTagMetaByTableAndColumnIndexAndValue;
		ISimpleTableRead2*	m_pISTTagMetaByTableAndColumnIndex;
		ISimpleTableRead2*  m_pISTTagMetaByTableAndID;
		ISimpleTableRead2*  m_pISTTagMetaByTableAndName;
		ISimpleTableRead2*	m_pISTColumnMeta;
		ISimpleTableRead2*	m_pISTColumnMetaByTableAndID;
		ISimpleTableRead2*  m_pISTColumnMetaByTableAndName;
		ISimpleTableRead2*	m_pISTTableMetaForMetabaseTables;
		ULONG	            m_cColKeyTypeMetaData;
		LPVOID				m_apvKeyTypeMetaData[cCOLUMNMETA_NumberOfColumns];
		LPWSTR              m_wszTABLE_MBProperty;
		LPWSTR              m_wszTABLE_IIsConfigObject;
		int					m_iStartRowForAttributes;  
		LPWSTR              m_wszBinFileForMeta;
		ULONG               m_cchBinFileForMeta;
		LPWSTR              m_wszIIS_MD_UT_SERVER;
		ULONG	            m_cchIIS_MD_UT_SERVER;
		LPWSTR              m_wszIIS_MD_UT_FILE;
		ULONG	            m_cchIIS_MD_UT_FILE;
		LPWSTR              m_wszIIS_MD_UT_WAM;
		ULONG	            m_cchIIS_MD_UT_WAM;
		LPWSTR              m_wszASP_MD_UT_APP;
		ULONG	            m_cchASP_MD_UT_APP;

}; // CWriterGlobalHelper

#endif _WRITER_GLOBAL_HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\dcomperm.cpp ===
#include "main.h"

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    DWORD returnValue=ERROR_SUCCESS;
//    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    Principal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));
    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal); 
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
    }

    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
		if (FAILED(err))
		{
		}
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
    }
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
		if (FAILED(err))
		{
		}
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
    }
      return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\comobj.cxx ===
#define INITGUID
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <issched.hxx>
#include <mbs.hxx>
#include <ptrmap.hxx>



CIdToPointerMapper  *g_PointerMapper = NULL;


CMDCOM::CMDCOM():
    m_ImpIConnectionPointContainer(),
    m_hresConstructorError(ERROR_SUCCESS)
{
    UINT i;
    HRESULT hRes;

    m_dwRefCount = 0;
    g_hReadSaveSemaphore = NULL;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    fFlusherInitialized = FALSE;
    dwMBFlushCookie = 0;
    msMBFlushTime = INETA_MB_FLUSH_DEFAULT;
    INITIALIZE_CRITICAL_SECTION( &csFlushLock );


    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
      m_aConnectionPoints[i] = NULL;

    HRESULT hr = NOERROR;

    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE(
                               "g_hReadSaveSemaphore",
                               &g_hReadSaveSemaphore,
                               1,
                               1
                               );

    if( g_hReadSaveSemaphore == NULL ) {
        hr = GetLastHResult();
        IIS_PRINTF((buff,"CreateSemaphore Failed with %x\n",hr));
    }
    else {

        COConnectionPoint* pCOConnPt;

        m_ImpIConnectionPointContainer.Init(this);
        // Rig this COPaper COM object to be connectable. Assign the connection
        // point array. This object's connection points are determined at
        // compile time--it currently has 2 connection points, one for ANSI,
        // one for UNICODE. Create a connection
        // point object for these and assign them into the array. This array could
        // easily grow to support additional connection points in the future.

        // First try creating a new connection point object. Pass 'this' as the
        // pHostObj pointer used by the connection point to pass its AddRef and
        // Release calls back to the host connectable object.
        pCOConnPt = new COConnectionPoint(this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_A);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A]);
            MD_ASSERT(SUCCEEDED(hr));
        }
        pCOConnPt = new COConnectionPoint(this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_W);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W]);
            MD_ASSERT(SUCCEEDED(hr));
        }
    }
    m_hresConstructorError = hr;
}

CMDCOM::~CMDCOM()
{
//    SetEvent(hevtDone);
    UINT i;
    IConnectionPoint* pIConnectionPoint;
    // Do final release of the connection point objects.
    // If this isn't the final release, then the client has an outstanding
    // unbalanced reference to a connection point and a memory leak may
    // likely result because the host COPaper object is now going away yet
    // a connection point for this host object will not end up deleting
    // itself (and its connections array).
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
    {
      pIConnectionPoint = m_aConnectionPoints[i];
      RELEASE_INTERFACE(pIConnectionPoint);
    }

    if (g_hReadSaveSemaphore != NULL) {
        CloseHandle(g_hReadSaveSemaphore);
    }
   DeleteCriticalSection( &csFlushLock );
   MD_ASSERT(g_PointerMapper);
   delete g_PointerMapper;

}

HRESULT
CMDCOM::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOM) {
        *ppObject = (IMDCOM *) this;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
      *ppObject = &m_ImpIConnectionPointContainer;
      AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG
CMDCOM::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOM::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT
CMDCOM::ComMDInitialize()
/*++

Routine Description:

    Initializes the metadata database. This must be called before any other API.
    Reads in the existing database, if found. If errors occur reading in the
    existing database, warnings are returned and the metabase is initialized
    with not data.

Arguments:

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            ERROR_ALREADY_INITIALIZED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_INVALID_DATA
            MD_WARNING_PATH_NOT_FOUND
            MD_WARNING_DUP_NAME
            MD_WARNING_INVALID_DATA

Notes:
    This could take a long time to process, as it may load in a large amount of data.
    If a warning code is returned, the database has been successfully initialized, but
    some data in the database was not loaded successfully.

--*/
{
    InitializeFlusher ();
    return InitWorker(FALSE);
}

HRESULT
CMDCOM::ComMDTerminate(IN BOOL bSaveData)
/*++

Routine Description:

    DeInitailizes the metadata database. This must be before the application terminates
    or dunloads the dll.

Arguments:

    SaveData      - If TRUE, the metadata is saved before terminating.
                    If the save fails, the metadata is not terminated.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_NOT_ENOUGH_MEMORY
              Errors from the file system.

Notes:
    This could take a long time to process, as it may save a large amount of data.

--*/
{

    return TerminateWorker1(FALSE);
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDShutdown( void)
{
    HRESULT hresReturn;
    BOOL bSaveData;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    TerminateFlusher ();
    SendShutdownNotifications();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    // IISADMIN and factory both have refences we do not wait for.
    //

    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 3) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {

        //
        // Need to hold a read lock here to make sure
        // Terminate doesn't occur during SaveAllData.
        //
        // Cannot hold a write lock, as SaveAllData gets
        // a read lock after getting ReadSaveSemaphore
        //

        g_rMasterResource->Lock(TSRES_LOCK_READ);

        if (g_dwInitialized > 0) {
            hresReturn = SaveAllData(TRUE, &CryptoStorage, pSessionKeyBlob);
        }
        else {
            if (g_dwInitialized > 0) {
                MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
                g_bSaveDisallowed = TRUE;
                MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
            }
            else {
                g_bSaveDisallowed = TRUE;
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               pszMDPath,
                               FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               (PBYTE) pszMDPath,
                               TRUE);
}

HRESULT
CMDCOM::ComMDAddMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Creates a meta object and adds it to the list of child objects for the object specified by Path.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path  - Path of the object to be added, relative to the path of Handle.
            Must not be NULL.
            eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME
            ERROR_INVALID_NAME

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        WCHAR strPath[METADATA_MAX_NAME_LEN];
        LPSTR pszTempPath = (LPSTR)pszMDPath;

        //
        // ExtractNameFromPath assumes no preceding delimeter
        //

        if (pszTempPath != NULL) {
            SkipPathDelimeter(pszTempPath, bUnicode);
        }

        //
        // Make sure at least one new object was specified
        //

        hresReturn = ExtractNameFromPath(pszTempPath,
                                         (LPSTR)strPath,
                                         bUnicode);

        if (FAILED(hresReturn)) {
            hresReturn = E_INVALIDARG;
        }
        else {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            hresReturn = AddObjectToDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  TRUE);
}

HRESULT
CMDCOM::ComMDDeleteMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a meta object and all of its data. Recursively deletes all descendants.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of object to be deleted, relative to the path of Handle.
           Must not be NULL.
           eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDPath == NULL) {
       hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = RemoveObjectFromDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        pszMDPath,
                                        FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        (PBYTE)pszMDPath,
                                        TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data. Recursively deletes all descendants of the child objects.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of the parent of the objects to be deleted, relative to the path of Handle.
           eg. "Root Object/Child"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    CMDBaseObject *pboParent;
    CMDBaseObject *pboChild;
    CMDHandle *phoHandle;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboParent, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            phoHandle = GetHandleObject(hMDHandle);
            MD_ASSERT (phoHandle != NULL);
            while ((pboChild = pboParent->EnumChildObject(0)) != NULL) {
                MD_REQUIRE(pboParent->RemoveChildObject(pboChild) == ERROR_SUCCESS);
                if (phoHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                    delete(pboChild);
                }
            }
            g_dwSystemChangeNumber++;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 pszMDPath,
                                 pszMDName,
                                 dwMDEnumObjectIndex,
                                 FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 (PBYTE)pszMDPath,
                                 (PBYTE)pszMDName,
                                 dwMDEnumObjectIndex,
                                 TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
        /* [in] */ DWORD dwMDEnumObjectIndex,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all child metaobjects once per call. Child Objects are numbers from 0 to NumObjects - 1, where
    NumObjects is the number of current child objects. If EnumObjectIndex is >= NumObjects, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path - Path of parent object, relative to the path of Handle.
           eg. "Root Object/Child/GrandChild"
    Name - Buffer where the Name of the object is returned. Must be at least METADATA_MAX_NAME_LEN characters long.

    EnumObjectIndex - Index of the value to be retrieved. The caller is expected to set this to 0 before the first call and increment
           it by 1 on each successive call until ERROR_NO_MORE_ITEMS is returned.
Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_PATH_NOT_FOUND
            ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDName == NULL) {
        hresReturn = ERROR_INVALID_PARAMETER;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected, *pboChild;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboChild = pboAffected->EnumChildObject(dwMDEnumObjectIndex);
            if (pboChild != NULL) {
                PVOID pvName = (PVOID)pboChild->GetName(bUnicode);
                if (pvName == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (bUnicode) {
                        wcscpy((LPWSTR)pszMDName, (LPWSTR)pvName);
                    }
                    else {
                        MD_STRCPY((LPSTR)pszMDName, (LPSTR)pvName);
                    }
                }
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                pszMDSourcePath,
                                hMDDestHandle,
                                pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                (PBYTE)pszMDSourcePath,
                                hMDDestHandle,
                                (PBYTE)pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    CMDHandle *phoDestHandle, *phoSourceHandle;
    CMDBaseObject *pboSource, *pboDest, *pboExisting, *pboIndex, *pboNew, *pboDestParent;
    LPSTR pszTempPath;
    LPSTR pszRemainingDestPath;
    BOOL bChanged = FALSE;
    WCHAR strName[METADATA_MAX_NAME_LEN];

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {

        //
        // check if pszDestPath is a valid parameter (non-NULL)
        //

        if (pszDestPath == NULL) {
            hresReturn = E_INVALIDARG;
        }
        else {

            //
            // Must have access to Dest parent to add it.
            // Make sure that a valid path was specified, ie. handle
            // points to ancestor.
            //
            pszTempPath = pszDestPath;
            SkipPathDelimeter(pszTempPath, bUnicode);
            hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
            if (FAILED(hresReturn)) {
                hresReturn = E_INVALIDARG;
            }
            if (!bMDCopyFlag) {
                //
                // Must have access to source parent to remove it.
                // Make sure that a valid path was specified, ie. handle
                // points to ancestor.
                //
                pszTempPath = pszSourcePath;
                SkipPathDelimeter(pszTempPath, bUnicode);
                hresReturn = ExtractNameFromPath(pszTempPath, (LPSTR)strName, bUnicode);
                if (FAILED(hresReturn)) {
                    hresReturn = E_INVALIDARG;
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboSource, hMDSourceHandle,
                                    (bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE,
                                     (LPSTR)pszSourcePath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            //
            // GetObjectFromPath updates path, need both original and remainder
            //
            pszRemainingDestPath = pszDestPath;
            hresReturn = GetObjectFromPath(pboDest, hMDDestHandle, METADATA_PERMISSION_WRITE,
                                        (LPSTR)pszRemainingDestPath, bUnicode);
            if ((SUCCEEDED(hresReturn)) ||
                ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL))) {
                //
                // Make sure dest is not descendant of source
                //
                for (pboIndex = pboDest; pboIndex != NULL; pboIndex = pboIndex->GetParent()) {
                    if (pboIndex == pboSource) {
                        hresReturn = E_INVALIDARG;
                        break;
                    }
                }
            }

            phoDestHandle = GetHandleObject(hMDDestHandle);
            if (SUCCEEDED(hresReturn)) {
                //
                // Object already exists
                //
                if (pboDest == pboSource) {
                    //
                    // Copy to self
                    //
                }
                else {
                    MD_ASSERT (phoDestHandle != NULL);
                    if (bMDOverwriteFlag) {
                        if (pboDest->GetName(bUnicode) == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                        else {
                            pboDestParent = pboDest->GetParent();
                            hresReturn = MakeTreeCopy(pboSource, pboNew, pboDest->GetName(bUnicode), bUnicode);
                            if (SUCCEEDED(hresReturn)) {
                                MD_REQUIRE(SUCCEEDED(pboDestParent->RemoveChildObject(pboDest->GetName(bUnicode), bUnicode)));
                                hresReturn = pboDestParent->InsertChildObject(pboNew);
                                if (SUCCEEDED(hresReturn)) {
                                    g_dwSystemChangeNumber++;
                                    if (phoDestHandle->SetChangeData(
                                        pboDest, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                                        delete(pboDest);
                                    }
                                    AddNewChangeData(phoDestHandle, pboNew);
                                }
                                else {
                                    delete (pboNew);
                                    pboDestParent->InsertChildObject(pboDest);
                                }
                            }
                        }
                    }
                    else {
                        //
                        // Object exists at destination and not overwrite.
                        // Add in missing objects and data.
                        //
                        hresReturn = CopyTree(phoDestHandle, pboDest, pboSource, bChanged);
                        if (bChanged) {
                            g_dwSystemChangeNumber++;
                        }
                    }
                }
            }
            else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboDest != NULL)) {

                //
                // Full destination path doesn't exist, so create it
                //

                hresReturn = MakeTreeCopyWithPath(pboSource,
                                               pboNew,
                                               pszRemainingDestPath,
                                               bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    MD_ASSERT(pboDest != NULL);
                    hresReturn = pboDest->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        g_dwSystemChangeNumber++;
                        AddNewChangeData(phoDestHandle, pboNew);
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }

            if ((SUCCEEDED(hresReturn)) && (!bMDCopyFlag)) {
                MD_REQUIRE(SUCCEEDED(pboSource->GetParent()->RemoveChildObject(pboSource)));
                phoSourceHandle = GetHandleObject(hMDSourceHandle);
                MD_ASSERT (phoSourceHandle != NULL);
                if (phoSourceHandle->SetChangeData(pboSource, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboSource);
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  pszMDNewName,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  (PBYTE)pszMDNewName,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName,
        IN BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((LPSTR)pszMDNewName == NULL) ||

        //
        // ExtractNameFromPath, below, checks name length so don't need to
        // check that here.
        //

        (bUnicode &&
            ((wcschr((LPWSTR)pszMDNewName, MD_PATH_DELIMETERW) != NULL) ||
             (wcschr((LPWSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL))) ||
        (!bUnicode &&
            ((MD_STRCHR((LPSTR)pszMDNewName, MD_PATH_DELIMETERA) != NULL) ||
             (MD_STRCHR((LPSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL)))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        WCHAR strName[METADATA_MAX_NAME_LEN];
        LPSTR pszNewName = (LPSTR)pszMDNewName;
        LPSTR pszTempName = pszNewName;

        hresReturn = ExtractNameFromPath(pszTempName, (LPSTR)strName, bUnicode);

        if (SUCCEEDED(hresReturn)) {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            CMDBaseObject *pboAffected, *pboParent;
            hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                pboParent = pboAffected->GetParent();
                if ( pboParent == NULL) {
                    //
                    // Can't rename MasterRoot
                    //
                    hresReturn = E_INVALIDARG;

                }
                else {
                    if (pboAffected->GetParent()->GetChildObject(pszNewName, &hresReturn, bUnicode) != NULL) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
                    }
                    if (SUCCEEDED(hresReturn)) {

                        BUFFER OriginalKeyName;
                        DWORD  dwStringLen = 0;

                        hresReturn= GetObjectPath(pboAffected,
                                                 &OriginalKeyName,
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 bUnicode);

                        if (SUCCEEDED(hresReturn)) {
                            //
                            // First Remove the object, to get it out of the hash table.
                            //

                            pboParent->RemoveChildObjectFromHash( pboAffected );

                            //
                            // Must use pszMDNewName, as this does not include delimeters
                            //

                            if (!pboAffected->SetName((LPSTR)pszMDNewName, bUnicode)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

                                //
                                // Attempt to reinsert the object
                                // Preserve previous error code by ignoreing this one.
                                //

                                pboParent->AddChildObjectToHash(pboAffected);
                            }
                            else {

                                //
                                // Reinsert the object with the new name.
                                //

                                hresReturn = pboParent->AddChildObjectToHash( pboAffected );

                                g_dwSystemChangeNumber++;
                                MD_ASSERT(GetHandleObject(hMDHandle) != NULL);
                                GetHandleObject(hMDHandle)->SetChangeData(pboAffected, MD_CHANGE_TYPE_RENAME_OBJECT, 0,
                                                                          (LPWSTR)OriginalKeyName.QueryPtr ());
                            }
                        }


                    }

                }
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PMETADATA_RECORD pmdrMDData,
        IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist, it creates and
    inserts a data object into the list of data objects of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data to set. See IMD.H.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.
    Duplicate data names are not allowed, even for different types.
--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (!ValidateData(pmdrMDData, bUnicode)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *AffectedObject;
        hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            pszPath = (LPSTR)pszMDPath;
            MD_ASSERT(pszMDPath != NULL);
            hresReturn = AddObjectToDataBase(hMDHandle, (LPSTR)pszMDPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;
                hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }

        if (SUCCEEDED(hresReturn)) {
            hresReturn = AffectedObject->SetDataObject(pmdrMDData, bUnicode);
        }
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;
            MD_ASSERT(GetHandleObject(hMDHandle) != NULL);
            GetHandleObject(hMDHandle)->SetChangeData(AffectedObject, MD_CHANGE_TYPE_SET_DATA, pmdrMDData->dwMDIdentifier);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets one metadata value.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_ACCESS_DENIED
              ERROR_PATH_NOT_FOUND
              MD_ERROR_DATA_NOT_FOUND
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by
    ComMDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            //
            // Found the object, get the data.
            //
            pbdRetrieve = pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                     pmdrMDData->dwMDAttributes,
                                                     pmdrMDData->dwMDDataType,
                                                     &pboAssociated);
        }
        else if ((hresReturn == (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            //
            // Object not found, get inheritable data.
            //
            pbdRetrieve = pboAffected->GetInheritableDataObject(pmdrMDData->dwMDIdentifier,
                                                                pmdrMDData->dwMDDataType,
                                                                &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE) pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDEnumMetaDataD(hMDHandle,
                              (PBYTE)pszMDPath,
                              pmdrMDData,
                              dwMDEnumDataIndex,
                              pdwMDRequiredDataLen,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [in] */ DWORD dwMDEnumDataIndex,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all metadata values once per call. Values are numbered from 0 to NumValues - 1, where
    NumValues is the number of current valules. If EnumDataIndex is >= NumValues, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, , relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_INVALID_PARAMETER
                 ERROR_PATH_NOT_FOUND
                 ERROR_ACCESS_DENIED
                 ERROR_INSUFFICIENT_BUFFER
                 ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pbdRetrieve = pboAffected->EnumDataObject(dwMDEnumDataIndex,
                                                      pmdrMDData->dwMDAttributes,
                                                      pmdrMDData->dwMDUserType,
                                                      pmdrMDData->dwMDDataType,
                                                      &pboAssociated);
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            pbdRetrieve = pboAffected->EnumInheritableDataObject(dwMDEnumDataIndex,
                                                                 pmdrMDData->dwMDUserType,
                                                                 pmdrMDData->dwMDDataType,
                                                                 &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
                        METADATA_REFERENCE) != 0) {
                        MD_ASSERT(((pbdRetrieve->GetAttributes()) & METADATA_INSERT_PATH) == 0);
                        pmdrMDData->pbMDData = (PBYTE)pbdRetrieve->GetData(bUnicode);
                        pbdRetrieve->IncrementReferenceCount();
                        pmdrMDData->dwMDDataTag = pbdRetrieve->GetMappingId();
                    }
                    else {
                        BUFFER bufData;
                        STRAU strData;
                        if ((pmdrMDData->dwMDAttributes & pbdRetrieve->GetAttributes() & METADATA_INSERT_PATH) != 0) {

                            hresReturn= InsertPathIntoData(&bufData,
                                                           &strData,
                                                           &pbData,
                                                           &dwDataLen,
                                                           pbdRetrieve,
                                                           hMDHandle,
                                                           pboAssociated,
                                                           bUnicode);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            if (pmdrMDData->dwMDDataLen < dwDataLen) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                                pmdrMDData->dwMDDataLen = 0;
                                *pdwMDRequiredDataLen = dwDataLen;
                            }
                            else {
                                MD_COPY(pmdrMDData->pbMDData, pbData, dwDataLen);
                                pmdrMDData->dwMDDataTag = 0;
                            }
                        }
                    }
                }
                if (SUCCEEDED(hresReturn)) {
                    BOOL bIsInherited = FALSE;
                    if ((pmdrMDData->dwMDAttributes & METADATA_ISINHERITED) &&
                        (pmdrMDData->dwMDAttributes & METADATA_INHERIT)) {
                        //
                        // Set the ISINHERITED flag
                        //
                        if (bInheritableOnly) {
                            bIsInherited = TRUE;
                        }
                        else {
                            if (pboAffected->GetDataObject(pbdRetrieve->GetIdentifier(),
                                                           pmdrMDData->dwMDAttributes &
                                                               ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                           pbdRetrieve->GetDataType()) == NULL) {
                                bIsInherited = TRUE;
                            }
                        }
                    }
                    pmdrMDData->dwMDAttributes =
                        (pbdRetrieve->GetAttributes() | ((bIsInherited) ? METADATA_ISINHERITED : 0));
                    pmdrMDData->dwMDIdentifier = pbdRetrieve->GetIdentifier();
                    pmdrMDData->dwMDUserType = pbdRetrieve->GetUserType();
                    pmdrMDData->dwMDDataType = pbdRetrieve->GetDataType();
                    pmdrMDData->dwMDDataLen = dwDataLen;
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDIdentifier,
                                dwMDDataType,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDIdentifier,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a data object.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Identifier - The identifier of the data to remove.

    DataType   - Optional type of the data to remove. If specified, only data of that
                 type will be removed. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              MD_ERROR_DATA_NOT_FOUND

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
       g_rMasterResource->Lock(TSRES_LOCK_WRITE);
       CMDBaseObject *pboAffected;
       hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
       if (SUCCEEDED(hresReturn)) {
           if (pboAffected->RemoveDataObject(dwMDIdentifier, dwMDDataType, TRUE) != NULL) {
               hresReturn = ERROR_SUCCESS;
               g_dwSystemChangeNumber++;
               MD_ASSERT(GetHandleObject(hMDHandle) != NULL);
               GetHandleObject(hMDHandle)->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwMDIdentifier);
           }
           else {
               hresReturn = MD_ERROR_DATA_NOT_FOUND;
           }
       }
       g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetAllMetaDataD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                pdwMDNumDataEntries,
                                pdwMDDataSetNumber,
                                dwMDBufferSize,
                                pbBuffer,
                                pdwMDRequiredBufferSize,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        /* [in] */ DWORD dwMDBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all data associated with a Meta Object.

Arguments:

    Handle     - METADATA_MASTER_ROOT_HANDLE or a handle returned by ComMDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be returned. Se imd.h.

    DataType   - The Type of the data. If not set to ALL_METADATA only metadata
                 of the specified Data Type will be returned. See imd.h.

    NumDataEntries - On successful output, specifes the number of entries copied to Buffer.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if ERROR_SUCCESS or ERROR_INSUFFICIENT_BUFFER is returned. See ComMDGetDataSetNumber.

    BufferSize     - The size in bytes of buffer. If the return code is ERROR_INSUFFICIENT_BUFFER, this contains
                     the number of bytes needed.

    Buffer         - Buffer to store the data. On successful return it will
                     contain an array of METADATA_GETALL_RECORD.

    RequiredBufferSize - If ERROR_INSUFFICIENT_BUFFER is returned, This contains
        the required buffer length, in bytes.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use
    a handle returned by ComMDOpenMetaObject.

    DWORD data is aligned on non-Intel platforms. This may not hold true on remote clients.
--*/
{
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDataSetNumber();
            }
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboAffected != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            if (pdwMDDataSetNumber != NULL) {
                *pdwMDDataSetNumber = pboAffected->GetDescendantDataSetNumber();
            }
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              dwMDAttributes,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              bInheritableOnly);
            PBYTE pbEnd = pbBuffer + dwMDBufferSize;
            PBYTE pbDataStart = pbBuffer + (dwNumDataObjects * sizeof(METADATA_GETALL_RECORD));
            PBYTE pbNextDataStart = pbDataStart;

            for (i = 0;
                 (i < dwNumDataObjects) ;
                 i++, pbDataStart = pbNextDataStart) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                DWORD dwDataLen = pbdCurrent->GetDataLen(bUnicode);
                PBYTE pbData = (PBYTE)(pbdCurrent->GetData(bUnicode));
                CMDBaseObject *pboAssociated;
                BUFFER bufData;
                STRAU strData;
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                    METADATA_REFERENCE) == 0) {
                    if ((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) != 0) {
                        //
                        // First do a get to get the metaobject associated with this data object
                        //
                        if (bInheritableOnly) {
                            MD_REQUIRE(pboAffected->GetInheritableDataObject(pbdCurrent->GetIdentifier(),
                                                                               pbdCurrent->GetDataType(),
                                                                               &pboAssociated) != NULL);
                        }
                        else {
                            MD_REQUIRE(pboAffected->GetDataObject(pbdCurrent->GetIdentifier(),
                                                                  dwMDAttributes,
                                                                  pbdCurrent->GetDataType(),
                                                                  &pboAssociated) != NULL);
                        }

                        hresReturn= InsertPathIntoData(&bufData,
                                                       &strData,
                                                       &pbData,
                                                       &dwDataLen,
                                                       pbdCurrent,
                                                       hMDHandle,
                                                       pboAssociated,
                                                       bUnicode);
                    }
                    DWORD dwAlignAdjust = (pbdCurrent->GetDataType() == DWORD_METADATA) ?
                        MD_ALIGN_ADJUST(pbDataStart) : 0;
                    pbNextDataStart = (pbDataStart + dwDataLen + dwAlignAdjust);
                }
                if (SUCCEEDED(hresReturn)) {
                    if (pbEnd < pbNextDataStart) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                    }
                    else {
                        if ((dwMDAttributes & (pbdCurrent->GetAttributes()) &
                            METADATA_REFERENCE) == 0) {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].pbMDData = NULL;
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataOffset = DIFF(pbDataStart - pbBuffer);
                            MD_COPY(pbDataStart, pbData, dwDataLen);
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataTag = 0;
                        }
                        else {
                            MD_ASSERT((dwMDAttributes & pbdCurrent->GetAttributes() & METADATA_INSERT_PATH) == 0);
                            MD_ASSERT(pbdCurrent->GetData(bUnicode) != NULL);
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].pbMDData = (PBYTE)pbdCurrent->GetData(bUnicode);
                            pbdCurrent->IncrementReferenceCount();
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataTag = pbdCurrent->GetMappingId();
                        }
                        ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier = pbdCurrent->GetIdentifier();
                        ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes = pbdCurrent->GetAttributes();
                        ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDUserType = pbdCurrent->GetUserType();
                        ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataType = pbdCurrent->GetDataType();
                        ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDDataLen = dwDataLen;
                    }
                }
            }
            FreeMainDataBuffer(ppvMainDataBuf);
            if (SUCCEEDED(hresReturn)) {
                *pdwMDNumDataEntries = dwNumDataObjects;
                if ((dwNumDataObjects > 0) &&
                    (dwMDAttributes & METADATA_ISINHERITED) &&
                    (dwMDAttributes & METADATA_INHERIT)) {
                    //
                    // Set the ISINHERITED flag
                    //
                    if (bInheritableOnly) {
                        for (i = 0; i < dwNumDataObjects; i++) {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                        }
                    }
                    else {

                        ppvMainDataBuf = GetMainDataBuffer();

                        dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                                          dwMDAttributes & ~(METADATA_INHERIT | METADATA_PARTIAL_PATH),
                                                                          dwMDUserType,
                                                                          dwMDDataType,
                                                                          bInheritableOnly);

                        //
                        // Current implementation puts the local items first
                        // So just set the rest to inherited
                        //
                        // DBG loop asserts that the implementation has not changed.
                        //

                        #if DBG
                        for (i = 0; i < dwNumDataObjects ; i++) {
                            pbdCurrent = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                            MD_ASSERT(pbdCurrent != NULL);
                            MD_ASSERT(pbdCurrent->GetIdentifier() == ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDIdentifier);
                        }
                        #endif //DBG

                        for (i = dwNumDataObjects; i < *pdwMDNumDataEntries; i++) {
                            ((PMETADATA_GETALL_RECORD)pbBuffer)[i].dwMDAttributes |= METADATA_ISINHERITED;
                        }

                        FreeMainDataBuffer(ppvMainDataBuf);
                    }
                }
            }
            *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - pbBuffer);
            #ifndef _X86_
            //
            // Alignment fluff. Alignment could cause up to 3 bytes to be added to
            // the total needed if the buffer size ends in a different modulo 4
            // than the one passed in.
            //
            if (FAILED(hresReturn)) {
                *pdwMDRequiredBufferSize +=3;
            }
            #endif
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ComMDDeleteAllMetaDataD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   dwMDUserType,
                                   dwMDDataType,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteAllMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        IN BOOL bUnicode)
{
    HRESULT hresReturn;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDHandle *phoHandle;
    CMDBaseObject *pboAffected;
    DWORD dwCurrentDataID;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            MD_REQUIRE((phoHandle = GetHandleObject(hMDHandle)) != NULL);
            dwNumDataObjects = pboAffected->GetAllDataObjects(ppvMainDataBuf,
                                                              METADATA_NO_ATTRIBUTES,
                                                              dwMDUserType,
                                                              dwMDDataType,
                                                              FALSE);
            for (i = 0; i < dwNumDataObjects ; i++) {
                pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                MD_ASSERT(pbdCurrent != NULL);
                dwCurrentDataID = pbdCurrent->GetIdentifier();
                MD_REQUIRE(pboAffected->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_DELETE_DATA, dwCurrentDataID);
            }
            if (dwNumDataObjects > 0) {
                g_dwSystemChangeNumber++;
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              pszMDSourcePath,
                              hMDDestHandle,
                              pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaDataD(hMDSourceHandle,
                              (PBYTE)pszMDSourcePath,
                              hMDDestHandle,
                              (PBYTE)pszMDDestPath,
                              dwMDAttributes,
                              dwMDUserType,
                              dwMDDataType,
                              bMDCopyFlag,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaDataD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ DWORD dwMDAttributes,
        /* [in] */ DWORD dwMDUserType,
        /* [in] */ DWORD dwMDDataType,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination object.
    Optionally copies inherited data based on the value of Attributes.

Arguments:

    SrcHandle  - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    SrcPath    - The path of the meta object with which then source data is associated, relative to the
                 path of SrcHandle.

    DestHandle - A handle returned by MDOpenMetaObject with write permission.

    DestPath   - The path of the meta object for data to be copied to, relative to the path of Handle.

    Attributes - The flags for the data. See imd.h.

    UserType   - The User Type for the data. If not set to ALL_METADATA, only metadata of the specified
                 User Type will be copied. See imd.h.

    DataType   - Optional type of the data to copy. If not set to ALL_METADATA,
                 only data of that type will be copied.

    CopyFlag   - If true, data will be copied. If false, data will be moved.
                 Must be true if METADATA_INHERIT is set.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid source handle if CopyFlag == TRUE,
        but provides no gaurantee that other threads will not also change
        things. If a consistent data state is desired, use a handle returned by
        MDOpenMetaObject. METADATA_MASTER_ROOT_HANDLE is not a valid destination
        handle.

    If inherited data is copied, it will be copied to the destination object,
        not the corresponding ancestor objects.
--*/
{
    HRESULT hresReturn;
    BOOL bInheritableOnly;
    CMDBaseData *pbdCurrent;
    DWORD i, dwNumDataObjects;
    PVOID *ppvMainDataBuf;
    CMDBaseObject *pboSource, *pboDest;
    LPSTR pszSourcePath = (LPSTR)pszMDSourcePath;
    LPSTR pszDestPath = (LPSTR)pszMDDestPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        hresReturn = E_INVALIDARG;
    }
    else {
        //
        // Lock for source object. If copying, just get read lock. If moving,
        // Need write lock.
        //
        g_rMasterResource->Lock((bMDCopyFlag) ? TSRES_LOCK_READ : TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboSource,
                                       hMDSourceHandle,
                                       ((bMDCopyFlag) ? METADATA_PERMISSION_READ : METADATA_PERMISSION_WRITE),
                                       (LPSTR)pszSourcePath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bInheritableOnly = FALSE;
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) &&
                 (pboSource != NULL) &&
                 (dwMDAttributes & METADATA_PARTIAL_PATH)) {
            bInheritableOnly = TRUE;
            hresReturn = ERROR_SUCCESS;
        }
        if (SUCCEEDED(hresReturn)) {
            ppvMainDataBuf = GetMainDataBuffer();
            MD_ASSERT (ppvMainDataBuf != NULL);
            dwNumDataObjects = pboSource->GetAllDataObjects(ppvMainDataBuf,
                                                            dwMDAttributes,
                                                            dwMDUserType,
                                                            dwMDDataType,
                                                            bInheritableOnly);
            g_rMasterResource->Convert(TSRES_CONV_WRITE);
            hresReturn = GetObjectFromPath(pboDest,
                                           hMDDestHandle,
                                           METADATA_PERMISSION_WRITE,
                                           (LPSTR)pszDestPath,
                                           bUnicode);
            if (SUCCEEDED(hresReturn)) {
                for (i = 0; (i < dwNumDataObjects) && (SUCCEEDED(hresReturn)) ; i++) {
                    pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                    MD_ASSERT(pbdCurrent != NULL);
                    hresReturn = pboDest->SetDataObject(pbdCurrent);
                    if (SUCCEEDED(hresReturn)) {
                        MD_ASSERT(GetHandleObject(hMDDestHandle) != NULL);
                        GetHandleObject(hMDDestHandle)->SetChangeData(pboDest,
                                                                      MD_CHANGE_TYPE_SET_DATA,
                                                                      pbdCurrent->GetIdentifier());
                    }
                }
                if ((!bMDCopyFlag) && (SUCCEEDED(hresReturn))) {
                    for (i = 0; i < dwNumDataObjects; i++) {
                        pbdCurrent=(CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i);
                        MD_ASSERT(pbdCurrent != NULL);
                        MD_REQUIRE(pboSource->RemoveDataObject(pbdCurrent, TRUE) == ERROR_SUCCESS);
                        MD_ASSERT(GetHandleObject(hMDSourceHandle) != NULL);
                        GetHandleObject(hMDSourceHandle)->SetChangeData(pboSource,
                                                                        MD_CHANGE_TYPE_DELETE_DATA,
                                                                        pbdCurrent->GetIdentifier());
                    }
                }
                g_dwSystemChangeNumber++;
            }
            FreeMainDataBuffer(ppvMainDataBuf);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{

    return ComMDGetMetaDataPathsD(hMDHandle,
                                  pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ComMDGetMetaDataPathsD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  dwMDIdentifier,
                                  dwMDDataType,
                                  dwMDBufferSize,
                                  (PBYTE)pszMDBuffer,
                                  pdwMDRequiredBufferSize,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataPathsD(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    IN BOOL bUnicode)
{
    HRESULT hresReturn = S_OK;
    CMDBaseObject *pboAssociated;
    CMDBaseObject *pboHandle;
    LPSTR pszPath = (LPSTR)pszMDPath;
    DWORD i, dwNumMetaObjects;
    DWORD dwBytesPerChar = ((bUnicode) ? sizeof(WCHAR) : sizeof(char));

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDBufferSize != 0) && (pszMDBuffer == NULL)) ||
             (dwMDDataType >= INVALID_END_METADATA) ||
             (pdwMDRequiredBufferSize == NULL)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        hresReturn = GetObjectFromPath(pboAssociated, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            PBYTE pbDataStart = pszMDBuffer;
            PBYTE pbNextDataStart = pbDataStart;
            PBYTE pbDataEnd = pszMDBuffer + (dwMDBufferSize * dwBytesPerChar);
            CMDBaseObject *pboCurrent;
            BUFFER bufPath;
            BUFFER bufMainDataBuf;
            DWORD dwReturn;

            pboHandle = GetHandleObject(hMDHandle)->GetObject();
            MD_ASSERT(pboHandle != NULL);
            dwNumMetaObjects = 0;

            hresReturn = pboAssociated->GetDataRecursive(&bufMainDataBuf,
                                                         dwMDIdentifier,
                                                         dwMDDataType,
                                                         dwNumMetaObjects);

            if (SUCCEEDED(hresReturn)) {

                if (dwNumMetaObjects != 0) {


                    CMDBaseObject **ppboList = (CMDBaseObject **)bufMainDataBuf.QueryPtr();

                    for (i = 0;
                         (i < dwNumMetaObjects) &&
                             ( SUCCEEDED(hresReturn) ||
                               hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
                         i++, pbDataStart = pbNextDataStart) {
                        pboCurrent=ppboList[i];
                        MD_ASSERT(pboCurrent != NULL);
                        DWORD dwStringLen = 0;

                        dwReturn = GetObjectPath(pboCurrent,
                                                 &bufPath,
                                                 dwStringLen,
                                                 pboHandle,
                                                 bUnicode);
                        if (dwReturn != ERROR_SUCCESS) {
                            //
                            // Only blow away previous hresReturn if this failed.
                            //
                            hresReturn = RETURNCODETOHRESULT(dwReturn);
                        }
                        else {

                            //
                            // Need 2 extra characters for "/"
                            //

                            pbNextDataStart = pbDataStart + ((dwStringLen + 2) * dwBytesPerChar);
                            if (pbDataEnd < pbNextDataStart) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                            }
                            else {
                                MD_COPY(pbDataStart,
                                        bufPath.QueryPtr(),
                                        dwStringLen * dwBytesPerChar);
                                if (bUnicode) {
                                    *(((LPWSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETERW;
                                    *(((LPWSTR)pbDataStart) + (dwStringLen + 1)) = (WCHAR)'\0';
                                }
                                else {
                                    *(((LPSTR)pbDataStart) + dwStringLen) = MD_PATH_DELIMETER;
                                    *(((LPSTR)pbDataStart) + (dwStringLen + 1)) = (CHAR)'\0';
                                }
                            }
                        }
                    }
                    //
                    // Append a final 0 for double NULL termination
                    //
                    pbNextDataStart = pbDataStart + dwBytesPerChar;
                    if (SUCCEEDED(hresReturn)) {
                        if ((pbDataStart + dwBytesPerChar) <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                else {
                    if (pszMDBuffer != NULL) {
                        //
                        // If NULL, just return success
                        // No strings, need to append 2 0's for double NULL termination
                        //

                        pbNextDataStart = pbDataStart + (dwBytesPerChar * 2);
                        if (pbNextDataStart <= pbDataEnd) {
                            if (bUnicode) {
                                *((LPWSTR)pbDataStart) = (WCHAR)'\0';
                                *(((LPWSTR)pbDataStart) + 1) = (WCHAR)'\0';
                            }
                            else {
                                *((LPSTR)pbDataStart) = (CHAR)'\0';
                                *(((LPSTR)pbDataStart) + 1) = (CHAR)'\0';
                            }
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
                        }
                    }
                }
                if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                    *pdwMDRequiredBufferSize = DIFF(pbNextDataStart - (PBYTE)pszMDBuffer) / dwBytesPerChar;
                }
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    return ComMDOpenMetaObjectD(hMDHandle,
                                (PBYTE)pszMDPath,
                                dwMDAccessRequested,
                                dwMDTimeOut,
                                phMDNewHandle,
                                TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDOpenMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ DWORD dwMDAccessRequested,
        /* [in] */ DWORD dwMDTimeOut,
        /* [out] */ PMETADATA_HANDLE phMDNewHandle,
        IN BOOL bUnicode)
/*++

Routine Description:

    Opens a meta object for read and/or write access. The returned handle is
        used by several of the other API's. Opening an object for Read access
        guarantees that that view of the data will not change while the object
        is open. Opening an object for write gaurantees that no other objects
        will read or write any changed data until the handle is closed.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject.

    Path            - The path of the object to be opened.

    AccessRequested - The permissions requested. See imd.h.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    NewHandle - The handled to be passed to other MD routines.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_PATH_BUSY

Notes:
    Multiple read handles or a single  write handle can be open on any given
    object.
    Opens for read will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for write.
    Opens for write will wait if the object being opened, any of its ancestor
    objects, or any of its descendant objects is open for read and/or write.

    If the request is for write access or Handle has write access, Handle must be closed before
    this request can succeed, unless Handle = METADATA_MASTER_ROOT_HANDLE.
    Handles should be closed as quickly as possible, as open handles can cause other requests to block.
--*/
{
    HRESULT hresReturn;
    DWORD WaitRetCode;
    METADATA_HANDLE mhTemp;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((phMDNewHandle == NULL) ||
             ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        CMDBaseObject *pboOpen;
        GetSystemTimeAsFileTime(&TempTime);
        ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) +
                      (_int64)TempTime.dwLowDateTime +
                      ((_int64)dwMDTimeOut * 10000);
        TimeLeft = dwMDTimeOut;
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
        }
        //
        // Spin loop waiting for permissions. Events get pulsed whenever a handle is closed.
        // Use a wait interval in case the close comes between the Unlock and the Wait.
        //
        while ((SUCCEEDED(hresReturn)) && (!bPermissionsAvailable) && (TimeLeft > 0)) {
            g_rMasterResource->Unlock();
            if (dwMDAccessRequested & METADATA_PERMISSION_WRITE) {
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            else {
                WaitRetCode = WaitForSingleObject(g_phEventHandles[EVENT_WRITE_INDEX], LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
            }
            GetSystemTimeAsFileTime(&TempTime);

            CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
            TimeLeft = ((ExpireTime - CurrentTime) / 10000);
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            //
            // Get object again to make sure the object hasn't been deleted
            // Should probably put an exception handler PermissionsAvailable and use
            // the current object
            //
            hresReturn = GetObjectFromPath(pboOpen, hMDHandle, 0, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                bPermissionsAvailable = PermissionsAvailable(pboOpen, dwMDAccessRequested, 0);
            }
        }
        if (SUCCEEDED(hresReturn))  {
            if (bPermissionsAvailable) {
                hresReturn = AddHandle(pboOpen, dwMDAccessRequested, mhTemp);
                if (SUCCEEDED(hresReturn)) {
                    *phMDNewHandle = mhTemp;
                }
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Closes a handle to a meta object. If the handle was opened with write
    permission and changes have been made via this handle, this will cause all
    registered callback functions to be called.

Arguments:

    Handle  - The handle returned by MDOpenMetaObject.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE

--*/
{
    HRESULT hresReturn;
    CMDHandle *hoTemp = NULL;
    BOOL bPulseWrite = FALSE;
    BOOL bPulseRead = FALSE;
    BOOL bSendNotifications = FALSE;
    BOOL bDeleteChangeData = FALSE;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) ||
        ((hoTemp = RemoveHandleObject(hMDHandle)) == NULL)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        if (hoTemp->IsWriteAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            bPulseWrite = TRUE;
            bSendNotifications = TRUE;
            bDeleteChangeData = TRUE;
        }
        if (hoTemp->IsReadAllowed()) {
            RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            bPulseRead = TRUE;
        }
        if (bPulseWrite) {
            bPulseWrite = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
        }
        if (bPulseRead && !bPulseWrite) {
            //
            // A write pulse activates everyone, so only do this if we didn't already do a write pulse
            //
            bPulseRead = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
        }
        if (bSendNotifications) {
            g_rMasterResource->Convert(TSRES_CONV_READ);
            if (FAILED(CreateNotifications(hoTemp,
                                           &dwNumChangeEntries,
                                           &pcoBuffer,
                                           &ppbufStorageArray))) {
                bSendNotifications = FALSE;
            }
        }

        hresReturn = ERROR_SUCCESS;
    }
    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                          dwNumChangeEntries,
                          pcoBuffer,
                          ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);
    }

    if (bDeleteChangeData) {

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    }

    delete (hoTemp);

    if (bDeleteChangeData) {
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle. If the handle had write permission and is being changed
    to read only, this will cause all registered callback functions to be called.

Arguments:

    Handle  - The handle to be modified.

    TimeOut         - The time to block waiting for open to succeed, in miliseconds.

    AccessRequested - The requested permissions. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
              ERROR_PATH_BUSY

Notes:
    Success or failure when adding permissions follows the same rules as OpenMetaObject.
    TimeOut values should be short for this call, as it is quite possible for 2 threads
    with read permission on the same data to attempt to update to write at the same time.
    Both will block until one read handle is closed.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoTemp;
    DWORD WaitRetCode;
    _int64 ExpireTime, CurrentTime, TimeLeft;
    FILETIME TempTime;
    BOOL bPermissionsAvailable;
    BOOL bAddRead, bAddWrite, bRemoveRead, bRemoveWrite;
    BOOL bEventPulsed = FALSE;
    BOOL bSendNotifications = FALSE;
    CMDHandle *phoNotifyHandle;

    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer;
    BUFFER **ppbufStorageArray;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE) || ((hoTemp = GetHandleObject(hMDHandle)) == NULL) ||
        ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = E_INVALIDARG;
    }
    else if ((hoTemp = GetHandleObject(hMDHandle)) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
    }
    else {
        bAddRead = (!(hoTemp->IsReadAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_READ));
        bAddWrite = (!(hoTemp->IsWriteAllowed()) && (dwMDAccessRequested & METADATA_PERMISSION_WRITE));
        bRemoveRead = ((hoTemp->IsReadAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_READ));
        bRemoveWrite = ((hoTemp->IsWriteAllowed()) && !(dwMDAccessRequested & METADATA_PERMISSION_WRITE));

        MD_ASSERT(!(bAddRead && bAddWrite));
        MD_ASSERT(!(bRemoveRead && bRemoveWrite));
        MD_ASSERT(!(bAddRead && bRemoveRead));
        MD_ASSERT(!(bAddWrite && bRemoveWrite));

        //
        // Add permissions first, because if delete comes first, another
        // object could open a handle to this in the interim, and the
        // object could get deleted.
        // Also, AddWrite can fail so it must be before RemoveRead
        // to avoid partial completion.
        //

        if (bAddWrite) {
            MD_ASSERT(hoTemp->IsReadAllowed());
            GetSystemTimeAsFileTime(&TempTime);
            ExpireTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime + ((_int64)dwMDTimeOut * 10000);
            TimeLeft = dwMDTimeOut;
            bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
            while ((!bPermissionsAvailable) && (TimeLeft > 0) && (hoTemp!=NULL)) {
                g_rMasterResource->Unlock();
                WaitRetCode = WaitForMultipleObjects(EVENT_ARRAY_LENGTH, g_phEventHandles, FALSE, LESSOROF((DWORD)TimeLeft, OPEN_WAIT_INTERVAL));
                GetSystemTimeAsFileTime(&TempTime);
                CurrentTime = ((_int64)TempTime.dwHighDateTime << 32) + (_int64)TempTime.dwLowDateTime;
                TimeLeft = ((ExpireTime - CurrentTime) / 10000);
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                //
                // The meta object could not have been deleted while the handle is open
                // but the handle object could have been deleted, so get it again.
                //
                hoTemp = GetHandleObject(hMDHandle);
                if (hoTemp != NULL) {
                    bPermissionsAvailable = PermissionsAvailable(hoTemp->GetObject(), METADATA_PERMISSION_WRITE, 1);
                }
            }
            if (hoTemp == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
            }
            else if (!bPermissionsAvailable) {
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_BUSY);
            }
            else {
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if (bAddRead) {
                MD_ASSERT(hoTemp->IsWriteAllowed());
                //
                // Must already have write access
                // Just add read access
                //
                AddPermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
            }
            if (bRemoveRead) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_READ);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_READ_INDEX]);
            }
            if (bRemoveWrite) {
                RemovePermissions(hoTemp->GetObject(), METADATA_PERMISSION_WRITE);
                bEventPulsed = PulseEvent(g_phEventHandles[EVENT_WRITE_INDEX]);
            }
            hoTemp->SetPermissions(dwMDAccessRequested);
        }
    }
    if ((SUCCEEDED(hresReturn)) && bRemoveWrite) {
        if (SUCCEEDED(CreateNotifications(hoTemp,
                                          &dwNumChangeEntries,
                                          &pcoBuffer,
                                          &ppbufStorageArray))) {
            phoNotifyHandle = new CMDHandle(hoTemp);
            if (phoNotifyHandle == NULL) {
                DeleteNotifications(dwNumChangeEntries,
                                    pcoBuffer,
                                    ppbufStorageArray);
            }
            else {
                bSendNotifications = TRUE;
                hoTemp->ZeroChangeList();
            }
        }
        hoTemp->RemoveNotifications();
    }
    g_rMasterResource->Unlock();

    if (bSendNotifications) {
        SendNotifications(hMDHandle,
                  dwNumChangeEntries,
                  pcoBuffer,
                  ppbufStorageArray);
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        //
        // Need to delete handle with write lock held,
        // Since this can delete metaobjects which can delete
        // data which accesses the data cache table.
        //

        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        delete (phoNotifyHandle);
        g_rMasterResource->Unlock();
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSaveData(
            IN METADATA_HANDLE hMDHandle)
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              Errors returned by the file system.
Notes:
    If the main file has been modified by other applications, this call will overwrite them.

--*/
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        hresReturn = InitStorageAndSessionKey(
                         &CryptoStorage,
                         &pSessionKeyBlob
                         );

        if( SUCCEEDED(hresReturn) ) {
            if (g_dwInitialized == 0) {
                hresReturn = MD_ERROR_NOT_INITIALIZED;
            }
            else {
                hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, hMDHandle);
//                RetCode = SaveAllDataToRegistry();
            }
            ::IISCryptoFreeBlob(pSessionKeyBlob);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo)
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    Handle  - The handle to get information about.

    Info    - Structure filled in with the information. See imd.h.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_HANDLE
Notes:
    pmdhiInfo->dwMDSystemChangeNumber will correspond to the System Change Number at the time
    the handle was created. It will not change if writes are done via this handle, or any other
    handle. A client can compare this number with the value returned by MDGetSystemChangeNumber
    to see if any writes have been done since the handle was opened.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *HandleObject;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pmdhiInfo == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        HandleObject = GetHandleObject(hMDHandle);
        if (HandleObject == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
        }
        else {
            HandleObject->GetHandleInfo(pmdhiInfo);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber)
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    SystemChangeNumber - The system change number. This is incremented every time the metadata is updated.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwSystemChangeNumber == NULL) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        *pdwSystemChangeNumber = g_dwSystemChangeNumber;
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  pszMDPath,
                                  pdwMDDataSetNumber,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ComMDGetDataSetNumberD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  pdwMDDataSetNumber,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetDataSetNumberD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    DataSetNumber  - A number associated with this data set. Can be used to identify common data sets.
                     Filled in if successful.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
All paths with the same data set number have identical data if inherited data is included.
The inverse is not true, eg. there may be paths with identical data but different data set numbers.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwMDDataSetNumber == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            *pdwMDDataSetNumber=pboQueried->GetDataSetNumber();
        }
        else if ((hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL)) {
            *pdwMDDataSetNumber=pboQueried->GetDescendantDataSetNumber();
            hresReturn = ERROR_SUCCESS;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddRefReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    AddRefs data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        #if DBG
            //
            // Make sure this is in the table
            //
            CMDBaseData *pbdAddRef = (CMDBaseData *)g_PointerMapper->FindMapping(dwMDDataTag);

            DWORD dwHash = DATA_HASH(pbdAddRef->GetIdentifier());
            CMDBaseData *pbdIndex;
            BOOL bFound = FALSE;

            if (g_ppbdDataHashTable[dwHash] == pbdAddRef) {
                bFound = TRUE;
            }
            else {
                for (pbdIndex=g_ppbdDataHashTable[dwHash];
                    (pbdIndex != NULL ) && (pbdIndex->GetNextPtr() != pbdAddRef);
                    pbdIndex = pbdIndex->GetNextPtr()) {
                }
                if (pbdIndex != NULL) {
                    bFound = TRUE;
                }
            }
            if (!bFound) {
                MD_ASSERT(FALSE);
            }
        #endif

        ((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)))->IncrementReferenceCount();

        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDReleaseReferenceData(
        /* [in] */ DWORD dwMDDataTag)
/*++

Routine Description:

    Releases data gotten by reference via the ComMDGetMetaData, ComMDEnumMetadata, or ComMDGetAllMetadata.

Arguments:

    DataTag - The tag returned with the data.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER

Notes:
    Tags are used without validation. Clients must not pass in invalid tags.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        DeleteDataObject((CMDBaseData *)(g_PointerMapper->FindMapping(dwMDDataTag)));
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDSetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - The new change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, 0, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboAffected->SetLastChangeTime(pftMDLastChangeTime);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   pszMDPath,
                                   pftMDLastChangeTime,
                                   FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ComMDGetLastChangeTimeD(hMDHandle,
                                   (PBYTE)pszMDPath,
                                   pftMDLastChangeTime,
                                   TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetLastChangeTimeD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out] */ PFILETIME pftMDLastChangeTime,
        IN BOOL bUnicode)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - Place to return the change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    PFILETIME pftTemp;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pftMDLastChangeTime == NULL){
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboQueried = NULL;
        hresReturn = GetObjectFromPath(pboQueried, hMDHandle, 0, pszPath, bUnicode);
        if ((SUCCEEDED(hresReturn)) ||
            ((hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) && (pboQueried != NULL))) {
            pftTemp = pboQueried->GetLastChangeTime();
            *pftMDLastChangeTime = *pftTemp;
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDBackupD(hMDHandle,
                        (LPSTR) pszMDBackupLocation,
                        dwMDVersion,
                        dwMDFlags,
                        TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDBackupD(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarning = ERROR_SUCCESS;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((dwMDFlags & !(MD_BACKUP_OVERWRITE |
                           MD_BACKUP_SAVE_FIRST |
                           MD_BACKUP_FORCE_BACKUP)) != 0) ||
             (((dwMDFlags & MD_BACKUP_SAVE_FIRST) == 0) &&
                 ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0) {
            IIS_CRYPTO_STORAGE CryptoStorage;
            PIIS_CRYPTO_BLOB pSessionKeyBlob;
            if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0) {
                hresReturn = InitStorageAndSessionKey(
                                 &CryptoStorage,
                                 &pSessionKeyBlob
                                 );

                if( SUCCEEDED(hresReturn) ) {
                    if (g_dwInitialized == 0) {
                        hresReturn = MD_ERROR_NOT_INITIALIZED;
                    }
                    else {
                        hresReturn = SaveAllData(FALSE, &CryptoStorage, pSessionKeyBlob, hMDHandle, TRUE);
                    }
                    ::IISCryptoFreeBlob(pSessionKeyBlob);
                }
                if (FAILED(hresReturn)) {
                    hresWarning = MD_WARNING_SAVE_FAILED;
                }
            }
        }

        if (SUCCEEDED(hresReturn) || ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0)) {

            //
            // Copy the file
            //

            STRAU strauBackupLocation;

            hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                              dwMDVersion,
                                              bUnicode,
                                              &strauBackupLocation);

            if (SUCCEEDED(hresReturn)) {
                BOOL bFailIfExists = ((dwMDFlags & MD_BACKUP_OVERWRITE) == 0) ? TRUE : FALSE;
                MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

                //
                // Copy the file
                //
                if (!CopyFile(g_strRealFileName->QueryStr(),
                              strauBackupLocation.QueryStr(FALSE),
                              bFailIfExists)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hresReturn)) {

                HANDLE hTempFileHandle;

                hTempFileHandle = CreateFile(strauBackupLocation.QueryStr(FALSE),
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0);
                if (hTempFileHandle != INVALID_HANDLE_VALUE) {
                    FILETIME ftCurrent;
                    GetSystemTimeAsFileTime(&ftCurrent);
                    SetFileTime(hTempFileHandle,
                                NULL,   // Creation Time
                                &ftCurrent,   // Last AccessTime
                                &ftCurrent); // Last Change Time
                    CloseHandle(hTempFileHandle);
                }

                hresReturn = BackupCertificates ((LPCWSTR)pszMDBackupLocation,
                                                    strauBackupLocation.QueryStr(FALSE),
                                                    g_strRealFileName->QueryStr());
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if (hresReturn == ERROR_SUCCESS) {
        hresReturn = hresWarning;
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreD((LPSTR) pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRestoreD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((dwMDVersion == MD_BACKUP_NEXT_VERSION) ||
        (dwMDFlags != 0)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {

        //
        // Send notifications before we grab locks in case users
        // try to access metabase. It would be nice to check the
        // file name before doing this but that requires ReadSaveSemaphore.
        //
        // Send Shutdown Notification since we don't have a Restore
        // Notification and it's close enough.
        //

        SendShutdownNotifications();

        //
        // Give applications some time to close their interfaces,
        // but don't wait too long, user is waiting.
        // Wait until references are closed, unless they take too long.
        // IISADMIN and factory both have refences we do not wait for.
        //
        // We don't actually need to wait during restore, since
        // interfaces are preserved, but waiting will allow clients
        // to cleanup properly.
        //

        for (int i = 0;
             (InterlockedIncrement((long *)&m_dwRefCount) > 3) &&
                 (i < MD_SHUTDOWN_WAIT_SECONDS);
             i++) {
            InterlockedDecrement((long *)&m_dwRefCount);
            Sleep(1000);
        }

        InterlockedDecrement((long *)&m_dwRefCount);

        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation);

        if (SUCCEEDED(hresReturn)) {
            //
            // Got a valid name
            // See if the file exists
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            STR   strCopyOfMetabaseFileName (*g_strRealFileName);

            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                FindClose(hFile);
                //
                // File actually exists,
                // Go ahead and restore.
                //
                g_rMasterResource->Lock(TSRES_LOCK_WRITE);
                //
                // Need to do the file copy before Terminate
                // so the global variables are still set.
                // Also good to not terminate if it fails.
                //
                if (!CopyFile(strauBackupLocation.QueryStr(FALSE),
                              g_strRealFileName->QueryStr(),
                              FALSE)) {
                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                }
                else {
                    //
                    // Prevent saves during termination.
                    //
                    BOOL bPrevSaveDisallowed = g_bSaveDisallowed;
                    g_bSaveDisallowed = TRUE;
                    DWORD dwInitializedSave = g_dwInitialized;
                    while (g_dwInitialized > 0) {
                        TerminateWorker1(TRUE);
                    }

                    RestoreCertificates ((LPCWSTR)pszMDBackupLocation,
                                          strauBackupLocation.QueryStr(FALSE),
                                          strCopyOfMetabaseFileName.QueryStr());

                    g_bSaveDisallowed = bPrevSaveDisallowed;
                    while (SUCCEEDED(hresReturn) && (g_dwInitialized < dwInitializedSave)) {
                        hresReturn = InitWorker(TRUE);
                    }

                }
                g_rMasterResource->Unlock();

                //
                // At this point all old handles are invalidated
                // and all no new handles have been opened.
                // So tell clients to invalidate any open handles now.
                //

                if (SUCCEEDED(hresReturn)) {
                    SendEventNotifications(MD_EVENT_MID_RESTORE);
                }
            }

        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ComMDEnumBackupsD((LPSTR) pszMDBackupLocation,
                             pdwMDVersion,
                             pftMDBackupTime,
                             dwMDEnumIndex,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumBackupsD(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if ((pszMDBackupLocation == NULL) ||
        (pdwMDVersion == NULL)) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        // Currently, no flags are defined
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        if (!strauBackupLocation.Copy(g_pstrBackupFilePath->QueryStr())) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else if (!strauBackupLocation.Append("\\")) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (bUnicode) {
                if (*(LPWSTR)pszMDBackupLocation == (WCHAR)'\0') {
                    if (!strauBackupLocation.Append(L"*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPWSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
            else {
                if (*(LPSTR)pszMDBackupLocation == '\0') {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else {
                    if (!strauBackupLocation.Append((LPSTR)pszMDBackupLocation)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
            }
        }
        if (SUCCEEDED(hresReturn)) {
            if (SUCCEEDED(hresReturn)) {
                if (!strauBackupLocation.Append(MD_BACKUP_SUFFIX)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (!strauBackupLocation.Append("*")) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else {

                        //
                        // Make sure MultiByte string is valid
                        //

                        if (strauBackupLocation.QueryStrA() == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // Successfully created the search name
            // Enumerate files
            //
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);
            HANDLE hFile = INVALID_HANDLE_VALUE;
            WIN32_FIND_DATA wfdFile;
            DWORD dwEnumIndex = (DWORD) -1;
            hFile = FindFirstFile(strauBackupLocation.QueryStrA(),
                                  &wfdFile);
            if (hFile == INVALID_HANDLE_VALUE) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
            else {
                if (CheckDigits(wfdFile.cFileName +
                                GetBackupNameLen(wfdFile.cFileName) +
                                (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                    dwEnumIndex++;
                }
                while (SUCCEEDED(hresReturn) && (dwEnumIndex != dwMDEnumIndex)) {
                    //
                    // Process the remaining files
                    //
                    if (FindNextFile(hFile, &wfdFile)) {
                        if (CheckDigits(wfdFile.cFileName +
                                        GetBackupNameLen(wfdFile.cFileName) +
                                        (sizeof(MD_BACKUP_SUFFIX) - 1))) {
                            //
                            // One of our files
                            //
                            dwEnumIndex++;
                        }
                    }
                    else {
                        hresReturn = GetLastHResult();
                    }
                }
                FindClose(hFile);
            }
            if (SUCCEEDED(hresReturn)) {
                //
                // Found the file
                // File name is in wfdFile.cFileName
                // Time is in wfdFile.ftLastWriteTime
                // Need to separate the name and version
                // Reuse strauBackupLocation
                //

                DWORD dwNameLen;
                if ((!strauBackupLocation.Copy(wfdFile.cFileName) ||
                    (strauBackupLocation.QueryStrW() == NULL))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    //
                    // ANSI bytes might not equal characters, so use unicode
                    //
                    dwNameLen = GetBackupNameLen(strauBackupLocation.QueryStrW());
                    strauBackupLocation.SetLen(dwNameLen);
                    if (strauBackupLocation.QueryCB(bUnicode) >
                        (MD_BACKUP_MAX_LEN * ((bUnicode) ? sizeof(WCHAR) : sizeof(char)))) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
                    }
                    else {
                        MD_COPY(pszMDBackupLocation,
                                strauBackupLocation.QueryStr(bUnicode),
                                strauBackupLocation.QueryCB(bUnicode) +
                                    ((bUnicode) ? sizeof(WCHAR) : sizeof(char)));
                        *pdwMDVersion = atol(wfdFile.cFileName +

                                             //
                                             // dwNameLen is # characters
                                             // Need to add # bytes, so
                                             // Get it from STRAU
                                             //

                                             strauBackupLocation.QueryCBA() +
                                             (sizeof(MD_BACKUP_SUFFIX) - 1));
                        MD_COPY(pftMDBackupTime,
                                &(wfdFile.ftLastWriteTime),
                                sizeof(FILETIME));
                    }
                }
            }
            else {
                if ((hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) ||
                    (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_FILES))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
                }
            }
        }

        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ComMDDeleteBackupD((LPSTR) pszMDBackupLocation,
                              dwMDVersion,
                              TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteBackupD(
            /* [in] */ LPSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (dwMDVersion == MD_BACKUP_NEXT_VERSION) {
        //
        // CreateBackupFileName checks for valid name,
        // but it allows NEXT_VERSION, so we check that here.
        //
        hresReturn = E_INVALIDARG;
    }
    else {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);

        STRAU strauBackupLocation;

        hresReturn = CreateBackupFileName(pszMDBackupLocation,
                                          dwMDVersion,
                                          bUnicode,
                                          &strauBackupLocation);

        if (SUCCEEDED(hresReturn)) {
            MD_ASSERT(strauBackupLocation.QueryStr(FALSE) != NULL);

            //
            // Delete the file
            //

            if (!DeleteFile(strauBackupLocation.QueryStr(FALSE))) {
                hresReturn = RETURNCODETOHRESULT(GetLastError());
            }
        }
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));

    }
    return hresReturn;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CMDCOM::NotifySinks(METADATA_HANDLE hHandle,
                    PMD_CHANGE_OBJECT pcoChangeList,
                    DWORD dwNumEntries,
                    BOOL bUnicode,
                    DWORD dwNotificationType,
                    DWORD dwEvent)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* pIConnectionPoint;
  IEnumConnections* pIEnum;
  CONNECTDATA ConnData;
  HRESULT hrTemp;


  FlushSomeData ();

  //
  // Correct broken connections.
  // It's not likely to be a high number so
  // save a memory allocation by using an array.
  //
  DWORD pdwLostConnections[10];
  DWORD dwNumLostConnections = 0;

  // If there was a paper event, broadcast appropriate notifications to
  // all Sinks connected to each connection point.
//  if (PAPER_EVENT_NONE != PaperEvent)
  {
      if (bUnicode) {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W];
      }
      else {
          pIConnectionPoint = m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A];
      }
      if (NULL != pIConnectionPoint)
      {
          pIConnectionPoint->AddRef();
          g_rSinkResource->Lock(TSRES_LOCK_READ);
          hr = pIConnectionPoint->EnumConnections(&pIEnum);
          if (SUCCEEDED(hr)) {
              // Loop thru the connection point's connections and if the
              // listening connection supports IPaperSink (ie, PaperSink events)
              // then dispatch the PaperEvent event notification to that sink.
              while (NOERROR == pIEnum->Next(1, &ConnData, NULL))
              {
                IMDCOMSINK* pIMDCOMSINK;

                if (bUnicode) {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_W,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                else {
                    hr = ConnData.pUnk->QueryInterface(IID_IMDCOMSINK_A,
                                                       (PPVOID)&pIMDCOMSINK);
                }
                if (SUCCEEDED(hr))
                {
                    switch (dwNotificationType) {
                        case MD_SINK_MAIN: {
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_W)pcoChangeList);
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDSinkNotify(hHandle,
                                                                                    dwNumEntries,
                                                                                    (PMD_CHANGE_OBJECT_A)pcoChangeList);
                            }
                        }
                        break;
                        case MD_SINK_SHUTDOWN: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                            else {
                                hrTemp = ((IMDCOMSINKA*)pIMDCOMSINK)->ComMDShutdownNotify();
                            }
                        }
                        break;
                        case MD_SINK_EVENT: {
                            //
                            // Shutdown Notifications
                            //
                            if (bUnicode) {
                                hrTemp = ((IMDCOMSINKW*)pIMDCOMSINK)->ComMDEventNotify(dwEvent);
                            }
                            else {
                                DBG_ASSERT(FALSE);
                            }
                        }
                        break;
                        default: {
                            DBG_ASSERT(FALSE);
                        }
                    }

                    pIMDCOMSINK->Release();
                    if (FAILED(hrTemp)) {
                        if ((HRESULT_CODE(hrTemp) == RPC_S_SERVER_UNAVAILABLE) ||
                            ((HRESULT_CODE(hrTemp) >= RPC_S_NO_CALL_ACTIVE) &&
                                (HRESULT_CODE(hrTemp) <= RPC_S_CALL_FAILED_DNE))) {
                            if (dwNumLostConnections < 10) {
                                pdwLostConnections[dwNumLostConnections++] = ConnData.dwCookie;
                            }
                        }
                    }
                }
                ConnData.pUnk->Release();
              }
              pIEnum->Release();
          }
          g_rSinkResource->Unlock();
          while (dwNumLostConnections > 0) {
              pIConnectionPoint->Unadvise(pdwLostConnections[--dwNumLostConnections]);
          }
          pIConnectionPoint->Release();
      }
  }

  return hr;
}

HRESULT
CMDCOM::ConvertNotificationsToDBCS(DWORD dwNumChangeEntries,
                                   BUFFER **ppbufStorageArray)
{
    HRESULT hresReturn = S_OK;
    //
    // ppbufStorageArray is an array of buffer pointers,
    // where each buffer contains a UNICODE path string
    // which needs to be converted to a Local System path string
    //

    STRAU strauPath;
    STRAU strauPathOptional;
    LPSTR pszDBCSPath;
    LPSTR pszDBCSPathOptional;
    LPSTR pmultiszTarget;
    DWORD dwStrLen1,dwStrLen2 = 0;

    for (DWORD i = 0; i < dwNumChangeEntries; i++) {
        MD_ASSERT(ppbufStorageArray[i] != NULL);

        pmultiszTarget = (LPSTR) ppbufStorageArray[i]->QueryPtr();
        if (!strauPath.Copy((LPWSTR)pmultiszTarget))
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            if ((PWORD)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR)))
            {
                if (!strauPathOptional.Copy((LPWSTR)(pmultiszTarget + strauPath.QueryCBW() + sizeof (WCHAR))))
                {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    pszDBCSPathOptional = strauPathOptional.QueryStrA();
                    if (pszDBCSPath == NULL || pszDBCSPathOptional == NULL)
                    {
                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    else
                    {
                        dwStrLen2 = strauPathOptional.QueryCBA() + 1 ;
                    }
                }
            }

            if (hresReturn == S_OK)
            {
                pszDBCSPath = strauPath.QueryStrA();
                if (pszDBCSPath == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    dwStrLen1 = strauPath.QueryCBA() + 1 ;

                    MD_ASSERT(ppbufStorageArray[i]->QuerySize() >= (dwStrLen1 + dwStrLen2 + sizeof(char)));

                    MD_COPY(pmultiszTarget, pszDBCSPath, dwStrLen1 );
                    if ( dwStrLen2 >0 )
                    {
                        MD_COPY(pmultiszTarget + dwStrLen1 , pszDBCSPathOptional, dwStrLen2 );
                    }
                    *(pmultiszTarget + dwStrLen1 + dwStrLen2) = '\0';
                }
            }
        }
    }
    return hresReturn;
}

VOID
CMDCOM::SendShutdownNotifications()
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_SHUTDOWN);
    NotifySinks(0,
                NULL,
                0,
                FALSE,
                MD_SINK_SHUTDOWN);
}

VOID
CMDCOM::SendEventNotifications(DWORD dwEvent)
{
    NotifySinks(0,
                NULL,
                0,
                TRUE,
                MD_SINK_EVENT,
                dwEvent);
}

VOID
CMDCOM::SendNotifications(METADATA_HANDLE hHandle,
                          DWORD dwTotalNumChangeEntries,
                          PMD_CHANGE_OBJECT_W pcoBuffer,
                          BUFFER **ppbufStorageArray
                          )
{

    DWORD dwNumChangeEntries;
    DWORD dwRemainingNumChangeEntries = dwTotalNumChangeEntries;


    MD_ASSERT(sizeof(MD_CHANGE_OBJECT_A) == sizeof(MD_CHANGE_OBJECT_W));

    while (dwRemainingNumChangeEntries != 0) {
        dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
        NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                    dwNumChangeEntries,
                    TRUE,
                    MD_SINK_MAIN);
        dwRemainingNumChangeEntries -= dwNumChangeEntries;
    }

    if (SUCCEEDED(ConvertNotificationsToDBCS(dwTotalNumChangeEntries,
                                             ppbufStorageArray))) {
        dwRemainingNumChangeEntries = dwTotalNumChangeEntries;
        while (dwRemainingNumChangeEntries != 0) {
            dwNumChangeEntries = LESSOROF(dwRemainingNumChangeEntries, MD_MAX_CHANGE_ENTRIES);
            NotifySinks(hHandle,
                    (PMD_CHANGE_OBJECT)(pcoBuffer + (dwTotalNumChangeEntries - dwRemainingNumChangeEntries)),
                        dwNumChangeEntries,
                        FALSE,
                        MD_SINK_MAIN);
            dwRemainingNumChangeEntries -= dwNumChangeEntries;
        }
    }
}

VOID
CMDCOM::DeleteNotifications(DWORD dwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W pcoBuffer,
                            BUFFER **ppbufStorageArray
                            )
{

    if (dwNumChangeEntries != 0) {
        if (ppbufStorageArray != NULL) {
            for (DWORD i = 0;i < dwNumChangeEntries;i++) {
                 delete (ppbufStorageArray[i]);
            }
            delete ppbufStorageArray;
        }
        delete pcoBuffer;
    }
}


HRESULT
CMDCOM::CreateNotifications(CMDHandle *phoHandle,
                            DWORD *pdwNumChangeEntries,
                            PMD_CHANGE_OBJECT_W *ppcoBuffer,
                            BUFFER ***pppbufStorageArray
                            )
{
    HRESULT hRes = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    PCHANGE_ENTRY pceChange;
    DWORD i,j;
    BUFFER **ppbufStorageArray = NULL;
    DWORD dwStringLen, dwStringOldNameLen;
    DWORD dwNumChangeEntries;
    PMD_CHANGE_OBJECT_W pcoBuffer = NULL;

    dwNumChangeEntries = phoHandle->GetNumChangeEntries();
    if (dwNumChangeEntries != 0) {
        ppbufStorageArray = new BUFFER *[dwNumChangeEntries];

        if (ppbufStorageArray == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            for (i = 0; i < dwNumChangeEntries; i++) {
                ppbufStorageArray[i] = new BUFFER();
                if (ppbufStorageArray[i] == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                //
                // Create UNICODE callbacks
                //
                pcoBuffer = new MD_CHANGE_OBJECT_W[dwNumChangeEntries];
                if (pcoBuffer == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    for (i = 0;
                        (dwReturn == ERROR_SUCCESS) && (i < dwNumChangeEntries);
                         i++) {
                        MD_REQUIRE((pceChange = phoHandle->EnumChangeEntries(i)) != NULL);
                        dwStringLen = 0;
                        dwReturn = GetObjectPath(pceChange->pboChanged,
                                                 ppbufStorageArray[i],
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 TRUE);
                        if (dwReturn == ERROR_SUCCESS) {
                            dwStringOldNameLen = 0;
                            if ( pceChange->pStrOrigName !=NULL) {
                                dwStringOldNameLen = pceChange->pStrOrigName->QueryCCH ();
                            }

                            // we adding 5, because: 1 for path_delimiter first line 1 for term-zero for first line
                            // 1 for path_delimiter second line 1 for term-zero for second line
                            // and last 1 for multisz term-zero
                            if (!ppbufStorageArray[i]->Resize((dwStringLen + dwStringOldNameLen + 5 ) * sizeof(WCHAR))) {
                                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else {
                                pcoBuffer[i].dwMDChangeType = pceChange->dwChangeType;
                                pcoBuffer[i].pszMDPath = (LPWSTR)(ppbufStorageArray[i]->QueryPtr());
                                pcoBuffer[i].pszMDPath[dwStringLen] = MD_PATH_DELIMETERW;
                                pcoBuffer[i].pszMDPath[dwStringLen + 1] = (WCHAR)'\0';
                                pcoBuffer[i].pszMDPath[dwStringLen + 2] = (WCHAR)'\0';
                                if ( dwStringOldNameLen )
                                {
                                    memcpy (&(pcoBuffer[i].pszMDPath[dwStringLen + 2]),
                                            pceChange->pStrOrigName->QueryStrW(),
                                            dwStringOldNameLen * sizeof(WCHAR) );
                                    pcoBuffer[i].pszMDPath[dwStringLen + 2 + dwStringOldNameLen] = MD_PATH_DELIMETERW;
                                    pcoBuffer[i].pszMDPath[dwStringLen + 3 + dwStringOldNameLen] = (WCHAR)'\0';
                                }
                                pcoBuffer[i].dwMDNumDataIDs = pceChange->dwNumDataIDs;
                                if (pceChange->dwNumDataIDs != 0) {
                                    MD_ASSERT(pceChange->pbufDataIDs != NULL);
                                    pcoBuffer[i].pdwMDDataIDs = (DWORD *)(pceChange->pbufDataIDs->QueryPtr());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (dwReturn != ERROR_SUCCESS) {
        //
        // Free Buffers
        //
        DeleteNotifications(dwNumChangeEntries,
                            pcoBuffer,
                            ppbufStorageArray);

        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    else {
        //
        // Pass back info
        // DeleteNotifications will be called later
        //
        *pdwNumChangeEntries = dwNumChangeEntries;
        *pppbufStorageArray = ppbufStorageArray;
        *ppcoBuffer = pcoBuffer;
    }

    if (dwReturn != ERROR_SUCCESS) {
        hRes = RETURNCODETOHRESULT(dwReturn);
    }
    return hRes;
}






VOID CMDCOM::InitializeFlusher (VOID)
{
    if (!fFlusherInitialized)
    {
        fFlusherInitialized = TRUE;

        EnterCriticalSection( &csFlushLock );
        dwFlushCnt = 0;
        dwFlushPeriodExtensions = 0;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
        LeaveCriticalSection( &csFlushLock );

    }

}

// The algorithm for flushing changes of emtabase to ahrd disk is the following:
// when change to metabase is made, and SlushSomeData is called from NotifySinks
// counter which counts the number of changes in metabase is incremented  and first time
// the change happens work item is schedulled for scheduller to flush a metabase after 60seconds
// if during 60 seconds more than INETA_MB_FLUSH_TRESHOLD changes will happen , then metabase will not
// flush cahnges to disk, but will extend flushing period for another 60 seconds. If during another 60 secs
// number of changes will be higer than INETA_MB_FLUSH_TRESHOLD agian period will be extended
// but no more times than INETA_MB_FLUSH_PERIODS_EXTENSION
// if in some period number of changes in metabase will be less than INETA_MB_FLUSH_TRESHOLD then
// peirod will not be extended and metabase will be saved to disk


VOID WINAPI CMDCOM::MetabaseLazyFlush(
    VOID * pv
    )
/*++

    Description:

        Scheduler callback for flushing the metabase

--*/
{
    BOOL fExtendPeriod =FALSE;
    CMDCOM *pMasterObject = (CMDCOM *)pv;

    MD_ASSERT(pMasterObject != NULL);

    EnterCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized)
    {
        pMasterObject->dwMBFlushCookie = 0;
        if ( pMasterObject->dwFlushCnt > INETA_MB_FLUSH_TRESHOLD)
        {
            if ( pMasterObject->dwFlushPeriodExtensions < INETA_MB_FLUSH_PERIODS_EXTENSION)
            {
                fExtendPeriod = TRUE;
                pMasterObject->dwFlushPeriodExtensions ++;
            }
        }

        pMasterObject->dwFlushCnt = 0;
        if (!fExtendPeriod)
        {
            pMasterObject->dwFlushPeriodExtensions = 0;
        }
        else
        {
            pMasterObject->dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                               pv, //context,
                                                               pMasterObject->msMBFlushTime);
        }
    }

    LeaveCriticalSection( &pMasterObject->csFlushLock );

    if (pMasterObject->fFlusherInitialized && !fExtendPeriod)
    {
        MB mb(pMasterObject);
        mb.Save();
    }

}

VOID CMDCOM::FlushSomeData (VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        dwFlushCnt++;
        if ( !dwMBFlushCookie )
        {
            dwMBFlushCookie = ScheduleWorkItem( MetabaseLazyFlush,
                                                this, //context,
                                                msMBFlushTime,
                                                FALSE);
        }
    }
    LeaveCriticalSection( &csFlushLock );
}


VOID CMDCOM::TerminateFlusher(VOID)
{
    EnterCriticalSection( &csFlushLock );
    if ( fFlusherInitialized)
    {
        fFlusherInitialized = FALSE;
        if ( dwMBFlushCookie )
        {
            RemoveWorkItem( dwMBFlushCookie );
            dwMBFlushCookie = 0;
        }
    }
    LeaveCriticalSection( &csFlushLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\memalloc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


extern "C" {


#include <iiscrypt.h>



PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return (PVOID)LocalAlloc( LPTR, Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    (VOID)LocalFree( (HLOCAL)Buffer );

}   // IISCryptoFreeMemory


}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\gbuf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gbuf.cxx

Abstract:

    IIS MetaBase subroutines to support global buffers

Author:

    Michael W. Thomas            12-July-96

Revision History:

--*/

#include <mdcommon.hxx>

HRESULT
InitBufferPool()
/*++

Routine Description:

    Initializes the pool of buffers.

Arguments:

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            Errors returned by CreateSemaphore
Notes:

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    DWORD i;

    g_ppvDataBufferBlock = NULL;
    g_pbcDataContainerBlock = NULL;
    if ((g_ppvDataBufferBlock = (PVOID *) new PVOID[NUM_DATA_BUFFERS][DATA_BUFFER_LEN]) == NULL) {
        RetCode = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if ((g_pbcDataContainerBlock = (PBUFFER_CONTAINER) new BUFFER_CONTAINER[NUM_DATA_BUFFERS]) == NULL) {
        RetCode = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        g_pbcDataFreeBufHead = NULL;
        g_pbcDataUsedBufHead = NULL;
        for (i = 0; i < NUM_DATA_BUFFERS; i++) {
            g_pbcDataContainerBlock[i].ppvBuffer = g_ppvDataBufferBlock + (i * DATA_BUFFER_LEN);
            g_pbcDataContainerBlock[i].NextPtr = g_pbcDataFreeBufHead;
            g_pbcDataFreeBufHead = g_pbcDataContainerBlock + i;
        }

        g_hDataBufferSemaphore = IIS_CREATE_SEMAPHORE(
                                     "g_hDataBufferSemaphore",
                                     &g_hDataBufferSemaphore,
                                     NUM_DATA_BUFFERS,
                                     NUM_DATA_BUFFERS
                                     );
        if (g_hDataBufferSemaphore == NULL) {
            RetCode = GetLastError();
        }
        else {
            INITIALIZE_CRITICAL_SECTION(&g_csDataBufferCritSec);
        }
    }
    if (RetCode != ERROR_SUCCESS) {
        delete (g_ppvDataBufferBlock);
        delete (g_pbcDataContainerBlock);
    }
    return RETURNCODETOHRESULT(RetCode);
}

VOID
DeleteBufferPool()
/*++

Routine Description:

    Deletes the pool of buffers.

Arguments:

Return Value:

Notes:

--*/
{
    delete (g_ppvDataBufferBlock);
    delete (g_pbcDataContainerBlock);
    DeleteCriticalSection(&g_csDataBufferCritSec);
    CloseHandle(g_hDataBufferSemaphore);
}

PVOID *
GetDataBuffer()
/*++

Routine Description:

    Gets a buffer.

Arguments:

Return Value:

    PVOID * - The buffer.

Notes:

--*/
{
    DWORD dwError;
    PVOID *ppvReturn = NULL;
    PBUFFER_CONTAINER pbcTemp;
    DWORD i;
    //
    // Use a dual synchonization scheme.
    // The semaphore is used to guarantee
    // a buffer is available.
    // The critical section is used to
    // contol access to global data.
    //
    dwError = WaitForSingleObject(g_hDataBufferSemaphore,
                                 INFINITE);
    if (dwError != WAIT_FAILED) {
        EnterCriticalSection(&g_csDataBufferCritSec);
        MD_ASSERT(g_pbcDataFreeBufHead != NULL);
        ppvReturn = g_pbcDataFreeBufHead->ppvBuffer;
        pbcTemp = g_pbcDataFreeBufHead->NextPtr;
        g_pbcDataFreeBufHead->NextPtr = g_pbcDataUsedBufHead;
        g_pbcDataUsedBufHead = g_pbcDataFreeBufHead;
        g_pbcDataFreeBufHead = pbcTemp;
        LeaveCriticalSection(&g_csDataBufferCritSec);
        for (i = 0; i < DATA_BUFFER_LEN; i++) {
            ppvReturn[i] = NULL;
        }
    }
    return (ppvReturn);
}

VOID
FreeDataBuffer(
         PVOID *ppvBuffer)
{
/*++

Routine Description:

    Gets a buffer.

Arguments:

    ppvBuffer - The buffer.

Return Value:

Notes:

--*/
    PBUFFER_CONTAINER pbcTemp;
    EnterCriticalSection(&g_csDataBufferCritSec);
    MD_ASSERT(g_pbcDataUsedBufHead != NULL);
    //
    // Just grab any container. It's more efficient to set ppvBuffer
    // than to find the right container.
    // Of course, this eliminates error checking. The caller is
    // responsible to make sure that it only passes in correct addresses.
    //
    pbcTemp = g_pbcDataUsedBufHead->NextPtr;
    g_pbcDataUsedBufHead->NextPtr = g_pbcDataFreeBufHead;
    g_pbcDataFreeBufHead = g_pbcDataUsedBufHead;
    g_pbcDataUsedBufHead = pbcTemp;
    g_pbcDataFreeBufHead->ppvBuffer = ppvBuffer;
    LeaveCriticalSection(&g_csDataBufferCritSec);
    MD_REQUIRE(ReleaseSemaphore(g_hDataBufferSemaphore,
                               1,
                               NULL));
}

BOOL
InsertItemIntoDataBuffer(
         PVOID pvItem,
         PVOID *ppvMainDataBuf,
         DWORD &dwNumBufferEntries)
{
/*++

Routine Description:

    Appends an item to the buffer at the specified location. This
    must be an append. Random insertion is not supported.
    This is actually a 2 tiered buffer scheme, where the first buffer
    is used an array of buffers.
    Items are pointers.

Arguments:

    Item             - The pointer to add to the buffer.

    MainDataBuf      - The buffer.

    NumBufferEntries - The number of entries currently in the buffer.

Return Value:

    BOOL       - TRUE if the item was added successfully.

Notes:

--*/
    BOOL bReturn = TRUE;
    DWORD dwMainBufIndex = dwNumBufferEntries / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwNumBufferEntries % (DATA_BUFFER_LEN - 1);
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < ((int)dwMainBufIndex - 1); i++) {

        //
        // Go to the buffer before the one we want,
        // in case we need to get the final one.
        //

        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] != NULL);
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if ((dwMainBufIndex != 0) && (dwSubBufIndex == 0)) {
        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] == NULL);
        ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] = GetDataBuffer();
    }

    MD_ASSERT((dwMainBufIndex == 0) || (i == (int)dwMainBufIndex - 1));
    if (dwMainBufIndex != 0) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
    }

    MD_ASSERT(ppvCurrentDataBuf[dwSubBufIndex] == 0);
    ppvCurrentDataBuf[dwSubBufIndex] = pvItem;
    dwNumBufferEntries++;

    return(bReturn);
}

PVOID
GetItemFromDataBuffer(
         PVOID *ppvMainDataBuf,
         DWORD dwItemNum)
/*++

Routine Description:

    Gets the specified item from the buffer.

Arguments:

    MainDataBuf   - The buffer.

    ItemNum       - The number of the item to get.

Return Value:

    PVOID         - The Item from that location.
                    NULL if no item exists at that location.

Notes:

--*/
{
    DWORD dwMainBufIndex = dwItemNum / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwItemNum % (DATA_BUFFER_LEN - 1);
    PVOID pvReturn;
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < (int)dwMainBufIndex; i++) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if (ppvCurrentDataBuf == NULL) {
        pvReturn = NULL;
    }
    else {
        pvReturn = ppvCurrentDataBuf[dwSubBufIndex];
    }
    return(pvReturn);
}

VOID
FreeMainDataBuffer(
         PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Frees a main data buffer. Deletes all sub buffers.

Arguments:

    MainDataBuf   - The main data buffer.

Return Value:

Notes:

--*/
{
    MD_ASSERT(ppvMainDataBuf != NULL);
    PVOID *ppvCurrentDataBuf;
    PVOID *ppvNextDataBuf;

    for ( ppvCurrentDataBuf = ppvMainDataBuf;
          ppvCurrentDataBuf != NULL;
          ppvCurrentDataBuf = ppvNextDataBuf ) {
        ppvNextDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
        FreeDataBuffer(ppvCurrentDataBuf);
    }
}

PVOID *
GetMainDataBuffer()
/*++

Routine Description:

    Gets a main data buffer. Deletes all sub buffers.

Arguments:

Return Value:

    PVOID * - The main data buffer.

Notes:

--*/
{
    return(GetDataBuffer());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\main.h ===
#include <buffer.hxx>
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <tchar.h>
#include <conio.h>
#include <time.h>

#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>
//#include <netlib.h>

#define INITGUID
#define _WIN32_DCOM
#undef DEFINE_GUID      // Added for NT5 migration
#include <ole2.h>
#include <coguid.h>

#include "iadmw.h"
#include "iiscnfg.h"
#include "iwamreg.h"

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    );

class CMDKey
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE () {return m_hKey;}
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    HRESULT OpenNode(LPCTSTR pchSubKeyPath);
    // to open an existing MD key, or create one if doesn't exist
    HRESULT CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    HRESULT Close();

    HRESULT ForceWriteMetabaseToDisk();
    
    BOOL IsEmpty( PWCHAR pszSubString = L"" );

    HRESULT SetData(
     DWORD id,
     DWORD attr,
     DWORD uType,
     DWORD dType,
     DWORD cbLen,
     LPBYTE pbData,
     PWCHAR pszSubString = L"" );

    BOOL GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen,
     LPBYTE pbData,
     DWORD BufSize,
     PWCHAR pszSubString = L"" );

    BOOL GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen,
     LPBYTE pbData,
     DWORD BufSize,
     DWORD  dwAttributes,
     DWORD  dwUType,
     DWORD  dwDType,
     PWCHAR pszSubString = L"" );

private:

    HRESULT DoCoInitEx();
    void DoCoUnInit();

    // a count of the calls to coinit
    INT m_cCoInits;
};

void MyPrintf(TCHAR *pszfmt, ...);
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\metafix\metasub.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase subroutines to support exported routines

Author:

    Michael W. Thomas            31-May-96

Revision History:

Notes:

    Most routines in this file assume that g_rMasterResource is already taken
    for read or write as appropriate.
--*/

#include <locale.h>
#include <mdcommon.hxx>
#include <inetsvcs.h>

#if DBG

BOOL g_fShowMetaLocks = FALSE;

#endif DBG

HRESULT GetObjectFromPath(
         OUT CMDBaseObject *&rpboReturn,
         IN METADATA_HANDLE hHandle,
         IN DWORD dwPermissionNeeded,
         IN OUT LPTSTR &strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds an object from a path. Updates Path to point past the last
    object found if the whole path is not found. If the entire path
    is not found, the last object found is returned.

Arguments:

    Return - The object found.

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    PermissionNeeded - The read/write permissions needed. Compared with the
             permissions associated with Handle.

    Path   - The path of the object requested, relative to Handle. If the path
             is not found, this is updated to point to the portion of the path
             not found.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *pboCurrent, *pboPrevious;
    LPTSTR strCurPath = strPath;

    CMDHandle *HandleObject = GetHandleObject(hHandle);
    if (HandleObject == NULL) {
        hresReturn = E_HANDLE;
    }
    else if ((((dwPermissionNeeded & METADATA_PERMISSION_WRITE) != 0) && (!HandleObject->IsWriteAllowed())) ||
        (((dwPermissionNeeded & METADATA_PERMISSION_READ) != 0) && (!HandleObject->IsReadAllowed()))) {
        hresReturn = E_ACCESSDENIED;
    }
    else {
        pboCurrent = HandleObject->GetObject();
        MD_ASSERT(pboCurrent != NULL);
        strCurPath = strPath;

        if (strCurPath != NULL) {
            SkipPathDelimeter(strCurPath, bUnicode);
            while ((pboCurrent != NULL) &&
                (!IsStringTerminator(strCurPath, bUnicode))) {
                pboPrevious = pboCurrent;
                //
                // GetChildObject increments strCurPath on success
                // and returns NULL if child not found
                //
                pboCurrent = pboCurrent->GetChildObject(strCurPath, &hresReturn, bUnicode);
                if (FAILED(hresReturn)) {
                    break;
                }
                if (pboCurrent != NULL) {
                    SkipPathDelimeter(strCurPath, bUnicode);
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {
            if ((strCurPath == NULL) ||
                IsStringTerminator(strCurPath, bUnicode)) {  // Found the whole path
                rpboReturn = pboCurrent;
                hresReturn = ERROR_SUCCESS;
            }
            else {           //return last object found and an error code
                rpboReturn = pboPrevious;
                hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
                strPath = strCurPath;
            }
        }
    }

    return (hresReturn);
}

HRESULT AddObjectToDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Creates and adds one or more objects to the metabase. Finds the deepest object
    pointed to by Handle/Path and creates any subobject specified by path.

Arguments:

    Handle - The Meta Data handle. METADATA_MASTER_ROOT_HANDLE or a handle
             returned by MDOpenMetaObject with read permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_NOT_ENOUGH_MEMORY
             ERROR_INVALID_NAME

Notes:

--*/
{
    HRESULT hresReturn=ERROR_SUCCESS;
    CMDBaseObject *pboParent;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    HRESULT hresExtractRetCode = ERROR_SUCCESS;

    hresReturn = GetObjectFromPath(pboParent,
                                hHandle,
                                METADATA_PERMISSION_WRITE,
                                strTempPath,
                                bUnicode);
    //
    // This should return ERROR_PATH_NOT_FOUND and the parent object,
    // with strPath set to the remainder of the path,
    // which should be the child name, without a preceding delimeter.
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        MD_ASSERT(pboParent != NULL);
        for (hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
            SUCCEEDED(hresExtractRetCode);
            hresExtractRetCode = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode)) {
            CMDBaseObject *pboNew;
            if (bUnicode) {
                pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
            }
            else {
                pboNew = new CMDBaseObject((LPSTR)strName, NULL);
            }
            if (pboNew == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            else if (!pboNew->IsValid()) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                delete (pboNew);
                break;
            }
            else {
                hresReturn = pboParent->InsertChildObject(pboNew);
                if (FAILED(hresReturn)) {
                    delete (pboNew);
                    break;
                }
                else {
                    pboParent = pboNew;
                    MD_ASSERT(GetHandleObject(hHandle) != NULL);
                    GetHandleObject(hHandle)->SetChangeData(pboNew, MD_CHANGE_TYPE_ADD_OBJECT, 0);
                }
            }
        }
    }
    else if (SUCCEEDED(hresReturn)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
    }
    if (hresExtractRetCode == RETURNCODETOHRESULT(ERROR_INVALID_NAME)) {
        hresReturn = hresExtractRetCode;
    }
    return(hresReturn);
}

HRESULT RemoveObjectFromDataBase(
         IN METADATA_HANDLE hHandle,
         IN LPTSTR strPath,
         IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a metaobject and all subobjects from the database.

Arguments:

    Handle - The Meta Data handle. A handle returned by MDOpenMetaObject with write permission.

    Path   - The path of the object(s) to be created.

Return Value:

    DWORD  - ERROR_SUCCESS
             ERROR_ACCESS_DENIED
             ERROR_PATH_NOT_FOUND
             ERROR_INVALID_PARAMETER

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboDelete;
    LPTSTR strTempPath = strPath;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    //
    // Make sure that a valid path was specified
    //
    SkipPathDelimeter(strTempPath, bUnicode);
    hresReturn = ExtractNameFromPath(strTempPath, (LPSTR)strName, bUnicode);
    if (FAILED(hresReturn)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        strTempPath = strPath;
        hresReturn = GetObjectFromPath(pboDelete,
                                       hHandle,
                                       METADATA_PERMISSION_WRITE,
                                       strTempPath,
                                       bUnicode);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = (pboDelete->GetParent())->RemoveChildObject(pboDelete);
            if (SUCCEEDED(hresReturn)) {
                MD_ASSERT(GetHandleObject(hHandle) != NULL);
                if (GetHandleObject(hHandle)->SetChangeData(pboDelete, MD_CHANGE_TYPE_DELETE_OBJECT, 0)
                    != ERROR_SUCCESS) {
                    delete(pboDelete);
                }
            }
        }
    }
    return(hresReturn);
}

CMDHandle *GetHandleObject(
         IN METADATA_HANDLE hHandle)
/*++

Routine Description:

    Gets the handle object associated with Handle.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

Return Value:

    CMDHandle * - The handle object, or NULL if not found.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    for (hoCurrent = g_phHandleHead;
        (hoCurrent != NULL) && (hoCurrent->GetHandleIdentifier() != hHandle);
        hoCurrent = hoCurrent->GetNextPtr()) {
    }
    return (hoCurrent);
}

BOOL
PermissionsAvailable(
         IN CMDBaseObject *pboTest,
         IN DWORD dwRequestedPermissions,
         IN DWORD dwReadThreshHold
         )
/*++

Routine Description:

    Checks if the requested handle permissions are available for a meta object.

Arguments:

    Handle - The Meta Data handle to get. METADATA_MASTER_ROOT_HANDLE Or a handle
             returned by MDOpenMetaObject.

    RequestedPermissions - The permissions requested.

    ReadThreshHold - The number of reads allows on a write request. Normally 0.

Return Value:

    BOOL   - TRUE if the permissions are available.

Notes:

--*/
{
    BOOL bResults = TRUE;
    CMDBaseObject *pboCurrent;
    MD_ASSERT(pboTest != NULL);
    if (dwRequestedPermissions & METADATA_PERMISSION_WRITE) {
        if ((pboTest->GetReadPathCounter() != 0) ||
            (pboTest->GetWritePathCounter() != 0)) {
            bResults = FALSE;
        }
        if ((pboTest->GetReadCounter() > dwReadThreshHold) || (pboTest->GetWriteCounter() != 0)) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest->GetParent();bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if ((pboCurrent->GetReadCounter() != 0) || (pboCurrent->GetWriteCounter() != 0)) {
                bResults = FALSE;
            }
        }
    }
    else if (dwRequestedPermissions & METADATA_PERMISSION_READ) {
        if (pboTest->GetWritePathCounter() != 0) {
            bResults = FALSE;
        }
        for (pboCurrent = pboTest;bResults && (pboCurrent!=NULL);pboCurrent=pboCurrent->GetParent()) {
            if (pboCurrent->GetWriteCounter() != 0) {
                bResults = FALSE;
            }
        }
    }
    else {
        MD_ASSERT(FALSE);
    }
    return (bResults);
}

VOID RemovePermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRemovePermissions
         )
/*++

Routine Description:

    Removes the handle permissions from a meta object.

Arguments:

    Affected - The object to remove permissions from.

    RemovePermissions - The permissions to remove.

Return Value:

Notes:

--*/
{
    MD_ASSERT(pboAffected != NULL);
    CMDBaseObject *pboCurrent;
    if ((dwRemovePermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->DecrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementWritePathCounter();
        }
    }
    if ((dwRemovePermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->DecrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->DecrementReadPathCounter();
        }
    }
    
#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRemovePermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRemovePermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms releasted (%d) on ");
        cchSz = strlen(szBuf);
    
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
    
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
    
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

VOID
AddPermissions(
         IN CMDBaseObject *pboAffected,
         IN DWORD dwRequestedPermissions
         )
/*++

Routine Description:

    Adds handle permissions to a meta object.

Arguments:

    Affected - The object to remove permissions from.

    ReqyestedPermissions - The permissions to add.

Return Value:

Notes:

--*/
{
    CMDBaseObject *pboCurrent;
    if (((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) &&
        ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0)) {
        pboAffected->IncrementWriteCounter();
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
            pboCurrent->IncrementReadPathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_WRITE) != 0) {
        pboAffected->IncrementWriteCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementWritePathCounter();
        }
    }
    else if ((dwRequestedPermissions & METADATA_PERMISSION_READ) != 0) {
        pboAffected->IncrementReadCounter();
        for (pboCurrent = pboAffected->GetParent(); pboCurrent != NULL; pboCurrent = pboCurrent->GetParent()) {
            pboCurrent->IncrementReadPathCounter();
        }
    }

#if DBG
    char szBuf[1024];
    unsigned long cchSz;
    BUFFER bufName;
    unsigned long cchBuf = 0;
    int wCount;

    if (g_fShowMetaLocks)
        {
        if ((dwRequestedPermissions & (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ)) ==
                (METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read/Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_WRITE))
            {
            strcpy(szBuf, "Write");
            wCount = pboAffected->GetWriteCounter();
            }
        else if (dwRequestedPermissions & (METADATA_PERMISSION_READ))
            {
            strcpy(szBuf, "Read");
            wCount = pboAffected->GetReadCounter();
            }
        else
            {
            strcpy(szBuf, "No");
            wCount = 0;
            }

        strcat(szBuf, " perms obtained (%d) on ");
        cchSz = strlen(szBuf);
        
        GetObjectPath(pboAffected, &bufName, cchBuf, g_pboMasterRoot, FALSE);
        
        cchBuf = (cchBuf + cchSz + 2 > sizeof(szBuf)) ? sizeof(szBuf) - cchSz - 2 : cchBuf;
        memcpy(szBuf + cchSz, bufName.QueryPtr(), cchBuf);
        szBuf[cchSz + cchBuf] = '\n';
        szBuf[cchSz + cchBuf + 1] = '\0';
        
        DBGPRINTF((DBG_CONTEXT, szBuf, wCount));
        }
#endif
}

HRESULT
AddHandle(
         IN CMDBaseObject *pboAssociated,
         IN DWORD dwRequestedPermissions,
         IN METADATA_HANDLE &rmhNew
         )
/*++

Routine Description:

    Creates a handle object and adds it to the handle list.

Arguments:

    Handle - The object the handle is associated with.

    RequestedPermissions - The permissions for the handle.

    New - The handle id.

Return Value:
    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDHandle *hoNew = new CMDHandle(pboAssociated,
                                     dwRequestedPermissions,
                                     g_dwSystemChangeNumber,
                                     g_mhHandleIdentifier++);
    if (hoNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        rmhNew = hoNew->GetHandleIdentifier();
        hoNew->SetNextPtr(g_phHandleHead);
        g_phHandleHead = hoNew;
        AddPermissions(pboAssociated, dwRequestedPermissions);
    }
    return(hresReturn);
}

CMDHandle *
RemoveHandleObject(
         IN METADATA_HANDLE mhHandle
         )
/*++

Routine Description:

    Removes a handle object from the handle list.

Arguments:

    Handle - The handle to be removed.

Return Value:

    CMDHandle * - The Handle object removed.

Notes:

--*/
{
    CMDHandle *hoCurrent;
    CMDHandle *hoReturn;

    if (g_phHandleHead->GetHandleIdentifier() == mhHandle) {
        hoReturn = g_phHandleHead;
        g_phHandleHead = g_phHandleHead->GetNextPtr();
    }
    else {
        for (hoCurrent = g_phHandleHead;(hoCurrent->GetNextPtr() != NULL) &&
            (hoCurrent->GetNextPtr()->GetHandleIdentifier() != mhHandle);
            hoCurrent = hoCurrent->GetNextPtr()) {
        }
        hoReturn = hoCurrent->GetNextPtr();
        if (hoCurrent->GetNextPtr() != NULL) {
            MD_ASSERT (hoCurrent->GetNextPtr()->GetHandleIdentifier() == mhHandle);
            hoCurrent->SetNextPtr(hoCurrent->GetNextPtr()->GetNextPtr());
        }
    }
    return (hoReturn);
}

HRESULT
SaveDataObject(HANDLE hFileHandle,
               CMDBaseData *pbdSave,
               PBYTE pbLineBuf,
               DWORD dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save a data object.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Save       - The data object to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL bGoodData = TRUE;
    int iStringLen;
    PBYTE pbData;
    DWORD dwTemp;

    if ((pbdSave->GetAttributes() & METADATA_VOLATILE) == 0) {

        *pbLineBuf = MD_ID_DATA;

        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            pbLineBuf,
                            pbrNextPtr,
                            1,
                            FALSE);

        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetIdentifier();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetAttributes();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetUserType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }
        if (SUCCEEDED(hresReturn)) {
            dwTemp = pbdSave->GetDataType();
            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                (PBYTE)&dwTemp,
                                pbrNextPtr,
                                sizeof(DWORD),
                                FALSE);
        }

        if (SUCCEEDED(hresReturn)) {
            if (pbdSave->GetData(TRUE) == NULL) {
                //
                // This is to make sure that unicode conversion doesn't cause an error.
                //
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                if (IsSecureMetadata(pbdSave->GetIdentifier(), pbdSave->GetAttributes())) {
                    PIIS_CRYPTO_BLOB blob;

                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    MD_ASSERT(pCryptoStorage != NULL);

                    hresReturn = pCryptoStorage->EncryptData(&blob,
                                                          pbdSave->GetData(TRUE),
                                                          pbdSave->GetDataLen(TRUE),
                                                          0);

                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = WriteLine(hFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE)blob,
                                            pbrNextPtr,
                                            IISCryptoGetBlobLength(blob),
                                            TRUE);

                        ::IISCryptoFreeBlob(blob);
                    }
                } else {
                    hresReturn = WriteLine(hFileHandle,
                                        dwWriteBufSize,
                                        pbWriteBuf,
                                        (PBYTE)pbdSave->GetData(TRUE),
                                        pbrNextPtr,
                                        pbdSave->GetDataLen(TRUE),
                                        TRUE);
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
SaveMasterRoot(HANDLE hFileHandle,
               PBYTE pbLineBuf,
               DWORD  dwWriteBufSize,
               PBYTE pbWriteBuf,
               PBYTE &pbrNextPtr,
               IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save the master root object, including its data objects.

Arguments:

    FileHandle - File handle for use by WriteLine.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    PFILETIME pftTime;

    pftTime = g_pboMasterRoot->GetLastChangeTime();

    *pbLineBuf = MD_ID_ROOT_OBJECT;

    hresReturn = WriteLine(hFileHandle,
                        dwWriteBufSize,
                        pbWriteBuf,
                        pbLineBuf,
                        pbrNextPtr,
                        1,
                        FALSE);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = WriteLine(hFileHandle,
                            dwWriteBufSize,
                            pbWriteBuf,
                            (PBYTE)pftTime,
                            pbrNextPtr,
                            sizeof(FILETIME),
                            TRUE);
    }

    for(dwEnumObjectIndex=0,dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
        (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
        dataAssociatedData=g_pboMasterRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
        hresReturn = SaveDataObject(hFileHandle,
                                 dataAssociatedData,
                                 pbLineBuf,
                                 dwWriteBufSize,
                                 pbWriteBuf,
                                 pbrNextPtr,
                                 pCryptoStorage);
    }

    return(hresReturn);
}

HRESULT
SaveTree(
         IN HANDLE hFileHandle,
         IN CMDBaseObject *pboRoot,
         IN PBYTE pbLineBuf,
         IN BUFFER *pbufParentPath,
         IN DWORD  dwWriteBufSize,
         IN PBYTE pbWriteBuf,
         IN OUT PBYTE &pbrNextPtr,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage)
/*++

Routine Description:

    Save a tree, recursively saving child objects. This works out as
    a depth first save.

Arguments:

    FileHandle - File handle for use by WriteLine.

    Root       - The root of the tree to save.

    LineBuf    - The line buffer to write string to.

    WriteBufSize - Buffer size for use by WriteLine.

    WriteBuf   - Buffer for use by WriteLine.

    NextPtr    - Pointer into WriteBuf for use by WriteLine.

    CryptoStorage - Used to encrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    CMDBaseObject *objChildObject;
    CMDBaseData *dataAssociatedData;
    DWORD dwEnumObjectIndex;
    DWORD dwParentPathLen, dwNewParentPathLen;
    DWORD dwNameLen;
    LPWSTR strParentPath;
    PFILETIME pftTime;

    dwParentPathLen = wcslen((LPWSTR)pbufParentPath->QueryPtr());
    if (pboRoot->GetName(TRUE) == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        dwNameLen = wcslen((LPWSTR)pboRoot->GetName(TRUE));
        //
        // include 1 for delimeter and 1 for \0
        //
        dwNewParentPathLen = dwParentPathLen + dwNameLen + 2;
        if (!pbufParentPath->Resize((dwNewParentPathLen) * sizeof(WCHAR))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            strParentPath = (LPWSTR)pbufParentPath->QueryPtr();
            wcscat(strParentPath, (LPWSTR)pboRoot->GetName(TRUE));
            strParentPath[dwParentPathLen + dwNameLen] = MD_PATH_DELIMETERW;
            strParentPath[dwNewParentPathLen - 1] = (WCHAR)'\0';
            pftTime = pboRoot->GetLastChangeTime();

            *pbLineBuf = MD_ID_OBJECT;

            hresReturn = WriteLine(hFileHandle,
                                dwWriteBufSize,
                                pbWriteBuf,
                                pbLineBuf,
                                pbrNextPtr,
                                1,
                                FALSE);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE)pftTime,
                                    pbrNextPtr,
                                    sizeof(FILETIME),
                                    FALSE);
            }

            if (SUCCEEDED(hresReturn)) {
                hresReturn = WriteLine(hFileHandle,
                                    dwWriteBufSize,
                                    pbWriteBuf,
                                    (PBYTE) strParentPath,
                                    pbrNextPtr,
                                    (dwNewParentPathLen) * sizeof(WCHAR),
                                    TRUE);
            }

            if (SUCCEEDED(hresReturn)) {

                for(dwEnumObjectIndex=0,dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA);
                    (SUCCEEDED(hresReturn)) && (dataAssociatedData!=NULL);
                    dataAssociatedData=pboRoot->EnumDataObject(dwEnumObjectIndex++, 0, ALL_METADATA, ALL_METADATA)) {
                    hresReturn = SaveDataObject(hFileHandle,
                                             dataAssociatedData,
                                             pbLineBuf,
                                             dwWriteBufSize,
                                             pbWriteBuf,
                                             pbrNextPtr,
                                             pCryptoStorage);
                }

                for(dwEnumObjectIndex=0,objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++);
                    (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                    objChildObject=pboRoot->EnumChildObject(dwEnumObjectIndex++)) {
                    hresReturn = SaveTree(hFileHandle,
                                       objChildObject,
                                       pbLineBuf,
                                       pbufParentPath,
                                       dwWriteBufSize,
                                       pbWriteBuf,
                                       pbrNextPtr,
                                       pCryptoStorage);
                }
            }

            //
            // Buffer may have changed, so don't use strParentPath
            //
            ((LPWSTR)pbufParentPath->QueryPtr())[dwParentPathLen] = (WCHAR)'\0';
        }
    }

    return(hresReturn);
}

HRESULT
SaveAllData(
         IN BOOL bSetSaveDisallowed,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
         IN METADATA_HANDLE hHandle,
         IN BOOL bHaveReadSaveSemaphore
         )
/*++

Routine Description:

    Saves all meta data.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    PBYTE pbLineBuf = NULL;
    PBYTE pbWriteBuf = NULL;
    PBYTE pbNextPtr = NULL;
    BUFFER *pbufParentPath = new BUFFER(0);
    LPTSTR strTempFileName = g_strTempFileName->QueryStr();
    LPTSTR strRealFileName = g_strRealFileName->QueryStr();
    LPTSTR strBackupFileName = g_strBackupFileName->QueryStr();
    DWORD  dwWriteBufSize = READWRITE_BUFFER_LENGTH;
    HANDLE hTempFileHandle;
    CMDBaseObject *objChildObject;
    DWORD dwEnumObjectIndex;
    DWORD dwStringLen;
    BOOL bDeleteTemp = TRUE;
    DWORD dwTemp = ERROR_SUCCESS;
    DWORD dwTempLastSaveChangeNumber;
    BOOL  bSaveNeeded = FALSE;

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    if (!g_bSaveDisallowed) {
        g_bSaveDisallowed = bSetSaveDisallowed;
        pbLineBuf = new BYTE[MAX_RECORD_BUFFER];
        for ((pbWriteBuf = new BYTE[dwWriteBufSize]);
            (pbWriteBuf == NULL) && ((dwWriteBufSize/=2) >= MAX_RECORD_BUFFER);
            pbWriteBuf = new BYTE[dwWriteBufSize]) {
        }
        if ((pbWriteBuf == NULL) || (pbLineBuf == NULL)
            || (pbufParentPath == NULL) || (!pbufParentPath->Resize(MD_MAX_PATH_LEN))) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // Write to a temp file first in case there are errors.
            //

            SECURITY_ATTRIBUTES saStorage;
            PSECURITY_ATTRIBUTES psaStorage = NULL;

            if (g_psdStorage != NULL) {
                saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
                saStorage.lpSecurityDescriptor = g_psdStorage;
                saStorage.bInheritHandle = FALSE;
                psaStorage = &saStorage;
            }

            hTempFileHandle = CreateFile(strTempFileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         psaStorage,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         0);
            if (hTempFileHandle == INVALID_HANDLE_VALUE) {
                DWORD dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
            else {
                g_rMasterResource->Lock(TSRES_LOCK_READ);

                //
                // Only Save if changes have been made since the last save.
                //

                if (g_dwLastSaveChangeNumber != g_dwSystemChangeNumber) {

                    //
                    //
                    //

                    bSaveNeeded = TRUE;

                    if (hHandle != METADATA_MASTER_ROOT_HANDLE) {
                        CMDHandle *phoHandle;
                        phoHandle = GetHandleObject(hHandle);
                        if ((phoHandle == NULL) || (phoHandle->GetObject() != g_pboMasterRoot)) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                        }
                        else if ((!phoHandle->IsReadAllowed()) && (!phoHandle->IsWriteAllowed())) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_ACCESS_DENIED);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        *(LPWSTR)pbufParentPath->QueryPtr() = MD_PATH_DELIMETERW;
                        ((LPWSTR)pbufParentPath->QueryPtr())[1] = (WCHAR)'\0';
                        pbNextPtr = pbWriteBuf;
                        hresReturn = WriteLine(hTempFileHandle,
                                            dwWriteBufSize,
                                            pbWriteBuf,
                                            (PBYTE) MD_SIGNATURE_STRINGW,
                                            pbNextPtr,
                                            sizeof(MD_SIGNATURE_STRINGW),
                                            TRUE);
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MAJOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMajorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf = MD_ID_MINOR_VERSION_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwMinorVersionNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            *pbLineBuf =  MD_ID_CHANGE_NUMBER;
                            *((UNALIGNED DWORD *)(pbLineBuf + 1)) = g_dwSystemChangeNumber;
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + sizeof(DWORD),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            //
                            // Write the session key blob to the file.
                            //
                            *pbLineBuf =  MD_ID_SESSION_KEY;
                            memcpy((PCHAR)pbLineBuf+1, (PCHAR)pSessionKeyBlob, IISCryptoGetBlobLength(pSessionKeyBlob));
                            hresReturn = WriteLine(hTempFileHandle,
                                                dwWriteBufSize,
                                                pbWriteBuf,
                                                pbLineBuf,
                                                pbNextPtr,
                                                1 + IISCryptoGetBlobLength(pSessionKeyBlob),
                                                TRUE);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SaveMasterRoot(hTempFileHandle,
                                                     pbLineBuf,
                                                     dwWriteBufSize,
                                                     pbWriteBuf,
                                                     pbNextPtr,
                                                     pCryptoStorage);

                            for(dwEnumObjectIndex=0,objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++);
                                (SUCCEEDED(hresReturn)) && (objChildObject!=NULL);
                                objChildObject=g_pboMasterRoot->EnumChildObject(dwEnumObjectIndex++)) {
                                hresReturn = SaveTree(hTempFileHandle,
                                                   objChildObject,
                                                   pbLineBuf,
                                                   pbufParentPath,
                                                   dwWriteBufSize,
                                                   pbWriteBuf,
                                                   pbNextPtr,
                                                   pCryptoStorage);
                            }
                        }
                    }

                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;

                }

                //
                // Release lock before writing to file.
                //

                g_rMasterResource->Unlock();

                if (bSaveNeeded && SUCCEEDED(hresReturn)) {

                    hresReturn = FlushWriteBuf(hTempFileHandle,
                                           pbWriteBuf,
                                           pbNextPtr);
                }


                //
                // FlushFileBuffers was added trying to solve 390968 when metabase
                // sometimes becomes corrupted during resets.  That should ensure that data
                // is already on the disk when doing later MoveFile operations
                //
                
                if (!FlushFileBuffers (hTempFileHandle)) {
                    hresReturn = GetLastError();
    			    DBGPRINTF(( DBG_CONTEXT, "Failed FlushFileBuffers - error 0x%0x\n", hresReturn));
                }

                //
                // Always close the file handle
                //

                if (!CloseHandle(hTempFileHandle)) {
                    hresReturn = GetLastError();
                }

            }
            if (SUCCEEDED(hresReturn) && bSaveNeeded) {
                //
                // New data file created successfully
                // Backup real file and copy temp
                // to real
                //
                if (!MoveFile(strTempFileName, strRealFileName)) {
                    if (GetLastError() != ERROR_ALREADY_EXISTS) {
                        dwTemp = GetLastError();
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    //
                    // Real File exists, so back it up
                    //
                    else if (!MoveFile(strRealFileName, strBackupFileName)) {
                        //
                        // backup failed, check for old backup file
                        //
                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            dwTemp = GetLastError();
                        }
                        else if (!DeleteFile(strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        else if (!MoveFile(strRealFileName, strBackupFileName)) {
                            dwTemp = GetLastError();
                        }
                        hresReturn = RETURNCODETOHRESULT(dwTemp);
                    }
                    if (SUCCEEDED(hresReturn)) {
                        BOOL bDeleteBackup = TRUE;
                        //
                        // Real file is backed up
                        // so move in new file
                        //
                        if (!MoveFile(strTempFileName, strRealFileName)) {
                            dwTemp = GetLastError();
                            hresReturn = RETURNCODETOHRESULT(dwTemp);
                            //
                            // Moved real to backup but
                            // failed to move temp to real
                            // so restore from backup
                            //
                            if (!MoveFile(strBackupFileName, strRealFileName)) {
                                //
                                // Unable to write new file
                                // or restore original file so don't delete backup
                                //
                                bDeleteBackup = FALSE;
                            }
                        }
                        if (bDeleteBackup) {
                            DeleteFile(strBackupFileName);
                        }
                    }
                    if (FAILED(hresReturn)) {
                        //
                        // temp file was created ok but a problem
                        // occurred while moving it to real
                        // so don't delete it
                        //
                        bDeleteTemp = FALSE;
                    }
                    else {

                        //
                        // Update Change Number
                        // Must have ReadSaveSemaphore when accessing this.
                        //

                        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
                    }
                }
            }
            if (bDeleteTemp && (hTempFileHandle != INVALID_HANDLE_VALUE)) {
                DeleteFile(strTempFileName);
            }
        }
    }

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }

    if ( pbufParentPath != NULL ) {
        delete(pbufParentPath);
    }

    if ( pbWriteBuf != NULL ) {
        delete(pbWriteBuf);
    }

    if ( pbLineBuf != NULL ) {
        delete(pbLineBuf);
    }

    if ( FAILED( hresReturn )) {
        DBGPRINTF(( DBG_CONTEXT, "Failed to flush metabase - error 0x%08lx\n", hresReturn));
    } else {
        //DBGPRINTF(( DBG_CONTEXT, "Successfully flushed metabase to disk\n" ));
    }

    return hresReturn;
}

DWORD
DeleteKeyFromRegistry(HKEY hkeyParent,
                      LPTSTR pszCurrent)
/*++

Routine Description:

    Deletes a key and all data and subkeys from the registry.

    RECURSIVE ROUTINE! DO NOT USE STACK!

Arguments:

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn;
    LPTSTR pszName;

    MDRegKey *pmdrkCurrent = new MDRegKey(hkeyParent,
                                          pszCurrent);
    if (pmdrkCurrent == NULL) {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        dwReturn = GetLastError();
    }
    if (dwReturn == ERROR_SUCCESS) {
        MDRegKeyIter *pmdrkiCurrent = new MDRegKeyIter(*pmdrkCurrent);
        if (pmdrkiCurrent == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            dwReturn = GetLastError();
        }
        while ((dwReturn == ERROR_SUCCESS) &&
            (dwReturn = pmdrkiCurrent->Next(&pszName, NULL, 0)) == ERROR_SUCCESS) {
            dwReturn = DeleteKeyFromRegistry(*pmdrkCurrent,
                                              pszName);
        }
        delete (pmdrkiCurrent);
        if (dwReturn == ERROR_NO_MORE_ITEMS) {
            dwReturn = ERROR_SUCCESS;
        }
    }
    delete (pmdrkCurrent);

    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(hkeyParent,
                                pszCurrent);
    }
    return dwReturn;
}

HRESULT
ReadMetaObject(
         IN CMDBaseObject *&cboRead,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a meta object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Read       - Place to return the created object.

    ObjectLine - The object info.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS

Notes:

--*/
{
    HRESULT hresReturn;
    CMDBaseObject *pboParent;
    WCHAR strName[METADATA_MAX_NAME_LEN];
    FILETIME ftTime;
    PFILETIME pftParentTime;
    FILETIME ftParentTime;
    PBYTE pbLine = (PBYTE)pbufLine->QueryPtr();
    LPTSTR strObjectName;

    if ((dwLineLen <= BASEMETAOBJECTLENGTH) || (*(pbLine + dwLineLen - 1) != '\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        ftTime = *(UNALIGNED FILETIME *)(pbLine + 1);
        //
        // GetObjectFromPath checks permissions on the handle
        // This only gets called from init so just tell it read.
        //
        strObjectName = (LPTSTR)(pbLine + BASEMETAOBJECTLENGTH);
        hresReturn = GetObjectFromPath(pboParent,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    METADATA_PERMISSION_READ,
                                    strObjectName,
                                    bUnicode);

        //
        // This should return ERROR_PATH_NOT_FOUND and the parent object,
        // with strObjectLine set to the remainder of the path,
        // which should be the child name, without a preceding delimeter.
        //

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            MD_ASSERT(pboParent != NULL);
            if (bUnicode) {
                hresReturn = ExtractNameFromPath((LPWSTR *)&strObjectName, (LPWSTR)strName);
            }
            else {
                hresReturn = ExtractNameFromPath((LPSTR)strObjectName, (LPSTR)strName);
            }
            if (SUCCEEDED(hresReturn)) {
                CMDBaseObject *pboNew;
                if (bUnicode) {
                    pboNew = new CMDBaseObject((LPWSTR)strName, NULL);
                }
                else {
                    pboNew = new CMDBaseObject((LPSTR)strName, NULL);
                }
                if (pboNew == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else if (!pboNew->IsValid()) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    delete (pboNew);
                }
                else {
                    //
                    // InsertChildObject sets the last change time to current time.
                    // This isn't really a change, so save and restore time.
                    //
                    pftParentTime = pboParent->GetLastChangeTime();
                    ftParentTime = *pftParentTime;
                    hresReturn = pboParent->InsertChildObject(pboNew);
                    if (SUCCEEDED(hresReturn)) {
                        pboParent->SetLastChangeTime(&ftParentTime);
                        pboNew->SetLastChangeTime(&ftTime);
                        cboRead = pboNew;
                    }
                    else {
                        delete (pboNew);
                    }
                }
            }
        }
        else if (SUCCEEDED(hresReturn)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
        }
    }
    return (hresReturn);
}

HRESULT
ReadDataObject(
         IN CMDBaseObject *cboAssociated,
         IN BUFFER *pbufLine,
         IN DWORD dwLineLen,
         IN IIS_CRYPTO_STORAGE *pCryptoStorage,
         IN BOOL bUnicode)
/*++

Routine Description:

    Read a data object. Given a string with the object info.,
    create the object and add it to the database.

Arguments:

    Associated - The associated meta object.

    DataLine   - The data info.

    BinaryBuf  - Buffer to use in UUDecode.

    CryptoStorage - Used to decrypt secure data.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 ERROR_ALREADY_EXISTS
                 ERROR_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    PFILETIME pftTime;
    FILETIME ftTime;
    PBYTE pbDataLine = (PBYTE)pbufLine->QueryPtr();
    PBYTE pbDataValue;
    DWORD dwDataLength;
    PIIS_CRYPTO_BLOB blob = NULL;

    if (dwLineLen < DATAOBJECTBASESIZE) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        MD_ASSERT(pbufLine->QuerySize() >= DATAOBJECTBASESIZE);
        mdrData.dwMDIdentifier = *(UNALIGNED DWORD *)(pbDataLine + 1);
        mdrData.dwMDAttributes = *(UNALIGNED DWORD *)(pbDataLine + 1 + sizeof(DWORD));
        mdrData.dwMDUserType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (2 * sizeof(DWORD)));
        mdrData.dwMDDataType = *(UNALIGNED DWORD *)(pbDataLine + 1 + (3 * sizeof(DWORD)));

        pbDataValue = pbDataLine + DATAOBJECTBASESIZE;
        dwDataLength = dwLineLen - DATAOBJECTBASESIZE;

        if (IsSecureMetadata(mdrData.dwMDIdentifier, mdrData.dwMDAttributes) &&
            pCryptoStorage != NULL) {

            //
            // This is a secure data object, we we'll need to decrypt it
            // before proceeding. Note that we must clone the blob before
            // we can actually use it, as the blob data in the line buffer
            // is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
            // the only IISCrypto function that can handle unaligned data.)
            //

            hresReturn = ::IISCryptoCloneBlobFromRawData(
                             &blob,
                             pbDataValue,
                             dwDataLength
                             );

            if (SUCCEEDED(hresReturn)) {
                DWORD dummyRegType;

                MD_ASSERT(::IISCryptoIsValidBlob(blob));
                hresReturn = pCryptoStorage->DecryptData(
                               (PVOID *)&pbDataValue,
                               &dwDataLength,
                               &dummyRegType,
                               blob
                               );

            }
        }

        if (SUCCEEDED(hresReturn)) {
            mdrData.pbMDData = pbDataValue;

            switch (mdrData.dwMDDataType) {
                case DWORD_METADATA: {
                    if (dwDataLength != sizeof(DWORD)) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if ((LONG)dwDataLength < 1 ||
                        (!bUnicode && (pbDataValue[dwDataLength-1] != '\0')) ||
                        (bUnicode && *(((LPWSTR)pbDataValue) + ((dwDataLength / sizeof(WCHAR)) -1)) != (WCHAR)'\0')) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                    }
                    break;
                }
                case BINARY_METADATA:
                {
                    mdrData.dwMDDataLen = dwDataLength;
                    break;
                }
                case MULTISZ_METADATA:
                {
                    if (bUnicode) {
                        if (dwDataLength < (2 * sizeof(WCHAR)) ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-1)) != (WCHAR)'\0' ||
                            *((LPWSTR)pbDataValue + ((dwDataLength / sizeof(WCHAR))-2)) != (WCHAR)'\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    else {
                        if (dwDataLength < 2 ||
                            pbDataValue[dwDataLength-1] != '\0' ||
                            pbDataValue[dwDataLength-2] != '\0') {
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {
                        mdrData.dwMDDataLen = dwDataLength;
                    }
                    break;
                }
                default: {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        //
        // SetDataObject sets the last change time to current time.
        // This isn't really a change, so save and restore time.
        //
        pftTime = cboAssociated->GetLastChangeTime();
        ftTime = *pftTime;
        hresReturn = cboAssociated->SetDataObject(&mdrData, bUnicode);
        cboAssociated->SetLastChangeTime(&ftTime);
    }

    if (blob != NULL) {
        ::IISCryptoFreeBlob(blob);
    }

    return(hresReturn);
}

HRESULT
FlushWriteBuf(HANDLE hWriteFileHandle,
              PBYTE pbWriteBuf,
              PBYTE &pbrNextPtr)
/*++

Routine Description:

    Flush the write buffer to the file.

Arguments:

    FileHandle - File handle to write to.

    WriteBuf   - Buffer to write to file.

    NextPtr    - Pointer past end of buffer.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesWritten;
    if (pbrNextPtr > pbWriteBuf) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       DIFF((BYTE *)pbrNextPtr - (BYTE *)pbWriteBuf),
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

BOOL
CopyLineWithEscapes(PBYTE &pbrFileBuf,
                    DWORD &dwrFileBufLen,
                    PBYTE &pbrLineBuf,
                    DWORD &dwrLineBufLen,
                    BOOL  &brMidEscape)
    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbrFileBuf, dwrFileBufLen, brMidEscape
    // FAILURE: pbrLineBuf, dwrLineBufLen, brMidEscape
    // On FAILURE, it fills to the end of the buffer
    //
{
    BOOL bReturn = TRUE;
    PBYTE pbFileBufEnd = pbrFileBuf + dwrFileBufLen;
    PBYTE pbLineBufEnd = pbrLineBuf + dwrLineBufLen;
    PBYTE pbFileBufIndex = pbrFileBuf;
    PBYTE pbLineBufIndex = pbrLineBuf;

    brMidEscape = FALSE;

    while ((pbLineBufIndex < pbLineBufEnd) && (pbFileBufIndex < (pbFileBufEnd - 1))) {
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
        }
        *pbFileBufIndex++ = *pbLineBufIndex++;
    }
    if ((pbLineBufIndex != pbLineBufEnd) && (pbFileBufIndex < pbFileBufEnd)) {
        MD_ASSERT(pbFileBufIndex == (pbFileBufEnd - 1));
        //
        // file last byte in buffer
        //
        if (NEEDS_ESCAPE(*pbLineBufIndex)) {
            *pbFileBufIndex++ = MD_ESCAPE_BYTE;
            brMidEscape = TRUE;
        }
        else {
            *pbFileBufIndex++ = *pbLineBufIndex++;
        }
    }
    if (pbLineBufIndex != pbLineBufEnd) {
        bReturn = FALSE;
        pbrLineBuf = pbLineBufIndex;
        dwrLineBufLen = DIFF(pbLineBufEnd - pbLineBufIndex);
    }
    else {
        pbrFileBuf = pbFileBufIndex;
        dwrFileBufLen = DIFF(pbFileBufEnd - pbFileBufIndex);
    }

    return bReturn;
}


HRESULT
WriteLine(HANDLE hWriteFileHandle,
          DWORD  dwWriteBufSize,
          PBYTE  pbWriteBuf,
          PBYTE  pbLineBuf,
          PBYTE  &pbNextPtr,
          DWORD  dwLineLen,
          BOOL   bTerminate)
/*++

Routine Description:

    Write a line. Performs buffered writes to a file. Does not append \n.
    The string does not need to be terminated with \0.

Arguments:

    FileHandle - File to write to.

    WriteBufSize - Buffer size.

    WriteBuf   - Buffer to store data in.

    LineBuf    - The line buffer with data to write.

    NextPtr    - Pointer to the next unused character in WriteBuf.

    Len        - The number of characters to write.

Return Value:

    DWORD      - ERROR_SUCCESS
                 Return codes from file system

Notes:

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    PBYTE pbWriteBufEnd = pbWriteBuf + dwWriteBufSize;
    DWORD dwBufferBytesLeft = DIFF(pbWriteBufEnd - pbNextPtr);
    DWORD dwBytesWritten;
    BOOL  bMidEscape;

    MD_ASSERT(pbLineBuf != NULL);
    MD_ASSERT(pbWriteBuf != NULL);
    MD_ASSERT((pbNextPtr >= pbWriteBuf) && (pbNextPtr <= pbWriteBufEnd));

    //
    // CopyLineWithExcapes updates parameters.
    // SUCCESS: pbNextPtr, dwBufferBytesLeft
    // FAILURE: pbLineBuf, dwLineLen, bMidEscape
    // On FAILURE, it fills to the end of the buffer
    //

    while ((dwReturn == ERROR_SUCCESS) &&
        (!CopyLineWithEscapes(pbNextPtr, dwBufferBytesLeft, pbLineBuf, dwLineLen, bMidEscape))) {
        if (!WriteFile(hWriteFileHandle,
                       pbWriteBuf,
                       dwWriteBufSize,
                       &dwBytesWritten,
                       NULL)) {
            dwReturn = GetLastError();
        }
        dwBufferBytesLeft = dwWriteBufSize;
        pbNextPtr = pbWriteBuf;
        if (bMidEscape) {
            *pbNextPtr++ = *pbLineBuf++;
            dwBufferBytesLeft--;
            dwLineLen--;
        }
    }
    if (bTerminate && (dwReturn == ERROR_SUCCESS)) {
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_ESCAPE_BYTE;
        dwBufferBytesLeft--;
        if (dwBufferBytesLeft == 0) {
            if (!WriteFile(hWriteFileHandle,
                           pbWriteBuf,
                           dwWriteBufSize,
                           &dwBytesWritten,
                           NULL)) {
                dwReturn = GetLastError();
            }
            dwBufferBytesLeft = dwWriteBufSize;
            pbNextPtr = pbWriteBuf;
        }
        *pbNextPtr++ = MD_TERMINATE_BYTE;
    }
    return (RETURNCODETOHRESULT(dwReturn));
}

PBYTE
FindEndOfData(PBYTE pbNextPtr,
              PBYTE pbEndReadData,
              BOOL bEscapePending)
{
    PBYTE pbIndex = pbNextPtr;
    BOOL bEndFound = FALSE;

    if ((pbEndReadData > pbIndex) && bEscapePending) {
        if (*pbIndex == MD_TERMINATE_BYTE) {
            bEndFound = TRUE;
        }
        pbIndex++;
    }
    while ((pbEndReadData -1 > pbIndex) && !bEndFound) {
        if (*pbIndex == MD_ESCAPE_BYTE) {
            pbIndex++;
            if (*pbIndex == MD_TERMINATE_BYTE) {
                bEndFound = TRUE;
            }
        }
        pbIndex++;
    }
    if (!bEndFound) {
        MD_ASSERT(pbIndex == pbEndReadData - 1);
        pbIndex++;
    }
    return pbIndex;
}

DWORD
GetLineFromBuffer(PBYTE &pbrNextPtr,
                  PBYTE &pbrEndReadData,
                  BUFFER *pbufLine,
                  DWORD &dwrLineLen,
                  BOOL &brEscapePending)
    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //
{
    DWORD dwReturn = ERROR_HANDLE_EOF;
    PBYTE pbLineIndex;
    DWORD dwBytesToRead;
    PBYTE pbEndReadLine;
    PBYTE pbReadDataIndex = pbrNextPtr;

    if (pbrNextPtr != pbrEndReadData) {
        //
        // first find out how many bytes we need to read
        //
        pbEndReadLine = FindEndOfData(pbrNextPtr, pbrEndReadData, brEscapePending);
        MD_ASSERT(pbEndReadLine > pbrNextPtr);

        //
        // Actual number of bytes needed may be less than the size of the data
        // but never more, so just resize for the max we might need
        //
        if (!pbufLine->Resize(dwrLineLen + DIFF(pbEndReadLine - pbrNextPtr))) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pbLineIndex = (PBYTE)pbufLine->QueryPtr() + dwrLineLen;
            if (brEscapePending) {
                brEscapePending = FALSE;
                if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                    dwReturn = ERROR_SUCCESS;
                    pbReadDataIndex++;
                }
            }
            while ((dwReturn != ERROR_SUCCESS) && (pbReadDataIndex < pbEndReadLine)) {
                if (*pbReadDataIndex != MD_ESCAPE_BYTE) {
                    *pbLineIndex++ = *pbReadDataIndex++;
                }
                else {
                    pbReadDataIndex++;
                    if (pbReadDataIndex == pbEndReadLine) {
                        brEscapePending = TRUE;
                    }
                    else {
                        if (*pbReadDataIndex == MD_ESCAPE_BYTE) {
                            *pbLineIndex++ = *pbReadDataIndex++;
                        }
                        else {
                            MD_ASSERT(*pbReadDataIndex == MD_TERMINATE_BYTE);
                            pbReadDataIndex++;
                            dwReturn = ERROR_SUCCESS;
                        }
                    }
                }
            }
            dwrLineLen = DIFF(pbLineIndex - (PBYTE)pbufLine->QueryPtr());
            pbrNextPtr = pbReadDataIndex;
        }
    }
    return dwReturn;
}

HRESULT
GetNextLine(
         IN HANDLE hReadFileHandle,
         IN OUT PBYTE &pbrEndReadData,
         IN BUFFER *pbufRead,
         IN OUT BUFFER *pbufLine,
         IN OUT DWORD &dwrLineLen,
         IN OUT PBYTE &pbrNextPtr)
/*++

Routine Description:

    Get the next line. Performs buffered reads from a file. Only pbrCurPtr may be modified between calls.
    Other variables must be set up before the first call and not changed.

Arguments:

    ReadFileHandle - File to write to.

    EndReadDataPtr - Points past the end of the data in ReadBuf.

    Read       - Buffer for file data.

    Line       - A line buffer which the returned line is stored in.

    LineLen    - The length of the data in line

    NextPtr    - On entry, pointer to the next unread character in ReadBuf.
                 On exit, pointer to the new next unread character in ReadBuf.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_INVALID_DATA
                 Return codes from file system

Notes:
    On EOF, returns ERROR_SUCCESS, dwrLineLen = 0.

--*/
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwLineLen = 0;
    BOOL bEscapePending = FALSE;
    DWORD dwGetLineReturn = ERROR_HANDLE_EOF;
    BOOL bEOF = FALSE;

    //
    // GetLineFromBuffer modifies variables!!!!
    // SUCCESS: pbrNextPtr, pbufLine, dwrLineLen
    // FAILURE: pbrNextPtr, pbufLine, dwrLineLen, bEscapePending
    //

    while ((dwReturn == ERROR_SUCCESS) && (dwGetLineReturn == ERROR_HANDLE_EOF) && (!bEOF)) {

        dwGetLineReturn = GetLineFromBuffer(pbrNextPtr,
                                            pbrEndReadData,
                                            pbufLine,
                                            dwLineLen,
                                            bEscapePending);

        if (dwGetLineReturn == ERROR_HANDLE_EOF) {
            if (!ReadFile(hReadFileHandle,
                          (LPVOID) pbufRead->QueryPtr(),
                          pbufRead->QuerySize(),
                          &dwBytesRead,
                          NULL)) {
                dwReturn = GetLastError();
            }
            else {
                pbrEndReadData = (BYTE *)pbufRead->QueryPtr() + dwBytesRead;
                pbrNextPtr = (PBYTE)pbufRead->QueryPtr();
                if (dwBytesRead == 0) {
                    bEOF = TRUE;
                }
            }
        }
    }
    if (bEOF) {
        MD_ASSERT(dwGetLineReturn = ERROR_HANDLE_EOF);
        dwLineLen = 0;
    }
    else if (dwGetLineReturn != ERROR_SUCCESS) {
        dwReturn = dwGetLineReturn;
    }

    dwrLineLen = dwLineLen;
    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
GetLineID(
         IN OUT LPTSTR &strCurPtr)
/*++

Routine Description:

    Determines the ID of a line from the metadata file.

Arguments:

    CurPtr     - The line to ID. Updated on successful ID to point past
                 the id string.

Return Value:

    DWORD      - MD_ID_OBJECT
                 MD_ID_DATA
                 MD_ID_REFERENCE
                 MD_ID_ROOT_OBJECT
                 MD_ID_NONE

Notes:

--*/
{
    DWORD dwLineID;
    if (MD_STRNICMP(strCurPtr, MD_OBJECT_ID_STRING, ((sizeof(MD_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_DATA_ID_STRING, ((sizeof(MD_DATA_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_DATA;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_DATA_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_REFERENCE_ID_STRING, ((sizeof(MD_REFERENCE_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_REFERENCE;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_REFERENCE_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_ROOT_OBJECT_ID_STRING, ((sizeof(MD_ROOT_OBJECT_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_ROOT_OBJECT;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_ROOT_OBJECT_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_CHANGE_NUMBER_ID_STRING, ((sizeof(MD_CHANGE_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_CHANGE_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_CHANGE_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MAJOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MAJOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MAJOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else if (MD_STRNICMP(strCurPtr, MD_MINOR_VERSION_NUMBER_ID_STRING, ((sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING)/sizeof(TCHAR)) - 1)) == 0) {
        dwLineID = MD_ID_MINOR_VERSION_NUMBER;
        strCurPtr = (LPTSTR)((BYTE *)strCurPtr + (sizeof(MD_MINOR_VERSION_NUMBER_ID_STRING) - sizeof(TCHAR)));
    }
    else {
        dwLineID = MD_ID_NONE;
    }
    return(dwLineID);
}

HRESULT
GetWarning(
         IN HRESULT hresWarningCode)
/*++

Routine Description:

    Converts error to warnings.

Arguments:

    WarnignCode - The error code to convert.

Return Value:

    DWORD      - MD_WARNING_PATH_NOT_FOUND
                 MD_WARNING_DUP_NAME
                 MD_WARNING_INVALID_DATA

Notes:

--*/
{
    HRESULT hresReturn;
    switch (hresWarningCode) {
        case (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)):
            hresReturn = MD_WARNING_PATH_NOT_FOUND;
            break;
        case (RETURNCODETOHRESULT(ERROR_DUP_NAME)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        case (RETURNCODETOHRESULT(ERROR_INVALID_DATA)):
            hresReturn = MD_WARNING_INVALID_DATA;
            break;
        case (RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS)):
            hresReturn = MD_WARNING_DUP_NAME;
            break;
        default:
            hresReturn = hresWarningCode;
    }
    return (hresReturn);
}

BOOL CheckDigits(LPTSTR pszString)
{
    LPTSTR pszTemp;
    BOOL bDigitFound = FALSE;
    BOOL bReturn = FALSE;
    for (pszTemp = pszString;MD_ISDIGIT(*pszTemp); pszTemp++) {
        bDigitFound = TRUE;
    }
    if (bDigitFound && (*pszTemp == (TCHAR)'\0')) {
        bReturn = TRUE;
    }
    return bReturn;
}

HRESULT
InitStorageHelper(
    PBYTE RawBlob,
    DWORD RawBlobLength,
    IIS_CRYPTO_STORAGE **NewStorage
    )
/*++

Routine Description:

    Helper routine to create and initialize a new IIS_CRYPTO_STORAGE
    object from an unaligned blob.

Arguments:

    RawBlob - Pointer to the raw unaligned session key blob.

    RawBlobLength - Length of the raw blob data.

    NewStorage - Receives a pointer to the new IIS_CRYPTO_STORAGE object
        if successful.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    PIIS_CRYPTO_BLOB alignedBlob;
    IIS_CRYPTO_STORAGE *storage = NULL;
    HRESULT hresReturn = NO_ERROR;

    //
    // Make a copy of the blob. This is necessary, as the incoming
    // raw blob pointer is most likely not DWORD-aligned.
    //

    hresReturn = ::IISCryptoCloneBlobFromRawData(
                   &alignedBlob,
                   RawBlob,
                   RawBlobLength
                   );

    if (SUCCEEDED(hresReturn)) {
        //
        // Create a new IIS_CRYPTO_STORAGE object and initialize it from
        // the DWORD-aligned blob.
        //

        storage = new IIS_CRYPTO_STORAGE();

        if (storage == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            HCRYPTPROV hProv;

            hresReturn = GetCryptoProvider( &hProv );

            if (SUCCEEDED(hresReturn)) {
                hresReturn = storage->Initialize(
                             alignedBlob,
                             TRUE,          // fUseMachineKeyset
                             hProv
                             );
            }

            if (FAILED(hresReturn)) {
                delete storage;
                storage = NULL;
            }
        }

        ::IISCryptoFreeBlob(alignedBlob);
    }

    *NewStorage = storage;
    return hresReturn;

}   // InitStorageHelper


HRESULT
ReadAllData(BOOL bHaveReadSaveSemaphore)
/*++

Routine Description:

    Reads all meta data from a file.

Arguments:

Return Value:

    HRESULT    - ERROR_SUCCESS
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    HRESULT hresWarningCode = ERROR_SUCCESS;
    PBYTE  pbEndReadData;
    PBYTE  pbNextPtr;
    DWORD  dwLineLen;
    LPTSTR strReadFileName = g_strRealFileName->QueryStr();
    HANDLE hReadFileHandle;
    BYTE   bLineId;
    DWORD  dwTemp;
    CMDBaseObject *pboRead;
    FILETIME ftTime;
    BUFFER *pbufRead = new BUFFER(0);
    BUFFER *pbufLine = new BUFFER(0);
    IIS_CRYPTO_STORAGE *pStorage = NULL;
    BOOL bUnicode;
    DWORD dwTempLastSaveChangeNumber;

    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
    }
    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(strReadFileName,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0);

    if (hReadFileHandle == INVALID_HANDLE_VALUE) {
        dwTemp = GetLastError();
        hresReturn = RETURNCODETOHRESULT(dwTemp);
    }
    else {
        //
        // Allocate Buffers
        //
        if (!pbufLine->Resize(MAX_RECORD_BUFFER) ||
            !pbufRead->Resize(READWRITE_BUFFER_LENGTH)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            pbEndReadData = (PBYTE)pbufRead->QueryPtr();
            //
            // GetNextLine makes sure that the next line is in the buffer and sets strCurPtr to point to it
            // The line is NULL terminated, no new line. The variables passed in must not be modified outside
            // of GetNextLine.
            //
            dwLineLen = 0;
            pbNextPtr = pbEndReadData;
            hresReturn = GetNextLine(hReadFileHandle,
                                  pbEndReadData,
                                  pbufRead,
                                  pbufLine,
                                  dwLineLen,
                                  pbNextPtr);
            if (SUCCEEDED(hresReturn)) {
                //
                // See if it's our file
                //
                if (dwLineLen == sizeof(MD_SIGNATURE_STRINGA) &&
                    (MD_CMP(MD_SIGNATURE_STRINGA, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = FALSE;
                }
                else if  (dwLineLen == sizeof(MD_SIGNATURE_STRINGW) &&
                    (MD_CMP(MD_SIGNATURE_STRINGW, pbufLine->QueryPtr(), dwLineLen) == 0)) {
                    bUnicode = TRUE;
                }
                else {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }

                if (SUCCEEDED(hresReturn)) {
                    //
                    // The first GetNextLine filled the buffer
                    // so we may not need to do any file system stuff
                    // with g_rMasterResource locked.
                    //
                    g_rMasterResource->Lock(TSRES_LOCK_WRITE);

                    while ((SUCCEEDED(hresReturn)) &&
                           (SUCCEEDED(hresReturn = GetNextLine(hReadFileHandle,
                                                   pbEndReadData,
                                                   pbufRead,
                                                   pbufLine,
                                                   dwLineLen,
                                                   pbNextPtr))) &&
                           (dwLineLen > 0) &&
                           (((bLineId = *(BYTE *)(pbufLine->QueryPtr())) == MD_ID_NONE) ||
                               (bLineId == MD_ID_MAJOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_MINOR_VERSION_NUMBER) ||
                               (bLineId == MD_ID_CHANGE_NUMBER) ||
                               (bLineId == MD_ID_SESSION_KEY))) {

                        if (bLineId != MD_ID_NONE) {
                            if (bLineId != MD_ID_SESSION_KEY &&
                                dwLineLen != (1 + sizeof(DWORD))) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                            }
                            else {
                                dwTemp = *(UNALIGNED DWORD *)FIRSTDATAPTR(pbufLine);
                                switch (bLineId) {
                                case MD_ID_MAJOR_VERSION_NUMBER:
                                    g_dwMajorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_MINOR_VERSION_NUMBER:
                                    g_dwMinorVersionNumber = dwTemp;
                                    break;
                                case MD_ID_CHANGE_NUMBER:
                                    g_dwSystemChangeNumber = dwTemp;
                                    break;
                                case MD_ID_SESSION_KEY:
                                    {
                                        BOOL    fSecuredRead = TRUE;
                                        HKEY    hkRegistryKey = NULL;
                                        DWORD   dwRegReturn, dwValue,dwType,dwSize = sizeof(DWORD);

                                            dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                                                                     SETUP_REG_KEY,
                                                                     &hkRegistryKey);
                                            if (dwRegReturn == ERROR_SUCCESS) 
                                            {
                                                dwSize = MAX_PATH * sizeof(TCHAR);
                                                dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                                                MD_UNSECUREDREAD_VALUE,
                                                                NULL,
                                                                &dwType,
                                                                (BYTE *)&dwValue,
                                                                &dwSize);
                                                if ( dwRegReturn == ERROR_SUCCESS && 
                                                     dwType == REG_DWORD &&
                                                     dwValue == 1)
                                                {
                                                    hresReturn = NO_ERROR;
                                                    pStorage = NULL;
                                                    fSecuredRead = FALSE;

                                                    DBGPRINTF(( DBG_CONTEXT,
                                                                "Temporary disabling  decryption for metabase read\n"));


                                                    // special indicator for IIS setup that we passed this point
                                                    dwValue = 2;
                                                    dwRegReturn = RegSetValueEx(hkRegistryKey,
                                                                    MD_UNSECUREDREAD_VALUE,
                                                                    0,
                                                                    REG_DWORD,
                                                                    (PBYTE)&dwValue,
                                                                    sizeof(dwValue));
                                                    if (dwRegReturn == ERROR_SUCCESS) 
                                                    {
                                                        DBGPRINTF(( DBG_CONTEXT,"Reanabling decryption after W9z upgrade\n"));
                                                    }

                                                }
                                                MD_REQUIRE( RegCloseKey( hkRegistryKey ) == NO_ERROR );
                                            }

                                        if (fSecuredRead)
                                        {
                                            if (IISCryptoIsClearTextSignature((IIS_CRYPTO_BLOB UNALIGNED *) FIRSTDATAPTR(pbufLine)))
                                            {
                                                    // call special function focibly tell that this machine has no 
                                                    // encryption enabled even if it happens to be so
                                                    // that's a special handling for French case with US locale
                                                    IISCryptoInitializeOverride (FALSE);
                                            }


                                            hresReturn = InitStorageHelper(
                                                           FIRSTDATAPTR(pbufLine),
                                                           dwLineLen-1,
                                                           &pStorage
                                                           );
                                        }
                                    }
                                    break;
                                default:
                                    MD_ASSERT(FALSE);
                                }
                            }
                        }
                    }
                    if (SUCCEEDED(hresReturn)) {

                        //
                        // This must be the global master object
                        //
                        if ((dwLineLen != 1 + sizeof(FILETIME)) || (bLineId != MD_ID_ROOT_OBJECT)) {
                            //
                            // This file is hosed
                            //
                            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                        }
                        else {
                            //
                            // Got the MasterRoot Object.
                            //

                            ftTime = *(UNALIGNED FILETIME *)FIRSTDATAPTR(pbufLine);
                            g_pboMasterRoot->SetLastChangeTime(&ftTime);
                            //
                            // Read in MasterRoot Data.
                            //
                            for (hresReturn = GetNextLine(hReadFileHandle,
                                                  pbEndReadData,
                                                  pbufRead,
                                                  pbufLine,
                                                  dwLineLen,
                                                  pbNextPtr);
                                ((SUCCEEDED(hresReturn)) && (dwLineLen != 0)
                                && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr)) {
                                if (bLineId == MD_ID_DATA) {
                                    hresReturn = ReadDataObject(g_pboMasterRoot, pbufLine, dwLineLen, pStorage, bUnicode);
                                }
                            }
                        }
                    }
                    //
                    // All of the required stuff is read in, and the next line is either
                    // NULL or the first normal object.
                    // Loop through all normal objects.
                    //
                    if (SUCCEEDED(hresReturn)) {
                        while ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                            MD_ASSERT(bLineId == MD_ID_OBJECT);
                            for (hresReturn = ReadMetaObject(pboRead,
                                                           pbufLine,
                                                           dwLineLen,
                                                           pStorage,
                                                           bUnicode);
                                (FAILED(hresReturn));
                                hresReturn = ReadMetaObject(pboRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pStorage,
                                                          bUnicode)) {
                                //
                                // This for loop normally shouldn't be executed.
                                // The purpose of the loop is to ignore problems if
                                // the object is bad.
                                //
                                if (hresReturn == RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                    //
                                    // Serious error, we're done.
                                    //
                                    break;
                                }
                                else {
                                    //
                                    // Just give a warning and go to the next object
                                    // Ignore everything until we get to the next object
                                    //
                                    hresWarningCode = hresReturn;

                                    for (hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr);
                                        ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                        && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                        hresReturn = GetNextLine(hReadFileHandle,
                                                              pbEndReadData,
                                                              pbufRead,
                                                              pbufLine,
                                                              dwLineLen,
                                                              pbNextPtr)) {

                                    }
                                    if (dwLineLen == 0) {
                                        //
                                        // EOF, we're done
                                        //
                                        break;
                                    }
                                }
                            }
                            if ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)) {
                                //
                                // Got an object.
                                // Read in data.
                                //
                                for (hresReturn = GetNextLine(hReadFileHandle,
                                                      pbEndReadData,
                                                      pbufRead,
                                                      pbufLine,
                                                      dwLineLen,
                                                      pbNextPtr);
                                    ((SUCCEEDED(hresReturn)) && (dwLineLen > 0)
                                    //
                                    // GetLineID increments strCurPtr if a match is found
                                    //
                                    && ((bLineId = *(PBYTE)pbufLine->QueryPtr()) != MD_ID_OBJECT));
                                    hresReturn = GetNextLine(hReadFileHandle,
                                                          pbEndReadData,
                                                          pbufRead,
                                                          pbufLine,
                                                          dwLineLen,
                                                          pbNextPtr)) {
                                    if (bLineId == MD_ID_DATA) {
                                        hresReturn = ReadDataObject(pboRead,
                                                                    pbufLine,
                                                                    dwLineLen,
                                                                    pStorage,
                                                                    bUnicode);
                                        //
                                        // dwReturn gets blown away by the for loop.
                                        // Most errors we can just ignore anyway, but
                                        // save a warning.
                                        //
                                        if (FAILED(hresReturn)) {
                                            if (hresReturn != RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY)) {
                                                hresWarningCode = hresReturn;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //
                    // Must have MasterResource when accessing SystemChangeNumber
                    // so save it away here. Only update LastSaveChangeNumber on success.
                    //

                    dwTempLastSaveChangeNumber = g_dwSystemChangeNumber;
                    g_rMasterResource->Unlock();
                }
            }
            if (!CloseHandle(hReadFileHandle)) {
                dwTemp = GetLastError();
                hresReturn = RETURNCODETOHRESULT(dwTemp);
            }
        }
    }
    //
    // File not found is ok
    // Start with MasterRoot only
    //
    if (hresReturn == RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    if ((SUCCEEDED(hresReturn)) && (hresWarningCode != ERROR_SUCCESS)) {
        hresReturn = GetWarning(hresWarningCode);
    }

    if (SUCCEEDED(hresReturn)) {
        g_dwLastSaveChangeNumber = dwTempLastSaveChangeNumber;
    }

    //
    // Cleanup
    //
    if (!bHaveReadSaveSemaphore) {
        MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
    }
    delete(pbufRead);
    delete(pbufLine);
    delete(pStorage);
    return hresReturn;
}

HRESULT
InitWorker(
    IN BOOL bHaveReadSaveSemaphore
    )
{
    HRESULT hresReturn = ERROR_SUCCESS;

    g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    if (g_dwInitialized++ > 0) {
        hresReturn = g_hresInitWarning;
    }
    else {
        g_pboMasterRoot = NULL;
        g_phHandleHead = NULL;
        for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
            g_phEventHandles[i] = NULL;
        }
        g_mhHandleIdentifier = METADATA_MASTER_ROOT_HANDLE;
        g_pboMasterRoot = new CMDBaseObject(MD_MASTER_ROOT_NAME);
        g_ppbdDataHashTable = NULL;
        g_dwSystemChangeNumber = 0;
        g_strRealFileName = NULL;
        g_strTempFileName = NULL;
        g_strBackupFileName = NULL;
        g_pstrBackupFilePath = NULL;

        g_psidSystem = NULL;
        g_psidAdmin = NULL;
        g_paclDiscretionary = NULL;
        g_psdStorage = NULL;

        if ((g_pboMasterRoot == NULL) || (!(g_pboMasterRoot->IsValid()))) {

            IIS_PRINTF((buff,"Unable to allocate CMDBaseObject\n"));
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            g_pboMasterRoot->SetParent(NULL);
            g_phHandleHead = new CMDHandle(g_pboMasterRoot,
                                           METADATA_PERMISSION_READ,
                                           g_dwSystemChangeNumber,
                                           g_mhHandleIdentifier++);
            if (g_phHandleHead == NULL) {
                IIS_PRINTF((buff,"Unable to allocate CMDHandle\n"));
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                g_phHandleHead->SetNextPtr(NULL);
                if( ( g_phEventHandles[EVENT_READ_INDEX] = IIS_CREATE_EVENT(
                                                               "g_phEventHandles[EVENT_READ_INDEX]",
                                                               &g_phEventHandles[EVENT_READ_INDEX],
                                                               TRUE,
                                                               FALSE
                                                               ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if( ( g_phEventHandles[EVENT_WRITE_INDEX] = IIS_CREATE_EVENT(
                                                                   "g_phEventHandles[EVENT_WRITE_INDEX]",
                                                                   &g_phEventHandles[EVENT_WRITE_INDEX],
                                                                   TRUE,
                                                                   FALSE
                                                                   ) ) == NULL ) {
                    hresReturn = GetLastHResult();
                    IIS_PRINTF((buff,"CreateEvent Failed with %x\n",hresReturn));
                }
                else if ((g_ppbdDataHashTable = new CMDBaseData *[DATA_HASH_TABLE_LEN]) == NULL) {
                    IIS_PRINTF((buff,"Unable to allocate CMDBaseData\n"));
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = InitBufferPool();
                    if (SUCCEEDED(hresReturn)) {
                        for (int i =0; i < DATA_HASH_TABLE_LEN; i++) {
                            g_ppbdDataHashTable[i] = NULL;
                        }
                        //
                        // BugBug - There is a conceiveable deadlock if ReadAllData is called
                        // with g_rMasterResource Locked, due to the semaphore used to control
                        // file access. Would like to release g_rMasterResource, but that could
                        // cause duplicate inits.
                        //

                        hresReturn = SetStorageSecurityDescriptor();
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetDataFile();
                            if (SUCCEEDED(hresReturn)) {
                                hresReturn = ReadAllData(bHaveReadSaveSemaphore);
                            }
//                            if ((RetCode = SetRegistryStoreValues()) == ERROR_SUCCESS) {
//                                RetCode = ReadAllDataFromRegistry();
//                            }
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hresReturn)) {

            // Check if the Major/Minor version needs to get updated...
            // if there is a specified version in the registry (set by iis setup during upgrade)
            // then use that new version, if it's not a dword, then use the default for g_dwMajorVersionNumber.
            CheckForNewMetabaseVersion();

            if (!CheckVersionNumber()) {
                IIS_PRINTF((buff,"MD: Invalid version number\n"));
                hresReturn = MD_ERROR_INVALID_VERSION;
            }
        }

        if (FAILED(hresReturn)) {
            g_dwInitialized--;
            delete(g_pboMasterRoot);
            delete(g_phHandleHead);
            delete(g_ppbdDataHashTable);
            DeleteBufferPool();
            for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
                if (g_phEventHandles[i] != NULL) {
                    CloseHandle(g_phEventHandles[i]);
                }
            }
            ReleaseStorageSecurityDescriptor();
        }
        //
        // Save the return code.
        // Secondary init's repeat warnings.
        // If error, the next init will overwrite this.
        // So don't worry about setting this to errors.
        //
        g_hresInitWarning = hresReturn;
    }
    g_rMasterResource->Unlock();
    return hresReturn;
}

HRESULT
TerminateWorker1(
         IN BOOL bHaveReadSaveSemaphore
         )
{
    HRESULT hresReturn;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        if (g_dwInitialized == 0) {
            hresReturn = MD_ERROR_NOT_INITIALIZED;
        }
        else {
            if (g_dwInitialized == 1) {
                hresReturn = SaveAllData(FALSE,
                                         &CryptoStorage,
                                         pSessionKeyBlob,
                                         METADATA_MASTER_ROOT_HANDLE,
                                         bHaveReadSaveSemaphore);
//                RetCode = SaveAllDataToRegistry();
            }
            if (SUCCEEDED(hresReturn)) {
                if (--g_dwInitialized == 0)
                    TerminateWorker();
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

VOID
TerminateWorker()
{
/*++

Routine Description:

    Worker routine for termination.

Arguments:

    SaveData   - If true, saves metadata.

Return Value:

    DWORD      - ERROR_SUCCESS
                 MD_ERROR_NOT_INITIALIZED
                 ERROR_NOT_ENOUGH_MEMORY
                 Return codes from file system

Notes:

    If SaveData is TRUE and the save fails, the termination code is not executed
    and an error code is returned.

--*/
    CMDHandle *CurHandle, *NextHandle;
    for (CurHandle = g_phHandleHead;CurHandle!=NULL;CurHandle=NextHandle) {
        NextHandle = CurHandle->GetNextPtr();
        delete (CurHandle);
    }

    for (int i = 0; i < EVENT_ARRAY_LENGTH; i++) {
        if (g_phEventHandles[i] != NULL) {
            CloseHandle(g_phEventHandles[i]);
        }
    }
    delete(g_pboMasterRoot);

    //
    // All data objects should be deleted by
    // deleting the handles and masterroot
    // but it's possible a client failed
    // to release a data by reference so
    // destroy all remaining data objects
    //

    DeleteAllRemainingDataObjects();
    ReleaseStorageSecurityDescriptor();

    delete (g_ppbdDataHashTable);
    delete(g_strRealFileName);
    delete(g_strTempFileName);
    delete(g_strBackupFileName);
    delete(g_pstrBackupFilePath);
    DeleteBufferPool();
}

HRESULT
SetStorageSecurityDescriptor()
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BOOL status;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PLATFORM_TYPE platformType;

    //
    // Verify that globals were initialized correctly.
    //


    MD_ASSERT(g_psidSystem == NULL);
    MD_ASSERT(g_psidAdmin == NULL);
    MD_ASSERT(g_paclDiscretionary == NULL);
    MD_ASSERT(g_psdStorage == NULL);

    //
    // Of course, we only need to do this under NT...
    //

    platformType = IISGetPlatformType();

    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        g_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (g_psdStorage == NULL) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     g_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(g_psidSystem)
                       - sizeof(DWORD);

        g_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( g_paclDiscretionary == NULL ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     g_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidSystem
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     g_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     g_psidAdmin
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     g_psdStorage,
                     TRUE,
                     g_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = RETURNCODETOHRESULT(GetLastError());
            goto fatal;

        }
    }

fatal:

    if (FAILED(hresReturn)) {
        ReleaseStorageSecurityDescriptor();

    }

    return hresReturn;

}

VOID
ReleaseStorageSecurityDescriptor()
{
    if( g_paclDiscretionary != NULL ) {
        LocalFree( g_paclDiscretionary );
        g_paclDiscretionary = NULL;
    }

    if( g_psidAdmin != NULL ) {
        FreeSid( g_psidAdmin );
        g_psidAdmin = NULL;

    }

    if( g_psidSystem != NULL ) {
        FreeSid( g_psidSystem );
        g_psidSystem = NULL;
    }

    if( g_psdStorage != NULL ) {
        LocalFree( g_psdStorage );
        g_psdStorage = NULL;
    }
}

HRESULT
ExtractNameFromPath(
         IN OUT LPSTR &strPath,
         OUT LPSTR strNameBuffer,
         IN BOOL bUnicode)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    LPSTR pszIndex;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (bUnicode) {
        LPWSTR wstrPath = (LPWSTR)strPath;
        hresReturn = ExtractNameFromPath(&wstrPath, (LPWSTR)strNameBuffer);
        strPath = (LPSTR) wstrPath;
    }
    else {
        if (strPath != NULL) {
            for (pszIndex = strPath;
                 ((pszIndex - strPath) < METADATA_MAX_NAME_LEN) && (*pszIndex != (TCHAR)'\0') &&
                    (*pszIndex != MD_PATH_DELIMETER) && (*pszIndex != MD_ALT_PATH_DELIMETER);
                 pszIndex = CharNextExA(CP_ACP,
                                        pszIndex,
                                        0)) {
            }
            DWORD dwStrBytes = DIFF(pszIndex - strPath);
            if ((dwStrBytes) >= METADATA_MAX_NAME_LEN) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
            }
            else {
                MD_COPY(strNameBuffer, strPath, dwStrBytes);
                strNameBuffer[dwStrBytes] = (TCHAR)'\0';
                strPath = pszIndex;
                if (*strNameBuffer != (TCHAR)'\0') {
                    //
                    // if a non-null name
                    //
                    SKIP_PATH_DELIMETERA(strPath);
                    hresReturn = ERROR_SUCCESS;
                }
            }
        }
    }
    return (hresReturn);
}

HRESULT
ExtractNameFromPath(
         IN OUT LPWSTR *pstrPath,
         OUT LPWSTR strNameBuffer)
/*++

Routine Description:

    Finds the next name in a path.

Arguments:

    Path       - The path. Updated on success to point past the name.

    NameBuffer - The buffer to store the name.

Return Value:

    DWORD      - ERROR_SUCCESS
                 ERROR_PATH_NOT_FOUND
                 ERROR_INVALID_NAME

Notes:

--*/
{
    int i;
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);

    MD_ASSERT(strNameBuffer != NULL);
    if (*pstrPath != NULL) {
        for (i = 0;
            (i < METADATA_MAX_NAME_LEN) && ((*pstrPath)[i] != (WCHAR)'\0') &&
                ((*pstrPath)[i] != (WCHAR)MD_PATH_DELIMETER) && ((*pstrPath)[i] != (WCHAR)MD_ALT_PATH_DELIMETER);
            i++) {
            strNameBuffer[i] = (*pstrPath)[i];
        }
        if (i == METADATA_MAX_NAME_LEN) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_NAME);
        }
        else {
            strNameBuffer[i] = (WCHAR)'\0';
            *pstrPath += i;
            if (*strNameBuffer != (WCHAR)'\0') {
                //
                // if a non-null name
                //
                SKIP_PATH_DELIMETERW(*pstrPath);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
    return (hresReturn);
}

BOOL DataMatch(IN CMDBaseData *pbdExisting,
               IN PMETADATA_RECORD pmdrData,
               OUT PBOOL pbError,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Determines if a set of data maches an existing object.

Arguments:

    Existing   - The existing data object.

    Identifier - The Identifier of the data.

    Attributes - The flags for the data.
                      METADATA_INHERIT

    UserType   - The User Type for the data. User Defined.

    DataType   - The Type of the data.
                      DWORD_METADATA
                      STRING_METADATA
                      BINARY_METADATA

    DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.
                 Binary data must not exceed METADATA_MAX_BINARY_LEN bytes.
                 String data must not exceed METADATA_MAX_STRING_LEN characters,
                 include the trailing '\0'.

    Data       - Pointer to the data.


Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    BOOL bReturn = TRUE;
    BOOL bError = FALSE;

    if ((pmdrData->dwMDIdentifier != pbdExisting->GetIdentifier()) ||
        (pmdrData->dwMDAttributes != pbdExisting->GetAttributes()) ||
        (pmdrData->dwMDUserType != pbdExisting->GetUserType()) ||
        (pmdrData->dwMDDataType != pbdExisting->GetDataType())) {
        bReturn = FALSE;
    }
    else {
        if (pbdExisting->GetData(bUnicode) == NULL) {
            bError = TRUE;
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    if (*(DWORD *)(pmdrData->pbMDData) != *(DWORD *)(pbdExisting->GetData())) {
                        bReturn = FALSE;
                    }
                    break;
                }
                case STRING_METADATA:
                case EXPANDSZ_METADATA:
                {
                    if (bUnicode) {
                        LPWSTR pszStringData = (LPWSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = (LPWSTR)L"";
                        }
                        if (wcscmp(pszStringData, (LPWSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    else {
                        LPSTR pszStringData = (LPSTR)(pmdrData->pbMDData);
                        if (pszStringData == NULL) {
                            pszStringData = "";
                        }
                        if (MD_STRCMP(pszStringData, (LPSTR)(pbdExisting->GetData(bUnicode))) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                case BINARY_METADATA:
                case MULTISZ_METADATA:
                {
                    if (pmdrData->dwMDDataLen != pbdExisting->GetDataLen(bUnicode)) {
                        bReturn = FALSE;
                    }
                    else {
                        if (MD_CMP(pmdrData->pbMDData, pbdExisting->GetData(bUnicode), pmdrData->dwMDDataLen) != 0) {
                            bReturn = FALSE;
                        }
                    }
                    break;
                }
                default: {
                    bReturn = FALSE;
                }
            }
        }
    }
    *pbError = bError;
    return (bReturn);
}

VOID
DeleteDataObject(
         IN CMDBaseData *pbdDelete)
/*++

Routine Description:

    Decrements the reference count of an object and deletes it if the reference count becomes 0.

Arguments:

    Delete      - The data object to delete.

Return Value:

Notes:

--*/
{
    DWORD dwHash = DATA_HASH(pbdDelete->GetIdentifier());
    CMDBaseData *pdataIndex;

    MD_ASSERT(pbdDelete != NULL);
    if (pbdDelete->DecrementReferenceCount() == 0) {
        if (g_ppbdDataHashTable[dwHash] == pbdDelete) {
            g_ppbdDataHashTable[dwHash] = pbdDelete->GetNextPtr();
        }
        else {
            for (pdataIndex=g_ppbdDataHashTable[dwHash];
                pdataIndex->GetNextPtr() != pbdDelete;
                pdataIndex = pdataIndex->GetNextPtr()) {
            }
            pdataIndex->SetNextPtr(pbdDelete->GetNextPtr());
        }
        switch (pbdDelete->GetDataType()) {
        case DWORD_METADATA: {
            delete ((CMDDWData *) pbdDelete);
            break;
        }
        case STRING_METADATA: {
            delete ((CMDSTRData *) pbdDelete);
            break;
        }
        case BINARY_METADATA: {
            delete ((CMDBINData *) pbdDelete);
            break;
        }
        case EXPANDSZ_METADATA: {
            delete ((CMDEXSZData *) pbdDelete);
            break;
        }
        case MULTISZ_METADATA: {
            delete ((CMDMLSZData *) pbdDelete);
            break;
        }
        default: {
            MD_ASSERT(FALSE);
            delete (pbdDelete);
        }
        }
    }
}

VOID
DeleteAllRemainingDataObjects()
{
    DWORD i;
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdSave;

    for (i = 0; i < DATA_HASH_TABLE_LEN; i++) {
        for (pbdIndex=g_ppbdDataHashTable[i];
            pbdIndex != NULL;
            pbdIndex = pbdSave) {
            pbdSave = pbdIndex->GetNextPtr();
            switch (pbdIndex->GetDataType()) {
            case DWORD_METADATA: {
                delete ((CMDDWData *) pbdIndex);
                break;
            }
            case STRING_METADATA: {
                delete ((CMDSTRData *) pbdIndex);
                break;
            }
            case BINARY_METADATA: {
                delete ((CMDBINData *) pbdIndex);
                break;
            }
            case EXPANDSZ_METADATA: {
                delete ((CMDEXSZData *) pbdIndex);
                break;
            }
            case MULTISZ_METADATA: {
                delete ((CMDMLSZData *) pbdIndex);
                break;
            }
            default: {
                MD_ASSERT(FALSE);
                delete (pbdIndex);
            }
            }
        }
    }
}


BOOL
ValidateData(IN PMETADATA_RECORD pmdrData,
             IN BOOL bUnicode)
/*++

Routine Description:

    Checks data values for new metadata.

Arguments:

    Data       - The data structure. All fields must be set.

        Attributes - The flags for the data.
                 METADATA_INHERIT - If set on input, inherited data will be returned.
                                    If not set on input, inherited data will not be returned.

                 METADATA_PARTIAL_PATH - If set on input, this routine will return ERROR_SUCCESS
                                    and the inherited data even if the entire path is not present.
                                    Only valid if METADATA_INHERIT is also set.

        DataType   - The Type of the data.
                 DWORD_METADATA
                 STRING_METADATA
                 BINARY_METADATA

Return Value:

    BOOL       - TRUE if the data values are valid.

Notes:
--*/
{
    BOOL bReturn = TRUE;

    if (((pmdrData->pbMDData == NULL) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) ||
                (((pmdrData->dwMDDataType == BINARY_METADATA) ||
                    (pmdrData->dwMDDataType == MULTISZ_METADATA)) &&
                        (pmdrData->dwMDDataLen > 0)))) ||
        (pmdrData->dwMDDataType <= ALL_METADATA) ||
        (pmdrData->dwMDDataType >= INVALID_END_METADATA) ||
        ((pmdrData->dwMDAttributes &
            ~(METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE | METADATA_VOLATILE | METADATA_INSERT_PATH | METADATA_LOCAL_MACHINE_ONLY))!=0) ||
        (((pmdrData->dwMDAttributes & METADATA_REFERENCE) != 0) &&
            ((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0)) ||
        (((pmdrData->dwMDAttributes & METADATA_INSERT_PATH) != 0) &&
            ((pmdrData->dwMDDataType == DWORD_METADATA) || (pmdrData->dwMDDataType == BINARY_METADATA)))) {
        bReturn = FALSE;
    }

    if (bReturn && (pmdrData->dwMDDataType == MULTISZ_METADATA)) {
        if (bUnicode) {
            LPWSTR pszData = (LPWSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen / 2) <= 1) ||
                    (pszData[(dwDataLen / 2) - 1] != (WCHAR)'\0') ||
                    (pszData[(dwDataLen / 2) - 2] != (WCHAR)'\0')) {
                    bReturn = FALSE;
                }
            }
        }
        else {
            LPSTR pszData = (LPSTR) pmdrData->pbMDData;
            DWORD dwDataLen = pmdrData->dwMDDataLen;
            if (dwDataLen > 0) {
                if (((dwDataLen) == 1) ||
                    (pszData[(dwDataLen) - 1] != '\0') ||
                    (pszData[(dwDataLen) - 2] != '\0')) {
                    bReturn = FALSE;
                }
            }
        }
    }

    return (bReturn);
}

CMDBaseData *
MakeDataObject(IN PMETADATA_RECORD pmdrData,
               IN BOOL bUnicode)
{
/*++

Routine Description:

    Looks for a data object matching the parameters.
    If found, increments the reference count. If not found, it
    creates it.

Arguments:

    Data - The data for the new object.

        Identifier - The Identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    BOOL       - TRUE if the data matches

Notes:

--*/
    CMDBaseData *pbdIndex;
    CMDBaseData *pbdReturn = NULL;
    CMDBaseData *pbdNew = NULL;
    DWORD dwHash = DATA_HASH(pmdrData->dwMDIdentifier);
    BOOL bDataMatchError = FALSE;

    for (pbdIndex = g_ppbdDataHashTable[dwHash];
        (pbdIndex != NULL) &&
        !DataMatch(pbdIndex, pmdrData, &bDataMatchError, bUnicode) &&
        !bDataMatchError;
        pbdIndex = pbdIndex->GetNextPtr()) {
    }
    if (!bDataMatchError) {
        if (pbdIndex != NULL) {
            pbdReturn = pbdIndex;
            pbdReturn->IncrementReferenceCount();
        }
        else {
            switch(pmdrData->dwMDDataType) {
                case DWORD_METADATA: {
                    pbdNew = new CMDDWData(pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes,
                        pmdrData->dwMDUserType, *(DWORD *)(pmdrData->pbMDData));
                    break;
                }
                case STRING_METADATA: {
                    pbdNew = new CMDST