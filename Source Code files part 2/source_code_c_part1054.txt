\dfs\tools\dfsadmin\dfsadmin.h ===
#ifndef __DFS_SCRIPT_H__
#define __DFS_SCRIPT_H__

#include "lm.h"
#include "lmdfs.h"
#include <dfsheader.h>
#include <dfsprefix.h>
#include <dfsmisc.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include "objects.h"



DFSSTATUS
DfsView (
    LPWSTR RootName,
    FILE *Out );

DumpDfsInfo(
    DWORD Entry,
    DWORD Level,
    PDFS_INFO_4 pBuf,
    FILE *Out);

DFSSTATUS
SetTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget);

DFSSTATUS
SetLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink);


DFSSTATUS
DfsMerge (
    PROOT_DEF pRoot,
    LPWSTR NameSpace );


DFSSTATUS
VerifyLink(
    PLINK_DEF pLink);

DFSSTATUS
VerifyTarget(
    PLINK_DEF pLink,
    PTARGET_DEF pTarget);

VOID
DumpCurrentTime();

DWORD
UpdateLinkMetaInformation(
    PUNICODE_STRING pLinkName,
    PLINK_DEF pLink);

extern ULONG AddLinks, RemoveLinks, AddTargets, RemoveTargets, ApiCalls;

extern FILE *DebugOut;

#endif // __DFS_SCRIPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\objects.h ===
#ifndef __DFS_SCRIPT_OBJECTS_H__
#define __DFS_SCRIPT_OBJECTS_H__


DFSSTATUS
AddNewLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink,
    BOOLEAN Update );

DFSSTATUS
AddNewTarget( 
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget);

DFSSTATUS
AddNewRoot(
    PROOT_DEF pRoot,
    LPWSTR NameSpace,
    BOOLEAN Update );

DeleteRoot(
    PROOT_DEF pRoot );


DeleteLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink );

DeleteTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget );

DFSSTATUS
DfsCreateWideString(
    PUNICODE_STRING pName,
    LPWSTR *pString );


#endif // __DFS_SCRIPT_OBJECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\dfsadmin.c ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsprefix.h>
#include <dfsadmin.h>


DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

ULONG AddLinks, RemoveLinks, AddTargets, RemoveTargets, ApiCalls;
VOID
ScriptUsage();




VOID
ProcessDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace,
    BOOLEAN Update);

VOID
VerifyDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace );

VOID
SetDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace );


#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;

MAKEARG(Import);
MAKEARG(Export);
MAKEARG(Name);
MAKEARG(DebugFile);

SWITCH(Debug);
SWITCH(Verify);
SWITCH(Update);
SWITCH(Set);

LPWSTR ImportFile = NULL;
LPWSTR NameSpace = NULL;
LPWSTR ExportFile = NULL;
LPWSTR DebugFile = NULL;

FILE *ExportOut;
FILE *DebugOut = NULL;

extern int DumpRoots(PROOT_DEF pRoot,
                     FILE *DebugOut );


VOID
DumpCurrentTime()
{

    SYSTEMTIME CurrentTime;

    GetLocalTime( &CurrentTime );
    printf("Current Time: %d\\%d\\%d, %d:%d:%d:%d\n",
           CurrentTime.wMonth, CurrentTime.wDay, CurrentTime.wYear,
           CurrentTime.wHour, CurrentTime.wMinute, CurrentTime.wSecond, 
           CurrentTime.wMilliseconds );


}
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw,i;
    PROOT_DEF pRoot = NULL;

    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    ExportOut = stdout;

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);

        if (Status != ERROR_SUCCESS)
        {
            ScriptUsage();
            exit(-1);
        }

    }

    if (DfsPrefixTableInit() != STATUS_SUCCESS)
    {
        printf("Prefix table init failed \n");
        exit(-1);

    }

    DumpCurrentTime();

    if (Status == ERROR_SUCCESS && fArgImport)
    {
        printf("input file is %wS\n", ImportFile );
        pRoot = GetDfsTrees( ImportFile );

        if ((pRoot != NULL) && (fSwitchDebug == TRUE)) 
        {
            DumpRoots( pRoot, DebugOut);
        }

        if (fSwitchVerify)
        {
            VerifyDfsRoots(pRoot, NameSpace);
        }
        else if (fSwitchSet)
        {
            SetDfsRoots(pRoot, NameSpace);

        }
        else if (fSwitchUpdate)
        {
            ProcessDfsRoots( pRoot, NameSpace, TRUE );
        }
        else {
            ProcessDfsRoots( pRoot, NameSpace, FALSE);
        }
    }
    else if (Status == ERROR_SUCCESS && fArgName)
    {
        DfsView(NameSpace, ExportOut);
    }
    else {
        ScriptUsage();
    }
    DumpCurrentTime();
    printf("DfsServer is exiting with status %x\n", Status);
    exit(0);

}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgImport, ArgLenImport) == 0)
        {
            fArgImport = TRUE;
            ImportFile = &Arg[ArgLenImport];
            if (wcslen(ImportFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                ImportFile = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgExport, ArgLenExport) == 0)
        {
            fArgExport = TRUE;
            ExportFile = &Arg[ArgLenExport];
            if (wcslen(ExportFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                ExportFile = NULL;
            }
            else 
            {
                ExportOut = _wfopen(ExportFile, L"w");
            }
        }
        else if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            printf("Namespace is %wS\n",NameSpace);
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                NameSpace = NULL;
            }
        }
        else if (_wcsnicmp(Arg, ArgDebugFile, ArgLenDebugFile) == 0)
        {
            fArgDebugFile = TRUE;
            DebugFile = &Arg[ArgLenDebugFile];
            if (wcslen(DebugFile) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
                DebugFile = NULL;
            }
            else {
                DebugOut = _wfopen(DebugFile, L"w");
                fSwitchDebug = TRUE;
            }
        }

        else if (_wcsicmp(Arg, SwitchDebug) == 0)
        {
            fSwitchDebug = TRUE;
            if (DebugOut == NULL)
            {
                DebugOut = stdout;
            }
        }
        else if (_wcsicmp(Arg, SwitchVerify) == 0)
        {
            fSwitchVerify = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchUpdate) == 0)
        {
            fSwitchUpdate = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchSet) == 0)
        {
            fSwitchSet = TRUE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ScriptUsage()
{
    printf("Usage:\n");
    printf("/Debug - Enable debug settings\n");
    printf("/DebugFile:<File> - name of file to send debug output\n");
    printf("/Name:<NameSpace> - namespace of interest\n");
    printf("/Verify - Verify the namespace with import file dfs information\n");
    printf("/Update - update the namespace with import file dfs information\n");
    printf("/Set - Set the import file dfs information in the namespace\n");    
    printf("/Import:<File> - name of file to import\n");
    printf("/Export:<File> - name of file for export data\n");
    
    return;
}

VOID
ProcessDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace,
    BOOLEAN Update )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status;
    LPWSTR UseRootName;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {

        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = AddNewRoot(pRoot, UseRootName, Update);
        if (Status != ERROR_SUCCESS)
        {
            printf("AddRoot failed for %wS, status %d\n", UseRootName, Status);
        }
    }
}

VOID
VerifyDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status, VerifyStatus;
    PLINK_DEF pLink;
    DWORD ErrorLinks = 0;
    LPWSTR UseRootName;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {
        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = DfsMerge(pRoot, UseRootName);
        if (Status != ERROR_SUCCESS)
        {
            printf("Verify failed for %wS, status %d\n", UseRootName, Status);
        }
        else {
            for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
            {
                VerifyStatus = VerifyLink( pLink );
                if (VerifyStatus != ERROR_SUCCESS)
                {
                    Status = VerifyStatus;
                    ErrorLinks++;
                }
            }
            printf("Found %d links not verified (Status %x)\n", ErrorLinks, VerifyStatus);
        }
    }
}


VOID
SetDfsRoots(
    PROOT_DEF pRoots,
    LPWSTR NameSpace )
{
    PROOT_DEF pRoot;
    DFSSTATUS Status;
    PLINK_DEF pLink;
    DFSSTATUS SetStatus;
    LPWSTR UseRootName;
    DWORD ErrorLinks = 0;

    for (pRoot = pRoots; pRoot != NULL; pRoot = NEXT_ROOT_OBJECT(pRoot))
    {
        UseRootName = (NameSpace == NULL) ? pRoot->RootObjectName : NameSpace;

        Status = DfsMerge(pRoot, UseRootName);
        if (Status != ERROR_SUCCESS)
        {
            printf("Set failed for %wS, status %d\n", UseRootName, Status);
        }
        else {
            AddLinks = 0;
            RemoveLinks = 0;
            AddTargets = 0;
            RemoveTargets = 0;

            for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
            {

                SetStatus = SetLink( UseRootName, pLink );
                if (SetStatus != ERROR_SUCCESS)
                {
                    Status = SetStatus;
                    ErrorLinks++;
                }
            }
            printf("Added %d links, Removed %d\n", AddLinks, RemoveLinks);
            printf("Added %d targets, Removed %d\n", AddTargets, RemoveTargets);
            printf("%d links failed\n", ErrorLinks);


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\merge.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsadmin.h"

DFSSTATUS
AddRootToPrefixTable(
    struct _DFS_PREFIX_TABLE **ppTable,
    PROOT_DEF pRoot );

PLINK_DEF
CreateNewLinkEntry(
    LPWSTR LinkName );

PTARGET_DEF
CreateNewTargetEntry(
    LPWSTR ServerName,
    LPWSTR ShareName,
    ULONG State );

PLINK_DEF
GetLinkEntry( 
    struct _DFS_PREFIX_TABLE *pTable,
    LPWSTR NameString );

PTARGET_DEF
GetTargetEntry(
    PLINK_DEF pLink,
    LPWSTR ServerName,
    LPWSTR ShareName );

PLINK_DEF
MergeLinkInfo(
    PDFS_INFO_4 pBuf,
    struct _DFS_PREFIX_TABLE *pPrefixTable );




DFSSTATUS
DfsMerge (
    PROOT_DEF pRoot,
    LPWSTR NameSpace )
{
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = -1;
    DWORD Level = 4;
    DFSSTATUS Status;
    NTSTATUS NtStatus;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i;

    PLINK_DEF pGrownLinks = NULL, pLink;
    struct _DFS_PREFIX_TABLE *pPrefixTable;


    Status = AddRootToPrefixTable( &pPrefixTable,
                                   pRoot );
    if (Status != ERROR_SUCCESS)
    {
        printf("DfsVerify: create prefix table failed %x\n", Status);
        return Status;
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Contacting %wS for enumeration \n", NameSpace);
    }

    Status = NetDfsEnum( NameSpace,
                         Level, 
                         PrefMaxLen, 
                         &pBuffer, 
                         &EntriesRead, 
                         &ResumeHandle);

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Enumeration for %wS is complete %d entries\n", 
                 NameSpace,
                 EntriesRead);
    }
    
    if (Status != ERROR_SUCCESS)
    {
        printf("Export: cannot enum %wS: error %x\n", NameSpace, Status);
        return Status;
    }

    pCurrentBuffer = (PDFS_INFO_4)pBuffer;

    NtStatus = DfsPrefixTableAcquireWriteLock( pPrefixTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }



    for (i = 0; i < EntriesRead; i++)
    {
        pLink = MergeLinkInfo( pCurrentBuffer,
                               pPrefixTable);
        if (pLink != NULL)
        {
            if (pGrownLinks == NULL)
            {
                pGrownLinks = pRoot->pLinks;
            }
            NEXT_LINK_OBJECT(pLink) = pGrownLinks;
            pGrownLinks = pLink;
        }

        pCurrentBuffer++;
    }
    DfsPrefixTableReleaseLock(pPrefixTable);
    if (pGrownLinks != NULL)
    {
        pRoot->pLinks = pGrownLinks;
    }
    return Status;
}


PTARGET_DEF
CreateNewTargetEntry(
    LPWSTR ServerName,
    LPWSTR ShareName,
    ULONG  State )
{
    DFSSTATUS Status;
    UNICODE_STRING TargetName;
    PTARGET_DEF pTarget;

    Status = DfsCreateUnicodePathString( &TargetName,
                                         2, // unc path: 2 leading sep.
                                         ServerName,
                                         ShareName );
    if (Status == ERROR_SUCCESS)
    {
        pTarget = CreateTargetDef(IN_NAMESPACE, TargetName.Buffer, State);

        DfsFreeUnicodeString(&TargetName);
    }

    return pTarget;
}

PLINK_DEF
CreateNewLinkEntry(
    LPWSTR LinkName )
{
    PLINK_DEF pLink;

    pLink = CreateLinkDef(IN_NAMESPACE, LinkName, NULL);

    return pLink;
}


VOID
UpdateLinkEntry( 
    PLINK_DEF pLink,
    ULONG State,
    ULONG Timeout,
    LPWSTR Comment )
{
    if (State != 0)
    {
        AddObjectStateValue(&pLink->BaseObject, State);
    }
    if (Timeout != 0)
    {
        AddObjectTimeoutValue(&pLink->BaseObject, Timeout);
    }
    if (Comment != NULL)
    {
        AddObjectComment(&pLink->BaseObject, Comment);
    }
}

DFSSTATUS
AddRootToPrefixTable(
    struct _DFS_PREFIX_TABLE **ppTable,
    PROOT_DEF pRoot )
{
    struct _DFS_PREFIX_TABLE *pTable = NULL;
    NTSTATUS NtStatus;
    PLINK_DEF pLink;
    UNICODE_STRING LinkName;
    ULONG Links = 0;

    NtStatus = DfsInitializePrefixTable( &pTable,
                                         FALSE, 
                                         NULL );

    if (NtStatus != STATUS_SUCCESS)
    {
        return NtStatus;
    }

    NtStatus = DfsPrefixTableAcquireWriteLock( pTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }
    for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
    {
        RtlInitUnicodeString(&LinkName, pLink->LinkObjectName);
        NtStatus = DfsInsertInPrefixTableLocked( pTable,
                                                 &LinkName,
                                                 (PVOID)(pLink) );
        if (NtStatus == STATUS_SUCCESS)
        {
            pLink->LinkObjectFlags |= IN_TABLE;
        }
        else {
            printf(" AddRootToPrefixTable: Link %wZ, Status 0x%x\n, Links %d", 
                   &LinkName, NtStatus, Links);

            break;
        }
        Links++;
    }
    DfsPrefixTableReleaseLock(pTable);
    *ppTable = pTable;
    return NtStatus;
}


DFSSTATUS
DeletePrefixTable(
    struct _DFS_PREFIX_TABLE *pTable,
    PROOT_DEF pRoot )
{
    PLINK_DEF pLink;
    NTSTATUS NtStatus;
    UNICODE_STRING LinkName;

    
    NtStatus = DfsPrefixTableAcquireWriteLock( pTable);
    if (NtStatus != STATUS_SUCCESS)
    {
        printf("Unable to take prefix table lock, %x\n", NtStatus);
        return NtStatus;
    }
    for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
    {
        if ((pLink->LinkObjectFlags & IN_TABLE) == TRUE)
        {
            RtlInitUnicodeString(&LinkName, pLink->LinkObjectName);
            NtStatus = DfsRemoveFromPrefixTableLocked( pTable,
                                                       &LinkName,
                                                       (PVOID)(pLink) );
            if (NtStatus == STATUS_SUCCESS)
            {
                pLink->LinkObjectFlags &= ~IN_TABLE;
            }
            else {
                break;
            }
        }
    }
    DfsPrefixTableReleaseLock(pTable);
    DfsDereferencePrefixTable( pTable );

    return NtStatus;



}




PLINK_DEF
GetLinkEntry( 
    struct _DFS_PREFIX_TABLE *pTable,
    LPWSTR NameString )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Suffix;
    PLINK_DEF pLink;

    RtlInitUnicodeString( &Name, NameString );
    
    Status = DfsFindUnicodePrefixLocked( pTable,
                                         &Name,
                                         &Suffix,
                                         &pLink,
                                         NULL );

    if (Status == STATUS_SUCCESS)
    {
        return pLink;
    }
    
    if (Status != STATUS_OBJECT_PATH_NOT_FOUND)
    {
        printf("GetLinkEntry: unexpected status %x\n", Status);
    }
    return NULL;
}



PTARGET_DEF
GetTargetEntry(
    PLINK_DEF pLink,
    LPWSTR ServerName,
    LPWSTR ShareName )
{
    PTARGET_DEF pTarget, pReturn = NULL;
    UNICODE_STRING TargetName;
    DFSSTATUS Status;

    Status = DfsCreateUnicodePathString( &TargetName,
                                         2, // unc path: 2 leading sep.
                                         ServerName,
                                         ShareName );
    if (Status != ERROR_SUCCESS)
    {
        printf("GetTargetEntry: failed to create string\n");
        return NULL;
    }

    for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
    {
        if (_wcsicmp(TargetName.Buffer, pTarget->Name) == 0)
        {
            pReturn = pTarget;
            break;

        }
    }

    DfsFreeUnicodeString(&TargetName);

    return pReturn;
}


PLINK_DEF
MergeLinkInfo(
    PDFS_INFO_4 pBuf,
    struct _DFS_PREFIX_TABLE *pPrefixTable )
{
    PLINK_DEF pLink, pReturn = NULL;
    DWORD i;
    PDFS_STORAGE_INFO pStorage;
    UNICODE_STRING LinkName, ServerName, ShareName, Remains;
    DFSSTATUS Status;
    PTARGET_DEF pTargetList = NULL, pTarget;

    RtlInitUnicodeString( &LinkName, pBuf->EntryPath);
    Status = DfsGetPathComponents(&LinkName,
                                  &ServerName,
                                  &ShareName,
                                  &Remains);

    if (Remains.Length == 0)
    {
        return NULL;
    }
    if ((pLink = GetLinkEntry(pPrefixTable,
                              Remains.Buffer)) == NULL)
    {
        pLink = CreateNewLinkEntry(Remains.Buffer);
        UpdateLinkEntry( pLink, pBuf->State, pBuf->Timeout, pBuf->Comment);
        pReturn = pLink;
    }

    SetObjectInNameSpace(pLink);
    for(i = 0, pStorage = pBuf->Storage;
        i < pBuf->NumberOfStorages;
        i++, pStorage = pBuf->Storage+i) {

        if ((pTarget = GetTargetEntry(pLink,
                                      pStorage->ServerName,
                                      pStorage->ShareName)) == NULL)
        {
            pTarget = CreateNewTargetEntry(pStorage->ServerName,
                                           pStorage->ShareName,
                                           pStorage->State);
            if (pTargetList == NULL)
            {
                pTargetList = pLink->LinkObjectTargets;
            }
                
            pTarget->NextTarget = pTargetList;
            pTargetList = pTarget;
        }
        SetInNameSpace(pTarget);
    }
    if (pTargetList != NULL)
    {
        pLink->LinkObjectTargets = pTargetList;
    }

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfscmd\makefile.inc ===
$(O)\app.res: \
        $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        app.rc \
        app.rc2 \
        resource.h \
        sharing.ico \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\view.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsheader.h"
#include "dfsmisc.h"
#include "dfsprefix.h"
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include "DfsAdmin.h"

DFSSTATUS
DfsView (
    LPWSTR RootName,
    FILE *Out )
{
    LPBYTE pBuffer = NULL;
    DWORD ResumeHandle = 0;
    DWORD EntriesRead = 0;
    DWORD PrefMaxLen = -1;
    DWORD Level = 4;
    DFSSTATUS Status;
    PDFS_INFO_4 pCurrentBuffer;
    DWORD i;

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Contacting %wS for enumeration \n", RootName);
    }
    Status = NetDfsEnum( RootName, 
                         Level, 
                         PrefMaxLen, 
                         &pBuffer, 
                         &EntriesRead, 
                         &ResumeHandle);

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Enumeration for %wS is complete %d entries\n", 
               RootName, 
               EntriesRead);
    }


    if (Status != ERROR_SUCCESS)
    {
        printf("Export: cannot enum %wS: error %x\n", RootName, Status);
    }
    else {
        pCurrentBuffer = (PDFS_INFO_4)pBuffer;

        for (i = 0; i < EntriesRead; i++)
        {
            DumpDfsInfo(i, Level, pCurrentBuffer, Out);
            pCurrentBuffer++;
        }
        fwprintf(Out, L"END ROOT\n");
    }

    return Status;
}



DumpDfsInfo(
    DWORD Entry,
    DWORD Level,
    PDFS_INFO_4 pBuf,
    FILE *Out)
{
    DWORD i;
    PDFS_STORAGE_INFO pStorage;
    UNICODE_STRING LinkName, ServerName, ShareName, Remains;
    DFSSTATUS Status;

    if (Level != 4) {
        printf("Fix Dump DfsInfo for different levels\n");
        return 0;
    }

    if (Entry == 0)
    {
        fwprintf(Out, L"ROOT %ws \n", pBuf->EntryPath);

        for(i = 0, pStorage = pBuf->Storage;
            i < pBuf->NumberOfStorages;
            i++, pStorage = pBuf->Storage+i)
        {
            fwprintf(Out, L"\tTARGET \\\\%ws\\%ws\n", 
                     pStorage->ServerName, pStorage->ShareName);
        }
        fwprintf(Out, L"\n");
    }
    else 
    {
        RtlInitUnicodeString( &LinkName, pBuf->EntryPath);
        Status = DfsGetPathComponents(&LinkName,
                                      &ServerName,
                                      &ShareName,
                                      &Remains);

        fwprintf(Out, L"\tLINK \"%ws\" ", Remains.Buffer);
        if (pBuf->Comment && (pBuf->Comment[0] != 0))
        {
            printf("Comment is %ws\n", pBuf->Comment);
            fwprintf(Out, L"\tCOMMENT \"%ws\" ", pBuf->Comment);
        }
        fwprintf(Out, L"\tSTATE %x ", pBuf->State);
        if (pBuf->Timeout != 0)
        {
            fwprintf(Out, L"\tTIMEOUT %d ", pBuf->Timeout);
        }
        fwprintf(Out, L"\n");
        for(i = 0, pStorage = pBuf->Storage;
            i < pBuf->NumberOfStorages;
            i++, pStorage = pBuf->Storage+i)
        {
            fwprintf(Out, L"\t\tTARGET \\\\%ws\\%ws", 
                   pStorage->ServerName, pStorage->ShareName);
            fwprintf(Out, L"\tSTATE %x \n", pStorage->State);
        }
    }
    fwprintf(Out, L"\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\set.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsadmin.h>


DFSSTATUS
SetTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget)
{
    DFSSTATUS Status;

    if (IsInScript(pTarget) && IsInNameSpace(pTarget))
    {
        Status = ERROR_SUCCESS;
    }
    else if (IsInScript(pTarget))
    {
        Status = AddNewTarget( LinkOrRoot, pTarget, FirstTarget);
    }
    else if (IsInNameSpace(pTarget))
    {
        Status = DeleteTarget( LinkOrRoot, pTarget );
        // printf("Delete Target Status for %wS, %wS %x\n", LinkOrRoot, pTarget->Name, Status);
    }
    else 
    {
        printf("SetTarget: Target %wS has error!\n", pTarget->Name);
        Status = ERROR_GEN_FAILURE;
    }
    return Status;
}

DFSSTATUS
SetLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS TargetStatus = ERROR_SUCCESS;
    PTARGET_DEF pTarget;
    UNICODE_STRING LinkName;
    BOOLEAN FirstTarget = FALSE;

    if (!IsObjectInScript(pLink))
    {
        if (IsObjectInNameSpace(pLink))
        {
            Status = DeleteLink( RootNameString, pLink);
        }
        else 
        {
            printf("Set Link error! \n");
            Status = ERROR_GEN_FAILURE;
        }
    }
    else {
        if (!IsObjectInNameSpace(pLink))
        {
            AddLinks++;
            FirstTarget = TRUE;
        }
        Status = DfsCreateUnicodePathString(&LinkName, FALSE, RootNameString, pLink->LinkObjectName);
    
        if (Status == ERROR_SUCCESS)
        {
            for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
            {
                TargetStatus = SetTarget(LinkName.Buffer, pTarget, FirstTarget);
                if (TargetStatus != ERROR_SUCCESS)
                {
                    Status = ERROR_GEN_FAILURE;
                }
                FirstTarget = FALSE;
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = UpdateLinkMetaInformation( &LinkName, pLink );
            }

            DfsFreeUnicodeString(&LinkName);
        }

    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\verify.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "..\..\lib\dfsgram\dfsobjectdef.h"
#include <dfsadmin.h>


VOID
DumpLink(
    PLINK_DEF pLink )
{
    PTARGET_DEF pTarget;
    printf("Link %wS\n", pLink->LinkObjectName);

    for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
    {
        printf("\tTarget %wS\n", pTarget->Name);
    }
}


DFSSTATUS
VerifyTarget(
    PLINK_DEF pLink,
    PTARGET_DEF pTarget)
{
    if (IsInScript(pTarget) && IsInNameSpace(pTarget))
    {
        return ERROR_SUCCESS;
    }
    else if (IsInScript(pTarget))
    {
        printf("/t Target %wS for link %wS is not in the namespace\n", 
               pTarget->Name,
               pLink->LinkObjectName);
    }
    else if (IsObjectInNameSpace(pLink))
    {
        printf("/t Target %wS for link %wS is additional in the namespace\n", 
               pTarget->Name,
               pLink->LinkObjectName);
    }
    else 
    {
        printf("Script error for target %wS link %wS!\n", pTarget->Name, pLink->LinkObjectName);
    }
    return ERROR_GEN_FAILURE;
}


DFSSTATUS
VerifyLink(
    PLINK_DEF pLink)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS TargetStatus = ERROR_SUCCESS;
    PTARGET_DEF pTarget;

    if (IsObjectInScript(pLink) && IsObjectInNameSpace(pLink))
    {
        for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
        {
            TargetStatus = VerifyTarget(pLink, pTarget);
            if (TargetStatus != ERROR_SUCCESS)
            {
                Status = ERROR_GEN_FAILURE;
            }
        }

    }
    else if (IsObjectInScript(pLink))
    {
        printf("Link %wS is not in the namespace, %wS\n", pLink->LinkObjectName);
        
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    else if (IsObjectInNameSpace(pLink))
    {
        printf("Link %wS is additional in namespace %wS \n",pLink->LinkObjectName);
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    else 
    {
        printf("Script error for Link %wS \n", pLink->LinkObjectName);
        DumpLink(pLink);
        Status = ERROR_GEN_FAILURE;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsadmin\objects.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "dfsadmin.h"



UpdateApiCalls()
{
    if ((++ApiCalls % 500) == 0)
    {
        printf("Api calls completed: %d\n", ApiCalls);
        DumpCurrentTime();
    }
}

DFSSTATUS
AddNewRoot(
    PROOT_DEF pRoot,
    LPWSTR NameSpace,
    BOOLEAN Update )
{
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RootName;

    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;

    LPWSTR UseRootName;

    PLINK_DEF pLink;

    UseRootName = NameSpace;
    if (UseRootName == NULL)
    {
        UseRootName = pRoot->RootObjectName;
    }
    RtlInitUnicodeString(&RootName, UseRootName);

    Status = DfsGetPathComponents(&RootName,
                                  &ServerName,
                                  &ShareName,
                                  NULL );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCreateWideString(&ServerName, &ServerNameString);
    }

    if (Status == ERROR_SUCCESS) 
    {
        Status = DfsCreateWideString(&ShareName, &ShareNameString);
    }

    if (Status == ERROR_SUCCESS) 
    {
       Status = NetDfsAddStdRoot( ServerNameString, ShareNameString, NULL, 0);
       if (Status != ERROR_SUCCESS)
       {
           printf("NetDfsAddStdRoot failed: Status 0x%x, Server %wS Share %wS\n",
                  Status, ServerNameString, ShareNameString);
       }

       UpdateApiCalls();
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }

    if ((Status == ERROR_SUCCESS) ||
        ((Status == ERROR_FILE_EXISTS) && (Update == TRUE)))
    {
        for (pLink = pRoot->pLinks; pLink != NULL; pLink = NEXT_LINK_OBJECT(pLink))
        {
            Status = AddNewLink( UseRootName, pLink, Update);
            if ((Status != ERROR_SUCCESS) &&
                ((Status != ERROR_FILE_EXISTS) || (Update != TRUE)))
            {
                if (DebugOut)
                {
                    fwprintf(DebugOut, L"Add link failed: Root %wS Link %wS\n", UseRootName,
                           pLink->LinkObjectName);
                }
                break;
            }
        }
    }

    return Status;
}


DFSSTATUS
AddNewLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink,
    BOOLEAN Update )
{
    UNICODE_STRING LinkName;
    DFSSTATUS Status;
    PTARGET_DEF pTarget;

    Status = DfsCreateUnicodePathString(&LinkName,
                                        0, // not unc path: no leading seperators.
                                        RootNameString,
                                        pLink->LinkObjectName);

    if (Status == ERROR_SUCCESS)
    {
//        Status = NetDfsAdd( LinkName.Buffer, NULL, NULL, NULL, DFS_ADD_VOLUME);

        UpdateApiCalls();
        if ((++AddLinks % 400) == 0)
        {
            printf("Done with %d Links %d Targets %d Api calls\n", 
                   AddLinks, AddTargets, ApiCalls );
        }
        if (Status == ERROR_SUCCESS)
        {
            for (pTarget = pLink->LinkObjectTargets; pTarget != NULL; pTarget = pTarget->NextTarget)
            {
                Status = AddNewTarget( LinkName.Buffer, pTarget, pTarget == pLink->LinkObjectTargets);
                if ((Status != ERROR_SUCCESS) &&
                ((Status != ERROR_FILE_EXISTS) || (Update != TRUE)))
                {
                    if (DebugOut)
                    {
                        fwprintf(DebugOut, L"Add target failed: Root %wS Link %wS Target %wS\n", RootNameString,
                                 pLink->LinkObjectName, 
                                 pTarget->Name);
                    }
                    break;
                }
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            Status = UpdateLinkMetaInformation(&LinkName, 
                                               pLink);
        }
        DfsFreeUnicodeString(&LinkName);
    }

    //printf("Add new link status %x\n", Status);
    return Status;
}

DWORD
UpdateLinkMetaInformation(
    PUNICODE_STRING pLinkName,
    PLINK_DEF pLink)
{
    DWORD Status = ERROR_SUCCESS;

    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectCommentSet(pLink))
        {
            DFS_INFO_100 Info100;

            Info100.Comment = pLink->BaseObject.Comment;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 100, (LPBYTE)&Info100);
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectStateSet(pLink))
        {
            DFS_INFO_101 Info101;

            Info101.State = pLink->BaseObject.State;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 101, (LPBYTE)&Info101);
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        if (IsObjectTimeoutSet(pLink))
        {
            DFS_INFO_102 Info102;

            Info102.Timeout = pLink->BaseObject.Timeout;
            Status = NetDfsSetInfo( pLinkName->Buffer, NULL, NULL, 102, (LPBYTE)&Info102);
        }
    }
    return Status;
}

DFSSTATUS
AddNewTarget( 
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget,
    BOOLEAN FirstTarget)
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;
    ULONG Flags = 0;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING TargetName;

    if (FirstTarget)
    {
        Flags = DFS_ADD_VOLUME;
    }

    RtlInitUnicodeString(&TargetName, pTarget->Name );
    Status = DfsGetFirstComponent(&TargetName,
                                  &ServerName,
                                  &ShareName );
    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);


    if (Status == ERROR_SUCCESS) {
        Status = NetDfsAdd( LinkOrRoot, ServerNameString, ShareNameString, NULL, Flags);
        if ((Status != ERROR_SUCCESS) && (Status != ERROR_NOT_FOUND))
        {
            printf("NetDfsAdd failed: Status 0x%x, Link %wS Server %wS Share %wS Flags 0x%x\n",
                   Status, LinkOrRoot, ServerNameString, ShareNameString, Flags);
        }
        if (Status == ERROR_NOT_FOUND)
        {
            Status = NetDfsAdd( LinkOrRoot, ServerNameString, ShareNameString, NULL, DFS_ADD_VOLUME);
            if (Status != ERROR_SUCCESS)
            {
                printf("NetDfsAdd failed again!: Status 0x%x, Link %wS Server %wS Share %wS Flags 0x%x\n",
                       Status, LinkOrRoot, ServerNameString, ShareNameString, Flags);
            }
        }

        UpdateApiCalls();
    }

        

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Add new target %wS %wS %wS status %x\n", 
                 LinkOrRoot, 
                 ServerNameString, 
                 ShareNameString, 
                 Status);
    }


    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }
    AddTargets++;
    return Status;
}



DeleteRoot(
    PROOT_DEF pRoot )
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status;
    
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RootName;

    RtlInitUnicodeString(&RootName, pRoot->RootObjectName);

    Status = DfsGetPathComponents(&RootName,
                                  &ServerName,
                                  &ShareName,
                                  NULL );

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);

    if (Status == ERROR_SUCCESS) 
    {
        Status = NetDfsRemoveStdRoot( ServerNameString, ShareNameString, 0);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsremovedStdRoot failed: Status 0x%x, Server %wS Share %wS\n",
                   Status, ServerNameString, ShareNameString);
        }
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Remove root %wS, Status %x\n", RootName.Buffer, Status);
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }

    return Status;
}


DeleteLink(
    LPWSTR RootNameString,
    PLINK_DEF pLink )
{
    UNICODE_STRING LinkName;
    DFSSTATUS Status;

    Status = DfsCreateUnicodePathString(&LinkName, FALSE, RootNameString, pLink->LinkObjectName);

    if (Status == ERROR_SUCCESS)
    {
        Status = NetDfsRemove( LinkName.Buffer, NULL, NULL);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsRemove Failed 0x%x, for link %wS\n",
                   Status, LinkName.Buffer);
        }
        UpdateApiCalls();
        if (DebugOut)
        {
            fwprintf(DebugOut, L"Removed Link %wS, Status %x\n", LinkName.Buffer, Status);
        }
        DfsFreeUnicodeString(&LinkName);
    }
    RemoveLinks++;
    return Status;

}

DeleteTarget(
    LPWSTR LinkOrRoot,
    PTARGET_DEF pTarget )
{
    LPWSTR ServerNameString = NULL;
    LPWSTR ShareNameString = NULL;
    DFSSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING TargetName;

    RtlInitUnicodeString( &TargetName, pTarget->Name);

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetFirstComponent(&TargetName,
                                      &ServerName,
                                      &ShareName );
    }

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ServerName, &ServerNameString);

    if (Status == ERROR_SUCCESS)
        Status = DfsCreateWideString(&ShareName, &ShareNameString);
    
    if (Status == ERROR_SUCCESS) {
        Status = NetDfsRemove( LinkOrRoot, ServerNameString, ShareNameString);
        if (Status != ERROR_SUCCESS)
        {
            printf("NetDfsRemove Failed 0x%x, for link %wS, Server %wS Share %wS\n",
                   Status, LinkOrRoot, ServerNameString, ShareNameString);
        }

        UpdateApiCalls();
    }

    if (DebugOut)
    {
        fwprintf(DebugOut, L"Removed Link %wS target %wS, Status %x\n", 
                 LinkOrRoot, 
                 pTarget->Name, 
                 Status);
    }

    if (ServerNameString != NULL)
    {
        free(ServerNameString);
    }
    if (ShareNameString != NULL)
    {
        free(ShareNameString);
    }
    RemoveTargets++;
    return Status;
}



DFSSTATUS
DfsCreateWideString(
    PUNICODE_STRING pName,
    LPWSTR *pString )
{

    DFSSTATUS Status = ERROR_SUCCESS;

    *pString = malloc(pName->Length + sizeof(WCHAR));

    if (*pString != NULL)
    {
        RtlCopyMemory(*pString, pName->Buffer, pName->Length);
        (*pString)[pName->Length/sizeof(WCHAR)] = 0;
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfscmd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_SYS_MSG_NOT_FOUND           2
#define IDI_SHARING                     100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfscmd\cmd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:      cmd.cxx
//
//  Contents:  Command-line operations
//
//  History:   7-May-96     BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <shlobj.h>
#include "cmd.hxx"
#include "myutil.hxx"

ULONG
DfscmdPrintf(
    PWCHAR format,
    ...);

//
//      -- create intermediate directories
//      -- don't remove if it's the last one
//      --

// This function determines where the server and share name are in a UNC path,
// and sets them to the output parameters. Note that the input parameter is
// munged in the process. E.g.:
//        input:  \\brucefo4\root\hello
//        output: \\brucefo4\0root\hello
//                  ^server   ^share
//
// FALSE is returned if it doesn't appear to be a UNC path. TRUE is returned
// if everything seems ok.

BOOL
GetServerShare(
    IN OUT PWSTR pszUncPath,
    OUT PWSTR* ppszServer,
    OUT PWSTR* ppszShare
    )
{
    appAssert(NULL != pszUncPath);

    //
    // Do a quick check that this is a UNC path
    //

    PWSTR pT;

    if (   L'\\' != pszUncPath[0]
        || L'\\' != pszUncPath[1]
        || L'\\' == pszUncPath[2] || L'\0' == pszUncPath[2]
        || (NULL == (pT = wcschr(&pszUncPath[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszServer = &pszUncPath[2];
    *pT++ = L'\0';
    *ppszShare = pT;

    appDebugOut((DEB_TRACE,
        "GetServerShare: Server: %ws, share: %ws\n",
        *ppszServer, *ppszShare));
    return TRUE;
}

// This function determines the appropriate Dfs name to pass to the NetDfs
// APIs. The input buffer is modified. E.g.:
//        input:  \\dfsname\dfsshare
//        output: \\dfsname\0dfsshare
//                  ^dfs
//
// FALSE is returned if it doesn't appear to be a dfs name. TRUE is returned
// if everything seems ok.

BOOL
GetDfs(
    IN OUT PWSTR pszDfsName,
    OUT PWSTR* ppszDfs
    )
{
    appAssert(NULL != pszDfsName);

    //
    // Do a quick check that this is a Dfs name
    //

    PWSTR pT;

    if (   L'\\' != pszDfsName[0]
        || L'\\' != pszDfsName[1]
        || L'\\' == pszDfsName[2] || L'\0' == pszDfsName[2]
        || (NULL == (pT = wcschr(&pszDfsName[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszDfs = &pszDfsName[2];

    //
    // Go to next slash or end
    //
    pT++;
    while (*pT != L'\\' && *pT != L'\0')
        pT++;

    *pT = L'\0';

    appDebugOut((DEB_TRACE,
        "GetDfs: Dfs: %ws\n",
        *ppszDfs));
    return TRUE;
}


VOID
CmdMap(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN PWSTR pszComment,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdMap(%ws, %ws, %ws)\n",
        pszDfsPath, pszUncPath, pszComment));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }


    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                pszComment,
                                (fRestore == FALSE) ?
                                    DFS_ADD_VOLUME : DFS_ADD_VOLUME | DFS_RESTORE_VOLUME);
    if (status == NERR_Success)
    {
        // Notify shell of change.

        appDebugOut((DEB_TRACE,
            "Notify shell about new path %ws\n",
            pszDfsPath));

        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszDfsPath, NULL);
    }
    else
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdUnmap(
    IN PWSTR pszDfsPath
    )
{
    appDebugOut((DEB_TRACE,"CmdUnmap(%ws)\n",
        pszDfsPath));

    //
    // Delete all the replicas, and hence the volume
    //

    HRESULT hr = S_OK;
    PDFS_INFO_3 pVolumeInfo = NULL;
    NET_API_STATUS status = NetDfsGetInfo(
                                pszDfsPath,
                                NULL,
                                NULL,
                                3,
                                (LPBYTE*)&pVolumeInfo);
    CHECK_NET_API_STATUS(status);
    if (NERR_Success == status)
    {
        // now, we have pVolumeInfo memory to delete

        for (ULONG i = 0; i < pVolumeInfo->NumberOfStorages; i++)
        {
            appDebugOut((DEB_TRACE,
                "Deleting replica %d of %d\n",
                i + 1, pVolumeInfo->NumberOfStorages));

            PDFS_STORAGE_INFO pDfsStorageInfo = &pVolumeInfo->Storage[i];

            status = NetDfsRemove(
                            pszDfsPath,
                            pDfsStorageInfo->ServerName,
                            pDfsStorageInfo->ShareName);
            if (status != NERR_Success)
            {
				DfsErrorMessage(status);
            }
        }
        NetApiBufferFree(pVolumeInfo);
    }
    else
    {
		DfsErrorMessage(status);
    }

    // Notify shell of change.

    appDebugOut((DEB_TRACE,
            "Notify shell about deleted path %ws\n",
            pszDfsPath));

    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszDfsPath, NULL);
}

VOID
CmdAdd(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdAdd(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                NULL,
                                (fRestore == FALSE) ? 0 : DFS_RESTORE_VOLUME);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRemove(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRemove(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsRemove(
                                pszDfsPath,
                                pszServer,
                                pszShare);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdView(
    IN PWSTR pszDfsName,    // of form \\dfsname\dfsshare
    IN DWORD level,
    IN BOOLEAN fBatch,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdView(%ws, %d)\n",
        pszDfsName, level));

    PWSTR pszDfs;   // of form 'dfsname'
    if (!GetDfs(pszDfsName, &pszDfs))
    {
		Usage();
    }

    DWORD entriesread;
    LPBYTE buffer;
    DWORD resumeHandle = 0;
    NET_API_STATUS status = NetDfsEnum(
                                pszDfs,
                                level,
                                0xffffffff,
                                (LPBYTE*)&buffer,
                                &entriesread,
                                &resumeHandle);
    if (status == NERR_Success)
    {
        PDFS_INFO_3 pDfsInfo = (PDFS_INFO_3)buffer;
        DWORD i, j;
        LPDFS_STORAGE_INFO pStorage;

#if DBG == 1
        appDebugOut((DEB_TRACE,"NetDfsEnum returned %d entries\n", entriesread));
        for (i = 0; i < entriesread; i++)
        {
            if (level == 1)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_1)buffer)[i]));
            }
            else if (level == 2)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_2)buffer)[i]));
            }
            else if (level == 3)
            {
                pDfsInfo = &(((PDFS_INFO_3)buffer)[i]);
            }
            else
            {
                // bug!
                break;
            }
            appDebugOut((DEB_TRACE,"\t%ws\n", pDfsInfo->EntryPath));
        }
        pDfsInfo = (PDFS_INFO_3)buffer;
#endif // DBG == 1

        if (fBatch == FALSE)
        {
            for (i = 0; i < entriesread; i++)
            {
                DfscmdPrintf(L"%ws", pDfsInfo->EntryPath);

                if (level == 1)
                {
                    DfscmdPrintf(L"\r\n");
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_1));
                    continue;
                }

                if (L'\0' != *pDfsInfo->Comment)
                {
                    // Print the comment at column 60.
                    int len = wcslen(pDfsInfo->EntryPath);
                    while (len++ < 58)
                    {
                        DfscmdPrintf(L" ");    // putchar?
                    }

                    DfscmdPrintf(L"  %ws\r\n", pDfsInfo->Comment);
                }
                else
                {
                    DfscmdPrintf(L"\r\n");
                }

                if (level == 2)
                {
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_2));
                    continue;
                }

                pStorage = pDfsInfo->Storage;

                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {
                    DfscmdPrintf(L"\t\\\\%ws\\%ws\r\n",
                        pStorage[j].ServerName,
                        pStorage[j].ShareName);
                }

                pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }
        else
        {
            DfscmdPrintf(L"REM BATCH RESTORE SCRIPT\r\n\r\n");
            for (i = 0; i < entriesread; i++)
            {
                pStorage = pDfsInfo->Storage;
    
                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {

                    if (pDfsInfo->Comment == NULL
                          ||
                        j > 0
                          || 
                        (wcslen(pDfsInfo->Comment) == 1 && pDfsInfo->Comment[0] == L' ')
                    ) {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     } else {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\" \"%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            pDfsInfo->Comment,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     }
                }
                DfscmdPrintf(L"\r\n");
                pDfsInfo = (LPDFS_INFO_3) ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }

        NetApiBufferFree( buffer );
    }
    else
    {
		DfsErrorMessage(status);
    }
}


//
// The following is copied from dfsutil code, which allows redirection of
// output to a file.
//

#define MAX_MESSAGE_BUF 4096
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR MsgBuf[MAX_MESSAGE_BUF];
CHAR AnsiBuf[MAX_ANSI_MESSAGE_BUF];

ULONG
DfscmdPrintf(
   PWCHAR format,
   ...)
{
   DWORD written;
   va_list va;

   va_start(va, format);
   wvsprintf(MsgBuf, format, va);
   written = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
   WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, written, &written, NULL);

   va_end(va);
   return written;
}
                              

#ifdef MOVERENAME

VOID
CmdMove(
    IN PWSTR pszDfsPath1,
    IN PWSTR pszDfsPath2
    )
{
    appDebugOut((DEB_TRACE,"CmdMove(%ws, %ws)\n",
        pszDfsPath1, pszDfsPath2));

    NET_API_STATUS status = NetDfsMove(
                                pszDfsPath1,
                                pszDfsPath2);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRename(
    IN PWSTR pszPath,
    IN PWSTR pszNewPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRename(%ws, %ws)\n",
        pszPath, pszNewPath));

    NET_API_STATUS status = NetDfsRename(
                                pszPath,
                                pszNewPath);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsapi\dfsapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       Main.CXX
//
//  Contents:   Main file for DfsApi
//
//  History:    11-Mar-98	MariusB		Created
//				10-Dec-98	MariusB		Minor fixes
//				20-Nov-00	MariusB		
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include "lm.h"
#include "lmdfs.h"
#include "winsock2.h"
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <excpt.h>
#include <dsgetdc.h>
#include <windef.h>
#include <winbase.h>
#include <basetsd.h>

#if !defined(DFS_STORAGE_STATE_MASTER)
#define DFS_STORAGE_STATE_MASTER   0x0010
#define DFS_STORAGE_STATE_STANDBY  0x0020
#endif

#define RETURN return

#if !defined(UNICODE) || !defined(_UNICODE)
#error For UNICODE only
#endif

#define	NOREBOOT		1
#define CHECK_ERR(x)


BOOL	bDebug = FALSE;
FILE*	fDebug = NULL;
#define	MSG	\
		if (bDebug) fprintf(fDebug, "File %s, %lu\n", __FILE__, __LINE__); \
		if (bDebug) fprintf

ULONG	Usage(LPSTR ptszAppNane);
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv);
#if NOREBOOT
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv);
#endif
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
#if 0
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv);
#endif
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv);
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg);
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider);
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv);
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv);
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer);
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer);
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer);
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer);
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer);
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer);
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pStorage);
LPTSTR	GetStringParam(LPTSTR ptszParam);

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Core function for the application.
//
//  Arguments:  [argc]    			--      The number of arguments
//				[argv]				--		The arguments
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG __cdecl main(int argc, char* argv[])
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwArgc = 0;
	LPTSTR*	pptszArgv = NULL;
	INT		i = 0;
	INT		nArgNdx = 0;

	if (argc < 2 ||
		argv[1][1]=='?' && (
		argv[1][0]=='-' ||
		argv[1][0]=='/'))
	{
		ulErr = Usage(argv[0]);
		RETURN(ulErr);
	}

	if (NULL == (pptszArgv =
		(LPTSTR*)malloc(sizeof(LPTSTR)*max(argc,32))))
	{
		_ftprintf(stderr,
				  _T("Not enough memory\n"));

		ulErr = ERROR_NOT_ENOUGH_MEMORY;

        CHECK_ERR(ulErr);
		goto Error;
	}
	memset(pptszArgv, 0, sizeof(LPTSTR)*max(argc,32));

	for (i=0; i<argc; i++)
	{
#ifdef UNICODE
		if (NULL == (pptszArgv[i] = (LPTSTR)malloc(
			sizeof(_TCHAR)*(1+strlen(argv[i])))))
		{
			_ftprintf(stderr,
					  _T("Not enough memory\n"));
	
			ulErr = ERROR_NOT_ENOUGH_MEMORY;

            CHECK_ERR(ulErr);
			goto Error;
		}

		memset(pptszArgv[i],
			   0,
			   sizeof(TCHAR)*(1+strlen(argv[i])));
		mbstowcs(pptszArgv[i], argv[i], strlen(argv[i]));
#else
		pptszArgv[i]=argv[i];
#endif
		++dwArgc;
	} //for i

	if (pptszArgv[1] == _tcsstr(pptszArgv[1], _T("/debug")))
	{
		bDebug = TRUE;
		if (_T(':') == pptszArgv[1][strlen("/debug")])
		{
			if (NULL == (fDebug =
				_tfopen(pptszArgv[1]+strlen("/debug")+1, _T("wt+"))))
			{
				fprintf(stderr, "Opening %ws failed with %lu",
						pptszArgv[1]+strlen("/debug")+1,
						errno);
			}
		} //if

		if (NULL == fDebug)
		{
			fDebug = stderr;
		} //if

		MSG(fDebug,
			"\n\nDebug report for %ws\n",
			pptszArgv[0]);
		nArgNdx++;
	} //if

    for (i=0; i<argc; i++)
    {
        MSG(fDebug,
            "\tpptszArgv[%d]==\"%ws\"\n",
            i,
            pptszArgv[i]);
    }
    MSG(fDebug,
        "\tnArgNdx==%d\n",
        nArgNdx);

	if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("add")))
	{
		ulErr = Add(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("remove")))
	{
		ulErr = Remove(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("enum")))
	{
		ulErr = Enum(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getinfo")))
	{
		ulErr = GetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setinfo")))
	{
		ulErr = SetInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getclientinfo")))
	{
		ulErr = GetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setclientinfo")))
	{
		ulErr = SetClientInfo(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
#if NOREBOOT
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdroot")))
	{
		ulErr = AddStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removestdroot")))
	{
		ulErr = RemoveStdRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addftroot")))
	{
		ulErr = AddFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftroot")))
	{
		ulErr = RemoveFtRoot(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("removeftrootforced")))
	{
		ulErr = RemoveFtRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
        CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addstdrootforced")))
	{
		ulErr = AddStdRootForced(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("getdcaddress")))
	{
		ulErr = GetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#if 0
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("setdcaddress")))
	{
		ulErr = SetDcAddress(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetaddconnection")))
	{
		ulErr = AddConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("wnetcancelconnection")))
	{
		ulErr = CancelConnection(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}

	else if (0 == _tcsicmp(pptszArgv[nArgNdx+1], _T("addresstosite")))
	{
		ulErr = AddressToSite(dwArgc-nArgNdx-2, pptszArgv+nArgNdx+2);
		CHECK_ERR(ulErr);
	}
#endif
	else
	{
		ulErr = ERROR_INVALID_PARAMETER;

        CHECK_ERR(ulErr);
		goto Error;
	}

	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	fprintf(stdout, "%ws completed successfully\n", pptszArgv[0]);
	goto Cleanup;

Error:;
	fprintf(stderr, "%ws failed: %lu\n", pptszArgv[0], ulErr);
	goto Cleanup;

Cleanup:;
	if (NULL != pptszArgv)
	{
		DWORD	dwI = 0;

		for (dwI=0; dwI < dwArgc; dwI++)
		{
#ifdef UNICODE
			if (NULL != pptszArgv[dwI])
			{
				free(pptszArgv[dwI]);
				pptszArgv[dwI] = NULL;
			} //if
#endif
		} //for

		free(pptszArgv);
		pptszArgv = NULL;
	} //if

	if (fDebug != NULL && fDebug != stderr)
	{
		fclose(fDebug);
	}

	RETURN(ulErr);
}; //main



	
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   This function prints a help message to stderr
//
//  Arguments:  None.
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Usage(LPSTR ptszAppName)
{
	fprintf(stderr,
			"Usage: %s [/debug:[<filename>]] <command> <options>\n\n"
			"commands:\n"
			"\tadd <dfsentrypath> <server> <share> [<comment> [<options>]]\n"
			"\t    [/range:<lo>-<hi>]\n"
			"\t\toptions=add|restore\n"
			"\t\t/range works with options=add only. When /range is present\n"
			"\t\tthe command adds multiple links\n"
			"\tremove <dfsentrypath> [<server> <share>]\n"
			"\tenum <dfsname> <level> [<prefmaxlen>]\n"
			"\t\tprefmaxlen=integer greater than 0 (resume only)\n"
			"\t\tlevel=1,2,3,4,200\n"
			"\tgetinfo <dfsentrypath> <server> <share> <level>\n"
			"\t\tlevel=1,2,3,4,100\n"
			"\tsetinfo <dfsentrypath> <server> <share> <level> <options>\n"
			"\t\tlevel=100, options=<comment>, no <server>, <share>\n"
			"\t\tlevel=101, options=[active] [offline] [online] when <server> is not null\n"
			"\t\tlevel=101, options=ok|inconsistent|offline|online when <server> is null\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
			"\tgetclientinfo <dfsentrypath> [<server> <share>] <level>\n"
			"\t\tlevel=1,2,3,4\n"
			"\tsetclientinfo <dfsentrypath> [<server> <share>] <level> <options>\n"
			"\t\tlevel=101, options=[active] [offline] [online]\n"
			"\t\tlevel=102, options=<timeout>, no <server>, <share>\n"
#if NOREBOOT
			"\taddstdroot <servername> <rootshare> [<comment> [<options>]]\n"
			"\tremovestdroot <servername> <rootshare> [<options>]\n"
			"\taddftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftroot <servername> <rootshare> <ftdfsname> [<options>]\n"
			"\tremoveftrootforced <domainname> <servername> <rootshare> "
			"<ftdfsname> [<options>]\n"
			"\taddstdrootforced <servername> <rootshare> [<comment>] <store>\n"
#endif
			"\tgetdcaddress <servername>\n"
#if 0
			"\tsetdcaddress <servername> <dcipaddress> <timeout> [<flags>]\n"
#endif
			"\twnetaddconnection <level> <remotename> <password> [<localname>] [<level2params>]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, *, LPT1, etc.\n"
			"\t\tlevel2params=<type> [<provider>] [<username>] [<flags>]\n"
			"\t\ttype=disk|print|any\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\twnetcancelconnection <level> <localname> [<flags>] [force]\n"
			"\t\tlevel=1|2\n"
			"\t\tlocalname=<driverletter>:, etc\n"
			"\t\tflags=[update_profile] [update_recent] "
			"[temporary] [interactive] [prompt] [need_drive] [refcount] "
			"[redirect] [localdrive] [current_media] [deferred]\n"
			"\t\tforce=if present, the deletion of the connection is forced\n"
			"\n"
			"\taddresstosite <dcname> <ipaddress>\n\n"
			"To specify a NULL string in the middle of the command, use "
			"\"\".\n"
			"Example: setinfo \\\\myserver\\myentrypath \"\" \"\" "
			"100 \"My comment\".\n",
			ptszAppName);
	RETURN(ERROR_INVALID_PARAMETER);
};//Usage



	
//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   This function performs NetDfsAdd.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Add(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	ULONG	ulLo = 0;
	ULONG	ulHi = 0;
	LPTSTR	ptszVolName = NULL;
	LPTSTR	ptszRange = NULL;
	LPTSTR	ptszMinus = NULL;

	MSG(fDebug, "Entering Add(%lu,...)\n", dwArgc);
	if (dwArgc < 3 || NULL == pptszArgv || dwArgc > 6)
	{
		MSG(fDebug, "%lu < 3 || NULL == pptszArgv || %lu > 6",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (4 < dwArgc)
	{
		if (0 == _tcsicmp(pptszArgv[4], _T("add")))
		{
			dwFlags = DFS_ADD_VOLUME;
		}
		else if (0 == _tcsicmp(pptszArgv[4], _T("restore")))
		{
			dwFlags = DFS_RESTORE_VOLUME;
		}
		else
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	if (5 < dwArgc)
	{
		if (0 != _tcsnicmp(pptszArgv[5],
						   _T("/range:"),
						   _tcslen(_T("/range:"))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		ptszRange = pptszArgv[5]+_tcslen(_T("/range:"));
		if (NULL == (ptszMinus = _tcschr(ptszRange, _T('-'))))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}

		*ptszMinus = _T('\0');
		ulLo = _ttol(ptszRange);

		*ptszMinus = _T('-');
		ulHi = _ttol(ptszMinus+1);

		if (ulLo > ulHi)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	MSG(fDebug,
		"Calling NetDfsAdd(%ws, %ws, %ws, %ws, %lu)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]), 
		GetStringParam(pptszArgv[3]),
		dwFlags);
	if (0 == ulLo && 0 == ulHi)
	{
		ulErr = NetDfsAdd(GetStringParam(pptszArgv[0]),
						  GetStringParam(pptszArgv[1]),
						  GetStringParam(pptszArgv[2]),
						  GetStringParam(pptszArgv[3]),
						  dwFlags);
	}
	else
	{
		ULONG	ulLen = 0;

		if (NULL != GetStringParam(pptszArgv[0]))
		{
			ulLen += _tcslen(GetStringParam(pptszArgv[0]));
		}

		ptszVolName = new TCHAR[ulLen+11];
		if (NULL != ptszVolName)
		{
			memset(ptszVolName, 0, (11+ulLen) * sizeof(TCHAR));
			if (NULL != GetStringParam(pptszArgv[0]))
			{
				_tcscpy(ptszVolName, GetStringParam(pptszArgv[0]));
			}

			for (ULONG i=ulLo;
				 i <= ulHi && ERROR_SUCCESS == ulErr;
				 i++)
			{
				memset(ptszVolName+ulLen, 0, sizeof(TCHAR)*11);
				_ltot(i, ptszVolName+ulLen, 10);

				ulErr = NetDfsAdd(ptszVolName,
								  GetStringParam(pptszArgv[1]),
								  GetStringParam(pptszArgv[2]),
								  GetStringParam(pptszArgv[3]),
								  dwFlags);
				MSG(fDebug,
					"NetDfsAdd(%ws, %ws, %ws, %ws, %lu) %s\n",
					ptszVolName,
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					GetStringParam(pptszArgv[3]),
					dwFlags,
					((ERROR_SUCCESS == ulErr) ? "succeded" : "failed"));
			} //for

			delete ptszVolName;
		}
		else
		{
			MSG(fDebug,
				"Error %lu: not enough memory\n",
				ulErr = ERROR_NOT_ENOUGH_MEMORY);
		} //else
	} //else

	MSG(fDebug, "Exiting Add(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Add



	
//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   This function performs NetDfsRemove.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Remove(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug, "Entering Remove(%lu,..)\n", dwArgc);
	if (dwArgc < 1 || dwArgc > 3 || NULL == pptszArgv ||
		dwArgc > 1 && NULL == pptszArgv[1] ||
		dwArgc > 2 && NULL == pptszArgv[2] ||
		2 == dwArgc)
	{
		MSG(fDebug,
			"%lu < 1 || %lu > 3 || NULL == pptszArgv ||"
			" %lu > 1 && NULL == %ws ||"
			" %lu > 2 && NULL == %ws ||"
			" 2 == %lu",
			dwArgc, dwArgc, dwArgc, pptszArgv[1], dwArgc,
			pptszArgv[2], dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug, "Calling NetDfsRemove(%ws, %ws, %ws)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]));
	ulErr = NetDfsRemove(GetStringParam(pptszArgv[0]),
						 GetStringParam(pptszArgv[1]),
						 GetStringParam(pptszArgv[2]));

	MSG(fDebug, "Exiting Remove(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //Remove



	
//+---------------------------------------------------------------------------
//
//  Function:   Enum
//
//  Synopsis:   This function performs NetDfsEnum.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	Enum(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	DWORD	dwPrefMaxLen = (DWORD)-1;
	LPBYTE	pBuffer = NULL;
	DWORD	dwEntriesRead = 0;
	DWORD	dwResumeHandle = 0;

	MSG(fDebug, "Entering Enum(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 ||
		NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[1], _T("1")))
	{
		dwLevel = 1;
		dwPrefMaxLen = sizeof(DFS_INFO_1);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("2")))
	{
		dwLevel = 2;
		dwPrefMaxLen = sizeof(DFS_INFO_2);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("3")))
	{
		dwLevel = 3;
		dwPrefMaxLen = sizeof(DFS_INFO_3);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("4")))
	{
		dwLevel = 4;
		dwPrefMaxLen = sizeof(DFS_INFO_4);
	}
	else if (0 == _tcsicmp(pptszArgv[1], _T("200")))
	{
		dwLevel = 200;
		dwPrefMaxLen = sizeof(DFS_INFO_200);
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc)
	{
		dwPrefMaxLen = (DWORD)-1;
	}
	else
	{
		if (3 != dwArgc || NULL == pptszArgv[2] ||
			0 >= _ttoi(pptszArgv[2]))
		{
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		dwPrefMaxLen *= _ttoi(pptszArgv[2]);
	}

	MSG(fDebug, "Calling NetDfsEnum(%ws,%lu,%lu,..,..,%lu)\n",
		pptszArgv[0], dwLevel, dwPrefMaxLen, dwResumeHandle);
	ulErr = NetDfsEnum(GetStringParam(pptszArgv[0]),
                       dwLevel,
					   dwPrefMaxLen,
					   &pBuffer,
					   &dwEntriesRead,
					   &dwResumeHandle);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	if ((DWORD)-1 == dwPrefMaxLen)
	{
		LPBYTE	pCurBuffer = pBuffer;
		for (DWORD i=0; i<dwEntriesRead; i++)
		{
			ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}

			switch (dwLevel)
			{
				case 1:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
					break;
				case 2:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
					break;
				case 3:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
					break;
				case 4:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
					break;
				case 200:
					pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
					break;
				default:
					ulErr = ERROR_INVALID_PARAMETER;
					goto Error;
			} //switch
		} //for
	}
	else
	{
		do
		{
			LPBYTE	pCurBuffer = pBuffer;
			for (DWORD i=0; i<dwEntriesRead; i++)
			{
				ulErr = PrintDfsInfo(dwLevel, pCurBuffer);
				if (ERROR_SUCCESS != ulErr)
				{
					goto Error;
				}
	
				switch (dwLevel)
				{
					case 1:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_1)pCurBuffer)+1);
						break;
					case 2:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_2)pCurBuffer)+1);
						break;
					case 3:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_3)pCurBuffer)+1);
						break;
					case 4:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_4)pCurBuffer)+1);
						break;
					case 200:
						pCurBuffer = (LPBYTE)(((PDFS_INFO_200)pCurBuffer)+1);
						break;
					default:
						ulErr = ERROR_INVALID_PARAMETER;
						goto Error;
				} //switch
			} //for

			if (NULL != pBuffer)
			{
				NetApiBufferFree(pBuffer);
				pBuffer = NULL;
			}

			MSG(fDebug,
				"Calling NetDfsEnum(%ws, %lu, %lu,..,..,%lu)\n",
				GetStringParam(pptszArgv[0]),
				dwLevel,
				dwPrefMaxLen,
				dwResumeHandle);
			ulErr = NetDfsEnum(
						GetStringParam(pptszArgv[0]),
						dwLevel,
						dwPrefMaxLen,
						&pBuffer,
						&dwEntriesRead,
						&dwResumeHandle);
			if (ERROR_NO_MORE_ITEMS == ulErr)
			{
				if (0 != dwEntriesRead)
				{
					continue;
				}
				else
				{
					ulErr = ERROR_SUCCESS;
					break;
				}
			} //if

			if (ERROR_SUCCESS != ulErr)
			{
				goto Error;
			}
		}
		while(TRUE);
	} //else

Error:;
	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug,
		"Exiting Enum with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //Enum




	
//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   This function performs NetDfsGetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug, "4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		dwLevel = 100;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Calling NetDfsGetInfo(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
		GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetInfo(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[2]),
				dwLevel,
				&pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetInfo




	
//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   This function performs NetDfsSetInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug,
		"Calling SetInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("100")))
	{
		DFS_INFO_100 info;

		if (4 < dwArgc)
		{
			if (5 != dwArgc)
			{
				MSG(fDebug,
					"%ws == \"100\" && 5 != %dwArgc\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			}

			info.Comment = pptszArgv[4];
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            GetStringParam(pptszArgv[2]),
			100);
		ulErr = NetDfsSetInfo(
					GetStringParam(pptszArgv[0]),
					GetStringParam(pptszArgv[1]),
					GetStringParam(pptszArgv[2]),
					100,
					(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws==\"101\" && "
					"4 < %lu && "
					"8 < %lu",
					pptszArgv[3], dwArgc, dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			if (NULL != GetStringParam(pptszArgv[1]))
			{
				if (NULL == GetStringParam(pptszArgv[2]))
				{
					MSG(fDebug,
						"4 < %lu && "
						"NULL != %ws && "
						"NULL == %ws\n",
						dwArgc, GetStringParam(pptszArgv[1]),
						GetStringParam(pptszArgv[2]));
					RETURN(ERROR_INVALID_PARAMETER);
				}

				for (i = 4; i<dwArgc; i++)
				{
					if (0 == _tcsicmp(pptszArgv[i], _T("active")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ACTIVE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_OFFLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_STORAGE_STATE_ONLINE;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("standby")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_STANDBY))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_VOLUME_STATE_STANDBY;
					}
					else if (0 == _tcsicmp(pptszArgv[i], _T("master")))
					{
						if (0 != (info.State & DFS_STORAGE_STATE_MASTER))
						{
							RETURN(ERROR_INVALID_PARAMETER);
						}
						info.State |= DFS_VOLUME_STATE_RESYNCHRONIZE;
					}
					else
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
				} //for i
			}
			else
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("ok")))
				{
					info.State = DFS_VOLUME_STATE_OK;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("inconsistent")))
				{
					info.State = DFS_VOLUME_STATE_INCONSISTENT;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					info.State = DFS_VOLUME_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					info.State = DFS_VOLUME_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //else
		} //if

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetInfo(GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  101,
							  (LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		} //if

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[4],
					dwTimeout);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;

		MSG(fDebug,
			"Calling NetDfsSetInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetInfo(
							  GetStringParam(pptszArgv[0]),
							  GetStringParam(pptszArgv[1]),
							  GetStringParam(pptszArgv[2]),
							  102,
							  (LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Exiting SetInfo(..) with %lu", ulErr);
	RETURN(ulErr);
}; //SetInfo




	
//+---------------------------------------------------------------------------
//
//  Function:   GetClientInfo
//
//  Synopsis:   This function performs NetDfsGetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwLevel = 0;
	LPBYTE	pBuffer = NULL;

	MSG(fDebug,
		"Entering GetClientInfo(%lu,..)\n",
		dwArgc);
	if (4 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"4 != %lu || NULL == pptszArgv",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[3], _T("1")))
	{
		dwLevel = 1;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("2")))
	{
		dwLevel = 2;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("3")))
	{
		dwLevel = 3;
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("4")))
	{
		dwLevel = 4;
	}
	else
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug,
		"Calling NetDfsGetClientInfo"
		"(%ws,%ws,%ws,%lu,..)\n",
		GetStringParam(pptszArgv[0]),
		GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwLevel);
	ulErr = NetDfsGetClientInfo(
			  GetStringParam(pptszArgv[0]),
			  GetStringParam(pptszArgv[1]),
			  GetStringParam(pptszArgv[2]),
			  dwLevel,
			  &pBuffer);
	
	if (ERROR_SUCCESS == ulErr)
	{
		ulErr = PrintDfsInfo(dwLevel, pBuffer);
	}

	if (NULL != pBuffer)
	{
		NetApiBufferFree(pBuffer);
		pBuffer = NULL;
	}

	MSG(fDebug, "Exiting GetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetClientInfo





//+---------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Synopsis:   This function performs NetDfsSetClientInfo.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetClientInfo(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	DWORD	dwTimeout = 0;
	DWORD	i = 0;

	MSG(fDebug, "Entering SetClientInfo(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || NULL == pptszArgv\n",
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (0 == _tcsicmp(pptszArgv[3], _T("101")))
	{
		DFS_INFO_101 info;

		info.State = 0;
		if (4 < dwArgc)
		{
			if (8 < dwArgc)
			{
				MSG(fDebug,
					"%ws == \"101\" && "
					"4 < %lu && "
					"8 < %lu\n",
					pptszArgv[3],
					dwArgc,
					dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if

			for (i = 4; i<dwArgc; i++)
			{
				if (0 == _tcsicmp(pptszArgv[i], _T("active")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ACTIVE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ACTIVE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("offline")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_OFFLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_OFFLINE;
				}
				else if (0 == _tcsicmp(pptszArgv[i], _T("online")))
				{
					if (0 != (info.State & DFS_STORAGE_STATE_ONLINE))
					{
						RETURN(ERROR_INVALID_PARAMETER);
					}
					info.State |= DFS_STORAGE_STATE_ONLINE;
				}
				else
				{
					RETURN(ERROR_INVALID_PARAMETER);
				}
			} //for i
		} //if

		MSG(fDebug,
			"Calling NetDfsSetClientInfo(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			101);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									101,
									(LPBYTE)&info);
	}
	else if (0 == _tcsicmp(pptszArgv[3], _T("102")))
	{
		DFS_INFO_102 info;

		if (5 != dwArgc)
		{
			MSG(fDebug,
				"%ws==\"102\" && "
				"5 != %lu\n",
				pptszArgv[3], dwArgc);
			RETURN(ERROR_INVALID_PARAMETER);
		}

		if (0 == _tcsicmp(pptszArgv[4], _T("0")))
		{
			dwTimeout = 0;
		}
		else
		{
			if (0 == (dwTimeout = _ttoi(pptszArgv[4])))
			{
				MSG(fDebug,
					"%ws==\"102\" && "
					"0 == %lu\n",
					pptszArgv[3], dwArgc);
				RETURN(ERROR_INVALID_PARAMETER);
			} //if
		} //else

		info.Timeout = dwTimeout;


		MSG(fDebug,
			"Calling NetDfsSetClientInfo"
			"(%ws,%ws,%ws,%lu,..)\n",
			GetStringParam(pptszArgv[0]),
			GetStringParam(pptszArgv[1]),
			GetStringParam(pptszArgv[2]),
			102);
		ulErr = NetDfsSetClientInfo(GetStringParam(pptszArgv[0]),
									GetStringParam(pptszArgv[1]),
									GetStringParam(pptszArgv[2]),
									102,
									(LPBYTE)&info);
	}
	else
	{
		MSG(fDebug, "Invalid first parameter\n");
		RETURN(ERROR_INVALID_PARAMETER);
	}

	MSG(fDebug, "Exiting SetClientInfo(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //SetClientInfo




#if NOREBOOT
//+---------------------------------------------------------------------------
//
//  Function:   AddStdRoot
//
//  Synopsis:   This function performs NetDfsAddStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	MSG(fDebug,
		"Calling NetDfsAddStdRoot(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsAddStdRoot(
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]),
                GetStringParam(pptszArgv[2]),
				dwOptions);

	MSG(fDebug, "Exiting AddStdRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   RemoveStdRoot
//
//  Synopsis:   This function performs NetDfsRemoveStdRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveStdRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveStdRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 3 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 2 || %lu > 3 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (3 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[2]);
	}

	MSG(fDebug,
		"Calling NetDfsRemoveStdRoot"
		"(%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		dwOptions);
	ulErr = NetDfsRemoveStdRoot(
			GetStringParam(pptszArgv[0]),
            GetStringParam(pptszArgv[1]),
            dwOptions);

	MSG(fDebug,
		"Exiting RemoveStdRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveStdRoot




//+---------------------------------------------------------------------------
//
//  Function:   AddFtRoot
//
//  Synopsis:   This function performs NetDfsAddFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[4]);
	}

	MSG(fDebug,
		"Calling NetDfsAddFtRoot(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
        GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsAddFtRoot(GetStringParam(pptszArgv[0]),
							GetStringParam(pptszArgv[1]),
							GetStringParam(pptszArgv[2]),
							GetStringParam(pptszArgv[3]),
							dwOptions);

	MSG(fDebug, "Exiting AddFtRoot(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRoot
//
//  Synopsis:   This function performs NetDfsRemoveFtRoot.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRoot(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRoot(%lu,..)\n",
		dwArgc);
	if (dwArgc < 3 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || %lu > 4 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (4 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRoot"
		"(%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		dwOptions);
	ulErr = NetDfsRemoveFtRoot(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[2]),
							   dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRoot(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRoot





//+---------------------------------------------------------------------------
//
//  Function:   RemoveFtRootForced
//
//  Synopsis:   This function performs NetDfsRemoveFtRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	RemoveFtRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering RemoveFtRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 4 || dwArgc > 5 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 4 || %lu > 5 || NULL == pptszArgv\n",
			dwArgc, dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	if (5 == dwArgc)
	{
		dwOptions = _ttoi(pptszArgv[3]);
	}

	//
	//	BUGBUG
	//
	//	for the time being we ignore every option
	//
	dwOptions = 0;
	
	MSG(fDebug,
		"Calling NetDfsRemoveFtRootForced"
		"(%ws,%ws,%ws,%ws,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]),
		dwOptions);
	ulErr = NetDfsRemoveFtRootForced(GetStringParam(pptszArgv[0]),
									 GetStringParam(pptszArgv[1]),
									 GetStringParam(pptszArgv[2]),
									 GetStringParam(pptszArgv[3]),
									 dwOptions);

	MSG(fDebug,
		"Exiting RemoveFtRootForced(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //RemoveFtRootForced





//+---------------------------------------------------------------------------
//
//  Function:   AddStdRootForced
//
//  Synopsis:   This function performs NetDfsAddStdRootForced.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddStdRootForced(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsAddStdRootForced(%ws,%ws,%ws,%ws)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
        GetStringParam(pptszArgv[2]),
		GetStringParam(pptszArgv[3]));
	ulErr = NetDfsAddStdRootForced(GetStringParam(pptszArgv[0]),
								   GetStringParam(pptszArgv[1]),
								   GetStringParam(pptszArgv[2]),
								   GetStringParam(pptszArgv[3]));

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot





//+---------------------------------------------------------------------------
//
//  Function:   GetDcAddress
//
//  Synopsis:   This function performs NetDfsGetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwOptions = 0;
	LPTSTR	ptszIpAddress = NULL;
	BOOLEAN	bIsRoot = FALSE;
	ULONG	ulTimeout = 0;

	MSG(fDebug,
		"Entering AddStdRootForced(%lu,..)\n",
		dwArgc);
	if (1 != dwArgc || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu != 1 || NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	MSG(fDebug,
		"Calling NetDfsGetDcAddress(%ws,...)\n",
		GetStringParam(pptszArgv[0]));
	ulErr = NetDfsGetDcAddress(GetStringParam(pptszArgv[0]),
							   &ptszIpAddress,
							   &bIsRoot,
							   &ulTimeout);

	if (ERROR_SUCCESS == ulErr)
	{
		LPTSTR	ptszIs = bIsRoot?_T("is"):_T("is not");

		fprintf(stdout,
				"%ws %ws a Dfs server and it will be "
				"sticking to the DC having the %ws "
				"address for %lu seconds\n",
				GetStringParam(pptszArgv[0]),
				ptszIs,
				ptszIpAddress,
				ulTimeout);
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve DC address "
				"for %ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]));
	}

	if (NULL != ptszIpAddress)
	{
		NetApiBufferFree(ptszIpAddress);
	}

	MSG(fDebug, "Exiting AddStdRootForced(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //GetDcAddress




#if 0
//+---------------------------------------------------------------------------
//
//  Function:   SetDcAddress
//
//  Synopsis:   This function performs NetDfsSetDcAddress.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	SetDcAddress(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	ULONG	ulTimeout = 0;
	ULONG	ulFlags = 0;

	MSG(fDebug,
		"Entering SetDcAddress(%lu,..)\n",
		dwArgc);
	if (dwArgc < 2 || dwArgc > 4 || NULL == pptszArgv)
	{
		MSG(fDebug,
			"%lu < 3 || "
			"%lu > 4 || "
			"NULL == pptszArgv\n",
			dwArgc,
			dwArgc);
		RETURN(ERROR_INVALID_PARAMETER);
	} //if

	ulTimeout = (ULONG)_ttol(GetStringParam(pptszArgv[2]));
	ulFlags = 0;

	MSG(fDebug,
		"Calling NetDfsSetDcAddress(%ws,%ws,%lu,%lu)\n",
		GetStringParam(pptszArgv[0]),
        GetStringParam(pptszArgv[1]),
		ulTimeout,
		ulFlags);
	ulErr = NetDfsSetDcAddress(GetStringParam(pptszArgv[0]),
							   GetStringParam(pptszArgv[1]),
							   ulTimeout,
							   ulFlags);

	MSG(fDebug, "Exiting NetDfsSetDcAddress(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //AddStdRoot
#endif	// 0
#endif	// NOREBOOT




#if 0
//+---------------------------------------------------------------------------
//
//  Function:   AddConnection
//
//  Synopsis:   This function performs WNetAddConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = AddConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = AddConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //AddConnection





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection1
//
//  Synopsis:   This function performs WNetAddConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //AddConnection1





//+---------------------------------------------------------------------------
//
//  Function:   AddConnection2
//
//  Synopsis:   This function performs WNetAddConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG		ulErr = ERROR_SUCCESS;
	NETRESOURCE	NetResource;
	DWORD		dwFlags = 0;
	TCHAR		tszLocalName[128+1];
	ULONG		ulLocalNameLen = 128;

	MSG(fDebug,
		 "Entering AddConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 5)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}
	
	memset(tszLocalName, 0, sizeof(tszLocalName));
	ulErr = GetLocalName(tszLocalName,
						 ulLocalNameLen,
						 GetStringParam(pptszArgv[2]));
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	ulErr = GetNetResource(&NetResource,
						   GetStringParam(pptszArgv[3]),	// type
						   tszLocalName,					// localname
						   GetStringParam(pptszArgv[0]),	// remotename
						   GetStringParam(pptszArgv[4]));	// provider
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}

	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-6,
								   pptszArgv+6);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		 "Calling WNetAddConnection2(.., %ws, %ws, %lu)\n",
		 GetStringParam(pptszArgv[1]),
		 GetStringParam(pptszArgv[5]),
		 dwFlags);
	ulErr = WNetAddConnection2(&NetResource,
							   GetStringParam(pptszArgv[1]),
							   GetStringParam(pptszArgv[5]),
							   dwFlags);
Error:;	
	
	MSG(fDebug,
		 "Exiting AddConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //AddConnection2





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection
//
//  Synopsis:   This function performs WNetCancelConnectionX.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	if (0 == dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (0 == _tcsicmp(pptszArgv[0], _T("1")))
	{
		ulErr = CancelConnection1(dwArgc-1, pptszArgv+1);
	}
	else if (0 == _tcsicmp(pptszArgv[0], _T("2")))
	{
		ulErr = CancelConnection2(dwArgc-1, pptszArgv+1);
	}
	else
	{
		MSG(fDebug,
			 "Error %lu: invalid level: %ws\n",
			 ulErr = ERROR_INVALID_PARAMETER,
			 pptszArgv[0]);
	}

	RETURN(ulErr);
}; //CancelConnection





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection1
//
//  Synopsis:   This function performs WNetCancelConnection.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection1(DWORD dwArgc, LPTSTR* pptszArgv)
{
	RETURN(ERROR_INVALID_FUNCTION);
}; //CancelConnection1





//+---------------------------------------------------------------------------
//
//  Function:   CancelConnection2
//
//  Synopsis:   This function performs WNetCancelConnection2.
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	CancelConnection2(DWORD dwArgc, LPTSTR* pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwFlags = 0;
	BOOL	bForce = FALSE;

	MSG(fDebug,
		 "Entering CancelConnection2(%lu, ..)\n",
		 dwArgc);
	if (NULL == pptszArgv || dwArgc <= 0)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (2 == dwArgc	&&
		0 == _tcsicmp(_T("force"), pptszArgv[dwArgc-1]))
	{
		bForce = TRUE;
		--dwArgc;
	}
	
	ulErr = GetWNetConnectionFlags(&dwFlags,
								   dwArgc-1,
								   pptszArgv+1);
	if (ERROR_SUCCESS != ulErr)
	{
		goto Error;
	}
	
	MSG(fDebug,
		"Calling WNetCancelConnection2(%ws, %lu, %ws)\n",
		GetStringParam(pptszArgv[0]),
		dwFlags,
		bForce ? _T("TRUE") : _T("FALSE"));
	ulErr = WNetCancelConnection2(GetStringParam(pptszArgv[0]),
								  dwFlags,
								  bForce);
	
Error:;	
	
	MSG(fDebug,
		 "Exiting CancelConnection2(..) with %lu\n",
		 ulErr);
	RETURN(ulErr);
}; //CancelConnection2


#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetLocalName
//
//  Synopsis:   This function returns the first available letter for net 
//				use
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetLocalName(LPTSTR	ptszLocalName,
					 ULONG	ulLocalNameLen,
					 LPTSTR	ptszArg)
{
	ULONG	ulErr = ERROR_SUCCESS;
	CHAR	szDrive[4];
	BOOL	bFound = FALSE;

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws)\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg);
	if (NULL != ptszArg	&&
		0 != _tcsicmp(ptszArg, _T("available")) &&
		0 != _tcsicmp(ptszArg, _T("*")))
	{
		if (ulLocalNameLen < _tcslen(ptszArg))
		{
			RETURN(ERROR_NO_SYSTEM_RESOURCES);
		}

		_tcscpy(ptszLocalName, ptszArg);
	}
	else
	{
		if (ulLocalNameLen < 2)
		{
			RETURN(ERROR_INVALID_PARAMETER);
		}
	}

	szDrive[1] = ':';
	szDrive[2] = '\\';
	szDrive[3] = '\0';
	for (CHAR C='C'; !bFound && C<='Z'; C++)
	{
		ULONG	ulType = 0;

		szDrive[0] = C;
		switch (ulType = GetDriveTypeA(szDrive))
		{
			case	0:
			case	DRIVE_REMOVABLE:
			case	DRIVE_FIXED:
			case	DRIVE_REMOTE:
			case	DRIVE_CDROM:
			case	DRIVE_RAMDISK:
				MSG(fDebug,
					"%s is of type %lu\n",
					szDrive,
					ulType);
				continue;

			case	1:
				bFound = TRUE;
				break;

			default:
				ASSERT(FALSE);
		}// switch
	} //for

	if (!bFound)
	{
		ulErr = ERROR_NO_SYSTEM_RESOURCES;
	}
	else
	{
		szDrive[2] = '\0';
#ifdef	UNICODE
		mbstowcs(ptszLocalName, szDrive, ulLocalNameLen);
#else
		_strcpy(ptszLocalName, szDrive);
#endif
	}

	MSG(fDebug,
		"Entering GetNetResource(%ws, %lu, %ws) with %lu\n",
		ptszLocalName,
		ulLocalNameLen,
		ptszArg,
		ulErr);
	RETURN(ulErr);
}; //GetLocalName




//+---------------------------------------------------------------------------
//
//  Function:   GetNetResource
//
//  Synopsis:   This function fils a NETRESOURCE structure out
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetNetResource(NETRESOURCE*	pNetResource,
					   LPTSTR		ptszType,
					   LPTSTR		ptszLocalName,
					   LPTSTR		ptszRemoteName,
					   LPTSTR		ptszProvider)
{
	ULONG	ulErr = ERROR_SUCCESS;
	DWORD	dwType = 0;
	
	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws)\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider);
	if (NULL == pNetResource	||
		NULL == ptszType)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	memset(pNetResource, 0, sizeof(NETRESOURCE));
	if (0 == _tcsicmp(ptszType, _T("disk")))
	{
		dwType = RESOURCETYPE_DISK;
	}
	else if (0 == _tcsicmp(ptszType, _T("print")))
	{
		dwType = RESOURCETYPE_PRINT;
	}
	else if (0 == _tcsicmp(ptszType, _T("any")))
	{
		dwType = RESOURCETYPE_ANY;
	}
	else
	{
		MSG(fDebug,
			 "%ws is an invalid type\n",
			 ptszType);
		RETURN(ERROR_INVALID_PARAMETER);
	}

	pNetResource->dwType = dwType;
	pNetResource->lpLocalName = ptszLocalName;
	pNetResource->lpRemoteName = ptszRemoteName;
	pNetResource->lpProvider = ptszProvider;

	MSG(fDebug,
		 "Entering GetNetResource(.., %ws, %ws, %ws, %ws) with %lu\n",
		 ptszType,
		 ptszLocalName,
		 ptszRemoteName,
		 ptszProvider,
		 ulErr);
	RETURN(ulErr);
}; //GetNetResource





//+---------------------------------------------------------------------------
//
//  Function:   GetWNetConnectionFlags
//
//  Synopsis:   This function returns flags for WNetAddConnection2
//
//  Arguments:  [...]
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	GetWNetConnectionFlags(DWORD*	pdwFlags,
							   DWORD	dwArgc,
							   LPTSTR*	pptszArgv)
{
	ULONG	ulErr = ERROR_SUCCESS;

	MSG(fDebug,
		 "Entering CWNetAddConnection2Flags(.., %lu, ..)\n",
		 dwArgc);
	if (NULL == pdwFlags	||
		NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	*pdwFlags = 0;
	for (ULONG i=0; i<dwArgc; i++)
	{
		if (0 == _tcsicmp(_T("update_profile"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_PROFILE;
		}
		else if (0 == _tcsicmp(_T("update_recent"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_UPDATE_RECENT;
		}
		else if (0 == _tcsicmp(_T("temporary"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_TEMPORARY;
		}
		else if (0 == _tcsicmp(_T("interactive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_INTERACTIVE;
		}
		else if (0 == _tcsicmp(_T("prompt"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_PROMPT;
		}
		else if (0 == _tcsicmp(_T("need_drive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_NEED_DRIVE;
		}
		else if (0 == _tcsicmp(_T("refcount"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REFCOUNT;
		}
		else if (0 == _tcsicmp(_T("redirect"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_REDIRECT;
		}
		else if (0 == _tcsicmp(_T("localdrive"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_LOCALDRIVE;
		}
		else if (0 == _tcsicmp(_T("current_media"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_CURRENT_MEDIA;
		}
		else if (0 == _tcsicmp(_T("deferred"), pptszArgv[i]))
		{
			*pdwFlags |= CONNECT_DEFERRED;
		}
		else
		{
			MSG(fDebug,
				 "Error %lu: %ws is an invalid flag\n",
				 ulErr = ERROR_INVALID_PARAMETER,
				 pptszArgv[i]);
		}
	} //for

	MSG(fDebug,
		 "Exiting CWNetAddConnection2Flags(.., %lu, ..) with %lu\n",
		 dwArgc,
		 ulErr);
	RETURN(ulErr);
}; //GetWNetAddconnection2Flags



#if 0
//+---------------------------------------------------------------------------
//
//  Function:   AddressToSite
//
//  Synopsis:   This function performs DsAddressToSiteNames
//
//  Arguments:  [dwArg]		the number of arguments
//				[pptszArg]	the arguments
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	AddressToSite(DWORD		dwArgc,
					  LPTSTR*	pptszArgv)
{
	ULONG			ulErr = ERROR_SUCCESS;
	CString			sIp;
	CStringA		sIpA;
	ULONG			ulIP = 0;
	WSADATA			wsaData;
	PHOSTENT		pHost = NULL;
	SOCKET_ADDRESS	SocketAddress;
	SOCKADDR_IN		SockAddrIn;
	LPTSTR*			pptszSites = NULL;

	MSG(fDebug,
		"Entering AddressToSite(%lu, ...)\n",
		dwArgc);

	if (2 != dwArgc || NULL == pptszArgv)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	if (NULL == GetStringParam(pptszArgv[1]))
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	ulErr = sIp.Set(GetStringParam(pptszArgv[1]));
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}

	ulErr = sIpA.Set(sIp);
	if (ERROR_SUCCESS != ulErr)
	{
		RETURN(ulErr);
	}
	
	ulIP = inet_addr(sIpA.GetStringA());
	if (INADDR_NONE == ulIP)
	{
		fprintf(stderr,
				"Error %lu: invalid address %s\n",
				ulErr = ERROR_INVALID_PARAMETER,
				sIpA.GetStringA());
		RETURN(ulErr);
	}

	ulErr = WSAStartup(MAKEWORD(2,2),
					   &wsaData);
	if (ERROR_SUCCESS != ulErr)
	{
		fprintf(stderr,
				"Error %lu: cannot startup sockets",
				ulErr);
		RETURN(ulErr);
	}

	pHost = gethostbyaddr((LPCSTR)&ulIP,
						  sizeof(ulIP),
						  AF_INET);
	if (NULL == pHost)
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve host address "
				"for %ws",
				ulErr = WSAGetLastError(),
				GetStringParam(pptszArgv[1]));

		WSACleanup();
		RETURN(ulErr);
	}

	
	SockAddrIn.sin_family = pHost->h_addrtype;
	SockAddrIn.sin_port = 0;
	memcpy(&SockAddrIn.sin_addr,
		   pHost->h_addr,
		   pHost->h_length);

	SocketAddress.iSockaddrLength = sizeof(SockAddrIn);
	SocketAddress.lpSockaddr = (LPSOCKADDR)&SockAddrIn;

	ulErr = DsAddressToSiteNames(GetStringParam(pptszArgv[0]),
								 1,
								 &SocketAddress,
								 &pptszSites);
	if (ERROR_SUCCESS == ulErr && NULL != pptszSites[0])
	{
		fprintf(stdout,
				"The site of %ws on DC \\\\%ws is %ws\n",
				GetStringParam(pptszArgv[1]),
				GetStringParam(pptszArgv[0]),
				pptszSites[0]);
		NetApiBufferFree(pptszSites);
	}
	else if (ERROR_SUCCESS == ulErr && NULL == pptszSites[0])
	{
		fprintf(stdout,
				"Error %lu: address %ws is not associated "
				"to a site or it has an invalid format\n",
				ulErr = ERROR_INVALID_PARAMETER,
				GetStringParam(pptszArgv[1]));
	}
	else
	{
		fprintf(stderr,
				"Error %lu: cannot retrieve site of "
				"%ws from DC \\\\%ws\n",
				ulErr,
				GetStringParam(pptszArgv[0]),
				GetStringParam(pptszArgv[1]));
	}

	WSACleanup();

	MSG(fDebug,
		"Exiting AddressToSite(%lu, ...) with %lu\n",
		dwArgc,
		ulErr);
	RETURN(ulErr);
};	// AddressToSite



#endif

//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo
//
//  Synopsis:   This function prints a DFS_INFO_XXX buffer out.
//
//  Arguments:  [dwLevel]	the info level
//				[pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo(DWORD dwLevel, LPBYTE pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo(%lu,..)\n",
		dwLevel);
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	switch (dwLevel)
	{
		case 1:
			ulErr = PrintDfsInfo1((PDFS_INFO_1)pBuffer);
			break;
		case 2:
			ulErr = PrintDfsInfo2((PDFS_INFO_2)pBuffer);
			break;
		case 3:
			ulErr = PrintDfsInfo3((PDFS_INFO_3)pBuffer);
			break;
		case 4:
			ulErr = PrintDfsInfo4((PDFS_INFO_4)pBuffer);
			break;
		case 200:
			ulErr = PrintDfsInfo200((PDFS_INFO_200)pBuffer);
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);		
	} //switch

	MSG(fDebug,
		"Exiting PrintDfsInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo1
//
//  Synopsis:   This function prints a DFS_INFO_1 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo1(PDFS_INFO_1 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo1(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->EntryPath);

	MSG(fDebug,
		"Exiting PrintDfsInfo1(..) witb %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo1





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo2
//
//  Synopsis:   This function prints a DFS_INFO_2 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo2(PDFS_INFO_2 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo2(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);

	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
        fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);

	MSG(fDebug,
		"Exiting PrintDfsInfo2(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo2





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo3
//
//  Synopsis:   This function prints a DFS_INFO_3 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo3(PDFS_INFO_3 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo3(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
	fprintf(stdout, "%lu\n", pBuffer->NumberOfStorages);
	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo3(..) with %lu\n", ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo3





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo4
//
//  Synopsis:   This function prints a DFS_INFO_4 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo4(PDFS_INFO_4 pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	DWORD				i = 0;
	PDFS_STORAGE_INFO	pStorage = NULL;
	
	MSG(fDebug,
		"Entering PrintDfsInfo4(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws    ", pBuffer->EntryPath);
	fprintf(stdout, "\"%ws\"    ", pBuffer->Comment);
	switch (pBuffer->State & 0xff)
	{
		case DFS_VOLUME_STATE_OK:
			fprintf(stdout, "OK      ");
			break;
		case DFS_VOLUME_STATE_INCONSISTENT:
			fprintf(stdout, "INCONS  ");
			break;
		case DFS_VOLUME_STATE_ONLINE:
			fprintf(stdout, "ONLINE  ");
			break;
		case DFS_VOLUME_STATE_OFFLINE:
			fprintf(stdout, "OFFLINE ");
			break;
		default:
			RETURN(ERROR_INVALID_PARAMETER);
	} //switch
	switch (pBuffer->State & DFS_VOLUME_FLAVORS)
	{
        case DFS_VOLUME_FLAVOR_STANDALONE:
                fprintf(stdout, "Standalone      ");
                break;
        case DFS_VOLUME_FLAVOR_AD_BLOB:
                fprintf(stdout, "Ad Blob         ");
                break;
	} //switch
	
	fprintf(stdout, "%lus   ", pBuffer->Timeout);
	fprintf(stdout, "%lu storage(s)\n", pBuffer->NumberOfStorages);

	for (i=0, pStorage=pBuffer->Storage;
		 i<pBuffer->NumberOfStorages && ERROR_SUCCESS == ulErr; 
		 i++,pStorage=pBuffer->Storage+i)
	{
		ulErr = PrintStgInfo(pStorage);
	}

	MSG(fDebug,
		"Exiting PrintDfsInfo4(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintDfsInfo200
//
//  Synopsis:   This function prints a DFS_INFO_200 buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintDfsInfo200(PDFS_INFO_200 pBuffer)
{
	ULONG	ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintDfsInfo200(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "%ws\n", pBuffer->FtDfsName);

	MSG(fDebug,
		"Exiting PrintDfsInfo200(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintDfsInfo4





//+---------------------------------------------------------------------------
//
//  Function:   PrintStgInfo
//
//  Synopsis:   This function prints a DFS_STORAGE_INFO buffer out.
//
//  Arguments:  [pBuffer]	the info buffer
//
//  Returns:    ERROR_INVALID_PARAMETER
//
//	Notes:
//
//----------------------------------------------------------------------------
ULONG	PrintStgInfo(PDFS_STORAGE_INFO pBuffer)
{
	ULONG				ulErr = ERROR_SUCCESS;
	
	MSG(fDebug,
		"Entering PrintStgInfo(..)\n");
	if (NULL == pBuffer)
	{
		RETURN(ERROR_INVALID_PARAMETER);
	}

	fprintf(stdout, "\t\\\\%ws\\%ws\t",
			pBuffer->ServerName, pBuffer->ShareName);

	if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
	{
		fprintf(stdout, "online  ");

		if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_OFFLINE)
	{
		fprintf(stdout, "offline ");

		if (pBuffer->State & DFS_STORAGE_STATE_ONLINE)
		{
			RETURN(ERROR_INVALID_DATA);
		}
	} //if

	if (pBuffer->State & DFS_STORAGE_STATE_ACTIVE)
	{
		fprintf(stdout, "active  ");
	}

	fprintf(stdout, "\n");

	MSG(fDebug,
		"Exiting PrintStgInfo(..) with %lu\n",
		ulErr);
	RETURN(ulErr);
}; //PrintStgInfo





//+---------------------------------------------------------------------------
//
//  Function:   GetStringParam
//
//  Synopsis:   This function receives a string and it returns the 
//				string itself if it is a "good" one (not null, not 
//				empty, etc).
//
//  Arguments:  [ptszParam]	the string to evaluate
//
//  Returns:    the string itself or NULL.
//
//	Notes:
//
//----------------------------------------------------------------------------
LPTSTR	GetStringParam(LPTSTR ptszParam)
{
	if (NULL == ptszParam ||
		_T('\0') == ptszParam[0] ||
		0 == _tcscmp(_T("\"\""), ptszParam))
	{
		return(NULL);
	}

	return(ptszParam);
}; //GetStringParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfscmd\myutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       myutil.cxx
//
//  Contents:   Helper APIs for Sharing Tool
//
//  History:    6-Jun-93   WilliamW   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     MyGetLastComponent, public
//
//  Synopsis:   Parse a string to a (prefix, last-component) pair.  Any
//              trailing text after L'.' will be ignored
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszPrefix and pszLastComponent should be pre-allocated
//
//--------------------------------------------------------------------------

VOID
MyGetLastComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszPrefix,
    OUT PWSTR pszLastComponent
    )
{
    PWSTR pszTmp     = NULL;
    PWSTR pszTmpLast = NULL;

    //
    // Manufacture the prefix part by replacing L'\\' with L'\0'
    //

    wcscpy(pszPrefix, pszStr);

    pszTmp = wcsrchr(pszPrefix, L'\\');
    if (pszTmp != NULL)
    {
        *pszTmp = L'\0';

        //
        // Extract the last component.  The L'.' part will be replaced
        // by a L'\0'
        //

        pszTmpLast = pszTmp + 1;
        pszTmp = wcsrchr(pszTmpLast, L'.');
        if (pszTmp != NULL)
        {
            //
            // Replace with a L'\0' character
            //

            *pszTmp = L'\0';
        }
        wcscpy(pszLastComponent, pszTmpLast);
    }
    else
    {
        *pszPrefix = L'\0';
        wcscpy(pszLastComponent, pszStr);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyFindLastComponent, public
//
//  Synopsis:   Parse a string to find the last component. This is different
//              from MyGetLastComponent as it doesn't copy any data, but just
//              looks for the last backslash and points one after it.
//
//  History:    21-Nov-94   BruceFo
//
//--------------------------------------------------------------------------

PWSTR
MyFindLastComponent(
    IN const WCHAR* pszStr
    )
{
    PWSTR pszTmp = wcsrchr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        return pszTmp + 1;
    }
    else
    {
        return (PWSTR)pszStr;  // cast away const
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyGetNextComponent(), public
//
//  Synopsis:   Parse a string to a (next-components, remaing-components)
//              pair.  Any
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszNextComponent and pszRemaining should be pre-allocated.
//
//--------------------------------------------------------------------------
VOID
MyGetNextComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszNextComponent,
    OUT PWSTR pszRemaining
    )
{
    PWSTR pszTmp = NULL;

    if (*pszStr == L'\0')
    {
       *pszNextComponent = *pszRemaining = L'\0';
       return;
    }

#if DBG == 1
    if (*pszStr == L'\\')
    {
        appDebugOut((DEB_IERROR,
            "WARNING: MyGetNextComponent takes a relative path as its first argument\n"));
    }
#endif // DBG == 1

    //
    // Manufacture the next component part by replacing L'\\' with L'\0'
    //

    pszTmp = wcschr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        ULONG cchNextComponent = (ULONG)(pszTmp - pszStr);
        wcsncpy(pszNextComponent, pszStr, cchNextComponent);
        pszNextComponent[cchNextComponent] = L'\0';

        //
        // Handle the remaining component.
        //

        wcscpy(pszRemaining, pszTmp + 1);
    }
    else
    {
        //
        // No remaining part, this is the last component
        //

        *pszRemaining = L'\0';

        wcscpy(pszNextComponent, pszStr);
    }
}




//+-------------------------------------------------------------------------
//
//  Method:     MyStrStr
//
//  Synopsis:   A case insensitive version of wcsstr (i.e. strstr)
//
//--------------------------------------------------------------------------
PWSTR
MyStrStr(
    IN PWSTR pszInStr,
    IN PWSTR pszInSubStr
    )
{
    if (   pszInStr == NULL
        || pszInSubStr == NULL
        || *pszInStr == L'\0'
        || *pszInSubStr == L'\0')
    {
       return NULL;
    }

    INT iSubStrLen = wcslen(pszInSubStr);
    INT iStrLen = wcslen(pszInStr);

    PWSTR pszHeadInStr = pszInStr;
    PWSTR pszTailInStr = pszInStr + iSubStrLen;

    PWSTR pszEndInStr = pszInStr + iStrLen;

    while (pszTailInStr <= pszEndInStr)
    {
        if (0 != _wcsnicmp(pszHeadInStr, pszInSubStr, iSubStrLen))
        {
            return pszHeadInStr;
        }

        pszHeadInStr++;
        pszTailInStr++;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     MyFindPostfix
//
//  Synopsis:   Match the prefix with the string. If the string doesn't have
//              the prefix, return a pointer to the string itself. If it does,
//              then check to see if the character after the prefix is a
//              backslash. If it is, return a pointer to the character
//              following the backslash. Otherwise, return a pointer to the
//              character immediately after the prefix.
//
//              Examples:
//                      string          prefix      return
//                      \foo\bar\baz    \bad        \foo\bar\baz
//                      \foo\bar\baz    \foo\bar    baz
//                      \foo\bar\baz    \f          oo\bar\baz
//
//--------------------------------------------------------------------------

PWSTR
MyFindPostfix(
    IN PWSTR pszString,
    IN PWSTR pszPrefix
    )
{
    UINT cchPrefixLen = wcslen(pszPrefix);
    if (0 == _wcsnicmp(pszString, pszPrefix, cchPrefixLen))
    {
        PWSTR pszReturn = pszString + cchPrefixLen;

        if (*pszReturn == L'\\')
        {
            //
            // skip past the leading backslash.
            //
            ++pszReturn;
        }

        return pszReturn;
    }
    else
    {
        // prefix didn't match, return argument string

//         appDebugOut((DEB_ITRACE,
//                 "No postfix of ('%ws', '%ws')\n",
//                 pszString,
//                 pszPrefix));

        return pszString;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
                "Formatmessage failed = 0x%08lx\n",
                GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance,
                   (dwMsgId >= MSG_FIRST_MESSAGE)
                        ? IDS_APP_MSG_NOT_FOUND
                        : IDS_SYS_MSG_NOT_FOUND,
                   szText,
                   ARRAYLEN(szText));

        wsprintf(pszBuffer,szText,dwMsgId);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  Arguments:
//
//  Returns:
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Same as wcsstr (find string in string), but case-insensitive
//
//  Arguments:
//
//  Returns:
//
//  History:    2-Feb-95   BruceFo   Created
//
//----------------------------------------------------------------------------

wchar_t*
wcsistr(
    const wchar_t* string1,
    const wchar_t* string2
    )
{
    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    wchar_t* s1dup = NewDup(string1);
    wchar_t* s2dup = NewDup(string2);

    wchar_t* ret = NULL;

    if (NULL != s1dup && NULL != s2dup)
    {
        _wcslwr(s1dup); // lower case everything to make case-insensitive
        _wcslwr(s2dup);
        ret = wcsstr(s1dup, s2dup);
    }

    delete[] s1dup;
    delete[] s2dup;
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   IsDfsRoot
//
//  Synopsis:   Determine if the path passed in is a Dfs root, in form only.
//              Namely, does it look like "\\machine-or-domain\share"?
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
BOOL
IsDfsRoot(
    IN LPWSTR pszRoot
    )
{
    if (NULL != pszRoot
        && pszRoot[0] == L'\\'
        && pszRoot[1] == L'\\'
        && pszRoot[2] != L'\\'	// might be null
        )
    {
        LPWSTR pszTmp = wcschr(pszRoot + 2, L'\\');
        if (pszTmp != NULL)
        {
            if (pszTmp[1] != L'\0'
                && pszTmp[1] != L'\\'
                )
            {
                // ok, we've got "\\xxx\y...."
                // Now make sure it doesn't have a fourth backslash

                pszTmp = wcschr(pszTmp + 2, L'\\');
                if (pszTmp == NULL)
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   IsDfsShare
//
//  Synopsis:   Determine if the given share on the given server is a Dfs
//              share. This actually contacts the machine.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
DWORD
IsDfsShare(
    IN LPWSTR pszServer,
    IN LPWSTR pszShare,
    OUT BOOL* pfIsDfs
    )
{
    PSHARE_INFO_1005 pshi1005;
    NET_API_STATUS ret = NetShareGetInfo(pszServer, pszShare, 1005, (LPBYTE*)&pshi1005);
    if (NERR_Success == ret)
    {
        if (pshi1005->shi1005_flags & SHI1005_FLAGS_DFS)
        {
            *pfIsDfs = TRUE;
        }
        else
        {
            appDebugOut((DEB_ITRACE,
                "%ws not a Dfs share\n",
                pszShare));
        }

        NetApiBufferFree(pshi1005);
    }
    else
    {
        // This could be an access denied.

        appDebugOut((DEB_ERROR,
            "NetShareGetInfo(NULL, %ws...) failed, 0x%08lx\n",
            pszShare,
            ret));
    }

    return ret;
}



//+-------------------------------------------------------------------------
//
//  Member:     FindDfsRoot, public
//
//  Synopsis:   Parse a string to find the Dfs root. Returns a pointer to
//
//  History:    22-Apr-96   BruceFo
//
//--------------------------------------------------------------------------

BOOL
FindDfsRoot(
    IN PWSTR pszDfsPath,
    OUT PWSTR pszDfsRoot
    )
{
    PWSTR pszTmp;
    if (NULL != pszDfsPath
        && pszDfsPath[0] == L'\\'
        && pszDfsPath[1] == L'\\'
        && pszDfsPath[2] != L'\\'
        && pszDfsPath[2] != L'\0'
        && (NULL != (pszTmp = wcschr(pszDfsPath + 3, L'\\')))
        && pszTmp[1] != L'\\'
        && pszTmp[1] != L'\0'
        )
    {
        pszTmp = wcschr(pszTmp + 2, L'\\');

        if (NULL != pszTmp)
        {
            // the thing passed in was of the form "\\xxx\yyy\..."
            int len = (int)(pszTmp - pszDfsPath);
            wcsncpy(pszDfsRoot, pszDfsPath, len);
            pszDfsRoot[len] = L'\0';
        }
        else
        {
            // the thing passed in was of the form "\\xxx\yyy"
            wcscpy(pszDfsRoot, pszDfsPath);
        }

        appDebugOut((DEB_IERROR,
            "Dfs root of %ws is %ws\n",
            pszDfsPath, pszDfsRoot));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#define MAX_MESSAGE_BUF 8192
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR szMsgBuf[MAX_MESSAGE_BUF];
CHAR  szAnsiBuf[MAX_ANSI_MESSAGE_BUF];
VOID
StatusMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
    exit(1);
}

VOID
DfsErrorMessage(
    IN NET_API_STATUS status
    )
{
    ULONG written;

    MyFormatMessage(MSG_ERROR, szMsgBuf, ARRAYLEN(szMsgBuf), status);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);


	PWSTR pszDll = L"netmsg.dll";

	HINSTANCE hinst = LoadLibrary(pszDll);
	if (NULL == hinst)
	{
    	MyFormatMessage(MSG_NO_MESSAGES, szMsgBuf, ARRAYLEN(szMsgBuf), pszDll);
	}
	else
	{
    	DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             hinst,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
		FreeLibrary(hinst);

    	if (0 == dwReturn)   // couldn't find message
    	{
			// try system messages
    		dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_SYSTEM
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
    		if (0 == dwReturn)   // couldn't find message
    		{
    			MyFormatMessage(MSG_ERROR_UNKNOWN, szMsgBuf, ARRAYLEN(szMsgBuf));
    		}
    	}
	}
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    exit(1);
}

VOID
Usage(
    VOID
    )
{
    ErrorMessage(MSG_USAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfscmd\winmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:      winmain.cxx
//
//  Contents:  Main DFS Administrator file
//
//  History:   05-May-93 WilliamW    Created
//             11-Jul-95 WayneSc     Bug Fixes
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "cmd.hxx"
#include "myutil.hxx"

//
// Debug flag
//

DECLARE_INFOLEVEL(DfsAdmin)

//////////////////////////////////////////////////////////////////////////////

HINSTANCE g_hInstance;

#define MAX_ARGS 25

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main routine for the Sharing app.
//
//  History:    11-May-93 WilliamW   Created.
//              16-Sep-93 DavidMun   Added load & free of ccsvr.dll; move
//                                   InfoLevel init inside #if DBG.
//
//  The command line accepted by this program is described in message
//  MSG_USAGE, in messages.mc. In addition to that, the following options are
//  accepted in debug builds. These must preceed any retail options.
//
//  Debug options:
//      /debug
//          -- dump basic error information
//      /fulldebug
//          -- dump all error and trace information
//
//--------------------------------------------------------------------------

int APIENTRY
WinMain(
    IN HINSTANCE hInst,
    IN HINSTANCE hPrevInstance,
    IN LPSTR lpszCommandLineAnsi,
    IN int cmdShow
    )
{
    HRESULT hr;
    HACCEL  hAccel;
    MSG     msg;
    PWSTR   pszInitialDfs = NULL;
    PWSTR   pszCommandLine = GetCommandLine();  // get the unicode command line
    BOOLEAN fBatch = FALSE;
    BOOLEAN fRestore = FALSE;

    //
    // Store the current instance away.
    //

    g_hInstance = hInst;

#if DBG == 1

    DebugInitialize();

    //
    // Set debug info level
    //

    DfsAdminInfoLevel = DEB_ERROR | DEB_WARN;

    if (NULL != wcsstr(pszCommandLine, L"/debug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                ;
    }

    if (NULL != wcsstr(pszCommandLine, L"/fulldebug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                | DEB_IERROR
                | DEB_IWARN
                | DEB_ITRACE
                ;
    }

    // For some reason, the MessageBox call done for ASSRT_POPUP
    // is failing with error 2 (???), and although the assert message gets
    // printed, it doesn't break.

    DebugSetAssertLevel(ASSRT_MESSAGE | ASSRT_BREAK);

#endif

    //
    // Parse the command line. First, break everything out into separate
    // strings (kind of like argv/argc). Note that the program name doesn't
    // appear in pszCommandLine.
    //

    DWORD cArgs = 0;
    DWORD iArg;
    LPWSTR apszArgs[MAX_ARGS];

    LPWSTR pT = pszCommandLine;
    if (NULL != pT)
    {
        for (; cArgs < MAX_ARGS;)
        {
            while (L' ' == *pT || L'\t' == *pT) { pT++; }   // eat whitespace
            if (L'\0' == *pT)
            {
                break;
            }

            // We found a parameter. Find how long it is, allocate a string
            // to store it, and copy it. If the argument begins with a double
            // quote, we continue until we find the next double quote. To allow
            // double-quotes within strings, we allow these two special
            // sequences:
            //              \" => "			backslash escapes quotes
            //              \\ => \         backslash escapes backslash
            //              \x => x         backslash escapes anything!

            // First, determine the string size

            DWORD cchArg = 0;
            BOOL fQuoted = (L'"' == *pT);
            if (fQuoted)
            {
                ++pT;
            }

            // count the # of characters in the string
            LPWSTR pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        pT2 += 2;
                    }
					else
					{
                        pT2 += 1;
					}
                    ++cchArg;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    Usage();
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        Usage();
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    ++pT2;
                    ++cchArg;
                }
            }

            // allocate storage for the parameter
            LPWSTR pszNew = new WCHAR[cchArg + 1];
            if (NULL == pszNew)
            {
                ErrorMessage(MSG_OUTOFMEMORY);
            }
            LPWSTR pCopy = pszNew;

            // copy the string
            pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        ++pT2;	// skip the backslash
                    }
                    *pCopy++ = *pT2++;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    appAssert(FALSE);
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        appAssert(FALSE);
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    *pCopy++ = *pT2++;
                }
            }

            *pCopy = L'\0';
            apszArgs[cArgs++] = pszNew;
            pT = pT2;
        }

        if (cArgs >= MAX_ARGS)
        {
            Usage();
        }

        //
        // We've got the arguments parsed out now, so do something with them
        //

        iArg = 1;   // skip the first one, which is the program name

#if DBG == 1
        for (; iArg < cArgs; )
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/debug")
                || 0 == _wcsicmp(apszArgs[iArg], L"/fulldebug")
                )
            {
                ++iArg; // skip it
            }
            else
            {
                break;
            }
        }
#endif // DBG == 1

        if (iArg < cArgs)
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/help")
                || 0 == _wcsicmp(apszArgs[iArg], L"/h")
                || 0 == _wcsicmp(apszArgs[iArg], L"/?")
                || 0 == _wcsicmp(apszArgs[iArg], L"-help")
                || 0 == _wcsicmp(apszArgs[iArg], L"-h")
                || 0 == _wcsicmp(apszArgs[iArg], L"-?")
                )
            {
                Usage();
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/map"))
            {
                LPWSTR pszComment = NULL;
                if (
                    iArg + 2 > cArgs - 1
                    || iArg + 4 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else 
                        pszComment = apszArgs[iArg + 3];
                }
                if (iArg + 4 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 4], L"/restore"))
                        fRestore = TRUE;
                    else if (pszComment != NULL)
                        Usage();
                    else
                        pszComment = apszArgs[iArg + 4];
                }
                CmdMap(apszArgs[iArg + 1], apszArgs[iArg + 2], pszComment, fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/unmap"))
            {
                if (iArg + 1 != cArgs - 1)
                {
                    Usage();
                }
                CmdUnmap(apszArgs[iArg + 1]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/add"))
            {
                if (iArg + 2 > cArgs - 1
                    || iArg + 3 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else
                        Usage();
                }
                CmdAdd(apszArgs[iArg + 1], apszArgs[iArg + 2], fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/remove"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRemove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/view"))
            {
                if (   iArg + 1 > cArgs - 1
                    || iArg + 2 < cArgs - 1
                    )
                {
                    Usage();
                }
                DWORD level = 1;
                if (iArg + 2 == cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 2], L"/partial"))
                    {
                        level = 2;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/full"))
                    {
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batch"))
                    {
                        fBatch = TRUE;
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batchrestore"))
                    {
                        fBatch = TRUE;
                        fRestore = TRUE;
                        level = 3;
                    }
                    else
                    {
                        Usage();
                    }
                }
                CmdView(apszArgs[iArg + 1], level, fBatch, fRestore);
            }
#ifdef MOVERENAME
            else if (0 == _wcsicmp(apszArgs[iArg], L"/move"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdMove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/rename"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRename(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
#endif
            else
            {
                Usage();
            }
        }
		else
		{
			Usage();
		}
    }
	else
	{
    	Usage();
	}

	StatusMessage(MSG_SUCCESSFUL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsutil\dfsutil.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       dfsutil.cxx
//
//--------------------------------------------------------------------------



#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
#include "struct.hxx"
#include "flush.hxx"
#include "misc.hxx"
#include "info.hxx"
#include "messages.h"
//
// How we make args & switches
//

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;

#define SWITCH(x) \
    WCHAR Sw##x[] = L"/" L#x ; \
    BOOLEAN fSw##x;

#define FMAKEARG(x) \
    static WCHAR Arg##x[] = L#x L":"; \
    static LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    static BOOLEAN fArg##x;

#define FSWITCH(x) \
    static WCHAR Sw##x[] = L"/" L#x ; \
    static BOOLEAN fSw##x;

LPWSTR pwszNameBuffer = NULL;
LPWSTR pwszRootName = NULL;
LPWSTR pwszServerName = NULL;
LPWSTR pwszHexValue = NULL;
LPWSTR pwszDcName = NULL;
LPWSTR pwszDomainName = NULL;
LPWSTR pwszEntryToFlush = NULL;
LPWSTR pwszDumpArg = NULL;
LPWSTR pwszImportArg = NULL;
LPWSTR pwszExportArg = NULL;
LPWSTR pwszComment = NULL;
LPWSTR pwszShareName = NULL;


WCHAR wszNameBuffer[MAX_PATH+1] = { 0 };

MAKEARG(AddStdRoot);
MAKEARG(AddDomRoot);
MAKEARG(RemStdRoot);
MAKEARG(RemDomRoot);
MAKEARG(Server);
MAKEARG(Share);
MAKEARG(Unmap);
MAKEARG(Verbose);
MAKEARG(EventLog);
MAKEARG(Domain);
MAKEARG(Dns);
MAKEARG(Value);
MAKEARG(NetApiDfsDebug);
MAKEARG(DfsSvcVerbose);
MAKEARG(LoggingDfs);
MAKEARG(SyncInterval);
MAKEARG(DfsAlt);
MAKEARG(TraceLevel);
MAKEARG(Level);
MAKEARG(SetDc);
MAKEARG(Root);
MAKEARG(CscOnLine);
MAKEARG(CscOffLine);
MAKEARG(InSite);

//
// Switches (ie '/arg')
//
SWITCH(Debug);
SWITCH(Help);
SWITCH(HelpHelp);
SWITCH(ScriptHelp);
SWITCH(Dfs);
SWITCH(All);
SWITCH(StdDfs);
SWITCH(On);
SWITCH(Off);
SWITCH(PktInfo);
SWITCH(Set);
SWITCH(ReSet);


//
// Either a switch or an arg
//
MAKEARG(PktFlush);
SWITCH(PktFlush);
MAKEARG(SpcFlush);
SWITCH(SpcFlush);
MAKEARG(List);
SWITCH(List);

MAKEARG(SpcInfo);
SWITCH(SpcInfo);

//
// The macro can not make these
//

WCHAR SwQ[] = L"/?";
BOOLEAN fSwQ;
WCHAR SwQQ[] = L"/??";
BOOLEAN fSwQQ;

DWORD
Usage();

DWORD
CmdProcessUserCreds(
    VOID);

BOOLEAN
CmdProcessArg(
    LPWSTR Arg);

_cdecl
main(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argx;
    int argcw;

    // fSwDebug = TRUE;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    if ( argvw == NULL ) {
        MyPrintf(L"dfsutil:Can't convert command line to Unicode: %d\r\n", GetLastError() );
        return 1;
    }

    //
    // Get the arguments
    //
    if (argcw <= 1) {
        Usage();
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Process arguments
    //

    for (argx = 1; argx < argcw; argx++) {
        if (CmdProcessArg(argvw[argx]) != TRUE) {
            goto Cleanup;
        }
    }

    //
    // Do the work
    //
    if (fSwHelp == TRUE || fSwQ == TRUE) {
        dwErr = Usage();
    } else if (fSwPktFlush == TRUE || fArgPktFlush == TRUE) {
        dwErr = PktFlush(pwszEntryToFlush);
    } else if (fSwSpcFlush == TRUE || fArgSpcFlush == TRUE) {
        dwErr = SpcFlush(pwszEntryToFlush);
    } else if (fSwPktInfo == TRUE) {
        dwErr = PktInfo(fSwDfs, pwszHexValue);
    } else if (fSwSpcInfo == TRUE) {
        dwErr = SpcInfo(fSwAll);
    } else if (fArgAddStdRoot == TRUE) {
        dwErr = CmdAddRoot(
                    FALSE,
                    pwszServerName,
                    pwszShareName,
                    pwszComment);
    } else if (fArgAddDomRoot == TRUE) {
        dwErr = CmdAddRoot(
                    TRUE,
                    pwszServerName,
                    pwszShareName,
                    pwszComment);
    } else if (fArgRemStdRoot == TRUE) {
        dwErr = CmdRemRoot(
                    FALSE,
                    pwszServerName,
                    pwszShareName);
    } else if (fArgRemDomRoot == TRUE) {
        dwErr = CmdRemRoot(
                    TRUE,
                    pwszServerName,
                    pwszShareName);
    } else if (fSwHelpHelp == TRUE || fSwQQ == TRUE) {
        dwErr = Usage();
    } else if (fArgCscOffLine == TRUE) {
        dwErr = CmdCscOffLine(pwszNameBuffer);
    }
    else {
        dwErr = Usage();
//        ErrorMessage(MSG_NOTHING_TO_DO);
    }

Cleanup:

    if (dwErr == STATUS_SUCCESS) {
        ErrorMessage(MSG_SUCCESSFUL);
    } else {
        LPWSTR MessageBuffer;
        DWORD dwBufferLength;

        dwBufferLength = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPWSTR) &MessageBuffer,
                            0,
                            NULL);

        ErrorMessage(MSG_ERROR, dwErr);
        if (dwBufferLength > 0) {
            MyPrintf(L"%ws\r\n", MessageBuffer);
            LocalFree(MessageBuffer);
        }
    }

    return dwErr;
}

BOOLEAN
CmdProcessArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN dwErr = FALSE;
    BOOLEAN FoundAnArg = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg(%ws)\r\n", Arg);

    if ( Arg != NULL && wcslen(Arg) > 1) {

        dwErr = TRUE;
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgInSite, ArgLenInSite) == 0) {
            FoundAnArg = fArgInSite = TRUE;
            if (ArgLen > ArgLenInSite)
                pwszNameBuffer = &Arg[ArgLenInSite];
        } else if (_wcsnicmp(Arg, ArgRoot, ArgLenRoot) == 0) {
            FoundAnArg = fArgRoot = TRUE;
            if (ArgLen > ArgLenRoot)
                pwszRootName = &Arg[ArgLenRoot];
        } else if (_wcsnicmp(Arg, ArgAddStdRoot, ArgLenAddStdRoot) == 0) {
            FoundAnArg = fArgAddStdRoot = TRUE;
        } else if (_wcsnicmp(Arg, ArgRemStdRoot, ArgLenRemStdRoot) == 0) {
            FoundAnArg = fArgRemStdRoot = TRUE;
        } else if (_wcsnicmp(Arg, ArgAddDomRoot, ArgLenAddDomRoot) == 0) {
            FoundAnArg = fArgAddDomRoot = TRUE;
        } else if (_wcsnicmp(Arg, ArgRemDomRoot, ArgLenRemDomRoot) == 0) {
            FoundAnArg = fArgRemDomRoot = TRUE;
        } else if (_wcsnicmp(Arg, ArgShare, ArgLenShare) == 0) {
            FoundAnArg = fArgShare = TRUE;
            if (ArgLen > ArgLenShare)
                pwszShareName = &Arg[ArgLenShare];
        } else if (_wcsnicmp(Arg, ArgServer, ArgLenServer) == 0) {
            FoundAnArg = fArgServer = TRUE;
            if (ArgLen > ArgLenServer)
                pwszServerName = &Arg[ArgLenServer];
        } else if (_wcsnicmp(Arg, ArgUnmap, ArgLenUnmap) == 0) {
            FoundAnArg = fArgUnmap = TRUE;
            if (ArgLen > ArgLenUnmap)
                pwszNameBuffer = &Arg[ArgLenUnmap];
        } else if (_wcsnicmp(Arg, ArgCscOnLine, ArgLenCscOnLine) == 0) {
            FoundAnArg = fArgCscOnLine = TRUE;
            if (ArgLen > ArgLenCscOnLine)
                pwszNameBuffer = &Arg[ArgLenCscOnLine];
        } else if (_wcsnicmp(Arg, ArgCscOffLine, ArgLenCscOffLine) == 0) {
            FoundAnArg = fArgCscOffLine = TRUE;
            if (ArgLen > ArgLenCscOffLine)
                pwszNameBuffer = &Arg[ArgLenCscOffLine];
        } else if (_wcsnicmp(Arg, ArgDns, ArgLenDns) == 0) {
            FoundAnArg = fArgDns = TRUE;
            if (ArgLen > ArgLenDns)
                pwszNameBuffer = &Arg[ArgLenDns];
        } else if (_wcsnicmp(Arg, ArgNetApiDfsDebug, ArgLenNetApiDfsDebug) == 0) {
            FoundAnArg = fArgNetApiDfsDebug = TRUE;
            if (ArgLen > ArgLenNetApiDfsDebug)
                pwszNameBuffer = &Arg[ArgLenNetApiDfsDebug];
        } else if (_wcsnicmp(Arg, ArgDfsSvcVerbose, ArgLenDfsSvcVerbose) == 0) {
            FoundAnArg = fArgDfsSvcVerbose = TRUE;
            if (ArgLen > ArgLenDfsSvcVerbose)
                pwszNameBuffer = &Arg[ArgLenDfsSvcVerbose];
        } else if (_wcsnicmp(Arg, ArgLoggingDfs, ArgLenLoggingDfs) == 0) {
            FoundAnArg = fArgLoggingDfs = TRUE;
            if (ArgLen > ArgLenLoggingDfs)
                pwszNameBuffer = &Arg[ArgLenLoggingDfs];
        } else if (_wcsnicmp(Arg, ArgPktFlush, ArgLenPktFlush) == 0) {
            FoundAnArg = fArgPktFlush = TRUE;
            if (ArgLen > ArgLenPktFlush)
                pwszEntryToFlush = &Arg[ArgLenPktFlush];
        } else if (_wcsnicmp(Arg, ArgSpcFlush, ArgLenSpcFlush) == 0) {
            FoundAnArg = fArgSpcFlush = TRUE;
            if (ArgLen > ArgLenSpcFlush)
                pwszEntryToFlush = &Arg[ArgLenSpcFlush];
        } else if (_wcsnicmp(Arg, ArgVerbose, ArgLenVerbose) == 0) {
            FoundAnArg = fArgVerbose = TRUE;
            if (ArgLen > ArgLenVerbose)
                pwszHexValue = &Arg[ArgLenVerbose];
        } else if (_wcsnicmp(Arg, ArgValue, ArgLenValue) == 0) {
            FoundAnArg = fArgValue = TRUE;
            if (ArgLen > ArgLenValue)
                pwszHexValue = &Arg[ArgLenValue];
        } else if (_wcsnicmp(Arg, ArgTraceLevel, ArgLenTraceLevel) == 0) {
            FoundAnArg = fArgTraceLevel = TRUE;
            if (ArgLen > ArgLenTraceLevel)
                pwszHexValue = &Arg[ArgLenTraceLevel];
        } else if (_wcsnicmp(Arg, ArgLevel, ArgLenLevel) == 0) {
            FoundAnArg = fArgLevel = TRUE;
            if (ArgLen > ArgLenLevel)
                pwszHexValue = &Arg[ArgLenLevel];
        } else if (_wcsnicmp(Arg, ArgEventLog, ArgLenEventLog) == 0) {
            FoundAnArg = fArgEventLog = TRUE;
            if (ArgLen > ArgLenEventLog)
                pwszHexValue = &Arg[ArgLenEventLog];
        }

        // Switches go at the end!!

        if (_wcsicmp(Arg, SwDebug) == 0) {
            FoundAnArg = fSwDebug = TRUE;
        } else if (_wcsicmp(Arg, SwList) == 0) {
            FoundAnArg = fSwList = TRUE;
        } else if (_wcsicmp(Arg, SwPktFlush) == 0) {
            FoundAnArg = fSwPktFlush = TRUE;
        } else if (_wcsicmp(Arg, SwSpcFlush) == 0) {
            FoundAnArg = fSwSpcFlush = TRUE;
        } else if (_wcsicmp(Arg, SwPktInfo) == 0) {
            FoundAnArg = fSwPktInfo = TRUE;
        } else if (_wcsicmp(Arg, SwSpcInfo) == 0) {
            FoundAnArg = fSwSpcInfo = TRUE;
        } else if (_wcsicmp(Arg, SwDfs) == 0) {
            FoundAnArg = fSwDfs = TRUE;
        } else if (_wcsicmp(Arg, SwAll) == 0) {
            FoundAnArg = fSwAll = TRUE;
        } else if (_wcsicmp(Arg, SwOn) == 0) {
            FoundAnArg = fSwOn = TRUE;
        } else if (_wcsicmp(Arg, SwOff) == 0) {
            FoundAnArg = fSwOff = TRUE;
        } else if (_wcsicmp(Arg, SwStdDfs) == 0) {
            FoundAnArg = fSwStdDfs = TRUE;
        } else if (_wcsicmp(Arg, SwHelpHelp) == 0) {
            FoundAnArg = fSwHelpHelp = TRUE;
        } else if (_wcsicmp(Arg, SwScriptHelp) == 0) {
            FoundAnArg = fSwScriptHelp = TRUE;
        } else if (_wcsicmp(Arg, SwHelp) == 0) {
            FoundAnArg = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwQQ) == 0) {
            FoundAnArg = fSwQQ = TRUE;
        } else if (_wcsicmp(Arg, SwQ) == 0) {
            FoundAnArg = fSwQ = TRUE;
        } else if (_wcsicmp(Arg, SwSet) == 0) {
            FoundAnArg = fSwSet = TRUE;
        } else if (_wcsicmp(Arg, SwReSet) == 0) {
            FoundAnArg = fSwReSet = TRUE;
        }

        if (wszNameBuffer[0] == L'\0' && pwszNameBuffer != NULL) {
            wcscpy(wszNameBuffer, L"\\\\");
            wcscat(wszNameBuffer, pwszNameBuffer);
            pwszNameBuffer = wszNameBuffer;
            while (pwszNameBuffer[0] == L'\\' && pwszNameBuffer[1] == L'\\')
                pwszNameBuffer++;
            pwszNameBuffer--;
        }

        if (FoundAnArg == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, &Arg[1]);
            Usage();
            dwErr = FALSE;
            goto AllDone;
        }

    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
Usage()
{

    ErrorMessage(MSG_USAGE);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsutil\misc.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       misc.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
#include "struct.hxx"
#include "flush.hxx"
#include "misc.hxx"
#include "messages.h"

#define MAX_BUF_SIZE	10000

WCHAR MsgBuf[MAX_BUF_SIZE];
CHAR  AnsiBuf[MAX_BUF_SIZE*3];

WCHAR wszRootShare[MAX_PATH+1] = { 0 };
#define WINLOGON_FOLDER L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SFCVALUE L"SFCDisable"
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))



DWORD
DfspGetLinkName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszLinkName);


DWORD
AtoHex(
    LPWSTR pwszHexValue,
    PDWORD pdwErr)
{
    DWORD dwHexValue = 0;

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex(%ws)\r\n", pwszHexValue);

    if (pwszHexValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    if (pwszHexValue[0] == L'0' && (pwszHexValue[1] == L'x' || pwszHexValue[1] == L'X'))
        pwszHexValue = &pwszHexValue[2];

    swscanf(pwszHexValue, L"%x", &dwHexValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex returning 0x%x (dwErr=0x%x)\r\n", dwHexValue, *pdwErr);

    return dwHexValue;
}

DWORD
AtoDec(
    LPWSTR pwszDecValue,
    PDWORD pdwErr)
{
    DWORD dwDecValue = 0;

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec(%ws)\r\n", pwszDecValue);

    if (pwszDecValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(pwszDecValue, L"%d", &dwDecValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec returning 0x%x (dwErr=0x%x)\r\n", dwDecValue, *pdwErr);

    return dwDecValue;
}


DWORD
CmdCscOnLine(
    LPWSTR pwszServerName)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdCscOnLine(%ws)\r\n", pwszServerName);

    if (pwszServerName == NULL)
        pwszServerName = L"";

    MyPrintf(L"ServerName=[%ws]\r\n", pwszServerName);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CSC_SERVER_ONLINE,
                   pwszServerName,
                   wcslen(pwszServerName) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdCscOnLine exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
CmdCscOffLine(
    LPWSTR pwszServerName)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdCscOffLine(%ws)\r\n", pwszServerName);

    if (pwszServerName == NULL)
        pwszServerName = L"";

    MyPrintf(L"ServerName=[%ws]\r\n", pwszServerName);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CSC_SERVER_OFFLINE,
                   pwszServerName,
                   wcslen(pwszServerName) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdCscOffLine exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
CmdDfsFsctlDfs(
    LPWSTR DriverName,
    DWORD FsctlCmd)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdDfsFsctlDfs(0x%x)\r\n", FsctlCmd);

    RtlInitUnicodeString(&DfsDriverName, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FsctlCmd,
                   NULL,
                   0,
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdDfsFsctlDfs exit %d\r\n", dwErr);

    return(dwErr);
}

#if 0
DWORD
CmdSetOnSite(
    LPWSTR pwszDfsRoot,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    ULONG set)
{

    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    LPWSTR pwszLinkName = NULL;

    WCHAR wszDomDfsName[MAX_PATH+1];
    BOOLEAN IsFtRoot = FALSE;
    DWORD cbName;
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;
    BOOLEAN IsDomainName = FALSE;

    dwErr = DfspParseName(pwszDfsRoot, &pwszDfsName, &pwszShareName);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspGetLinkName(pwszDfsRoot, &pwszLinkName);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pwszDfsName,
                pwszDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
      dwErr = DfsSetFtOnSite(pwszDfsName, pwszShareName, pwszLinkName, pwszDcName, pAuthIdent, set);
    } 
    else {
      dwErr = RegConnectRegistry( pwszDfsName, HKEY_LOCAL_MACHINE, &rKey);

      if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszDfsName);
        goto Cleanup;
      }
      dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

      if (dwErr == ERROR_SUCCESS) {
           cbName = MAX_PATH;
           dwErr = RegQueryValueEx(
                       hKey,
                       FTDFS_VALUE_NAME,
                       NULL,
                       &dwType,
                      (PBYTE) wszDomDfsName,
                      &cbName);

           if (dwErr == ERROR_MORE_DATA)
                 dwErr = ERROR_SUCCESS;

           if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
                 IsFtRoot = TRUE;

      } else {
           MyPrintf(L"Not a Dfs root\r\n");
           goto Cleanup;
      }

      if (IsFtRoot == TRUE) {
           MyPrintf(L"Not a Std Dfs root\r\n");
           goto Cleanup;
      }

      dwErr = DfsSetOnSite(rKey, pwszLinkName, set);
    }

Cleanup:

    if (pwszDfsName != NULL)
        free(pwszDfsName);
    if (pwszShareName != NULL)
        free(pwszShareName);
    if (pwszLinkName != NULL)
        free(pwszLinkName);

    if (rKey != NULL)
        RegCloseKey(rKey);
    if (hKey != NULL)
        RegCloseKey(hKey);

    return dwErr;
}
#endif


DWORD
CmdAddRoot(
    BOOLEAN DomainDfs,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName,
    LPWSTR pwszComment)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddRoot(%ws,%ws,%ws,%ws)\r\n",
                            pwszServerName,
                            pwszShareName,
                            pwszComment);


    if (DomainDfs == FALSE)
    {

        dwErr = NetDfsAddStdRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszComment,
                    0);
    } else {
        dwErr = NetDfsAddFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszShareName,
                    pwszComment,
                    0);

    }
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddRoot returning %d\r\n", dwErr);
    return dwErr;
}

DWORD
CmdRemRoot(
    BOOLEAN DomDfs,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRemRoot(%ws,%ws)\r\n",
                            pwszServerName,
                            pwszShareName);


    if (DomDfs == FALSE) 
    {
        dwErr = NetDfsRemoveStdRoot(
                    pwszServerName,
                    pwszShareName,
                    0);
    } 
    else {
        dwErr = NetDfsRemoveFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszShareName,
                    0);

    }
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRemRoot returning %d\r\n", dwErr);
    return dwErr;
}


DWORD
DfspIsDomainName(
    LPWSTR pwszDomainName,
    LPWSTR pwszDcName,
    PBOOLEAN pIsDomainName)
{
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    ULONG DsDomainCount = 0;
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspIsDomainName(%ws,%ws)\r\n", pwszDomainName, pwszDcName);

    if (pwszDcName == NULL) {
        dwErr = DsGetDcName(
                    NULL,                            // Computer to remote to
                    NULL,                            // Domain
                    NULL,                            // Domain Guid
                    NULL,                            // Site Guid
                    DS_FORCE_REDISCOVERY,
                    &pDcInfo);
        if (dwErr != ERROR_SUCCESS) {
            if (fSwDebug == TRUE)
                MyPrintf(L"DsGetDcName() returned %d\r\n", dwErr);
            goto Cleanup;
         }
         pwszDcName = &pDcInfo->DomainControllerName[2];
    }

    dwErr = DsEnumerateDomainTrusts(
                pwszDcName,
                DS_DOMAIN_VALID_FLAGS,
                &pDsDomainTrusts,
                &DsDomainCount);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"DsEnumerateDomainTrusts() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    *pIsDomainName = FALSE;

    for (i = 0; i < DsDomainCount; i++) {
        if (
            (pDsDomainTrusts[i].NetbiosDomainName != NULL && 
            _wcsicmp(pwszDomainName, pDsDomainTrusts[i].NetbiosDomainName) == 0)
                ||
            (pDsDomainTrusts[i].DnsDomainName != NULL &&
            _wcsicmp(pwszDomainName, pDsDomainTrusts[i].DnsDomainName) == 0)
        ) {
            *pIsDomainName = TRUE;
            goto Cleanup;
        }
    }

Cleanup:

    if (pDsDomainTrusts != NULL)
        NetApiBufferFree(pDsDomainTrusts);

    if (pDcInfo != NULL)
        NetApiBufferFree(pDcInfo);

    if (fSwDebug == TRUE)
        MyPrintf(
            L"DfspIsDomainName returning %d (%s)\r\n",
            dwErr, *pIsDomainName == TRUE ? "T" : "F");

    if (dwErr == ERROR_NO_SUCH_DOMAIN)
    {
        *pIsDomainName = FALSE;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

DWORD
DfspParseName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszDfsName,
    LPWSTR *ppwszShareName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    WCHAR *wCp1 = NULL;
    WCHAR *wCp2 = NULL;
    ULONG Len = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspParseName(%ws)\r\n", pwszDfsRoot);

    wCp1 = pwszDfsRoot;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_PATH_SEP && *wCp2 != UNICODE_NULL)
        wCp2++;

    if (*wCp2 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pwszDfsName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pwszDfsName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pwszDfsName,Len+sizeof(WCHAR));
    RtlCopyMemory(pwszDfsName, wCp1, Len);

    wCp1 = wCp2;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_PATH_SEP && *wCp2 != UNICODE_NULL)
        wCp2++;

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pwszShareName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pwszShareName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pwszShareName,Len+sizeof(WCHAR));
    RtlCopyMemory(pwszShareName, wCp1, Len);

    *ppwszDfsName = pwszDfsName;
    *ppwszShareName = pwszShareName;

Cleanup:

    if (dwErr != ERROR_SUCCESS) {
        if (pwszDfsName != NULL)
            free(pwszDfsName);
        if (pwszShareName != NULL)
            free(pwszShareName);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspParseName returning %d\r\n", dwErr);

    return dwErr;
}


DWORD
DfspGetLinkName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszLinkName)
{
    WCHAR *wCp1 = NULL;
    WCHAR *wCp2 = NULL;
    ULONG Len = 0;
    DWORD dwErr = ERROR_SUCCESS;
 
    wCp1 = pwszDfsRoot;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;
    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    while (*wCp1 != UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
       wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    *ppwszLinkName = ++wCp1;

 Cleanup:
    return dwErr;
}

VOID
MyFormatMessageText(
    HRESULT   dwMsgId,
    PWSTR     pszBuffer,
    DWORD     dwBufferSize,
    va_list   *parglist)
{
    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (dwReturn == 0)
        MyPrintf(L"Formatmessage failed 0x%x\r\n", GetLastError());
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...)
{
    ULONG cch;
    va_list arglist;

    va_start(arglist, hr);
    MyFormatMessageText(hr, MsgBuf, ARRAYLEN(MsgBuf), &arglist);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(arglist);
}

VOID
MyPrintf(
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(hHandle, AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsutil\info.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       info.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsfsctl.h>
#include "struct.hxx"
#include "misc.hxx"


#define OFFSET_TO_POINTER(f,b) \
    ((VOID *)((PCHAR)(f) + (ULONG_PTR)(b)))

CHAR *OutBuf = NULL;
ULONG OutBufSize = 0x1000;
HANDLE DriverHandle = NULL;
CHAR InBuf[0x1000];
CHAR OutBuf2[0x1000];

VOID
GetDCs(
    LPWSTR Name);

DWORD
PktInfo(
    BOOLEAN fSwDfs,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type;
    ULONG State;
    ULONG Entry;
    ULONG Service;
    ULONG Level = 0;
    PDFS_GET_PKT_ARG pGetPkt = NULL;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fSwDfs == TRUE) {
        MyPrintf(L"--dfs.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_SERVER_NAME);
    } else {
        MyPrintf(L"--mup.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    }

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }
            
    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

TryAgain:

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_PKT,
                   NULL,
                   0,
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR) malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }


    dwErr = RtlNtStatusToDosError(NtStatus);

    if (!NT_SUCCESS(NtStatus))
        goto Cleanup;

    pGetPkt = (PDFS_GET_PKT_ARG)OutBuf;

    MyPrintf(L"%d entries...\r\n", pGetPkt->EntryCount);

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        pGetPkt->EntryObject[Entry].Prefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].Prefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].ShortPrefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].ShortPrefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].Address = (PDFS_PKT_ADDRESS_OBJECT *) OFFSET_TO_POINTER(
                                                            pGetPkt->EntryObject[Entry].Address,
                                                            OutBuf);
        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            pGetPkt->EntryObject[Entry].Address[Service] = (PDFS_PKT_ADDRESS_OBJECT)
                                                OFFSET_TO_POINTER(
                                                    pGetPkt->EntryObject[Entry].Address[Service],
                                                    OutBuf);
        }
    }

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        MyPrintf(L"Entry: %ws\r\n", pGetPkt->EntryObject[Entry].Prefix);
        MyPrintf(L"ShortEntry: %ws\r\n", pGetPkt->EntryObject[Entry].ShortPrefix);
        MyPrintf(L"Expires in %d seconds\r\n", pGetPkt->EntryObject[Entry].ExpireTime);
        MyPrintf(L"UseCount: %d Type:0x%x (",
                    pGetPkt->EntryObject[Entry].UseCount,
                    pGetPkt->EntryObject[Entry].Type);
        Type = pGetPkt->EntryObject[Entry].Type;
        if (Type & PKT_ENTRY_TYPE_OFFLINE)
            MyPrintf(L" OFFLINE");
        if (Type & PKT_ENTRY_TYPE_LOCAL)
            MyPrintf(L" LOCAL");
        if (Type & PKT_ENTRY_TYPE_STALE)
            MyPrintf(L" STALE");
        if (Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)
            MyPrintf(L" LOCAL_XPOINT");
        if (Type & PKT_ENTRY_TYPE_DELETE_PENDING)
            MyPrintf(L" DELETE_PENDING");
        if (Type & PKT_ENTRY_TYPE_PERMANENT)
            MyPrintf(L" PERMANENT");
        if (Type & PKT_ENTRY_TYPE_REFERRAL_SVC)
            MyPrintf(L" REFERRAL_SVC");
        if (Type & PKT_ENTRY_TYPE_SYSVOL)
            MyPrintf(L" SYSVOL");
        if (Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM)
            MyPrintf(L" OUTSIDE_MY_DOM");
        if (Type & PKT_ENTRY_TYPE_LEAFONLY)
            MyPrintf(L" LEAFONLY");
        if (Type & PKT_ENTRY_TYPE_NONDFS)
            MyPrintf(L" NONDFS");
        if (Type & PKT_ENTRY_TYPE_MACHINE)
            MyPrintf(L" MACHINE");
        if (Type & PKT_ENTRY_TYPE_DFS)
            MyPrintf(L" DFS");
        if (Type & PKT_ENTRY_TYPE_INSITE_ONLY)
            MyPrintf(L" INSITE");

        MyPrintf(L" )\r\n");

        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            MyPrintf(L"%4d:[%ws] State:0x%02x ",
                Service,
                pGetPkt->EntryObject[Entry].Address[Service]->ServerShare,
                pGetPkt->EntryObject[Entry].Address[Service]->State);
            State = pGetPkt->EntryObject[Entry].Address[Service]->State;
            //
            // Ugly - used to have State == 0x1 mean 'active'.  Now we return an
            // ULONG with multiple bits set, so 0x1 indicates the old way and
            // more than 1 bit set means the new way.
            //
            if (State == 0x0) {
                MyPrintf(L"\r\n");
            } else if (State == 0x1) {
                MyPrintf(L"( ACTIVE )\r\n");
            } else {
                MyPrintf(L"(");
                if (State & DFS_SERVICE_TYPE_ACTIVE)
                    MyPrintf(L" ACTIVE");
                if (State & DFS_SERVICE_TYPE_OFFLINE)
                    MyPrintf(L" OFFLINE");
                if (Level >= 1) {
                    if (State & DFS_SERVICE_TYPE_MASTER)
                        MyPrintf(L" MASTER");
                    if (State & DFS_SERVICE_TYPE_READONLY)
                        MyPrintf(L" READONLY");
                    if (State & DFS_SERVICE_TYPE_LOCAL)
                        MyPrintf(L" LOCAL");
                    if (State & DFS_SERVICE_TYPE_REFERRAL)
                        MyPrintf(L" REFERRAL");
                    if (State & DFS_SERVICE_TYPE_DOWN_LEVEL)
                        MyPrintf(L" DOWNLEVEL");
                    if (State & DFS_SERVICE_TYPE_COSTLIER)
                        MyPrintf(L" COSTLIER");
                }
                MyPrintf(L" )\r\n");
            }
        }
        MyPrintf(L"\r\n");
    }

Cleanup:

    if (OutBuf != NULL) {
        free(OutBuf); 
        OutBuf = NULL;
    }

    if (DriverHandle != NULL) {
        NTSTATUS st;
        st = NtClose(DriverHandle);
        DriverHandle = NULL;
    }

    return dwErr;
}

DWORD
SpcInfo(
    BOOLEAN fSwAll)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    WCHAR *wCp;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

TryAgain:

    wcscpy((WCHAR *)InBuf, L"*");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            wCp += wcslen(wCp) + 1;
        }
    }

    wcscpy((WCHAR *)InBuf, L"");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            if (fSwAll == TRUE || *wCp == '+') {
                GetDCs((wCp+1));
            }
            wCp += wcslen(wCp) + 1;
        }
    }

Cleanup:

    if (DriverHandle != NULL) {
        NtClose(DriverHandle);
        DriverHandle = NULL;
    }
    if (OutBuf != NULL) {
        free(OutBuf);
        OutBuf = NULL;
    }
    return dwErr;
}

VOID
GetDCs(
    LPWSTR Name)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR *wCp;

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   Name,
                   (wcslen(Name) + 1) * sizeof(WCHAR),
                   OutBuf2,
                   sizeof(OutBuf2));

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf2;
        while (*wCp) {
            MyPrintf(L"\t[%ws]\r\n", wCp);
            wCp += wcslen(wCp) + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\remotefs\dfs\tools\dfsutil\flush.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       flush.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmdfs.h>
#include "struct.hxx"
#include "dfsfsctl.h"
#include "messages.h"


WCHAR wszEverything[] = L"*";

DWORD
PktFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"PktFlush(%ws)\r\n", EntryPath);

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    MyPrintf(L"EntryPath=[%ws]\r\n", EntryPath);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"PktFlush exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
SpcFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"SpcFlush(%ws)\r\n", EntryPath);

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    MyPrintf(L"EntryPath=[%ws]\r\n", EntryPath);

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_SPC_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"PktFlush exit %d\r\n", dwErr);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\copyfile.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    SIS fast copy file routines

Authors:

    Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// This is ugly, but we need it in order to check the node type codes on files
// that we're trying to copy, and I figure that it's better than trying to hard
// code the constant.
//
//#include "..\..\..\cntfs\nodetype.h"

NTSTATUS
SipCopyStream(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PUNICODE_STRING      srcFileName,
    IN LONGLONG             srcStreamSize,
    IN PUNICODE_STRING      dstFileName,
    IN PUNICODE_STRING      streamName)
/*++

Routine Description:

    Copy a stream from a source file to a destination file.

Arguments:

    deviceExtension - The device extension for the target device.

    srcFileName     - The fully qualified file name of the source file, not including any stream name.

    srcStreamSize   - The size of the source stream in bytes.

    dstFileName     - The fully qualified file name of the destination file, not including any stream name.

    streamName      - The name of the stream to copy.

Return Value:

    The status of the copy.

--*/
{
    HANDLE              srcFileHandle = NULL;
    HANDLE              dstFileHandle = NULL;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   Obja[1];
    HANDLE              copyEventHandle = NULL;
    PKEVENT             copyEvent = NULL;
    IO_STATUS_BLOCK     Iosb[1];
    UNICODE_STRING      fullName[1];

#if     DBG
    if (BJBDebug & 0x8) {
        return STATUS_UNSUCCESSFUL;
    }
#endif  // DBG

    fullName->Buffer = NULL;

    if (srcFileName->Length > dstFileName->Length) {
        fullName->MaximumLength = srcFileName->Length + streamName->Length;
    } else {
        fullName->MaximumLength = dstFileName->Length + streamName->Length;
    }


    fullName->Buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        fullName->MaximumLength,
                        ' siS');

    if (NULL == fullName->Buffer) {
        SIS_MARK_POINT();
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = SipCreateEvent(
                SynchronizationEvent,
                &copyEventHandle,
                &copyEvent);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    fullName->Length = 0;
    RtlCopyUnicodeString(fullName,srcFileName);

    status = RtlAppendUnicodeStringToString(
                fullName,
                streamName);

    ASSERT(STATUS_SUCCESS == status);   // We guaranteed that the buffer was big enough.

    InitializeObjectAttributes( Obja,
                                fullName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    status = IoCreateFile(
                &srcFileHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                0,                          // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE
                 | FILE_NO_INTERMEDIATE_BUFFERING,
                NULL,                       // EA Buffer
                0,                          // EA length
                CreateFileTypeNone,
                NULL,                       // Extra create parameters
                IO_FORCE_ACCESS_CHECK
                 | IO_NO_PARAMETER_CHECKING
                );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    fullName->Length = 0;
    RtlCopyUnicodeString(fullName,dstFileName);

    status = RtlAppendUnicodeStringToString(
                fullName,
                streamName);

    ASSERT(STATUS_SUCCESS == status);   // We guaranteed that the buffer was big enough.

    InitializeObjectAttributes( Obja,
                                fullName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    status = IoCreateFile(
                &dstFileHandle,
                GENERIC_READ | GENERIC_WRITE,
                Obja,
                Iosb,
                &deviceExtension->FilesystemBytesPerFileRecordSegment,
                FILE_ATTRIBUTE_NORMAL,
                0,                                                      // share access
                FILE_CREATE,
                FILE_NON_DIRECTORY_FILE,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING
                );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

    status = SipBltRange(
                deviceExtension,
                srcFileHandle,
                dstFileHandle,
                0,                      // starting offset
                srcStreamSize,          // length
                copyEventHandle,
                copyEvent,
                NULL,                   // abortEvent
                NULL);                  // checksum (we don't care)

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        goto done;
    }

done:

    if (NULL != fullName->Buffer) {
        ExFreePool(fullName->Buffer);
    }

    if (NULL != srcFileHandle) {
        ZwClose(srcFileHandle);
    }

    if (NULL != dstFileHandle) {
        ZwClose(dstFileHandle);
    }

    if (NULL != copyEvent) {
        ObDereferenceObject(copyEvent);
    }

    if (NULL != copyEventHandle) {
        ZwClose(copyEventHandle);
    }

    return status;
}

NTSTATUS
SipCopyFileCreateDestinationFile(
    IN PUNICODE_STRING              dstFileName,
    IN ULONG                        createDisposition,
    IN PFILE_OBJECT                 calledOnFileObject,
    OUT PHANDLE                     dstFileHandle,
    OUT PFILE_OBJECT                *dstFileObject,
    IN PDEVICE_EXTENSION            deviceExtension)
/*++

Routine Description:

    Create the destination file for a SIS copyfile.  This code is split out from
    the mainline copyfile code because we create the destination in different places
    depending on whether replace-if-exists is set.  This function creates the file
    using the user's privs and verifies that it is on the correct volume and is not
    mapped by the user.  The file is opened exclusively.

Arguments:

    dstFileName         -   The fully qualified name of the file to create.

    createDisposition   -   How to create the file

    calledOnFileObject  -   The file object on which the COPYFILE call was made; used to
                            verify that the destination file is on the right volume.

    dstFileHandle       -   returns a handle to the newly created file

    dstFileObject       -   returns a pointer to the newly created file object

    deviceExtension     -   the device extension for the SIS device

Return Value:

    The status of the create.

--*/
{
    OBJECT_ATTRIBUTES           Obja[1];
    IO_STATUS_BLOCK             Iosb[1];
    NTSTATUS                    status;
    OBJECT_HANDLE_INFORMATION   handleInformation;
    LARGE_INTEGER               zero;
    FILE_STANDARD_INFORMATION   standardInfo[1];
    ULONG                       returnedLength;

    zero.QuadPart = 0;

#if     DBG
    {
        ULONG data = 0;
        ULONG i;

        for (i = 0; (i < 4) && (i * sizeof(WCHAR) < dstFileName->Length); i++) {
            data = data << 8 | (dstFileName->Buffer[dstFileName->Length / sizeof(WCHAR) - i - 1] & 0xff);
        }
        SIS_MARK_POINT_ULONG(data);
    }
#endif  // DBG

    //
    // Create the destination file with exclusive access.  We create the file with an initial allocation of
    // the size of the underlying NTFS BytesPerFileRecordSegment.  We do this in order to force the $DATA attribute
    // to always be nonresident; we deallocate the space later in the copyfile process.  We need to have the
    // attribute be nonresident because otherwise in certain cases when it gets converted to nonresident (which
    // can happen when the reparse point is written) NTFS will generate a paging IO write to the attribute,
    // which SIS will interpret as as a real write, and destroy the file contents.
    //

    InitializeObjectAttributes( Obja,
                                dstFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = IoCreateFile(
                dstFileHandle,
                GENERIC_READ | GENERIC_WRITE | DELETE,
                Obja,
                Iosb,
                &deviceExtension->FilesystemBytesPerFileRecordSegment,
                FILE_ATTRIBUTE_NORMAL,
                0,                                                      // share access
                createDisposition,
                FILE_NON_DIRECTORY_FILE,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING
                );


    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return status;
    }

    //
    // Dereference the file handle to a pointer to the file object.
    //

    status = ObReferenceObjectByHandle( *dstFileHandle,
                                        FILE_WRITE_DATA,
                                        *IoFileObjectType,
                                        UserMode,
                                        (PVOID *) dstFileObject,
                                        &handleInformation );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return status;
    }

    SIS_MARK_POINT_ULONG(*dstFileObject);

    //
    // Make sure the file is on the same device as the file object on which the
    // fsctl came down.
    //

    if (IoGetRelatedDeviceObject( *dstFileObject) !=
        IoGetRelatedDeviceObject( calledOnFileObject )) {

        //
        // The two files refer to different devices. Return an appropriate
        // error.
        //

        SIS_MARK_POINT();

        return STATUS_NOT_SAME_DEVICE;
    }

    //
    // Make sure no one has a section mapped to the destination file.
    //
    if ((NULL != (*dstFileObject)->SectionObjectPointer) &&
        !MmCanFileBeTruncated((*dstFileObject)->SectionObjectPointer,&zero)) {
        //
        // There's a mapped section to the file, so we don't really have it
        // exclusive, so we can't safely turn it into a SIS file.
        //
        SIS_MARK_POINT();
        return STATUS_SHARING_VIOLATION;
    }

    //
    // Make sure the destination file doesn't have hard links to it.
    //

    status = SipQueryInformationFile(
                *dstFileObject,
                deviceExtension->DeviceObject,
                FileStandardInformation,
                sizeof(*standardInfo),
                standardInfo,
                &returnedLength);

    if (sizeof(*standardInfo) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // standard information.
        //
        SIS_MARK_POINT_ULONG(returnedLength);

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    if (1 != standardInfo->NumberOfLinks) {
        SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    return STATUS_SUCCESS;
}

void NTAPI
SipCopyfileSourceOplockCompletionAPC(
    IN PVOID                ApcContext,
    IN PIO_STATUS_BLOCK     iosb,
    IN ULONG                Reserved)
/*++

Routine Description:

    Copyfile sometimes sets an oplock on the source file in order to
    avoid sharing violations.  This is the oplock completion APC that
    gets called when the oplock completes.  All we do is to free the
    IO status block; we're really using the oplock to prevent sharing
    violations, we're not ever going to acknowledge it, we're just going
    to finish the copy and then close the file.

Arguments:

    ApcContext - a pointer to the io status block.

    iosb - a pointer to the same io status block

Return Value:

--*/
{
    UNREFERENCED_PARAMETER( Reserved );
    UNREFERENCED_PARAMETER( ApcContext );

    ASSERT(ApcContext == iosb);

    ExFreePool(iosb);
}

NTSTATUS
SipFsCopyFile(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp)

/*++

Routine Description:

    This fsctrl function copies a file.  Source and destination path names
    are passed in via the input buffer (see SI_COPYFILE).

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PSI_COPYFILE                    copyFile;
    UNICODE_STRING                  fileName[2];
    PFILE_OBJECT                    fileObject[2] = {NULL,NULL};
    HANDLE                          fileHandle[2] = {NULL,NULL};
    LINK_INDEX                      linkIndex[2];
    CSID                            CSid;
    PVOID                           streamInformation = NULL;
    ULONG                           streamAdditionalLengthMagnitude;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                        status;
    OBJECT_HANDLE_INFORMATION       handleInformation;
    IO_STATUS_BLOCK                 Iosb[1];
    PDEVICE_EXTENSION               deviceExtension = DeviceObject->DeviceExtension;
    OBJECT_ATTRIBUTES               Obja[1];
    int                             i;
    PSIS_PER_FILE_OBJECT            perFO;
    PSIS_SCB                        scb;
    LARGE_INTEGER                   zero;
    LARGE_INTEGER                   underlyingFileSize;
    BOOLEAN                         srcIsSISLink;
    FILE_END_OF_FILE_INFORMATION    endOfFile;
    FILE_BASIC_INFORMATION          basicInformation[1];
    FILE_STANDARD_INFORMATION       standardInfo[1];
    FILE_INTERNAL_INFORMATION       internalInformation[1];
    PSIS_PER_LINK                   srcPerLink = NULL;
    PSIS_PER_LINK                   dstPerLink = NULL;
    LARGE_INTEGER                   CSFileNtfsId;
    FILE_ZERO_DATA_INFORMATION      zeroDataInformation[1];
    BOOLEAN                         prepared = FALSE;
    LONGLONG                        CSFileChecksum;
    CHAR                            reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
    PSIS_CS_FILE                    CSFile = NULL;
    ULONG                           returnedLength;
    SIS_CREATE_CS_FILE_REQUEST      createRequest[1];
    PDEVICE_OBJECT                  srcFileRelatedDeviceObject;


#define srcFileName   fileName[0]
#define dstFileName   fileName[1]
#define srcFileObject fileObject[0]
#define dstFileObject fileObject[1]
#define dstFileHandle fileHandle[0]
#define srcFileHandle fileHandle[1]
#define srcLinkIndex  linkIndex[0]
#define dstLinkIndex  linkIndex[1]

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    zero.QuadPart = 0;

    if (!SipCheckPhase2(deviceExtension)) {
        //
        // SIS couldn't initialize.  This probably isn't a SIS-enabled volume, so punt
        // the request.
        //

        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    SIS_MARK_POINT();

    //
    // Make sure the MaxIndex file is already open.  We need to do this
    // to prevent a deadlock if someone perversely wants to do a copyfile
    // with the MaxIndex file itself as the source.  If we can't open it,
    // fail with STATUS_INVALID_DEVICE_REQUEST, because SIS can't properly
    // initialize.
    //
    status = SipAssureMaxIndexFileOpen(deviceExtension);

    if (!NT_SUCCESS(status)) {

        SIS_MARK_POINT_ULONG(status);

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    copyFile = (PSI_COPYFILE) Irp->AssociatedIrp.SystemBuffer;

    //
    // Verify that the input buffer is present, and that it's long enough to contain
    // at least the copyfile header, and that the user isn't expecting output.
    //
    if ((NULL == copyFile)
        || (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(SI_COPYFILE))
        || (irpSp->Parameters.FileSystemControl.OutputBufferLength  != 0)) {
        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_1;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_1;
    }

#if     DBG
    //
    // Check for the magic "checkpoint log" call, which will make a copy of the
    // mark point string buffer.  (This doesn't have anything to do with a legit
    // copyfile request, it's just a convenient entry point for a test application
    // to request this function.)
    //
    if (copyFile->Flags & 0x80000000) {
        SipCheckpointLog();

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = GCH_MARK_POINT_ROLLOVER;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }
#endif  // DBG

    if (copyFile->Flags & ~COPYFILE_SIS_FLAGS) {
        status = STATUS_INVALID_PARAMETER_2;
        goto Error;
    }

    //
    // Verify that the user isn't passing in null-string filenames.
    //
    if ((copyFile->SourceFileNameLength <= 0) ||
        (copyFile->DestinationFileNameLength <= 0)) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_3;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_3;
    }

    srcFileName.Buffer = copyFile->FileNameBuffer;
    srcFileName.MaximumLength = (USHORT) copyFile->SourceFileNameLength;
    srcFileName.Length = srcFileName.MaximumLength - sizeof(WCHAR);

    dstFileName.Buffer = &copyFile->FileNameBuffer[srcFileName.MaximumLength / sizeof(WCHAR)];
    dstFileName.MaximumLength = (USHORT) copyFile->DestinationFileNameLength;
    dstFileName.Length = dstFileName.MaximumLength - sizeof(WCHAR);

    //
    // Verify that the user didn't supply file name length(s) that are too big
    // to fit in a USHORT.
    //
    if (((ULONG)srcFileName.MaximumLength != copyFile->SourceFileNameLength) ||
        ((ULONG)dstFileName.MaximumLength != copyFile->DestinationFileNameLength)) {
        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER;
    }

#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: (%.*ls -> %.*ls)\n",
             __LINE__,
             srcFileName.Length / sizeof(WCHAR),
             srcFileName.Buffer ? srcFileName.Buffer : L"",
             dstFileName.Length / sizeof(WCHAR),
             dstFileName.Buffer ? dstFileName.Buffer : L"");
    }
#endif  // DBG

    //
    // Verify that the buffer is big enough to contain the strings it claims to
    // contain, and that the string lengths passed in by the user make sense.
    //
    if (((ULONG)(srcFileName.MaximumLength
            + dstFileName.MaximumLength
            + FIELD_OFFSET(SI_COPYFILE, FileNameBuffer))
          > irpSp->Parameters.FileSystemControl.InputBufferLength)
        || (0 != (srcFileName.MaximumLength % sizeof(WCHAR)))
        || (0 != (dstFileName.MaximumLength % sizeof(WCHAR)))) {

        SIS_MARK_POINT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_4;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Open the source file for share read.  Ask only for read access.
    // If it turns out that the source file is not a SIS link, then
    // we'll reopen it exclusively.
    //
    // Note that we must call IoCreateFile instead of ZwCreateFile--the latter
    // bypasses access checking.  IO_NO_PARAMETER_CHECKING causes IoCreateFile
    // to change its local var RequestorMode (PreviousMode) to KernelMode, and
    // IO_FORCE_ACCESS_CHECK forces the same access checking that would be done
    // if the user mode caller had called NtCreateFile directly.
    //

    SIS_MARK_POINT();

    InitializeObjectAttributes( Obja,
                                &srcFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    status = IoCreateFile(
                &srcFileHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                0,                          // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE
                 | FILE_NO_INTERMEDIATE_BUFFERING,
                NULL,                       // EA Buffer
                0,                          // EA length
                CreateFileTypeNone,
                NULL,                       // Extra create parameters
                IO_FORCE_ACCESS_CHECK
                 | IO_NO_PARAMETER_CHECKING
                );

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (! NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Dereference the file handle to a pointer to the file object.
    //

    status = ObReferenceObjectByHandle( srcFileHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        UserMode,
                                        (PVOID *) &srcFileObject,
                                        &handleInformation );

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }


    SIS_MARK_POINT_ULONG(srcFileObject);

    srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);

    //
    // Make sure the file is on the same device as the file object on which the
    // fsctl came down.
    //

    if ( srcFileRelatedDeviceObject !=
        IoGetRelatedDeviceObject( irpSp->FileObject )) {

        //
        // The source file is on a different device than the file on which the
        // fsctl was called.  Fail the call.
        //

        SIS_MARK_POINT();

        status = STATUS_NOT_SAME_DEVICE;
        goto Error;
    }

    //
    // Make sure that this file object looks like a valid NTFS file object.
    // There's no really good way to do this, so we just make sure that the file
    // has FsContext and FsContext2 filled in, and that the NodeTypeCode in the
    // FsContext pointer is correct for an NTFS file.  We use a try-except block
    // in case the FsContext pointer is filled in with something that's not really
    // a valid pointer.
    //
    try {
        if (NULL == srcFileObject->FsContext ||
            NULL == srcFileObject->FsContext2 ||
            // NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
            NTFS_NTC_SCB_DATA != ((PFSRTL_COMMON_FCB_HEADER)srcFileObject->FsContext)->NodeTypeCode
           ) {
            SIS_MARK_POINT();

            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

#if     DBG
        DbgPrint("SIS: SipFsCopyFile: took an exception accessing srcFileObject->FsContext.\n");
#endif  // DBG
        SIS_MARK_POINT();

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto Error;
    }


    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    srcIsSISLink = SipIsFileObjectSIS(srcFileObject, DeviceObject, FindActive, &perFO, &scb);
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!srcIsSISLink) {
        //
        // The source file isn't a SIS link, so we need to close it and reopen it exclusively.
        //

        ObDereferenceObject(srcFileObject);
        srcFileObject = NULL;

        ZwClose(srcFileHandle);
        srcFileHandle = NULL;

        SIS_MARK_POINT();

        status = IoCreateFile(
                    &srcFileHandle,
                    GENERIC_READ,
                    Obja,
                    Iosb,
                    0,                          // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    0,                          // sharing (exclusive)
                    FILE_OPEN,
                    FILE_NON_DIRECTORY_FILE
                     | FILE_NO_INTERMEDIATE_BUFFERING,
                    NULL,                       // EA Buffer
                    0,                          // EA length
                    CreateFileTypeNone,
                    NULL,                       // Extra create parameters
                    IO_FORCE_ACCESS_CHECK
                     | IO_NO_PARAMETER_CHECKING
                    );

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Error;
        }

        //
        // Dereference the file handle to a pointer to the file object.
        //

        status = ObReferenceObjectByHandle( srcFileHandle,
                                            FILE_READ_DATA,
                                            *IoFileObjectType,
                                            UserMode,
                                            (PVOID *) &srcFileObject,
                                            &handleInformation );

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        SIS_MARK_POINT_ULONG(srcFileObject);

        srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);

        //
        // Make sure the file is on the same device as the file object on which the
        // fsctl came down.
        //

        if (srcFileRelatedDeviceObject !=
            IoGetRelatedDeviceObject( irpSp->FileObject )) {

            //
            // The source file is on a different device than the file on which the
            // fsctl was called.  Fail the call.
            //

            SIS_MARK_POINT();

            status = STATUS_NOT_SAME_DEVICE;
            goto Error;
        }

        //
        // Make sure that this file object looks like a valid NTFS file object.
        // There's no really good way to do this, so we just make sure that the file
        // has FsContext and FsContext2 filled in, and that the NodeTypeCode in the
        // FsContext pointer is correct for an NTFS file.  We use a try-except block
        // in case the FsContext pointer is filled in with something that's not really
        // a valid pointer.
        //
        try {
            if (NULL == srcFileObject->FsContext ||
                NULL == srcFileObject->FsContext2 ||
                // NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
                NTFS_NTC_SCB_DATA != ((PFSRTL_COMMON_FCB_HEADER)srcFileObject->FsContext)->NodeTypeCode
               ) {
                SIS_MARK_POINT();

                status = STATUS_OBJECT_TYPE_MISMATCH;
                goto Error;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

#if     DBG
            DbgPrint("SIS: SipFsCopyFile: took an exception accessing srcFileObject->FsContext.\n");
#endif  // DBG
            SIS_MARK_POINT();

            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    }

    //
    // Get the basic information to get the file attributes and the date
    // so that we can reset it after we transmute the file if needed.
    // We will also use this to set the data on the destination file.
    //

    status = SipQueryInformationFile(
                srcFileObject,
                DeviceObject,
                FileBasicInformation,
                sizeof(*basicInformation),
                basicInformation,
                &returnedLength);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    if (sizeof(*basicInformation) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // basic information.
        //
        status = STATUS_INFO_LENGTH_MISMATCH;
        SIS_MARK_POINT_ULONG(returnedLength);
        goto Error;
    }

    status = SipQueryInformationFile(
                srcFileObject,
                DeviceObject,
                FileStandardInformation,
                sizeof(*standardInfo),
                standardInfo,
                &returnedLength);

    if (sizeof(*standardInfo) != returnedLength) {
        //
        // For some reason, we got the wrong amount of data for the
        // standard information.
        //
        status = STATUS_INFO_LENGTH_MISMATCH;

        SIS_MARK_POINT_ULONG(returnedLength);

        goto Error;
    }

    if (1 != standardInfo->NumberOfLinks) {
        SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

        status = STATUS_OBJECT_TYPE_MISMATCH;

        goto Error;
    }

    if (!srcIsSISLink) {

        if (basicInformation->FileAttributes & (FILE_ATTRIBUTE_REPARSE_POINT |
                                                FILE_ATTRIBUTE_ENCRYPTED |
                                                FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // We can't SIS-ify other drivers' reparse points
            // and we don't touch encrypted files or directories.
            // Reject the call.
            //
            SIS_MARK_POINT();
            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        if (copyFile->Flags & COPYFILE_SIS_LINK) {
            //
            // The caller wants a copy only if the source is already a link
            // (fast copy).  It isn't, so return.
            //
            SIS_MARK_POINT();
            status = STATUS_OBJECT_TYPE_MISMATCH;
            goto Error;
        }

        if (basicInformation->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
            //
            // We only copy sparse files if they're fully allocated.  Check to see
            // if it is.
            //

            FILE_STANDARD_INFORMATION       standardInfo[1];
            FILE_ALLOCATED_RANGE_BUFFER     inArb[1];
            FILE_ALLOCATED_RANGE_BUFFER     outArb[1];
            ULONG                           returnedLength;

            status = SipQueryInformationFile(
                        srcFileObject,
                        DeviceObject,
                        FileStandardInformation,
                        sizeof(FILE_STANDARD_INFORMATION),
                        standardInfo,
                        NULL);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);

                goto Error;
            }

            inArb->FileOffset.QuadPart = 0;
            inArb->Length.QuadPart = MAXLONGLONG;

            status = SipFsControlFile(
                        srcFileObject,
                        DeviceObject,
                        FSCTL_QUERY_ALLOCATED_RANGES,
                        inArb,
                        sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                        outArb,
                        sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                        &returnedLength);

            if ((returnedLength == 0)
                || (outArb->FileOffset.QuadPart != 0)
                || (outArb->Length.QuadPart < standardInfo->EndOfFile.QuadPart)) {

                //
                // It's not fully allocated.  Disallow the copy.
                //
                status = STATUS_OBJECT_TYPE_MISMATCH;
                SIS_MARK_POINT();
                goto Error;
            }
        }

    }

    if ((NULL != srcFileObject->SectionObjectPointer) &&
        !MmCanFileBeTruncated(srcFileObject->SectionObjectPointer,&zero)) {
        //
        // There's a mapped section to the file, so we don't really have it
        // exclusive, so we can't use it for a source file.  Fail.
        //

        SIS_MARK_POINT_ULONG(srcFileObject);

        status = STATUS_SHARING_VIOLATION;
        goto Error;
    }

    if (!(copyFile->Flags & COPYFILE_SIS_REPLACE)) {

        //
        // We're not doing an overwrite create, so open the file before we do anything
        // else.  This allows us to do more validity checks before making the common
        // store file and mutating the source link (if needed).  If we're opening overwrite
        // then we postpone the open so that certain errors (like not being able to create
        // the common store file) do not cause us to overwrite the destination.
        //

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipCopyFileCreateDestinationFile(
                    &dstFileName,
                    FILE_CREATE,
                    irpSp->FileObject,
                    &dstFileHandle,
                    &dstFileObject,
                    deviceExtension);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }
    }

    //
    // If the source file is not already a SIS link, then move the file
    // into the common store and create a link to it.
    //

    if (!srcIsSISLink) {

        FILE_STANDARD_INFORMATION       standardInformation[1];

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        //
        // Query the standard information to get the file length.
        //
        status = SipQueryInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileStandardInformation,
                    sizeof(*standardInformation),
                    standardInformation,
                    NULL);                          // returned length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        underlyingFileSize = standardInformation->EndOfFile;

        //
        // Get the NTFS file id.  We need this in order to write the log record for the
        // CS file refcount change without a per-FO.
        //
        status = SipQueryInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileInternalInformation,
                    sizeof(*internalInformation),
                    internalInformation,
                    NULL);                      // returned length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Copy the source file into the common store directory and set
        // its ref count.
        //

        createRequest->deviceExtension = deviceExtension;
        createRequest->CSid = &CSid;
        createRequest->NtfsId = &CSFileNtfsId;
        createRequest->abortEvent = NULL;
        createRequest->CSFileChecksum = &CSFileChecksum;
#undef  srcFileObject   // this is ugly, but I'm in a hurry.  Clean up later.  BJB
        createRequest->srcFileObject = fileObject[0];
#define srcFileObject   fileObject[0]

        KeInitializeEvent(createRequest->doneEvent,NotificationEvent,FALSE);

        ExInitializeWorkItem(
                createRequest->workQueueItem,
                SipCreateCSFileWork,
                createRequest);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ExQueueWorkItem(
                createRequest->workQueueItem,
                DelayedWorkQueue);

        status = KeWaitForSingleObject(
                    createRequest->doneEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ASSERT(STATUS_SUCCESS == status);       // createRequest is on our stack, so we really need to wait

        status = createRequest->status;

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Error;
        }

        //
        // Lookup a CSFile object.
        //
        CSFile = SipLookupCSFile(
                    &CSid,
                    &CSFileNtfsId,
                    DeviceObject);

        if (NULL == CSFile) {
            SIS_MARK_POINT();
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Indicate that this is a new CS file that's never had a reference
        // to it.  We don't need to take the spin lock because before we write
        // the reparse point no one can know the GUID to get to this CS file, so
        // we're sure we have it exclusively.
        //
        CSFile->Flags |= CSFILE_NEVER_HAD_A_REFERENCE;

        //
        // Prepare to increment the reference count on the CS file, and allocate
        // a new link index and per link for the file.
        //
        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                    CSFile,
                    &internalInformation->IndexNumber,
                    DeviceObject,
                    &srcLinkIndex,
                    &srcPerLink,
                    &prepared);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Fill in the reparse point data.
        //

        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
                 reparseBuffer,
                 &CSid,
                 &srcLinkIndex,
                 &CSFileNtfsId,
                 &internalInformation->IndexNumber,
                 &CSFileChecksum,
                 TRUE)) {

            SIS_MARK_POINT();

            status = STATUS_DRIVER_INTERNAL_ERROR;
            goto Error;

        }

        //
        // Set the reparse point information and increment the CS file refcount.
        // This needs to proceed using the prepare/act/finish protocol for updating
        // the reference count.  Note that we do this before zeroing the file
        // so as not to lose the contents in the event of a failure later on.
        //

        status = SipFsControlFile(
                     srcFileObject,
                     DeviceObject,
                     FSCTL_SET_REPARSE_POINT,
                     reparseBuffer,
                     FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
                     NULL,                //  Output buffer
                     0,                   //  Output buffer length
                     NULL);               //  returned output buffer length

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        prepared = FALSE;
        status = SipCompleteCSRefcountChange(
                        srcPerLink,
                        &srcPerLink->Index,
                        CSFile,
                        TRUE,
                        TRUE);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            //
            // Now what?  Probably should back out the file copy, but we'll just pretend
            // that it worked.
            //
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipFsCopyFile: unable to complete refcount change, 0x%x\n",status);
#endif  // DBG
        }

        //
        // Set the file sparse, and zero it.
        //

        status = SipFsControlFile(
                    srcFileObject,
                    DeviceObject,
                    FSCTL_SET_SPARSE,
                    NULL,               // input buffer
                    0,                  // i.b. length
                    NULL,               // output buffer
                    0,                  // o.b. length
                    NULL);              // returned length

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        if (underlyingFileSize.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
            //
            // Only zero the file if we're sure that it's $DATA attribute is non-resident.
            // If it's resident, then either we'll convert it to non-resident below, which will
            // generate a paging IO write that will confuse us, or else it will stay resident
            // in which case it will appear to be allocated when we open the file.  If that happens,
            // we want to have the correct data in the file, hence we avoid zeroing it here.
            //

            zeroDataInformation->FileOffset.QuadPart = 0;
            zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

            status = SipFsControlFile(
                        srcFileObject,
                        DeviceObject,
                        FSCTL_SET_ZERO_DATA,
                        zeroDataInformation,
                        sizeof(FILE_ZERO_DATA_INFORMATION),
                        NULL,               // output buffer
                        0,                  // o.b. length
                        NULL);              // returned length

            SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                goto Error;
            }
        }

        //
        // Reset the file times that are contained in the basic information.
        //

        status = SipSetInformationFile(
                    srcFileObject,
                    DeviceObject,
                    FileBasicInformation,
                    sizeof(*basicInformation),
                    basicInformation);

        //
        // Just ignore errors on this (maybe we should return a warning?)
        //
#if DBG
        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            DbgPrint("SIS: SipFsCopyFile: set basic information returned 0x%x\n",status);
        }
#endif  // DBG

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        ASSERT(NULL != CSFile);
        SipDereferenceCSFile(CSFile);
        CSFile = NULL;

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    } else {

        //
        // The source file is a SIS link.
        //

        PSIS_CS_FILE        csFile = scb->PerLink->CsFile;
        KIRQL               OldIrql;
        BOOLEAN             SourceDirty, SourceDeleted;

        srcPerLink = scb->PerLink;

        SipReferencePerLink(srcPerLink);

        KeAcquireSpinLock(srcPerLink->SpinLock, &OldIrql);
        SourceDirty = (srcPerLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
        SourceDeleted = (srcPerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;
        KeReleaseSpinLock(srcPerLink->SpinLock, OldIrql);

        SipAcquireScb(scb);
        if (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) {
            SIS_MARK_POINT();
            SourceDirty = TRUE;
        }
        SipReleaseScb(scb);

        if (SourceDirty) {
            //
            // The source is a SIS link, but it is dirty, so we can't just copy the CS file.
            // Furthermore, we're not really equipped to make it into a new CS file while
            // it's still open and dirty.  Just fail the request.  NB: There is no race
            // here between checking the dirty bit and completing the copy.  If someone
            // sets the dirty bit later, all that will happen is that we'll have a copy
            // of the old file.
            //
            SIS_MARK_POINT();
            status = STATUS_SHARING_VIOLATION;
            goto Error;
        }

        if (SourceDeleted) {
            //
            // The source file is deleted, so we can't copy it.
            //
            SIS_MARK_POINT();
            status = STATUS_FILE_DELETED;
            goto Error;
        }

        //
        // Get the existing common store index.
        //

        CSid = csFile->CSid;

        CSFileNtfsId = csFile->CSFileNtfsId;
        underlyingFileSize = csFile->FileSize;
        CSFileChecksum = csFile->Checksum;
    }

    if (copyFile->Flags & COPYFILE_SIS_REPLACE) {

        //
        // We've postponed opening (and therefore destroying) the destination file
        // as long as possible.  Do it now.
        //

        ASSERT(NULL == dstFileHandle);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        status = SipCopyFileCreateDestinationFile(
                    &dstFileName,
                    FILE_OVERWRITE_IF,
                    irpSp->FileObject,
                    &dstFileHandle,
                    &dstFileObject,
                    deviceExtension);

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }
    }

    //
    // Set the destination file sparse and set its length to be equal to
    // that of the underlying file.
    //
    status = SipFsControlFile(
                dstFileObject,
                DeviceObject,
                FSCTL_SET_SPARSE,
                NULL,               // input buffer
                0,                  // i.b. length
                NULL,               // output buffer
                0,                  // o.b. length
                NULL);              // returned o.b. length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    endOfFile.EndOfFile = underlyingFileSize;

    status = SipSetInformationFile(
                 dstFileObject,
                 DeviceObject,
                 FileEndOfFileInformation,
                 sizeof(FILE_END_OF_FILE_INFORMATION),
                 &endOfFile);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Zero the file to blow away the allocation.
    //

    zeroDataInformation->FileOffset.QuadPart = 0;
    zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

    status = SipFsControlFile(
                dstFileObject,
                DeviceObject,
                FSCTL_SET_ZERO_DATA,
                zeroDataInformation,
                sizeof(FILE_ZERO_DATA_INFORMATION),
                NULL,               // output buffer
                0,                  // o.b. length
                NULL);              // returned length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Get the NTFS file id.  We need this in order to write the log record for the
    // CS file refcount change without a per-FO.
    //
    status = SipQueryInformationFile(
                dstFileObject,
                DeviceObject,
                FileInternalInformation,
                sizeof(*internalInformation),
                internalInformation,
                NULL);                          // returned length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Prepare a refcount change for the common store file, allocate a new
    // link index and a new perLink.
    //
    status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                srcPerLink->CsFile,
                &internalInformation->IndexNumber,
                DeviceObject,
                &dstLinkIndex,
                &dstPerLink,
                &prepared);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    //  Build destination reparse point data.
    //

    reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

    if (!SipIndicesIntoReparseBuffer(
             reparseBuffer,
             &CSid,
             &dstLinkIndex,
             &CSFileNtfsId,
             &internalInformation->IndexNumber,
             &CSFileChecksum,
             TRUE)) {

        SIS_MARK_POINT();

        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto Error;

    }

    //
    //  Set a SIS link reparse point.
    //

#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: SipFsControlFile on dstFile\n",__LINE__);
    }
#endif  // DBG

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    status = SipFsControlFile(
                 dstFileObject,
                 DeviceObject,
                 FSCTL_SET_REPARSE_POINT,
                 reparseBuffer,
                 FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
                 NULL,                //  Output buffer
                 0,                   //  Output buffer length
                 NULL);               //  returned output buffer length

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        goto Error;
    }

    //
    // Set the file times on the destination file to be the same as the source.
    //

    status = SipSetInformationFile(
                dstFileObject,
                DeviceObject,
                FileBasicInformation,
                sizeof(*basicInformation),
                basicInformation);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        //
        // Not sure what to do if this fails.  Just ignore it for now.
        //
        SIS_MARK_POINT_ULONG(status);
#if     DBG
        DbgPrint("SIS: SipFsCopyFile: set times on source failed 0x%x\n",status);
#endif  // DBG
    }

    prepared = FALSE;
    status = SipCompleteCSRefcountChange(
                dstPerLink,
                &dstPerLink->Index,
                dstPerLink->CsFile,
                TRUE,
                TRUE);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);
    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

#if     DBG
        DbgPrint("SIS: SipFsCopyFile: final complete failed 0x%x\n",status);
#endif  // DBG

        goto Error;
    }


    //
    // Figure out if the source file has more than one stream, and if it does
    // copy the extra streams into the destination file.  We do not support
    // single instancing on secondary streams, but do allow them to have
    // ordinary alternate data streams, which may or may not have different
    // content.
    //
    // We need to close the primary stream before we copy the alternate
    // streams, or else we wind up with ValidDataLength getting messed up, which
    // is why we do this so late.
    //
    // The API for querying the names of the additional streams leaves something
    // to be desired, in that there is no way to tell how much buffer to use.
    // We work around this issue by exponentially increasing (by powers of 4) the amount of buffer
    // and calling back into NTFS each time we find that we hadn't supplied enough.
    // We start with 1 kilobyte of extra space, and then increase up to a
    // megabyte before giving up.
    //

    for (streamAdditionalLengthMagnitude = 10;
         streamAdditionalLengthMagnitude <= 20;
         streamAdditionalLengthMagnitude += 2)  {

        ULONG                       streamBufferSize = (1 << streamAdditionalLengthMagnitude) + sizeof(FILE_STREAM_INFORMATION);
        PFILE_STREAM_INFORMATION    currentStream;

        if (NULL != streamInformation) {
            ExFreePool(streamInformation);
        }

        streamInformation = ExAllocatePoolWithTag(PagedPool,
                                                  streamBufferSize,
                                                  ' siS');

        SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

        if (NULL == streamInformation) {
            SIS_MARK_POINT();

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        status = SipQueryInformationFile(
                     srcFileObject,
                     DeviceObject,
                     FileStreamInformation,
                     streamBufferSize,
                     streamInformation,
                     NULL                                   // returned length
                     );

        if (STATUS_BUFFER_OVERFLOW == status) {
            //
            // We didn't supply enough buffer.  Grow it and try again.
            continue;
        }

        if (!NT_SUCCESS( status )) {
            //
            // It failed for some other reason, so we can't do the copy.
            //
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Run through the list of streams, and copy each one that's not named ::DATA$
        //
        currentStream = (PFILE_STREAM_INFORMATION)streamInformation;
        for (;;) {
            UNICODE_STRING  string;

            //
            // The "stream" name should be of the form :stream:DATA$.  If it's not of this form,
            // we ignore it.  If "stream" is the null string, we also ignore it.
            //

            ASSERT(currentStream->StreamNameLength < MAXUSHORT);

            if ((currentStream->StreamNameLength > 7 * sizeof(WCHAR)) &&
                (':' == currentStream->StreamName[0])) {
                //
                // The name starts with a colon, and is long enough to conclude with :DATA$
                // and have a non-null stream name.  Verify that it ends with :DATA$.
                //
                string.MaximumLength = string.Length =  5 * sizeof(WCHAR);
                string.Buffer = currentStream->StreamName + currentStream->StreamNameLength/sizeof(WCHAR) - 5;
                if (RtlEqualUnicodeString(&string,&NtfsDataString,TRUE) &&
                    (':' == currentStream->StreamName[currentStream->StreamNameLength/sizeof(WCHAR) - 6])) {

                    //
                    // We have an alternate data stream to copy.  If we haven't already, close the main
                    // stream so that NTFS doesn't reset ValidDataLength to 0.
                    //
                    if (NULL != dstFileHandle) {
                        ZwClose(dstFileHandle);
                        dstFileHandle = NULL;

                        ASSERT(NULL != dstFileObject);
                        ObDereferenceObject(dstFileObject);
                        dstFileObject = NULL;
                    } else {
                        ASSERT(NULL == dstFileObject);
                    }

                    //
                    // The stream name is of the form :stream:DATA$, and "stream" is not the null string.
                    // Copy the stream to the destination file.
                    //
                    string.MaximumLength = string.Length = (USHORT)(currentStream->StreamNameLength - 6 * sizeof(WCHAR));
                    string.Buffer = currentStream->StreamName;

                    status = SipCopyStream(
                                deviceExtension,
                                &srcFileName,
                                currentStream->StreamSize.QuadPart,
                                &dstFileName,
                                &string);

                    if (!NT_SUCCESS(status)) {
                        NTSTATUS        reopenStatus;

                        SIS_MARK_POINT_ULONG(status);

                        //
                        // Try to reopen the destination file so that we can later delete it.
                        //

                        reopenStatus = SipCopyFileCreateDestinationFile(
                                            &dstFileName,
                                            FILE_OVERWRITE_IF,
                                            irpSp->FileObject,
                                            &dstFileHandle,
                                            &dstFileObject,
                                            deviceExtension);

                        SIS_MARK_POINT_ULONG(reopenStatus);

                        //
                        // We don't care if the reopen worked; if it didn't, then we just won't be able to
                        // delete the partially created destinaion file object, which is just too bad.
                        // Note that we have already written the reparse point and finished the refcount update,
                        // so this create will be a full SIS create, and the delete below will be a full SIS
                        // delete, which will remove the newly created backpointer.
                        //

                        goto Error;
                    }
                }
            }

            if (0 == currentStream->NextEntryOffset) {
                //
                // This was the last stream in the buffer.  We're done.
                //
                goto doneWithStreams;
            }

            currentStream = (PFILE_STREAM_INFORMATION)(((PCHAR)currentStream) + currentStream->NextEntryOffset);
        }

    }   // Loop over stream buffer size

doneWithStreams:

    if (STATUS_BUFFER_OVERFLOW == status) {
        ASSERT(streamAdditionalLengthMagnitude > 20);

        //
        // Even a truly enormous buffer wasn't enough.  Too bad.
        //
        SIS_MARK_POINT();

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto Error;

    } else {
        ASSERT(streamAdditionalLengthMagnitude <= 20);
    }


Error:

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        if (prepared) {
            if (NULL == CSFile) {
                if (NULL != srcPerLink) {
                    SipCompleteCSRefcountChange(
                        srcPerLink,
                        &srcPerLink->Index,
                        srcPerLink->CsFile,
                        FALSE,
                        TRUE);
                } else {
                    ASSERT(NULL != dstPerLink);
                    SipCompleteCSRefcountChange(
                        dstPerLink,
                        &dstPerLink->Index,
                        dstPerLink->CsFile,
                        FALSE,
                        TRUE);
                }
            } else {
                SipCompleteCSRefcountChange(
                        NULL,
                        NULL,
                        CSFile,
                        FALSE,
                        TRUE);
            }
        }

        //
        // Delete the destination file if it was created.
        //

        if (dstFileObject) {

            FILE_DISPOSITION_INFORMATION disposition[1];
            NTSTATUS deleteStatus;

            disposition->DeleteFile = TRUE;

            //
            // We might be in the error path because the destination file was not on the
            // right device object.  If that's the case, then we can't use SipSetInformationFile
            // on it because it will hand the file object to the wrong device.  Instead, use
            // the generic version of the call, and start the irp at the top of the device
            // stack for the particular file object.
            //

            deleteStatus = SipSetInformationFileUsingGenericDevice(
                                dstFileObject,
                                IoGetRelatedDeviceObject(dstFileObject),
                                FileDispositionInformation,
                                sizeof(FILE_DISPOSITION_INFORMATION),
                                disposition);

#if DBG
            if (deleteStatus != STATUS_SUCCESS) {

                //
                // Not much we can do about this.  Just leak the file.
                //

                DbgPrint("SipFsCopyFile: unable to delete copied file, err 0x%x, initial error 0x%x\n", deleteStatus, status);
            }
#endif
        }
    } else {
        ASSERT(!prepared);
    }

    //
    // If there is a source file handle, close it.
    //
    if (NULL != srcFileHandle && NULL != srcFileObject) {
        ZwClose(srcFileHandle);
    }

    //
    // Close the destination file handle if there is one.
    //
    if (NULL != dstFileHandle) {
        ZwClose(dstFileHandle);
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    for (i = 0; i < 2; ++i) {
        if (fileObject[i]) {
            ObDereferenceObject(fileObject[i]);
        }
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (streamInformation) {
        ExFreePool(streamInformation);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != srcPerLink) {
        SipDereferencePerLink(srcPerLink);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != dstPerLink) {
        SipDereferencePerLink(dstPerLink);
    }

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    if (NULL != CSFile) {
        SipDereferenceCSFile(CSFile);
#if     DBG
        CSFile = NULL;
#endif  // DBG
    }
    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);


#if     DBG
    if (BJBDebug & 0x800) {
        DbgPrint("SIS: SipFsCopyFile %d: status %x\n", status);
    }
#endif  // DBG

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_COPYFILE);

    return status;
}
#undef  reparseBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\cow.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cow.c

Abstract:

	Copy on write support for the single instance store	
	
Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef		ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipBltRange)
#pragma alloc_text(PAGE, SipBltRangeByObject)
#endif		// ALLOC_PRAGMA

LIST_ENTRY CopyList[1];
KSPIN_LOCK CopyListLock[1];
KSEMAPHORE CopySemaphore[1];

NTSTATUS
SipBltRange(
	IN PDEVICE_EXTENSION		deviceExtension,
	IN HANDLE					sourceHandle,
	IN OUT HANDLE				dstHandle,
	IN LONGLONG					startingOffset,
	IN LONGLONG					length,
	IN HANDLE					copyEventHandle,
	IN PKEVENT					copyEvent,
    IN PKEVENT                  abortEvent,
	IN OUT PLONGLONG			checksum)
/*++

Routine Description:

	Wrapper for SipBltRangeByObject that takes a source handle rather than
	a file object pointer.  All this function does is to get the file object
	from the handle and call SipBltRangeByObject.

	This function must be called in the PsInitialSystemProcess context.

Arguments:

	sourceHandle - handle to the file from which to copy

	others - see SipBltRangeByObject for description

Return Value:

	status of the copy
--*/
{
	PFILE_OBJECT				srcFileObject = NULL;
	NTSTATUS					status;
	OBJECT_HANDLE_INFORMATION 	handleInformation[1];

	PAGED_CODE();

	status = ObReferenceObjectByHandle(
				sourceHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				KernelMode,
				(PVOID *) &srcFileObject,
				handleInformation);

	if (!NT_SUCCESS(status)) {
		ASSERT(NULL == srcFileObject);
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	status = SipBltRangeByObject(
				deviceExtension,
				srcFileObject,
				dstHandle,
				startingOffset,
				length,
				copyEventHandle,
				copyEvent,
				abortEvent,
				checksum);

done:

	if (NULL != srcFileObject) {
		ObDereferenceObject(srcFileObject);
	}

	return status;
}


NTSTATUS
SipBltRangeByObject(
	IN PDEVICE_EXTENSION		deviceExtension,
	IN PFILE_OBJECT				srcFileObject,
	IN OUT HANDLE				dstHandle,
	IN LONGLONG					startingOffset,
	IN LONGLONG					length,
	IN HANDLE					copyEventHandle,
	IN PKEVENT					copyEvent,
    IN PKEVENT                  abortEvent,
	IN OUT PLONGLONG			checksum)
/*++

Routine Description:

	Copy a range of a file from one place to another.  Maps the destination
	and does noncached reads from the source into the mapped
	region.  Does not return STATUS_SUCCESS until all of the bits
	of the new file are on the disk.

	This function must be called in the PsInitialSystemProcess context
	(ie., from a worker thread).

    This function may also be used to simply compute the checksum on a range
    of a file without doing a file copy.  Pass in srcFileObject == NULL and
    dstHandle == file to compute checksum on.

    NTRAID#65184-2000/03/09-nealch  SIS needs to check for sparse ranges when copying a file and not copy them


Arguments:

	deviceExtension - For the volume on which we're copying

	srcFileObject - the file from which to copy.  If NULL, checksum on
                    dstHandle file will be computed.

	dstHandle - Handle for the file into which to copy

	startingOffset - offset within the files from which to start copying

	length - the number of bytes to copy

	copyEventHandle - handle to an event that no one else
						is using now

	copyEvent - pointer to the same event as copyEventHandle

    abortEvent - pointer to an event that signals an abort request

	checksum - pointer to a place to hold the checksum of the blt'ed range.
				if NULL no checksum is computed.  Note that this must be
				initialized to 0 by the caller, unless a partial checksum has
				already beem computed, in which case it should contain the
				partial checksum.

Return Value:

	status of the copy
--*/
{
#define	MM_MAP_ALIGNMENT (64 * 1024 /*VACB_MAPPING_GRANULARITY*/)   // The file offset granularity that MM enforces.
#define	COPY_AMOUNT	(64 * 1024)	// How much we read or write at a time.  Must be >= MM_MAP_ALIGNMENT

	HANDLE				sectionHandle = NULL;
	NTSTATUS			status;
	LARGE_INTEGER		byteOffset;
	LONGLONG			finalOffset;
	IO_STATUS_BLOCK		Iosb[1];
	LARGE_INTEGER		maxSectionSize;
	ULONG				sectorSize = deviceExtension->FilesystemVolumeSectorSize;
	PIRP				readIrp = NULL;
	PDEVICE_OBJECT		srcFileRelatedDeviceObject;
	PIO_STACK_LOCATION	irpSp;

	PAGED_CODE();
    UNREFERENCED_PARAMETER( copyEventHandle );

	ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());
    ASSERT(checksum || srcFileObject);

	SIS_MARK_POINT_ULONG(startingOffset);
	SIS_MARK_POINT_ULONG(length);

    if (srcFileObject) {
	    srcFileRelatedDeviceObject = IoGetRelatedDeviceObject(srcFileObject);
    } else {
	    srcFileRelatedDeviceObject = NULL;
    }

	finalOffset = startingOffset + length;
	maxSectionSize.QuadPart = finalOffset;

	status = ZwCreateSection(
				&sectionHandle,
				SECTION_MAP_WRITE | STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY,
				NULL,
				&maxSectionSize,
				PAGE_READWRITE,
				SEC_COMMIT,
				dstHandle);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}
	ASSERT(status == STATUS_SUCCESS);	// and not STATUS_PENDING or anything weird

	for (byteOffset.QuadPart = startingOffset; byteOffset.QuadPart < finalOffset;) {
		ULONG 				validBytes, bytesToCopy;
		PCHAR				mappedBuffer = NULL, flushBuffer;
		LARGE_INTEGER		mappedOffset;
		ULONG_PTR		    viewSize;
        ULONG_PTR           flushSize;
		PCHAR				copyIntoAddress;
		ULONG				bytesCopied;

		SIS_MARK_POINT_ULONG(byteOffset.LowPart);

		mappedOffset.QuadPart = byteOffset.QuadPart - (byteOffset.QuadPart % MM_MAP_ALIGNMENT);
		ASSERT(mappedOffset.QuadPart <= byteOffset.QuadPart && mappedOffset.QuadPart + MM_MAP_ALIGNMENT > byteOffset.QuadPart);

        //
        // Abort if an oplock break has been received.
        //

        if (SipAbort(abortEvent)) {
			SIS_MARK_POINT();
            status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
            goto done;
        }

		if (finalOffset - mappedOffset.QuadPart > COPY_AMOUNT) {
			//
			// We can't map enough of the file to do the whole copy
			// here, so only map COPY_AMOUNT on this pass.
			//
			viewSize = COPY_AMOUNT;
		} else {
			//
			// We can map all the way to the end of the file.
			//
			viewSize = (ULONG)(finalOffset - mappedOffset.QuadPart);
		}
		ASSERT(viewSize >=
               (ULONG_PTR)(byteOffset.QuadPart - mappedOffset.QuadPart));
		validBytes = (ULONG)(viewSize - (ULONG)(byteOffset.QuadPart - mappedOffset.QuadPart));
		
		//
		// Now round validBytes up to a sector size.
		//
		bytesToCopy = ((validBytes + sectorSize - 1) / sectorSize) * sectorSize;

		ASSERT(bytesToCopy <= COPY_AMOUNT);

		//
		// Map in the region to which we're about to copy.
		//
		status = ZwMapViewOfSection(
					sectionHandle,
					NtCurrentProcess(),
					&mappedBuffer,
					0,							// zero bits
					0,							// commit size (ignored for mapped files)
					&mappedOffset,
					&viewSize,
					ViewUnmap,
					0,							// allocation type
					PAGE_READWRITE);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto done;
		}

		ASSERT(viewSize >= bytesToCopy);	// We have enough space allocated for the rounded up read

		copyIntoAddress = mappedBuffer + (ULONG)(byteOffset.QuadPart - mappedOffset.QuadPart);

        if (srcFileObject) {

		    // Now, read the bits in from the source file
		    readIrp = IoBuildSynchronousFsdRequest(
					    IRP_MJ_READ,
					    srcFileRelatedDeviceObject,
					    copyIntoAddress,
					    bytesToCopy,
					    &byteOffset,
					    copyEvent,
					    Iosb);

		    if (NULL == readIrp) {
			    status = STATUS_INSUFFICIENT_RESOURCES;
			    goto done;
		    }

		    irpSp = IoGetNextIrpStackLocation(readIrp);
		    irpSp->FileObject = srcFileObject;

		    status = IoCallDriver(srcFileRelatedDeviceObject, readIrp);

			if (STATUS_PENDING == status) {
			    status = KeWaitForSingleObject(copyEvent, Executive, KernelMode, FALSE, NULL);
			    ASSERT(status == STATUS_SUCCESS);
			    status = Iosb->Status;
			} else {
				KeClearEvent(copyEvent);
			}

		    if (!NT_SUCCESS(status)) {
			    SIS_MARK_POINT_ULONG(status);
			    ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);
			    goto done;
		    }

		    //
		    // Iosb->Information returns the actual number of bytes read from the
		    // file and into the mapped CS file, hence the actual number of bytes we
		    // copied on this trip through the loop.
		    //
		    bytesCopied = (ULONG)Iosb->Information;

        } else {

		    bytesCopied = validBytes;

        }

        //
        // Abort if an oplock break has been received.
        //

        if (SipAbort(abortEvent)) {
            status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
			ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);
			goto done;
        }

		if (NULL != checksum) {
			SipComputeChecksum(copyIntoAddress,bytesCopied,checksum);
		}

		flushBuffer = mappedBuffer;
		flushSize = viewSize;
		status = ZwFlushVirtualMemory(
					NtCurrentProcess(),
					&flushBuffer,
					&flushSize,
					Iosb);

		ZwUnmapViewOfSection(NtCurrentProcess(),mappedBuffer);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			goto done;
		}

		//
		// Add in the number of bytes that we actually copied into the file.
		//
		byteOffset.QuadPart += bytesCopied;
	}

	done:

	if (sectionHandle != NULL) {
		ZwClose(sectionHandle);
		sectionHandle = NULL;
	}

	return status;
#undef	COPY_AMOUNT
#undef	MM_MAP_ALIGNMENT
}

VOID
SiCopyThreadStart(
	IN PVOID		parameter)
/*++

Routine Description:

	A thread to handle SIS copy on write operations.  Because these operations may
	take a very large amount of time, we have our own thread rather than holding an
	ExWorker thread.  This thread waits for requests for initial or final copies to
	be posted, and then processes them.  The thread uses a global work queue, not
	one per volume.

Arguments:

	parameter - PVOID NULL.

Return Value:

	never returns.
--*/
{
	NTSTATUS 				status;
	PSI_COPY_THREAD_REQUEST	copyRequest;
	HANDLE					copyEventHandle;
	PKEVENT					copyEvent;

    UNREFERENCED_PARAMETER( parameter );
    ASSERT(parameter == NULL);

	status = SipCreateEvent(
				SynchronizationEvent,
				&copyEventHandle,
				&copyEvent);

	if (!NT_SUCCESS(status)) {
		DbgPrint("SipCopyThreadStart: unable to allocate copyevent, 0x%x\n",status);
		return;	// now what??
	}

	while (TRUE) {

		status = KeWaitForSingleObject(CopySemaphore,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);

		copyRequest = (PSI_COPY_THREAD_REQUEST)ExInterlockedRemoveHeadList(CopyList,CopyListLock);
        ASSERT(copyRequest != NULL);	// Else the semaphore isn't working right

        if (copyRequest) {

		    status = SipCompleteCopyWork(copyRequest->scb,copyEventHandle,copyEvent,copyRequest->fromCleanup);

		    ExFreePool(copyRequest);
        }
	}
}

NTSTATUS
SipOpenFileById(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLARGE_INTEGER					linkFileNtfsId,
    IN ACCESS_MASK                      desiredAccess,
    IN ULONG                            shareAccess,
	IN ULONG							createOptions,
	OUT PHANDLE							openedFileHandle)
/*++

Routine Description:

	Open a file by file id and return a handle to it.  Must be called in the
	PsInitialSystemProcess context.

Arguments:

	deviceExtension	- For the device on which this file is to be opened.

	linkFileNtfsId	- A pointer to the file ID of the file to open

    desiredAccess	- Access to request to the file.

    shareAccess		- Sharing mode.

	createOptions	- Options for the open.

	openedFileHandle- The opened handle
	
Return Value:

	the status of the open
--*/
{
	OBJECT_ATTRIBUTES				Obja[1];
	IO_STATUS_BLOCK					Iosb[1];
	UNICODE_STRING					fileNameString;
	CHAR							fileNameBuffer[sizeof(LARGE_INTEGER)];
	NTSTATUS						status;

	fileNameString.MaximumLength = sizeof(LARGE_INTEGER);
	fileNameString.Buffer = (PWCHAR)fileNameBuffer;
	
	RtlCopyMemory(fileNameString.Buffer,linkFileNtfsId,sizeof(*linkFileNtfsId));

	fileNameString.Length = sizeof(LARGE_INTEGER);

	//
	// We don't need to hold GrovelerFileResource here because we're only accessing
	// the handle, and the worst thing that an invalid handle will do here is to 
	// make the create file call fail.  Also, we don't have to worry about malicious
	// messing with the handle since we're in the system process context.
	//

	InitializeObjectAttributes(
		Obja,
		&fileNameString,
		OBJ_CASE_INSENSITIVE,
		deviceExtension->GrovelerFileHandle,
		NULL);

	status = NtCreateFile(
				openedFileHandle,
				desiredAccess,
				Obja,
				Iosb,
				NULL,				// Allocation size
				0,					// file attributes
				shareAccess,
				FILE_OPEN,
				createOptions | 
				FILE_OPEN_BY_FILE_ID,
				NULL,				// EA buffer
				0);					// EA length

#if		DBG
	if (!NT_SUCCESS(status) && STATUS_SHARING_VIOLATION != status) {
		DbgPrint("SIS: SipOpenFileById failed 0x%x\n",status);
	}
#endif	// DBG

	return status;
}

NTSTATUS
SipCompleteCopy(
	IN PSIS_SCB							scb,
	OUT BOOLEAN							fromCleanup)
/*++

Routine Description:

	Post a request to do a final copy on a file.  Does not wait for its
	completion.

Arguments:

	scb			- The scb for the file on which to try the final copy.

	fromCleanup	- TRUE iff this call was made from cleanup rather than from
					close.  Errors on final copies generated from cleanup
					are ignored, ones from close are retried on an exponential
					backoff schedule.
	
Return Value:

	STATUS_SUCCESS
--*/
{
	PSI_COPY_THREAD_REQUEST		copyRequest;

	copyRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof (SI_COPY_THREAD_REQUEST), ' siS');
	if (NULL == copyRequest) {
        //NTRAID#65186-2000/03/10-nealch  Handle out of memory without droping entry

#if DBG
		DbgPrint("SIS: SipCompleteCopy: Unable to allocate copy request for scb 0x%x\n",scb);
        ASSERT(FALSE);
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	ASSERT(copyRequest == (PSI_COPY_THREAD_REQUEST)copyRequest->listEntry);	// This is assumed at the dequeue side

	copyRequest->scb = scb;
	copyRequest->fromCleanup = fromCleanup;

	ExInterlockedInsertTailList(CopyList,copyRequest->listEntry,CopyListLock);
	KeReleaseSemaphore(CopySemaphore,IO_NO_INCREMENT,1,FALSE);

	return STATUS_SUCCESS;
}

//
// A context record used for final copies that have failed and are to be retried later.
//
typedef struct _SIS_RETRY_FINAL_COPY_CONTEXT {
		//
		// The timer DPC that executes to kick off the retry
		//
		KDPC			dpc[1];

		//
		// The timer that's used to start the DPC.
		//
		KTIMER			timer[1];

		//
		// The scb of the file on which to retry the final copy.
		//
		PSIS_SCB		scb;

		//
		// A work queue item to be used to start the actual retry.
		//
		WORK_QUEUE_ITEM	workItem[1];
} SIS_RETRY_FINAL_COPY_CONTEXT, *PSIS_RETRY_FINAL_COPY_CONTEXT;

VOID
SiRetryFinalCopyWork(
	IN PVOID			parameter)
/*++

Routine Description:

	A worker thread routine to retry a final copy that's failed.  We don't really directly
	retry the final copy here, but instead we just drop the reference to the scb that we've
	been holding.  Once all other references are also dropped to this scb, the final copy
	will be re-attempted.

Arguments:

	parameter - a pointer to a SIS_RETRY_FINAL_COPY_CONTEXT.  We free this when we're done.

Return Value:

	void
--*/
{
	PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext = (PSIS_RETRY_FINAL_COPY_CONTEXT)parameter;
	PDEVICE_EXTENSION				deviceExtension;

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ASSERT(NULL != retryContext);

	deviceExtension = retryContext->scb->PerLink->CsFile->DeviceObject->DeviceExtension;
	InterlockedDecrement(&deviceExtension->OutstandingFinalCopyRetries);

	SipDereferenceScb(retryContext->scb,RefsFinalCopyRetry);

	ExFreePool(retryContext);
}

VOID
SiRetryFinalCopyDpc(
	IN PKDPC			dpc,
	IN PVOID			context,
	IN PVOID			systemArg1,
	IN PVOID			systemArg2)
/*++

Routine Description:

	A timer-fired DPC routine that handles retrying a failed final copy.
	This just queues up a work item to do the final copy.

Arguments:

	dpc 		- The DPC that's executing

	context		- a PSIS_RETRY_FINAL_COPY_CONTEXT; see the definition of that structure
					for a description of the fields

	systemArg 1 & 2	- unused DPC parameters

Return Value:

	void
--*/
{
	PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext = (PSIS_RETRY_FINAL_COPY_CONTEXT)context;

    UNREFERENCED_PARAMETER( dpc );
    UNREFERENCED_PARAMETER( systemArg1 );
    UNREFERENCED_PARAMETER( systemArg2 );

	ASSERT(NULL != retryContext);
	ASSERT(retryContext->dpc == dpc);

	ExQueueWorkItem(retryContext->workItem,DelayedWorkQueue);
}


NTSTATUS
SipCompleteCopyWork(
	IN PSIS_SCB						scb,
	IN HANDLE						eventHandle,
	IN PKEVENT						event,
	IN BOOLEAN						fromCleanup)
/*++

Routine Description:

	A worker thread routine that does final copy on a file.  This function
	itself just checks some things (like whether the file's been deleted in the
	interim), calls SipFinalCopy to actually do the final copy, and then deals
	appropriately with errors if there are any.  If this is a close-generated
	call, we retry errors on an expeonential backoff schedule (with a time limit);
	if from cleanup, we ignore them on the theory that a close will eventually come
	along and we'll deal with it then.

	If we get an OPLOCK_BREAK_IN_PROGRESS, then someone else wants to use the file
	and we just stop.

Arguments:

	scb			- The scb on which to do the final copy

	eventHandle	- Handle to an event that we can use exclusively for now

	event		- Pointer to the same event as represented by eventHandle

	fromCleanup	- Whether this call originated in cleanup (TRUE) or close (FALSE)


Return Value:

	status of the final copy operation
--*/
{
	PSIS_PER_LINK					perLink = scb->PerLink;
	PDEVICE_EXTENSION				deviceExtension = perLink->CsFile->DeviceObject->DeviceExtension;
	NTSTATUS						status;
	KIRQL							OldIrql;
	BOOLEAN							wakeupNeeded;
	BOOLEAN							deleted;

	ASSERT(sizeof(scb->PerLink->LinkFileNtfsId) == sizeof(LARGE_INTEGER));

	SIS_MARK_POINT_ULONG(scb);

	//
	// The last reference to the SCB for a copied file has been dropped.
	// If there have been any writes into the file, then fill in any regions
	// that are unwritten from the underlying file.  If there have been no
	// writes into the file (which can happen for a mapped file) then
	// revert it into a reparse point.
	//

	//
	// Check to see whether the file was written into (a file can be
	// "copied" without being dirty if it's ever mapped).  We could probably
	// get away without taking the lock here because we hold the last
	// reference.
	//
	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;
	deleted = (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: SipCompleteCopyWork: scb %p, wakeupNeeded %d, deleted %d\n",scb,wakeupNeeded,deleted);
	}

	ASSERT((0 == scb->referencesByType[RefsFinalCopyRetry]) || fromCleanup);
	ASSERT((1 == scb->referencesByType[RefsFinalCopy]) || fromCleanup);
#endif	// DBG

	SIS_MARK_POINT_ULONG(wakeupNeeded);

	ASSERT((perLink->Flags & 
			(SIS_PER_LINK_FINAL_COPY | 
				SIS_PER_LINK_DIRTY |
				SIS_PER_LINK_FINAL_COPY_DONE)) ==
					(SIS_PER_LINK_DIRTY |
					 SIS_PER_LINK_FINAL_COPY));

	if (deleted) {

        SIS_MARK_POINT();
		//
		// This file was deleted after (possibly) being modified.  Make it look like
		// it's finished its final copy.
		//

		scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
		scb->PerLink->Flags &= ~(	SIS_PER_LINK_FINAL_COPY | 
									SIS_PER_LINK_FINAL_COPY_WAITERS);

		if (wakeupNeeded) {
			KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
		}

		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		SipDereferenceScb(scb, RefsFinalCopy);

		return STATUS_SUCCESS;
	}

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);

#if		DBG
	if (BJBDebug & 0x200000) {
		DbgPrint("SIS: SipCompleteCopyWork: skipping final copy because of set debug bit.\n");
		status = STATUS_SUCCESS;
	} else
#endif	// DBG

    SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	status = SipFinalCopy(
				deviceExtension,
				&perLink->LinkFileNtfsId,
				scb,
				eventHandle,
				event);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(scb);
		goto done;
	}

done:
				
	//
	// Set the flag indicating that the final copy is finished; this will result in
	// the dereference of the SCB actually deallocating it rather than just calling
	// us again.
	//

	KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);

	ASSERT(scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY);
	ASSERT(perLink->COWingThread == NULL);

	wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;

	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
		//
		// The final copy didn't complete because of an oplock break (ie,. someone else wanted
		// to use the file).  We'll leave it a SIS file for now and allow others to use it; we'll
		// complete the final copy later.
		//
        SIS_MARK_POINT_ULONG(status);

	} else if (NT_SUCCESS(status)) {

		scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
        SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	} else if (!fromCleanup) {

		//
		// The final copy failed for some reason other than an oplock break.
		// If we haven't retried too many times, schedule a retry for later.
		// We use an exponential backoff on the retries so they don't do
		// too much work in case it's a persistent error.  If the copy failed
		// with STATUS_INVALID_PARAMETER, it's probably becauce the file is
		// gone, so don't bother to try to retry in that case.
		//
		// The way that the retry works is that we just take a reference to the
		// scb and hold it until the timer expires.  We never go into final copy
		// when there are outstanding references, so this will prevent final
		// copy from happening until then.
		//
		// If this final copy was generated from cleanup rather than from close,
		// we don't do the error retry, but rather just ignore it.  Most likely it
		// was a sharing violation opening the file because another user opened it.
		// In any case, final copy will be rerun on close, so we needn't do anything here.
		//

		scb->ConsecutiveFailedFinalCopies++;
        SIS_MARK_POINT_ULONG(scb->PerLink->Flags);
        SIS_MARK_POINT_ULONG(scb->ConsecutiveFailedFinalCopies);

		if ((deviceExtension->OutstandingFinalCopyRetries < 130)
			&& (scb->ConsecutiveFailedFinalCopies <= (13 - (deviceExtension->OutstandingFinalCopyRetries / 10)))
			&& (STATUS_INVALID_PARAMETER != status)) {

			PSIS_RETRY_FINAL_COPY_CONTEXT	retryContext;
			LARGE_INTEGER	dueTime;

			retryContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_RETRY_FINAL_COPY_CONTEXT), ' siS');
			

			if (NULL == retryContext) {
				//
				// Too bad.  Treat this like an unrecoverable failure and get out of the way.
				//
				SIS_MARK_POINT_ULONG(scb);

				goto doneCheckingRetry;
			}

			SipReferenceScb(scb,RefsFinalCopyRetry);

			InterlockedIncrement(&deviceExtension->OutstandingFinalCopyRetries);

			KeInitializeTimer(retryContext->timer);
			KeInitializeDpc(retryContext->dpc, SiRetryFinalCopyDpc, retryContext);
			ExInitializeWorkItem(retryContext->workItem, SiRetryFinalCopyWork, retryContext);
			retryContext->scb = scb;

			//
			// We sleep for 2 ^ RetryCount seconds before retrying (ie., exponential backoff).
			//
			dueTime.QuadPart = -10 * 1000 * 1000 * (1 << scb->ConsecutiveFailedFinalCopies);

			KeSetTimerEx(
				retryContext->timer,
				dueTime,
				0,				// period (ie., non-recurring)
				retryContext->dpc);
				
		} else {
			//
			// We've retried too many times, just give up on the final copy.
			//
			SIS_MARK_POINT_ULONG(scb);

			scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
		}
	}

doneCheckingRetry:

	scb->PerLink->Flags &= ~(	SIS_PER_LINK_FINAL_COPY | 
								SIS_PER_LINK_FINAL_COPY_WAITERS);

    SIS_MARK_POINT_ULONG(scb->PerLink->Flags);

	if (wakeupNeeded) {
		KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
	}

	KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

	SipDereferenceScb(scb, RefsFinalCopy);

	return status;
}

NTSTATUS
SipFinalCopy(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLARGE_INTEGER					linkFileNtfsId,
	IN OUT PSIS_SCB						scb,
	IN HANDLE							eventHandle,
	IN PKEVENT							event)

/*++

Routine Description:

	Perform the final copy from the copied file area into a file
	that has been copied-on-write.  

Arguments:

	deviceExtension - the device extension for the volume on which
		we're working.

	linkFileNtfsId  - the file id (as in FILE_OPEN_BY_FILE_ID) for
		the final file into which we're to copy

	scb - the scb for the file (NB: should really be a per-link)

	copyEventHandle - A handle to an event used for internal synchronization

	copyEvent - a PKEVENT for the event reprsented by copyEventHandle

Return Value:

	Returns the status of the copy.
--*/
{
	HANDLE							linkFileHandle = NULL;
	NTSTATUS						status;
	NTSTATUS						queryAllocatedStatus;
	NTSTATUS						failureStatus = STATUS_SUCCESS;
	PSIS_PER_LINK					perLink = scb->PerLink;
	HANDLE							underlyingFileHandle = perLink->CsFile->UnderlyingFileHandle;
	LONGLONG						fileOffset;
    PREPARSE_DATA_BUFFER    		ReparseBufferHeader = NULL;
    UCHAR              				ReparseBuffer[SIS_REPARSE_DATA_SIZE];
	PFILE_OBJECT					fileObject = NULL;
	BOOLEAN							prepareWorked;
	KIRQL							OldIrql;
	HANDLE							oplockEventHandle = NULL;
	PKEVENT							oplockEvent = NULL;
	IO_STATUS_BLOCK					oplockIosb[1];
	BOOLEAN							deleteReparsePoint;
	BOOLEAN							foundRange;
	SIS_RANGE_STATE					rangeState;
	LONGLONG						rangeLength;
#if		DBG
	BOOLEAN							deletedReparsePoint = FALSE;
#endif	// DBG
#define	OUT_ARB_COUNT	10
	FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
	FILE_ALLOCATED_RANGE_BUFFER		outArb[OUT_ARB_COUNT];
	ULONG							returnedLength;
	ULONG							i;
	LARGE_INTEGER					zero;

	SipAcquireScb(scb);
	ASSERT(perLink->COWingThread == NULL);
	perLink->COWingThread = PsGetCurrentThread();
	SipReleaseScb(scb);

	status = SipCreateEvent(
				NotificationEvent,
				&oplockEventHandle,
				&oplockEvent);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

#if		DBG
		DbgPrint("SIS: SipFinalCopy: unable to create event, 0x%x\n",status);
#endif	// DBG

		goto done;
	}

	status = SipOpenFileById(
				deviceExtension,
				linkFileNtfsId,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                0,						// createOptions
				&linkFileHandle);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		if (STATUS_SHARING_VIOLATION != status) {
			DbgPrint("SIS: SipFinalCopy failed open, 0x%x\n", status);
		}
#endif	// DBG
		goto done;
	}

	//
	// Place a batch oplock on the file so that if someone tries to open it we'll
	// get a chance to finish/stop our copy without having them fail the open, but
	// rather just wait for us.
	//

	status = NtFsControlFile(
				linkFileHandle,
				oplockEventHandle,
				NULL,					// APC routine
				NULL,					// APC context
				oplockIosb,
				FSCTL_REQUEST_BATCH_OPLOCK,
				NULL,					// input buffer
				0,						// i.b. length
				NULL,					// output buffer
				0);						// output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (STATUS_OPLOCK_NOT_GRANTED != status) {
			DbgPrint("SIS: SipFinalCopy: request batch oplock failed, 0x%x\n",status);
		}
#endif	// DBG

		if (STATUS_OPLOCK_NOT_GRANTED == status) {
			//
			// Treat this as an oplock break, which will cause us to retry later.
			//
			status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		}

		goto done;
	}

	ASSERT(STATUS_PENDING == status);

	status = ObReferenceObjectByHandle(
				linkFileHandle,
				FILE_WRITE_DATA,
				*IoFileObjectType,
				KernelMode,
				&fileObject,
				NULL);								// Handle information

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SIS: SipFinalCopy failed ObReferenceObjectByHandle, 0x%x\n",status);
#endif	// DBG
		goto done;
	}

#if		DBG
	if (BJBDebug & 0x01000000) {
		DbgPrint("SIS: SipFinalCopy: failing request because of set BJBDebug bit\n");
		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
#endif	// DBG

	//
	// See if the file has any user mapped sections, in which case we can't do a final copy yet.
	// We'll probably have to wait for the reference count to go to 0.  We'll fail with oplock
	// break in progress, which will cause us to not set up a failure retry.
	//
	zero.QuadPart = 0;
	if ((NULL != fileObject->SectionObjectPointer) && 
		!MmCanFileBeTruncated(fileObject->SectionObjectPointer, &zero)) {
		SIS_MARK_POINT_ULONG(fileObject->FsContext);

		status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		goto done;
	}

	//
	// Flush the file.  We need to do this because we could have dirty data that came in through a mapped
	// file write, and we wouldn't notice that it's dirty yet.
	//
	status = SipFlushBuffersFile(
				fileObject,
				deviceExtension->DeviceObject);

	ASSERT(STATUS_PENDING != status);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// Cruise through the file and find all of the allocated ranges.  Fill in any clean portions
	// of those allocated ranges.  We do this regardless of whether we're doing a "partial" final
	// copy, because these copies are less likely to fail with a "disk full" error.  Attempt the copyout
	// to all clean, allocated regions regardless of errors.
	//
	inArb->FileOffset.QuadPart = 0;
	inArb->Length.QuadPart = MAXLONGLONG;

	for (;;) {

		//
		// Query the allocated ranges for this file.
		//

		queryAllocatedStatus = SipFsControlFile(
					fileObject,
					deviceExtension->DeviceObject,
					FSCTL_QUERY_ALLOCATED_RANGES,
					inArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					outArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER) * OUT_ARB_COUNT,
					&returnedLength);

		//
		// Run through all of the returned allocated ranges and find any clean regions within them.
		//
		ASSERT((returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0) && 
			   (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) <= OUT_ARB_COUNT));

		//
		// If the query allocated ranges failed for some other reason that having too much to write
		// into the buffer we provided, then pretend that the rest of the file is allocated
		// and fill it all in.
		//
		if (!NT_SUCCESS(queryAllocatedStatus) && (STATUS_BUFFER_OVERFLOW != queryAllocatedStatus)) {

			returnedLength = sizeof(FILE_ALLOCATED_RANGE_BUFFER);

			outArb->FileOffset.QuadPart = inArb->FileOffset.QuadPart;
			outArb->Length.QuadPart = scb->SizeBackedByUnderlyingFile - outArb->FileOffset.QuadPart;

			ASSERT(outArb->Length.QuadPart >= 0);
		}

		for (i = 0; i < returnedLength/sizeof(FILE_ALLOCATED_RANGE_BUFFER); i++) {
			//
			// Assert that the allocated ranges are in order; if this isn't true the code will still work, but it
			// will query the same range repetedly.
			//
			ASSERT(i == 0 || outArb[i].FileOffset.QuadPart > outArb[i-1].FileOffset.QuadPart);

			//
			// Figure out if there's anything clean in the allocated range, and if so do a copy out to it.
			//

			fileOffset = outArb[i].FileOffset.QuadPart;

			while (fileOffset < outArb[i].FileOffset.QuadPart + outArb[i].Length.QuadPart) {

				if (fileOffset >= scb->SizeBackedByUnderlyingFile) {
					goto CheckedAllRanges;
				}

				SipAcquireScb(scb);

				foundRange = SipGetRangeEntry(
								deviceExtension,
								scb,
								fileOffset,
								&rangeLength,
								&rangeState);

				if (!foundRange) {
					//
					// This and everything up to SizeBackedByUnderlyingFile are clean.
					//
					rangeLength = outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart);
					rangeState = Untouched;
				} else {
					//
					// If this range extends beyond the end of the allocated region, truncate it.
					//
					if (rangeLength > outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart)) {
						rangeLength = outArb[i].Length.QuadPart - (fileOffset - outArb[i].FileOffset.QuadPart);
					}
				}

				ASSERT(fileOffset + rangeLength <= outArb[i].FileOffset.QuadPart + outArb[i].Length.QuadPart);

				//
				// Don't let this extend beyond sizeBacked.
				//
				if (fileOffset + rangeLength > scb->SizeBackedByUnderlyingFile) {
					rangeLength = scb->SizeBackedByUnderlyingFile - fileOffset;
				}

				SipReleaseScb(scb);

				if (rangeState == Untouched || rangeState == Faulted) {
					//
					// We need to copy into this range.  Do it now.
					//

					SIS_MARK_POINT_ULONG(fileOffset);

					status = SipBltRange(
								deviceExtension,
								underlyingFileHandle,
								linkFileHandle,
								fileOffset,
								rangeLength,
								eventHandle,
								event,
#if		INTERRUPTABLE_FINAL_COPY
								oplockEvent,
#else	// INTERRUPTABLE_FINAL_COPY
								NULL,
#endif	// INTERRUPTABLE_FINAL_COPY
								NULL					// checksum
		                        );

					if (!NT_SUCCESS(status)) {
						SIS_MARK_POINT_ULONG(status);
#if		DBG
						if (STATUS_FILE_LOCK_CONFLICT != status) {
							DbgPrint("SIS: SipFinalCopy failed blt, 0x%x\n", status);
						}
#endif	// DBG
						failureStatus = status;
					} else if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
						SIS_MARK_POINT_ULONG(scb);
						goto done;
					}
					
				}

				//
				// update fileOffset and continue checking within this outArb entry.
				//
				fileOffset += rangeLength;

			}	// while loop of SIS ranges within the NTFS allocated range

		} // for loop of outArb entries

		//
		// If this isn't the last iteration, update the inArb.
		//
		if (STATUS_BUFFER_OVERFLOW == queryAllocatedStatus) {
			//
			// Assert that we're making progress.
			//
			ASSERT((outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart >= inArb->FileOffset.QuadPart) && (outArb[OUT_ARB_COUNT-1].Length.QuadPart > 0));

			//
			// Move up our input range.
			//
			inArb->FileOffset.QuadPart = outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart + outArb[OUT_ARB_COUNT-1].Length.QuadPart;
			inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;
				
		} else {
			break;
		}
	} // for loop of calls to QueryAllocatedRanges

CheckedAllRanges:

#if		ENABLE_PARTIAL_FINAL_COPY

	//
	// If any of the copies failed, then just punt the whole thing.
	//
	if (!NT_SUCCESS(failureStatus)) {
		SIS_MARK_POINT_ULONG(failureStatus);

		status = failureStatus;
		goto done;
	}

	//
	// Figue out if we want to delete the reparse point.  We do this if and only if the file is dirty all the way from 0
	// to SizeBackedByUnderlyingFile.  Note that the SipBltFile call above actually will set the ranges dirty because it's
	// just a normal (mapped) write that goes through SiWrite.
	//

	fileOffset = 0;

	SipAcquireScb(scb);

	rangeState = SipGetRangeDirty(
					deviceExtension,
					scb,
					(PLARGE_INTEGER)&fileOffset,	// we rely on LARGE_INTEGER and LONGLONG being the same thing
					scb->SizeBackedByUnderlyingFile,
					FALSE);

	if (Dirty == rangeState) {
		deleteReparsePoint = TRUE;		
	} else {
		deleteReparsePoint = FALSE;
	}

	SipReleaseScb(scb);

#undef	OUT_ARB_COUNT	
#else	// ENABLE_PARTIAL_FINAL_COPY

	//
	// We don't care if any of the copies in the allocated range pass failed, because
	// the following code is sufficient for all cases.
	//
	SIS_MARK_POINT_ULONG(failureStatus);

	//
	// Look through all of the ranges of the file up to the
	// maximum possible size backed by the underlying file,
	// and copy any ranges that aren't written from the underlying
	// file to the copied file.
	//
	fileOffset = 0;
	while (fileOffset < scb->SizeBackedByUnderlyingFile) {
		BOOLEAN				waiters;

#if		INTERRUPTABLE_FINAL_COPY
		if (fileOffset + 0x10000 < scb->SizeBackedByUnderlyingFile) {
			//
			// We've got a decent amount of the file left to cover.  Check to
			// see if we should abort because someone wants the file.
			//
			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			waiters = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) ? TRUE : FALSE;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (waiters) {
				//
				// Someone'e waiting for the file, and we're more than 64K from the end, so
				// abort the final copy now.
				//
				SIS_MARK_POINT_ULONG(scb);
				status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
				goto done;
			}
		}
#endif	// INTERRUPTABLE_FINAL_COPY

		SipAcquireScb(scb);

		foundRange = SipGetRangeEntry(
						deviceExtension,
						scb,
						fileOffset,
						&rangeLength,
						&rangeState);

		if (!foundRange) {
			//
			// The range was never filled in in the MCB, and hence everything
			// from here to SizeBackedByUnderlyingFile is untouched.  Munge
			// the locals to look like that.
			// 
			rangeLength = scb->SizeBackedByUnderlyingFile - fileOffset;
			rangeState = Untouched;
		} else if (fileOffset + rangeLength > scb->SizeBackedByUnderlyingFile) {
			//
			// This range extends beyond sizeBacked, so truncate it so that it
			// just meets the size.
			//
			rangeLength = (ULONG)(scb->SizeBackedByUnderlyingFile - fileOffset);
		}


		ASSERT(rangeLength > 0);
		ASSERT(fileOffset + rangeLength <= scb->SizeBackedByUnderlyingFile);

		SipReleaseScb(scb);

		if (rangeState == Untouched || rangeState == Faulted) {
			//
			// The bytes in this range have never been written into the backing file.
			// write them in now.
			//

			SIS_MARK_POINT_ULONG(fileOffset);

			status = SipBltRange(
						deviceExtension,
						underlyingFileHandle,
						linkFileHandle,
						fileOffset,
						rangeLength,
						eventHandle,
						event,
#if		INTERRUPTABLE_FINAL_COPY
						oplockEvent,
#else	// INTERRUPTABLE_FINAL_COPY
						NULL,
#endif	// INTERRUPTABLE_FINAL_COPY
						NULL					// checksum
                        );
 
			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
#if		DBG
				if (STATUS_FILE_LOCK_CONFLICT != status) {
					DbgPrint("SIS: SipFinalCopy failed blt, 0x%x\n", status);
				}
#endif	// DBG
				goto done;
			} else if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
				SIS_MARK_POINT_ULONG(scb);
				goto done;
			}
		} else {
			//
			// The range is written, meaning that the correct bytes are in the
			// copied file already, and we don't need to do a thing.
			//
			ASSERT(rangeState == Written);
		}

		//
		// Update our pointer to show we've covered this range, and move on.
		//
		fileOffset += rangeLength;
	}

	deleteReparsePoint = TRUE;	// the full final copy always deletes the reparse point
#endif	// ENABLE_PARTIAL_FINAL_COPY

	if (deleteReparsePoint) {

		//
		// Prepare to change the CS file reference count.  We need to do this
		// before we can delete the reparse point.
		//
		status = SipPrepareCSRefcountChange(
					perLink->CsFile,
					&perLink->Index,
					linkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			//
			// The prepare failed.  We'll just delete the reparse point and leak the reference.
			//
			SIS_MARK_POINT_ULONG(status);

#if		DBG
			DbgPrint("SIS: SipFinalCopy: prepare failed 0x%x\n",status);
#endif	// DBG

			prepareWorked = FALSE;
		} else {
			prepareWorked = TRUE;
		}

		//
		// Now, delete the reparse point.
		//

	    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    	ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SIS;
	    ReparseBufferHeader->ReparseDataLength = 0;
    	ReparseBufferHeader->Reserved = 0xcabd;	// ???

		SIS_MARK_POINT_ULONG(scb);

		status = SipFsControlFile(
					fileObject,
					deviceExtension->DeviceObject,
					FSCTL_DELETE_REPARSE_POINT,
					ReparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
					NULL,									// output buffer
					0,										// output buffer length
					NULL);									// returned output buffer length

		if (!NT_SUCCESS(status)) {

			SIS_MARK_POINT_ULONG(status);

			if (prepareWorked) {
				SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					FALSE,
					FALSE);
			}

			goto done;
		}
		ASSERT(status != STATUS_PENDING);

#if		DBG
		deletedReparsePoint = TRUE;
#endif	// DBG

		if (prepareWorked) {
			SIS_MARK_POINT_ULONG(perLink->CsFile);

			status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					TRUE,
					FALSE);

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
#if		DBG
				DbgPrint("SIS: SipFinalCopy: complete failed 0x%x\n",status);
#endif	// DBG
			}
		}
	}	// if delete reparse point

done:

	ASSERT(deletedReparsePoint || !NT_SUCCESS(status) || (STATUS_OPLOCK_BREAK_IN_PROGRESS == status));

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
#if		DBG
		fileObject = NULL;
#endif	// DBG
	}

	if (NULL != linkFileHandle) {
		SIS_MARK_POINT_ULONG(scb);
		NtClose(linkFileHandle);
		SIS_MARK_POINT_ULONG(scb);
	}

	if (NULL != oplockEvent) {
		ObDereferenceObject(oplockEvent);
#if		DBG
		oplockEvent = NULL;
#endif	// DBG
	}

	if (NULL != oplockEventHandle) {
		NtClose(oplockEventHandle);
	}

	SipAcquireScb(scb);
	ASSERT(perLink->COWingThread == PsGetCurrentThread());
	perLink->COWingThread = NULL;
	SipReleaseScb(scb);

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\refcount.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    refcount.c

Abstract:

	Common store file refcount support for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipProcessRefcountUpdateLogRecord)
#if		ENABLE_LOGGING
#pragma alloc_text(PAGE, SipRemoveRefBecauseOfLog)
#pragma alloc_text(PAGE, SipProcessRefcountLogDeleteRecord)
#pragma alloc_text(PAGE, SipAssureBackpointer)
#endif	// ENABLE_LOGGING
#endif	// ALLOC_PRAGMA
//
// A request to delete a common store file.
//
typedef struct _SI_DELETE_CS_FILE_REQUEST {
	WORK_QUEUE_ITEM			workQueueItem[1];
	PSIS_CS_FILE			CSFile;
	NTSTATUS				Status;
	KEVENT					event[1];
} SI_DELETE_CS_FILE_REQUEST, *PSI_DELETE_CS_FILE_REQUEST;

NTSTATUS
SipDeleteCSFile(
	PSIS_CS_FILE					CSFile)
/*++

Routine Description:

	Delete a common store file and close the handles/file objects we have to
	it.  Must be called in the PsInitialSystemProcess context (ie. on a worker
	thread).

Arguments:

	CSFile - the common store file to delete

Return Value:

	Returns the status of call.

--*/
{
	KIRQL							OldIrql;
	HANDLE							handleForDeleting = NULL;
	FILE_DISPOSITION_INFORMATION 	dispositionInformation[1];
	IO_STATUS_BLOCK					Iosb[1];
	NTSTATUS						status;

	SipAcquireUFO(CSFile/*,TRUE*/);

	SIS_MARK_POINT_ULONG(CSFile);

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
	CSFile->Flags |= CSFILE_FLAG_DELETED;
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

	status = SipOpenCSFileWork(
					CSFile, 
					TRUE, 						// openByName
					FALSE, 						// volCheck
					TRUE,						// openForDelete
					&handleForDeleting);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	dispositionInformation->DeleteFile = TRUE;
	status = NtSetInformationFile(	
				handleForDeleting,
				Iosb,
				dispositionInformation,
				sizeof(FILE_DISPOSITION_INFORMATION),
				FileDispositionInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// The file's gone now, so close all handles and file objects
	// that refer to it, except for the UndelyingFileObject.  We
	// keep that one around to avoid races with threads that have
	// already looked at it but haven't yet finished using it.
	//

	if (NULL != CSFile->UnderlyingFileHandle) {
		NtClose(CSFile->UnderlyingFileHandle);
		CSFile->UnderlyingFileHandle = NULL;
	}

	if (NULL != CSFile->BackpointerStreamFileObject) {
		ObDereferenceObject(CSFile->BackpointerStreamFileObject);
		CSFile->BackpointerStreamFileObject = NULL;
	}

	if (NULL != CSFile->BackpointerStreamHandle) {
		NtClose(CSFile->BackpointerStreamHandle);
		CSFile->BackpointerStreamHandle = NULL;
	}

done:

	if (NULL != handleForDeleting) {
		NtClose(handleForDeleting);
	}

	SipReleaseUFO(CSFile);

	return status;
}

VOID
SipDeleteCSFileWork(
	PVOID								Parameter)
/*++

Routine Description:

	A wrapper function for SipDeleteCSFile that extract the CSFile pointer from
	a request, calls SipDeleteCSFile, sticks the status in the request and sets
	the appropriate event.

Arguments:

	Parameter - a PSI_DELETE_CS_FILE_REQUEST

Return Value:

	void

--*/
{
	PSI_DELETE_CS_FILE_REQUEST		deleteRequest = Parameter;
	PSIS_CS_FILE					CSFile = deleteRequest->CSFile;

    deleteRequest->Status = SipDeleteCSFile(CSFile);

	KeSetEvent(deleteRequest->event, IO_NO_INCREMENT, FALSE);

	return;
}

NTSTATUS
SipPrepareCSRefcountChange(
	IN PSIS_CS_FILE						CSFile,
	IN OUT PLINK_INDEX					LinkIndex,
	IN PLARGE_INTEGER					LinkFileNtfsId,
	IN ULONG							UpdateType)
/*++

Routine Description:

	The first half of a prepare/commit pair for updating the refcount on a common
	store file.  This function must be called (and complete successfully) before
	we can add/delete the reparse point for a given per-link.

	If we're adding a reference, this routine will allocate a new link index
	and return it in the LinkIndex field.

	This function takes the backpointer resource for the given common store file
	exclusively, effectively serializing all updates to a particular common store
	file.

Arguments:

	CSFile - the common store file to which we're going to add/delete a reference

	LinkIndex - a pointer to the link index.  This is an IN parameter if
		increment is FALSE, an OUT parameter otherwise.
	
	LinkFileNtfsId - a pointer to the NTFS file id for the link file.  

	UpdateType - is this a create, delete or overwrite?

Return Value:

	Returns the status of call.  A successful return means that the appropriate
	log record has been committed to disk and the link index allocated if
	appropriate.

--*/
{
	NTSTATUS					status;
	SIS_LOG_REFCOUNT_UPDATE		logRecord[1];

	ASSERT((SIS_REFCOUNT_UPDATE_LINK_DELETED == UpdateType)
			|| (SIS_REFCOUNT_UPDATE_LINK_CREATED == UpdateType)
			|| (SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN == UpdateType));

	SipAcquireBackpointerResource(CSFile, TRUE, TRUE);

	if (SIS_REFCOUNT_UPDATE_LINK_CREATED == UpdateType) {
		PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;

		status = SipAllocateIndex(deviceExtension,LinkIndex);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			SipReleaseBackpointerResource(CSFile);

			return status;
		}
	}

	//
	// Log the update.
	//

	logRecord->UpdateType = UpdateType;
	logRecord->LinkFileNtfsId = *LinkFileNtfsId;
	logRecord->LinkIndex = *LinkIndex;
	logRecord->CSid = CSFile->CSid;

	status = SipMakeLogEntry(
				CSFile->DeviceObject->DeviceExtension,
				SIS_LOG_TYPE_REFCOUNT_UPDATE,
				sizeof(SIS_LOG_REFCOUNT_UPDATE),
				logRecord);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		SipReleaseBackpointerResource(CSFile);

		return status;
	}

	ASSERT(STATUS_PENDING != status);

	return STATUS_SUCCESS;
}


NTSTATUS
SipCompleteCSRefcountChangeForThread(
	IN OUT PSIS_PER_LINK				PerLink,
	IN PLINK_INDEX						LinkIndex,
	IN PSIS_CS_FILE						CSFile,
    IN BOOLEAN							Success,
	IN BOOLEAN							Increment,
	IN ERESOURCE_THREAD					thread)
/*++

Routine Description:

	The second half of a prepare/commit pair for updating the refcount on a common
	store file.  This function is called when the resolution of the action proposed
	in a prepare is known.  If the action worked (indicated by setting Success to
	TRUE), this function will appropriately update the backpointer stream for the
	affected common store file.

	This function releases the backpointer resource for the common store file.
	

Arguments:

	PerLink		- the per-link for the added/deleted link.  Only required if Success is
					TRUE.

    LinkIndex   - the index of the added/deleted link.  Only required if Success is TRUE.

	CSFile		- the common store file we're updating.

	Success		- did the update work

	Increment	- was this a create (TRUE) or delete (FALSE) operation?

	thread		- the ERESOURCE_THREAD on which the prepare was called

Return Value:

	Returns the status of call.  

--*/
{
	NTSTATUS					status;
	BOOLEAN						referencesRemain;
	SI_DELETE_CS_FILE_REQUEST	deleteRequest[1];
	KIRQL						OldIrql;
	BOOLEAN						deleteCSFile = FALSE;

	SIS_MARK_POINT_ULONG(PerLink);
	SIS_MARK_POINT_ULONG(CSFile);
	SIS_MARK_POINT_ULONG((Success << 1) | Increment);


	//ASSERT(NULL == PerLink || (PerLink->CsFile == CSFile));	// SipMergeFiles associates a PerLink with a different CSFile
	ASSERT((NULL != LinkIndex) || !Success);
	ASSERT((NULL != PerLink) || !Success);

	if (Success) {
		if (Increment) {
			status = SipAddBackpointer(CSFile,LinkIndex,&PerLink->LinkFileNtfsId);
			if (NT_SUCCESS(status)) {
				KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
				CSFile->Flags &= ~CSFILE_NEVER_HAD_A_REFERENCE;
				KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
			}
		} else {
			status = SipRemoveBackpointer(CSFile,LinkIndex,&PerLink->LinkFileNtfsId,&referencesRemain);

			if (NT_SUCCESS(status)) {

				//
				// We've blasted the backpointer successfully, mark the file as deleted.
				//

				KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
				ASSERT(!(PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE));
				PerLink->Flags |= SIS_PER_LINK_BACKPOINTER_GONE;
				KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

				SIS_MARK_POINT_ULONG(referencesRemain);

				//
				// If this was the last reference to the common store file, delete it.  We need to
				// post to do this because we need a new handle in order to properly call delete.
				//

				if (!referencesRemain) {
					deleteCSFile = TRUE;
				}
			} else {
				SIS_MARK_POINT_ULONG(status);
			}
		}
	} else {
		if (Increment) {
			//
			// This is a failed increment.  See if the common store file never had a reference,
			// in which case we delete it.
			//
			KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
			if (CSFile->Flags & CSFILE_NEVER_HAD_A_REFERENCE) {
				deleteCSFile = TRUE;
			}
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
		}
		status = STATUS_SUCCESS;
	}

	if (deleteCSFile) {
		//
		// We need to post work to PsInitialSystemProcess in order
		// to delete the common store file.
		//

		deleteRequest->CSFile = CSFile;
		KeInitializeEvent(deleteRequest->event, NotificationEvent, FALSE);

		ExInitializeWorkItem(deleteRequest->workQueueItem, SipDeleteCSFileWork, deleteRequest);
		ExQueueWorkItem(deleteRequest->workQueueItem, CriticalWorkQueue);

		status = KeWaitForSingleObject(deleteRequest->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);
	}

	SipReleaseBackpointerResourceForThread(CSFile,thread);

	return status;
}



NTSTATUS
SipCompleteCSRefcountChange(
	IN OUT PSIS_PER_LINK				PerLink,
    IN PLINK_INDEX						LinkIndex,
	IN PSIS_CS_FILE						CSFile,
	IN BOOLEAN							Success,
	IN BOOLEAN							Increment)
/*++

Routine Description:

	Wrapper for SipCompleteCSRefcountChangeForThread that fills in the current thread.
	See SipCompleteCSRefcountChangeForThread for comments.
	

Arguments:

	See SipCompleteCSRefcountChangeForThread.

Return Value:

	Returns the status of call.

--*/
{
	return SipCompleteCSRefcountChangeForThread(
			PerLink,
            LinkIndex,
			CSFile,
			Success,
			Increment,
			ExGetCurrentResourceThread());
}


#if		DBG
//
// Instrumentation
//

ULONG	BPCacheHits = 0;
ULONG	BPPageHits = 0;
ULONG	BPCacheMisses = 0;
ULONG	BPLookupSteps = 0;
ULONG	BPLookupReads = 0;
ULONG	BPDeleteAttempts = 0;
ULONG	BPDeleteReads = 0;
ULONG	BPDeleteTruncations = 0;
#endif	// DBG

NTSTATUS
SiDeleteAndSetCompletion(
	IN PDEVICE_OBJECT			DeviceObject,
	IN PIRP						Irp,
	IN PVOID					Context)
/*++

Routine Description:

	An IO completion routine for making asyncronous IO calls synchronous.
	Takes an event pointer as its parameter, sets the event, frees
	the irp (and its MDL) and terminates completion processing by returning
	STATUS_MORE_PROCESSING_REQUIRED.

Arguments:

	DeviceObject - ignored

	Irp - the irp that's being completed

	Context - pointer to the event to set

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

	
--*/
{
	PKEVENT		event = (PKEVENT)Context;
	PMDL		mdl, nextMdl;

    UNREFERENCED_PARAMETER( DeviceObject );
	ASSERT(NULL != Irp->UserIosb);

	*Irp->UserIosb = Irp->IoStatus;

	mdl = Irp->MdlAddress;
	while (NULL != mdl) {
		nextMdl = mdl->Next;
		MmUnlockPages(mdl);
		IoFreeMdl( mdl);
		mdl = nextMdl;
	}

	ASSERT(NULL == Irp->Tail.Overlay.AuxiliaryBuffer);	// else we'd have to free it.

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;

	
}

NTSTATUS
SipCheckBackpointer(
	IN PSIS_PER_LINK			PerLink,
    IN BOOLEAN                  Exclusive,
	OUT PBOOLEAN				foundMatch		OPTIONAL)
/*++

Routine Description:

	Check to be sure that there is a backpointer for this link index, and that
	the backpointer has the right file id.  If there isn't, initiate a volume check.

	Caller must hold the BackpointerResource (either shared or exclusive will do),
	this routine will not release it.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	PerLink - the perLink whose backpointer we want to check

	foundMatch - out boolean set to whether we found a match

Return Value:

	status of the check

	
--*/
{
	ULONG					i;
	ULONG					x, l, r;
	PSIS_BACKPOINTER		sector = NULL;
	PCHAR					page = NULL;
	PSIS_BACKPOINTER		thisEntry;
	ULONG					currentSectorMinEntry = MAXULONG;
	ULONG					currentPageMinEntry = MAXULONG;
	ULONG					sectorsPerPage;
	PIRP					irp;
	KEVENT					event[1];
	PSIS_CS_FILE			CSFile = PerLink->CsFile;
	PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;
	LARGE_INTEGER			fileOffset;
	IO_STATUS_BLOCK			Iosb[1];
	KIRQL					OldIrql;
	PIO_STACK_LOCATION		irpSp;
	BOOLEAN					matched = FALSE;
	NTSTATUS				status;
	ULONG					sectorsReadIntoPage = 0;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	sectorsPerPage = PAGE_SIZE / deviceExtension->FilesystemVolumeSectorSize;

	//
	// First, figure out if we've already verified the backpointer for
	// this per link.  If so, then we're done.  Note that more than
	// one thread may verify the same backpointer at the same time, which is OK.
	//
	KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
	if (PerLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) {
		KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

        matched = TRUE;
		status = STATUS_SUCCESS;
        goto done;
	}
	KeReleaseSpinLock(PerLink->SpinLock, OldIrql);

	status = SipAssureCSFileOpen(PerLink->CsFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	//
	// Now, check the cache.
	//

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);

	for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
		if (CSFile->BackpointerCache[i].LinkFileIndex.QuadPart == PerLink->Index.QuadPart) {
			if (CSFile->BackpointerCache[i].LinkFileNtfsId.QuadPart == PerLink->LinkFileNtfsId.QuadPart) {
				//
				// We have a match.
				//
				status = STATUS_SUCCESS;

				matched = TRUE;

                ASSERT(CSFile->BackpointerCache[i].LinkFileIndex.Check);
#if		DBG
				InterlockedIncrement(&BPCacheHits);
#endif	// DBG

				KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
				goto done;
			}
			//
			// Otherwise we have an Index match without a NtfsId match.  Initiate volume check.
			//
			SIS_MARK_POINT_ULONG(PerLink->Index.LowPart);
			SIS_MARK_POINT_ULONG(PerLink->LinkFileNtfsId.LowPart);
			SIS_MARK_POINT_ULONG(CSFile->BackpointerCache[i].LinkFileNtfsId.LowPart);
			status = STATUS_SUCCESS;
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

			if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
				SipCheckVolume(deviceExtension);
			}

			goto done;
		}
	}
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

#if		DBG
	InterlockedIncrement(&BPCacheMisses);
#endif	// DBG

	page = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, ' siS');
	if (NULL == page) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent,FALSE);

	//
	// It didn't hit in the cache.  Search the backpointer index in the CS file.  Use
	// a standard binary search.
	//

    if (0 == CSFile->BPStreamEntries) {
        goto NoMatch;
    }

    l = SIS_BACKPOINTER_RESERVED_ENTRIES;
    r = CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES - 1;

	do {
		ASSERT(l <= r);

		x = (l + r) / 2;

		ASSERT(x >= l);
		ASSERT(x <= r);

#if		DBG
		InterlockedIncrement(&BPLookupSteps);
#endif	// DBG

		if ((x < currentSectorMinEntry) || 
			(x >= currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector)) {

			//
			// Sector doesn't point at the sector we need.  See if we already have it read into
			// page.
			//
			if ((x >= currentPageMinEntry) && 
				(x < currentPageMinEntry
				 + sectorsReadIntoPage * deviceExtension->BackpointerEntriesPerSector)) {

				//
				// We do, so just reset sector and currentSectorMinEntry.
				//
				ULONG sectorWithinPage = (x - currentPageMinEntry) / deviceExtension->BackpointerEntriesPerSector;
				ASSERT(sectorWithinPage < sectorsReadIntoPage);

#if		DBG
				InterlockedIncrement(&BPPageHits);
#endif	// DBG

				sector = (PSIS_BACKPOINTER)(page + deviceExtension->FilesystemVolumeSectorSize * sectorWithinPage);

				currentSectorMinEntry = currentPageMinEntry + sectorWithinPage * deviceExtension->BackpointerEntriesPerSector;

            } else {
				//
				// The current page doesn't have what we need, read something in.  We read a page if
				// we can fit all of the range from l to r within it; otherwise, we just read in one
				// sector.
				//

#if		DBG
				InterlockedIncrement(&BPLookupReads);
#endif	// DBG

				//
				// We don't have the sector we need.  Get it.
				//

/*BJB - for now, always read in one sector at a time. */
/*BJB*/ sector = (PSIS_BACKPOINTER)page;
/*BJB*/ sectorsReadIntoPage = 1;

				fileOffset.QuadPart = ((x * sizeof(SIS_BACKPOINTER)) /
										deviceExtension->FilesystemVolumeSectorSize) * 
										deviceExtension->FilesystemVolumeSectorSize;

				irp = IoBuildAsynchronousFsdRequest(
							IRP_MJ_READ,
							deviceExtension->AttachedToDeviceObject,
							sector,
							deviceExtension->FilesystemVolumeSectorSize,
							&fileOffset,
							Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));

					KeClearEvent(event);
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
			
				currentSectorMinEntry = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER));

/*BJB*/ currentPageMinEntry = currentSectorMinEntry;
			}
		}

		ASSERT((x >= currentSectorMinEntry) && (x < currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector));

		thisEntry = &sector[x - currentSectorMinEntry];

		if (PerLink->Index.QuadPart < thisEntry->LinkFileIndex.QuadPart) {
			r = x-1;
		} else {
			l = x+1;
		}

	} while ((thisEntry->LinkFileIndex.QuadPart != PerLink->Index.QuadPart) && (l <= r));

	if (thisEntry->LinkFileIndex.QuadPart != PerLink->Index.QuadPart) {
        //
		// No match.
		//
		SIS_MARK_POINT_ULONG(thisEntry->LinkFileIndex.LowPart);
NoMatch:
		SIS_MARK_POINT_ULONG(PerLink);

		if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {	
			SipCheckVolume(deviceExtension);
		}

	} else {
		if (thisEntry->LinkFileNtfsId.QuadPart != PerLink->LinkFileNtfsId.QuadPart) {

			//
			// No match, do a volume check.
			//
			SIS_MARK_POINT_ULONG(PerLink);
			SIS_MARK_POINT_ULONG(thisEntry->LinkFileNtfsId.LowPart);

			if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
				SipCheckVolume(deviceExtension);
			}

		} else {
            BOOLEAN writeBack;

			//
			// Match.
			//
			matched = TRUE;

            //
            // We always make sure the Check flag is set.  If it's clear, we must
            // write the backpointer back to disk.  (Volume check is the only
            // code that ever clears this flag.)  STATUS_MEDIA_WRITE_PROTECTED
            // is used as the error code that the caller keys off of to retry
            // the operation with the backpointer resource held exclusive.
            //
            writeBack = thisEntry->LinkFileIndex.Check == 0;
            thisEntry->LinkFileIndex.Check = 1;

            if (writeBack && !Exclusive) {
                status = STATUS_MEDIA_WRITE_PROTECTED;
                goto done;
            }

            //
            // Stick it in the cache.
            //
			KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
			CSFile->BackpointerCache[CSFile->BPCacheNextSlot] = *thisEntry;
			CSFile->BPCacheNextSlot = (CSFile->BPCacheNextSlot + 1) % SIS_CS_BACKPOINTER_CACHE_SIZE;
			KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

            if (writeBack) {

				//
				// We need to rewrite the sector we just read.
				//
				
				irp = IoBuildAsynchronousFsdRequest(
						IRP_MJ_WRITE,
						deviceExtension->AttachedToDeviceObject,
						sector,
						deviceExtension->FilesystemVolumeSectorSize,
						&fileOffset,
						Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));
					//
					// No need to clear the event, because we'll never use it again.
					//
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
            }
		}
	}

	status = STATUS_SUCCESS;

done:

	if (matched) {
		//
		// Set the verified flag in the PerLink so that if anyone
		// else opens this link, we won't have to redo the check.  Note
		// that we need to do this before we release the BackpointerResource
		// so that we're not racing with someone who wants to delete this
		// backpointer.
		//
		KeAcquireSpinLock(PerLink->SpinLock, &OldIrql);
		PerLink->Flags |= SIS_PER_LINK_BACKPOINTER_VERIFIED;
		KeReleaseSpinLock(PerLink->SpinLock, OldIrql);
	}

	if (NULL != page) {
		ExFreePool(page);
	}

	if (NULL != foundMatch) {
		*foundMatch = matched;
	}

	return status;
}

NTSTATUS
SipAddBackpointer(
	IN PSIS_CS_FILE			CSFile,
	IN PLINK_INDEX			LinkFileIndex,
	IN PLARGE_INTEGER		LinkFileNtfsId)
/*++

Routine Description:

	Add a backpointer to the given common store file for the LinkFileIndex,LinkFileNtfsId pair.
	Note that the LinkFileIndex for this file must be the largest that has ever had a backpointer
	added for this particular common store file.

	Caller must hold the CSFile->BackpointerResource exclusive.  This routine does not release it.

	Does not return until the backpointer index is updated.  This update is atomic (because of
	being a single sector write).

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	CSFile - the common store file to which the backpointer should be attached.

	LinkFileIndex - the index

	LinkFileNtfsId - the file id for the appropriate file


Return Value:

	status of the add

	
--*/
{
	PSIS_BACKPOINTER		sector = NULL;
	LARGE_INTEGER			fileOffset;
	PIRP					irp;
	BOOLEAN					isThisSectorZero;
	PDEVICE_EXTENSION		deviceExtension = CSFile->DeviceObject->DeviceExtension;
	NTSTATUS				status;
	KEVENT					event[1];
	IO_STATUS_BLOCK			Iosb[1];
	ULONG                   index, startIndex, stopIndex;
	PIO_STACK_LOCATION		irpSp;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SIS_MARK_POINT_ULONG(LinkFileIndex->LowPart);
	SIS_MARK_POINT_ULONG(LinkFileNtfsId->LowPart);

	status= SipAssureCSFileOpen(CSFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');

	if (NULL == sector) {
		SIS_MARK_POINT();

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent, FALSE);

	//
	// Read in the last sector of the backpointer file.
	//

	fileOffset.QuadPart = (((CSFile->BPStreamEntries - 1 + SIS_BACKPOINTER_RESERVED_ENTRIES) * sizeof(SIS_BACKPOINTER)) /
							deviceExtension->FilesystemVolumeSectorSize) * 
							deviceExtension->FilesystemVolumeSectorSize;

	ASSERT(fileOffset.QuadPart >= 0);

	if (fileOffset.QuadPart == 0) {
		isThisSectorZero = TRUE;
	} else {
		isThisSectorZero = FALSE;
	}

	ASSERT(isThisSectorZero == 
			(CSFile->BPStreamEntries <= (deviceExtension->BackpointerEntriesPerSector - SIS_BACKPOINTER_RESERVED_ENTRIES)));

	irp = IoBuildAsynchronousFsdRequest(
			IRP_MJ_READ,
			deviceExtension->AttachedToDeviceObject,
			sector,
			deviceExtension->FilesystemVolumeSectorSize,
			&fileOffset,
			Iosb);

	if (NULL == irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = CSFile->BackpointerStreamFileObject;

    ASSERT(irpSp->FileObject);

	IoSetCompletionRoutine(
		irp,
		SiDeleteAndSetCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	ASSERT(0 == KeReadStateEvent(event));

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
		status = Iosb->Status;
	} else {
		ASSERT(0 != KeReadStateEvent(event));
		KeClearEvent(event);
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}


	//
	// Scan the sector to find the place to insert the new mapping.
	// This will be the first terminal free entry (ie., the first
	// entry with LinkFileIndex == MAXLONGLONG).  This is not the
	// same as a deleted entry (one in which LinkFileNtfsId is
	// MAXLONGLONG).  Search from back to front so we're guaranteed
    // to always insert at the end, irregardless of any backpointer
    // stream corruption.
    //
    // Be careful, unsigned integers...
	//
    startIndex = deviceExtension->BackpointerEntriesPerSector - 1;
    stopIndex = (isThisSectorZero ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0) - 1;

    for (index = startIndex;
         index != stopIndex && sector[index].LinkFileIndex.QuadPart == MAXLONGLONG;
         index--) {
        continue;
    }

    if (index != startIndex) {
		//
		// We found a free entry.  Note that we always
		// set the check bit (used during volume checking).
		//
        if (index != stopIndex &&
            sector[index].LinkFileIndex.QuadPart >= LinkFileIndex->QuadPart) {
			//
			// We should always be inserting the highest allocated link file index.
			// We're not, so something's corrupt.  Initiate a volume check.
			//
			SIS_MARK_POINT_ULONG(CSFile);
			SIS_MARK_POINT_ULONG(index);
			SIS_MARK_POINT_ULONG(sector[index].LinkFileIndex.LowPart);
			SIS_MARK_POINT_ULONG(LinkFileIndex->LowPart);

			// Initiate a volume check, but don't abort.

			SipCheckVolume(deviceExtension);
        }

        index++;                                // bump up to free entry

		sector[index].LinkFileIndex = *LinkFileIndex;
		sector[index].LinkFileIndex.Check = 1;
		sector[index].LinkFileNtfsId = *LinkFileNtfsId;

		if (isThisSectorZero) {
			ASSERT(index >= SIS_BACKPOINTER_RESERVED_ENTRIES);
			CSFile->BPStreamEntries = index + 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;
		} else {
			CSFile->BPStreamEntries = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER)) + index + 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;
		}
		ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
               CSFile->BPStreamEntries > 0);
	} else {
		//
		// We need to add a new sector to the end of the file.  Initialize
		// a new one containing only this entry.
		//

		sector[0].LinkFileIndex = *LinkFileIndex;
		sector[0].LinkFileIndex.Check = 1;
		sector[0].LinkFileNtfsId = *LinkFileNtfsId;

		for (index = 1; 
			 index < deviceExtension->BackpointerEntriesPerSector;
			 index++) {
			
			sector[index].LinkFileIndex.QuadPart = MAXLONGLONG;
			sector[index].LinkFileNtfsId.QuadPart = MAXLONGLONG;
		}

		fileOffset.QuadPart += deviceExtension->FilesystemVolumeSectorSize;
		ASSERT(fileOffset.QuadPart >= 0);

		ASSERT(CSFile->BPStreamEntries < ((ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER))) - 
									SIS_BACKPOINTER_RESERVED_ENTRIES + 1);

		CSFile->BPStreamEntries = ((ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER))) - 
									SIS_BACKPOINTER_RESERVED_ENTRIES + 1;

		ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
               CSFile->BPStreamEntries > 0);
	}

	//
	// Write out the newly updated sector
	//
	
	irp = IoBuildAsynchronousFsdRequest(
			IRP_MJ_WRITE,
			deviceExtension->AttachedToDeviceObject,
			sector,
			deviceExtension->FilesystemVolumeSectorSize,
			&fileOffset,
			Iosb);

	if (NULL == irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = CSFile->BackpointerStreamFileObject;

	IoSetCompletionRoutine(
		irp,
		SiDeleteAndSetCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	ASSERT(0 == KeReadStateEvent(event));

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
		status = Iosb->Status;
	} else {
		ASSERT(0 != KeReadStateEvent(event));
		//
		// No need to clear the event, because we're never going to use it again.
		//
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

done:

	if (NULL != sector) {
		ExFreePool(sector);
	}	

	return status;
}

NTSTATUS
SipRemoveBackpointer(
	IN PSIS_CS_FILE					CSFile,
	IN PLINK_INDEX					LinkIndex,
	IN PLARGE_INTEGER				LinkFileNtfsId,
	OUT PBOOLEAN					ReferencesRemain)
/*++

Routine Description:

	Remove a backpointer from the given common store file.  If this is the last
	backpointer, will indicate so by setting ReferencesRemain to false.

	Does not return until the update is complete.

	Caller must hold the backpointer resource exclusively for this CS file. This
	routine does not release it.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	CSFile - the common store file to which the backpointer should be attached.

	LinkFileIndex - the index

	LinkFileNtfsId - the file id for the appropriate file

	ReferencesRemain - set TRUE iff there are more backpointers left for the file

Return Value:

	status of the remove

	
--*/
{
	NTSTATUS						status;
	KIRQL							OldIrql;
	PSIS_BACKPOINTER				sector = NULL;
	ULONG							i;
	ULONG							x, l, r;
	KEVENT							event[1];
	BOOLEAN							truncateFile;
	PIRP							irp;
	FILE_END_OF_FILE_INFORMATION	endOfFileInfo[1];
	PDEVICE_EXTENSION				deviceExtension = CSFile->DeviceObject->DeviceExtension;
	ULONG							currentSectorMinEntry = MAXULONG;
	LARGE_INTEGER					fileOffset;
	IO_STATUS_BLOCK					Iosb[1];
	PIO_STACK_LOCATION				irpSp;
	PSIS_BACKPOINTER				thisEntry;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SIS_MARK_POINT_ULONG(LinkIndex->LowPart);

	status= SipAssureCSFileOpen(CSFile);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

#if		DBG
	InterlockedIncrement(&BPDeleteAttempts);
#endif	// DBG

	*ReferencesRemain = TRUE;		// We'll fix this up later if need be.

	//
	// Blow away any entry in the cache.  We don't need to worry about it getting
	// refilled before we've updated the backpointer index, because we hold the
	// BackPointer resource exclusive.
	//

	KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);

	for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
		if (CSFile->BackpointerCache[i].LinkFileIndex.QuadPart == LinkIndex->QuadPart) {
			CSFile->BackpointerCache[i].LinkFileIndex.QuadPart = MAXLONGLONG;
		}
	}
	KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');
	if (NULL == sector) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	KeInitializeEvent(event,SynchronizationEvent,FALSE);

	//
	// Search the backpointer index in the CS file.  Use
	// a standard binary search.
	//

    if (0 == CSFile->BPStreamEntries) {
        goto NoMatch;
    }

    l = SIS_BACKPOINTER_RESERVED_ENTRIES;
    r = CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES - 1;

	do {
		ASSERT(l <= r);

		x = (l + r) / 2;

		ASSERT(l <= x);
		ASSERT(r >= x);

		if ((x < currentSectorMinEntry) || 
			(x >= currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector)) {

			//
			// We don't have the sector we need.  Get it.
			//

#if		DBG
			InterlockedIncrement(&BPDeleteReads);
#endif	// DBG

			fileOffset.QuadPart = ((x * sizeof(SIS_BACKPOINTER)) /
									deviceExtension->FilesystemVolumeSectorSize) * 
									deviceExtension->FilesystemVolumeSectorSize;

			ASSERT(fileOffset.QuadPart >= 0);

			irp = IoBuildAsynchronousFsdRequest(
					IRP_MJ_READ,
					deviceExtension->AttachedToDeviceObject,
					sector,
					deviceExtension->FilesystemVolumeSectorSize,
					&fileOffset,
					Iosb);

			if (NULL == irp) {
				SIS_MARK_POINT();
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto done;
			}

			irpSp = IoGetNextIrpStackLocation(irp);
			irpSp->FileObject = CSFile->BackpointerStreamFileObject;

			IoSetCompletionRoutine(
				irp,
				SiDeleteAndSetCompletion,
				event,
				TRUE,
				TRUE,
				TRUE);


			ASSERT(0 == KeReadStateEvent(event));

			status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

			if (STATUS_PENDING == status) {
				status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
				ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
				status = Iosb->Status;
			} else {
				ASSERT(0 != KeReadStateEvent(event));
				KeClearEvent(event);
			}

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto done;
			}
			
			currentSectorMinEntry = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER));
		}

		ASSERT((x >= currentSectorMinEntry) && (x < currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector));

		thisEntry = &sector[x - currentSectorMinEntry];

		if (LinkIndex->QuadPart < thisEntry->LinkFileIndex.QuadPart) {
			r = x-1;
		} else {
			l = x+1;
		}
	} while ((thisEntry->LinkFileIndex.QuadPart != LinkIndex->QuadPart) && (l <= r));

	if (thisEntry->LinkFileIndex.QuadPart != LinkIndex->QuadPart) {
		//
		// No match.
		//
NoMatch:
		SIS_MARK_POINT_ULONG(CSFile);

		if (PsGetCurrentThreadId() != deviceExtension->Phase2ThreadId) {
			//
			// If we're not in Phase2 initialization, then we expect that the backpointer should
			// be there, and we need to kick off a volume check if it's not.  If we are in
			// Phase2, then we're just processing the log and it's not too surprising that
			// the file isn't there, so just ignore it.
			//
			SipCheckVolume(deviceExtension);
		}
	} else {
		if (thisEntry->LinkFileNtfsId.QuadPart != LinkFileNtfsId->QuadPart) {

			//
			// No match, do a volume check.
			//
			SIS_MARK_POINT_ULONG(CSFile);
			SipCheckVolume(deviceExtension);

		} else {
			//
			// We found the entry we wanted.  Figure out whether this was the last entry
			// in the file and the only entry in the sector.  First, blow away the entry
			// that we're supposed to delete.
			//

			thisEntry->LinkFileNtfsId.QuadPart = MAXLONGLONG;

			if (currentSectorMinEntry + deviceExtension->BackpointerEntriesPerSector >= CSFile->BPStreamEntries) {
				//
				// This is the last sector in the file.  Figure out if this is the last entry in the
				// sector.
				//
				truncateFile = TRUE;

				for (i = fileOffset.QuadPart == 0 ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0;
					 i < deviceExtension->BackpointerEntriesPerSector;
					 i++) {
					if (sector[i].LinkFileNtfsId.QuadPart != MAXLONGLONG) {
						truncateFile = FALSE;
						break;
					}
				}
			} else {
				//
				// This isn't the last sector in the file, so we're not going to be truncating.
				//
				truncateFile = FALSE;
			}

			if (truncateFile) {
				//
				// We need to scan backward through the file looking for empty sectors in order
				// to figure out how much to delete. 
				//

#if		DBG
				InterlockedIncrement(&BPDeleteTruncations);
#endif	// DBG

				while (fileOffset.QuadPart > 0) {
					//
					// Read in the next lower sector.  
					//
					ASSERT(fileOffset.QuadPart >= deviceExtension->FilesystemVolumeSectorSize);

					fileOffset.QuadPart -= deviceExtension->FilesystemVolumeSectorSize;

					ASSERT(fileOffset.QuadPart >= 0);

					irp = IoBuildAsynchronousFsdRequest(
							IRP_MJ_READ,
							deviceExtension->AttachedToDeviceObject,
							sector,
							deviceExtension->FilesystemVolumeSectorSize,
							&fileOffset,
							Iosb);

					if (NULL == irp) {
						SIS_MARK_POINT();
						status = STATUS_INSUFFICIENT_RESOURCES;
						goto done;
					}

					irpSp = IoGetNextIrpStackLocation(irp);
					irpSp->FileObject = CSFile->BackpointerStreamFileObject;

					IoSetCompletionRoutine(
						irp,
						SiDeleteAndSetCompletion,
						event,
						TRUE,
						TRUE,
						TRUE);

					ASSERT(0 == KeReadStateEvent(event));

					status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

					if (STATUS_PENDING == status) {
						status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
						ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
						status = Iosb->Status;
					} else {
						ASSERT(0 != KeReadStateEvent(event));
						KeClearEvent(event);
					}

					if (!NT_SUCCESS(status)) {
						SIS_MARK_POINT_ULONG(status);
						goto done;
					}

					//
					// Check this sector
					//
					for (i = fileOffset.QuadPart == 0 ? SIS_BACKPOINTER_RESERVED_ENTRIES : 0;
						 i < deviceExtension->BackpointerEntriesPerSector; 
						 i++) {

						if (sector[i].LinkFileNtfsId.QuadPart != MAXLONGLONG) {
							//
							// This entry is valid, so we're not going to truncate this sector.
							// Stop here.
							//
							fileOffset.QuadPart += deviceExtension->FilesystemVolumeSectorSize;
							ASSERT(fileOffset.QuadPart >= 0);

							goto truncateNow;
						}
					}
				}
truncateNow:
				ASSERT(fileOffset.QuadPart % deviceExtension->FilesystemVolumeSectorSize == 0);

				if (0 == fileOffset.QuadPart) {
					//
					// There's nothing in sector 0, so the backpointer list is empty.  Indicate that
					// to our caller, and then set the truncate so that it won't wipe out sector 0
					// where the header is held.
					//
                    if ((deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_NODELETE) == 0) {
                        //
                        // Never delete a common store file while a volume check
                        // is in progress.
                        //
					    *ReferencesRemain = FALSE;
                    } else {
#if DBG
                        DbgPrint("SipRemoveBackpointer volume check not deleting\n");
#endif
                    }
					endOfFileInfo->EndOfFile.QuadPart = deviceExtension->FilesystemVolumeSectorSize;
					CSFile->BPStreamEntries = 0;
				} else {
					endOfFileInfo->EndOfFile = fileOffset;
					CSFile->BPStreamEntries = (ULONG)(fileOffset.QuadPart / sizeof(SIS_BACKPOINTER) - SIS_BACKPOINTER_RESERVED_ENTRIES);
					ASSERT(CSFile->BPStreamEntries < 0x7fffffff &&
                           CSFile->BPStreamEntries > 0);
				}

				status = SipSetInformationFile(
							CSFile->BackpointerStreamFileObject,
							deviceExtension->DeviceObject,
							FileEndOfFileInformation,
							sizeof(FILE_END_OF_FILE_INFORMATION),
							endOfFileInfo);

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}

			}

            if (!truncateFile || 0 == currentSectorMinEntry) {

                ASSERT(0 == fileOffset.QuadPart || 0 != currentSectorMinEntry);

				//
				// We need to rewrite the sector with the given entry deleted.
				//
				irp = IoBuildAsynchronousFsdRequest(
						IRP_MJ_WRITE,
						deviceExtension->AttachedToDeviceObject,
						sector,
						deviceExtension->FilesystemVolumeSectorSize,
						&fileOffset,
						Iosb);

				if (NULL == irp) {
					SIS_MARK_POINT();
					status = STATUS_INSUFFICIENT_RESOURCES;
					goto done;
				}

				irpSp = IoGetNextIrpStackLocation(irp);
				irpSp->FileObject = CSFile->BackpointerStreamFileObject;

				IoSetCompletionRoutine(
					irp,
					SiDeleteAndSetCompletion,
					event,
					TRUE,
					TRUE,
					TRUE);

				ASSERT(0 == KeReadStateEvent(event));

				status = IoCallDriver(deviceExtension->AttachedToDeviceObject, irp);

				if (STATUS_PENDING == status) {
					status = KeWaitForSingleObject(event,Executive, KernelMode, FALSE, NULL);
					ASSERT(STATUS_SUCCESS == status);		// We're using stack stuff, so this must succeed
					status = Iosb->Status;
				} else {
					ASSERT(0 != KeReadStateEvent(event));
					//
					// No need to clear the event, because we'll never use it again.
					//
				}

				if (!NT_SUCCESS(status)) {
					SIS_MARK_POINT_ULONG(status);
					goto done;
				}
			}
		}
	}

	status = STATUS_SUCCESS;

done:

	if (NULL != sector) {
		ExFreePool(sector);
	}

	return status;
}

#if	ENABLE_LOGGING
VOID
SipAssureBackpointer(
	IN PFILE_OBJECT						fileObject,
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_SCB							scb)
/*++

Routine Description:

	We're playing back the log and we've decided that a given file
	should still exist and have a backpointer.  Check it out, and if
	necessary rewrite the reparse point on the file with a new
	backpointer.

Arguments:

	fileObject - for the file to check

	deviceExtension - for the volume on which this record resides

	scb - of the file in question

Return Value:

	void	
--*/
{
	BOOLEAN					foundMatch;
	NTSTATUS				status;
	REPARSE_DATA_BUFFER		reparseBuffer[1];
	LINK_INDEX				newLinkIndex;

	PAGED_CODE();

	ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);

	status = SipCheckBackpointer(
				scb->PerLink,
				&foundMatch);

	if (!NT_SUCCESS(status)) {
		//
		// Just bag it.
		//

		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (foundMatch) {
		//
		// The backpointer is already there, so we're done.
		//
		goto done;
	}

	//
	// The backpointer's gone.  Check the file to see if it's got a valid reparse
	// point on it.  If it does, then we'll fix up the backpointer.
	//

	if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&scb->PerLink->CsFile->CSid,
				&newLinkIndex,

done:

}

VOID
SipRemoveRefBecauseOfLog(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PLINK_INDEX						linkIndex,
	IN PLARGE_INTEGER					linkFileNtfsId,
	IN PCSID							CSid)
/*++

Routine Description:

	We're playing back the log and we've decided that we want to delete
	a reference to a common store file.  Delete it.

Arguments:

	deviceExtension - for the volume on which this record resides

	linkIndex - the link index for the backpointer we're deleting

	linkFileNtfsId - the NTFS id for the backpointer we're deleting

	CSid - the common store ID for the CS file holding the backpointer

Return Value:

	void	
--*/
{
	PSIS_CS_FILE			CSFile = NULL;
	BOOLEAN					referencesRemain;

	PAGED_CODE();

	ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);

	CSFile = SipLookupCSFile(
				&logRecord->CSid,
				NULL,
				deviceExtension->DeviceObject);

	if (NULL == CSFile) {
		//
		// We're out of memory.  Just ignore this log record.
		//
		SIS_MARK_POINT();
		goto done;
	}

	//
	// Since we're in Phase2, we know that we're the only thread messing with
	// this CS file.  Therefore, we don't need to bother synchronizing (ie., taking
	// the backpointer resource).  Just blow away the backpointer.  Note that there
	// is special code in the backpointer routine that will avoid starting a volume
	// check in the Phase2 thread even if we try to remove a backpointer that's already
	// gone.
	//

	status = SipRemoveBackpointer(
				CSFile,
				&logRecord->LinkIndex,
				&logRecord->LinkFileNtfsId,
				&referencesRemain);

	if (NT_SUCCESS(status) && !referencesRemain) {
		//
		// This was the last reference to the CS file.  Delete it.  We are already
		// in the PsInitialSystemProcess, so we don't need to post, we'll just call
		// the work routine directly.
		//
		SI_DELETE_CS_FILE_REQUEST		deleteRequest[1];

		SIS_MARK_POINT();

		deleteRequest->CSFile = CSFile;
		KeInitializeEvent(deleteRequest->event, NotificationEvent, FALSE);

		SipDeleteCSFileWork(deleteRequest);
	}

done:
	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}
}

VOID
SipProcessRefcountLogDeleteRecord(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_LOG_REFCOUNT_UPDATE			logRecord)
{
	NTSTATUS				status;
	HANDLE					fileHandle = NULL;
	PFILE_OBJECT			fileObject = NULL;
	PSIS_SCB				scb;
	PSIS_PER_FO				perFO;

	PAGED_CODE();

	ASSERT(SIS_REFCOUNT_UPDATE_LINK_DELETED == logRecord->UpdateType);

	//
	// We have a delete record in the log file.  We need to assure that either
	// the delete happened and the backpointer was eliminated, or else the
	// delete didn't happen and the backpointer is still there, but not one
	// without the other.
	//

	//
	// Proceed by opening the file named in the record and checking to see if
	// it has a SIS reparse point on it.  If it does, then we'll back out the
	// delete.  Otherwise, we'll make sure the backpointer is gone.
	//

	status = SipOpenFileById(
				deviceExtension,
				&logRecord->LinkFileNtfsId,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				0,										// exclusive
				FILE_NON_DIRECTORY_FILE,
				&fileHandle);

	if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
		//
		// The file's gone.  Make sure the backpointer is similarly gone.
		//
		SipRemoveRefBecauseOfLog(
			deviceExtension,
			&logRecord->LinkIndex,
			&logRecord->LinkFileNtfsId,
			&logRecord->CSid);

		goto done;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// We can't open the file, but it's not because it's missing.
		// Just ignore the log record.
		//
		goto done;
	}

	//
	// The file still exists.  See if it's a SIS link.
	//
	status = ObReferenceObjectByHandle(
				fileHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				KernelMode,
				&fileObject,
				NULL);							// Handle information

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (SipIsFileObjectSIS(fileObject, deviceExtension->DeviceObject, FindActive, &perFO, &scb)) {
		//
		// It's there and it is a SIS file object.  Make sure that it's got a valid backpointer.
		//

		SipAssureBackpointer(
			fileObject,
			deviceExtension,
			scb);
			
	} else {
		//
		// It's there, but it's not a SIS file object.
		//
	}
				

done:

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
		fileObject = NULL;
	}
	if (NULL != fileHandle) {
		ZwClose(fileHandle);
		fileHandle = NULL;
	}	

				
}
VOID
SipProcessRefcountUpdateLogRecord(
	IN PDEVICE_EXTENSION				deviceExtension,
	IN PSIS_LOG_REFCOUNT_UPDATE			logRecord)
/*++

Routine Description:

	We're in phase 2 initialization reading back the log.  We've got a refcount
	update log record.  Look at it and ensure that what it describes has really
	either happened or not happened, not part way.

	In particular, these log records all describe either creates or deletes.
	In either case, we check to see if the link file still exists, and if it
	does we update the backpointers accordingly.  In the case of deletes, this
	means that we might have to restore a deleted backpointer.  For creates, we
	might have to add a never-created backpointer.

	The one exception is that when the common store file is gone, then the link
	file gets deleted if it exists, because it's of little 

	If, on the other hand, the link file is gone, then we make sure that the
	backpointer is similarly gone.

Arguments:

	deviceExtension - for the volume on which this record resides

	logRecord - the log record in question

Return Value:

	void	
--*/
{
	PAGED_CODE();

	ASSERT(!deviceExtension->Phase2InitializationComplete);
	ASSERT(deviceExtension->Phase2ThreadId == PsGetCurrentThreadId());

	switch (logRecord->UpdateType) {
		case SIS_REFCOUNT_UPDATE_LINK_DELETED:
		case SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN:
			SipProcessRefcountLogDeleteRecord(deviceExtension,logRecord);
	}

}
#endif	// ENABLE_LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\post.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    post.c

Abstract:

	SIS support for posting to the Fsp

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

NTSTATUS
SiPrePostIrp(
	IN OUT PIRP		Irp)
/*++

Routine Description:

	Code to prepare an irp for posting.  Just locks the buffers for
	appropriate operations and marks the irp pending.

Arguments:

    Irp - Pointer to the Irp to be posted

Return Value:

    status of perparation

--*/

{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS status = STATUS_SUCCESS;

	if (irpSp->MajorFunction == IRP_MJ_READ
		|| irpSp->MajorFunction == IRP_MJ_WRITE) {
		if (!(irpSp->MinorFunction & IRP_MN_MDL)) {
			status = SipLockUserBuffer(
							Irp,
							irpSp->MajorFunction == IRP_MJ_READ ? IoWriteAccess : IoReadAccess,
							irpSp->Parameters.Read.Length);
		}
	}

	IoMarkIrpPending(Irp);

	return status;
}

NTSTATUS
SipLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

	This routine is stolen from NTFS.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    status of locking

--*/

{
    PMDL Mdl = NULL;

    ASSERT( Irp != NULL );

    if (Irp->MdlAddress == NULL) {

        //
        // Allocate the Mdl, and Raise if we fail.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, FALSE, Irp );

        if (Mdl == NULL) {
			return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, Irp->RequestorMode, Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;

			return Status;
        }
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}

VOID
SiFspDispatch(
	IN PVOID			parameter)
/*++

Routine Description:

	Generic dispatch routine for SIS posted irps.  Take the posted irp and execute
	it.  Frees the request buffer on completion.

Arguments:

	parameter - a PSI_FSP_REQUEST containing the information for the posted irp

Return Value:

	void

--*/
{
	PSI_FSP_REQUEST 			fspRequest = parameter;
	PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(fspRequest->Irp);

	SIS_MARK_POINT();
			 
	ASSERT(irpSp != NULL);

	switch (irpSp->MajorFunction) {
		case IRP_MJ_READ:		
			SIS_MARK_POINT_ULONG(fspRequest->Irp);
			SipCommonRead(fspRequest->DeviceObject, fspRequest->Irp, TRUE);
			break;

		default:
			SIS_MARK_POINT();
#if		DBG
			DbgPrint("SiFspDispatch: Invalid major function code in posted irp, 0x%x.\n", irpSp->MajorFunction);
			DbgBreakPoint();
#endif	// DBG
	}
	SIS_MARK_POINT();

	ExFreePool(fspRequest);
}

NTSTATUS
SipPostRequest(
	IN PDEVICE_OBJECT			DeviceObject,
	IN OUT PIRP					Irp,
	IN ULONG					Flags)
/*++

Routine Description:

	Routine to post a SIS irp.  Prepares the irp, constructs a post request 
	and queues it to a critical worker thread.

Arguments:

	DeviceObject	- For the SIS device

	Irp				- The IRP to be posted

	Flags			- currently unused

Return Value:

	status of the posting

--*/
{
	NTSTATUS 				status;
	PSI_FSP_REQUEST			fspRequest;

	fspRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_FSP_REQUEST), ' siS');
	if (fspRequest == NULL) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	fspRequest->Irp = Irp;
	fspRequest->DeviceObject = DeviceObject;
	fspRequest->Flags = Flags;

    status = SiPrePostIrp(Irp);
	
	if (!NT_SUCCESS(status)) {
		ExFreePool(fspRequest);
		return status;
	}

	ExInitializeWorkItem(
		fspRequest->workQueueItem,
		SiFspDispatch,
		(PVOID)fspRequest);
	
	ExQueueWorkItem(fspRequest->workQueueItem,CriticalWorkQueue);

	return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\index.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    index.c

Abstract:

	Support for SIS indices.

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

BOOLEAN
SipIndicesFromReparseBuffer(
	IN PREPARSE_DATA_BUFFER		reparseBuffer,
	OUT PCSID					CSid,
	OUT PLINK_INDEX				LinkIndex,
    OUT PLARGE_INTEGER          CSFileNtfsId,
    OUT PLARGE_INTEGER          LinkFileNtfsId,
	OUT PLONGLONG				CSFileChecksum OPTIONAL,
	OUT PBOOLEAN				EligibleForPartialFinalCopy OPTIONAL,
	OUT PBOOLEAN				ReparseBufferCorrupt OPTIONAL)
/*++

Routine Description:

	Take a SIS reparse buffer, check it for internal consistency and
	decode it to its constituient parts.

Arguments:

	reparseBuffer	- the buffer to decode
	CSid
	LinkIndex
	CSFileNtfsId
	LinkFileNtfsId
	CSFileChecksum	- the values from the reparse point
	EligibleForPartialFinalCopy - can we do a partial final copy on this file (ie., is the
								  reparse format version > 4?)
	ReparseBufferCorrupt - are we convinced that the buffer is corrupt (rather than just
									being too new a version)  Meaningful only if
									the return value of the function is FALSE

Return Value:

	TRUE if the buffer was decoded successfully, FALSE otherwise.

--*/
{
    PSI_REPARSE_BUFFER sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseBuffer->GenericReparseBuffer.DataBuffer;
    LONGLONG Checksum = 0;

	//
	// First check to be sure that we understand this reparse point format version and
	// that it has the correct size.
	//
	if (reparseBuffer->ReparseDataLength < sizeof(ULONG)) {
		//
		// The reparse buffer is to small to include a version number.  We guarantee that
		// no SIS version will ever produce such a reparse point, so it is corrupt.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}

		return FALSE;
	}

	if (sisReparseBuffer->ReparsePointFormatVersion < 4) {
		//
		// It's too old to be supported.  Treat it as corrupt.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}
		return FALSE;
	}

	if (sisReparseBuffer->ReparsePointFormatVersion > SIS_REPARSE_BUFFER_FORMAT_VERSION) {
		//
		// This buffer is from a newer version of SIS than the filter.  It is non-corrupt,
		// but we don't understand it.
		//
		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = FALSE;
		}

		return FALSE;
	}

    //
    // Now check the checksum.
    //
    SipComputeChecksum(
	    sisReparseBuffer,
	    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	    &Checksum);

    if (Checksum != sisReparseBuffer->Checksum.QuadPart) {

		if (NULL != ReparseBufferCorrupt) {
			*ReparseBufferCorrupt = TRUE;
		}

        return FALSE;
    }

	//
	// Fill in the return values from the reparse point.
	//
	*CSid = sisReparseBuffer->CSid;
	*LinkIndex = sisReparseBuffer->LinkIndex;
    *LinkFileNtfsId = sisReparseBuffer->LinkFileNtfsId;
    *CSFileNtfsId = sisReparseBuffer->CSFileNtfsId;

	if (NULL != CSFileChecksum) {
		*CSFileChecksum = sisReparseBuffer->CSChecksum;
	}

	if (NULL != EligibleForPartialFinalCopy) {
		*EligibleForPartialFinalCopy = (sisReparseBuffer->ReparsePointFormatVersion > 4);
	}

	if (NULL != ReparseBufferCorrupt) {
		*ReparseBufferCorrupt = FALSE;
	}

	return TRUE;
}

BOOLEAN
SipIndicesIntoReparseBuffer(
	OUT PREPARSE_DATA_BUFFER	reparseBuffer,
	IN PCSID				    CSid,
	IN PLINK_INDEX              LinkIndex,
    IN PLARGE_INTEGER           CSFileNtfsId,
    IN PLARGE_INTEGER           LinkFileNtfsId,
	IN PLONGLONG				CSFileChecksum,
	IN BOOLEAN					EligibleForPartialFinalCopy)
/*++

Routine Description:

	Given the information that goes into a SIS reparse buffer, construct the
	buffer.  The caller must provide a sufficiently large buffer, and is
	responsible for filling in the ReparseDataLength field of the buffer
	with a size that corresponds to the size of the buffer (note that this is
	not EQUAL to the size of the buffer, because the meaning of this field
	is that it gives the length of the buffer beyond the mandatory header
	portion).

Arguments:

	reparseBuffer	- the buffer into which to write the reparse data
	CSid
	LinkIndex
	CSFileNtfsId
	LinkFileNtfsId
	CSFileChecksum	- the values to go into the reparse point

Return Value:

	TRUE if the buffer was encoded successfully, FALSE otherwise.

--*/
{
    PSI_REPARSE_BUFFER sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseBuffer->GenericReparseBuffer.DataBuffer;

	//
	// Check that we've got enough space.
	//
	if (reparseBuffer->ReparseDataLength < sizeof(SI_REPARSE_BUFFER)) {
		return FALSE;
	}

	//
	// Fill in the NTFS part of the reparse buffer.
	//
    reparseBuffer->ReparseTag = IO_REPARSE_TAG_SIS;
    reparseBuffer->Reserved = 0xcaf; //???

	//
	// Fill in SIS's part of the buffer.
	//
	if (EligibleForPartialFinalCopy) {
		sisReparseBuffer->ReparsePointFormatVersion = SIS_REPARSE_BUFFER_FORMAT_VERSION;
	} else {
		//
		// When we go to version 6 of the reparse buffer, EligibleForPartialFinalCopy should be
		// built into the reparse point.  For now, we'll just use a version 4 reparse point.
		//
		sisReparseBuffer->ReparsePointFormatVersion = 4;
	}
	sisReparseBuffer->Reserved = 0xb111b010;
	sisReparseBuffer->CSid = *CSid;
	sisReparseBuffer->LinkIndex = *LinkIndex;
    sisReparseBuffer->LinkFileNtfsId = *LinkFileNtfsId;
    sisReparseBuffer->CSFileNtfsId = *CSFileNtfsId;
	sisReparseBuffer->CSChecksum = *CSFileChecksum;

    //
    // Compute the checksum.
    //
	sisReparseBuffer->Checksum.QuadPart = 0;
    SipComputeChecksum(
	    sisReparseBuffer,
	    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	    &sisReparseBuffer->Checksum.QuadPart);

	//
	// Indicate the size.
	//
	reparseBuffer->ReparseDataLength = sizeof(SI_REPARSE_BUFFER);

	return TRUE;
}

NTSTATUS
SipIntegerToBase36UnicodeString(
		ULONG					Value,
		PUNICODE_STRING			String)
/*++

Routine Description:

	This does what RtlIntegerToUnicodeString(Value,36,String) would do if it
	handled base 36.  We use the same rules for digits as are normally used
	in Hex: 0-9, followed by a-z.  Note that we're intentionally using Arabic
	numerals and English letters here rather than something localized because
	this is intended to generate filenames that are never seen by users, and
	are constant regardless of the language used on the machine.

Arguments:

	Value 	- The ULONG to be converted into a base36 string
	String 	- A pointer to a UNICODE string to receive the result

Return Value:

	success or buffer overflow

--*/

{
	ULONG numChars;
	ULONG ValueCopy = Value;
	ULONG currentCharacter;

    // First, figure out the length by seeing how many times we can divide 36 into the value
	for (numChars = 0; ValueCopy != 0; ValueCopy /= 36, numChars++) {
		// No loop body
	}

	// Special case the value 0.
	if (numChars == 0) {
		ASSERT(Value == 0);
		if (String->MaximumLength < sizeof(WCHAR))
			return STATUS_BUFFER_OVERFLOW;
		String->Buffer[0] = '0';
		String->Length = sizeof(WCHAR);

		return STATUS_SUCCESS;
	}

	// If the string is too short, quit now.
	if (numChars * sizeof(WCHAR) > String->MaximumLength) {
		return STATUS_BUFFER_OVERFLOW;
	}

	// Convert the string character-by-character starting at the lowest order (and so rightmost) "digit"
	ValueCopy = Value;
	for (currentCharacter = 0 ; currentCharacter < numChars; currentCharacter++) {
		ULONG digit = ValueCopy % 36;
		ASSERT(ValueCopy != 0);
		if (digit < 10) {
			String->Buffer[numChars - (currentCharacter + 1)] = (WCHAR)('0' + (ValueCopy % 36));
		} else {
			String->Buffer[numChars - (currentCharacter + 1)] = (WCHAR)('a' + ((ValueCopy % 36) - 10));
		}
		ValueCopy /= 36;
	}
	ASSERT(ValueCopy == 0);

	// Fill in the string length, and we're done
	String->Length = (USHORT)(numChars * sizeof(WCHAR));
	
	return STATUS_SUCCESS;
}

NTSTATUS
SipIndexToFileName(
    IN PDEVICE_EXTENSION 	deviceExtension,
	IN PCSID	  			CSid,
	IN ULONG				appendBytes,
	IN BOOLEAN				mayAllocate,
    OUT PUNICODE_STRING 	fileName
	)
/*++

Routine Description:

	Given an index, returns the corresponding fully qualified file name.

Arguments:

    deviceExtension  - device extension
	CSid 	         - The id to convert
	appendBytes		 - A number of bytes that must be left unused at the end of fileName
	mayAllocate		 - May we allocate a new string, or do we have to live with what we have?
	fileName         - A pointer to a UNICODE string to receive the result

Return Value:

	success or buffer overflow

--*/
{
    NTSTATUS 			status;
	USHORT				stringMaxLength;
	UNICODE_STRING		GUIDString[1];
	BOOLEAN				allocatedBufferSpace = FALSE;

	//
	// We generate the filename as <common store path>\<guid>.sis, where <guid> is
	// the standard striung representation of the GUID for the common store file (ie.,
	// its CSid).
	//

	stringMaxLength = (USHORT)(deviceExtension->CommonStorePathname.Length +
						INDEX_MAX_NUMERIC_STRING_LENGTH +
						appendBytes);

	if (mayAllocate && stringMaxLength > fileName->MaximumLength) {
		fileName->Buffer = ExAllocatePoolWithTag(PagedPool, stringMaxLength, ' siS');
		if (!fileName->Buffer) {
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		allocatedBufferSpace = TRUE;
		fileName->MaximumLength = stringMaxLength;
	} else if (fileName->MaximumLength < stringMaxLength) {
        return STATUS_BUFFER_OVERFLOW;
	}

	RtlCopyUnicodeString(fileName,&deviceExtension->CommonStorePathname);
	ASSERT(fileName->Length < fileName->MaximumLength);
	ASSERT(fileName->Length == deviceExtension->CommonStorePathname.Length);

	status = RtlStringFromGUID(CSid,GUIDString);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Get rid of the leading and trailing curly braces in the GUID name.
	//
	ASSERT(GUIDString->Buffer[0] == '{' && GUIDString->Buffer[(GUIDString->Length/sizeof(WCHAR)) - 1] == '}');
	GUIDString->Buffer++;
	GUIDString->Length -= 2 * sizeof(WCHAR);

	status = RtlAppendUnicodeStringToString(
				fileName,
				GUIDString);

	//
	// Just for safety, undo the hacking that we did on the GUID string before freeing it.
	//
	GUIDString->Buffer--;
	GUIDString->Length += 2 * sizeof(WCHAR);

	RtlFreeUnicodeString(GUIDString);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	status = RtlAppendUnicodeToString(fileName,L".sis");
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

    return STATUS_SUCCESS;

Error:

	if (allocatedBufferSpace) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}

	return status;
}

BOOLEAN
SipFileNameToIndex(
    IN PUNICODE_STRING		fileName,
    OUT PCSID		        CSid)
/*++

Routine Description:

	Given a common store file name, returns the corresponding index.  The
    file name must be in the format generated by SipIndexToFileName().

Arguments:

	fileName         - A pointer to a UNICODE string containing the file name.
	CSid 	         - A pointer to a CSID to receive the result.

Return Value:

	TRUE if successful, else FALSE

--*/
{
	UNICODE_STRING		substring[1];
	NTSTATUS			status;
#define BUFSIZE 42
    WCHAR               buffer[BUFSIZE];

    //
    // Format: "<guid>.sis", where <guid> is the standard string representation of the
	// csid guid with the curly braces stripped off.
    //

	if (fileName->Length <= 4 * sizeof(WCHAR)) {
		//
		// It doesn't end in .sis, ignore it.
		//
		return FALSE;
	}

	substring->Buffer = buffer;
    substring->Buffer[0] = L'{';
    substring->Length = sizeof(WCHAR);
    substring->MaximumLength = BUFSIZE * sizeof(WCHAR);

    status = RtlAppendUnicodeStringToString(substring, fileName);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return FALSE;
	}

	substring->Length = substring->Length - 3 * sizeof(WCHAR);
    substring->Buffer[(substring->Length - 1) / sizeof(WCHAR)] = L'}';

	status = RtlGUIDFromString(substring, CSid);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return FALSE;
	}

    return TRUE;
}

NTSTATUS
SipOpenMaxIndexFile(
	IN OUT PDEVICE_EXTENSION			deviceExtension,
	IN BOOLEAN							create
	)
/*++

Routine Description:

	Open the MaxIndex file for a given volume.  Must be called in the
	PsInitialSystemProcess context.

Arguments:

	deviceExtension	- For the volume on which to open the MaxIndex file

	create			- May we create the file, or must it already exist?

Return Value:

	status of the open

--*/
{
	OBJECT_ATTRIBUTES		Obja;
	UNICODE_STRING			fileName;
	NTSTATUS				status;
	IO_STATUS_BLOCK			Iosb;

	ASSERT(deviceExtension->MaxAllocatedIndex.QuadPart == 0 || create);

	fileName.Buffer = ExAllocatePoolWithTag(
							NonPagedPool,
							deviceExtension->CommonStorePathname.Length + 8 * sizeof(WCHAR),
							' siS');

	if (!fileName.Buffer) {
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}
	fileName.MaximumLength = deviceExtension->CommonStorePathname.Length + 8 * sizeof(WCHAR);
	fileName.Length = 0;

	RtlCopyUnicodeString(&fileName,&deviceExtension->CommonStorePathname);
	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);

	status = RtlAppendUnicodeToString(&fileName,L"MaxIndex");
	if (!NT_SUCCESS(status)) {
		goto done;
	}

	InitializeObjectAttributes(
				&Obja,
				&fileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL);

	status = NtCreateFile(
				&deviceExtension->IndexHandle,
				GENERIC_READ|GENERIC_WRITE,
				&Obja,
				&Iosb,
				NULL,							// Allocation Size
				0,								// File Attributes
				FILE_SHARE_READ,
				create ? FILE_OVERWRITE_IF : FILE_OPEN,
				FILE_WRITE_THROUGH,
				NULL,							// EA Buffer
				0);								// EA Length


done:

	if (NULL != fileName.Buffer) {
		ExFreePool(fileName.Buffer);
	}

	return status;

}

VOID
SipAllocateIndices(
	IN PVOID					Parameter)
/*++

Routine Description:

	This is a worker thread routine that allocates a new chunk of indices
	from the index file.  Essentially, opens the index file and reads
	the old value if necessary.  Then, it adds the chunk size onto the
	max allocated index, and writes the new value back into the file
	write through.  When the write completes, set the event and exit.

Arguments:

    parameter - a PSI_ALLOCATE_INDICES.

Return Value:

	void

--*/
{
    PSI_ALLOCATE_INDICES 	allocateRequest = Parameter;
	KIRQL 					OldIrql;
	PDEVICE_EXTENSION		deviceExtension = allocateRequest->deviceExtension;
	NTSTATUS 				status;
	IO_STATUS_BLOCK			Iosb;
	LARGE_INTEGER			ByteOffset;

#if	DBG
	// Just to ensure that we don't have more then one allocator running at once, we check
	// that the allocation request is really == TRUE (rather than just != 0), and then set
	// it to 2.

	KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);
	ASSERT(deviceExtension->IndexAllocationInProgress == TRUE);
	deviceExtension->IndexAllocationInProgress = 2;
	KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);
#endif	// DBG

	if (deviceExtension->IndexHandle == NULL) {
		status = SipCreateEvent(
					SynchronizationEvent,
					&deviceExtension->IndexFileEventHandle,
					&deviceExtension->IndexFileEvent);
	
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto done;
		}

		status = SipOpenMaxIndexFile(
                    deviceExtension,
                    (BOOLEAN) (deviceExtension->MaxAllocatedIndex.QuadPart != 0));
	
		if (!NT_SUCCESS(status)) {
			//
			// We can't open the MaxIndex file.  It was probably deleted
			// or something.  Kick off a volume check to rebuild it.
			//
			SIS_MARK_POINT_ULONG(status);

            KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
            deviceExtension->Flags |= SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
            KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

            status = STATUS_CORRUPT_SYSTEM_FILE;

            //
            // Do a volume check only if this is the first attempt.
            //
	        if (deviceExtension->MaxAllocatedIndex.QuadPart == 0) {
			    SipCheckVolume(deviceExtension);
            }

			goto done;
		}
	}

	if (deviceExtension->MaxAllocatedIndex.QuadPart == 0) {

		ByteOffset.QuadPart = 0;

		status = ZwReadFile(
					deviceExtension->IndexHandle,
					deviceExtension->IndexFileEventHandle,
					NULL,											// APC routine
					NULL,											// APC Context
					&Iosb,
					&deviceExtension->MaxAllocatedIndex,
					sizeof(deviceExtension->MaxAllocatedIndex),
					&ByteOffset,
					NULL);											// Key

		if (status == STATUS_PENDING) {
			status = KeWaitForSingleObject(deviceExtension->IndexFileEvent,Executive,KernelMode,FALSE,NULL);
			ASSERT(status == STATUS_SUCCESS);
			status = Iosb.Status;
		}

		if (!NT_SUCCESS(status) || Iosb.Information != sizeof(LONGLONG) || deviceExtension->MaxAllocatedIndex.Check) {
#if		DBG
			DbgPrint(
				"SIS: SipAllocateIndices: ZwReadFile of MaxIndex file failed, wrong length or invalid value, 0x%x, %d\n",
				status,Iosb.Information);
#endif	// DBG
			ZwClose(deviceExtension->IndexHandle);
			deviceExtension->IndexHandle = NULL;

            KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
            deviceExtension->Flags |= SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
            KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

            status = STATUS_CORRUPT_SYSTEM_FILE;

			SipCheckVolume(deviceExtension);

			goto done;
		}

		deviceExtension->MaxUsedIndex = deviceExtension->MaxAllocatedIndex;
	}

	deviceExtension->MaxAllocatedIndex.QuadPart += 1000;			// 1000 is pretty arbitrary.  We can do better.

	ByteOffset.QuadPart = 0;

	status = ZwWriteFile(
				deviceExtension->IndexHandle,
				deviceExtension->IndexFileEventHandle,
				NULL,												// APC routine
				NULL,												// APC context
				&Iosb,
				&deviceExtension->MaxAllocatedIndex,
				sizeof(deviceExtension->MaxAllocatedIndex),
				&ByteOffset,
				NULL);												// key

    if (status == STATUS_PENDING) {
		status = KeWaitForSingleObject(deviceExtension->IndexFileEvent,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = Iosb.Status;
    }

	if (!NT_SUCCESS(status)) {
		// The write failed.  Back out the allocation.
		deviceExtension->MaxAllocatedIndex.QuadPart -= 1000;
#if		DBG
		DbgPrint("SIS: SipAllocateIndices: writing MaxIndex file failed, 0x%x\n",status);
#endif	// DBG
	}

done:

	KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);
	deviceExtension->IndexStatus = status;
	deviceExtension->IndexAllocationInProgress = FALSE;
	KeSetEvent(deviceExtension->IndexEvent, 0, FALSE);	// we may no longer touch allocationRequest after this set
	KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

	return;

	
}

NTSTATUS
SipAllocateIndex(
	IN PDEVICE_EXTENSION		DeviceExtension,
	OUT PLINK_INDEX				Index)
/*++

Routine Description:

	Allocate a new LINK_INDEX.  If there are indices that have been reserved from the
	file but not yet allocated, we can just grab one and return it.  Otherwise, we
	need to wait for a new index allocation.  If one is not already in progress, we
	start it and wait for it to complete.

Arguments:

	deviceExtension	- for the volume on which we're to allocate the index.

	Index - returns the new index

Return Value:

	status of the allocation.

--*/
{
    KIRQL 					OldIrql;
	BOOLEAN					StartAllocator;
	SI_ALLOCATE_INDICES		AllocateRequest[1];
	NTSTATUS				status;

    if (DeviceExtension->Flags & SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX) {
        return STATUS_CORRUPT_SYSTEM_FILE;
    }

	KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);

	while (TRUE) {
		if (DeviceExtension->MaxAllocatedIndex.QuadPart > DeviceExtension->MaxUsedIndex.QuadPart) {
			DeviceExtension->MaxUsedIndex.QuadPart++;
			*Index = DeviceExtension->MaxUsedIndex;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return STATUS_SUCCESS;
		}

		// There are no free indices left, we have to block.
		if (!DeviceExtension->IndexAllocationInProgress) {
			StartAllocator = TRUE;
			DeviceExtension->IndexAllocationInProgress = TRUE;

			// Stop anyone from passing the barrier until the allocator runs.
			KeClearEvent(DeviceExtension->IndexEvent);

		} else {
			StartAllocator = FALSE;
		}

		KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);

		if (StartAllocator) {
			ExInitializeWorkItem(AllocateRequest->workQueueItem, SipAllocateIndices, AllocateRequest);
			AllocateRequest->deviceExtension = DeviceExtension;
			ExQueueWorkItem(AllocateRequest->workQueueItem, CriticalWorkQueue);
		}

		status = KeWaitForSingleObject(DeviceExtension->IndexEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		if ((status != STATUS_SUCCESS) && !StartAllocator) {
			// The reason that we check StartAllocator here is because the allocation request is
			// on our stack, and we really can't return until the work item is completed.  (Of course,
			// the KeWaitForSingleObject should never fail in the first place...)
			return status;
		}

		KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);
	
		if (!NT_SUCCESS(DeviceExtension->IndexStatus)) {
			status = DeviceExtension->IndexStatus;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return status;
		}
	}
}

NTSTATUS
SipGetMaxUsedIndex(
	IN PDEVICE_EXTENSION				DeviceExtension,
	OUT PLINK_INDEX						Index)
/*++

Routine Description:

	Return a number that's at least as big as the largest LINK_INDEX ever allocated
	on this volume.  Note that if it looks like we don't have any indices available
	we'll kick the index allocator, because otherwise we can't be sure that the
	index values are valid (they may have never been read for this volume).

Arguments:

	deviceExtension	- for the volume we're considering

	Index - returns new index

Return Value:

	status of the check.  *Index is meaningful iff NT_SUCCESS(return value).

--*/
{
    KIRQL 					OldIrql;
	BOOLEAN					StartAllocator;
	SI_ALLOCATE_INDICES		AllocateRequest[1];
	NTSTATUS				status;

	KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);

	while (TRUE) {
		if (DeviceExtension->MaxAllocatedIndex.QuadPart > DeviceExtension->MaxUsedIndex.QuadPart) {
			*Index = DeviceExtension->MaxUsedIndex;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return STATUS_SUCCESS;
		}

		// There are no free indices left, we have to block.
		if (!DeviceExtension->IndexAllocationInProgress) {
			StartAllocator = TRUE;
			DeviceExtension->IndexAllocationInProgress = TRUE;

			// Stop anyone from passing the barrier until the allocator runs.
			KeClearEvent(DeviceExtension->IndexEvent);

		} else {
			StartAllocator = FALSE;
		}

		KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);

		if (StartAllocator) {
			ExInitializeWorkItem(AllocateRequest->workQueueItem, SipAllocateIndices, AllocateRequest);
			AllocateRequest->deviceExtension = DeviceExtension;
			ExQueueWorkItem(AllocateRequest->workQueueItem, CriticalWorkQueue);
		}

		status = KeWaitForSingleObject(DeviceExtension->IndexEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		if ((status != STATUS_SUCCESS) && !StartAllocator) {
			// The reason that we check StartAllocator here is because the allocation request is
			// on our stack, and we really can't return until the work item is completed.  (Of course,
			// the KeWaitForSingleObject should never fail in the first place...)
			return status;
		}

		KeAcquireSpinLock(DeviceExtension->IndexSpinLock, &OldIrql);
	
		if (!NT_SUCCESS(DeviceExtension->IndexStatus)) {
			status = DeviceExtension->IndexStatus;
			KeReleaseSpinLock(DeviceExtension->IndexSpinLock, OldIrql);
			return status;
		}
	}
}

NTSTATUS
SipAssureMaxIndexFileOpen(
	IN PDEVICE_EXTENSION		deviceExtension)
{
	NTSTATUS		status;
	KIRQL			OldIrql;
	LINK_INDEX		uselessIndex;
	

	//
	// Make sure that the MaxIndex file is already opened.  We need to
	// do this here to avoid a deadlock if someone
	// tries to do a copyfile with MaxIndex as the source, which would
	// otherwise deadlock.  If things are messed up, this might kick off
	// a volume check, but we should still fail the open.
	//
	if (deviceExtension->IndexHandle != NULL) {
		//
		// The file's already open, no need to do any work.
		//

		return STATUS_SUCCESS;
	}

	//
	// The index file isn't open.  Rather than trying to open it directly,
	// we avoid races by just calling the index allocator.  We'll throw away
	// the index we get back, but they're plentiful so it's not much of a
	// problem.
	//

	status = SipAllocateIndex(deviceExtension, &uselessIndex);

	if (!NT_SUCCESS(status)) {
		BOOLEAN volumeCheckPending;

		SIS_MARK_POINT_ULONG(status);

		//
		// If we're in a volume check, transmute the error to STATUS_RETRY on the
		// theory that the volume check will rebuild the MaxIndex file.  If not,
		// then just leave it alone.
		//

		KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
		volumeCheckPending = (deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_PENDING) ? TRUE : FALSE;
		KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

		if (volumeCheckPending) {
			SIS_MARK_POINT();
			status = STATUS_RETRY;
		}

		return status;
	}
	
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sicheck.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sicheck.c

Abstract:

    Code to rebuild the SIS common store backpointers after corruption.

Authors:

    Bill Bolosky, 1998

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

typedef struct _FILE_FIND_INFO {
    HANDLE              FindHandle;
    PVOID               FindBufferNext;
    ULONG               FindBufferLength;
    NTSTATUS            Status;
    PDEVICE_EXTENSION   DeviceExtension;
    PVOID               FindBuffer;
} FILE_FIND_INFO, *PFILE_FIND_INFO;

NTSTATUS
SipVCInitFindFile(
    OUT PFILE_FIND_INFO FindInfo,
    IN PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    Initializes the volume check common store directory findfirst/findnext
    functionality.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure to be passed to
                      SipVCFindNextFile.
    deviceExtension - the D.E. for the volume to be checked

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK ioStatusBlock;

    FindInfo->DeviceExtension = deviceExtension;
    FindInfo->Status = STATUS_SUCCESS;
    FindInfo->FindBufferLength = 4096;

    FindInfo->FindBuffer = ExAllocatePoolWithTag(
                                PagedPool,
                                FindInfo->FindBufferLength,
                                ' siS');

    FindInfo->FindBufferNext = FindInfo->FindBuffer;

    if (!FindInfo->FindBuffer) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        InitializeObjectAttributes(
            &Obja,
            &deviceExtension->CommonStorePathname,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        //
        // Open the directory for list access.
        //
        status = NtOpenFile(
                    &FindInfo->FindHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );
    }

    return status;
}

NTSTATUS
SipVCCloseFindFile(
    IN PFILE_FIND_INFO FindInfo)
/*++

Routine Description:

    Closes the FILE_FIND_INFO handles.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.

Return Value:

    status of operation.

--*/
{

    ASSERT(FindInfo->FindBuffer);
    ExFreePool(FindInfo->FindBuffer);

    return NtClose(FindInfo->FindHandle);
}

NTSTATUS
SipVCFindNextFile(
    IN PFILE_FIND_INFO FindInfo,
    OUT PFILE_DIRECTORY_INFORMATION *DirectoryInfo)
/*++

Routine Description:

    Returns the next entry in the common store directory.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.
    DirectoryInfo   - pointer to FILE_DIRECTORY_INFORMATION structure
                      to be filled in.

Return Value:

    status of operation.

--*/
{
    PFILE_DIRECTORY_INFORMATION dirInfo;
    IO_STATUS_BLOCK ioStatusBlock;

Restart:
    dirInfo = (PFILE_DIRECTORY_INFORMATION) FindInfo->FindBufferNext;

    if (dirInfo == (PFILE_DIRECTORY_INFORMATION) FindInfo->FindBuffer) { 

        //
        // Read in the next batch of file names.
        //

        FindInfo->Status = NtQueryDirectoryFile(
                                FindInfo->FindHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                dirInfo,
                                FindInfo->FindBufferLength,
                                FileDirectoryInformation,
                                FALSE,
                                NULL,
                                FALSE
                                );

        if (! NT_SUCCESS(FindInfo->Status) &&
            STATUS_BUFFER_OVERFLOW != FindInfo->Status) {

            //
            // We handle STATUS_BUFFER_OVERFLOW below.
            //
            return FindInfo->Status;

        }
    }

    //
    // Adjust FindBufferNext for the next time we're called.
    //
    if (dirInfo->NextEntryOffset) {

        FindInfo->FindBufferNext = (PVOID) ((PUCHAR) dirInfo + dirInfo->NextEntryOffset);

    } else {

        FindInfo->FindBufferNext = FindInfo->FindBuffer;

        if (FindInfo->Status == STATUS_BUFFER_OVERFLOW) {

            //
            // The current entry is incomplete.
            //
            goto Restart;
        }    
    }

    *DirectoryInfo = dirInfo;

    return STATUS_SUCCESS;
}

NTSTATUS
SipComputeCSChecksum(
    IN PSIS_CS_FILE     csFile,
    IN OUT PLONGLONG    csFileChecksum,
    HANDLE              eventHandle,
    PKEVENT             event)
/*++

Routine Description:

    Computes the checksum of the specified common store file.

Arguments:

    csFile          - common store file.

    csFileChecksum  - pointer to variable to receive checksum value.

    eventHandle     - event handle required by SipBltRangeByObject.

    event           - corresponding event required by SipBltRangeByObject.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;

    *csFileChecksum = 0;

	if (0 == csFile->FileSize.QuadPart) {
		//
		// We can't call SipBltRangeByObject for empty files because it tries
		// to map them, which is illegal.  However, we know the checksum value for
		// the empty file is 0, so we'll just run with that.
		//
		SIS_MARK_POINT_ULONG(csFile);

		return STATUS_SUCCESS;
	}

    status = SipBltRangeByObject(
                csFile->DeviceObject->DeviceExtension,
                NULL,                       // srcFileObject
                csFile->UnderlyingFileHandle,
                0,                          // startingOffset,
                csFile->FileSize.QuadPart,
                eventHandle,
                event,
                NULL,                       // abortEvent,
                csFileChecksum);

    return status;
}

NTSTATUS
SipVCGetNextCSFile(
    PFILE_FIND_INFO FindInfo,
    PSIS_CS_FILE *cs)
/*++

Routine Description:

    Returns the next common store file to process.  The file is verified to have
    the proper guid style name and a valid backpointer stream header.

Arguments:

    FindInfo        - pointer to FILE_FIND_INFO structure returned from
                      SipVCInitFindFile.
    cs              - variable to receive pointer to SIS_CS_FILE structure.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    PFILE_DIRECTORY_INFORMATION dirInfo;
    UNICODE_STRING fileName;
    CSID CSid;
    PSIS_CS_FILE csFile;
    PDEVICE_EXTENSION deviceExtension = FindInfo->DeviceExtension;

    //
    // Ignore non-CS files.
    //

    for (;;) {

        //
        // Get the next file name in the directory.
        //
        status = SipVCFindNextFile(FindInfo, &dirInfo);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (dirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }

        ASSERT(dirInfo->FileNameLength < MAXUSHORT);

        fileName.Buffer = dirInfo->FileName;
        fileName.Length = fileName.MaximumLength = (USHORT) dirInfo->FileNameLength;

        if (SipFileNameToIndex(&fileName, &CSid)) {

            //
            // This is a valid CS file name.  Lookup/create a SIS object for it.
            //
            csFile = SipLookupCSFile( &CSid, 0, deviceExtension->DeviceObject);

            if (NULL == csFile) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {
                //
                // It's not marked for deletion; make sure it's open.
                //

                status = SipAcquireUFO(csFile/*,TRUE*/);

                if (!NT_SUCCESS(status)) {
                    SIS_MARK_POINT_ULONG(status);
                    return status;
                }

                if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {

#if DBG
                    if (csFile->Flags & CSFILE_FLAG_CORRUPT) {
                        ASSERT(NULL == csFile->UnderlyingFileObject);
                        ASSERT(NULL == csFile->UnderlyingFileHandle);
                        ASSERT(NULL == csFile->BackpointerStreamFileObject);
                        ASSERT(NULL == csFile->BackpointerStreamHandle);
                    }
#endif

                    if (NULL == csFile->UnderlyingFileObject) {
                        SIS_MARK_POINT_ULONG(csFile);
                        //
                        // Open the CS file.  
                        //
                        status = SipOpenCSFileWork(
                                    csFile,             // common store file to open
                                    FALSE,              // open by ID if possible
                                    FALSE,              // TRUE => don't close handles if backpointer stream is corrupt
						            FALSE,				// don't request delete access
                                    NULL);              // do complete open
                    } else {
                        //
                        // The underlying file was already open, so we just succeed.
                        //
                        status = STATUS_SUCCESS;
                    }
                }

                SipReleaseUFO(csFile);

                if (STATUS_SUCCESS == status) {

                    *cs = csFile;
                    return status;

                } else {

                    // eventlog?
#if DBG
                    if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
                        DbgPrint("SipVCGetNextCSFile: SipOpenCSFileForVolCheck failed, %x, on:\n     %0.*ws\n",
                            status,
                            fileName.Length / sizeof(WCHAR),
                            fileName.Buffer);
                    }
#endif
                }
            }

            //
            // Skip this file.
            //
            SipDereferenceCSFile(csFile);
        }
    }
}


typedef struct _CSFILE_INFO {
    PSIS_CS_FILE        CSFile;
    HANDLE              SectionHandle;
    PSIS_BACKPOINTER    BPBuffer;           // mapped buffer address
    ULONG               BufferSize;         // mapped buffer size
    ULONG               BPCount;            // # entries rounded up to sector granularity
    ULONG               BPCountAdjusted;    // # entries after compaction, sector gran
    ULONG               BPActiveCount;      // # entries after compaction, non-sector gran
} CSFILE_INFO, *PCSFILE_INFO;


NTSTATUS
SipVCMapBPStream(
    IN PSIS_CS_FILE     csFile,
    OUT PCSFILE_INFO    csInfo)
/*++

Routine Description:

    Maps the common store file's backpointer stream into memory.

Arguments:

    csFile          - the common store file to map.

    csInfo          - CSFILE_INFO structure to hold information on the mapping.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;
    ULONG bpSize;
    LARGE_INTEGER   maxSectionSize;
    PDEVICE_EXTENSION deviceExtension = csFile->DeviceObject->DeviceExtension;
    ULONG_PTR viewSize;

    csInfo->CSFile = csFile;

    //
    // Compute the size of the backpointer stream rounded up to sector
    // granularity.
    //
    bpSize = ((((csFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) *
                sizeof(SIS_BACKPOINTER)) +
                deviceExtension->FilesystemVolumeSectorSize - 1) /
                deviceExtension->FilesystemVolumeSectorSize) * 
                deviceExtension->FilesystemVolumeSectorSize;

    maxSectionSize.QuadPart = bpSize;

    csInfo->BPCount = bpSize / sizeof(SIS_BACKPOINTER);
    csInfo->BPCountAdjusted = csInfo->BPCount;
    ASSERT(bpSize % sizeof(SIS_BACKPOINTER) == 0);

    //
    // Create a section to map the stream.
    //
    status = ZwCreateSection(
                &csInfo->SectionHandle,
                SECTION_MAP_WRITE | STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY,
                NULL,
                &maxSectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                csFile->BackpointerStreamHandle);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("SIS SipVCMapBPStream: ZwCreateSection failed, %x\n", status);
#endif
        goto Error;
    }
    ASSERT(status == STATUS_SUCCESS);       // and not STATUS_PENDING or anything weird

    //
    // Make sure we map the entire stream.
    //
    csInfo->BPBuffer = NULL;
    csInfo->BufferSize = 0;

    //
    // Map in the backpointer region.
    //

    viewSize = csInfo->BufferSize;
    status = ZwMapViewOfSection(
                csInfo->SectionHandle,
                NtCurrentProcess(),
                &csInfo->BPBuffer,
                0,                          // zero bits
                0,                          // commit size (ignored for mapped files)
                0,                          // section offset
                &viewSize,
                ViewUnmap,
                0,                          // allocation type
                PAGE_READWRITE);

    if (NT_SUCCESS(status)) {

        csInfo->BufferSize = (ULONG)viewSize;
        ASSERT(status == STATUS_SUCCESS);   // and not STATUS_PENDING or anything weird
        return status;
    }

#if DBG
    DbgPrint("SIS SipVCMapBPStream: ZwMapViewOfSection failed, %x\n", status);
#endif

    status = ZwClose(csInfo->SectionHandle);
    ASSERT(STATUS_SUCCESS == status);

    csInfo->SectionHandle = NULL;

Error:

    return status;
}

NTSTATUS
SipVCUnmapBPStream(
    IN PCSFILE_INFO    csInfo)
/*++

Routine Description:

    Undoes the mapping done in SipVCMapBPStream.

Arguments:

    csInfo          - CSFILE_INFO structure filled in by SipVCMapBPStream.

Return Value:

    status of operation.

--*/
{
    NTSTATUS status;

    status = ZwUnmapViewOfSection(NtCurrentProcess(), csInfo->BPBuffer);
    ASSERT(STATUS_SUCCESS == status);

    status = ZwClose(csInfo->SectionHandle);
    ASSERT(STATUS_SUCCESS == status);

    return STATUS_SUCCESS;
}

INLINE
NTSTATUS
SipVCReadBP(
    PCSFILE_INFO        csInfo,
    ULONG               i,
    PSIS_BACKPOINTER    *bp)
/*++

Routine Description:

    Returns a pointer to the specified backpointer entry.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

    i               - index into backpointer array to find.

    bp              - variable to received pointer to desired entry.

Return Value:

    status of operation.

--*/
{
    if (i >= csInfo->BPCount) {
        return STATUS_END_OF_FILE;
    }

    *bp = &csInfo->BPBuffer[i];
    return STATUS_SUCCESS;
}

INLINE
NTSTATUS
SipVCWriteBP(
    PCSFILE_INFO        csInfo,
    ULONG               i,
    PSIS_BACKPOINTER    bp)
/*++

Routine Description:

    Overwrites the contents of the specifed backpointer entry.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

    i               - index into backpointer array to overwrite.

    bp              - pointer to SIS_BACKPOINTER structure the contents of which will
                      overwrite the specified stream entry.

Return Value:

    status of operation.

--*/
{
    ASSERT(i < csInfo->BPCount);

    if (&csInfo->BPBuffer[i] != bp) {
        csInfo->BPBuffer[i] = *bp;
    }
    return STATUS_SUCCESS;
}

#if DBG
BOOLEAN
issorted(
    PCSFILE_INFO        csInfo)
/*++

Routine Description:

    Verify the backpointer stream is properly sorted.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

Return Value:

    status of operation.

--*/
{
#define key LinkFileIndex.QuadPart
    PSIS_BACKPOINTER a = &csInfo->BPBuffer[SIS_BACKPOINTER_RESERVED_ENTRIES];
    int i, r;

    r = csInfo->BPActiveCount - 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;

    for (i=0; i < r; i++)
        if (a[i].key > a[i+1].key)
            return FALSE;
    return TRUE;
}
#endif

VOID
SipVCSort(
    PCSFILE_INFO        csInfo)
/*++

Routine Description:

    Sort the backpointer stream by link index in ascending order.

Arguments:

    csInfo          - CSFILE_INFO structure associated with the common store file.

Return Value:

    none.

--*/
{
#define key LinkFileIndex.QuadPart
    PSIS_BACKPOINTER a = &csInfo->BPBuffer[SIS_BACKPOINTER_RESERVED_ENTRIES];
    const static ULONG ha[] = {1, 8, 23, 77, 281, 1073, 4193, 16577, 65921, 262913, MAXULONG};
    SIS_BACKPOINTER v;
    ULONG i, j, h, r;
    int k;

    r = csInfo->BPActiveCount - 1 - SIS_BACKPOINTER_RESERVED_ENTRIES;

    ASSERT(r > 0 && r < MAXULONG);

    // Shell sort.  Adapted from Sedgewick, "Algorithms in C", 3rd edition

    for (k = 0; ha[k] <= r; k++)
        continue;

    while (--k >= 0) {
        h = ha[k];
        for (i = h; i <= r; i++) {
            j = i;
            if (a[i].key < a[j-h].key) {
                v = a[i];
                do {
                    a[j] = a[j-h];
                    j -= h;
                } while (j >= h && v.key < a[j-h].key);
                a[j] = v;
            }
        }
    }

#if DBG
    ASSERT(issorted(csInfo));
#endif

}

NTSTATUS
SipVCPhase1(
    PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    First phase of volume checking.  Repair backpointer stream in all
    common store files and clear backpointer check bits.

Arguments:

    deviceExtension - the D.E. for the volume to be checked

Return Value:

    status of operation.

--*/
{
    PSIS_CS_FILE csFile;
    CSFILE_INFO csInfo;
    KIRQL OldIrql;
    ULONG r, w;
    FILE_FIND_INFO FindInfo;
    LINK_INDEX maxIndexSeen;
    NTSTATUS status;
    BOOLEAN sortNeeded, corruptMaxIndex;
    SIS_BACKPOINTER dummyBP;
    PSIS_BACKPOINTER bp;
    PSIS_BACKPOINTER prevBP;
	LINK_INDEX Index;
    ULONG nScans;
#if DBG
    ULONG csFileCount = 0;
#endif

    dummyBP.LinkFileIndex.QuadPart = 0;
    dummyBP.LinkFileNtfsId.QuadPart = 0;

    //
    // Make sure the index allocator is initialized before we begin.
    //
    status = SipAllocateIndex(deviceExtension, &maxIndexSeen);

    if (STATUS_CORRUPT_SYSTEM_FILE == status) {
        //
        // We need to repair the maxIndex file.
        //
        corruptMaxIndex = TRUE;
    } else {
        ASSERT(NT_SUCCESS(status));
        corruptMaxIndex = FALSE;
    }

    maxIndexSeen.QuadPart = 0;

    //
    // Phase 1: Scan the Common Store directory.
    //          - Check for legal GUID name.  Ignore file if invalid name.
    //          - Verify that backpointer link indices are in ascending order.
    //          - Reset all backpointer check flags.
    //          - Compact the backpointer stream.
    //          - Track MaxIndex.
    //          - Don't allocate new indices.
    //
    //
    // When we're done with this phase, the backpointer stream can still
    // have duplicate link indices.  They will be fixed in the subsequent
    // phases.
    // 
    // How do we check for cross-CS file link collisions?
    // Should we handle "too big" link indices?  That is,
    // probable pending MaxIndex wrap?
    //
    status = SipVCInitFindFile(
                &FindInfo,
                deviceExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (;;) {

        status = SipVCGetNextCSFile(&FindInfo, &csFile);

        if (!NT_SUCCESS(status)) {

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase1: SipVCGetNextCSFile failed, %x\n", status);
#endif
            }

            break;
        }

        //
        // Acquire exclusive access to the backpointer stream.
        //
		SipAcquireBackpointerResource(csFile, TRUE, TRUE);

        //
        // Skip if this file has been deleted.
        //
        if (csFile->Flags & CSFILE_FLAG_DELETED) {
            goto SkipCSFile;
        }

#if DBG
        ++csFileCount;
#endif
        //
        // Map the backpointer stream into memory.
        //
        status = SipVCMapBPStream(csFile, &csInfo);

        if (!NT_SUCCESS(status)) {
            goto SkipCSFile;
        }

        nScans = 0;

Restart:
        ++nScans;                           // shouldn't have to restart more than once
        sortNeeded = FALSE;
        prevBP = &dummyBP;

        //
        // Walk the backpointer list.
        //
        for (r = w = SIS_BACKPOINTER_RESERVED_ENTRIES; ; ++r) {

            status = SipVCReadBP(&csInfo, r, &bp);

            if (STATUS_END_OF_FILE == status) {

                BOOLEAN resetMaxIndex = FALSE;

                //
                // We've processed all the backpointers.  Check MaxIndex.
                // If it's invalid, reset it to the maximum value we've
                // seen thus far.
                //
                KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);

                if (maxIndexSeen.QuadPart > deviceExtension->MaxUsedIndex.QuadPart) {

                    //
                    // MaxIndex is bogus, reset it.  Note that we
                    // have not allocated any new indices during this
                    // phase, so we haven't made the situation any worse
                    // than it was when we started.
                    //
                    // We'll now reset MaxIndex, and phase 2 will
                    // reallocate any indices for backpointers that aren't
                    // found, and phase 3 will delete the backpointers
                    // that existed but were not detected during phase 2.
                    //
                    deviceExtension->MaxUsedIndex.QuadPart = 
                    deviceExtension->MaxAllocatedIndex.QuadPart = maxIndexSeen.QuadPart + 10000;

                }

                KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

                if (r > w) {

                    ULONG d;
                    SIS_BACKPOINTER delBP;

                    //
                    // We compacted the stream.  Mark the entries at the end
                    // deleted.  We only need to go up as far as the end of
                    // the sector containing the last valid back pointer.
                    //
                    delBP.LinkFileIndex.QuadPart = MAXLONGLONG;
                    delBP.LinkFileNtfsId.QuadPart = MAXLONGLONG;

                    csInfo.BPCountAdjusted =
                          ((((w * sizeof(SIS_BACKPOINTER)) +
                          deviceExtension->FilesystemVolumeSectorSize - 1) /
                          deviceExtension->FilesystemVolumeSectorSize) *
                          deviceExtension->FilesystemVolumeSectorSize) /
                          sizeof(SIS_BACKPOINTER);

                    ASSERT(csInfo.BPCountAdjusted <= csInfo.BPCount);
                    ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);
                    ASSERT((csInfo.BPCount * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

                    for (d = csInfo.BPCountAdjusted - 1; d >= w; --d) {
                        status = SipVCWriteBP(&csInfo, d, &delBP);
                    }
                }

                csInfo.BPActiveCount = w;

                //
                // See if we need to do a sort.
                //
                if (sortNeeded) {
                    if (nScans > 1) {
                        //
                        // Should never have to sort more than once.
                        //
                        ASSERT(!"SIS: SipVCPhase1 internal error");
                        break;
                    }

                    SipVCSort(&csInfo);
                    goto Restart;
                }

                break;
            }

            //
            // We have the backpointer, now validate it.
            //
            if (MAXLONGLONG != bp->LinkFileIndex.QuadPart &&
                MAXLONGLONG != bp->LinkFileNtfsId.QuadPart &&
                0           != bp->LinkFileIndex.QuadPart &&
                0           != bp->LinkFileNtfsId.QuadPart) {

                //
                // Track the highest in-use index.
                //
                if (bp->LinkFileIndex.QuadPart > maxIndexSeen.QuadPart) {
                    maxIndexSeen = bp->LinkFileIndex;
                }

                //
                // Mark this backpointer as unreferenced.
                //
                bp->LinkFileIndex.Check = 0;

                //
                // Check for out of order backpointers.
                //
                if (bp->LinkFileIndex.QuadPart < prevBP->LinkFileIndex.QuadPart) {

                    //
                    // The backpointer list is not sorted.  This can happen if
                    // the MaxIndex wraps or is somehow corrupted.
                    //
                    sortNeeded = TRUE;

                }

                //
                // Check for duplicate and colliding link indices.  Handle them simply
                // by deleting them.  The link enumeration phase will find or add all
                // appropriate backpointers.
                //
                if (bp->LinkFileIndex.QuadPart != prevBP->LinkFileIndex.QuadPart) {

                    //
                    // Write the backpointer back to the file, compacting the list.
                    //
                    status = SipVCWriteBP(&csInfo, w, bp);
                    ASSERT(STATUS_SUCCESS == status);

                    //
                    // The value just written is the new prevBP.
                    //
                    SipVCReadBP(&csInfo, w, &prevBP);
                    ++w;
                }
            }
        }

        ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);

        ASSERT(csFile->BPStreamEntries >= csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES);

        status = SipVCUnmapBPStream(&csInfo);
        ASSERT(STATUS_SUCCESS == status);

        //
        // Truncate the stream if necessary.  Both BPCountAdjusted
        // and BPCount are sector granular counts.
        //
        if (csInfo.BPCountAdjusted < csInfo.BPCount) {
            FILE_END_OF_FILE_INFORMATION    endOfFileInfo[1];

            ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);

            csFile->BPStreamEntries = csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES;

            ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

            endOfFileInfo->EndOfFile.QuadPart = csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER);

            status = SipSetInformationFile(
                        csFile->BackpointerStreamFileObject,
                        deviceExtension->DeviceObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        endOfFileInfo);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh1: Can't truncate csFile, %x\n", status);
            }
#endif
        }

SkipCSFile:
		SipReleaseBackpointerResource(csFile);
        SipDereferenceCSFile(csFile);
    }

    //
    // If the MaxIndex file was corrupt, it will be repaired on the next call
    // to SipAllocateIndex.  Clear the corrupt flag so the call will go through.
    //
    if (corruptMaxIndex) {
        KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
        deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX;
        KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);
    }

    //
    // Allocate an index.  This will cause the MaxIndex file to be updated
    // with the new value set above (if one was set).
    //
    SipAllocateIndex(deviceExtension, &Index);

#if DBG
    DbgPrint("SIS SipVCPhase1 processed %d common store files\n", csFileCount);
#endif

    SipVCCloseFindFile(&FindInfo);
    return status;
}

#define nRPI 256
#define sizeof_ReparsePointInfo (nRPI * sizeof(FILE_REPARSE_POINT_INFORMATION))
#define INDEX_NAME_LENGTH (37*sizeof(WCHAR))    // sizeof(L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION")

UNICODE_STRING reparseIndexDir = {
    INDEX_NAME_LENGTH,
    INDEX_NAME_LENGTH,
    L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION"
};

BOOLEAN
SipRecheckPerLinks(
    PDEVICE_EXTENSION deviceExtension,
    BOOLEAN ForceLookup)
/*++

Routine Description:

    Either calls SipCheckBackpointer or forces it to be called at the next file open.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

    ForceLookup     - set to TRUE if only want to force SipCheckBackpointer to be called
                      at next open time, otherwise SipCheckBackpointer will be called
                      immediately if the backpointer has not already been verified.

Return Value:

    status of operation.

--*/
{
    PSIS_SCB scb = NULL;
    BOOLEAN retStatus = TRUE;

    //
    // Walk the list of scb's.  SipEnumerateScbList grabs a reference
    // to the returned scb for us, and releases a reference from the
    // passed in scb.
    //
    while (scb = SipEnumerateScbList(deviceExtension, scb)) {
        KIRQL OldIrql;
        BOOLEAN found;
        PSIS_CS_FILE csFile;
        PSIS_PER_LINK perLink;
        NTSTATUS status;
        int i;

        perLink = scb->PerLink;
        csFile = perLink->CsFile;

        if (ForceLookup ||
            (perLink->Flags & (SIS_PER_LINK_BACKPOINTER_VERIFIED | SIS_PER_LINK_BACKPOINTER_GONE)) == 0) {
            //
            // Take exclusive access to the backpointer stream.
            //
			SipAcquireBackpointerResource(csFile, TRUE, TRUE);
            SipAcquireScb(scb);

            if ((csFile->Flags & CSFILE_FLAG_DELETED) == 0) {
                //
                // Force a backpointer lookup.
                //
                KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                perLink->Flags &= ~SIS_PER_LINK_BACKPOINTER_VERIFIED;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                //
                // Clear the cache so it isn't found there.
                //
                for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
                    csFile->BackpointerCache[i].LinkFileIndex.QuadPart = -1;
                }

                if (!ForceLookup) {
                    //
                    // Recheck the backpointer.  This will find the check flag
                    // clear and rewrite the backpointer with the check flag set.
                    //
                    status = SipCheckBackpointer(perLink, TRUE, &found);

                    if (!NT_SUCCESS(status)) {
#if DBG
                        DbgPrint("SIS SipRecheckPerLinks: SipCheckBackpointer failed, %s\n", status);
#endif
                        retStatus = FALSE;

                    } else if (!found && (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) == 0) {
                        //
                        // This can happen if the open during phase 2 fails.  It shouldn't.
                        // NTRAID#65187-2000/03/10-nealch  Restore backpointer
                        //
                        ASSERT(!"SipRecheckPerLinks: backpointer not found.");
                    }
                }
            }

            //
            // We're done with this one.
            //
            SipReleaseScb(scb);
			SipReleaseBackpointerResource(csFile);
        }
    }

    return retStatus;
}

NTSTATUS
SipVCPhase2(
    PDEVICE_EXTENSION deviceExtension,
    BOOLEAN *verifiedAll)
/*++

Routine Description:

    Second phase of volume checking.  Enumerate all SIS link files and open
    and close them.  Normal validation/repair performed in SiCreate will
    correct any inconsistencies.  It will also set the backpointer check
    bit in the common store file for use in phase 3.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

    verifiedAll     - pointer to BOOLEAN to receive indication of whether all
                      all link files were successfully verified.  If FALSE, not
                      all link files were verified, therefore phase 3 should not
                      be run.

Return Value:

    status of operation.

--*/
{
    HANDLE hIndex = NULL, hFile;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS status;
    UNICODE_STRING reparseIndexName;
    PFILE_REPARSE_POINT_INFORMATION reparsePointInfo = NULL;
    BOOLEAN restartScan;
    BOOLEAN linkOpenFailure = FALSE;
    ULONG returnedCount;
    ULONG i;

    //
    // Phase 2: Enumerate all SIS link files.
    //          - Open/close each file.  Normal driver operation will validate
    //            reparse point information and CS backpointer as well as
    //            set the backpointer check flag.
    //
    // What do we do about errors during the scan?
    //  Ignore sharing violations (assume we already have the file open)
    //  Don't delete any CS files (err toward conservativeness.)
    //

    //
    // Force a back pointer recheck on all open per-links.
    //
    if (! SipRecheckPerLinks(deviceExtension, TRUE)) {
        linkOpenFailure = TRUE;
    }

    reparsePointInfo = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof_ReparsePointInfo,
                            ' siS');

    if (!reparsePointInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Concatenate the file system root pathname with the reparse index pathname.
    // (Yes, we should be able to open just the reparse index pathname using
    // the filesystem root handle as the parent directory, but that's not working...)
    //
    reparseIndexName.MaximumLength = deviceExtension->FilesystemRootPathname.Length +
                                     reparseIndexDir.Length;

    reparseIndexName.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    reparseIndexName.MaximumLength,
                                    ' siS');

    if (!reparseIndexName.Buffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlCopyUnicodeString(&reparseIndexName, &deviceExtension->FilesystemRootPathname);

    status = RtlAppendUnicodeStringToString(&reparseIndexName, &reparseIndexDir);
    ASSERT(STATUS_SUCCESS == status);

    InitializeObjectAttributes(
        &Obja,
        &reparseIndexName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access.
    //
    status = NtOpenFile(
                &hIndex,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &ioStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    ExFreePool(reparseIndexName.Buffer);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("SIS SipVCPhase2: reparse index open failed, %x\n", status);
#endif
        goto Error;
    }

    restartScan = TRUE;

    //
    // Loop reading a bunch of directory entries.
    //
    for (;;) {

        status = NtQueryDirectoryFile(
                        hIndex,
                        NULL,            //  Event
                        NULL,            //  ApcRoutine
                        NULL,            //  ApcContext
                        &ioStatusBlock,
                        reparsePointInfo,
                        sizeof_ReparsePointInfo,
                        FileReparsePointInformation,
                        FALSE,           //  ReturnSingleEntry
                        NULL,            //  FileName
                        restartScan );   //  RestartScan

        restartScan = FALSE;

        if (STATUS_SUCCESS != status) {

            ASSERT(STATUS_BUFFER_OVERFLOW != status);

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase2: NtQueryDirectoryFile failed, %x\n", status);
#endif
            }

            break;

        }

        returnedCount = (ULONG)ioStatusBlock.Information /
                        sizeof(FILE_REPARSE_POINT_INFORMATION);

        //
        // Loop processing each directory entry (reparse point).
        //
        for (i = 0; i < returnedCount; ++i) {

            if (IO_REPARSE_TAG_SIS == reparsePointInfo[i].Tag) {
                UNICODE_STRING  fid;

                //
                // Open/Close the SIS link.  If we get a sharing violation,
                // assume that we already have it open.
                //

                fid.Length = fid.MaximumLength = sizeof(LONGLONG);
                fid.Buffer = (PVOID) &reparsePointInfo[i].FileReference;

                InitializeObjectAttributes(
                    &Obja,
                    &fid,
                    OBJ_CASE_INSENSITIVE,
                    deviceExtension->GrovelerFileHandle,
                    NULL);

                //
                // Open the link file.  Use DesiredAccess == 0 to avoid
                // sharing violations.
                //

                status = NtCreateFile(
                            &hFile,
                            0,                  // DesiredAccess,
                            &Obja,
                            &ioStatusBlock,
                            NULL,               // Allocation size
                            0,                  // file attributes
                            0,                  // ShareAccess
                            FILE_OPEN,
                            FILE_NON_DIRECTORY_FILE |
                            //FILE_COMPLETE_IF_OPLOCKED | 
                            FILE_OPEN_BY_FILE_ID,
                            NULL,               // EA buffer
                            0);                 // EA length

                if (NT_SUCCESS(status)) {

                    NtClose(hFile);

                } else {

                    switch (status) {
                        //
                        // These errors can safely be ignored.
                        //
                    case STATUS_INVALID_PARAMETER:
                    case STATUS_OBJECT_PATH_NOT_FOUND:
                    case STATUS_SHARING_VIOLATION:
                    case STATUS_DELETE_PENDING:
#if DBG
                        DbgPrint("SIS SipVCPhase2: ignored open failure, ID: %08x%08x, status: %x\n",
                            reparsePointInfo[i].FileReference, status);
#endif
                        break;

                    default:
                        //
                        // We were unable to validate the reparse info and CS
                        // backpointer, so we cannot delete any unreferenced
                        // backpointers in any common store files nor any common
                        // store files themselves.
                        //
#if DBG
                        DbgPrint("SIS SipVCPhase2: open failure, ID: %08x%08x, status: %x\n",
                            reparsePointInfo[i].FileReference, status);
#endif
                        linkOpenFailure = TRUE;
                    }
                }
            }
        }
    }

    //
    // The open/close above should have verified all link file backpointers,
    // including those already open.  Double check that all open link
    // files have had their backpointers verified.
    //
    if (! SipRecheckPerLinks(deviceExtension, FALSE)) {
        linkOpenFailure = TRUE;
    }

Error:
    if (hIndex)
        NtClose(hIndex);
    if (reparsePointInfo)
        ExFreePool(reparsePointInfo);

    *verifiedAll = !linkOpenFailure;

    return status;
}

NTSTATUS
SipVCPhase3(
    PDEVICE_EXTENSION deviceExtension)
/*++

Routine Description:

    Third and final phase of volume checking.  Enumerate all common store
    files and delete any that have no valid backpointers.  All valid
    backpointers should have their check bit set at this point.

Arguments:

    deviceExtension - the D.E. for the volume to be checked.

Return Value:

    status of operation.

--*/
{
    PSIS_CS_FILE csFile;
    CSFILE_INFO csInfo;
    KIRQL OldIrql;
    ULONG r, w;
    FILE_FIND_INFO FindInfo;
    LINK_INDEX maxIndexSeen;
    NTSTATUS status;
    SIS_BACKPOINTER dummyBP;
    PSIS_BACKPOINTER bp;
    PSIS_BACKPOINTER prevBP;
#if DBG
    ULONG csFileCount = 0, deletedCSCount = 0;
#endif

    dummyBP.LinkFileIndex.QuadPart = 0;
    dummyBP.LinkFileNtfsId.QuadPart = 0;

    maxIndexSeen.QuadPart = 0;

    //
    // Phase 3: Scan the Common Store directory.
    //          - Check for legal GUID name.  Ignore file if invalid name.
    //          - Verify that backpointer link indices are in ascending order.
    //          - Reset all backpointer check flags.
    //          - Compact the backpointer stream.
    //          - Track MaxIndex.
    //          - Don't allocate new indices.
    //
    //
    // When we're done with this phase, the backpointer stream can still
    // duplicate link indices.  They will be fixed in the subsequent
    // phases.
    // 
    // How do we check for cross-CS file link collisions?
    // Should we handle "too big" link indices?  That is,
    // probable pending MaxIndex wrap?
    //
    status = SipVCInitFindFile(
                &FindInfo,
                deviceExtension);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (;;) {

        status = SipVCGetNextCSFile(&FindInfo, &csFile);

        if (!NT_SUCCESS(status)) {

            if (STATUS_NO_MORE_FILES == status) {
                status = STATUS_SUCCESS;
            } else {
#if DBG
                DbgPrint("SIS SipVCPhase3: SipVCGetNextCSFile failed, %x\n", status);
#endif
            }

            break;
        }

        //
        // Acquire exclusive access to the backpointer stream.
        //
		SipAcquireBackpointerResource(csFile,TRUE,TRUE);

        //
        // Skip if this file has been deleted.
        //
        if (csFile->Flags & CSFILE_FLAG_DELETED) {
            goto SkipCSFile;
        }

#if DBG
        ++csFileCount;
#endif
        //
        // Map the backpointer stream into memory.
        //
        status = SipVCMapBPStream(csFile, &csInfo);

        if (!NT_SUCCESS(status)) {
            goto SkipCSFile;
        }

        prevBP = &dummyBP;

        //
        // Walk the backpointer list.
        //
        for (r = w = SIS_BACKPOINTER_RESERVED_ENTRIES; ; ++r) {

            status = SipVCReadBP(&csInfo, r, &bp);

            if (STATUS_END_OF_FILE == status) {

                BOOLEAN resetMaxIndex = FALSE;
                LINK_INDEX Index;

                //
                // We've processed all the backpointers.  Check MaxIndex.
                // It should be valid unless corruption is occuring during
                // the volume check.
                //
                KeAcquireSpinLock(deviceExtension->IndexSpinLock, &OldIrql);

                if (maxIndexSeen.QuadPart > deviceExtension->MaxUsedIndex.QuadPart) {

                    //
                    // MaxIndex is bogus, reset it.  Note that we
                    // have not allocated any new indices during this
                    // phase, so we haven't made the situation any worse
                    // than it was when we started.
                    //
                    // We'll now reset MaxIndex, and phase 2 will
                    // reallocate any indices for backpointers that aren't
                    // found, and phase 3 will delete the backpointers
                    // that existed but were not detected during phase 2.
                    //
                    deviceExtension->MaxUsedIndex.QuadPart = 
                    deviceExtension->MaxAllocatedIndex.QuadPart = maxIndexSeen.QuadPart + 10000;

                    resetMaxIndex = TRUE;

                    //
                    // Event log
                    //

                }

                KeReleaseSpinLock(deviceExtension->IndexSpinLock, OldIrql);

                if (resetMaxIndex) {

                    //
                    // Allocate an index.  This will cause the MaxIndex file
                    // to be updated with the new value set above.
                    //

                    status = SipAllocateIndex(deviceExtension, &Index);

                    if (!NT_SUCCESS(status)) {

                        //
                        // This is bad.
                        //
                    }
                }

                if (r > w) {

                    ULONG d;
                    SIS_BACKPOINTER delBP;

                    //
                    // We compacted the stream.  Mark the entries at the end
                    // deleted.  We only need to go up as far as the end of
                    // the sector containing the last valid back pointer.
                    //
                    delBP.LinkFileIndex.QuadPart = MAXLONGLONG;
                    delBP.LinkFileNtfsId.QuadPart = MAXLONGLONG;

                    csInfo.BPCountAdjusted =
                          ((((w * sizeof(SIS_BACKPOINTER)) +
                          deviceExtension->FilesystemVolumeSectorSize - 1) /
                          deviceExtension->FilesystemVolumeSectorSize) *
                          deviceExtension->FilesystemVolumeSectorSize) /
                          sizeof(SIS_BACKPOINTER);

                    ASSERT(csInfo.BPCountAdjusted <= csInfo.BPCount);
                    ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);
                    ASSERT((csInfo.BPCount * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

                    for (d = csInfo.BPCountAdjusted - 1; d >= w; --d) {
                        status = SipVCWriteBP(&csInfo, d, &delBP);
                    }
                }

                csInfo.BPActiveCount = w;

                break;
            }

            //
            // We have the backpointer, now validate it.
            //
            if (MAXLONGLONG != bp->LinkFileIndex.QuadPart &&
                MAXLONGLONG != bp->LinkFileNtfsId.QuadPart &&
                0           != bp->LinkFileIndex.QuadPart &&
                0           != bp->LinkFileNtfsId.QuadPart) {

                //
                // If this backpointer is unreferenced, delete it.
                //
                if (0 == bp->LinkFileIndex.Check) {
                    continue;
                }

                //
                // Track the highest in-use index.
                //
                if (bp->LinkFileIndex.QuadPart > maxIndexSeen.QuadPart) {

                    maxIndexSeen = bp->LinkFileIndex;

                }

                //
                // We should not see duplicate link indices unless corruption is
                // occuring during the volume check.
                //
                if (bp->LinkFileIndex.QuadPart == prevBP->LinkFileIndex.QuadPart) {

                    // event log

                }

                //
                // We should not see out of order backpointers unless corruption is
                // occuring during the volume check.
                //
                if (bp->LinkFileIndex.QuadPart < prevBP->LinkFileIndex.QuadPart) {

                    // Event log
                }

                //
                // Write the backpointer back to the file, compacting the list.
                // Note that this doesn't actually write anything in the case
                // where r == w.
                //
                status = SipVCWriteBP(&csInfo, w, bp);
                ASSERT(STATUS_SUCCESS == status);

                SipVCReadBP(&csInfo, w, &prevBP);
                ++w;

            }
        }

        ASSERT(csInfo.BPActiveCount >= SIS_BACKPOINTER_RESERVED_ENTRIES);
        ASSERT(csFile->BPStreamEntries >= csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES);

        status = SipVCUnmapBPStream(&csInfo);
        ASSERT(STATUS_SUCCESS == status);

        csFile->BPStreamEntries = csInfo.BPActiveCount - SIS_BACKPOINTER_RESERVED_ENTRIES;

        //
        // Delete the common store file if there are no references to it.
        //
        if (0 == csFile->BPStreamEntries) {

            status = SipDeleteCSFile(csFile);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh3: Can't delete csFile, %x\n", status);
            }

            ++deletedCSCount;
#endif
        } else if (csInfo.BPCountAdjusted < csInfo.BPCount) {

            //
            // Truncate the stream.  Both BPCountAdjusted
            // and BPCount are sector granular counts.
            //
            FILE_END_OF_FILE_INFORMATION    endOfFileInfo[1];

            ASSERT((csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER)) % deviceExtension->FilesystemVolumeSectorSize == 0);

            endOfFileInfo->EndOfFile.QuadPart = csInfo.BPCountAdjusted * sizeof(SIS_BACKPOINTER);

            status = SipSetInformationFile(
                        csFile->BackpointerStreamFileObject,
                        deviceExtension->DeviceObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        endOfFileInfo);

#if DBG
            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                DbgPrint("SIS VCPh3: Can't truncate csFile, %x\n", status);
            }
#endif
        }

SkipCSFile:
		SipReleaseBackpointerResource(csFile);
        SipDereferenceCSFile(csFile);
    }

#if DBG
    DbgPrint("SIS SipVCPhase3 processed %d common store files, deleted %d.\n", csFileCount, deletedCSCount);
#endif

    SipVCCloseFindFile(&FindInfo);
    return status;
}

VOID
SiVolumeCheckThreadStart(
    IN PVOID        context)
/*++

Routine Description:

    A thread to handle SIS volume check operations.  This thread is created to
    perform a volume check on one volume, and when it completes it terminates.
    It synchronizes with nothing.

Arguments:

    context - Pointer to the device extension needing the volume check.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION       deviceExtension = context;
    NTSTATUS                status;
    KIRQL                   OldIrql;
    OBJECT_ATTRIBUTES       Obja[1];
    IO_STATUS_BLOCK         Iosb[1];
    UNICODE_STRING          fileName;
    BOOLEAN                 verifiedAll;
    HANDLE                  vHandle = NULL;

	if (!SipCheckPhase2(deviceExtension)) {
		//
		// SIS can't initialize, so just give up.
		//
		SIS_MARK_POINT();

	    PsTerminateSystemThread(STATUS_SUCCESS);
	}

    //
    // Create the volume check indicator file in the common store directory
    // so that if we crash before we finish, we'll restart on next reboot.
    // (A file is preferred over a registry entry in case the volume is moved
    // before rebooting.)
    //
    fileName.MaximumLength = 
        deviceExtension->CommonStorePathname.Length
        + SIS_VOLCHECK_FILE_STRING_SIZE
        + sizeof(WCHAR);

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' siS');

    if (NULL != fileName.Buffer) {

        RtlCopyUnicodeString(&fileName, &deviceExtension->CommonStorePathname);
        RtlAppendUnicodeToString(&fileName, SIS_VOLCHECK_FILE_STRING);

        InitializeObjectAttributes(
                Obja,
                &fileName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

        status = ZwCreateFile(
                &vHandle,
                DELETE,
                Obja,
                Iosb,
                NULL,                   // Allocation size
                FILE_ATTRIBUTE_NORMAL,  // file attributes
                0,                      // share mode
                FILE_OPEN_IF,           // always create
                0,                      // create options
                NULL,                   // EA buffer
                0);                     // EA length

        ExFreePool(fileName.Buffer);

        if (!NT_SUCCESS(status)) {
            vHandle = NULL;
#if DBG
            DbgPrint("SIS SipCheckVolume unable to create indicator file, %s\n", status);
#endif
        }
    }

    //
    // Phase 1: Scan the Common Store directory.
    //

    status = SipVCPhase1(deviceExtension);

    //
    // Phase 2: Enumerate all SIS link files.
    //

    status = SipVCPhase2(deviceExtension, &verifiedAll);

    //
    // Turn off the no-delete flag.  During phase 1 & phase 2, the no-delete
    // flag prevented common store files from being deleted during normal
    // driver operation.  It is now safe (and is necessary) to turn this flag
    // off now.
    // The exlusive flag instructs SiCreate to acquire the backpointer
    // resource exclusive rather than shared, since it is likely that it
    // will have to write the backpointer back to the stream during a volume
    // check.
    //

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
    deviceExtension->Flags &= ~(SIP_EXTENSION_FLAG_VCHECK_NODELETE | SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE);
    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // Phase 3: Scan the Common Store directory again.
    //

    if (verifiedAll) {
        status = SipVCPhase3(deviceExtension);
    } else {
        
        // eventlog

#if DBG
        DbgPrint("SIS: Volume Check skipping CS delete phase\n");
#endif
    }

    //
    // Done.  Delete the volume check indicator file, turn off the volume check
    // enabled flag and terminate this thread.
    //
    if (vHandle) {
        FILE_DISPOSITION_INFORMATION disposition[1];

        disposition->DeleteFile = TRUE;

        status = ZwSetInformationFile(
                        vHandle,
                        Iosb,
                        disposition,
                        sizeof(FILE_DISPOSITION_INFORMATION),
                        FileDispositionInformation);
#if DBG
        if (STATUS_SUCCESS != status) {
            DbgPrint("SIS: SipCheckVolume can't delete indicator file, %x\n", status);
        }
#endif
        ZwClose(vHandle);
    }

    // eventlog

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);

    deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_VCHECK_PENDING;

    ASSERT((deviceExtension->Flags &
                (SIP_EXTENSION_FLAG_VCHECK_PENDING |
                 SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE |
                 SIP_EXTENSION_FLAG_VCHECK_NODELETE)) == 0);

    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

#if DBG
    DbgPrint("SIS: SipCheckVolume complete.\n");
#endif

    PsTerminateSystemThread(STATUS_SUCCESS);
}

NTSTATUS
SipCheckVolume(
    IN OUT PDEVICE_EXTENSION            deviceExtension)
/*++

Routine Description:

    Initiates a full volume check for the specified volume.  This call returns
    before the volume check completes.

Arguments:

    deviceExtension - the D.E. for the volume to be checked

Return Value:

    None.

--*/
{
    KIRQL                   OldIrql;
    ULONG                   fl;
    NTSTATUS                status;
    HANDLE                  threadHandle;
    OBJECT_ATTRIBUTES       oa;

    SIS_MARK_POINT();

    //
    // Indicate we're doing a volume check.
    //
    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);

    fl = deviceExtension->Flags;

    if ((fl & SIP_EXTENSION_FLAG_VCHECK_PENDING) == 0) {
        deviceExtension->Flags |= 
            SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE |
            SIP_EXTENSION_FLAG_VCHECK_PENDING |
            SIP_EXTENSION_FLAG_VCHECK_NODELETE;
    }

    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // If we're currenty running a volume check, do nothing.
    //
    if (fl & SIP_EXTENSION_FLAG_VCHECK_PENDING) {
        return STATUS_SUCCESS;
    }

#if DBG
    DbgPrint("SIS: SipCheckVolume starting.\n");
    if (BJBDebug & 0x00080000) {
        ASSERT(!"Volume Check");
    }
#endif

    //
    // Create a thread which will do the volume check and terminate when
    // it's complete.
    //
    InitializeObjectAttributes (&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    status = PsCreateSystemThread(
                    &threadHandle,
                    THREAD_ALL_ACCESS,
                    &oa,                // Object Attributes
                    NULL,               // Process (NULL => PsInitialSystemProcess)
                    NULL,               // Client ID
                    SiVolumeCheckThreadStart,
                    deviceExtension);   // context

    if (NT_SUCCESS (status)) {
       status = ZwClose (threadHandle);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sicalls.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sicalls.c

Abstract:

	Routines to make calls into the underlying file system for the
	Single Instance Store.  Generally, these are similar to the
	similar Zw calls, but they take file objects rather than handles
	and call down directly to the driver below SIS rather than going
	through the entire stack.

Authors:

    Bill Bolosky & Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// Context used to communicate between SipQueryInformationFile and
// SiQueryInformationCompleted.
//
typedef struct _SI_QUERY_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_QUERY_COMPLETION_CONTEXT, *PSI_QUERY_COMPLETION_CONTEXT;

NTSTATUS
SiQueryInformationCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipQueryInformationFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_QUERY_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_QUERY_COMPLETION_CONTEXT completionContext = (PSI_QUERY_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipQueryInformationFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN ULONG 					InformationClass,
    IN ULONG 					Length,
    OUT PVOID 					Information,
    OUT PULONG					ReturnedLength		OPTIONAL
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.  This call sends the
	irp directly to the driver immediately below SIS, so the file object
	must be something that's understood by the stack beneath SIS.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    InformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    Information - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipQueryInformationFileUsingGenericDevice(
				FileObject,
				deviceExtension->AttachedToDeviceObject,
				InformationClass,
				Length,
				Information,
				ReturnedLength);
}

NTSTATUS
SipQueryInformationFileUsingGenericDevice(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN ULONG 					InformationClass,
    IN ULONG 					Length,
    OUT PVOID 					Information,
    OUT PULONG					ReturnedLength		OPTIONAL
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    InformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    Information - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	SI_QUERY_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.  Set a valid return Length.
        //

	    if (NULL != ReturnedLength) {
	        *ReturnedLength = 0;
	    }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = Information;
    irp->Flags = IRP_BUFFERED_IO;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

	IoSetCompletionRoutine(
			irp,
			SiQueryInformationCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

	if (NULL != ReturnedLength) {
	    *ReturnedLength = (ULONG)completionContext->Iosb->Information;
	}
    return status;
}

//
// Context used to communicate between SipSetInformationFile and
// SiSetInformationCompleted.
//
typedef struct _SI_SET_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_SET_COMPLETION_CONTEXT, *PSI_SET_COMPLETION_CONTEXT;


NTSTATUS
SiSetInformationCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipSetInformationFileUsingGenericDevice.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_SET_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_SET_COMPLETION_CONTEXT completionContext = (PSI_SET_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipSetInformationFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN FILE_INFORMATION_CLASS	InformationClass,
    IN ULONG 					Length,
    IN PVOID 					Information
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

	All this routine really does is to pull the filesystem device object
	out of the SIS device extension and pass it into the generic version
	of set information file.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

	DeviceObject - the SIS device object for the device on which this file
		lies.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipSetInformationFileUsingGenericDevice(
				FileObject,
				deviceExtension->AttachedToDeviceObject,
				InformationClass,
				Length,
				Information);
}

NTSTATUS
SipSetInformationFileUsingGenericDevice(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject,
    IN FILE_INFORMATION_CLASS	InformationClass,
    IN ULONG 					Length,
    IN PVOID 					Information
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the class that is specified,
    and it is placed into the caller's output buffer.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	SI_SET_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

	ASSERT(InformationClass != FilePositionInformation);	// This call isn't supported in this routine
	ASSERT(InformationClass != FileTrackingInformation);	// This call isn't supported in this routine
	ASSERT(InformationClass != FileModeInformation);		// This call isn't supported in this routine
	ASSERT(InformationClass != FileCompletionInformation);	// This call isn't supported in this routine

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;

	irp->Flags = IRP_SYNCHRONOUS_API;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;
	if (FileDispositionInformation == InformationClass) {
		//
		// Auditing code needs to know the handle used for a delete.
		// We're in kernel mode, so we don't need to provide one.
		// Null out the field.
		//
		irpSp->Parameters.SetFile.DeleteHandle = NULL;
	}

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = Information;

    irp->Flags |= IRP_BUFFERED_IO;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = InformationClass;

	IoSetCompletionRoutine(
			irp,
			SiSetInformationCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

    return status;
}


//
// Context used to communicate between SipFsControlFile and
// SiFsControlCompleted.
//

#if DBG
//used to detect if we are returning from IOCallDriver without STATUS_PENDING
//being returned but with the completion routine not yet called.
#define SIMAGIC_INIT        0xBad4Babe
#define SIMAGIC_COMPLETED   0xBad2Babe
#endif

typedef struct _SI_FS_CONTROL_COMPLETION_CONTEXT {

#if DBG
        ULONG               magic;
#endif

		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];

} SI_FS_CONTROL_COMPLETION_CONTEXT, *PSI_FS_CONTROL_COMPLETION_CONTEXT;

NTSTATUS
SiFsControlCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipQueryInformationFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done, copy the output
	data into the caller's buffer if appropriate, and free the irp

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_FS_CONTROL_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_FS_CONTROL_COMPLETION_CONTEXT completionContext = (PSI_FS_CONTROL_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

    ASSERT(completionContext->magic == SIMAGIC_INIT);
	*completionContext->Iosb = Irp->IoStatus;

	//
	// Handle cleanup processing for buffered IO.
	//
	if (Irp->Flags & IRP_BUFFERED_IO) {
		if (Irp->Flags & IRP_INPUT_OPERATION &&
			Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
			!NT_ERROR(Irp->IoStatus.Status)) {

            //
            // Copy the information from the system buffer to the caller's
            // buffer.  We don't need to worry about problems with the copy
			// because only KernelMode callers can use this interface.
            //

            RtlCopyMemory( Irp->UserBuffer,
                           Irp->AssociatedIrp.SystemBuffer,
                           Irp->IoStatus.Information );
		}

        //
        // Free the buffer if needed.
        //

        if (Irp->Flags & IRP_DEALLOCATE_BUFFER) {
            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        }

	}

#if DBG
    completionContext->magic = SIMAGIC_COMPLETED;
#endif

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipFsControlFile(
	IN PFILE_OBJECT				fileObject,
	IN PDEVICE_OBJECT			DeviceObject,
	IN ULONG					ioControlCode,
	IN PVOID					inputBuffer,
	IN ULONG					inputBufferLength,
	OUT PVOID					outputBuffer,
	IN ULONG					outputBufferLength,
	OUT PULONG					returnedOutputBufferLength	OPTIONAL)
/*++

Routine Description:

	Call a file system control given a file object.  This file object must
	be recognized by the components underlying SIS on the driver stack.

Arguments:
    FileObject - Supplies a pointer to the file object on which to make the
		fsctl call

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

	ioControlCode - The fsctl itself

	inputBuffer	- pointer to the buffer containing input data for the fsctl.  May be
			NULL is inputBufferLength is zero

	inputBufferLength - the size of the input buffer

	outputBuffer - buffer into which to place the data returned from the fsctl call.
		May be NULL is outputBufferLength is 0.

	outputBufferLength - the length of the output buffer.

	returnedOutputBufferLength - the actual count of bytes returned by the fsctl call.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PDEVICE_EXTENSION	deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

	return SipFsControlFileUsingGenericDevice(
				fileObject,
				deviceExtension->AttachedToDeviceObject,
				ioControlCode,
				inputBuffer,
				inputBufferLength,
				outputBuffer,
				outputBufferLength,
				returnedOutputBufferLength);
}


NTSTATUS
SipFsControlFileUsingGenericDevice(
	IN PFILE_OBJECT				fileObject,
	IN PDEVICE_OBJECT			DeviceObject,
	IN ULONG					ioControlCode,
	IN PVOID					inputBuffer,
	IN ULONG					inputBufferLength,
	OUT PVOID					outputBuffer,
	IN ULONG					outputBufferLength,
	OUT PULONG					returnedOutputBufferLength	OPTIONAL)
/*++

Routine Description:

	Call a file system control given a file object.

Arguments:
    FileObject - Supplies a pointer to the file object on which to make the
		fsctl call

	DeviceObject - The device object onto which to make the call.  This must be
		an appropriate device for the given file.

	ioControlCode - The fsctl itself

	inputBuffer	- pointer to the buffer containing input data for the fsctl.  May be
			NULL is inputBufferLength is zero

	inputBufferLength - the size of the input buffer

	outputBuffer - buffer into which to place the data returned from the fsctl call.
		May be NULL is outputBufferLength is 0.

	outputBufferLength - the length of the output buffer.

	returnedOutputBufferLength - the actual count of bytes returned by the fsctl call.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
	PIO_STACK_LOCATION					irpSp;
	PIRP								irp;
	SI_FS_CONTROL_COMPLETION_CONTEXT	completionContext[1];
	NTSTATUS							status;
	ULONG								method;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(IoGetRelatedDeviceObject(fileObject) == IoGetAttachedDevice(DeviceObject));

#if		DBG
	if ((BJBDebug & 0x00800000) && (FSCTL_SET_REPARSE_POINT == ioControlCode)) {
		//
		// Fail the call for debugging 
		//
		DbgPrint("SIS: SipFsControlFile: intentionally failing FSCTL_SET_REPARSE_POINT for debugging reasons\n");
		return STATUS_UNSUCCESSFUL;
	}
#endif	// DBG

	//
	// Temporary hack: we need to do FSCTL_SET_REPARSE_POINT and FSCTL_DELETE_REPARSE_POINT on file objects
	// that the user opened read only.  In order to get NTFS to do this, we set the WriteAccess bit in the file
	// object.  Remove this hack once there's a more permanent fix in NTFS.
	//
	// We also now need to do this for FSCTL_SET_SPARSE.
	//
	if ((FSCTL_SET_REPARSE_POINT == ioControlCode) || (FSCTL_DELETE_REPARSE_POINT == ioControlCode) ||
		(FSCTL_SET_SPARSE == ioControlCode)) {
		fileObject->WriteAccess = TRUE;
	}

	//
	// The method is the input/output method of the IO control.  It is the low
	// two bits of the IO control code.
	//
	method = ioControlCode & 3;

	irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

	if (!irp) {
		SIS_MARK_POINT();
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

	irp->UserEvent = NULL;
	irp->UserIosb = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
	irpSp->FileObject = fileObject;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = outputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = inputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = ioControlCode;

    irp->MdlAddress = (PMDL) NULL;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

	switch (method) {
		case 0:
				if (inputBufferLength || outputBufferLength) {
					irp->AssociatedIrp.SystemBuffer = 
						ExAllocatePoolWithTag(NonPagedPool, 
							(inputBufferLength > outputBufferLength) ? inputBufferLength : outputBufferLength,
							' siS');

					if (irp->AssociatedIrp.SystemBuffer == NULL) {
						IoFreeIrp(irp);
						return STATUS_INSUFFICIENT_RESOURCES;
					}

					if (ARGUMENT_PRESENT(inputBuffer)) {
						RtlCopyMemory(	irp->AssociatedIrp.SystemBuffer,
										inputBuffer,
										inputBufferLength);
					}
					irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
					irp->UserBuffer = outputBuffer;

					if (ARGUMENT_PRESENT(outputBuffer)) {
						irp->Flags |= IRP_INPUT_OPERATION;
					}
				} else {
					irp->Flags = 0;
					irp->UserBuffer = NULL;
				}
				break;
		case 1:
		case 2:
				ASSERT(FALSE && "WRITEME");
		case 3:
				irpSp->Parameters.DeviceIoControl.Type3InputBuffer = inputBuffer;
				irp->Flags = 0;
				irp->UserBuffer = outputBuffer;
				break;
		default:
			ASSERT(FALSE && "SIS: SipFsControlFile: bogus method number\n");
	}

#if DBG
    completionContext->magic = SIMAGIC_INIT;
#endif
	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

	IoSetCompletionRoutine(
			irp,
			SiFsControlCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);
			
	status = IoCallDriver(DeviceObject, irp);

	if (status == STATUS_PENDING) {

		status = KeWaitForSingleObject(completionContext->event,Executive,KernelMode,FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = completionContext->Iosb->Status;
	}

#if DBG
    ASSERT(completionContext->magic == SIMAGIC_COMPLETED);
    if (completionContext->magic != SIMAGIC_COMPLETED) {    //wait for completion routine

		DbgPrint("SIS: SipFsControlFile: waiting for completion routine!\n");
		status = KeWaitForSingleObject(completionContext->event,Executive,KernelMode,FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = completionContext->Iosb->Status;
    }
#endif

	SIS_MARK_POINT_ULONG(completionContext->Iosb->Information);

	if (NULL != returnedOutputBufferLength) {
		*returnedOutputBufferLength =
            (ULONG)completionContext->Iosb->Information;
	}

#if DBG
    completionContext->magic = 0;   //mark it as freed
#endif
	return status;
	
}


//
// Context used to communicate between SipFlushBuffersFile and
// SiFlushBuffersCompleted.
//
typedef struct _SI_FLUSH_COMPLETION_CONTEXT {
		//
		// An event to indicate that the irp has completed.
		//
		KEVENT				event[1];

		//
		// The status copied out of the completed irp.
		//
		IO_STATUS_BLOCK		Iosb[1];
} SI_FLUSH_COMPLETION_CONTEXT, *PSI_FLUSH_COMPLETION_CONTEXT;

NTSTATUS
SiFlushBuffersCompleted(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
	)
/*++

Routine Description:

	IO completion routine for Irps generated by SipFlushBuffersFile.
	Since this irp originated with SIS, there is no place to pass it up
	to.  So, we copy the completion status into a return buffer, set
	an event indicating that the operation is done and free the irp.

Arguments:
	DeviceObject	- For the SIS device

	Irp				- The irp that's completing

	Context			- Pointer to a SI_FLUSH_COMPLETION_CONTEXT; see the
						definition for a description of the contents.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSI_QUERY_COMPLETION_CONTEXT completionContext = (PSI_QUERY_COMPLETION_CONTEXT)Context;

	UNREFERENCED_PARAMETER(DeviceObject);

	*completionContext->Iosb = Irp->IoStatus;

	KeSetEvent(completionContext->event,IO_NO_INCREMENT,FALSE);

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipFlushBuffersFile(
    IN PFILE_OBJECT 			FileObject,
	IN PDEVICE_OBJECT			DeviceObject
    )

/*++

Routine Description:

	This routine flushes the cache for a given file object.  It is
	synchronous; it doesn't return until the flush is completed.

Arguments:
    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

	DeviceObject - the SIS device object for the device on which this file
		lies.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP 							irp;
    NTSTATUS 						status;
    PIO_STACK_LOCATION 				irpSp;
	PDEVICE_EXTENSION				deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	SI_FLUSH_COMPLETION_CONTEXT		completionContext[1];

    PAGED_CODE();

	ASSERT(IoGetRelatedDeviceObject(FileObject) == IoGetAttachedDevice(DeviceObject));
	ASSERT(!(FileObject->Flags & FO_STREAM_FILE));	// can't do this stuff on stream files

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceExtension->AttachedToDeviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = (PKEVENT) NULL;
    irp->UserIosb = completionContext->Iosb;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = FileObject;

    irp->Flags = IRP_SYNCHRONOUS_API;

	KeInitializeEvent(completionContext->event,NotificationEvent,FALSE);

    //
    // The flush buffers irp doesn't have any parameters.
    //

	IoSetCompletionRoutine(
			irp,
			SiFlushBuffersCompleted,
			completionContext,
			TRUE,
			TRUE,
			TRUE);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceExtension->AttachedToDeviceObject, irp );

    //
    // Wait for the operation to complete and obtain the final status from
    // the completion context, which gets it from the completed irp.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( completionContext->event,
                                        Executive,
                                        KernelMode,
										FALSE,
                                        NULL );
        status = completionContext->Iosb->Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siclnup.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siclnup.c

Abstract:

	Cleanup routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#endif	// ALLOC_PRAGMA


void
SipCheckOverwrite(
    IN PSIS_PER_FILE_OBJECT perFO,
    IN PSIS_SCB             scb,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine determines if the file has been completely overwritten,
    and if it has, it removes the SIS reparse point to convert the
    file back to non-SIS state.

Arguments:

    perFO - pointer to the file's perFO structure.

    scb - pointer to the primary scb of the perFO.

    DeviceObject - Pointer to this driver's device object.

Return Value:

    None.

--*/

{
    PSIS_PER_LINK           perLink;
    KIRQL                   OldIrql;
    NTSTATUS                status;

    perLink = scb->PerLink;

    //
    // If the file has been completely overwritten, remove the reparse point
    // now to avoid having to reopen the file later.
    //

    if ((perLink->Flags & (SIS_PER_LINK_DIRTY|
                           SIS_PER_LINK_BACKPOINTER_GONE|
						   SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|
                           SIS_PER_LINK_FINAL_COPY|
                           SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

        SIS_RANGE_STATE     rangeState;
        LONGLONG            rangeLength;
        BOOLEAN             foundRange;
        BOOLEAN             overwritten;
        PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

        SipAcquireScb(scb);

        if ((perLink->Flags & SIS_PER_LINK_OVERWRITTEN) ||
            scb->SizeBackedByUnderlyingFile == 0) {

            overwritten = TRUE;

        } else {

            foundRange = SipGetRangeEntry(
                            deviceExtension,
                            scb,
                            0,                      // starting offset
                            &rangeLength,
                            &rangeState);
            
            overwritten = foundRange &&
                          rangeState == Written &&
                          rangeLength >= scb->SizeBackedByUnderlyingFile;

        }

        SipReleaseScb(scb);

        if (overwritten) {

            BOOLEAN     tagRemoved = FALSE;
            BOOLEAN     wakeupNeeded;

            //
            // The file has been completely overwritten.  See if
            // another thread sneaked in and did final copy for us, or
			// deleted the file.
            //

            KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

            if ((perLink->Flags & (SIS_PER_LINK_DIRTY|
                                   SIS_PER_LINK_BACKPOINTER_GONE|
								   SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|
                                   SIS_PER_LINK_FINAL_COPY|
                                   SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

                perLink->Flags |= SIS_PER_LINK_OVERWRITTEN | SIS_PER_LINK_FINAL_COPY;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

            } else {

				//
				// Someone else has already dealt with this file.  Just mark it overwritten so that
				// we won't have to check ranges in the future and punt.
				//

                perLink->Flags |= SIS_PER_LINK_OVERWRITTEN;
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                return;

            }

            //
            // Prepare to change the CS file reference count.  We need to do this
            // before we can delete the reparse point.
            //
            status = SipPrepareCSRefcountChange(
						perLink->CsFile,
						&perLink->Index,
						&perLink->LinkFileNtfsId,
						SIS_REFCOUNT_UPDATE_LINK_DELETED);

            //
            // Abort if the prepare failed.
            //

            if (NT_SUCCESS(status)) {

                PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
                UCHAR                   ReparseBuffer[SIS_REPARSE_DATA_SIZE];

                //
                // Now, delete the reparse point.  We need to set the "can ignore" flag
                // in the per-link first so that any creates that happen once we delete the
                // reparse point don't cause problems later on.
                //

                ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
                ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SIS;
                ReparseBufferHeader->ReparseDataLength = 0;
                ReparseBufferHeader->Reserved = 0xcabd; // ???

                SIS_MARK_POINT_ULONG(scb);

                status = SipFsControlFile(
                            perFO->fileObject,
                            deviceExtension->DeviceObject,
                            FSCTL_DELETE_REPARSE_POINT,
                            ReparseBuffer,
                            FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
                            NULL,									// output buffer
                            0,										// output buffer length
							NULL);									// returned output buffer length

                ASSERT(status != STATUS_PENDING);

                if (NT_SUCCESS(status)) {
                    tagRemoved = TRUE;

                }
        #if     DBG
                if (!tagRemoved) {
                    SIS_MARK_POINT_ULONG(status);
					if ((!(perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE)) && (STATUS_NOT_A_REPARSE_POINT != status)) {
	                    DbgPrint("SIS: SipCheckOverwrite: FSCTL_DELETE_REPARSE_POINT failed %x%s pl %x fo %x\n",
    	                    status, (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? " (Deleted)" : "", perLink, perFO->fileObject);
					}
                }
        #endif

				SIS_MARK_POINT_ULONG(perLink->CsFile);

                status = SipCompleteCSRefcountChange(
							perLink,
							&perLink->Index,
							perLink->CsFile,
							tagRemoved,
							FALSE);

                if (!NT_SUCCESS(status)) {
                    SIS_MARK_POINT_ULONG(status);
        #if     DBG
                    DbgPrint("SIS: SipCheckOverwrite: complete failed 0x%x\n",status);
        #endif  // DBG
                }

                SIS_MARK_POINT_ULONG(tagRemoved);

            } else {

                //
                // The prepare failed--abort.
                //
                SIS_MARK_POINT_ULONG(status);

        #if     DBG
                DbgPrint("SIS: SipCheckOverwrite: prepare failed 0x%x\n",status);
        #endif  // DBG

            }

            //
            // Wake up any threads that are waiting on us.
            //

            KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

            wakeupNeeded = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS) != 0;

            if (tagRemoved) {

        #if     DBG
                //DbgPrint("SIS: SipCheckOverwrite: FinalCopy performed, pl %x fo %x scb %x\n", perLink, perFO->fileObject, scb);
        #endif  // DBG

                perLink->Flags |= SIS_PER_LINK_FINAL_COPY_DONE;
            }

            perLink->Flags &= ~(SIS_PER_LINK_FINAL_COPY_WAITERS|SIS_PER_LINK_FINAL_COPY);

            KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

            if (wakeupNeeded) {
                KeSetEvent(perLink->Event, IO_NO_INCREMENT, FALSE);
            }

        }

    }

}


NTSTATUS
SiCleanupCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	IRP completion routine for SiCleanup for SIS files in certain circumstances.
	Re-synchronizes with the calling thread by clearing PendingReturned and setting
	an event.

Arguments:

    DeviceObject - Pointer to this driver's device object.

	Irp			 - The IRP that's completing

	Context		 - pointer to the event to set to indicate completion

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT			event = (PKEVENT)Context;

    UNREFERENCED_PARAMETER( DeviceObject );

	//
	// We're re-syncing with the calling site, so clear PendingReturned.
	//
	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

#if		DBG
	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		DbgPrint("SIS: SiCleanupCompletion: cleanup failed 0x%x\n",Irp->IoStatus.Status);
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
	}
#endif	// DBG

	return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
SiCleanup(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp
	)
/*++

Routine Description:

	General SIS Irp dispatch routine for cleanup irps.  For SIS files, handle stuff like
	lock cleanup and delete processing.  If this is the last handle to the file (ie.,
	cleanup count is 0) then deal with delete processing, and if appropriate kick off a
	final copy.

Arguments:

    DeviceObject - Pointer to this driver's device object.

	Irp			 - The cleanup IRP

Return Value:

	status of the cleanup returned from NTFS

--*/
{
	PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT 				fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT 		perFO;
	PSIS_SCB					scb;
	NTSTATUS 					status;
	PIO_STACK_LOCATION			nextIrpSp;
	PDEVICE_EXTENSION			deviceExtension = DeviceObject->DeviceExtension;
	LONG						uncleanCount;
	KIRQL						OldIrql;
	BOOLEAN						uncleanup;
	BOOLEAN						deleteOnClose;
	BOOLEAN						deletingFile;
	BOOLEAN						finalCopyDone;
	PSIS_PER_LINK				perLink;
	BOOLEAN 					dirty;
	BOOLEAN						abortDelete;
	KEVENT						event[1];
	BOOLEAN						prepared;
	BOOLEAN						startFinalCopy;
	BOOLEAN						anythingInCopiedFile;

    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindAny,&perFO,&scb)) {
        return SiPassThrough(DeviceObject,Irp);
	}

	perLink = scb->PerLink;

	nextIrpSp = IoGetNextIrpStackLocation(Irp);

	SIS_MARK_POINT_ULONG(scb);
	SIS_MARK_POINT_ULONG(perFO);

    //
    // If the file has been completely overwritten, convert it back to a
    // non-SIS file now.
    //

    SipCheckOverwrite(perFO, scb, DeviceObject);

	SipAcquireScb(scb);

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

	uncleanup = (perFO->Flags & SIS_PER_FO_UNCLEANUP) ? TRUE : FALSE;
	deleteOnClose = (perFO->Flags & SIS_PER_FO_DELETE_ON_CLOSE) ? TRUE : FALSE;
#if		DBG
	//
	// Assert that we're not seeing two cleanups on the same file object.
	//
	ASSERT(!uncleanup || !(perFO->Flags & SIS_PER_FO_CLEANED_UP));
	perFO->Flags |= SIS_PER_FO_CLEANED_UP;
#endif	// DBG

	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

#if		DBG
	if (BJBDebug & 0x20) {
		DbgPrint("SIS: SipCommonCleanup: scb %p, uncleanup %d, uncleancount %d\n",scb,uncleanup,perFO->fc->UncleanCount);
	}
#endif	// DBG

	if (!uncleanup) {
		//
		// We're seeing a cleanup on a file object for which we didn't see a
		// corresponding create.  This most often happens during stress when someone
		// opens a file that's in the process of being created/turned into a SIS
		// link by copyfile.  Even though copyfile opens the files exclusively,
		// it's possible to open them if the user asks for no permission, and then
		// the file object created by copyfile will show up here.  This is benign.
		//
		SipReleaseScb(scb);

#if		DBG
		if (BJBDebug & 0x40000) {
			DbgPrint("SIS: SipCommonCleanup: ignoring cleanup on unexpected file object %p\n",fileObject);
		}
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);
		SIS_MARK_POINT_ULONG(fileObject);
		SIS_MARK_POINT_ULONG(perFO);
		return SiPassThrough(DeviceObject,Irp);
	}
	SipReleaseScb(scb);

	//  Unlock all outstanding file locks.
			
	(VOID) FsRtlFastUnlockAll( &scb->FileLock,
							   fileObject,
							   IoGetRequestorProcess( Irp ),
							   NULL );
	SipAcquireScb(scb);

	// GCH: To do: Make sure all cleanups come through here.
    uncleanCount = InterlockedDecrement(&perFO->fc->UncleanCount);

	ASSERT(uncleanCount >= 0);

	if (uncleanCount == 0) {

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		deletingFile = ((perLink->Flags & SIS_PER_LINK_DELETE_DISPOSITION_SET) ? TRUE : FALSE) || deleteOnClose;
		dirty = (perLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
		finalCopyDone = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		anythingInCopiedFile = (scb->Flags & SIS_SCB_ANYTHING_IN_COPIED_FILE) ? TRUE : FALSE;

		SipReleaseScb(scb);

		if (deletingFile) {
			status = SipPrepareCSRefcountChange(
						perLink->CsFile,
						&perLink->Index,
						&perLink->LinkFileNtfsId,
						SIS_REFCOUNT_UPDATE_LINK_DELETED);

			prepared = NT_SUCCESS(status);

			SIS_MARK_POINT_ULONG(status);
			//
			// Mark the link as FINAL_DELETE_IN_PROGRESS, which will prevent
			// the file from being opened (causing it to fail with 
			// STATUS_ACCESS_DENIED).  We need to do this after the
			// prepare in order to properly serialize with supersede/overwrite
			// creates.  Also, if the DELETED flag is already set, then the file
			// was probably destroyed by overwrite/supersede, and so we'll just abort
			// the refcount change.
			//
			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			if (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) {
				abortDelete = TRUE;
			} else {
				abortDelete = FALSE;
				perLink->Flags |= SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS;
			}
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (abortDelete) {
				SIS_MARK_POINT_ULONG(scb);
#if DBG && 0
	            DbgPrint("SipCommonCleanup: aborting refcount change, fileObject @ 0x%x, %0.*ws\n",
				            irpSp->FileObject,
				            irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

				if (prepared) {
					SipCompleteCSRefcountChange(
						perLink,
						&perLink->Index,
						perLink->CsFile,
						FALSE,
						FALSE);
				}
				deletingFile = FALSE;
			}
		} else {
			if (anythingInCopiedFile && !dirty) {
				//
				// We might have user mapped writes to the file.  Flush it and recheck to see if it's dirty.
				//
				SipFlushBuffersFile(fileObject,DeviceObject);

				KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
				dirty = (perLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
				KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			}
		}
	} else {
		SipReleaseScb(scb);
		deletingFile = FALSE;
	}

	//
	// Now send the cleanup down to NTFS.  
	//
	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

	if (deletingFile || ((0 == uncleanCount) && dirty && !finalCopyDone)) {

		KeInitializeEvent(event,NotificationEvent,FALSE);

		IoSetCompletionRoutine(
			Irp,
			SiCleanupCompletion,
			event,
			TRUE,
			TRUE,
			TRUE);

		status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);
		}

		if (deletingFile && prepared) {

			SIS_MARK_POINT_ULONG(perLink->CsFile);

			//
			// Cover for a race with create where we think the file is gone but NTFS doesn't
			// because it saw a new create before the final cleanup came down.  By setting this
			// bit, create will just fail rather than letting the underlying file get opened.
			//

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			perLink->Flags |= SIS_PER_LINK_FILE_DELETED;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			

			status = SipCompleteCSRefcountChange(
						perLink,
						&perLink->Index,
						perLink->CsFile,
						TRUE,
						FALSE);

			SIS_MARK_POINT_ULONG(status);
		} else if ((0 == uncleanCount) && dirty && !finalCopyDone) {
			//
			// Kick off a final copy.
			//
			SIS_MARK_POINT_ULONG(scb);

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			//
			// Check to see if it's already entered (or finished) final copy.  We need to recheck
			// here because someone could have gotten in since we checked finalCopyDone above.
			//
			if (perLink->Flags & (SIS_PER_LINK_FINAL_COPY|SIS_PER_LINK_FINAL_COPY_DONE)) {
				startFinalCopy = FALSE;
			} else {
				startFinalCopy = TRUE;
				perLink->Flags |= SIS_PER_LINK_FINAL_COPY;
			} 
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);

			if (startFinalCopy) {
				SipReferenceScb(scb, RefsFinalCopy);
				SipCompleteCopy(scb,TRUE);
			}
		}

		status = Irp->IoStatus.Status;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return status;
	} else {
		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		status = IoCallDriver(deviceExtension->AttachedToDeviceObject,Irp);
#if		DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SiCleanup: cleanup failed in ntfs 0x%x, perFO 0x%x, scb 0x%x\n",status,perFO,scb);
			SIS_MARK_POINT_ULONG(status);
		}
#endif	// DBG
		return status;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siclose.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siclose.c

Abstract:

	Close routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

NTSTATUS
SiClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is invoked upon file close operations.  If it's a SIS file,
	remove our filter context and clean up after ourselves.  In any case,
	let the close go down to NTFS.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the close irp

Return Value:

	The status from the NTFS close

--*/

{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PSIS_SCB 				scb;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

#if DBG
	if (BJBDebug & 0x1) {
		DbgPrint("SIS: SiClose: fileObject %p, %0.*ws\n",
		    fileObject,fileObject->FileName.Length / sizeof(WCHAR),fileObject->FileName.Buffer);
	}
#endif	// DBG

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindAny,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT_ULONG(perFO);

	//
	// Get rid of the perFO for this file object.  If this was the last file object,
	// then the filter context will get removed by NTFS, and deallocated by the appropriate
	// callback routine.
	//

	SipDeallocatePerFO(perFO,DeviceObject);

	//
	// We don't need to do any further processing on this SIS file object, so pass it
	// through.
	//
	SipDirectPassThroughAndReturn(DeviceObject, Irp);	// NB: This was a SIS file object!!!!

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sicreate.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sicreate.c

Abstract:

	Create file handling for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

typedef struct _SIS_CREATE_COMPLETION_CONTEXT {
	//
	// An event set by the completion routine once the irp is completed.
	//
	KEVENT				event[1];

	//
	// The completion status of the request.
	//
	IO_STATUS_BLOCK		Iosb[1];

	//
	// This is set if the completion routine returned STATUS_SUCCESS and allowed
	// the irp to finish complete processing.  It is FALSE if the caller needs to
	// complete the irp again.
	//
	BOOLEAN				completeFinished;

	//
	// Was the FILE_OPEN_REPARSE_POINT flag set in the original open request?
	//
	BOOLEAN				openReparsePoint;

	//
	// Was the create disposition supersede, overwrite or overwrite_if?
	//
	BOOLEAN				overwriteOrSupersede;

	//
	// Was this an open of an alternate stream of a SIS reparse point?
	//
	BOOLEAN				alternateStream;

	//
	// The index values for the link.  These are retrieved by the
	// completion routine.
	//

	CSID				CSid;
	LINK_INDEX			LinkIndex;

    //
    // The link file's id is stored in the reparse point info to avoid having
    // to call ntfs to get it.
    //

    LARGE_INTEGER       LinkFileNtfsId;

    //
    // The common store file is opened via its file id.
    //

    LARGE_INTEGER       CSFileNtfsId;

} SIS_CREATE_COMPLETION_CONTEXT, *PSIS_CREATE_COMPLETION_CONTEXT;

NTSTATUS
SiCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SiCreateCompletionStage2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SipWaitForFinalCopy(
	IN PSIS_PER_LINK	perLink,
	IN BOOLEAN			FinalCopyInProgress);

typedef struct _SI_DEREF_FILE_OBJECT_WORK_CONTEXT {
	WORK_QUEUE_ITEM				workQueueItem[1];
	PFILE_OBJECT				fileObject;
} SI_DEREF_FILE_OBJECT_WORK_CONTEXT, *PSI_DEREF_FILE_OBJECT_WORK_CONTEXT;

VOID
SiDerefFileObjectWork(
	IN PVOID			parameter)
/*++

Routine Description:

	A worker thread routine to drop an object reference.  Takes a pointer
	to a context record that in turn holds a pointer to the file object
	to dereference.  Dereferences the object and frees the context.

Arguments:

	parameter - the SI_DEREF_FILE_OBJECT_WORK_CONTEXT for this work item.

Return Value:

	void

--*/
{
	PSI_DEREF_FILE_OBJECT_WORK_CONTEXT		context = parameter;

	SIS_MARK_POINT_ULONG(context->fileObject);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SiDerefFileObjectWork: fo %p\n",context->fileObject);
	}
#endif	// DBG

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ObDereferenceObject(context->fileObject);
	ExFreePool(context);

}



NTSTATUS
SiOplockBreakNotifyCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
/*++

Routine Description:

	Someone had a complete-if-oplocked create finish indicating that there was
	an oplock break in progress.  We sent down an FSCTL_OPLOCK_BREAK_NOTIFY irp
	in order to see when the oplock break completes so that we'll know that we
	don't have block CS file reads.

	The FSCTL has now completed, and this is the completion routine.  Indicate
	that the oplock break is complete, wake up anyone who might be waiting,
	free the irp and return STATUS_MORE_PROCESSING_REQUIRED so that the IO system
	doesn't go nuts with an irp that doesn't have anything above SIS.

	In order to assure that the file object doesn't get deallocated while the fsctl
	is outstanding, we took a reference to it before we launched the fsctl.  We
	need to drop that reference here; if we're not called at PASSIVE_LEVEL we can't
	do that, so we may have to post the dereference.

Arguments:
v	DeviceObject	- our device object

	irp				- the create irp, which contains the create request in the
					  current stack location.

	context			- a PVOID cast of the perFO.

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PSIS_PER_FILE_OBJECT		perFO = Context;
    KIRQL						OldIrql;

    UNREFERENCED_PARAMETER( DeviceObject );
	SIS_MARK_POINT_ULONG(perFO);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SiOplockBreakNotifyCompletion: perFO %p, fileObject %p\n",perFO,perFO->fileObject);
	}
#endif	// DBG

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
	ASSERT(perFO->Flags & SIS_PER_FO_OPBREAK);
	perFO->Flags &= ~SIS_PER_FO_OPBREAK;

	if (perFO->Flags & SIS_PER_FO_OPBREAK_WAITERS) {
		perFO->Flags &= ~SIS_PER_FO_OPBREAK_WAITERS;

		ASSERT(perFO->BreakEvent);
		KeSetEvent(perFO->BreakEvent, IO_NO_INCREMENT, FALSE);
	}
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	if (PASSIVE_LEVEL != OldIrql) {
		//
		// We were called at raised IRQL, so we can't drop the reference that
		// we hold to the file object.  Post a work item to do that.
		//
		PSI_DEREF_FILE_OBJECT_WORK_CONTEXT	context;

		SIS_MARK_POINT_ULONG(perFO);

		context = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREF_FILE_OBJECT_WORK_CONTEXT), ' siS');
		if (NULL == context) {
			//
			// Too bad, dribble it.
			//
			SIS_MARK_POINT_ULONG(perFO);

#if		DBG
			if (BJBDebug & 0x2000) {
				DbgPrint("SIS: SiOplockBreakNotifyCompletion: dribbling FO: perFO %x, fo %x\n",perFO,perFO->fileObject);
			}
#endif	// DBG

		} else {

#if		DBG
			if (BJBDebug & 0x2000) {
				DbgPrint("SIS: SiOplockBreakNotifyCompletion: pushing off level: perFO %x, fo %x\n",perFO,perFO->fileObject);
			}
#endif	// DBG

			ExInitializeWorkItem(
				context->workQueueItem,
				SiDerefFileObjectWork,
				(PVOID)context);

			context->fileObject = perFO->fileObject;

			ExQueueWorkItem(context->workQueueItem,CriticalWorkQueue);
		}
		
	} else {
		//
		// We're already at PASSIVE_LEVEL and so can dereference the object inline.
		//
		ObDereferenceObject(perFO->fileObject);
	}

	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SiUnopenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

	SIS has decicided to back out the open of a file object; to do that it
	sends down a cleanup and close to NTFS.  Either the cleanup or close has
	completed.  Since we use the same IRP that the original create came down
	on, we need to stop the completion processing.  Clear out pending, set
	an event to restart the calling thread and return 
	STATUS_MORE_PROCESSING_REQUIRED.

Arguments:
	DeviceObject	- our device object

	irp				- the create irp, which we're using for the cleanup/close

	context			- pointer to an event to set

Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT		event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );

	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SipUnopenFileObject(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp)
/*++

Routine Description:

	NTFS has successfully completed a create on a file, but we haven't yet
	let the irp bubble up to the IO system.  For some reason, we have decided
	that we need to fail the irp, so we have to back NTFS out of the
	idea that the file's open.  To that end, we send down a cleanup and then
	a close on the file.

Arguments:
	DeviceObject	- our device object

	irp				- the create irp, which contains the create request in the
					  current stack location.

Return Value:

	void; if this fails, we just have to ignore it, because we're out of options.

--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION		nextIrpSp = IoGetNextIrpStackLocation(Irp);
	KEVENT					event[1];
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

	ASSERT(IRP_MJ_CREATE == irpSp->MajorFunction);
	ASSERT(NULL != irpSp->FileObject);

	SIS_MARK_POINT_ULONG(irpSp->FileObject);

#if		DBG
///*BJB*/	DbgPrint("SIS: SipUnopenFile object: unopening file object at 0x%x on irp 0x%x\n",irpSp->FileObject,Irp);
#endif	// DBG

	KeInitializeEvent(event, NotificationEvent, FALSE);

	//
	// First, send down the cleanup.
	//

    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

	nextIrpSp->MajorFunction = IRP_MJ_CLEANUP;
	nextIrpSp->MinorFunction = 0;

	IoSetCompletionRoutine(
		Irp,
		SiUnopenCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// If the cleanup failed, then don't try to send down the close.
		// We'll just dribble the file, because we're plain out of options.
		//

		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
		DbgPrint("SIS: SipUnopenFileObject, cleanup failed 0x%x on file object 0x%x\n",
					Irp->IoStatus.Status, irpSp->FileObject);
#endif	// DBG

		return;
	}

	//
	// Now, send down the close.
	//
	
    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

	nextIrpSp->MajorFunction = IRP_MJ_CLOSE;
	nextIrpSp->MinorFunction = 0;

	IoSetCompletionRoutine(
		Irp,
		SiUnopenCompletion,
		event,
		TRUE,
		TRUE,
		TRUE);

	IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

#if		DBG
	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// I don't think closes can fail, but just in case...
		//
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

		DbgPrint("SIS: SipUnopenFileObject, close failed 0x%x on file object 0x%x (!)\n",
					Irp->IoStatus.Status, irpSp->FileObject);
	}
#endif	//DBG

	return;
}

BOOLEAN
SipDoesFileObjectDescribeAlternateStream(
	IN PUNICODE_STRING					fileName,
	IN PFILE_OBJECT						relatedFileObject,
	IN PDEVICE_OBJECT					DeviceObject)
/*++

Routine Description:

	Figure out whether this file object describes an alternate stream
	or the unnamed data stream.  This function can only be called on file
	objects that have not yet completed the create process, because it looks
	at the fileObject->FileName field which is only guaranteed to be
	meaningful in that case.

	This works by parsing the file name, looking for ':' characters in the
	terminal part of the path name (ie., after the final '\').

	If the file name is empty, is checks the relatedFileObject.  In this case,
	we are opening an alternate stream iff the related file object is not a SIS
	file object.  NB: This assumes that the newly opened file object has a SIS
	reparse point on it.  If it doesn't, then we may return FALSE when we should
	say TRUE.  Caveat Emptor!

Arguments:

	fileName - The name used to open the file.

	relatedFileObject - The related file object used to open the file.

	DeviceObject - the SIS device object.

Return Value:

	TRUE if the file object describes an alternate stream, FALSE otherwise.

--*/

{
	LONG					index;
	LONG					firstColonIndex = -1;

	if (0 == fileName->Length) {
		
		//
		// This is probably a relative open using the empty file name, esstentially opening the
		// same file as the related file object.  Since we know this reparse point
		//
		PSIS_PER_FILE_OBJECT		perFO;
		PSIS_SCB					scb;

		if (NULL == relatedFileObject) {
			//
			// There's no file name and no related file object.  It's strange that
			// this open worked at all.
			//

			SIS_MARK_POINT();
			return FALSE;
		}

		return !SipIsFileObjectSIS(relatedFileObject, DeviceObject, FindActive, &perFO, &scb);

	}

	for (index = fileName->Length / sizeof(WCHAR) - 1;
		 index >= 0;
		 index--) {

		if ('\\' == fileName->Buffer[index]) {
			break;
		}
		if (':' == fileName->Buffer[index]) {
			if (-1 == firstColonIndex) {
				//
				// This is the first colon we've seen.  Just remember where it is.
				//
				firstColonIndex = index;
			} else {
				//
				// We've now seen two colons.  If they're next to one another,
				// this is the unnamed stream.  If they're not, this is a named
				// stream.
				//
				ASSERT(index < firstColonIndex);

				if (index + 1 == firstColonIndex) {
					//
					// We saw "::", which means this is the unnamed stream.
					//
					return FALSE;
				} else {
					//
					// We saw  ":streamName:", which means this is a named stream.
					//
					return TRUE;
				}
			}
		}
	}

	if (-1 != firstColonIndex) {
		//
		// We saw a colon.  If it's not the last character of the file name, this is
		// an alternate stream.
		//
		if (firstColonIndex != (LONG)(fileName->Length / sizeof(WCHAR) - 1)) {
			//
			// It was "something:somethingElse" where somethingElse is not the empty
			// string.  It's an alternate stream.
			//
			return TRUE;
		}
	}

	return FALSE;

}

NTSTATUS
SiCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful; if
	the user is trying to open with FILE_OPEN_REPARSE_POINT, it clears the
	flag and uses a special complete routine, in order to prevent users from
	opening SIS reparse points (while allowing opening of other reparse points).

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
	CHAR							reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define	reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
	CSID							newCSid;
    FILE_INTERNAL_INFORMATION		internalInfo[1];
	LINK_INDEX						newLinkIndex;
	LARGE_INTEGER					newCSFileNtfsId;
	LARGE_INTEGER					newLinkFileNtfsId;
	UNICODE_STRING					fileName[1];
	LONGLONG						CSFileChecksumFromReparsePoint;
    PIO_STACK_LOCATION 				irpSp;
    PDEVICE_EXTENSION 				deviceExtension;
    PIO_STACK_LOCATION 				nextIrpSp;
	SIS_CREATE_COMPLETION_CONTEXT	context[1];
	PSIS_SCB						scb = NULL;
	PSIS_PER_LINK					perLink;
	PSIS_CS_FILE					CSFile;
	PSIS_PER_FILE_OBJECT			perFO = NULL;
	PFILE_OBJECT					fileObject;
	PFILE_OBJECT					relatedFileObject = NULL;
	NTSTATUS						status;
	KIRQL							OldIrql;
    UCHAR                           CreateDisposition = 0;
	BOOLEAN							validReparseStructure;
	BOOLEAN							bogusReparsePoint = FALSE;
	BOOLEAN							fileBackpointerGoneBitSet;
    BOOLEAN                         BPExclusive;
	BOOLEAN							FinalCopyInProgress;
	BOOLEAN 						thingsChanged;
	BOOLEAN							completedStage2 = FALSE;
	BOOLEAN							ReparsePointCorrupted;
	BOOLEAN							EligibleForPartialFinalCopy;
	BOOLEAN							openedById;
    BOOLEAN                         RepairingCollision = FALSE;

	fileName->Buffer = NULL;

retry:

    deviceExtension = DeviceObject->DeviceExtension;

    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  Allow users to open the device that represents our driver.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

    irpSp = IoGetCurrentIrpStackLocation( Irp );

	ASSERT(irpSp->MajorFunction == IRP_MJ_CREATE);

	//
	// If this is a paging file open, wash our hands of it.
	//
	if (irpSp->Flags & SL_OPEN_PAGING_FILE) {

		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	fileObject = irpSp->FileObject;
    SIS_MARK_POINT_ULONG(fileObject);

	//
   	// Simply copy this driver stack location contents to the next driver's
   	// stack.
   	//

  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

    CreateDisposition = (UCHAR) ((irpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    if ((CreateDisposition == FILE_SUPERSEDE) ||
   	    (CreateDisposition == FILE_OVERWRITE) ||
       	(CreateDisposition == FILE_OVERWRITE_IF)) {

		context->overwriteOrSupersede = TRUE;
	} else {
		context->overwriteOrSupersede = FALSE;
	}

	openedById = (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) ? TRUE : FALSE;

#if		DBG
/*BJB*/	SIS_MARK_POINT_ULONG(fileObject);
/*BJB*/	if ((NULL != fileObject) && (NULL != fileObject->FileName.Buffer)) {
			ULONG data = 0;
			ULONG i;

			for (i = 0; (i < 4) && (i * sizeof(WCHAR) < irpSp->FileObject->FileName.Length); i++) {
				data = (data >> 8) | ((irpSp->FileObject->FileName.Buffer[irpSp->FileObject->FileName.Length / sizeof(WCHAR) - i - 1] & 0xff) << 24);
			}
			SIS_MARK_POINT_ULONG(data);
/*BJB*/	}

/*BJB*/	SIS_MARK_POINT_ULONG(CreateDisposition << 16 | irpSp->Parameters.Create.ShareAccess);
/*BJB*/	SIS_MARK_POINT_ULONG(irpSp->Parameters.Create.SecurityContext->DesiredAccess);

	if (BJBDebug & 0x40) {
		DbgPrint("SIS: SiCreate %d: fileObject %p, %0.*ws\n",
                    __LINE__,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	if (irpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT) {

		//
		// The user is trying to open a reparse point.  If it's an overwrite or supersede,
		// clear the flag (we'll turn it on again later).  Otherwise, just note that it was
		// set, so that we'll check to see if it's a SIS file later.
		//
		
	    if (context->overwriteOrSupersede) {

			nextIrpSp->Parameters.Create.Options &= ~FILE_OPEN_REPARSE_POINT;
		} else {
			//
			// We need to squirrel away the file name and related file object because we might
			// need to perform a check for an alternate stream later on.
			//
			ASSERT(NULL == fileName->Buffer);

			fileName->Length = 0;
			fileName->MaximumLength = fileObject->FileName.MaximumLength;
			if (fileName->MaximumLength != 0) {
				fileName->Buffer = ExAllocatePoolWithTag(PagedPool, fileName->MaximumLength, ' siS');
				if (NULL == fileName->Buffer) {
					SIS_MARK_POINT();

					status = STATUS_INSUFFICIENT_RESOURCES;
					goto fail;
				}
				SIS_MARK_POINT_ULONG(fileName->Buffer);

				RtlCopyUnicodeString(fileName, &fileObject->FileName);
			}

			ASSERT(NULL == relatedFileObject);
			relatedFileObject = fileObject->RelatedFileObject;
			if (NULL != relatedFileObject) {
				SIS_MARK_POINT_ULONG(relatedFileObject);

				ObReferenceObject(relatedFileObject);
			}
		}

		context->openReparsePoint = TRUE;
	} else {
		context->openReparsePoint = FALSE;
	}

	KeInitializeEvent(context->event,SynchronizationEvent,FALSE);

    IoSetCompletionRoutine(
   	    Irp,
       	SiCreateCompletion,
        context,
   	    TRUE,
       	TRUE,
        TRUE
   	    );

    //
    // Now call the appropriate file system driver with the request.
    //

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

//	SIS_MARK_POINT_ULONG(Irp);
    status = IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );
//	SIS_MARK_POINT_ULONG(status);

	//
	// Wait for the completion routine
	//
	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(context->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
//		SIS_MARK_POINT_ULONG(status);
	} else {
		KeClearEvent(context->event);
	}

    SIS_MARK_POINT();
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (context->completeFinished) {
        PSIS_PER_FILE_OBJECT    perFO;
        PSIS_SCB                scb;

		//
		// It wasn't a SIS reparse point, so the completion routine
		// didn't stop the completion.  Return whatever status was sent
		// to the completion routine.
		//

		SIS_MARK_POINT_ULONG(context->Iosb->Status);

        if (NT_SUCCESS(context->Iosb->Status) &&
            SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &perFO, &scb)) {

            //
            // Indicate that we expect to see a cleanup for this file object.
            // The UnClose count is incremented in the per-FO allocator because
            // we will see closes (but not cleanups) for stream file objects.
            //
            ASSERT(0 == (perFO->Flags & SIS_PER_FO_UNCLEANUP));

            InterlockedIncrement(&perFO->fc->UncleanCount);
            perFO->Flags |= SIS_PER_FO_UNCLEANUP;
        }

        ASSERT(STATUS_PENDING != context->Iosb->Status);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

        return context->Iosb->Status;
    }

	if ((STATUS_REPARSE == context->Iosb->Status) && 
		(IO_REPARSE_TAG_SIS != context->Iosb->Information) &&
		context->openReparsePoint) {

		//
		// This was a request to open a reparse point overwrite or supersede, and it turned out to
		// be a non-SIS reparse point.  Re-submit the open with the reparse
		// flag reset.  Note: there is an unavoidable refcount update race here, because
		// we don't know that this file will not be converted into a SIS file in the interim.
		//

		ASSERT(context->overwriteOrSupersede);

		SIS_MARK_POINT();

	  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
	    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

		nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}

	if (context->alternateStream) {
		//
		// It was an open of an alternate stream of a SIS reparse point.  Turn on 
		// FILE_OPEN_REPARSE_POINT and resubmit the request.
		//
		ASSERT(context->overwriteOrSupersede || !context->openReparsePoint);
		ASSERT(STATUS_REPARSE == context->Iosb->Status);

		SIS_MARK_POINT();

	  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
	    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

		nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		IoSetCompletionRoutine(
			Irp,
			NULL,
			NULL,
			FALSE,
			FALSE,
			FALSE);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}

	//
	// If this was an open reparse point and not supersede/overwrite,
	// we need to skip straight to reading the reparse data.
	//
	if (context->openReparsePoint && !context->overwriteOrSupersede) {
		ASSERT(NT_SUCCESS(context->Iosb->Status));	// or else SiCreateCompletion should have handled it.
		ASSERT(STATUS_REPARSE != context->Iosb->Status);	// because this was FILE_OPEN_REPARSE_POINT

		SIS_MARK_POINT();
		scb = NULL;

		completedStage2 = TRUE;

		goto recheckReparseInfo;
	}

	//
	// It must have been a SIS link.
	//
	ASSERT((STATUS_FILE_CORRUPT_ERROR == context->Iosb->Status) || 
			((STATUS_REPARSE == context->Iosb->Status) &&
			(IO_REPARSE_TAG_SIS == context->Iosb->Information)));

	//
	// Assure that SIS phase 2 initialization has completed.  Doing this here
	// assures that there are no open SIS links until this is completed.
	//
	if (!SipCheckPhase2(deviceExtension)) {

		//
		// This is a SIS reparse point opened without FILE_FLAG_OPEN_REPARSE_POINT
		// on a non-SIS enabled volume.  If it's an overwrite/supersede or it's opened
		// for delete access, then let it continue (if we can't initialize, we probably 
		// don't need to worry about backpointer consitency).  If not, then punt it.
		//

		if (context->overwriteOrSupersede || (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)) {
			SIS_MARK_POINT();

		  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
		    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

			nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

			IoSetCompletionRoutine(
				Irp,
				NULL,
				NULL,
				FALSE,
				FALSE,
				FALSE);

			if (NULL != fileName->Buffer) {
				ExFreePool(fileName->Buffer);
				fileName->Buffer = NULL;
			}
			if (NULL != relatedFileObject) {
				ObDereferenceObject(relatedFileObject);
				relatedFileObject = NULL;
			}

			return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
		} else {
			SIS_MARK_POINT();
			status = STATUS_INVALID_DEVICE_REQUEST;
			goto fail;
		}
	}

	if (STATUS_FILE_CORRUPT_ERROR == context->Iosb->Status) {
		//
		// This error must have come from SiCreateCompletion; if it was from NTFS then completeFinished
		// would have been true.  It indicates that the reparse buffer was a SIS reparse buffer but was
		// bogus.  Set scb to NULL and fall through to the stage 2 open, which will open the underlying
		// file and recheck the reparse point, probably get another invalid, and let the underlying file
		// be opened without SIS doing anything.
		//
		scb = NULL;
		bogusReparsePoint = TRUE;
	} else if (context->overwriteOrSupersede) {

		BOOLEAN		finalDeleteInProgress;

		//
		// The create completed with a STATUS_REPARSE and it was a SIS link and
		// there weren't any problems that caused the complete routine to just
		// fail the request.
        //
        // Lookup the scb using the ntfs file id from the reparse info.  Note
        // that we can't trust this id to be correct, but we can use it as a
        // hint.
		//

		SIS_MARK_POINT();
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		scb = SipLookupScb(	&context->LinkIndex,
							&context->CSid,
        	                &context->LinkFileNtfsId,
            	            &context->CSFileNtfsId,
							NULL,				// stream name NTRAID#65188-2000/03/10-nealch Handle alternate data streams
							DeviceObject,
							Irp->Tail.Overlay.Thread,
							&FinalCopyInProgress,
                            NULL);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL == scb) {
#if		DBG
			DbgPrint("SIS: SiCreate: Unable to allocate SCB\n");
#endif	// DBG
			status = STATUS_INSUFFICIENT_RESOURCES;
			SIS_MARK_POINT();
			goto fail;
		}

        SIS_MARK_POINT_ULONG(scb);

        ASSERT(scb->PerLink && scb->PerLink->CsFile);

        if (!IsEqualGUID(&scb->PerLink->CsFile->CSid, &context->CSid)) {

            //
            // There is a link index collision.  Since we're going to blow away
            // the reparse point, just kick off a volume check and let the
            // operation proceed.
            //

			SIS_MARK_POINT_ULONG(scb);

		    SipDereferenceScb(scb, RefsLookedUp);

		  	nextIrpSp = IoGetNextIrpStackLocation( Irp );
		    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );

			nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

			IoSetCompletionRoutine(
				Irp,
				NULL,
				NULL,
				FALSE,
				FALSE,
				FALSE);

			if (NULL != fileName->Buffer) {
				ExFreePool(fileName->Buffer);
				fileName->Buffer = NULL;
			}
			if (NULL != relatedFileObject) {
				ObDereferenceObject(relatedFileObject);
				relatedFileObject = NULL;
			}

            SipCheckVolume(deviceExtension);

			return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
        }

		perLink = scb->PerLink;

		if (perLink->COWingThread != Irp->Tail.Overlay.Thread) {

			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
			thingsChanged = SipWaitForFinalCopy(perLink, FinalCopyInProgress);
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			if (thingsChanged) {
				//
				// Something changed out from under us during the final copy.
				// Retry everything.
				//
				SIS_MARK_POINT_ULONG(scb);

				SipDereferenceScb(scb,RefsLookedUp);

				if (NULL != fileName->Buffer) {
					ExFreePool(fileName->Buffer);
					fileName->Buffer = NULL;
				}
				if (NULL != relatedFileObject) {
					ObDereferenceObject(relatedFileObject);
					relatedFileObject = NULL;
				}

				goto retry;
			}
		}


   	    SIS_MARK_POINT_ULONG(CreateDisposition);

#if 0
		DbgPrint("SiCreate %s: fileObject @ 0x%x, %0.*ws\n",
   	                FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

        //
   	    // Assume that our reparse point will be deleted and
    	// prepare for the CS file refcount update.  This will
        // also serialize all overwrite/supersede/delete operations
   	    // on this file until SipCompleteCSRefcountChange is called.
    	//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	
	    status = SipPrepareCSRefcountChange(
					perLink->CsFile,
					&perLink->Index,
					&perLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	    if (!NT_SUCCESS(status)) {
	
		    SIS_MARK_POINT_ULONG(status);

			goto fail;
	    }

		//
		// Verify that this file isn't in the process of being finally deleted.  If it is, fail the create.
		//
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		finalDeleteInProgress = (perLink->Flags & SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		if (finalDeleteInProgress) {
			SIS_MARK_POINT_ULONG(scb);

			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				perLink->CsFile,
				FALSE,
				FALSE);

			status = STATUS_ACCESS_DENIED;

			goto fail;
		}

        SIS_MARK_POINT_ULONG(scb);

	} else {
		//
		// We'll just ignore the stuff in the reparse point for now, and catch it after we really open
		// the file file FILE_OPEN_REPARSE_POINT and query it.  The reparse data that we have now is essentially
		// useless because the file could change between the STATUS_REPARSE return and the actual open
		// of the file below.
		//
		scb = NULL;
	}

	//
	// Now we want to open the reparse point itself.  We do this by turning on the
	// FILE_OPEN_REPARSE_POINT flag and sending the Irp back down to NTFS.  The rest of the
	// work of opening the link (allocating the perFO, etc.) is done in the stage2
	// completion routine.
	//

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));
	nextIrpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

	IoSetCompletionRoutine(
		Irp,
		SiCreateCompletionStage2,
		context,
		TRUE,
		TRUE,
		TRUE);

	SIS_MARK_POINT_ULONG(Irp);

	//
	// Again call into the filesystem.
	//
		
	ASSERT(0 == KeReadStateEvent(context->event));

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
//	SIS_MARK_POINT_ULONG(status);

	//
	// Wait for the completion routine to execute.
	//
	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(context->event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
	} else {
		KeClearEvent(context->event);
	}
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	//
	// If the completion failed, release the scb and return.
	//
	if (!NT_SUCCESS(context->Iosb->Status)) {

		if (NULL != scb) {

            if (context->overwriteOrSupersede) {

		        SIS_MARK_POINT_ULONG(CreateDisposition);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
				    scb->PerLink->CsFile,
	                FALSE,
	                FALSE);
            }

		    SIS_MARK_POINT_ULONG(context->Iosb->Status);

			SipDereferenceScb(scb, RefsLookedUp);
		}

		Irp->IoStatus = *context->Iosb;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	if (bogusReparsePoint) {
		//
		// Just return the completion to the user.
		//
		SIS_MARK_POINT_ULONG(fileObject);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		Irp->IoStatus = *context->Iosb;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return context->Iosb->Status;
	}

	completedStage2 = TRUE;


    if (context->overwriteOrSupersede) {

	    ULONG						returnedLength;

        //
        // Get the ntfs file id.  If it's the same as the one we started with
        // (ie. the one that triggered the STATUS_REPARSE), then we know that
        // our file was overwritten.
        //

		SIS_MARK_POINT_ULONG(CreateDisposition);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	    status = SipQueryInformationFile(
					irpSp->FileObject,
					DeviceObject,
				    FileInternalInformation,
				    sizeof(FILE_INTERNAL_INFORMATION),
				    internalInfo,
				    &returnedLength);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	    if (!NT_SUCCESS(status)) {

            //
            // Just assume that we didn't overwrite the file.  This may
            // cause the CS reference count to be retained when it shouldn't,
            // but that's better than vice versa, where data loss would
            // result.
            //

		    SIS_MARK_POINT_ULONG(status);
#if DBG
		    DbgPrint("SiCreate %s: SipQueryInformationFile failed 0x%x, (%0.*ws)\n",
                FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
                status,
                irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

            SipCompleteCSRefcountChange(
				scb->PerLink,
				&scb->PerLink->Index,
				scb->PerLink->CsFile,
	            FALSE,
	            FALSE);

        } else {

			PSIS_SCB		newScb;

	        ASSERT(status != STATUS_PENDING);
	        ASSERT(returnedLength == sizeof(FILE_INTERNAL_INFORMATION));

			//
			// If there's another user of this file, then it might have an attached
			// filter context.  If so, even though it's not a SIS file anymore we
			// need to update the unclean count on the file, because we'll see
			// a cleanup for this file object.
			//

			if (SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &perFO, &newScb)) {
	            ASSERT(0 == (perFO->Flags & SIS_PER_FO_UNCLEANUP));

	            InterlockedIncrement(&perFO->fc->UncleanCount);
	            perFO->Flags |= SIS_PER_FO_UNCLEANUP;
			}

            if (internalInfo->IndexNumber.QuadPart != scb->PerLink->LinkFileNtfsId.QuadPart) {

                //
                // This is a different file.  (Could have been moved without us
                // knowing, or a delete/create/overwrite/supersede race before the
                // SipPrepareCSRefcountChange.)
                //
                SIS_MARK_POINT();
#if DBG
		        DbgPrint("SiCreate %s: different file opened, (%0.*ws)\n",
                    FILE_SUPERSEDE == CreateDisposition ? "FILE_SUPERSEDE" : "FILE_OVERWRITE",
                    status,
                    irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
#endif

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
					scb->PerLink->CsFile,
	                FALSE,
	                FALSE);

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

            } else {

                //
                // This is the same file.  Remove a reference from the
                // common store file, and mark the scb truncated and the
                // reparse point gone.
                //
		        SIS_MARK_POINT();

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipCompleteCSRefcountChange(
				    scb->PerLink,
				    &scb->PerLink->Index,
					scb->PerLink->CsFile,
                    (BOOLEAN) ((scb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? FALSE : TRUE),
	                FALSE);

				SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

				SipAcquireScb(scb);
				scb->SizeBackedByUnderlyingFile = 0;
				SipReleaseScb(scb);
            }
        }

#if DBG
	    //
	    // Try to read the reparse information from the file that we just opened.
        // It should not be a SIS reparse point (SIS reparse points are always
        // created using exclusive access).
	    //

		RtlZeroMemory(reparseBuffer,sizeof(SIS_REPARSE_DATA_SIZE));

	    status = SipFsControlFile(
					    irpSp->FileObject,
					    DeviceObject,
					    FSCTL_GET_REPARSE_POINT,
					    NULL,
					    0,
					    reparseBuffer,
					    SIS_REPARSE_DATA_SIZE,
						NULL);						// returned output buffer length

        if (NT_SUCCESS(status)) {

            ASSERT(IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag);

        } else {

            ASSERT(STATUS_NOT_A_REPARSE_POINT == status || 
                   STATUS_FILE_CORRUPT_ERROR == status || 
			      (STATUS_BUFFER_OVERFLOW == status && IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag));

        }
#endif

		//
		// This is no longer a sis link (or at least we assume so).
        // Detach ourself from the file and let the open complete normally.
		//
		SipDereferenceScb(scb, RefsLookedUp);

        //
        // The completion status is whatever came back from the completion of the actual
        // open.  Copy it into the irp.
        //
        Irp->IoStatus = *context->Iosb;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

        return context->Iosb->Status;
    }

recheckReparseInfo:

    SIS_MARK_POINT();

	//
	// Read the reparse information from the file that we just opened.  Until we do that,
	// we don't have any assurance that it's the file whose STATUS_REPARSE we got; someone
	// may have changed the file in the interim.
	//

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	status = SipFsControlFile(
					irpSp->FileObject,
					DeviceObject,
					FSCTL_GET_REPARSE_POINT,
					NULL,
					0,
					reparseBuffer,
					SIS_REPARSE_DATA_SIZE,
					NULL);						// returned output buffer length

	SIS_MARK_POINT_ULONG(status);
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	//
	// If get reparse failed with a status code that indicates that we're just looking
	// at the wrong kind of reparse point, or if the reparse tag isn't a SIS reparse
	// tag, let the open proceed without SIS involvement.
	//

	if ((STATUS_BUFFER_TOO_SMALL == status) ||
		(STATUS_VOLUME_NOT_UPGRADED == status) ||
		(STATUS_NOT_A_REPARSE_POINT == status) ||
		(STATUS_BUFFER_OVERFLOW == status) ||
        (STATUS_INVALID_PARAMETER == status) ||     //happens when opening a volume
		(NT_SUCCESS(status) && (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag))) {

		SIS_MARK_POINT_ULONG(reparseBuffer->ReparseTag);

		//
		// This is a non-sis link now.  Detach ourself from the file and
		// let the open complete normally.
		//

		if (NULL != scb) {
			SipDereferenceScb(scb, RefsLookedUp);
			scb = NULL;
		}

        //
        // It seems unlikely that we in the process of repairing a collision, but
        // handle it just the same.
        //
        if (RepairingCollision) {
		    SIS_MARK_POINT();
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		//
		// This could be a SIS file object from which we've already deleted the reparse point.
		// If so, then we need to increment the uncleanup count.
		//

        if (SipIsFileObjectSIS(fileObject, DeviceObject, FindAny, &perFO, &scb)) {

            //
            // Indicate that we expect to see a cleanup for this file object.
            // The UnClose count is incremented in the per-FO allocator because
            // we will see closes (but not cleanups) for stream file objects.
            //

		    SIS_MARK_POINT_ULONG(fileObject);
            ASSERT(0 == (perFO->Flags & SIS_PER_FO_UNCLEANUP));

            InterlockedIncrement(&perFO->fc->UncleanCount);
            perFO->Flags |= SIS_PER_FO_UNCLEANUP;
        }

		//
		// The completion status is whatever came back from the completion of the actual
		// open.  Copy it into the irp.
		//
		Irp->IoStatus = *context->Iosb;
		
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		//
		// The get reparse point failed, but not with a status that we'd expected.
		// Fail the entire open with the same status.
		//

		SIS_MARK_POINT_ULONG(status);

        if (RepairingCollision) {
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		goto fail;
	}


	validReparseStructure = SipIndicesFromReparseBuffer(
								reparseBuffer,
								&newCSid,
								&newLinkIndex,
								&newCSFileNtfsId,
								&newLinkFileNtfsId,
								&CSFileChecksumFromReparsePoint,
								&EligibleForPartialFinalCopy,
								&ReparsePointCorrupted);

	if (!validReparseStructure) {

        //
        // It seems unlikely that we're in the process of repairing a collision, but
        // handle it just the same.
        //
        if (RepairingCollision) {
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;
        }

		if (ReparsePointCorrupted) {
			//
			// This is a bogus reparse point.  Delete the reparse point and open the
			// underlying file.
			//
			SIS_MARK_POINT_ULONG(irpSp->FileObject);

			goto deleteReparsePoint;
		}

		//
		// This is a reparse buffer that's not corrupt, but which we don't understand,
		// presumably from a newer version of the filter.  Open the underlying file.
		//
		goto openUnderlyingFile;
	}

	//
	// If the user specified FILE_OPEN_REPARSE_POINT and not overwrite/supersede,
	// this might actually be an alternate stream.  We need to parse the file name
	// to figure this out, and if so complete the irp.
	//
	if (context->openReparsePoint
		&& (!context->overwriteOrSupersede) 
		&& (!openedById)
		&& SipDoesFileObjectDescribeAlternateStream(fileName,relatedFileObject, DeviceObject)) {

		SIS_MARK_POINT_ULONG(irpSp->FileObject);
        ASSERT(!RepairingCollision);

		//
		// This is an alternate stream of a SIS file object that the user opened
		// with FILE_OPEN_REPARSE_POINT.  Do not attach to it, just return it directly
		// to the user.
		//

		Irp->IoStatus = *context->Iosb;
		
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		if (NULL != fileName->Buffer) {
			ExFreePool(fileName->Buffer);
			fileName->Buffer = NULL;
		}
		if (NULL != relatedFileObject) {
			ObDereferenceObject(relatedFileObject);
			relatedFileObject = NULL;
		}

		return context->Iosb->Status;
	}

	//
	// Have to check phase2 in case we got here through the FILE_OPEN_REPARSE_POINT path.
	//
	if (!SipCheckPhase2(deviceExtension)) {
		SIS_MARK_POINT();

		//
		// We can't initialize.  This must be an open reparse point because otherwise
		// we would have quit at the earlier phase2 check.  Just open the underlying file.
		//

		ASSERT(context->openReparsePoint);
        ASSERT(!RepairingCollision);

		goto openUnderlyingFile;
	}

	//
	// Handle the case where the file is a SIS link, but not the right one.
	// This can happen if someone deletes the link that we started opening
	// and the creates a new one in the same filename between when we got
	// STATUS_REPARSE and here.  This also always happens on FILE_OPEN_REPARSE_POINT
	// calls that are not supersede/overwrite.  Also handle the case where
    // we have a link index collision (two or more files have the same link
    // index).
	//
	if ((NULL == scb) ||
        (newLinkIndex.QuadPart != scb->PerLink->Index.QuadPart) ||
        !IsEqualGUID(&scb->PerLink->CsFile->CSid, &newCSid)) {
		PSIS_SCB		newScb;

		SIS_MARK_POINT_ULONG(scb);
		SIS_MARK_POINT_ULONG(newLinkIndex.QuadPart);

		//
		// Lookup the new SCB and drop our reference to the old one.
        //
        // The ntfs file id is the one we got from ntfs, not the reparse info.
		//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		newScb = SipLookupScb(
					&newLinkIndex,
					&newCSid,
					&newLinkFileNtfsId,
					&newCSFileNtfsId,
					NULL,							// stream name NTRAID#65188-2000/03/10-nealch Handle alternate data streams
					DeviceObject,
					Irp->Tail.Overlay.Thread,
					&FinalCopyInProgress,
                    NULL);


		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (NULL == newScb) {
			//
			// We're out of memory in a bad place.  Just fail the open request.
			//
			SIS_MARK_POINT();

			status = STATUS_INSUFFICIENT_RESOURCES;
			goto fail;
		}

		SIS_MARK_POINT_ULONG(newScb);

        if (!IsEqualGUID(&newScb->PerLink->CsFile->CSid, &newCSid)) {
            if (!RepairingCollision) {
                //
                // We just detected a link index collision.  Take the collision
                // mutant and recheck for collision (in case of thread race).  If
                // there's no race (or we win), then we'll end up in the else
	            // clause below.
                //
                SipCheckVolume(deviceExtension);

                status = SipAcquireCollisionLock(deviceExtension);

                if (!NT_SUCCESS(status)) {
                    goto fail;
                }

                RepairingCollision = TRUE;

            } else {
                BOOLEAN rc;
                LINK_INDEX AllocatedIndex;

                //
                // We've completed the second pass after taking the collision
                // mutant, and the collision still exists, so now it's time
                // to fix it.
                //
                status = SipAllocateIndex(deviceExtension, &AllocatedIndex);

                if (!NT_SUCCESS(status)) {
                    SipDereferenceScb(newScb, RefsLookedUp);
                    SipReleaseCollisionLock(deviceExtension);
                    RepairingCollision = FALSE;
                    goto fail;
                }

                //
                // Don't bother getting the ntfs file id from ntfs.  If the one
                // in the reparse info is wrong, then this link index is assumed
                // bogus and will be deleted below.
                //

                //
                // Update the link index in the reparse info and write it out
                // to the file.
                //
                rc = SipIndicesIntoReparseBuffer(
                        reparseBuffer,
                        &newCSid,
                        &AllocatedIndex,
                        &newCSFileNtfsId,
                        &newLinkFileNtfsId,
                        &CSFileChecksumFromReparsePoint,
                        EligibleForPartialFinalCopy);

                ASSERT(rc);

                status = SipFsControlFile(
                                irpSp->FileObject,
                                DeviceObject,
                                FSCTL_SET_REPARSE_POINT,
                                reparseBuffer,
                                SIS_REPARSE_DATA_SIZE,
                                NULL,
                                0,
                                NULL);      // returned output buffer length

                if (!NT_SUCCESS(status)) {
                    SipDereferenceScb(newScb, RefsLookedUp);
                    SipReleaseCollisionLock(deviceExtension);
                    RepairingCollision = FALSE;
                    goto fail;
                }

                //
                // Release the collision mutex and restart at RecheckReparseInfo.
                //
                SipReleaseCollisionLock(deviceExtension);
                RepairingCollision = FALSE;
            }

            //
            // Note that we're not releasing the scb we collided with, since we
            // want that to stick around to catch any other threads that try to
            // open the file we're fixing.
            //
            if (NULL != scb) {
                SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

                SipDereferenceScb(scb, RefsLookedUp);
        
                SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
            }
            scb = newScb;
            newScb = NULL;
            goto recheckReparseInfo;

        } else if (RepairingCollision) {
            //
            // There must have been a thread race and we lost.  Just release
            // the collision mutex and continue.
            //
            SipReleaseCollisionLock(deviceExtension);
            RepairingCollision = FALSE;

        }

		ASSERT(newScb != scb);

		if (newScb->PerLink->COWingThread != Irp->Tail.Overlay.Thread) {
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			thingsChanged = SipWaitForFinalCopy(newScb->PerLink, FinalCopyInProgress);

			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			if (thingsChanged) {
				//
				// Go off and recheck this file's reparse point data.
				//

				SIS_MARK_POINT();

				SipDereferenceScb(newScb, RefsLookedUp);
				newScb = NULL;

				goto recheckReparseInfo;
			}
		} else {
			//
			// We're the COWingThread.  Since things can't change under the COWing thread,
			// this must be the first pass through here.  Assert that.
			//
			ASSERT(NULL == scb);
		}

		//
		// Switch scbs and complete the open.
		//

		if (NULL != scb) {
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

			SipDereferenceScb(scb, RefsLookedUp);
	
			SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		}
		scb = newScb;
		newScb = NULL;

		//
		// Check to make sure there's a CS file for this file.
		//
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		status = SipAssureCSFileOpen(scb->PerLink->CsFile);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (!NT_SUCCESS(status)) {
			//
			// The CS file open failed.  If it failed because the CS file isn't there, delete the
			// reparse point and open the underlying file.  Otherwise, let the open complete.
			//

			if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
				SIS_MARK_POINT();
				goto deleteReparsePoint;
			}

			SIS_MARK_POINT_ULONG(status);
			goto fail;
		}

		perLink = scb->PerLink;
		CSFile = perLink->CsFile;

		SipAcquireScb(scb);
		KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
		if (!(scb->PerLink->Flags & (SIS_PER_LINK_DIRTY|SIS_PER_LINK_BACKPOINTER_GONE)) && (scb->SizeBackedByUnderlyingFile == 0)) {
			scb->SizeBackedByUnderlyingFile = CSFile->FileSize.QuadPart;
		}
		KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);
		SipReleaseScb(scb);

    } else if (RepairingCollision) {
        //
        // There must have been a thread race and we lost.  Just release
        // the collision mutex and continue.
        //
        SipReleaseCollisionLock(deviceExtension);
        RepairingCollision = FALSE;
    }

	//
	// Assert that this really is the file we think it is.
	//
	ASSERT(newLinkIndex.QuadPart == perLink->Index.QuadPart);
	ASSERT(IsEqualGUID(&newCSid,&CSFile->CSid));
    ASSERT(newLinkFileNtfsId.QuadPart == perLink->LinkFileNtfsId.QuadPart);

	//
	// Determine if the reparse point has the right CS file checksum. 
	// 
	if ((CSFileChecksumFromReparsePoint != CSFile->Checksum)
#if		DBG
		&& (!(BJBDebug & 0x100))
#endif	// DBG
		) {
		//
		// This reparse point has the wrong checksum.  Delete the reparse point and let the open of
		// the underlying file proceed.
		// 
		SIS_MARK_POINT();

#if		DBG
		DbgPrint("SIS: SiCreate %d: checksum mismatch on reparse point.\n",__LINE__);
		DbgPrint("\tr: %08x%08x, c: %08x%08x\n", CSFileChecksumFromReparsePoint, CSFile->Checksum);
#endif	// DBG

		goto deleteReparsePoint;
	}

	SIS_MARK_POINT_ULONG(scb);

	//
	// Check that the reparse point has an NTFS file Id that matches the one in the
	// reparse point.  If it doesn't (which can happen with user set reparse points)
	// then delete the reparse point.
	//
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	status = SipQueryInformationFile(
				irpSp->FileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);								// returned length

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto fail;
	}

	if (internalInfo->IndexNumber.QuadPart != scb->PerLink->LinkFileNtfsId.QuadPart) {
		SIS_MARK_POINT_ULONG(scb->PerLink->LinkFileNtfsId.LowPart);

		//
		// The file and reparse point don't match on NTFS id.  Thus, the reparse point
		// is bogus and we need to delete it.
		//
		goto deleteReparsePoint;
	}

#if		0
	//
	// Verify that the link index for this file is within the range 
	// that we think could have possibly been allocated.
	//

	status = SipGetMaxUsedIndex(deviceExtension,MaxUsedIndex);
	if (NT_SUCCESS(status)) {
		if ((MaxUsedIndex->QuadPart < perLink->Index.QuadPart)) {
			//
			// One of the indices is bigger than what we think we could have possibly
			// allocated.  Something's fishy, so initiate a volume check.
			//
			SIS_MARK_POINT_ULONG(MaxUsedIndex->HighPart);
			SIS_MARK_POINT_ULONG(MaxUsedIndex->LowPart);
			SIS_MARK_POINT_ULONG(perLink->Index.HighPart);
			SIS_MARK_POINT_ULONG(perLink->Index.LowPart);

			SipCheckVolume(deviceExtension);
		}
	} else {
		//
		// Since this was only a consistency check, ignore that it failed.
		//
		SIS_MARK_POINT_ULONG(status);
	}
#endif	// 0

    //
    // If a volume check is underway, we're probably going to be writing the
    // backpointer back to disk, and to do that we must hold the backpointer
    // resource exclusive.  
    //
    if (deviceExtension->Flags & SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE) {
		SipAcquireBackpointerResource(CSFile,TRUE,TRUE);
        BPExclusive = TRUE;
    } else {
		SipAcquireBackpointerResource(CSFile,FALSE,TRUE);
        BPExclusive = FALSE;
    }
	SipAcquireScb(scb);

RecheckDelete:

	//
	// Check to see if this file is in the process of being finally deleted, and
	// deny access to it if it is.  This cures a race between where the uncleanup
	// count is decremented in siclnup.c and incremented here in the delete
	// case.
	//
	// Also check to see if the file has the DELETED bit set, in which case it's
	// been overwritten and we should just open it without checking the
	// backpointers.
	//

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	if ((perLink->Flags & (SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS|SIS_PER_LINK_FILE_DELETED))
#if		DBG
		|| (BJBDebug & 0x80)
#endif	// DBG
		) {

		SIS_MARK_POINT_ULONG(perLink);
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);
		SipReleaseScb(scb);
		SipReleaseBackpointerResource(CSFile);

		status = STATUS_ACCESS_DENIED;
		goto fail;
	}

	fileBackpointerGoneBitSet = (perLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE) ? TRUE : FALSE;

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (fileBackpointerGoneBitSet) {

		//
		// If the file's deleted, we shouldn't be sending anything to the
		// CS file.  Set SizeBacked to 0.  (This also happens in the
		// delete path, but there's a race with this code, so both
		// sides do it.
		//
		scb->SizeBackedByUnderlyingFile = 0;

	} else if (!context->openReparsePoint) {

        BOOLEAN foundBP;

		//
		// Check to see that the backpointer is here for this file.
		// We don't do the check on FILE_OPEN_REPARSE_POINT because
		// restore uses this to open links that were restored prior to
		// the files to which they referred.
		//

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
		status = SipCheckBackpointer(perLink, BPExclusive, &foundBP);
		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

        if (!NT_SUCCESS(status)) {

		    SIS_MARK_POINT_ULONG(status);
		    SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);

            //
            // STATUS_MEDIA_WRITE_PROTECTED means that SipCheckBackpointer
            // needs to write the backpointer back to disk, and to do so,
            // we must take the backpointer resource exclusive.
            //
            if (STATUS_MEDIA_WRITE_PROTECTED == status) {

		        SIS_MARK_POINT_ULONG(perLink);

				SipAcquireBackpointerResource(CSFile,TRUE,TRUE);
	            SipAcquireScb(scb);
                BPExclusive = TRUE;

                goto RecheckDelete;

            }

		    goto fail;
        }

        if (!foundBP) {
            LINK_INDEX newLinkIndex;

            //
            // The backpointer was not found.  SipCheckBackpointer has already
            // initiated a volume check, and we now need to add a backpointer.
            // (Volume checking is dependent on SiCreate fixing all link
            // corruption, including the backpointer.)  We don't have to worry
            // about the common store file being deleted before we can add a
            // backpointer because no common store files are ever deleted while
            // a volume check is in progress.
            //

	        ASSERT((perLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) == 0);

		    SIS_MARK_POINT_ULONG(perLink);
		    SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);

	        status = SipPrepareCSRefcountChange(
					    perLink->CsFile,
					    &newLinkIndex,
					    &perLink->LinkFileNtfsId,
					    SIS_REFCOUNT_UPDATE_LINK_CREATED);

            if (!NT_SUCCESS(status)) {
                goto fail;
            }

            //
            // We now hold the backpointer resource exclusive.  See if a race
            // with another thread has already fixed the backpointer.
            //
	        if (perLink->Flags & SIS_PER_LINK_BACKPOINTER_VERIFIED) {

                //
                // The backpointer has been fixed.  We're done.
                //
                status = SipCompleteCSRefcountChange(
				            perLink,
				            &perLink->Index,
					        perLink->CsFile,
	                        FALSE,
	                        TRUE);

                ASSERT(STATUS_SUCCESS == status);

            } else {

                BOOLEAN rc;

                //
                // Update the link index in the reparse info and write it out
                // to the file.
                //
                rc = SipIndicesIntoReparseBuffer(
	                    reparseBuffer,
	                    &CSFile->CSid,
	                    &newLinkIndex,
                        &CSFile->CSFileNtfsId,
                        &perLink->LinkFileNtfsId,
	                    &CSFile->Checksum,
						EligibleForPartialFinalCopy);

                ASSERT(rc);

	            status = SipFsControlFile(
					            irpSp->FileObject,
					            DeviceObject,
					            FSCTL_SET_REPARSE_POINT,
					            reparseBuffer,
					            SIS_REPARSE_DATA_SIZE,
					            NULL,
					            0,
						        NULL);      // returned output buffer length

                if (NT_SUCCESS(status)) {

                    //
                    // The backpointer has been fixed.  Reset the link index
                    // in the perlink structure.
                    //
                    SipUpdateLinkIndex(scb, &newLinkIndex);

                    status = SipCompleteCSRefcountChange(
				                perLink,
				                &perLink->Index,
					            perLink->CsFile,
	                            TRUE,
	                            TRUE);

                    if (! NT_SUCCESS(status)) {
                        goto fail;
                    }

                    ASSERT(STATUS_SUCCESS == status);
				    KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                    perLink->Flags |= SIS_PER_LINK_BACKPOINTER_VERIFIED;
				    KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                } else {

                    //
                    // Not much we can do.
                    //
                    SipCompleteCSRefcountChange(
				        perLink,
				        &perLink->Index,
					    perLink->CsFile,
	                    FALSE,
	                    TRUE);

                    goto fail;

                }
            }

			SipAcquireBackpointerResource(CSFile,FALSE,TRUE);
	        SipAcquireScb(scb);
            BPExclusive = FALSE;

            goto RecheckDelete;
        }
	}

	//
	// Check to see if we need to query allocated ranges for this file.
	//
	if (EligibleForPartialFinalCopy && !(scb->Flags & SIS_SCB_RANGES_INITIALIZED)) {
		//
		// We need to do a query allocated ranges for this file.  Any ranges that are
		// allocated we set dirty.
		//
#define	OUT_ARB_COUNT		10

		FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
		FILE_ALLOCATED_RANGE_BUFFER		outArb[OUT_ARB_COUNT];
		ULONG							returnedLength;
		ULONG							i;
		NTSTATUS						addRangeStatus;
		FILE_STANDARD_INFORMATION		standardInfo[1];

		inArb->FileOffset.QuadPart = 0;
		inArb->Length.QuadPart = MAXLONGLONG;

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		for (;;) {

			//
			// Query the allocated ranges for this file.
			//

			status = SipFsControlFile(
						irpSp->FileObject,
						DeviceObject,
						FSCTL_QUERY_ALLOCATED_RANGES,
						inArb,
						sizeof(FILE_ALLOCATED_RANGE_BUFFER),
						outArb,
						sizeof(FILE_ALLOCATED_RANGE_BUFFER) * OUT_ARB_COUNT,
						&returnedLength);

			//
			// Run through all of the returned allocated ranges and mark them dirty.
			//
			ASSERT((returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0) && 
				   (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) <= OUT_ARB_COUNT));

			//
			// If the query allocated ranges failed for some other reason that having too much to write
			// into the buffer we provided, fail the whole create.
			//
			if (!NT_SUCCESS(status) && (STATUS_BUFFER_OVERFLOW != status)) {
				SipReleaseScb(scb);
				SipReleaseBackpointerResource(CSFile);

				SIS_MARK_POINT_ULONG(status);
				goto fail;
			}

			ASSERT(NT_SUCCESS(status) || (returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER) == OUT_ARB_COUNT));

			for (i = 0; i < returnedLength/sizeof(FILE_ALLOCATED_RANGE_BUFFER); i++) {
				//
				// Assert that the allocated ranges are in order; if this isn't true the code will still work, but it
				// will query the same range repetedly.
				//
				ASSERT(i == 0 || outArb[i].FileOffset.QuadPart > outArb[i-1].FileOffset.QuadPart);

				//
				// The file has an allocated range.  Mark it dirty.
				//
#if		DBG
				if (BJBDebug & 0x100000) {
					DbgPrint("SIS: SiCreate %d: found a newly opened file with an allocated range, start 0x%x.0x%x, length 0x%x.0x%x\n",
                            __LINE__,
							outArb[i].FileOffset.HighPart,outArb[i].FileOffset.LowPart,
							outArb[i].Length.HighPart,outArb[i].Length.LowPart);
				}
#endif	// DBG

				SIS_MARK_POINT_ULONG(outArb[i].FileOffset.LowPart);
				SIS_MARK_POINT_ULONG(outArb[i].Length.LowPart);

				//
				// Mark the range dirty
				//
				addRangeStatus = SipAddRangeToWrittenList(
										deviceExtension,
										scb,
										&outArb[i].FileOffset,
										outArb[i].Length.QuadPart);

				scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

				if (outArb[i].FileOffset.QuadPart != 0 ||
					outArb[i].Length.QuadPart > deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
					scb->Flags |= SIS_SCB_BACKING_FILE_OPENED_DIRTY;
				}


				if (!NT_SUCCESS(addRangeStatus)) {
					SipReleaseScb(scb);
					SipReleaseBackpointerResource(CSFile);

					status = addRangeStatus;
					SIS_MARK_POINT_ULONG(status);
					goto fail;
				}
			}

			//
			// If this isn't the last iteration, update the inArb.
			//
			if (STATUS_BUFFER_OVERFLOW == status) {
				//
				// Assert that we're making progress.
				//
				ASSERT((outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart >= inArb->FileOffset.QuadPart) && (outArb[OUT_ARB_COUNT-1].Length.QuadPart > 0));

				//
				// Move up our input range.
				//
				inArb->FileOffset.QuadPart = outArb[OUT_ARB_COUNT-1].FileOffset.QuadPart + outArb[OUT_ARB_COUNT-1].Length.QuadPart;
				inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;
				
			} else {
				break;
			}
#undef	OUT_ARB_COUNT
		}

		//
		// Check the file length.  If it is less than the size of the common store file, then
		// reduce sizeBackedByUnderlyingFile.
		//

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		status = SipQueryInformationFile(
					irpSp->FileObject,
					DeviceObject,
					FileStandardInformation,
					sizeof(FILE_STANDARD_INFORMATION),
					standardInfo,
					NULL);

		SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

		if (!NT_SUCCESS(status)) {
			SipReleaseScb(scb);
			SipReleaseBackpointerResource(CSFile);
			SIS_MARK_POINT_ULONG(status);

			goto fail;
		}

		if (standardInfo->EndOfFile.QuadPart < scb->PerLink->CsFile->FileSize.QuadPart) {
			scb->SizeBackedByUnderlyingFile = standardInfo->EndOfFile.QuadPart;
			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE|SIS_SCB_BACKING_FILE_OPENED_DIRTY;
		} else if (standardInfo->EndOfFile.QuadPart != scb->PerLink->CsFile->FileSize.QuadPart) {
			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE|SIS_SCB_BACKING_FILE_OPENED_DIRTY;
		}

		scb->Flags |= SIS_SCB_RANGES_INITIALIZED;
	}


	//
	// Allocate a perFO for this file object.  We couldn't do this in
	// stage 1 because FsRtl insists that file objects that we claim
	// have FsContext filled in, which isn't the case until we get
	// here.
	//
	perFO = SipCreatePerFO(irpSp->FileObject,scb,DeviceObject);

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (perFO == NULL) {
#if		DBG
		DbgPrint("SIS: SiCreate: unable to allocate per-FO\n");
#endif	// DBG

		SIS_MARK_POINT_ULONG(scb);

		SipReleaseScb(scb);
		SipReleaseBackpointerResource(CSFile);

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto fail;
	}

	//
	// If this was a FILE_OPEN_REPARSE_POINT create, indicate that in the perFO.
	//
	if (context->openReparsePoint) {
		perFO->Flags |= SIS_PER_FO_OPEN_REPARSE;
	}

	//
	// If this is a delete-on-close create, set the appropriate flag in the
	// perFO.
	//
	if (irpSp->Parameters.Create.Options & FILE_DELETE_ON_CLOSE) {
		perFO->Flags |= SIS_PER_FO_DELETE_ON_CLOSE;
	}

	//
	// Indicate that we expect to see a cleanup for this file object.
	// The UnClose count is incremented in the per-FO allocator, because
	// we will see closes (but not cleanups) for stream file objects.
	//
	InterlockedIncrement(&perFO->fc->UncleanCount);
	perFO->Flags |= SIS_PER_FO_UNCLEANUP;

	SipReleaseScb(scb);
	SipReleaseBackpointerResource(CSFile);

	//
	// If this is a COMPLETE_ON_OPLOCKED create and it returned 
	// STATUS_OPLOCK_BREAK_IN_PROGRESS, launch an irp with a
	// FSCTL_OPLOCK_BREAK_NOTIFY on this file so that we can tell
	// when we can allow reads to go to the common store file through
	// this file object.
	//
	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == context->Iosb->Status) {
		PIRP					fsctlIrp;
		PIO_STACK_LOCATION		fsctlIrpSp;

		SIS_MARK_POINT_ULONG(scb);

		//
		// Take a reference to the file object so that it won't go away until the irp
		// completes.
		//
		status = ObReferenceObjectByPointer(
					irpSp->FileObject,
					FILE_READ_DATA,
					*IoFileObjectType,
					KernelMode);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto fail;
		}

		//
		// Allocate and set  up an irp for an FSCTL_OPLOCK_BREAK_NOTIFY.
		//

		fsctlIrp = IoAllocateIrp( deviceExtension->AttachedToDeviceObject->StackSize, FALSE);
		if (NULL == fsctlIrp) {
			SIS_MARK_POINT_ULONG(scb);

			ObDereferenceObject(irpSp->FileObject);

			status = STATUS_INSUFFICIENT_RESOURCES;
			goto fail;
		}

	    fsctlIrp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
	    fsctlIrp->Tail.Overlay.Thread = PsGetCurrentThread();
	    fsctlIrp->RequestorMode = KernelMode;

	    //
	    // Fill in the service independent parameters in the IRP.
	    //

	    fsctlIrp->UserEvent = (PKEVENT) NULL;
    	fsctlIrp->UserIosb = NULL;
	    fsctlIrp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    	fsctlIrp->Overlay.AsynchronousParameters.UserApcContext = NULL;

	    //
    	// Get a pointer to the stack location for the first driver.  This will be
	    // used to pass the original function codes and parameters.
    	//

	    fsctlIrpSp = IoGetNextIrpStackLocation( fsctlIrp );
    	fsctlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
		fsctlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
	    fsctlIrpSp->FileObject = irpSp->FileObject;

		fsctlIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
		fsctlIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;
		fsctlIrpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_OPLOCK_BREAK_NOTIFY;
		fsctlIrpSp->Parameters.FileSystemControl.Type3InputBuffer = NULL;

		fsctlIrp->AssociatedIrp.SystemBuffer = NULL;
		fsctlIrp->Flags = 0;

		IoSetCompletionRoutine(
			fsctlIrp,
			SiOplockBreakNotifyCompletion,
			perFO,
			TRUE,
			TRUE,
			TRUE);

		//
		// Mark the perFO as waiting for an opbreak.
		//

		perFO->Flags |= SIS_PER_FO_OPBREAK;

		//
		// Launch the irp.  It's asynchronous and the completion routine will clean it up.
		//
		status = IoCallDriver(deviceExtension->AttachedToDeviceObject, fsctlIrp);

		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SiCreate: launched FSCTL_OPLOCK_BREAK_NOTIFY on irp %p, perFO %p, fo %p, status %x\n",
						fsctlIrp, perFO, perFO->fileObject, status);
		}
#endif	// DBG

	}

	//
	// Drop the reference to the SCB that was created by the lookup,
	// since it is now referenced by the perFO that we just allocated.
	//
	SipDereferenceScb(scb, RefsLookedUp);

	//
	// Make sure that we've looked up the fileId for this perLink.
	//
	ASSERT( SipAssureNtfsIdValid(perFO, perLink) );

	//
	// Now complete the original irp with the completion status that came back from the
	// actual open of the file (unless we have an oplock break in progress, in which
	// case we return that).
	//
	ASSERT(NT_SUCCESS(context->Iosb->Status));	// we peeled off the failure case a while back

	Irp->IoStatus = *context->Iosb;
	status = Irp->IoStatus.Status;

#if		DBG
	if (BJBDebug & 0x2) {
		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

		DbgPrint("SIS: SiCreate %d: completing with status %x, scb %p, fileObject %p, %0.*ws\n",
                    __LINE__,
					Irp->IoStatus.Status,
					scb,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	SIS_TIMING_POINT_SET(SIS_TIMING_CLASS_CREATE);

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}
	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}

	return status;

fail:

	SIS_MARK_POINT_ULONG(status);

	if (NULL != perFO) {
		SipDeallocatePerFO(perFO, DeviceObject);
	}

	if (NULL != scb) {
		SipDereferenceScb(scb, RefsLookedUp);
	}

	if (completedStage2) {
		SipUnopenFileObject(DeviceObject, Irp);
	}

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}

	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}
	
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;

deleteReparsePoint:

	ASSERT(NT_SUCCESS(context->Iosb->Status));

	//
	// If this wasn't a FILE_OPEN_REPARSE_POINT create, then delete the bogus reparse point.
	// If it was, then we leave the reparse point but don't attach to the file or do anything else
	// with it.
	//

	if (!context->openReparsePoint) {

		//
		// For whatever reason, we've decided that this is a bogus SIS reparse point and
		// that it should be deleted.  Do so and then let the open complete successfully
		// for the file that used to be under the reparse point.
		//

#if		DBG
		if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
			DbgPrint("SIS: SiCreate: deleting reparse point for f.o. 0x%x\n", irpSp->FileObject);
		}
#endif	// DBG

		ASSERT(NULL == perFO);

		if (NULL != scb) {
			SipDereferenceScb(scb, RefsLookedUp);
		}

		reparseBuffer->ReparseTag = IO_REPARSE_TAG_SIS;
		reparseBuffer->ReparseDataLength = 0;
		reparseBuffer->Reserved = 0xcabd;	// ???

		status = SipFsControlFile(
					irpSp->FileObject,
					DeviceObject,
					FSCTL_DELETE_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer),
					NULL,										// output buffer
					0,											// output buffer length
					NULL);										// returned output buffer length

		SIS_MARK_POINT_ULONG(status);

#if		DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SiCreate: unable to delete bogus reparse point for f.o. 0x%x, 0x%x\n",irpSp->FileObject,status);
		}
#endif	// DBG
	}

openUnderlyingFile:

	//
	// Regardless of whether we deleted the reparse point,
	// complete the create with whatever status came back when we opened
	// the reparse point.
	//

	ASSERT(completedStage2);

	Irp->IoStatus = *context->Iosb;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	if (NULL != fileName->Buffer) {
		ExFreePool(fileName->Buffer);
		fileName->Buffer = NULL;
	}
	if (NULL != relatedFileObject) {
		ObDereferenceObject(relatedFileObject);
		relatedFileObject = NULL;
	}

	return context->Iosb->Status;
	
}
#undef	reparseBuffer


NTSTATUS
SiCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++
Routine Description:

    This function is the create/open completion routine for this filter
    file system driver.  If a file is a SIS link, it will stop the
	IRP completion and allow SiCreate to deal with the SIS
	link.  Otherwise, it will allow the irp to complete normally.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - a PSIS_CREATE_COMPLETION_CONTEXT

Return Value:

    The function value is STATUS_SUCCESS or STATUS_MORE_PROCESSING_REQUIRED
	depending on whether the file was a SIS reparse point.

--*/

{
	PSIS_CREATE_COMPLETION_CONTEXT 	context = (PSIS_CREATE_COMPLETION_CONTEXT)Contxt;
	BOOLEAN 						completeFinished;
	BOOLEAN							validReparseStructure;
	PREPARSE_DATA_BUFFER 			reparseBuffer;

    UNREFERENCED_PARAMETER( DeviceObject );

	//
	// Clear the pending returned bit in the irp.  This is necessary because SiCreate
	// waits for us even if the lower level returned pending.
	//
	Irp->PendingReturned = FALSE;

	SIS_MARK_POINT_ULONG(Irp);

#if		DBG
	if (BJBDebug & 0x2) {
		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

		DbgPrint("SIS: SiCreateCompletion %d: status: %x, fo %p, %0.*ws\n",
                    __LINE__,
					Irp->IoStatus.Status,
					irpSp->FileObject,
					irpSp->FileObject->FileName.Length / sizeof(WCHAR),irpSp->FileObject->FileName.Buffer);
	}
#endif	// DBG

	context->alternateStream = FALSE;

    if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
        (Irp->IoStatus.Information == IO_REPARSE_TAG_SIS)) {

		SIS_MARK_POINT_ULONG(context);

		//
		// It's a SIS reparse point.  Check to make sure that it's
		// a sensible request and a sensible reparse point.
		//

		reparseBuffer = (PREPARSE_DATA_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

		//
		// Verify that this is the terminal part of the pathname; ie., that someone
		// isn't trying to use a SIS reparse point as a directory name.  For reasons
		// that aren't entirely clear, NTFS returns the length of the remaining
		// pathname component in the Reserved field in the reparse buffer.  Check that
		// it's zero here, and fail if it's not.
		//
		if (reparseBuffer->Reserved != 0) {
			// 
			// This is a SIS link being used as the non-final portion of a pathname.
			// See if it is for a directory or for a named stream.  If it's a directory,
			// then someone has used a SIS link as a directory in an open request, which
			// is invalid and should be failed.  If it's a named stream, then we allow the
			// open to proceed to the underlying stream.
			//
			PIO_STACK_LOCATION	irpSp = IoGetCurrentIrpStackLocation(Irp);
			PUNICODE_STRING		fileName = &irpSp->FileObject->FileName;
			WCHAR				delimiter;

			SIS_MARK_POINT_ULONG(reparseBuffer->Reserved);

			//
			// The Reserved field in the reparse buffer is the length of the *unprocessed*
			// portion of the name.  Make sure that it's meaningful, and that it points at
			// either a colon or backslash.
			//
			ASSERT(reparseBuffer->Reserved <= fileName->Length);

			delimiter = fileName->Buffer[(fileName->Length - reparseBuffer->Reserved)/sizeof(WCHAR)];

#if		0
			//
			// There's a bug in NTFS where it fills in the reserved field with a number that's one
			// character too big (unless the file name started with a ':', in which case it gets
			// it right).  Compensate for that.
			//
			if (
#if		DBG
				(!(BJBDebug & 0x04000000)) && 
#endif	// DBG
				(delimiter != '\\' && (fileName->Length > reparseBuffer->Reserved))) {
				ASSERT(reparseBuffer->Reserved >= 4);
				reparseBuffer->Reserved -= sizeof(WCHAR);
				delimiter = fileName->Buffer[(fileName->Length - reparseBuffer->Reserved)/sizeof(WCHAR)];
			}
#endif	// 0

			ASSERT((':' == delimiter) || ('\\' == delimiter));

			if (':' == delimiter) {
				//
				// It's a stream name delimiter.  If it's the last character of the file name or it's followed
				// immediately by another ':', then it's the unnamed stream and we let it be.  Otherwise, we open
				// the alternate stream.
				//
				SIS_MARK_POINT();
				if ((reparseBuffer->Reserved == fileName->Length) ||
					(':' != fileName->Buffer[(fileName->Length - (reparseBuffer->Reserved - sizeof(WCHAR))) / sizeof(WCHAR)])) {

					context->alternateStream = TRUE;
					completeFinished = FALSE;

					goto finish;
				} else {
					//
					// It's the ::$DATA stream.  Fall through.
					//
					SIS_MARK_POINT();
				}
			} else {
				//
				// It's a directory.  Fail the request.
				//
				SIS_MARK_POINT();

				Irp->IoStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
				Irp->IoStatus.Information = 0;

				completeFinished = TRUE;

				goto finish;
			}
		}

		validReparseStructure = SipIndicesFromReparseBuffer(
									reparseBuffer,
									&context->CSid,
									&context->LinkIndex,
                                    &context->CSFileNtfsId,
                                    &context->LinkFileNtfsId,
									NULL,						// CS file checksum, handled in stage 2
									NULL,
									NULL);

		ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);
		Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
#if	DBG
		reparseBuffer = NULL;	// Just for safety
#endif	// DBG

		if (!validReparseStructure) {
			SIS_MARK_POINT();

			//
			// It's a corrupt reparse buffer.  We'll set FILE_CORRUPT_ERROR here, and SiCreate will pick it up
			// and let the user open the underlying file without SIS.
			//
			Irp->IoStatus.Status = STATUS_FILE_CORRUPT_ERROR;
			
			completeFinished = FALSE;

			goto finish;
		}

		SIS_MARK_POINT_ULONG(context->LinkIndex.LowPart);

		completeFinished = FALSE;
	} else if ((Irp->IoStatus.Status == STATUS_REPARSE) && context->openReparsePoint && context->overwriteOrSupersede) {
		//
		// The user wanted to open the reparse point overwrise or supersede, and it's a non-SIS
		// reparse point.  We need to send the request back to SiCreate
		// and let it resubmit it with the open reparse flag reset.  First,
		// blow away the reparse buffer.
		//

		ASSERT(NULL != Irp->Tail.Overlay.AuxiliaryBuffer);

		ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);
		Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

		completeFinished = FALSE;
	} else if (NT_SUCCESS(Irp->IoStatus.Status) && 
				context->openReparsePoint && 
				(!context->overwriteOrSupersede) &&
				(STATUS_REPARSE != Irp->IoStatus.Status)) {
		//
		// It was an open reparse point request without supersede/overwrite specified.
		// We need to send the request back to SiCreate to see if the file is a SIS reparse
		// point.  We don't need to blow away the reparse buffer, because there isn't
		// one.
		//

		//
		// We allow STATUS_REPARSE returns when openReparsePoint and !overwriteOrSupersede
		// to fall through and complete.  These typically come because of mount points that
		// are used as an internal pathname component (OPEN_REPARSE only applies to the
		// final component).  If we eventually wind up at a SIS reparse point, we'll make another
		// trip through SiCreate and catch it then.
		//

		completeFinished = FALSE;
	} else {
		//
		// It's not a SIS reparse point, and so not our problem.  Allow the normal
		// completion to happen.
		//
		completeFinished = TRUE;
	}

finish:

	*context->Iosb = Irp->IoStatus;
	context->completeFinished = completeFinished;

	KeSetEvent(context->event, IO_NO_INCREMENT, FALSE);

	if (completeFinished) {
		SIS_MARK_POINT();
		return STATUS_SUCCESS;
	} else {
		SIS_MARK_POINT();
		return STATUS_MORE_PROCESSING_REQUIRED;
	}
}


NTSTATUS
SiCreateCompletionStage2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

	A user did a create, which completed with a SIS reparse tag.  We caught
	it, added FILE_OPEN_REPARSE_POINT and sent it back down.  It's now 
	completed.  Bounce control back to SiCreate, cutting off the
	Irp completion processing here.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - Points at a SIS_CREATE_COMPLETION_CONTEXT

Return Value:

    The function value is STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
	PSIS_CREATE_COMPLETION_CONTEXT 	context = (PSIS_CREATE_COMPLETION_CONTEXT)Contxt;

    UNREFERENCED_PARAMETER( DeviceObject );
	SIS_MARK_POINT();

	//
	// Clear the pending returned bit in the irp.  This is necessary because SiCreate
	// waits for us even if the lower level returned pending.
	//
	Irp->PendingReturned = FALSE;

	*context->Iosb = Irp->IoStatus;
	KeSetEvent(context->event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
SipWaitForFinalCopy(
	IN PSIS_PER_LINK	perLink,
	IN BOOLEAN			FinalCopyInProgress)
/*++

Routine Description:

	Wait for a file to be out of final copy processing.  If the file is being
	deleted, then we just pretend that final copy isn't requested, and return
	FALSE.
	

Arguments:

	perLink	-	The per-link for the file for which we want to wait

	FinalCopyInProgress - The value returned when we looked up the SCB.

Return Value:

	TRUE if the file has changed and needs to be reevaluated, FALSE if it's OK
	to use this per link.

--*/
{
	NTSTATUS 			status;
	KIRQL 				OldIrql;
	BOOLEAN 			finalCopyDone;
	BOOLEAN				fileDeleted;

	if (FinalCopyInProgress) {

		SIS_MARK_POINT_ULONG(perLink);
	
		status = KeWaitForSingleObject(perLink->Event, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);
	
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		if (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) {
			finalCopyDone = TRUE;
		} else {
			finalCopyDone = FALSE;
		}
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);
	
		return finalCopyDone;
	} else {
		//
		// Handle the case where we got in between when the final copy done
		// bit was set and the last reference to the file dropped by cow.c.
		// If this happens, we'll see the final copy done bit set, but won't have
		// final copy in progress set and won't get a wakeup.  
		// In this case, just drop our reference and retry.  This shouldn't 
		// produce a livelock because the reparse point should be gone and the 
		// next trip through create should follow the standard, non-SIS path.
		//
	
		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
		finalCopyDone = (perLink->Flags & SIS_PER_LINK_FINAL_COPY_DONE) ? TRUE : FALSE;
		fileDeleted = (perLink->Flags & (SIS_PER_LINK_FILE_DELETED|SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS)) ? TRUE : FALSE;
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		//
		// The file is going or gone, so there's no need to wait for any final copy processing.
		//
		if (fileDeleted) {
			SIS_MARK_POINT_ULONG(perLink);

			return FALSE;
		}
	
		if (finalCopyDone) {
			SIS_MARK_POINT_ULONG(perLink);
	
			return TRUE;
		}
	}

	return FALSE;
}

NTSTATUS
SipAssureCSFileOpen(
	IN PSIS_CS_FILE		CSFile)
/*++

Routine Description:

	Make sure that the actual file corresponding to the given CSFile
	object (along with its backpointer stream) is actually open.  If it
	isn't, post a worker thread request to do it, and wait for it to
	complete.

Arguments:

	CSFile - the common store file object

Return Value:

	status of the open; STATUS_SUCCESS if it was already open.

--*/
{
	NTSTATUS			status;

	KeEnterCriticalRegion();		// We must disable APCs while holding a mutant in a user thread
	status = SipAcquireUFO(CSFile/*,TRUE*/);

//	SIS_MARK_POINT_ULONG(CSFile);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		KeLeaveCriticalRegion();
		return status;
	}

    if (CSFile->Flags & CSFILE_FLAG_CORRUPT) {

		//
		// The CS file backpointer stream is corrupt, which means that we're
		// doing a volume check, and this file is unavailable until the volume
		// check completes.  Indicate a retry.
		//

        status = STATUS_RETRY;

    } else if ((NULL == CSFile->UnderlyingFileObject) || 
			   (NULL == CSFile->UnderlyingFileHandle) ||
			   (NULL == CSFile->BackpointerStreamFileObject) ||
			   (NULL == CSFile->BackpointerStreamHandle)) {

		SI_OPEN_CS_FILE openRequest[1];
		//
		// No one has opened this CS file yet, so we need
		// to do it.  Queue up a work item to do it on
		// a worker thread.
		//

		SIS_MARK_POINT_ULONG(CSFile);

		openRequest->CSFile = CSFile;
        openRequest->openByName = FALSE;

		KeInitializeEvent(
			openRequest->event,
			NotificationEvent,
			FALSE);

		ExInitializeWorkItem(
			openRequest->workQueueItem,
			SipOpenCSFile,
			openRequest);

		ExQueueWorkItem(
			openRequest->workQueueItem,
			CriticalWorkQueue);

		status = KeWaitForSingleObject(
					openRequest->event,
					Executive,
					KernelMode,
					FALSE,
					NULL);

		//
		// If this fails, we're hosed because the worker thread might touch the openRequest,
		// which is on our stack.
		//
		ASSERT(status == STATUS_SUCCESS);

		status = openRequest->openStatus;

		if ((STATUS_FILE_INVALID == status) || (CSFile->Flags & CSFILE_FLAG_CORRUPT)) {
			//
			// We're doing a volume check, so tell the user to retry later when the check
			// has gotten far enough.
			//
			status = STATUS_RETRY;
		}

	} else {
		//
		// The underlying file was already open, so we just succeed.
		//
		status = STATUS_SUCCESS;
	}
	SipReleaseUFO(CSFile);
	KeLeaveCriticalRegion();

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sidebug.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sidebug.c

Abstract:

	Various debugging and instrumentation code that isn't used in the product

Authors:

    Bill Bolosky, Summer, 1998

Environment:

    Kernel mode


Revision History:
	June, 1998 - split out of other files


--*/

#include "sip.h"

#if		TIMING
KSPIN_LOCK	SipTimingLock[1];

SIS_TREE	SipTimingPairTree[1];
SIS_TREE	SipThreadLastPointTree[1];

//
// How many timing points are currently in the timing point tree.
//
ULONG		SipTimingPointEntries = 0;

typedef	struct _SIS_TIMING_PAIR_KEY {
	PCHAR							file1;
	ULONG							line1;
	PCHAR							file2;
	ULONG							line2;
} SIS_TIMING_PAIR_KEY, *PSIS_TIMING_PAIR_KEY;

typedef	struct _SIS_TIMING_PAIR {
	RTL_SPLAY_LINKS					Links;

	SIS_TIMING_PAIR_KEY;

	LONGLONG						accumulatedTime;
	LONGLONG						accumulatedSquareTime;
	LONGLONG						maxTime;
	LONGLONG						minTime;
	ULONG							count;

	struct _SIS_TIMING_PAIR			*next;
} SIS_TIMING_PAIR, *PSIS_TIMING_PAIR;

typedef	struct _SIS_THREAD_LAST_POINT_KEY {
	HANDLE							threadId;
} SIS_THREAD_LAST_POINT_KEY, *PSIS_THREAD_LAST_POINT_KEY;

typedef	struct _SIS_THREAD_LAST_POINT {
	RTL_SPLAY_LINKS					Links;

	SIS_THREAD_LAST_POINT_KEY;

	PCHAR							file;
	LONGLONG						time;
	ULONG							line;

	struct _SIS_THREAD_LAST_POINT	*next;
	struct _SIS_THREAD_LAST_POINT	*prev;
} SIS_THREAD_LAST_POINT, *PSIS_THREAD_LAST_POINT;

PSIS_TIMING_PAIR			SipTimingPairStack = NULL;
SIS_THREAD_LAST_POINT		SipThreadLastPointHeader[1];

ULONG	SipEnabledTimingPointSets = MAXULONG;

BOOLEAN		SipTimingInitialized = FALSE;

LONG NTAPI 
SipTimingPairCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_TIMING_PAIR_KEY	key = Key;
	PSIS_TIMING_PAIR		node = Node;

	if (key->file1 < node->file1) return -1;
	if (key->file1 > node->file1) return 1;
	if (key->line1 < node->line1) return -1;
	if (key->line1 > node->line1) return 1;

	if (key->file2 < node->file2) return -1;
	if (key->file2 > node->file2) return 1;
	if (key->line2 < node->line2) return -1;
	if (key->line2 > node->line2) return 1;

	return 0;
}

LONG NTAPI
SipThreadLastPointCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_THREAD_LAST_POINT_KEY	key = Key;
	PSIS_THREAD_LAST_POINT		node = Node;

	if (key->threadId > node->threadId) return -1;
	if (key->threadId < node->threadId) return 1;
	
	return 0;
}


VOID
SiThreadCreateNotifyRoutine(
	IN HANDLE		ProcessId,
	IN HANDLE		ThreadId,
	IN BOOLEAN		Create)
/*++
Routine Description:

	This routine is called whenever any thread is created or deleted in the system.
	We're interested in tracking thread deletions so that we can clean out any
	entries that they might have in the last point list.

Arguments:

	ProcessId - The process in which the created/deleted thread lives.  Unused.
	ThreadId  -	The ID of the newly created/deleted thread
	Create	  - Whether the thread is being created or deleted.

Return Value:

	void

--*/
{
	KIRQL						OldIrql;
	SIS_THREAD_LAST_POINT_KEY	key[1];
	PSIS_THREAD_LAST_POINT		lastPoint;

	if (Create) {
		//
		// We only care about deletes; new threads are handled correctly the first
		// time they execute a SIS_TIMING_POINT.
		//
		return;
	}
	

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	key->threadId = PsGetCurrentThreadId();
	lastPoint = SipLookupElementTree(SipThreadLastPointTree, key);

	if (NULL != lastPoint) {
		SipDeleteElementTree(SipThreadLastPointTree, lastPoint);

		//
		// Remove it from the linked list.
		//
		ASSERT(lastPoint != SipThreadLastPointHeader);

		lastPoint->next->prev = lastPoint->prev;
		lastPoint->prev->next = lastPoint->next;

		//
		// And free its memory.
		//

		ExFreePool(lastPoint);
	}

	KeReleaseSpinLock(SipTimingLock, OldIrql);
}


VOID
SipInitializeTiming()
/*++

Routine Description:

	Initialize the internal timing system structures.  Must be called once
	per system, and must be called before any SIS_TIMING_POINTS are called.

Arguments:

	None

Return Value:

	None

--*/
{
	NTSTATUS	status;

	KeInitializeSpinLock(SipTimingLock);

	SipThreadLastPointHeader->next = SipThreadLastPointHeader->prev = SipThreadLastPointHeader;

	status = PsSetCreateThreadNotifyRoutine(SiThreadCreateNotifyRoutine);

	if (!NT_SUCCESS(status)) {
		//
		// We include this DbgPrint even in free builds on purpose.  TIMING is only
		// going to be turned on when a developer is running, not in the retail build,
		// so this string won't ever get sent to a customer.  However, it makes lots of
		// sense for a developer to want to run the timing on the free build, since it
		// won't have the debugging code timing distortions caused by running checked.
		// That developer probably wants to know if the initialization failed, so I'm
		// leaving this DbgPrint turned on.
		//

		DbgPrint("SIS: SipInitializeTiming: PsSetCreateThreadNotifyRoutine failed, 0x%x\n",status);

		//
		// Just punt without setting SipTimingInitialized.
		//

		return;
	}


	//
	// Set up the splay trees.
	//

	SipInitializeTree(SipTimingPairTree, SipTimingPairCompareRoutine);
	SipInitializeTree(SipThreadLastPointTree, SipThreadLastPointCompareRoutine);

	SipTimingInitialized = TRUE;	
}


VOID
SipTimingPoint(
	IN PCHAR							file,
	IN ULONG							line,
	IN ULONG							n)
/*++

Routine Description:

	An instrumentation routine for measuring performance.  This routine keeps
	track of pairs of timing points for particular threads with associated times,
	and can produce statistics about the amount of (wall clock) time that has
	elapsed between them.

Arguments:

	file - The file holding the timing point.

	line - the line number within the file that has the timing point

	n - the timing point set; these can be enabled and disabled dynamically

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	LARGE_INTEGER				perfTimeIn = KeQueryPerformanceCounter(NULL);	
	LARGE_INTEGER				perfTimeOut;
	SIS_THREAD_LAST_POINT_KEY	lastPointKey[1];
	PSIS_THREAD_LAST_POINT		lastPoint;
	SIS_TIMING_PAIR_KEY			timingPairKey[1];
	PSIS_TIMING_PAIR			timingPair;
	LONGLONG					thisTime;


	if (!SipTimingInitialized) {
		SIS_MARK_POINT();
		return;
	}

	ASSERT(n < 32);
	if (!(SipEnabledTimingPointSets & (1 << n))) {
		//
		// This timing point set isn't enabled.  Just ignore the call.
		//
		return;
	}

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	//
	// Look up the last SIS_TIMING_POINT called by this thread.
	//

	lastPointKey->threadId = PsGetCurrentThreadId();
	lastPoint = SipLookupElementTree(SipThreadLastPointTree, lastPointKey);

	if (NULL == lastPoint) {
		//
		// This is the first timing point for this thread.  Just make a new
		// entry in the tree and continue.
		//

		lastPoint = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_THREAD_LAST_POINT), ' siS');

		if (NULL == lastPoint) {
			//
			// See the comment in SipInitializeTiming for justification of why we have this
			// DbgPrint on even in a free build.
			//
			DbgPrint("SIS: SipTimingPoint: unable to allocate new SIS_THREAD_LAST_POINT.\n");
			goto done;
		}

		lastPoint->threadId = lastPointKey->threadId;

		SipInsertElementTree(SipThreadLastPointTree, lastPoint, lastPointKey);

		//
		// Insert the thread in the global last point linked list.
		//
		lastPoint->next = SipThreadLastPointHeader->next;
		lastPoint->prev = SipThreadLastPointHeader;
		lastPoint->next->prev = lastPoint;
		lastPoint->prev->next = lastPoint;

	} else {
		//
		// This isn't the first time this thread has done a timing point.  Make an
		// entry in the pairs tree.
		//

		thisTime = perfTimeIn.QuadPart - lastPoint->time;

		timingPairKey->file1 = lastPoint->file;
		timingPairKey->line1 = lastPoint->line;
		timingPairKey->file2 = file;
		timingPairKey->line2 = line;

		timingPair = SipLookupElementTree(SipTimingPairTree, timingPairKey);

		if (NULL == timingPair) {
			//
			// This is the first time we've seen this pair of timing points in sequence.
			// Build a new timing pair.
			//

			timingPair = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_TIMING_PAIR), ' siS');

			if (NULL == timingPair) {
				DbgPrint("SIS: SipTimingPoint: couldn't allocate timing pair.\n");
				goto done;
			} else {
				//
				// Initialize the new timing pair entry.
				//
				timingPair->file1 = timingPairKey->file1;
				timingPair->line1 = timingPairKey->line1;
				timingPair->file2 = timingPairKey->file2;
				timingPair->line2 = timingPairKey->line2;

				timingPair->accumulatedTime = 0;
				timingPair->accumulatedSquareTime = 0;
				timingPair->maxTime = 0;
				timingPair->minTime = perfTimeIn.QuadPart - lastPoint->time;

				timingPair->count = 0;

				timingPair->next = SipTimingPairStack;
				SipTimingPairStack = timingPair;

				SipInsertElementTree(SipTimingPairTree, timingPair, timingPairKey);

				SipTimingPointEntries++;
			}
		}

		//
		// Update the statistice in the timing pair.
		//
		timingPair->accumulatedTime += thisTime;
		timingPair->accumulatedSquareTime += thisTime * thisTime;

		if (timingPair->maxTime < thisTime) {
			timingPair->maxTime = thisTime;
		}

		if (timingPair->minTime > thisTime) {
			timingPair->minTime = thisTime;
		}

		timingPair->count++;
	}

done:

	if (NULL != lastPoint) {
		//
		// Finally, update the last point information.  Recheck the time here in
		// order to reduce the interference from the timing function itself.
		//

		lastPoint->file = file;
		lastPoint->line = line;

		perfTimeOut = KeQueryPerformanceCounter(NULL);
		lastPoint->time = perfTimeOut.QuadPart;
	}

	KeReleaseSpinLock(SipTimingLock, OldIrql);

}

VOID
SipClearTimingInfo()
{
	KIRQL					OldIrql;
	PSIS_THREAD_LAST_POINT	lastPoint;

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	//
	// First blow away all of the thread entries.
	//

	lastPoint = SipThreadLastPointHeader->next;
	while (SipThreadLastPointHeader != lastPoint) {
		PSIS_THREAD_LAST_POINT		next = lastPoint->next;

		//
		// Remove it from the tree
		//
		SipDeleteElementTree(SipThreadLastPointTree, lastPoint);

		//
		// Remove it from the linked list.
		//
		lastPoint->next->prev = lastPoint->prev;
		lastPoint->prev->next = lastPoint->next;

		//
		// Free its memory.
		//
		ExFreePool(lastPoint);

		lastPoint = next;
	}

	//
	// Now blow away all of the pair entries.
	//

	while (NULL != SipTimingPairStack) {
		PSIS_TIMING_PAIR		next = SipTimingPairStack->next;

		ASSERT(0 != SipTimingPointEntries);

		SipDeleteElementTree(SipTimingPairTree, SipTimingPairStack);

		ExFreePool(SipTimingPairStack);

		SipTimingPairStack = next;
		SipTimingPointEntries--;
	}

	ASSERT(0 == SipTimingPointEntries);

	KeReleaseSpinLock(SipTimingLock, OldIrql);
}

VOID
SipDumpTimingInfo()
{
	KIRQL				OldIrql;
	LARGE_INTEGER		perfFreq;
	PSIS_TIMING_PAIR	timingPair;

	KeQueryPerformanceCounter(&perfFreq);

	KeAcquireSpinLock(SipTimingLock, &OldIrql);

	DbgPrint("File1\tLine1\tFile2\tLine2\taccTime\tatSquared\tmaxTime\tminTime\tcount\n");

	for (timingPair = SipTimingPairStack; NULL != timingPair; timingPair = timingPair->next) {
		DbgPrint("%s\t%d\t%s\t%d\t%I64d\t%I64d\t%I64d\t%I64d\t%d\n",
					timingPair->file1,
					timingPair->line1,
					timingPair->file2,
					timingPair->line2,
					timingPair->accumulatedTime,
					timingPair->accumulatedSquareTime,
					timingPair->maxTime,
					timingPair->minTime,
					timingPair->count);
	}
	
	DbgPrint("performance frequency (in Hertz)\t%I64d\n",perfFreq.QuadPart);
	DbgPrint("%d total entries\n",SipTimingPointEntries);

	KeReleaseSpinLock(SipTimingLock, OldIrql);
	
}
#endif	// TIMING

#if		RANDOMLY_FAILING_MALLOC
#undef  ExAllocatePoolWithTag

#if		COUNTING_MALLOC
#define	ExAllocatePoolWithTag(poolType, size, tag)	SipCountingExAllocatePoolWithTag((poolType),(size),(tag), __FILE__, __LINE__)
#endif	// COUNTING_MALLOC

//
// This is copied from ntos\inc\ex.h
//
#if		!defined(POOL_TAGGING) && !COUNTING_MALLOC
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif	// !POOL_TAGGING && !COUNTING_MALLOC

typedef struct _SIS_FAIL_ENTRY_KEY {
	PCHAR				File;
	ULONG				Line;
} SIS_FAIL_ENTRY_KEY, *PSIS_FAIL_ENTRY_KEY;

typedef struct _SIS_FAIL_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_FAIL_ENTRY_KEY;
	ULONG				count;
	ULONG				Era;
} SIS_FAIL_ENTRY, *PSIS_FAIL_ENTRY;

ULONG				FailFrequency = 30;				// Fail a malloc 1 time in this many
ULONG				FailMallocRandomSeed = 0xb111b010;
ULONG				FailMallocAttemptCount = 0;
ULONG				FailMallocEraSize = 1000;
KSPIN_LOCK			FailMallocLock[1];
SIS_TREE			FailMallocTree[1];
ERESOURCE_THREAD	CurrentFailThread = 0;
FAST_MUTEX			FailFastMutex[1];
#define		FAIL_RANDOM_TABLE_SIZE	1024
ULONG				FailRandomTable[FAIL_RANDOM_TABLE_SIZE];
ULONG				FailRandomTableIndex = FAIL_RANDOM_TABLE_SIZE;
ULONG				IntentionallyFailedMallocs = 0;

VOID
SipFillFailRandomTable(void)
{
	ULONG		i;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ExAcquireFastMutex(FailFastMutex);

	for (i = 0; i < FAIL_RANDOM_TABLE_SIZE && i < FailRandomTableIndex; i++) {
		FailRandomTable[i] = RtlRandom(&FailMallocRandomSeed);
	}
	FailRandomTableIndex = 0;
	ExReleaseFastMutex(FailFastMutex);
}

ULONG
SipGenerateRandomNumber(void)
{
	if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
		//
		// We need to subtract one from the returned TableIndex, because InterlockedIncrement is
		// pre-increment, not post-increment.
		//
		ULONG	tableIndex = InterlockedIncrement(&FailRandomTableIndex) - 1;
		ASSERT(tableIndex != 0xffffffff);

		return(FailRandomTable[tableIndex % FAIL_RANDOM_TABLE_SIZE]);
	}
	SipFillFailRandomTable();
	return RtlRandom(&FailMallocRandomSeed);
}

LONG NTAPI
SipFailMallocCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_FAIL_ENTRY_KEY		key = Key;
	PSIS_FAIL_ENTRY			entry = Node;

	if (entry->File < key->File) return -1;
	if (entry->File > key->File) return 1;
	ASSERT(entry->File == key->File);

	if (entry->Line < key->Line) return -1;
	if (entry->Line > key->Line) return 1;
	ASSERT(entry->Line == key->Line);

	return 0;
}

VOID 
SipInitFailingMalloc(void)
{
	ULONG	i;
	LARGE_INTEGER	time = KeQueryPerformanceCounter(NULL);

	SipInitializeTree(FailMallocTree, SipFailMallocCompareRoutine);
	KeInitializeSpinLock(FailMallocLock);
	ExInitializeFastMutex(FailFastMutex);

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	FailMallocRandomSeed = (ULONG)(time.QuadPart >> 8);	// roughly time since boot in us, which should be fairly random

	SipFillFailRandomTable();

}

VOID *
SipRandomlyFailingExAllocatePoolWithTag(
    IN POOL_TYPE 		PoolType,
    IN ULONG 			NumberOfBytes,
    IN ULONG 			Tag,
	IN PCHAR			File,
	IN ULONG			Line)
{
	KIRQL				OldIrql;
	ERESOURCE_THREAD	threadId = ExGetCurrentResourceThread();
	ULONG				failCount;
	ULONG				attemptCount = InterlockedIncrement(&FailMallocAttemptCount);
	ULONG				randomNumber;

	if ((threadId == CurrentFailThread) || (NonPagedPoolMustSucceed == PoolType)) {
		//
		// This is an internal malloc (ie., the tree package has just called back into us), or it's a must
		// succeed call.  Just let it go.
		//
		return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
	}

	randomNumber = SipGenerateRandomNumber();

	if (0 == (randomNumber % FailFrequency)) {
		PSIS_FAIL_ENTRY		failEntry;
		SIS_FAIL_ENTRY_KEY	failEntryKey[1];

		KeAcquireSpinLock(FailMallocLock, &OldIrql);
		ASSERT(0 == CurrentFailThread);
		CurrentFailThread = threadId;

		//
		// See if we've already failed this one.
		//
		failEntryKey->File = File;
		failEntryKey->Line = Line;

		failEntry = SipLookupElementTree(FailMallocTree, failEntryKey);

		if (NULL == failEntry) {
			failEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_FAIL_ENTRY), ' siS');
			if (NULL == failEntry) {
				//
				// A real malloc failure!  Fail the user's malloc as well.
				//
#if		DBG
				DbgPrint("SIS: SipRandomlyFailingExAllocatePoolWithTag: internal ExAllocatePoolWithTag failed\n");
#endif	// DBG
				CurrentFailThread = 0;

				KeReleaseSpinLock(FailMallocLock, OldIrql);
				return NULL;
			}
			failEntry->File = File;
			failEntry->Line = Line;
			failEntry->Era = attemptCount / FailMallocEraSize;
			failCount = failEntry->count = 1;

			SipInsertElementTree(FailMallocTree, failEntry, failEntryKey);
		} else {
			if (failEntry->Era != attemptCount / FailMallocEraSize) {
				failCount = failEntry->count = 1;
				failEntry->Era = attemptCount / FailMallocEraSize;
			} else {
				failCount = ++failEntry->count;
			}
		}

		CurrentFailThread = 0;
		KeReleaseSpinLock(FailMallocLock, OldIrql);

		//
		// For now, don't fail a request from a specific site twice.
		//
		if (failCount == 1) {
#if		DBG
			if (!(BJBDebug & 0x02000000)) {
				DbgPrint("SIS: SipRandomlyFailingExAllocatePoolWithTag: failing malloc from file %s, line %d, size %d\n",File,Line,NumberOfBytes);
			}
#endif	// DBG
			SIS_MARK_POINT_ULONG(File);
			SIS_MARK_POINT_ULONG(Line);

			InterlockedIncrement(&IntentionallyFailedMallocs);

			return NULL;
		}
	}

	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}
//
// WARNING: ExAllocatePoolWithTag called later in this file will not have randomly failing behavior.
//
#endif	// RANDOMLY_FAILING_MALLOC

#if		COUNTING_MALLOC
//
// The counting malloc code must follow the randomly failing malloc code in the file, because of
// macro redefinitions. 
//

#undef	ExAllocatePoolWithTag
#undef	ExFreePool
//
// This is copied from ntos\inc\ex.h
//
#if		!defined(POOL_TAGGING)
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif	// !POOL_TAGGING

typedef struct _SIS_COUNTING_MALLOC_CLASS_KEY {
	POOL_TYPE										poolType;
	ULONG											tag;
	PCHAR											file;
	ULONG											line;
} SIS_COUNTING_MALLOC_CLASS_KEY, *PSIS_COUNTING_MALLOC_CLASS_KEY;

typedef struct _SIS_COUNTING_MALLOC_CLASS_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_COUNTING_MALLOC_CLASS_KEY;
	ULONG											numberOutstanding;
	ULONG											bytesOutstanding;
	ULONG											numberEverAllocated;
	LONGLONG										bytesEverAllocated;
	struct _SIS_COUNTING_MALLOC_CLASS_ENTRY			*prev, *next;
} SIS_COUNTING_MALLOC_CLASS_ENTRY, *PSIS_COUNTING_MALLOC_CLASS_ENTRY;

typedef struct _SIS_COUNTING_MALLOC_KEY {
	PVOID				p;
} SIS_COUNTING_MALLOC_KEY, *PSIS_COUNTING_MALLOC_KEY;

typedef struct _SIS_COUNTING_MALLOC_ENTRY {
	RTL_SPLAY_LINKS;
	SIS_COUNTING_MALLOC_KEY;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY		classEntry;
	ULONG									byteCount;
} SIS_COUNTING_MALLOC_ENTRY, *PSIS_COUNTING_MALLOC_ENTRY;

KSPIN_LOCK							CountingMallocLock[1];
BOOLEAN								CountingMallocInternalFailure = FALSE;
SIS_COUNTING_MALLOC_CLASS_ENTRY		CountingMallocClassListHead[1];
SIS_TREE							CountingMallocClassTree[1];
SIS_TREE							CountingMallocTree[1];

LONG NTAPI
SipCountingMallocClassCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_COUNTING_MALLOC_CLASS_KEY		key = Key;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	entry = Node;

	if (key->poolType > entry->poolType)	return 1;
	if (key->poolType < entry->poolType)	return -1;
	ASSERT(key->poolType == entry->poolType);

	if (key->tag > entry->tag)				return 1;
	if (key->tag < entry->tag)				return -1;
	ASSERT(key->tag == entry->tag);

	if (key->file > entry->file)	return 1;
	if (key->file < entry->file)	return -1;
	ASSERT(key->file == entry->file);

	if (key->line > entry->line)	return 1;
	if (key->line < entry->line)	return -1;
	ASSERT(key->line == entry->line);

	return 0;
}

LONG NTAPI
SipCountingMallocCompareRoutine(
	PVOID			Key,
	PVOID			Node)
{
	PSIS_COUNTING_MALLOC_KEY	key = Key;
	PSIS_COUNTING_MALLOC_ENTRY	entry = Node;

	if (key->p < entry->p)	return 1;
	if (key->p > entry->p)	return -1;
	ASSERT(key->p == entry->p);

	return 0;
}

VOID *
SipCountingExAllocatePoolWithTag(
    IN POOL_TYPE 		PoolType,
    IN ULONG 			NumberOfBytes,
    IN ULONG 			Tag,
	IN PCHAR			File,
	IN ULONG			Line)
{
	PVOID								memoryFromExAllocate;
	KIRQL								OldIrql;
	SIS_COUNTING_MALLOC_CLASS_KEY		classKey[1];
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	classEntry;
	SIS_COUNTING_MALLOC_KEY				key[1];
	PSIS_COUNTING_MALLOC_ENTRY			entry;
	//
	// First do the actual malloc
	//

	memoryFromExAllocate = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);

	if (NULL == memoryFromExAllocate) {
		//
		// We're out of memory.  Punt.
		//
		SIS_MARK_POINT();
		return NULL;
	}

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);
	//
	// See if we already have a class entry for this tag/poolType pair.
	//
	classKey->tag = Tag;
	classKey->poolType = PoolType;
	classKey->file = File;
	classKey->line = Line;

	classEntry = SipLookupElementTree(CountingMallocClassTree, classKey);
	if (NULL == classEntry) {
		//
		// This is the first time we've seen a malloc of this class.
		//
		classEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_COUNTING_MALLOC_CLASS_ENTRY), ' siS');
		if (NULL == classEntry) {
			SIS_MARK_POINT();
			CountingMallocInternalFailure = TRUE;
			KeReleaseSpinLock(CountingMallocLock, OldIrql);
			return memoryFromExAllocate;
		}

		//
		// Fill in the new class entry.
		//
		classEntry->tag = Tag;
		classEntry->poolType = PoolType;
		classEntry->file = File;
		classEntry->line = Line;
		classEntry->numberOutstanding = 0;
		classEntry->bytesOutstanding = 0;
		classEntry->numberEverAllocated = 0;
		classEntry->bytesEverAllocated = 0;

		//
		// Put it in the tree of classes.
		//

		SipInsertElementTree(CountingMallocClassTree, classEntry, classKey);

		//
		// And put it in the list of classes.
		//

		classEntry->prev = CountingMallocClassListHead;
		classEntry->next = CountingMallocClassListHead->next;
		classEntry->prev->next = classEntry->next->prev = classEntry;
	}

	//
	// Roll up an entry for the pointer.
	//
	entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_COUNTING_MALLOC_ENTRY), ' siS');

	if (NULL == entry) {
		CountingMallocInternalFailure = TRUE;
		KeReleaseSpinLock(CountingMallocLock, OldIrql);
		return memoryFromExAllocate;
	}

	//
	// Update the stats in the class.
	//
	classEntry->numberOutstanding++;
	classEntry->bytesOutstanding += NumberOfBytes;
	classEntry->numberEverAllocated++;
	classEntry->bytesEverAllocated += NumberOfBytes;

	//
	// Fill in the pointer entry.
	//
	entry->p = memoryFromExAllocate;
	entry->classEntry = classEntry;
	entry->byteCount = NumberOfBytes;

	//
	// Stick it in the tree.
	//
	key->p = memoryFromExAllocate;
	SipInsertElementTree(CountingMallocTree, entry, key);
	
	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	return memoryFromExAllocate;
}

VOID
SipCountingExFreePool(
	PVOID				p)
{
	SIS_COUNTING_MALLOC_KEY				key[1];
	PSIS_COUNTING_MALLOC_ENTRY			entry;
	KIRQL								OldIrql;

	key->p = p;

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);

	entry = SipLookupElementTree(CountingMallocTree, key);
	if (NULL == entry) {
		//
		// We may have failed to allocate the entry because of an
		// internal failure in the counting package, or else we're
		// freeing memory that was allocated by another system
		// component, like the SystemBuffer in an irp.
		//
	} else {
		//
		// Update the stats in the class.
		//
		ASSERT(entry->classEntry->numberOutstanding > 0);
		entry->classEntry->numberOutstanding--;

		ASSERT(entry->classEntry->bytesOutstanding >= entry->byteCount);
		entry->classEntry->bytesOutstanding -= entry->byteCount;

		//
		// Remove the entry from the tree
		//
		SipDeleteElementTree(CountingMallocTree, entry);

		//
		// And free it
		//
		ExFreePool(entry);
	}

	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	//
	// Free the caller's memory
	//

	ExFreePool(p);
}

VOID
SipInitCountingMalloc(void)
{
	KeInitializeSpinLock(CountingMallocLock);

	CountingMallocClassListHead->next = CountingMallocClassListHead->prev = CountingMallocClassListHead;

	SipInitializeTree(CountingMallocClassTree, SipCountingMallocClassCompareRoutine);
	SipInitializeTree(CountingMallocTree, SipCountingMallocCompareRoutine);
}

VOID
SipDumpCountingMallocStats(void)
{
	KIRQL								OldIrql;
	PSIS_COUNTING_MALLOC_CLASS_ENTRY	classEntry;
	ULONG								totalAllocated = 0;
	ULONG								totalEverAllocated = 0;
	ULONG								totalBytesAllocated = 0;
	ULONG								totalBytesEverAllocated = 0;
	extern ULONG						BJBDumpCountingMallocNow;

	KeAcquireSpinLock(CountingMallocLock, &OldIrql);

	if (0 == BJBDumpCountingMallocNow) {
		KeReleaseSpinLock(CountingMallocLock, OldIrql);
		return;
	}

	BJBDumpCountingMallocNow = 0;

	DbgPrint("Tag\tFile\tLine\tPoolType\tCountOutstanding\tBytesOutstanding\tTotalEverAllocated\tTotalBytesAllocated\n");

	for (classEntry = CountingMallocClassListHead->next;
		 classEntry != CountingMallocClassListHead;
		 classEntry = classEntry->next) {

		DbgPrint("%c%c%c%c\t%s\t%d\t%s\t%d\t%d\t%d\t%d\n",
					(CHAR)(classEntry->tag >> 24),
					(CHAR)(classEntry->tag >> 16),
					(CHAR)(classEntry->tag >> 8),
					(CHAR)(classEntry->tag),
					classEntry->file,
					classEntry->line,
					(classEntry->poolType == NonPagedPool) ? "NonPagedPool" : ((classEntry->poolType == PagedPool) ? "PagedPool" : "Other"),
					classEntry->numberOutstanding,
					classEntry->bytesOutstanding,
					classEntry->numberEverAllocated,
					(ULONG)classEntry->bytesEverAllocated);

		totalAllocated += classEntry->numberOutstanding;
		totalEverAllocated += classEntry->numberEverAllocated;
		totalBytesAllocated += classEntry->bytesOutstanding;
		totalBytesEverAllocated += (ULONG)classEntry->bytesEverAllocated;
	}

	KeReleaseSpinLock(CountingMallocLock, OldIrql);

	DbgPrint("%d objects, %d bytes currently allocated.   %d objects, %d bytes ever allocated.\n",
				totalAllocated,totalBytesAllocated,totalEverAllocated,totalBytesEverAllocated);
	
}
#endif	// COUNTING_MALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sifsctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sifsctl.c

Abstract:

        File system control routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef  ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA

typedef struct _SIS_DISMOUNT_CONTEXT {
    WORK_QUEUE_ITEM         workItem[1];
    PDEVICE_EXTENSION       deviceExtension;
} SIS_DISMOUNT_CONTEXT, *PSIS_DISMOUNT_CONTEXT;

VOID
SiDismountWork(
    IN PVOID                            parameter)
{
    PSIS_DISMOUNT_CONTEXT   dismountContext = parameter;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                "SIS: SiDismountWork\n");
#endif  // DBG

    //
    // We're in a system thread, so we don't need to diable APCs before taking the
    // GrovelerFileObjectResource.
    //
    ASSERT(PsIsSystemThread(PsGetCurrentThread()));

    ExAcquireResourceExclusiveLite(dismountContext->deviceExtension->GrovelerFileObjectResource, TRUE);


    if (NULL != dismountContext->deviceExtension->GrovelerFileHandle) {
        NtClose(dismountContext->deviceExtension->GrovelerFileHandle);
        dismountContext->deviceExtension->GrovelerFileHandle = NULL;
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountWork closed GrovelerFile handle\n");
#endif  // DBG
    }

    if (NULL != dismountContext->deviceExtension->GrovelerFileObject) {
        ObDereferenceObject(dismountContext->deviceExtension->GrovelerFileObject);
        dismountContext->deviceExtension->GrovelerFileObject = NULL;
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountWork closed GrovelerFile object\n");
#endif  // DBG
    }

    ExReleaseResourceLite(dismountContext->deviceExtension->GrovelerFileObjectResource);

    ExFreePool(dismountContext);
}

NTSTATUS
SiDismountVolumeCompletion(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp,
        IN PVOID                        Context)
{
    PDEVICE_EXTENSION       deviceExtension = Context;
    PSIS_DISMOUNT_CONTEXT   dismountContext;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));
    ASSERT(STATUS_PENDING != Irp->IoStatus.Status);

    dismountContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_DISMOUNT_CONTEXT), ' siS');

    if (NULL != dismountContext) {
        SIS_MARK_POINT_ULONG(dismountContext);

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                    "SIS: SiDismountCompletion: queueing dismount work\n");
#endif  // DBG

        ExInitializeWorkItem(dismountContext->workItem, SiDismountWork, dismountContext);
        dismountContext->deviceExtension = deviceExtension;
        ExQueueWorkItem(dismountContext->workItem,CriticalWorkQueue);
    } else {
        //
        // Too bad, we'll just dribble it.
        //
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SiDismountCompletion: Unable to allocate dismount context\n");
#endif  // DBG
        SIS_MARK_POINT();
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SipDismountVolume(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp)

/*++

Routine Description:

    Someone is trying a dismount volume request.  We can't tell if it's valid, so
    trap the completion.  If it completes successfully, then we need to clean up our
    state.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the FSCTL_DISMOUNT_VOLUME

Return Value:

    The function value is the status of the operation.

--*/
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_DISMOUNT_TRACE_LEVEL,
                "SIS: SipDismountVolume: called, DO 0x%x, Irp 0x%x\n",DeviceObject, Irp);
#endif  // DBG

    RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

    IoSetCompletionRoutine(
            Irp,
            SiDismountVolumeCompletion,
            DeviceObject->DeviceExtension,
            TRUE,                           // invoke on success
            FALSE,                          // invoke on error
            FALSE);                         // invoke on cancel

    return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
}

NTSTATUS
SiUserSetSISReparsePointCompletion(
    IN PDEVICE_OBJECT               DeviceObject,
    IN PIRP                         Irp,
    IN PVOID                        Context)
{
    PKEVENT event = (PKEVENT)Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    Irp->PendingReturned = FALSE;

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipUserSetSISReparsePoint(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                         Irp)
{
        PREPARSE_DATA_BUFFER    reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
        PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
        PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
        PIO_STACK_LOCATION      nextIrpSp;
        ULONG                   InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;
        BOOLEAN                 validReparseData;
        CSID                    CSid;
        LINK_INDEX              LinkIndex;
        LARGE_INTEGER           CSFileNtfsId;
        LARGE_INTEGER           LinkFileNtfsId;
        LONGLONG                CSFileChecksum;
        PSIS_CS_FILE            CSFile = NULL;
        NTSTATUS                status;
        ULONG                   returnedLength;
        BOOLEAN                 prepared = FALSE;
        LINK_INDEX              newLinkIndex;
        KEVENT                  event[1];
        PSIS_PER_LINK           perLink = NULL;
        FILE_ALL_INFORMATION    allInfo[1];
        BOOLEAN                 EligibleForPartialFinalCopy;
        KIRQL                   OldIrql;
        PSIS_PER_FILE_OBJECT    perFO;
        PSIS_SCB                scb;

        SIS_MARK_POINT();

        if (!SipCheckPhase2(deviceExtension)) {
                //
                // This isn't a SIS enabled volume, or something else bad happened.  Just let it go.
                //
                SIS_MARK_POINT();
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        ASSERT(InputBufferLength >= SIS_REPARSE_DATA_SIZE);     // must have been checked by caller

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        //
        // This is a SIS reparse point.  Figure out whether it's valid.
        //

        validReparseData = SipIndicesFromReparseBuffer(
                                reparseBuffer,
                                &CSid,
                                &LinkIndex,
                                &CSFileNtfsId,
                                &LinkFileNtfsId,
                                &CSFileChecksum,
                                &EligibleForPartialFinalCopy,
                                NULL);

        if (SipIsFileObjectSIS(irpSp->FileObject, DeviceObject, FindActive, &perFO, &scb)) {
                perLink = scb->PerLink;
                //
                // This is a SIS file object.  If we're setting a reparse point where the CSid and
                // CSFile checksum are the same as the current file, assume that it's restore doing
                // the set, and just clear the dirty bit and leave the file be.  If someone other
                // than restore does this, it's harmless to anyone but them.
                //
                if ((!validReparseData) || (!IsEqualGUID(&CSid, &perLink->CsFile->CSid)) || CSFileChecksum != perLink->CsFile->Checksum) {
                        //
                        // The user is trying to set to an invalid reparse point, a different file or
                        // has a bogus checksum.  This isn't implemented.
                        //
                        SIS_MARK_POINT_ULONG(scb);

#if DBG
                        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                    "SIS: SipUserSetSISReparsePoint: unimplemented set\n");
#endif  // DBG

                        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                        Irp->IoStatus.Information = 0;

                        IoCompleteRequest(Irp, IO_NO_INCREMENT);

                        return STATUS_NOT_IMPLEMENTED;
                }

                KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
                if ((perLink->Flags &
                                ( SIS_PER_LINK_BACKPOINTER_GONE
                                | SIS_PER_LINK_FINAL_COPY
                                | SIS_PER_LINK_FINAL_COPY_DONE
                                | SIS_PER_LINK_OVERWRITTEN
                                | SIS_PER_LINK_FILE_DELETED
                                | SIS_PER_LINK_DELETE_DISPOSITION_SET)) == 0) {

                        SIS_MARK_POINT_ULONG(scb);

                        Irp->IoStatus.Status = STATUS_SUCCESS;
                        Irp->IoStatus.Information = 0;

                        perLink->Flags &= ~SIS_PER_LINK_DIRTY;

                } else {
                        SIS_MARK_POINT_ULONG(scb);
#if DBG
                        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                    "SIS: SipUserSetSISReparsePoint: trying to re-set reparse point on file in funny state\n");
#endif  // DBG
                        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                        Irp->IoStatus.Information = 0;
                }
                KeReleaseSpinLock(perLink->SpinLock, OldIrql);

                status = Irp->IoStatus.Status;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                return status;
        }


        if (!validReparseData) {
            //
            // It's not a valid reparse point, so we don't update our backpointers.  Just let
            // it get set, and we'll delete it if anyone tries to open the resulting file.
            //
            SIS_MARK_POINT();
            SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Rewrite reparse point in the buffer pointed to by the irp to have a new, unused link index
        // which prevents problems with files existing on disk with link indices > MaxIndex.
        //
        status = SipAllocateIndex(deviceExtension,&newLinkIndex);
        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            newLinkIndex.QuadPart = 0;
            newLinkIndex.Check = 0;
        }

        if (!SipIndicesIntoReparseBuffer(
                                reparseBuffer,
                                &CSid,
                                &newLinkIndex,
                                &CSFileNtfsId,
                                &LinkFileNtfsId,
                                &CSFileChecksum,
                                EligibleForPartialFinalCopy)) {

                status = STATUS_DRIVER_INTERNAL_ERROR;
                SIS_MARK_POINT();
                goto Error;
        }

        //
        // Get the file information.
        //
        status = SipQueryInformationFile(
                                irpSp->FileObject,
                                DeviceObject,
                                FileAllInformation,
                                sizeof(FILE_ALL_INFORMATION),
                                allInfo,
                                &returnedLength);

        if ((STATUS_BUFFER_OVERFLOW == status) && (returnedLength == sizeof(FILE_ALL_INFORMATION))) {
                //
                // We expect to get a buffer overflow, because of the file name return.  Treat this
                // like success.
                //
                SIS_MARK_POINT();
                status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // If this is a sparse file and eliginle for partial final copy, then zero out any
        // trailing unallocated region.
        //
        if (EligibleForPartialFinalCopy && (allInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE)) {
#define NUM_RANGES_PER_ITERATION        10

                FILE_ALLOCATED_RANGE_BUFFER     inArb[1];
                FILE_ALLOCATED_RANGE_BUFFER     outArb[NUM_RANGES_PER_ITERATION];
                FILE_ZERO_DATA_INFORMATION      zeroData[1];
                unsigned                                        allocatedRangesReturned;

                for (inArb->FileOffset.QuadPart = 0;
                         inArb->FileOffset.QuadPart < allInfo->StandardInformation.EndOfFile.QuadPart;
                        ) {
                        //
                        // Query the range.
                        //
                        inArb->Length.QuadPart = MAXLONGLONG;

                        status = SipFsControlFile(
                                                irpSp->FileObject,
                                                DeviceObject,
                                                FSCTL_QUERY_ALLOCATED_RANGES,
                                                inArb,
                                                sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                                                outArb,
                                                sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGES_PER_ITERATION,
                                                &returnedLength);

                        if (!NT_SUCCESS(status)) {
                                //
                                // Just skip this part.
                                //
                                SIS_MARK_POINT_ULONG(status);
                                goto VDLExtended;
                        }

                        ASSERT(returnedLength % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0);

                        allocatedRangesReturned = returnedLength / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

                        if (allocatedRangesReturned < NUM_RANGES_PER_ITERATION) {
                                if ((1 == allocatedRangesReturned) &&
                                        (0 == inArb->FileOffset.QuadPart) &&
                                        (0 == outArb[0].FileOffset.QuadPart) &&
                                        (allInfo->StandardInformation.EndOfFile.QuadPart <= outArb[0].Length.QuadPart) &&
                                        (deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart >= allInfo->StandardInformation.EndOfFile.QuadPart)) {

                                        //
                                        // This is a special case.  This is a small file with a single allocated range extending from
                                        // the start of the file to the end.  It's possibly a resident stream, so we FSCTL_SET_ZERO_DATA
                                        // won't necessarily make it go away.  We just deal with this by make it not be eligible for partial
                                        // final copy.
                                        //

                                        EligibleForPartialFinalCopy = FALSE;

                                } else if (allocatedRangesReturned > 0) {
                                        inArb->FileOffset.QuadPart =
                                                outArb[allocatedRangesReturned-1].FileOffset.QuadPart + outArb[allocatedRangesReturned-1].Length.QuadPart;
                                }
                                //
                                // Zero out the remainder of the file, in order to extend ValidDataLength.
                                //
                                zeroData->FileOffset = inArb->FileOffset;
                                zeroData->BeyondFinalZero.QuadPart = MAXLONGLONG;

                                status = SipFsControlFile(
                                                        irpSp->FileObject,
                                                        DeviceObject,
                                                        FSCTL_SET_ZERO_DATA,
                                                        zeroData,
                                                        sizeof(FILE_ZERO_DATA_INFORMATION),
                                                        NULL,                                                           // output buffer
                                                        0,                                                                      // o.b. length
                                                        NULL);                                                          // returned length

#if DBG
                                if (!NT_SUCCESS(status)) {
                                    SIS_MARK_POINT_ULONG(status);
                                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                                "SIS: SipUserSetSISReparsePoint: unable to zero data, 0x%x\n",status);
                                }
#endif  // DBG
                                goto VDLExtended;
                        }

                        ASSERT(allocatedRangesReturned == NUM_RANGES_PER_ITERATION);
                        inArb->FileOffset.QuadPart =
                                outArb[NUM_RANGES_PER_ITERATION-1].FileOffset.QuadPart + outArb[NUM_RANGES_PER_ITERATION-1].Length.QuadPart;
                }



#undef  NUM_RANGES_PER_ITERATION
        }

VDLExtended:

        CSFile = SipLookupCSFile(
                                &CSid,
                                &CSFileNtfsId,
                                DeviceObject);

        if (NULL == CSFile) {
                //
                // We couldn't allocate a CSFile, just fail the request.
                //
                SIS_MARK_POINT();
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
        }

        //
        // Make sure the common store file is open.
        //
        status = SipAssureCSFileOpen(CSFile);

        if (!NT_SUCCESS(status)) {
                //
                // It wasn't there or we couldn't get to it for some reason, just let the set proceed.
                //
                SIS_MARK_POINT_ULONG(status);
                SipDereferenceCSFile(CSFile);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Check the checksum.
        //
        if (CSFile->Checksum != CSFileChecksum) {
                SIS_MARK_POINT();

                //
                // The checksum's bogus, so the reparse point isn't good for much.  Let the set
                // proceed anyway.  When the user tries to open this file, we'll delete the reparse
                // point.
                //
                SipDereferenceCSFile(CSFile);
                SipDirectPassThroughAndReturn(DeviceObject, Irp);
        }

        //
        // Prepare for a refcount change, allocate the new link index,
        // and create a new perLink.
        //

        status = SipPrepareRefcountChangeAndAllocateNewPerLink(
                    CSFile,
                    &allInfo->InternalInformation.IndexNumber,
                    DeviceObject,
                    &newLinkIndex,
                    &perLink,
                    &prepared);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Error;
        }

        //
        // Construct the new reparse point in the buffer pointed to by the irp.
        //
        if (!SipIndicesIntoReparseBuffer(
                                reparseBuffer,
                                &CSFile->CSid,
                                &newLinkIndex,
                                &CSFile->CSFileNtfsId,
                                &allInfo->InternalInformation.IndexNumber,
                                &CSFileChecksum,
                                EligibleForPartialFinalCopy)) {

            status = STATUS_DRIVER_INTERNAL_ERROR;
            SIS_MARK_POINT();
            goto Error;
        }

        //
        // Set an event to synchronize completion.
        //
        KeInitializeEvent(event, NotificationEvent, FALSE);

        //
        // Set up the irp
        //
        nextIrpSp = IoGetNextIrpStackLocation(Irp);
        RtlCopyMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

        IoSetCompletionRoutine(
                Irp,
                SiUserSetSISReparsePointCompletion,
                event,
                TRUE,
                TRUE,
                TRUE);

        IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

        status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
        ASSERT(STATUS_SUCCESS == status);

        if (!NT_SUCCESS(Irp->IoStatus.Status)) {
                SipCompleteCSRefcountChange(
                        NULL,
            NULL,
                        CSFile,
                        FALSE,
                        TRUE);
        } else {
                status = SipCompleteCSRefcountChange(
                                        perLink,
                                    &perLink->Index,
                                        CSFile,
                                        TRUE,
                                        TRUE);

                if (!NT_SUCCESS(status)) {
                        //
                        // We know we just messeded up, so just kick off the volume
                        // check right away.
                        //
                        SIS_MARK_POINT_ULONG(status);

                        SipCheckVolume(deviceExtension);
                }
        }

        SipDereferencePerLink(perLink);
        SipDereferenceCSFile(CSFile);

#if             DBG
        perLink = NULL;
        CSFile = NULL;
#endif  // DBG

        status = Irp->IoStatus.Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

Error:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        if (prepared) {
                ASSERT(NULL != CSFile);

                status = SipCompleteCSRefcountChange(
                                        NULL,
                    NULL,
                                        CSFile,
                                        FALSE,
                                        TRUE);

                if (!NT_SUCCESS(status)) {
                        SIS_MARK_POINT_ULONG(status);
                }
        }

        if (NULL != CSFile) {
                SipDereferenceCSFile(CSFile);
#if             DBG
                CSFile = NULL;
#endif  // DBG
        }

        if (NULL != perLink) {
                SipDereferencePerLink(perLink);
#if             DBG
                perLink = NULL;
#endif  // DBG
        }

        return status;
}



NTSTATUS
SipQueryAllocatedRanges(
        IN PDEVICE_OBJECT               DeviceObject,
        IN PIRP                                 Irp)
/*++

Routine Description:

        This routine implements FSCTL_QUERY_ALLOCATED_RANGES for SIS links.  SIS links
        that weren't opened FILE_OPEN_REPARSE_POINT look like they're completely allocated
        (ie., that they're all data and no holes).  This function returns such.

        We complete the irp and return the appropriate status.

        This code is stolen from NTFS.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the FSCTL_QUERY_ALLOCATED_RANGES.

Return Value:

    The function value is the status of the operation.

--*/

{
        BOOLEAN                                                 validUserBuffer = TRUE;
        PFILE_ALLOCATED_RANGE_BUFFER    OutputBuffer;
        LONGLONG                                                Length, StartingOffset;
        NTSTATUS                                                status;
        FILE_STANDARD_INFORMATION               standardInformation[1];
        PIO_STACK_LOCATION                              IrpSp = IoGetCurrentIrpStackLocation(Irp);
        ULONG                                                   returnedLength;
        ULONG                                                   RemainingBytes;

        Irp->IoStatus.Information = 0;

        //
        // Query the file's standard information to get the length.
        //
        status = SipQueryInformationFile(
                                IrpSp->FileObject,
                                DeviceObject,
                                FileStandardInformation,
                                sizeof(FILE_STANDARD_INFORMATION),
                                standardInformation,
                                &returnedLength);

        if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);

                goto done;
        }

        ASSERT(returnedLength == sizeof(FILE_STANDARD_INFORMATION));

        //
        // This is a METHOD_NEITHER buffer, so we have to be careful in touching it.
        // Code to check it out stolen from NTFS.
        //

        try {
                if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(FILE_ALLOCATED_RANGE_BUFFER)) {
                        status = STATUS_INVALID_PARAMETER;
                        leave;
                }

        RemainingBytes = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
                OutputBuffer = (PFILE_ALLOCATED_RANGE_BUFFER)SipMapUserBuffer(Irp);

                if (NULL == OutputBuffer) {
                        //
                        // We couldn't map the user buffer because of resource shortages.
                        //
                        SIS_MARK_POINT_ULONG(IrpSp->FileObject);

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto done;
                }

                if (KernelMode != Irp->RequestorMode) {
            ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                      IrpSp->Parameters.FileSystemControl.InputBufferLength,
                                          sizeof( ULONG ));

                        ProbeForWrite( OutputBuffer, RemainingBytes, sizeof( ULONG ));

        } else if (!IsLongAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer ) ||
                   !IsLongAligned( OutputBuffer )) {
                        validUserBuffer = FALSE;
            leave;
                }

        StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
        Length = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;

        //
        //  Check that the input parameters are valid.
        //

        if ((Length < 0) ||
            (StartingOffset < 0) ||
            (Length > MAXLONGLONG - StartingOffset)) {

            status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Check that the requested range is within file size
        //  and has a non-zero length.
        //

        if (Length == 0) {
                        SIS_MARK_POINT();
            leave;
        }

        if (StartingOffset >= standardInformation->EndOfFile.QuadPart) {
                        SIS_MARK_POINT();
            leave;
        }

        if (standardInformation->EndOfFile.QuadPart - StartingOffset < Length) {

            Length = standardInformation->EndOfFile.QuadPart - StartingOffset;
        }

                //
                // Show that the entire requested range is allocated.
                //
        if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

            status = STATUS_BUFFER_TOO_SMALL;

                        SIS_MARK_POINT();

        } else {

            OutputBuffer->FileOffset.QuadPart = StartingOffset;
            OutputBuffer->Length.QuadPart = Length;
            Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                        status = STATUS_SUCCESS;
        }

        } except (EXCEPTION_EXECUTE_HANDLER) {
                validUserBuffer = FALSE;
        }

        if (!validUserBuffer) {
                status = STATUS_INVALID_USER_BUFFER;
        }

done:
        Irp->IoStatus.Status = status;


        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
}


NTSTATUS
SipMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  This
    simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SipLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a LoadFileSystem request.
    This simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SiFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE_EXTENSION       devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          newDeviceObject;
    PDEVICE_EXTENSION       newDevExt;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                status;
    PIO_STACK_LOCATION      nextIrpSp;
    PSIS_PER_FILE_OBJECT    perFO;
    PSIS_SCB                scb;
    PVPB                    vpb;
    KEVENT                  waitEvent;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_FSCONTROL_TRACE_LEVEL,
                "SIS: SiFsControl: fo %p, mf %x, code %x\n",
                irpSp->FileObject,
                irpSp->MinorFunction,
                irpSp->Parameters.FileSystemControl.FsControlCode );
#endif

    //
    //  If this is for our control device object, fail the operation
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        SIS_MARK_POINT();

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.  
        //
        //  Since the device object we are going to attach to has not yet been
        //  created (it is created by the base file system) we are going to use
        //  the type of the file system control device object.  We are assuming
        //  that the file system control device object will have the same type
        //  as the volume device objects associated with it.
        //

        ASSERT(IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType));

        status = IoCreateDevice(
                    FsDriverObject,
                    sizeof( DEVICE_EXTENSION ),
                    (PUNICODE_STRING) NULL,
                    DeviceObject->DeviceType,
                    0,
                    FALSE,
                    &newDeviceObject );

        if (NT_SUCCESS( status )) {

            //
            //  We need to save the RealDevice object pointed to by the vpb
            //  parameter because this vpb may be changed by the underlying
            //  file system.  Both FAT and CDFS may change the VPB address if
            //  the volume being mounted is one they recognize from a previous
            //  mount.
            //

            newDevExt = newDeviceObject->DeviceExtension;
            newDevExt->RealDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine(
                Irp,
                SipMountCompletion,
                &waitEvent,
                TRUE,
                TRUE,
                TRUE);

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

            //
            //  Wait for the completion routine to be called
            //

	        if (STATUS_PENDING == status) {

		        NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		        ASSERT(localStatus == STATUS_SUCCESS);
	        }

            //
            //  Get the correct VPB from the real device object saved in our
            //  device extension.  We do this because the VPB in the IRP stack
            //  may not be the correct VPB when we get here.  The underlying
            //  file system may change VPBs if it detects a volume it has
            //  mounted previously.
            //

            vpb = newDevExt->RealDeviceObject->Vpb;

            //
            //  If the operation succeeded and we are not alreayd attached,
            //  attach to the device object.
            //

            if (NT_SUCCESS( Irp->IoStatus.Status ) &&
                !SipAttachedToDevice( vpb->DeviceObject )) {

                //
                //  Attach to the new mounted volume.  Note that we must go through
                //  the VPB to locate the file system volume device object.
                //

                SipAttachToMountedDevice( 
                        vpb->DeviceObject, 
                        newDeviceObject, 
                        newDevExt->RealDeviceObject );

            } else {

        #if DBG
                //
                //  Display what mount failed.
                // 

                SipCacheDeviceName( newDeviceObject );
                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                              "SIS: Mount volume failure for       \"%wZ\", status=%08x\n",
                              &newDevExt->Name, 
                              Irp->IoStatus.Status );

                } else {

                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                              "SIS: Mount volume failure for       \"%wZ\", already attached\n", 
                              &newDevExt->Name );
                }
        #endif

                //
                //  The mount request failed.  Cleanup and delete the device
                //  object we created.
                //

                SipCleanupDeviceExtension( newDeviceObject );
                IoDeleteDevice( newDeviceObject );
            }

            //
            //  Continue processing the operation
            //

            status = Irp->IoStatus.Status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;

        } else {

#if DBG
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                        "SIS: Error creating volume device object, status=%08x\n", 
                        status );
#endif

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.
        //

#if DBG
        SipCacheDeviceName( DeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Loading File System, Detaching from \"%wZ\"\n", 
                    &devExt->Name );
#endif

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            SipLoadFsCompletion,
            &waitEvent,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

		    NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(localStatus == STATUS_SUCCESS);
	    }

#if DBG
        //
        //  Display the name if requested
        //

        SipCacheDeviceName( DeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Detaching from recognizer      \"%wZ\", status=%08x\n", 
                    &devExt->Name,
                    Irp->IoStatus.Status );
#endif

        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            status = IoAttachDeviceToDeviceStackSafe( DeviceObject, 
                                                      devExt->AttachedToDeviceObject,
                                                      &devExt->AttachedToDeviceObject );

            ASSERT(STATUS_SUCCESS == status);

        } else {

            //
            //  The load was successful, delete the Device object attached to the
            //  recognizer.
            //

            SipCleanupDeviceExtension( DeviceObject );
            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction && 
            SipIsFileObjectSIS(irpSp->FileObject,DeviceObject,FindActive,&perFO,&scb)) {

        SIS_MARK_POINT_ULONG(scb);
        SIS_MARK_POINT_ULONG(irpSp->Parameters.FileSystemControl.FsControlCode);

        //
        // This is a big switch of all of the known fsctl calls.  Most of these calls just get
        // passed through on the link file, but we explicity list them to indicate that we put
        // some thought into the particular call and determined that passing it through is
        // appropriate.  In the checked build, we generate a DbgPrint for unknown fsctl calls,
        // then pass them through on the link file.
        //

        switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

            //
            // Fsctl calls 0-5
            //
            // oplock calls all get passed through.
            //

            case FSCTL_REQUEST_OPLOCK_LEVEL_1:
            case FSCTL_REQUEST_OPLOCK_LEVEL_2:
            case FSCTL_REQUEST_BATCH_OPLOCK:
            case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
            case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
            case FSCTL_OPLOCK_BREAK_NOTIFY:
                goto PassThrough;

            //
            // Fsctl call 6
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_LOCK_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 7
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_UNLOCK_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 8
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_DISMOUNT_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 9 is decommissioned.
            //

            //
            // Fsctl call 10
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_IS_VOLUME_MOUNTED:
                goto PassThrough;

            //
            // Fsctl call 11
            //
            // Ntfs doesn't even look at the parameters, it just succeeds the request.
            //

            case FSCTL_IS_PATHNAME_VALID:
                goto PassThrough;

            //
            // Fsctl call 12
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_MARK_VOLUME_DIRTY:
                goto PassThrough;

            //
            // Fsctl call 13 is decommissioned.
            //

            //
            // Fsctl call 14
            //
            // This is valid only on paging files and only in kernel mode.  Pass through and let NTFS
            // fail or assert.
            //

            case FSCTL_QUERY_RETRIEVAL_POINTERS:
                goto PassThrough;

            //
            // Fsctl calls 15 and 16
            //
            // The compression state of the link file is independent
            // of the compression state of the CS file (which preferably
            // is compressed).  Pass through.
            //

            case FSCTL_GET_COMPRESSION:
            case FSCTL_SET_COMPRESSION:
                goto PassThrough;

            //
            // Fsctl calls 17 and 18 are decommissioned.
            //

            //
            // Fsctl call 19
            //
            // This is disconcerting--ntfs treats system hives specially.
            // Basically, it works hard to keep them consistent across crashes.
            // It's not such a good idea to do this with a SIS file, since we're
            // not going to be all that great with user data across a crash.  However,
            // given that we've gotten here, just go for it.
            //

            case FSCTL_MARK_AS_SYSTEM_HIVE:
                ASSERT(!"SIS: SiFsControl: Someone called FSCTL_MARK_AS_SYSTEM_HIVE on a SIS file!\n");
                goto PassThrough;

            //
            // Fsctl call 20
            //
            // oplock calls all get passed through.
            //

            case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                goto PassThrough;

            //
            // Fsctl call 21
            //
            // NTFS doesn't even mention this fsctl.  We'll let it fail it.
            //

            case FSCTL_INVALIDATE_VOLUMES:
                goto PassThrough;

            //
            // Fsctl call 22
            //
            // NTFS doesn't even mention this fsctl.  We'll let it fail it.
            //

            case FSCTL_QUERY_FAT_BPB:
                goto PassThrough;

            //
            // Fsctl call 23
            //
            // oplock calls all get passed through.
            //

            case FSCTL_REQUEST_FILTER_OPLOCK:
                goto PassThrough;

            //
            // Fsctl call 24
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_FILESYSTEM_GET_STATISTICS:
                goto PassThrough;

            //
            // Fsctl call 25
            //
            // This call only looks at the volume on which the file is located, it doesn't
            // depend on the particular file.  Pass it through on the link file.
            //

            case FSCTL_GET_NTFS_VOLUME_DATA:
                goto PassThrough;

            //
            // Fsctl call 26
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_GET_NTFS_FILE_RECORD:
                goto PassThrough;

            //
            // Fsctl call 27
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_GET_VOLUME_BITMAP:
                goto PassThrough;

            //
            // Fsctl call 28
            //
            // This returns file cluster allocation information.
            // If opened reparse, pass through.  If not, then send to
            // where the data is.
            //

            case FSCTL_GET_RETRIEVAL_POINTERS: {
                BOOLEAN         openedAsReparse;
                KIRQL           OldIrql;
                BOOLEAN         dirty;

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (openedAsReparse) {
                    //
                    // The user opened this file FILE_OPEN_REPARSE_POINT, so tell the truth
                    // about the link file.
                    //
                    goto PassThrough;
                }

                KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
                dirty = (scb->PerLink->Flags & SIS_PER_LINK_DIRTY) ? TRUE : FALSE;
                KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

                //
                // Just because the per-link dirty bit isn't set doesn't mean that the
                // file's totally clean.  Check the scb bits.
                //
                if (!dirty) {
                    SipAcquireScb(scb);
                    if (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) {
                        dirty = TRUE;
                    }
                    SipReleaseScb(scb);
                }

                if (dirty) {

                    //
                    // We should look at the ranges queried and split things up, much like we do with
                    // reads that span dirty/clean boundaries.
                    //
                    // NTRAID#65190-2000/03/10-nealch  Handle FSCTL_GET_RETRIEVAL_POINTERS for "dirtied" sis files.
                    //

                    SIS_MARK_POINT_ULONG(scb);

#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: SiFsControl: FSCTL_GET_RETRIEVAL_POINTERS: called on dirty file, returning STATUS_NOT_IMPLEMENTED\n");
#endif  // DBG

                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                //
                // Just send this to the common store file.
                //

                goto SendToCSFile;
            }

            //
            // Fsctl call 29
            //
            // This is called on a volume handle, but a file handle
            // is passed in the input buffer.  It moves a range of the
            // file to a specified location on the volume.  We just pass it through
            // regardless; trying to move unallocated regions of a link file is
            // meaningless, and trying to move allocated regions will do the
            // right thing.  To move the common store file, it can be called with
            // a CS file handle.
            //

            case FSCTL_MOVE_FILE:
                goto PassThrough;

            //
            // Fsctl call 30
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_IS_VOLUME_DIRTY:
                goto PassThrough;

            //
            // Fsctl call 32
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_ALLOW_EXTENDED_DASD_IO:
                goto PassThrough;

            //
            // Fsctl call 33 is decommissioned.
            //

            //
            // Fsctl call 35
            //
            // Directory only - pass through and let NTFS fail.
            //

            case FSCTL_FIND_FILES_BY_SID:
                goto PassThrough;

            //
            // Fsctl call 36 is decommissioned.
            //

            //
            // Fsctl call 37 is decommissioned.
            //

            //
            // Fsctls 38-40.
            //
            // Pass through.  Object ID's are similar to file ID's, but are user assigned.
            //

            case FSCTL_SET_OBJECT_ID:
            case FSCTL_GET_OBJECT_ID:
            case FSCTL_DELETE_OBJECT_ID:
                goto PassThrough;

            //
            // Fsctl call 41
            //
            // We can have only one reparse point on a file, and SIS is using it.  We should
            // probably COW this file, but for now just disallow this, except in the case
            // where it's a SIS reparse point being set, in which case we forward the request to
            // SipUserSetSISReparsePoint.
            //

            case FSCTL_SET_REPARSE_POINT: {
                PREPARSE_DATA_BUFFER reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
                ULONG InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

                if ((NULL == reparseBuffer) || 
                            (InputBufferLength < SIS_REPARSE_DATA_SIZE)) {

                    SIS_MARK_POINT_ULONG(InputBufferLength);

                    status = STATUS_INVALID_PARAMETER;
                    goto CompleteWithStatus;
                }

                if (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag) {

                    status = STATUS_INVALID_PARAMETER;
                    goto CompleteWithStatus;
                }

                status = SipUserSetSISReparsePoint(DeviceObject, Irp);

                SIS_MARK_POINT_ULONG(status);

                return status;
            }

            //
            // Fsctl call 42
            //
            // Just let the user read the SIS reparse point.
            //

            case FSCTL_GET_REPARSE_POINT:
                goto PassThrough;

            //
            // Fsctl call 43
            //
            // Disallow deleting SIS reparse points directly.
            //

            case FSCTL_DELETE_REPARSE_POINT:
                status = STATUS_ACCESS_DENIED;
                goto CompleteWithStatus;

            //
            // Fsctl call 44
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_ENUM_USN_DATA:
                goto PassThrough;

            //
            // Fsctl call 45
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_SECURITY_ID_CHECK:
                goto PassThrough;

            //
            // Fsctl call 46
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_READ_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctls 47 and 48
            //
            // Pass through.  Object ID's are similar to file ID's, but are user assigned.
            //

            case FSCTL_SET_OBJECT_ID_EXTENDED:
            case FSCTL_CREATE_OR_GET_OBJECT_ID:
                goto PassThrough;

            //
            // Fsctl call 49
            //
            // SIS link files are already sparse.
            //

            case FSCTL_SET_SPARSE:
                goto PassThrough;

            //
            // Fsctl call 50
            //
            // This is only partially implemented, for the case where the user opened the
            // file FILE_OPEN_REPARSE_POINT.
            //

            case FSCTL_SET_ZERO_DATA: {
                BOOLEAN openedAsReparse;
                BOOLEAN openedDirty;
                KIRQL OldIrql;

                //
                // Check to see if the file is opened FILE_OPEN_REPARSE_POINT, and fail the request if not.
                //

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (!openedAsReparse) {

                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                //
                // Verify that this file wasn't opened dirty.
                //

                SipAcquireScb(scb);
                openedDirty = (scb->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY) ? TRUE : FALSE;
                SipReleaseScb(scb);

                if (openedDirty) {
                    SIS_MARK_POINT();
#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: tried FSCTL_SET_ZERO_DATA on file that was opened dirty.  Failing it.\n");
#endif  // DBG
                    status = STATUS_NOT_IMPLEMENTED;
                    goto CompleteWithStatus;
                }

                goto PassThrough;
            }


            //
            // Fsctl call 51
            //
            // Depends on whether the file is opened FILE_OPEN_REPARSE.  Implemented in its own
            // function.
            //

            case FSCTL_QUERY_ALLOCATED_RANGES: {
                BOOLEAN openedAsReparse;
                KIRQL   OldIrql;

                KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
                openedAsReparse = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
                KeReleaseSpinLock(perFO->SpinLock, OldIrql);

                if (openedAsReparse) {

                    //
                    // This file was opened as a reparse point, so we just pass it
                    // through and let the real set of allocated ranges show through.
                    //

                    goto PassThrough;

                } else {

                    //
                    // This was a normal open, so call our special routine that will
                    // show the file as a single, allocated chunk.
                    //

                    return SipQueryAllocatedRanges(DeviceObject,Irp);
                }
            }

            //
            // Fsctl call 52 obsolete
            //

            //
            // Fsctl calls 53-56
            //
            // Encrypting a file results in the file being completely
            // overwritten.  SIS files, therefore, will simply COW back
            // to normal if they're encrypted.
            //

            case FSCTL_SET_ENCRYPTION:
            case FSCTL_ENCRYPTION_FSCTL_IO:
            case FSCTL_WRITE_RAW_ENCRYPTED:
            case FSCTL_READ_RAW_ENCRYPTED:
                goto PassThrough;

            //
            // Fsctl call 57
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_CREATE_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 58
            //
            // Returns USN data for a file.
            //

            case FSCTL_READ_FILE_USN_DATA:
                goto PassThrough;

            //
            // Fsctl call 59
            //
            // This call writes a USN record as if the file were closed, and posts
            // any USN updates that were pending a close for this file.  Pass it
            // through on the link file.
            //

            case FSCTL_WRITE_USN_CLOSE_RECORD:
                goto PassThrough;

            //
            // Fsctl call 60
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_EXTEND_VOLUME:
                goto PassThrough;

            //
            // Fsctl call 61
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_QUERY_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 62
            //
            // Volume only - pass through and let NTFS fail.
            //

            case FSCTL_DELETE_USN_JOURNAL:
                goto PassThrough;

            //
            // Fsctl call 63
            //
            // This sets some bits in the CCB related to USN processing
            // for the file.  These bits don't appear to be read by anything
            // in ntfs.
            //

            case FSCTL_MARK_HANDLE:
                goto PassThrough;

            //
            // Fsctl call 64
            //
            // Our very own copyfile request.
            //
            case FSCTL_SIS_COPYFILE:
                return SipFsCopyFile(DeviceObject,Irp);

            //
            // Fsctl call 65
            //
            // The groveler fsctl.  This is valid only on \SIS Common Store\GrovelerFile, which
            // can never be a SIS link.  Fail the request.
            //

            case FSCTL_SIS_LINK_FILES:
                status = STATUS_ACCESS_DENIED;
                goto CompleteWithStatus;

            //
            // Fsctl call 66
            //
            // Something related to HSM.  Not sure what to do with this; just pass it through.
            //

            case FSCTL_HSM_MSG:
                goto PassThrough;

            //
            //  Handle everything else
            //

            default:
#if DBG
                DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                            "SiFsControl with unknown code 0x%x\n",irpSp->Parameters.FileSystemControl.FsControlCode);
                if (BJBDebug & 0x400) {
                    DbgBreakPoint();
                }
#endif  // DBG
                goto PassThrough;
        }

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                FSCTL_SIS_COPYFILE == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipFsCopyFile(DeviceObject,Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                       FSCTL_SIS_LINK_FILES == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipLinkFiles(DeviceObject, Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                       FSCTL_DISMOUNT_VOLUME == irpSp->Parameters.FileSystemControl.FsControlCode) {

        return SipDismountVolume(DeviceObject, Irp);

    } else if (IRP_MN_USER_FS_REQUEST == irpSp->MinorFunction &&
                    FSCTL_SET_REPARSE_POINT == irpSp->Parameters.FileSystemControl.FsControlCode) {

        PREPARSE_DATA_BUFFER reparseBuffer = Irp->AssociatedIrp.SystemBuffer;
        ULONG InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Handle a user set of a SIS reparse point.
        //

        if ((NULL == reparseBuffer) || 
                (InputBufferLength < SIS_REPARSE_DATA_SIZE) || 
                (IO_REPARSE_TAG_SIS != reparseBuffer->ReparseTag)) {

            //
            // This isn't a valid SIS reparse point being set, just pass the call through.
            //

            goto PassThrough;
        }

        status =  SipUserSetSISReparsePoint(DeviceObject, Irp);
        return status;

    } else {

        //
        // Simply pass this file system control request through, we don't need a callback
        //

PassThrough:
        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    // Any special processing has been completed, so simply pass the request
    // along to the next driver.
    //

    return IoCallDriver( devExt->AttachedToDeviceObject, Irp );

/////////////////////////////////////////////////////////////////////////////
//                  Handle status cases
/////////////////////////////////////////////////////////////////////////////

CompleteWithStatus:

    SIS_MARK_POINT_ULONG(status);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

SendToCSFile:
    IoCopyCurrentIrpStackLocationToNext( Irp );

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->FileObject = scb->PerLink->CsFile->UnderlyingFileObject;

    IoSetCompletionRoutine(
                Irp,
                NULL,
                NULL,
                FALSE,
                FALSE,
                FALSE);

    return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siinit.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    siinit.c

Abstract:

    SIS initialization and mount/attach support

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

/////////////////////////////////////////////////////////////////////////////
//
//                          Globals
//

/////////////////////////////////////////////////////////////////////////////

//
//  This is the string for the data attribute, $DATA, cribbed from ntfsdata.c
//

const UNICODE_STRING NtfsDataString = CONSTANT_UNICODE_STRING( L"$DATA" );


//
//  Holds pointer to the device object that represents this driver and is used
//  by external programs to access this driver.
//

PDEVICE_OBJECT SisControlDeviceObject = NULL;


//
//  List head for list of device extensions
//

KSPIN_LOCK DeviceExtensionListLock;
LIST_ENTRY DeviceExtensionListHead;

//
//  Global logging variables
//

KTIMER              LogTrimTimer[1];
KDPC                LogTrimDpc[1];
WORK_QUEUE_ITEM     LogTrimWorkItem[1];


/////////////////////////////////////////////////////////////////////////////
//
//                      Function Prototypes
//
/////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SipAttachToFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SipDetachFromFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SipEnumerateFileSystemVolumes(
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );

VOID
SipGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SipFsNotification)
#endif  // ALLOC_PRAGMA



//
//  Given a device type, return a valid name
//

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (sizeof(DeviceTypeNames) / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Known device type names
//

static const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

/////////////////////////////////////////////////////////////////////////////
//
//                          FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the SIS file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    PFAST_IO_DISPATCH   fastIoDispatch;
    UNICODE_STRING      nameString;
    NTSTATUS            status;
    ULONG               i;
    HANDLE              threadHandle;
    LARGE_INTEGER       dueTime;

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_TRACE_LEVEL,
                "SIS: SIS.sys built %s. %s\n",
                 __DATE__ " " __TIME__,
                GCHEnableFastIo ? "FastIo " : "NO-FastIo" );

    //DbgBreakPoint();
#endif

    UNREFERENCED_PARAMETER( RegistryPath );
    SIS_MARK_POINT();

#if DBG
    KeInitializeSpinLock(MarkPointSpinLock);

    for (i = 0; i < NumScbReferenceTypes; i++) {
        totalScbReferencesByType[i] = 0;
    }
#endif  // DBG

#if COUNTING_MALLOC
    //
    // We need to initialize counting malloc before failing malloc.
    //
    SipInitCountingMalloc();
#endif  // COUNTING_MALLOC

#if RANDOMLY_FAILING_MALLOC
    SipInitFailingMalloc();
#endif  // RANDOMLY_FAILING_MALLOC

    //
    // Assert that we've left enough room in the backpointer streams for the header.
    //

    ASSERT(sizeof(SIS_BACKPOINTER_STREAM_HEADER) <= sizeof(SIS_BACKPOINTER) * SIS_BACKPOINTER_RESERVED_ENTRIES);

    ASSERT(sizeof(GUID) == 2 * sizeof(LONGLONG));   // SipCSFileTreeCompare relies on this

    ASSERT(sizeof(SIS_LOG_HEADER) % 4 == 0);    // The log drain code relies on this.

    //
    //  Save our Driver Object
    //

    FsDriverObject = DriverObject;

    //
    //  Create the Control Device Object (CDO).  This object represents this 
    //  driver.  Note that it does not have a device extension.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem\\Filters\\Sis" );
    status = IoCreateDevice(
                DriverObject,
                0,
                &nameString,
                FILE_DEVICE_DISK_FILE_SYSTEM,
                0,
                FALSE,
                &SisControlDeviceObject );

    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: Error creating control device object, status=%08x\n", status );
#endif // DBG
        SIS_MARK_POINT();
        return status;
    }

#if TIMING
    SipInitializeTiming();
#endif  // TIMING

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SiPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SiCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SiClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SiCleanup;
    DriverObject->MajorFunction[IRP_MJ_READ] = SiRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = SiWrite;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SiFsControl;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = SiSetInfo;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = SiQueryInfo;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = SiLockControl;

    //
    // Allocate fast I/O data structure and fill it in.
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), SIS_POOL_TAG );
    if (!fastIoDispatch) {
        IoDeleteDevice( SisControlDeviceObject );
        SIS_MARK_POINT();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );

    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SiFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SiFastIoRead;
    fastIoDispatch->FastIoWrite = SiFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SiFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SiFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SiFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SiFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SiFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SiFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SiFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SiFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SiFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SiFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SiFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SiFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SiFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SiFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SiFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SiFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SiFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SiFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

    //
    //  Setup list of device extensions
    //

    KeInitializeSpinLock(&DeviceExtensionListLock);
    InitializeListHead(&DeviceExtensionListHead);

    //
    //  Register this driver for watching file systems coming and going.  This
    //  enumeates all existing file systems as well as new file systems as they
    //  come and go.
    //

    status = IoRegisterFsRegistrationChange( DriverObject, SipFsNotification );
    if (!NT_SUCCESS( status )) {
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: Error registering FS change notification, status=%08x\n", status );
#endif // DBG
        IoDeleteDevice( SisControlDeviceObject );
        SIS_MARK_POINT();
        return status;
    }

    //
    // Set up the list & synch stuff for handing copy requests off to the copy thread(s).
    //

    InitializeListHead(CopyList);
    KeInitializeSpinLock(CopyListLock);
    KeInitializeSemaphore(CopySemaphore,0,MAXLONG);

    //
    // Create the thread that does the copy-on-write copies.  We need to deal with having more than
    // one thread if necessary...
    //

    status = PsCreateSystemThread(
                    &threadHandle,
                    THREAD_ALL_ACCESS,
                    NULL,               // Object Attributes
                    NULL,               // Process (NULL => PsInitialSystemProcess)
                    NULL,               // Client ID
                    SiCopyThreadStart,
                    NULL);              // context

    KeInitializeDpc(LogTrimDpc,SiLogTrimDpcRoutine,NULL);
    KeInitializeTimerEx(LogTrimTimer, SynchronizationTimer);
    ExInitializeWorkItem(LogTrimWorkItem,SiTrimLogs,NULL);

    dueTime.QuadPart = LOG_TRIM_TIMER_INTERVAL;

    KeSetTimerEx(LogTrimTimer,dueTime,0,LogTrimDpc);

#if TIMING && !DBG
    //
    // We need to have some way to get at the timing variables through the debugger.
    //
    {
        extern ULONG BJBClearTimingNow, BJBDumpTimingNow, SipEnabledTimingPointSets;

        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: BJBClearTimingNow %p; BJBDumpTimingNow %p; SipEnabledTimingPointSets %p\n",
                    &BJBClearTimingNow, 
                    &BJBDumpTimingNow, 
                    &SipEnabledTimingPointSets);
    }
#endif  // TIMING && !DBG

    SIS_MARK_POINT();
    return STATUS_SUCCESS;
}

NTSTATUS
SipInitializeDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    

Arguments:

    DevExt - the device extension to initialize

Return Value:

    Status of the operation

--*/
{
    PDEVICE_EXTENSION           devExt = DeviceObject->DeviceExtension;
    PWCHAR                      nameBuffer;
    ULONG                       nameLen;
    UNICODE_STRING              name;
    WCHAR                       lnameBuf[MAX_DEVNAME_LENGTH];

    SIS_MARK_POINT();

    //
    //  Set our device object into our extension
    //

    devExt->DeviceObject = DeviceObject;

    //
    // Initialize the various splay trees.
    //

    SipInitializeTree(devExt->ScbTree, SipScbTreeCompare);
    KeInitializeSpinLock(devExt->ScbSpinLock);
    SipInitializeTree(devExt->PerLinkTree, SipPerLinkTreeCompare);
    KeInitializeSpinLock(devExt->PerLinkSpinLock);
    SipInitializeTree(devExt->CSFileTree, SipCSFileTreeCompare);
    KeInitializeSpinLock(devExt->CSFileSpinLock);

    InitializeListHead(&devExt->ScbList);

    ExInitializeResourceLite(devExt->CSFileHandleResource);
    ExInitializeResourceLite(devExt->GrovelerFileObjectResource);

    //
    //  The only time this will be null is if we are attaching to the file
    //  system CDO (control device object).  Init the common store name
    //  (to null) and return.
    //

    if (!devExt->RealDeviceObject) {

        SIS_MARK_POINT();
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);

        devExt->Flags |= SIP_EXTENSION_FLAG_INITED_CDO;
        return STATUS_SUCCESS;
    }

    //
    //  We are attaching to a mounted volume.  Get the name of that volume.
    //

    RtlInitEmptyUnicodeString( &name, lnameBuf, sizeof(lnameBuf) );
    SipGetBaseDeviceObjectName( devExt->RealDeviceObject, &name );
    
    //
    //  Allocate a buffer to hold the name we received and store it in our
    //  device extension
    //
    
    nameLen = name.Length + SIS_CSDIR_STRING_SIZE + sizeof(WCHAR);

    nameBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       nameLen,
                                       SIS_POOL_TAG);

    if (NULL == nameBuffer) {

        SIS_MARK_POINT();
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  We got the buffer, store the name in it
    //

    RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,
                              nameBuffer,
                              nameLen);

    RtlCopyUnicodeString(&devExt->CommonStorePathname,
                         &name);

    //
    //  We want to save the path to the root of the volume.  Save a copy of
    //  the pointer and lengths before we add the common store name onto the
    //  string.  We do want to add the "\" character.

    devExt->FilesystemRootPathname = devExt->CommonStorePathname;
    devExt->FilesystemRootPathname.Length += sizeof(WCHAR);

    //
    //  Append the common store name to it
    //

    RtlAppendUnicodeToString(&devExt->CommonStorePathname,SIS_CSDIR_STRING);

    //
    // Set up the stuff for the index allocator.  Note that by setting MaxAllocatedIndex
    // equal to MaxUsedIndex, we force the allocator to run the first time that anyone
    // tries to get an index.  It'll recognize the special case, open the index file
    // and do the right thing.
    //

    devExt->MaxAllocatedIndex.QuadPart = devExt->MaxUsedIndex.QuadPart = 0;
    KeInitializeSpinLock(devExt->IndexSpinLock);
    KeInitializeEvent(devExt->IndexEvent,NotificationEvent,FALSE);
    devExt->IndexHandle = NULL;
    devExt->IndexFileEventHandle = NULL;
    devExt->IndexFileEvent = NULL;

    devExt->GrovelerFileHandle = NULL;
    devExt->GrovelerFileObject = NULL;
    KeInitializeSpinLock(devExt->FlagsLock);
    devExt->Flags = 0;
    KeInitializeEvent(devExt->Phase2DoneEvent,NotificationEvent,FALSE);

    KeInitializeMutex(devExt->CollisionMutex, 0);

#if     ENABLE_LOGGING
    devExt->LogFileHandle = NULL;
    devExt->LogFileObject = NULL;
    devExt->LogWriteOffset.QuadPart = 0;
    KeInitializeMutant(devExt->LogFileMutant, FALSE);
#endif  // ENABLE_LOGGING

    devExt->OutstandingFinalCopyRetries = 0;

    devExt->FilesystemVolumeSectorSize = devExt->AttachedToDeviceObject->SectorSize;
    ASSERT(devExt->FilesystemVolumeSectorSize > 63);       // do any disks have sectors this small?

    devExt->BackpointerEntriesPerSector = devExt->FilesystemVolumeSectorSize / sizeof(SIS_BACKPOINTER);

    //
    // Add this device extension to the list of SIS device extensions.
    //

    ExInterlockedInsertTailList(
            &DeviceExtensionListHead,
            &devExt->DevExtLink,
            &DeviceExtensionListLock );

    SIS_MARK_POINT();

    //
    //  Mark extension as initialized
    //

    devExt->Flags |= SIP_EXTENSION_FLAG_INITED_VDO;

    return STATUS_SUCCESS;
}


VOID
SipCleanupDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    We're about to free a device extension, probably because the
    volume has been dismounted for some reason.  Clean it up.

Arguments:

    devExt - the device extension to clean

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION       devExt = DeviceObject->DeviceExtension;
    KIRQL OldIrql;

    SIS_MARK_POINT();

    //
    //  Cleanup the name strings
    //

    if (NULL != devExt->CommonStorePathname.Buffer) {

        ASSERT(devExt->CommonStorePathname.Buffer == devExt->FilesystemRootPathname.Buffer);
        ExFreePool(devExt->CommonStorePathname.Buffer);
        RtlInitEmptyUnicodeString(&devExt->CommonStorePathname,NULL,0);
        RtlInitEmptyUnicodeString(&devExt->FilesystemRootPathname,NULL,0);
    }

#if DBG
    //
    //  If a name buffer is allocated, free it
    //

    if (NULL != devExt->Name.Buffer) {

        ExFreePool( devExt->Name.Buffer );
        RtlInitEmptyUnicodeString( &devExt->Name, NULL, 0 );
    }
#endif

    //
    //  Cleanup if initialized
    //

    if (devExt->Flags & (SIP_EXTENSION_FLAG_INITED_CDO|SIP_EXTENSION_FLAG_INITED_VDO)) {

        //
        // Verify the splay trees are empty
        //

        ASSERT(devExt->ScbTree->TreeRoot == NULL);
        ASSERT(devExt->PerLinkTree->TreeRoot == NULL);
        ASSERT(devExt->CSFileTree->TreeRoot == NULL);


        ASSERT(IsListEmpty(&devExt->ScbList));

        //
        //  Cleanup resouces
        //

        ExDeleteResourceLite(devExt->CSFileHandleResource);
        ExDeleteResourceLite(devExt->GrovelerFileObjectResource);

        //
        //  Unlink from the device extension list (if VDO)
        //

        if (devExt->Flags & SIP_EXTENSION_FLAG_INITED_VDO) {

            KeAcquireSpinLock(&DeviceExtensionListLock, &OldIrql);

            RemoveEntryList( &devExt->DevExtLink );

            KeReleaseSpinLock(&DeviceExtensionListLock, OldIrql);
        }
    }
}


VOID
SipFsNotification(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Ffolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
    UNICODE_STRING name;
    WCHAR nameBuf[MAX_DEVNAME_LENGTH];

    PAGED_CODE();
    SIS_MARK_POINT();

    RtlInitEmptyUnicodeString( &name, nameBuf, sizeof(nameBuf) );

#if DBG
    //
    //  Display the names of all the file system we are notified of
    //

    SipGetBaseDeviceObjectName( DeviceObject, &name );
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
              "SIS: %s       \"%wZ\" (%s)\n",
              (FsActive) ? "Activating file system  " : "Deactivating file system",
              &name,
              GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType) );
#endif

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {

        SipAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SipDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
SipAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    UNICODE_STRING ntfsName;
    NTSTATUS status;

    PAGED_CODE();
    SIS_MARK_POINT();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    }

    //
    //  See if this is one of the standard Microsoft file system recognizer
    //  devices (see if this device is in the FS_REC driver).  If so skip it.
    //  We no longer attach to file system recognizer devices, we simply wait
    //  for the real file system driver to load.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    SipGetObjectName( DeviceObject->DriverObject, Name );

    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    }

    //
    //  See if this is NTFS's control device object (CDO)
    //

    RtlInitUnicodeString( &ntfsName, L"\\Ntfs" );
    SipGetBaseDeviceObjectName( DeviceObject, Name );

    if (RtlCompareUnicodeString( &ntfsName, Name, TRUE ) == 0) {

        SIS_MARK_POINT();

#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Found NTFS Control Device Object\n");
#endif

        //
        //  We found the ntfs control device object, save it
        //

        FsNtfsDeviceObject = DeviceObject;

    } else {

        //
        //  Not NTFS CDO, return
        //

        SIS_MARK_POINT();
        return STATUS_SUCCESS;
    } 

    SIS_MARK_POINT();

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( FsDriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        SIS_MARK_POINT();
        return status;
    }

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( newDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( newDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Do the attachment
    //

    devExt = newDeviceObject->DeviceExtension;

    status = IoAttachDeviceToDeviceStackSafe( newDeviceObject, 
                                              DeviceObject,
                                              &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS(status)) {

        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializaing our device extension
    //

    status = SipInitializeDeviceExtension( newDeviceObject );
    ASSERT(STATUS_SUCCESS == status);

    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

#if DBG
    //
    //  Display who we have attached to
    //

    SipCacheDeviceName( newDeviceObject );
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                "SIS: Attaching to file system       \"%wZ\" (%s)\n",
                &devExt->Name,
                GET_DEVICE_TYPE_NAME(newDeviceObject->DeviceType) );
#endif

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = SipEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( newDeviceObject );

    ErrorCleanupDevice:
        SipCleanupDeviceExtension( newDeviceObject );
        IoDeleteDevice( newDeviceObject );

    return status;
}


VOID
SipDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

#if DBG
            //
            //  Display who we detached from
            //

            SipCacheDeviceName( ourAttachedDevice );
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                        "SIS: Detaching from file system     \"%wZ\" (%s)\n",
                        &devExt->Name,
                        GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
#endif

            //
            //  Since we only attached to NTFS, we can only detach from
            //  NTFS
            //

            ASSERT(FsNtfsDeviceObject == DeviceObject);
            FsNtfsDeviceObject = NULL;

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoDetachDevice( DeviceObject );
            SipCleanupDeviceExtension( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            SIS_MARK_POINT();
            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
    SIS_MARK_POINT();
}


NTSTATUS
SipEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT realDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList(
                    FSDeviceObject->DriverObject,
                    NULL,
                    0,
                    &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         SIS_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !SipAttachedToDevice( devList[i] )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                SipGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the real (disk) device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &realDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( FsDriverObject,
                                                 sizeof( DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &newDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  attach to volume
                            //

                            SipAttachToMountedDevice( devList[i], 
                                                      newDeviceObject, 
                                                      realDeviceObject );
                        }

                        //
                        //  Remove reference added by IoGetDiskDeviceObject
                        //

                        ObDereferenceObject( realDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}


NTSTATUS
SipAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT NewDeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject
    )
/*++

Routine Description:

    This will attach to a DeviceObject that represents a mounted volume.

Arguments:

    DeviceObject - The device to attach to

    NewDeviceObject - Our device object we are going to attach

    RealDeviceObject - The real device object associated with DeviceObject

Return Value:

    Status of the operation

--*/
{        
    PDEVICE_EXTENSION newDevExt = NewDeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(IS_MY_DEVICE_OBJECT( NewDeviceObject ));
    ASSERT(!SipAttachedToDevice ( DeviceObject ));

    //
    //  Initialize our device extension
    //

    newDevExt->RealDeviceObject = RealDeviceObject;

    //
    //  We don't want to attach to the BOOT partition, skip this volume
    //  (and cleanup) if this is the boot partition
    //

    if (RealDeviceObject->Flags & DO_SYSTEM_BOOT_PARTITION) {

#if DBG
        SipCacheDeviceName( NewDeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Not filtering boot volume      \"%wZ\"\n",
                    &newDevExt->Name );
#endif

        //
        //  Cleanup
        //

        SipCleanupDeviceExtension( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );

        return STATUS_SUCCESS;
    }

    //
    //  Propagate Device flags from Device Object we are attaching to
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( NewDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( NewDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Attach our device object to the given device object
    //

    status = IoAttachDeviceToDeviceStackSafe( NewDeviceObject, 
                                              DeviceObject,
                                              &newDevExt->AttachedToDeviceObject );

    if (!NT_SUCCESS(status)) {

        //
        //  The attachment failed, delete the device object
        //

        SipCleanupDeviceExtension( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );

    } else {

        //
        //  Initialize our device extension
        //

        SipInitializeDeviceExtension( NewDeviceObject );

        ClearFlag( NewDeviceObject->Flags, DO_DEVICE_INITIALIZING );

        //
        //  Display the name
        //

#if DBG
        SipCacheDeviceName( NewDeviceObject );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Attaching to volume            \"%wZ\"\n", 
                    &newDevExt->Name );
#endif
    }

    return status;
}


VOID
SipGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}


VOID
SipGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    SipGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}


BOOLEAN
SipAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.

Arguments:

    DeviceObject - The device chain we want to look through

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.  This is returned
    //  with a refrence on it.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            ObDereferenceObject( currentDevObj );
            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

#if DBG
VOID
SipCacheDeviceName (
    IN PDEVICE_OBJECT OurDeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object.  This always allocates a buffer to hold the name, even if
    a name can not be found.  It does this so we won't keep trying to find
    a name during later calls (if it doesn't have a name now, it won't have
    one in the future).
    
    If the given device object already has a name, it immediatly returns.

    If not it will try and get the name from:
        - The device object
        - The real device object if there is one

Arguments:

    OurDeviceObject - The device object to store the name in.
    NamedDeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION devExt = OurDeviceObject->DeviceExtension;
    PWCHAR nameBuffer;
    UNICODE_STRING deviceName;
    WCHAR deviceNameBuffer[MAX_DEVNAME_LENGTH];

    ASSERT(IS_MY_DEVICE_OBJECT( OurDeviceObject ));

    //
    //  If there is already a name, return
    //

    if (NULL != devExt->Name.Buffer) {

        return;
    }

    //
    //  Get the name of the given device object.
    //

    RtlInitEmptyUnicodeString( &deviceName, deviceNameBuffer, sizeof(deviceNameBuffer) );
    SipGetBaseDeviceObjectName( OurDeviceObject, &deviceName );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((deviceName.Length <= 0) && (NULL != devExt->RealDeviceObject)) {

        SipGetBaseDeviceObjectName( devExt->RealDeviceObject, &deviceName );
    }

    //
    //  Allocate a buffer to insert into the device extension to hold
    //  this name.
    //

    nameBuffer = ExAllocatePoolWithTag( 
                                NonPagedPool, 
                                deviceName.Length + sizeof(WCHAR),
                                SIS_POOL_TAG );

    if (NULL != nameBuffer) {

        //
        //  Insert the name into the device extension.
        //

        RtlInitEmptyUnicodeString( &devExt->Name, 
                                   nameBuffer, 
                                   deviceName.Length + sizeof(WCHAR) );

        RtlCopyUnicodeString( &devExt->Name, &deviceName );
    }
}
#endif //DBG


VOID
SipPhase2Work(
    PVOID                   context)
{
    HANDLE                  vHandle;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       Obja[1];
    IO_STATUS_BLOCK         Iosb[1];
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)context;
    UNICODE_STRING          fileName;
    HANDLE                  volumeRootHandle = NULL;
    PFILE_OBJECT            volumeRootFileObject = NULL;
    NTFS_VOLUME_DATA_BUFFER volumeDataBuffer[1];
    ULONG                   returnedLength;
    PFILE_OBJECT            volumeFileObject = NULL;
    HANDLE                  volumeHandle = NULL;
    UNICODE_STRING          volumeName;
    BOOLEAN                 initializationWorked = TRUE;
    BOOLEAN                 grovelerFileResourceHeld = FALSE;
    KIRQL                   OldIrql;

    fileName.Buffer = NULL;

    SIS_MARK_POINT();

#if DBG
    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                "SIS: SipPhase2Work                  \"%wZ\"\n",
                &deviceExtension->Name);
#endif  // DBG

    deviceExtension->Phase2ThreadId = PsGetCurrentThreadId();

    fileName.MaximumLength =
        deviceExtension->CommonStorePathname.Length
        + max(SIS_GROVELER_FILE_STRING_SIZE, SIS_VOLCHECK_FILE_STRING_SIZE)
        + sizeof(WCHAR);

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, SIS_POOL_TAG);

    if (NULL == fileName.Buffer) {

        initializationWorked = FALSE;
        goto done;
    }

    //
    // Open the groveler file.  Take the GrovelerFileObjectResource exclusive, even through
    // we probably don't need it here since we're creating it rather than destroying it.
    // We don't need to disable APCs, since we're in a system thread.
    //
	ASSERT(PsIsSystemThread(PsGetCurrentThread()));

    ExAcquireResourceExclusiveLite(deviceExtension->GrovelerFileObjectResource, TRUE);
    grovelerFileResourceHeld = TRUE;

    fileName.Length = 0;

    RtlCopyUnicodeString(&fileName,&deviceExtension->CommonStorePathname);

    ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);
    RtlAppendUnicodeToString(&fileName,SIS_GROVELER_FILE_STRING);

    InitializeObjectAttributes(
            Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtCreateFile(
            &deviceExtension->GrovelerFileHandle,
            GENERIC_READ,
            Obja,
            Iosb,
            NULL,                   // Allocation size
            0,                      // file attributes
            FILE_SHARE_READ |
            FILE_SHARE_WRITE,
            FILE_OPEN_IF,           // create it if necessary
            0,                      // create options
            NULL,                   // EA buffer
            0);                     // EA length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    ASSERT(STATUS_PENDING != status);   // create is always synchronous

    status = ObReferenceObjectByHandle(
                deviceExtension->GrovelerFileHandle,
                FILE_READ_DATA,
                *IoFileObjectType,
                KernelMode,
                &deviceExtension->GrovelerFileObject,
                NULL);          // handleInformation

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        initializationWorked = FALSE;
        goto done;
    }

    ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
    grovelerFileResourceHeld = FALSE;

    //
    // Temporarily open a handle to the volume root, just to verify that the
    // groveler file is on the same volume as the device to which we're attached.
    // Essentially, this is checking for rogue mount points.
    //

    InitializeObjectAttributes(
        Obja,
        &deviceExtension->FilesystemRootPathname,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &volumeRootHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                NULL,               // allocation size
                0,                  // file attributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE |
                FILE_SHARE_DELETE,
                FILE_OPEN,
                0,                  // create options
                NULL,               // EA buffer
                0);                 // EA length

    if (!NT_SUCCESS(status)) {
        //
        // Since this is only a paranoid consistency check, we'll just ignore
        // the check and continue as if it succeeded.
        //
#if DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SipPhase2Work: unable to open volume root, 0x%x\n",status);
#endif  // DBG
    } else {
        status = ObReferenceObjectByHandle(
                    volumeRootHandle,
                    FILE_READ_DATA,
                    *IoFileObjectType,
                    KernelMode,
                    &volumeRootFileObject,
                    NULL);          // handle info

        if (!NT_SUCCESS(status)) {
            //
            // Just blow off the consistency check.
            //
#if DBG
            DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                        "SIS: SipPhase2Work: unable to reference volume root handle, 0x%x\n",status);
#endif  // DBG
        } else {
            if (IoGetRelatedDeviceObject(volumeRootFileObject) !=
                IoGetRelatedDeviceObject(deviceExtension->GrovelerFileObject)) {
#if DBG
                DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                            "SIS: \\SIS Common Store\\GrovelerFile is on the wrong volume from \\.  SIS aborted for this volume.\n");
#endif  // DBG
                ObDereferenceObject(deviceExtension->GrovelerFileObject);
                ZwClose(deviceExtension->GrovelerFileHandle);

                deviceExtension->GrovelerFileObject = NULL;
                deviceExtension->GrovelerFileHandle = NULL;

                goto done;
            }
        }
    }

    //
    // Try to open the volume check file.  If it exists, then we must initiate a
    // volume check.
    //

    RtlCopyUnicodeString(&fileName, &deviceExtension->CommonStorePathname);

    ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);
    RtlAppendUnicodeToString(&fileName, SIS_VOLCHECK_FILE_STRING);

    InitializeObjectAttributes(
            Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtCreateFile(
            &vHandle,
            0,
            Obja,
            Iosb,
            NULL,                   // Allocation size
            0,                      // file attributes
            0,                      // share mode
            FILE_OPEN,              // don't create
            0,                      // create options
            NULL,                   // EA buffer
            0);                     // EA length

    if (NT_SUCCESS(status)) {

        NtClose(vHandle);

        //
        // This will create a new thread to do the volume check, which
        // will immediately block waiting for us to finish phase 2
        // initialization.
        //
        SipCheckVolume(deviceExtension);
    }

    //
    // Get the NTFS volume information to find the bytes per file record segment.
    // We first need to open a volume handle to do this.  We get the volume name
    // by stripping the trailing backslash from the root pathanme.
    //

    //
    // Start by setting the bytes per file record to a safe size, in case for some
    // reason we can't get the volume information.  For our purposes, we want to err
    // on the high side.
    //

    deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart = 16 * 1024;

    volumeName.Length = deviceExtension->FilesystemRootPathname.Length - sizeof(WCHAR);
    volumeName.MaximumLength = volumeName.Length;
    volumeName.Buffer = deviceExtension->FilesystemRootPathname.Buffer;

    InitializeObjectAttributes(
        Obja,
        &volumeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &volumeHandle,
                GENERIC_READ,
                Obja,
                Iosb,
                NULL,               // allocation size
                0,                  // file attributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE |
                FILE_SHARE_DELETE,
                FILE_OPEN,
                0,                  // create options
                NULL,               // EA buffer
                0);                 // EA length

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    status = ObReferenceObjectByHandle(
                volumeHandle,
                FILE_READ_DATA,
                *IoFileObjectType,
                KernelMode,
                &volumeFileObject,
                NULL);          // handleInformation

    if (!NT_SUCCESS(status))  {
        SIS_MARK_POINT_ULONG(status);

        initializationWorked = FALSE;
        goto done;
    }

    status = SipFsControlFile(
                    volumeFileObject,
                    deviceExtension->DeviceObject,
                    FSCTL_GET_NTFS_VOLUME_DATA,
                    NULL,                           // input buffer
                    0,                              // i.b. length
                    volumeDataBuffer,
                    sizeof(NTFS_VOLUME_DATA_BUFFER),
                    &returnedLength);

    if (!NT_SUCCESS(status) || (sizeof(NTFS_VOLUME_DATA_BUFFER) != returnedLength)) {
        SIS_MARK_POINT_ULONG(status);
        SIS_MARK_POINT_ULONG(returnedLength);

#if     DBG
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                    "SIS: SipPhase2Work: unable to get NTFS volume data (or wrong length) 0x%x, %d\n",status,returnedLength);
#endif  // DBG

        initializationWorked = FALSE;
        // fall through

    } else {
        deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart =
            volumeDataBuffer->BytesPerFileRecordSegment;

        ASSERT(volumeDataBuffer->BytesPerSector == deviceExtension->FilesystemVolumeSectorSize);
    }

    if (NULL != volumeHandle) {
        NtClose(volumeHandle);
        volumeHandle = NULL;
    }

    if (NULL != volumeFileObject) {
        ObDereferenceObject(volumeFileObject);
        volumeFileObject = NULL;
    }


    //
    // Open the log file, which will also replay the log.  Note that we MUST have opened
    // the root handle before we make this call.
    //
    SipOpenLogFile(deviceExtension);

    // Whatever other phase 2 initialization we need to do

done:

    ASSERT(PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId);
    deviceExtension->Phase2ThreadId = NULL;
    SIS_MARK_POINT();

    if (grovelerFileResourceHeld) {
        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileResourceHeld = FALSE;
    }

    //
    // Indicate that we're done.  Once we do this set, we have to assume that folks are
    // using the phase2 initialized stuff.
    //

    ASSERT(!deviceExtension->Phase2InitializationComplete);

    KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
    deviceExtension->Flags &= ~SIP_EXTENSION_FLAG_PHASE_2_STARTED;
    deviceExtension->Phase2InitializationComplete = initializationWorked;

    //
    // Finally, wake up any threads that happend to block on phase 2 initialization
    // while we were doing it.
    //

    KeSetEvent(deviceExtension->Phase2DoneEvent, IO_DISK_INCREMENT, FALSE);
    KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    if (NULL != fileName.Buffer) {

        ExFreePool(fileName.Buffer);
    }

    if (NULL != volumeRootHandle) {

        NtClose(volumeRootHandle);
    }

    if (NULL != volumeRootFileObject) {

        ObDereferenceObject(volumeRootFileObject);
    }
}


BOOLEAN
SipHandlePhase2(
    PDEVICE_EXTENSION               deviceExtension)
{
    KIRQL               OldIrql;
    BOOLEAN             startPhase2;
    NTSTATUS            status;
    WORK_QUEUE_ITEM     workItem[1];

    SIS_MARK_POINT();

	//
	// If this is the device object that we created to attach to the
	// Ntfs primary device object to watch for mount requests, then just
	// say no.
	//
	if (NULL == deviceExtension->RealDeviceObject) {
		return FALSE;
	}

	//
	// First, figure out if anyone else has started phase 2, and indicate that
	// it's started now.
	//
	KeAcquireSpinLock(deviceExtension->FlagsLock, &OldIrql);
	startPhase2 = !(deviceExtension->Flags & SIP_EXTENSION_FLAG_PHASE_2_STARTED);
	deviceExtension->Flags |= SIP_EXTENSION_FLAG_PHASE_2_STARTED;
	KeReleaseSpinLock(deviceExtension->FlagsLock, OldIrql);

    //
    // If we're the ones who need to start phase 2, then do it.
    //
    if (startPhase2) {

        KeClearEvent(deviceExtension->Phase2DoneEvent);

        ExInitializeWorkItem(
            workItem,
            SipPhase2Work,
            (PVOID)deviceExtension);

        ExQueueWorkItem(workItem,CriticalWorkQueue);
    }

    //
    // Allow the phase2 worker thread to proceed, since it may well do the phase2 check while
    // doing its internal work.
    //
    if (PsGetCurrentThreadId() == deviceExtension->Phase2ThreadId) {
        SIS_MARK_POINT();
        return TRUE;
    }

    status = KeWaitForSingleObject(deviceExtension->Phase2DoneEvent, Executive, KernelMode, FALSE, NULL);
    ASSERT(status == STATUS_SUCCESS);
    SIS_MARK_POINT();

    return deviceExtension->Phase2InitializationComplete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siinst.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    siinst.c

Abstract:

        Routines to convert two separate identical files into one.  Used only by the groveler.

Authors:

    Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef          ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipCreateCSFile)
#pragma alloc_text(PAGE, SipCreateCSFileWork)
#endif          // ALLOC_PRAGMA


BOOLEAN
SipAbort(
    IN PKEVENT event)

/*++

Routine Description:

    This function checks for an abort signaled via an event.

Arguments:

    event - pointer to an event that signals an abort.

Return Value:

    TRUE if an abort request has been signaled, otherwise FALSE.

--*/

{
	if (event) {
		return KeReadStateEvent(event) != 0;
	} else {
		return FALSE;
	}
}

VOID
SipCreateCSFileWork(
	PVOID				parameter)

/*++

Routine Description:

    This function creates a file in the common store directory and copies
    its contents from the specified source file.

Arguments:

        parameter - a pointer to a SIS_CREATE_CS_FILE_REQUEST.  Its fields
        are described below:

    deviceExtension - Pointer to the device extension for this driver.

    CSid - the id assigned to the common store file.  This is allocated here
                        and returned.

    SrcFileObject - the file containing the contents to copy into
        the common store file.

        NtfsId - returns the NTFS file ID for the newly created common store file.

    AbortEvent - pointer to an event that signals an abort request.  If NULL,
                not abortable.

        CSFileChecksum - Receives the checksum for the new common store file.

        doneEvent - an event to signal on completion

        status - a place for us to return our status

Return Value:

        void

--*/

{
	PSIS_CREATE_CS_FILE_REQUEST		createRequest = (PSIS_CREATE_CS_FILE_REQUEST)parameter;
	PDEVICE_EXTENSION				deviceExtension = createRequest->deviceExtension;
	PCSID							CSid = createRequest->CSid;
	PFILE_OBJECT					SrcFileObject = createRequest->srcFileObject;
	PLARGE_INTEGER					NtfsId = createRequest->NtfsId;
	PKEVENT							AbortEvent = createRequest->abortEvent;
	PLONGLONG						CSFileChecksum = createRequest->CSFileChecksum;
	HANDLE							CSHandle = NULL;
	UNICODE_STRING					CSFileName;
	FILE_STANDARD_INFORMATION		standardFileInfo[1];
	FILE_INTERNAL_INFORMATION		internalInformation[1];
	NTSTATUS						status;
	IO_STATUS_BLOCK					Iosb[1];
	OBJECT_ATTRIBUTES				Obja[1];
	HANDLE							copyEventHandle = NULL;
	PKEVENT							copyEvent = NULL;
	HANDLE							backpointerStreamHandle = NULL;
	LARGE_INTEGER					zero;
	PSIS_BACKPOINTER				sector = NULL;
	PSIS_BACKPOINTER_STREAM_HEADER	backpointerStreamHeader;
	ULONG							index;
	ULONG							retryCount;

	PAGED_CODE();

	CSFileName.Buffer = NULL;

	//
	// Allocate a new common store id.
	//
	retryCount = 0;

	for (;;) {
		status = ExUuidCreate(CSid);

		if (STATUS_RETRY == status) {
			KEVENT			neverSetEvent[1];
			LARGE_INTEGER	timeout[1];

			//
			// We got a retry, which means that the Uuid allocator needs to wait for
			// the timer to tick before it can allocate a new uuid.  Go to sleep for
			// a little while.
			//

			if (++retryCount == 10) {
				// 
				// We've retried too much.  Punt.
				//
				SIS_MARK_POINT();
				goto Error;
			}

			KeInitializeEvent(neverSetEvent, SynchronizationEvent, FALSE);
			timeout->QuadPart = -10 * 1000 * 100;   // 100 ms wait

			status = KeWaitForSingleObject(neverSetEvent,Executive, KernelMode, FALSE, timeout);
			ASSERT(STATUS_TIMEOUT == status);
                                
		} else if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		} else {
			break;
		}
	}

	*CSFileChecksum = 0;

	sector = ExAllocatePoolWithTag(PagedPool, deviceExtension->FilesystemVolumeSectorSize, ' siS');

	if (NULL == sector) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;

		goto Error;
	}

	backpointerStreamHeader = (PSIS_BACKPOINTER_STREAM_HEADER)sector;

    //
    // Get the source file size.
    //

	status = SipQueryInformationFile(
				SrcFileObject,
				deviceExtension->DeviceObject,
				FileStandardInformation,
				sizeof(*standardFileInfo),
				standardFileInfo,
				NULL);                           // returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto Error;
	}

	//
	// Create the common store file.
	// First, create the file name from the index.
	//

	CSFileName.MaximumLength = deviceExtension->CommonStorePathname.MaximumLength + 
	                                INDEX_MAX_NUMERIC_STRING_LENGTH + 
	                                BACKPOINTER_STREAM_NAME_SIZE + 
	                                sizeof(WCHAR);
	CSFileName.Buffer = ExAllocatePoolWithTag(PagedPool, CSFileName.MaximumLength, SIS_POOL_TAG);
    CSFileName.Length = 0;

	if (!CSFileName.Buffer) {
		SIS_MARK_POINT();
		status = STATUS_NO_MEMORY;
		goto Error;
	}

	status = SipIndexToFileName(
				deviceExtension, 
				CSid,
				BACKPOINTER_STREAM_NAME_SIZE,
				FALSE,							// may allocate
				&CSFileName);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Abort if an oplock break has been received.
	//

	if (SipAbort(AbortEvent)) {
		status = STATUS_OPLOCK_BREAK_IN_PROGRESS;
		SIS_MARK_POINT();
		goto Error;
	}

	InitializeObjectAttributes(
		Obja,
		&CSFileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = ZwCreateFile(
				&CSHandle,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				Obja,
				Iosb,
				&standardFileInfo->EndOfFile,
				FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
				0,
				FILE_CREATE,
				FILE_NON_DIRECTORY_FILE,
				NULL,                                   // EA buffer
				0);                                             // EA length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Create the backpointer stream for the file.
	//
	status = RtlAppendUnicodeToString(&CSFileName,BACKPOINTER_STREAM_NAME);
	ASSERT(STATUS_SUCCESS == status);       // because we allocated the buffer to be big enough

	InitializeObjectAttributes(
		Obja,
		&CSFileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = ZwCreateFile(
				&backpointerStreamHandle,
				GENERIC_READ | GENERIC_WRITE | DELETE,
				Obja,
				Iosb,
				NULL,                                                   // allocation size
				FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
				FILE_SHARE_READ | FILE_SHARE_DELETE,
				FILE_CREATE,
				FILE_NON_DIRECTORY_FILE,
				NULL,                                                   // EA Buffer
				0);                                                             // EA Length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SIS: SipCreateCSFile: unable to open checksum stream, 0x%x\n",status);
#endif  // DBG
		goto Error;
	}

	//
	// Get the NTFS file id.  This is passed back to the caller so
	// that the common store file can be opened efficiently in the
	// future.
	//
	status = ZwQueryInformationFile(
				CSHandle,
				Iosb,
				internalInformation,
				sizeof(*internalInformation),
				FileInternalInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Create an event for the copy operation.
	//

	status = SipCreateEvent(
				SynchronizationEvent,
				&copyEventHandle,
				&copyEvent);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
	}

	//
	// Copy the file's contents into the common store.
	//

	if (0 != standardFileInfo->EndOfFile.QuadPart) {

		status = SipBltRangeByObject(
					deviceExtension,
					SrcFileObject,
					CSHandle,
					0,
					standardFileInfo->EndOfFile.QuadPart,
					copyEventHandle,
					copyEvent,
					AbortEvent,
					CSFileChecksum);

		if ((!NT_SUCCESS(status)) || (STATUS_OPLOCK_BREAK_IN_PROGRESS == status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Initialize the backpointer sector.  First write the header,
	// then fill in the remainder of the backpointer entries.
	//

	backpointerStreamHeader->FormatVersion = BACKPOINTER_STREAM_FORMAT_VERSION;
	backpointerStreamHeader->Magic = BACKPOINTER_MAGIC;
	backpointerStreamHeader->FileContentChecksum = *CSFileChecksum;

	for (index = SIS_BACKPOINTER_RESERVED_ENTRIES; 
		 index < deviceExtension->BackpointerEntriesPerSector;
		 index++) {

		sector[index].LinkFileIndex.QuadPart = MAXLONGLONG;
		sector[index].LinkFileNtfsId.QuadPart = MAXLONGLONG;
	}

	zero.QuadPart = 0;

	status = ZwWriteFile(
				backpointerStreamHandle,
				copyEventHandle,
				NULL,                                   // APC Routine
				NULL,                                   // APC Context
				Iosb,
				sector,
				deviceExtension->FilesystemVolumeSectorSize,
				&zero,
				NULL);                                  // key

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(copyEvent, Executive, KernelMode, FALSE, NULL);
		ASSERT(status == STATUS_SUCCESS);     // Since we've got this pointed at our stack, it must succeed.

		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto Error;
		}

#if     DBG
	if (BJBDebug & 0x200) {
		DbgPrint("SIS: SipCreateCSFile: common store file has checksum 0x%x.%x\n",
				 (ULONG)(*CSFileChecksum >> 32), (ULONG)(*CSFileChecksum));
	}
#endif  // DBG

	//
	// Return the file id.
	//

	*NtfsId = internalInformation->IndexNumber;

Exit:
	if (CSFileName.Buffer) {
	ExFreePool(CSFileName.Buffer);
	}

	if (CSHandle) {
		ZwClose(CSHandle);
	}
	if (backpointerStreamHandle) {
		ZwClose(backpointerStreamHandle);
	}
	if (NULL != copyEvent) {
		ObDereferenceObject(copyEvent);
	}
	if (NULL != copyEventHandle) {
		ZwClose(copyEventHandle);
	}
	if (NULL != sector) {
		ExFreePool(sector);
	}

	createRequest->status = status;
	KeSetEvent(createRequest->doneEvent,IO_DISK_INCREMENT,FALSE);

	return;

Error:
	SIS_MARK_POINT_ULONG(status);

	if (CSHandle) {
		FILE_DISPOSITION_INFORMATION disposition[1];
		NTSTATUS deleteStatus;

		disposition->DeleteFile = TRUE;

		deleteStatus = ZwSetInformationFile(
						CSHandle,
						Iosb,
						disposition,
						sizeof(FILE_DISPOSITION_INFORMATION),
						FileDispositionInformation);

#if     DBG
		if (deleteStatus != STATUS_SUCCESS) {

			//
			// Not much we can do about this.  Just leak the file.
			//

			SIS_MARK_POINT_ULONG(status);

			DbgPrint("SipCreateCSFile: unable to delete CS file, err 0x%x, initial error 0x%x\n", deleteStatus, status);
		}
#endif
	}

	goto Exit;
}


NTSTATUS
SipCreateCSFile(
	IN PDEVICE_EXTENSION		deviceExtension,
	OUT PCSID					CSid,
	IN HANDLE					SrcHandle,
	OUT PLARGE_INTEGER			NtfsId,
	IN PKEVENT					AbortEvent OPTIONAL,
	OUT PLONGLONG				CSFileChecksum)
/*++

Routine Description:

        Create a common store file.  This function just rolls up a create request,
        posts it to a worker thread and waits for it to complete.

Arguments:

	deviceExtension - Pointer to the device extension for this driver.

	CSid - the id assigned to the common store file.  This is allocated in the
                        worker routine and returned to the caller

	SrcHandle - the file containing the contents to copy into
        the common store file.

	NtfsId - returns the NTFS file ID for the newly created common store file.

	AbortEvent - pointer to an event that signals an abort request.  If NULL,
                not abortable.

	CSFileChecksum - Receives the checksum for the new common store file.

Return Value:

        The status of the request

--*/
{
	SIS_CREATE_CS_FILE_REQUEST	createRequest[1];
	NTSTATUS					status;
	OBJECT_HANDLE_INFORMATION	handleInformation[1];

	createRequest->srcFileObject = NULL;
        
	status = ObReferenceObjectByHandle(
				SrcHandle,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				(PVOID *) &createRequest->srcFileObject,
				handleInformation);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	createRequest->deviceExtension = deviceExtension;
	createRequest->CSid = CSid;
	createRequest->NtfsId = NtfsId;
	createRequest->abortEvent = AbortEvent;
	createRequest->CSFileChecksum = CSFileChecksum;

	KeInitializeEvent(createRequest->doneEvent,NotificationEvent,FALSE);

	ExInitializeWorkItem(
		createRequest->workQueueItem,
		SipCreateCSFileWork,
		createRequest);

	ExQueueWorkItem(
		createRequest->workQueueItem,
		DelayedWorkQueue);

	status = KeWaitForSingleObject(
				createRequest->doneEvent,
				Executive,
				KernelMode,
				FALSE,
				NULL);

	ASSERT(STATUS_SUCCESS == status);               // createRequest is on our stack, so we really need to wait

	//
	// Return the status of the actual create request.
	//

	status = createRequest->status;

done:

	if (NULL != createRequest->srcFileObject) {
		ObDereferenceObject(createRequest->srcFileObject);
	}

	return status;
}


NTSTATUS
SipRelinkFile(
	PSIS_SCB 		scbSrc,
	PFILE_OBJECT	fileObjectSrc,
	PSIS_CS_FILE	csFileDst)
/*++

Routine Description:

    Unlink the specified link file from it's common store file and relink it to
    the specified different common store file.

Arguments:

    scbSrc - pointer to the scb of the link file.

    fileObjectSrc - pointer to a file object using scbSrc.

    csFileDst - pointer to the common store file that is the target of the
                relink operation.

Return Value:

	The status of the request

--*/
{
	PSIS_SCB		primaryScb;
	PSIS_CS_FILE	csFileSrc;
	LINK_INDEX		NewLinkIndex;
	LINK_INDEX		OldLinkIndex;
	BOOLEAN			FinalCopyInProgress;
	NTSTATUS		status;
	CHAR			reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

	csFileSrc = scbSrc->PerLink->CsFile;

	SIS_MARK_POINT_ULONG(csFileDst);

	//
	// If they are already linked to the same common store file then
	// there's nothing to do.
	//

	if (csFileSrc == csFileDst) {
		status = STATUS_SUCCESS;
		goto Exit;
	}

	// NTRAID#65191-2000/05/23-nealch  When a partial SIS file is detected, convert it to a non-sis file.
	//
	// If the CS files have different checksums, then they're not the same file and shouldn't
	// be linked together.  Fail.
	//
	if (csFileSrc->Checksum != csFileDst->Checksum) {
		SIS_MARK_POINT();
		status = STATUS_INVALID_PARAMETER;
		goto Exit;
	}

	//
	// Unlink scbSrc and relink it to csFileDst.  We need to prepare both CS files.
	// CSsrc will be decremented; CSdst will be incremented. In order to avoid
	// deadlocks, we always prepare the CS file with the lower address first.
	//

	OldLinkIndex = scbSrc->PerLink->Index;

	if (csFileSrc < csFileDst) {

		status = SipPrepareCSRefcountChange(
					csFileSrc,
					&OldLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_CREATED);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the first refcount change (the one who's prepare worked).
			//
			SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&OldLinkIndex,
				csFileSrc,
				FALSE,
				FALSE);

			goto Error;
		}

	} else {

		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_CREATED);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipPrepareCSRefcountChange(
					csFileSrc,
					&OldLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the first refcount change (the one who's prepare worked).
			//
			SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&NewLinkIndex,
				csFileDst,
				FALSE,
				TRUE);

			goto Error;
		}
	}

	//
	// Fill in the reparse point data.
	//

	reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

	if (!SipIndicesIntoReparseBuffer(
			reparseBuffer,
			&csFileDst->CSid,
			&NewLinkIndex,
			&csFileDst->CSFileNtfsId,
			&scbSrc->PerLink->LinkFileNtfsId,
			&csFileDst->Checksum,
			TRUE)) {

		ASSERT(FALSE);
	}

	//
	// Add the new backpointer.  Note that the link file is still properly linked
	// to the source cs file.
	//

	status = SipCompleteCSRefcountChange(
				scbSrc->PerLink,
				&NewLinkIndex,
				csFileDst,
				TRUE,
				TRUE);

	if (!NT_SUCCESS(status)) {
		//
		// Abort the refcount changes.
		//
		SIS_MARK_POINT_ULONG(status);

		SipCompleteCSRefcountChange(
			scbSrc->PerLink,
			&OldLinkIndex,
			csFileSrc,
			FALSE,
			FALSE);
        
		goto Error;

	}

	//
	// Set the reparse point information.  If successful, the link file
	// will correctly point to the new cs file, and the cs file will already
	// have the reference and backpointer set.
	//

	status = SipFsControlFile(
				fileObjectSrc,
				csFileDst->DeviceObject,
				FSCTL_SET_REPARSE_POINT,
				reparseBuffer,
				FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
				NULL,                   // output buffer
				0,                      // output buffer length
				NULL);                  // returned output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// Abort the refcount updates.
		//
		SipCompleteCSRefcountChange(
			scbSrc->PerLink,
			&OldLinkIndex,
			csFileSrc,
			FALSE,
			FALSE);

		//
		// Remove the reference we successfully added to the destination cs file.
		//
		status = SipPrepareCSRefcountChange(
					csFileDst,
					&NewLinkIndex,
					&scbSrc->PerLink->LinkFileNtfsId,
					SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipCompleteCSRefcountChange(
					scbSrc->PerLink,
					&NewLinkIndex,
					csFileDst,
					TRUE,
					FALSE);

#if		DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
		}
#endif	//  DBG

		goto Error;
	}

    //
    // When we remove the backpointer from the source CS file the scb will
    // become "defunct", and I/O requests through it via any existing file
    // objects will be sent to the filesystem w/o intervention from SIS.
    // To prevent that, we need to create a new scb that will become the
    // primary, active scb.
    //

    primaryScb = SipLookupScb(
                    &NewLinkIndex,
                    &csFileDst->CSid,
                    &scbSrc->PerLink->LinkFileNtfsId,
                    &csFileDst->CSFileNtfsId,
                    NULL,
                    csFileDst->DeviceObject,
                    NULL,
                    &FinalCopyInProgress,
                    NULL);

    if (primaryScb) {
        ASSERT(IsEqualGUID(&primaryScb->PerLink->CsFile->CSid, &csFileDst->CSid));

        //
        // Install the new scb into the chain of scb's hanging off the filter
        // context and update all appropriate reference counts.
        //

        status = SipInitializePrimaryScb(
                    primaryScb,
                    scbSrc,
                    fileObjectSrc,
                    csFileSrc->DeviceObject);

        ASSERT(STATUS_SUCCESS == status);

		//
		// We've passed off our reference to the primaryScb, so destroy our pointer to it.
		//
		primaryScb = NULL;

    } else {
#if DBG
        SIS_MARK_POINT();
        DbgPrint("SIS: SipRelinkFile: SipLookupScb failed\n");
#endif
    }

    //
    // Finish the refcount updates.
    //

    status = SipCompleteCSRefcountChange(
                scbSrc->PerLink,
                &OldLinkIndex,
                csFileSrc,
                TRUE,
                FALSE);

#if		DBG
    if (!NT_SUCCESS(status)) {
        //
        // Now what?
        //
        SIS_MARK_POINT_ULONG(status);

        goto Error;
    }
#endif	// DBG

    ASSERT(scbSrc->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE);

Error:
Exit:
    return status;
}


typedef struct _SIS_MERGE_NORMAL_FILES_REQUEST {
        WORK_QUEUE_ITEM                 workQueueItem[1];
        PDEVICE_EXTENSION               deviceExtension;
        PFILE_OBJECT                    fileObject[2];
        HANDLE                                  fileHandle[2];
        FILE_BASIC_INFORMATION  basicInfo[2];
        PKEVENT                                 abortEvent;
        NTSTATUS                                status;
        PIRP                                    Irp;
        BOOLEAN                                 posted;
} SIS_MERGE_NORMAL_FILES_REQUEST, *PSIS_MERGE_NORMAL_FILES_REQUEST;


VOID
SipMergeNormalFilesWork(
	PVOID							Parameter)
{
	PSIS_MERGE_NORMAL_FILES_REQUEST	mergeRequest = (PSIS_MERGE_NORMAL_FILES_REQUEST)Parameter;
	NTSTATUS						status;
	CSID							CSid;
	LARGE_INTEGER					CSFileNtfsId;
	LONGLONG						CSFileChecksum;
	PSIS_CS_FILE					CSFile = NULL;
	ULONG							i;
	FILE_STANDARD_INFORMATION		standardInfo[1];
	FILE_INTERNAL_INFORMATION		internalInfo[1];
	LINK_INDEX						linkIndex[2];
	PDEVICE_EXTENSION				deviceExtension = mergeRequest->deviceExtension;
	PDEVICE_OBJECT					DeviceObject = deviceExtension->DeviceObject;
	FILE_ZERO_DATA_INFORMATION		zeroDataInformation[1];
	CHAR							reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

    //
    // Copy one of the files into the common store.  This will create
    // the file in the common store and copy the contents.
    //

	if (!mergeRequest->posted) {

		ASSERT(NULL != mergeRequest->fileHandle[0] && NULL != mergeRequest->fileHandle[1]);

		status = SipCreateCSFile(
					deviceExtension,
					&CSid,
					mergeRequest->fileHandle[0],
					&CSFileNtfsId,
					mergeRequest->abortEvent,
					&CSFileChecksum);
	} else {
		SIS_CREATE_CS_FILE_REQUEST              createRequest[1];

		ASSERT(NULL == mergeRequest->fileHandle[0] && NULL == mergeRequest->fileHandle[1]);

		createRequest->deviceExtension = deviceExtension;
		createRequest->CSid = &CSid;
		createRequest->NtfsId = &CSFileNtfsId;
		createRequest->abortEvent = mergeRequest->abortEvent;
		createRequest->CSFileChecksum = &CSFileChecksum;
		createRequest->srcFileObject = mergeRequest->fileObject[0];

		KeInitializeEvent(createRequest->doneEvent, NotificationEvent, FALSE);

		SipCreateCSFileWork(createRequest);

		status = createRequest->status;
	}

	//
	// Check to see if we got an oplock break.  This happens if the abort event is set
	// for whatever reason.  If we did, then we change the status to STATUS_REQUEST_ABORTED.
	// We need to do this because STATUS_OPLOCK_BREAK_IN_PROGRESS is a success code.
	//
	if (STATUS_OPLOCK_BREAK_IN_PROGRESS == status) {
		SIS_MARK_POINT();
		status = STATUS_REQUEST_ABORTED;
		//
		// Fall through and let the upcoming error check take care of it.
		//
	}

    if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
        goto Error;
	}

	CSFile = SipLookupCSFile(
				&CSid,
				&CSFileNtfsId,
				DeviceObject);

	if (NULL == CSFile) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}

	//
	// Indicate that this is a new CS file that's never had a reference
	// to it.  We don't need to take the spin lock because before we write
	// the reparse point no one can know the GUID to get to this CS file, so
	// we're sure we have it exclusively.
	//
	CSFile->Flags |= CSFILE_NEVER_HAD_A_REFERENCE;

    //
    // Make the link files reparse points.
    //

	for (i = 0; i < 2; ++i) {
		PSIS_PER_LINK           perLink;
		BOOLEAN					prepared = FALSE;

		status = SipQueryInformationFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FileStandardInformation,
					sizeof(*standardInfo),
					standardInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		status = SipQueryInformationFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FileInternalInformation,
					sizeof(*internalInfo),
					internalInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Set the file sparse
		//
		status = SipFsControlFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FSCTL_SET_SPARSE,
					NULL,                           // input buffer
					0,                                      // i.b. length
					NULL,                           // output buffer
					0,                                      // o.b. length
					NULL);                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Prepare the refcount change, allocate a new link index and lookup a new perLink.
		//
		status = SipPrepareRefcountChangeAndAllocateNewPerLink(
					CSFile,
					&internalInfo->IndexNumber,
					DeviceObject,
					&linkIndex[i],
					&perLink,
					&prepared);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			
			if (prepared) {
				SipCompleteCSRefcountChange(
						NULL,
						NULL,
						CSFile,
						FALSE,
						TRUE);
			}

			if (NULL != perLink) {
				SipDereferencePerLink(perLink);
				perLink = NULL;
			}

			goto Error;
		}
        //
        // Fill in the reparse point data.
        //
    
        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&CSid,
				&linkIndex[i],
				&CSFileNtfsId,
				&internalInfo->IndexNumber,
				&CSFileChecksum,
				TRUE)) {

			SIS_MARK_POINT();
            status = STATUS_DRIVER_INTERNAL_ERROR;

			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				perLink->CsFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			goto Error;
		}

        //
        // Set the reparse point information.
        //

        status = SipFsControlFile(
					mergeRequest->fileObject[i],
					DeviceObject,
					FSCTL_SET_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
					NULL,				//  Output buffer
					0,					//  Output buffer length
					NULL);				//  returned output buffer length

        if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			//
			// Abort the CS file reference count update.
			//
			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				CSFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			perLink = NULL;

			goto Error;
		}

		//
		// Finish the CS file reference count update.
		//
		status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					CSFile,
					TRUE,
					TRUE);

		SipDereferencePerLink(perLink);

		if (!NT_SUCCESS(status)) {
			//
			// Now what?  We'll probably wind up doing a volume check because of this.
			//
			SIS_MARK_POINT_ULONG(status);
		}

		if (standardInfo->EndOfFile.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {
			//
			// Only zero the file if we're sure that it's $DATA attribute is non-resident.
			// If it's resident, then either we'll convert it to non-resident below, which will
			// generate a paging IO write that will confuse us, or else it will stay resident
			// in which case it will appear to be allocated when we open the file.  If that happens,
			// we want to have the correct data in the file, hence we avoid zeroing it here.
			//

			zeroDataInformation->FileOffset.QuadPart = 0;
			zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

			status = SipFsControlFile(
						mergeRequest->fileObject[i],
						DeviceObject,
						FSCTL_SET_ZERO_DATA,
						zeroDataInformation,
						sizeof(FILE_ZERO_DATA_INFORMATION),
						NULL,                           // output buffer
						0,                                      // o.b. length
						NULL);                          // returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}
		}

		//
		// Reset the times
		//
                        
		status = SipSetInformationFile( 
					mergeRequest->fileObject[i],
					DeviceObject,
					FileBasicInformation,
					sizeof(FILE_BASIC_INFORMATION),
					mergeRequest->basicInfo + i);

		//
		// Just ignore an error on this.
		//
#if             DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			DbgPrint("SIS: SipLinkFiles: set basic info failed\n");
		}
#endif  // DBG

	}	// for each link
#undef  reparseBuffer

Error:

	mergeRequest->status = status;

	if (mergeRequest->posted) {
		//
		// Complete the irp
		//

		mergeRequest->Irp->IoStatus.Status = status;
		mergeRequest->Irp->IoStatus.Information = 0;

		IoCompleteRequest(mergeRequest->Irp, IO_NO_INCREMENT);

		if (NULL != mergeRequest->abortEvent) {
			ObDereferenceObject(mergeRequest->abortEvent);
		}

		for (i = 0; i < 2; ++i) {
			ASSERT(mergeRequest->fileObject[i]);
			ObDereferenceObject(mergeRequest->fileObject[i]);
		}

		ExFreePool(mergeRequest);
	}

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	return;
}


NTSTATUS
SipMergeFiles(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp,
	IN PSIS_LINK_FILES	linkFiles)

/*++

Routine Description:

	Merge two files together.  One of the calls from the FSCTL_LINK_FILES
	fsctl.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the merge files request

Return Value:

    The function value is the status of the operation.  It does not
        complete the irp (unless it returns STATUS_PENDING, in which
		case the irp will be completed asynchronously).

--*/

{
	HANDLE								fileHandle[2];
	PFILE_OBJECT						fileObject[2] = {NULL, NULL};
	HANDLE								abortEventHandle;
	PKEVENT								abortEvent = NULL;
	PIO_STACK_LOCATION					irpSp = IoGetCurrentIrpStackLocation( Irp );
	NTSTATUS							status;
	OBJECT_HANDLE_INFORMATION			handleInformation;
	PDEVICE_EXTENSION					deviceExtension = DeviceObject->DeviceExtension;
	int									i;
	PSIS_PER_FILE_OBJECT				perFO[2];
	PSIS_SCB							scb[2];
	BOOLEAN								fileIsSIS[2];
	LARGE_INTEGER						zero;
	FILE_BASIC_INFORMATION				basicInfo[2];
	FILE_STANDARD_INFORMATION			standardInfo[1];
	FILE_INTERNAL_INFORMATION			internalInfo[1];
	LONGLONG							CSFileChecksum;
	CHAR								reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)
	PSIS_CS_FILE						CSFile = NULL;
	FILE_ZERO_DATA_INFORMATION			zeroDataInformation[1];
	PSIS_MERGE_NORMAL_FILES_REQUEST		mergeRequest = NULL;
	BOOLEAN								prepared = FALSE;

	ASSERT(SIS_LINK_FILES_OP_MERGE == linkFiles->operation);

	fileHandle[0] = linkFiles->u.Merge.file1;
	fileHandle[1] = linkFiles->u.Merge.file2;
	abortEventHandle = linkFiles->u.Merge.abortEvent;

	zero.QuadPart = 0;

	//
	// The abort event handle is optional.  It is the responsibility of the
	// caller to signal the event if it wants this service to abort before it
	// completes.
	//

	if (abortEventHandle) {
		status = ObReferenceObjectByHandle( 
					abortEventHandle,
					EVENT_QUERY_STATE | SYNCHRONIZE,
					NULL,
					UserMode,
					&abortEvent,
					NULL);

		if (!NT_SUCCESS( status )) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Dereference the file handles to pointers to their
	// file objects and see if the two file specifications
	// refer to the same device.
	//

	for (i = 0; i < 2; ++i) {
		status = ObReferenceObjectByHandle( 
					fileHandle[i],
					FILE_READ_DATA,
					*IoFileObjectType,
					UserMode,
					(PVOID *) &fileObject[i],
					&handleInformation );

		if (!NT_SUCCESS( status )) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}
	}

	//
	// Verify that there are no rogue user mapped sections open to the files.
	//
	for (i = 0; i < 2; i++) {
		if ((NULL != fileObject[i]->SectionObjectPointer)
			&& !MmCanFileBeTruncated(fileObject[i]->SectionObjectPointer,&zero)) {

			SIS_MARK_POINT();
			status = STATUS_SHARING_VIOLATION;
			goto Error;
		}
	}

    //
    // Verify that both files are on the same volume.
    //

    if ((IoGetRelatedDeviceObject( fileObject[0] ) !=
         IoGetRelatedDeviceObject( fileObject[1] )) ||
           (IoGetRelatedDeviceObject(fileObject[0]) != 
                IoGetRelatedDeviceObject(irpSp->FileObject))) {

		//
		// The two files refer to different devices, or a different device
		// from the file object on which we were called. Return an appropriate
		// error.
		//

		SIS_MARK_POINT();
		status = STATUS_NOT_SAME_DEVICE;
		goto Error;

	}

	for (i = 0; i < 2; ++i) {
		perFO[i] = NULL;
		fileIsSIS[i] = SipIsFileObjectSIS(fileObject[i],DeviceObject,FindActive,&perFO[i],&scb[i]);

		//
		// Get the file times and sizes so we can reset them after we munge the file,
		// and check the file attributes now.
		//
		status = SipQueryInformationFile(
					fileObject[i],
					DeviceObject,
					FileBasicInformation,
					sizeof(*basicInfo),
					&basicInfo[i],
					NULL);                                  // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}


		if (basicInfo[i].FileAttributes & (FILE_ATTRIBUTE_ENCRYPTED |
                                           FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // We don't touch encrypted files. Reject the call.
            //
            SIS_MARK_POINT();
            status = STATUS_INVALID_PARAMETER_3;
            goto Error;
        }

		if (fileIsSIS[i]) {
			//
			// If it's a SIS file, we don't need to check the stream info because we
			// know it's alright.  However, we do need to verify that it's not dirty.
			//
			if ((scb[i]->PerLink->Flags & SIS_PER_LINK_DIRTY) || (scb[i]->Flags & SIS_SCB_BACKING_FILE_OPENED_DIRTY)) {
				SIS_MARK_POINT_ULONG(scb[i]);
				status = STATUS_SHARING_VIOLATION;
				goto Error;
			}
		} else {

			if (basicInfo[i].FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
				//
				// We can't SISify other reparse points. Reject the call.
				//
				SIS_MARK_POINT();
				status = STATUS_INVALID_PARAMETER;
				goto Error;
			}

			//
			// Query the file to find its link count, and reject the call if it's bigger than
			// one; we can't have hard links to SIS links.
			//
			status = SipQueryInformationFile(
						fileObject[i],
						DeviceObject,
						FileStandardInformation,
						sizeof(*standardInfo),
						standardInfo,
						NULL);                  // returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}

			if (1 != standardInfo->NumberOfLinks) {
				SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);
				status = STATUS_INVALID_PARAMETER;
				goto Error;
			}

			//
			// If the file is sparse and has unallocated regions, reject it.
			//
			if (basicInfo[i].FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
				FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
				FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
				ULONG							returnedLength;

				inArb->FileOffset.QuadPart = 0;
				inArb->Length.QuadPart = MAXLONGLONG;

				status = SipFsControlFile(
							fileObject[i],
							DeviceObject,
							FSCTL_QUERY_ALLOCATED_RANGES,
							inArb,
							sizeof(FILE_ALLOCATED_RANGE_BUFFER),
							outArb,
							sizeof(FILE_ALLOCATED_RANGE_BUFFER),
							&returnedLength);

				if ((returnedLength == 0) 
					|| (outArb->FileOffset.QuadPart != 0) 
					|| (outArb->Length.QuadPart < standardInfo->EndOfFile.QuadPart)) {

					//
					// It's not fully allocated.  Disallow the copy.
					//
					status = STATUS_OBJECT_TYPE_MISMATCH;
					SIS_MARK_POINT();
					goto Error;
				}
			}
		}	// else the file isn't a SIS link
	}	// for each file

    //
    // If neither file is a SIS link, then copy file1
    // into the common store and create links to it.
    //

    if (!fileIsSIS[0] && !fileIsSIS[1]) {
		mergeRequest = ExAllocatePoolWithTag(PagedPool, sizeof(SIS_MERGE_NORMAL_FILES_REQUEST), ' siS');

		if (NULL == mergeRequest) {
			SIS_MARK_POINT();
			status = STATUS_INSUFFICIENT_RESOURCES;

			goto Error;
		}

		mergeRequest->posted = !IoIsOperationSynchronous(Irp);

		RtlCopyMemory(mergeRequest->basicInfo,basicInfo,sizeof(FILE_BASIC_INFORMATION) * 2);

		for (i = 0; i < 2; i++) {
			mergeRequest->fileObject[i] = fileObject[i];
			if (mergeRequest->posted) {
				mergeRequest->fileHandle[i] = NULL;
			} else {
				mergeRequest->fileHandle[i] = fileHandle[i];
			}
		}
		mergeRequest->Irp = Irp;
		mergeRequest->deviceExtension = deviceExtension;
		mergeRequest->abortEvent = abortEvent;

		if (mergeRequest->posted) {
			//
			// Post the request to a worker thread and return STATUS_PENDING.
			//

			SIS_MARK_POINT_ULONG(mergeRequest);

			IoMarkIrpPending(Irp);

			ExInitializeWorkItem(
				mergeRequest->workQueueItem,
				SipMergeNormalFilesWork,
				mergeRequest);

			ExQueueWorkItem(
				mergeRequest->workQueueItem,
				DelayedWorkQueue);

			//
			// NULL out our local copies of things whose references we have handed off
			// to the fsp.  This is just to make sure that we don't touch them again,
			// because they can go away at any time, whenever the thread gets around to
			// it.
			//
			Irp = NULL;
			abortEvent = NULL;
			for (i = 0; i < 2; i++) {
				fileObject[i] = NULL;
			}
			mergeRequest = NULL;

			status = STATUS_PENDING;
                        
		} else {
			//
			// We can block, so do the work locally.
			//

			SipMergeNormalFilesWork(mergeRequest);

			status = mergeRequest->status;
		}

	} else if (fileIsSIS[0] && fileIsSIS[1]) {

        //
        // This is relinking from one CS file to another. Unlink it from CsFile1
        // and link it to CsFile0.
        //
        SIS_MARK_POINT_ULONG(scb[1]);

        status = SipRelinkFile(scb[1], fileObject[1], scb[0]->PerLink->CsFile);

        ASSERT(STATUS_PENDING != status);       // this would mess up the Exit code below

    } else {

    	// NTRAID#65191-2000/05/23-nealch  When a partial SIS file is detected, convert it to a non-sis file.
		//
		// One file is a SIS file and the other is not.
		//

        PSIS_CS_FILE            csFile;
        LINK_INDEX              linkIndex;
        HANDLE                  linkHandle;
        PFILE_OBJECT            linkFileObject;
        PSIS_PER_LINK           perLink;        // for the non-link file
        PFILE_BASIC_INFORMATION linkBasicInfo;

        if (fileIsSIS[0]) {

            //
            // File0 is a SIS link, file1 is not.
            //

            csFile = scb[0]->PerLink->CsFile;
            linkHandle = fileHandle[1];
                        linkFileObject = fileObject[1];
            linkBasicInfo = &basicInfo[1];

        } else {

            ASSERT(fileIsSIS[1]);

            //
            // File1 is a SIS link, file0 is not.
            //

            csFile = scb[1]->PerLink->CsFile;
            linkHandle = fileHandle[0];
                        linkFileObject = fileObject[0];
            linkBasicInfo = &basicInfo[0];

        }

		//
		// Make sure the CS file is open so that we know its index and checksum.
		//
		status = SipAssureCSFileOpen(csFile);
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		CSFileChecksum = csFile->Checksum;

		status = SipQueryInformationFile(
					linkFileObject,
					DeviceObject,
					FileInternalInformation,
					sizeof(*internalInfo),
					internalInfo,
					NULL);                                          // returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			goto Error;
		}

		//
		// Set the file sparse
		//
		status = SipFsControlFile(
					linkFileObject,
					DeviceObject,
					FSCTL_SET_SPARSE,
					NULL,				// input buffer
					0,					// i.b. length
					NULL,				// output buffer
					0,					// o.b. length
					NULL);				// returned length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT();
			goto Error;
		}

        //
        // Make the non-link file a reparse point.
        //

		//
		// Prepare a refcount change, allocate a new link index and look up a new perLink.
		//
		status = SipPrepareRefcountChangeAndAllocateNewPerLink(
					csFile,
					&internalInfo->IndexNumber,
					DeviceObject,
					&linkIndex,
					&perLink,
					&prepared);

		if (!NT_SUCCESS(status)) {
			if (prepared) {
				SipCompleteCSRefcountChange(
					NULL,
					NULL,
					csFile,
					FALSE,
					TRUE);

				prepared = FALSE;
			}

			if (NULL != perLink) {
				SipDereferencePerLink(perLink);
				perLink = NULL;
			}

			goto Error;
		}

        reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

        if (!SipIndicesIntoReparseBuffer(
				reparseBuffer,
				&csFile->CSid,
				&linkIndex,
				&csFile->CSFileNtfsId,
				&internalInfo->IndexNumber,
				&CSFileChecksum,
				TRUE)) {

			SIS_MARK_POINT();
			status = STATUS_DRIVER_INTERNAL_ERROR;
			goto Error;
        }

        //
        // Set the reparse point information.
        //

		status = SipFsControlFile(
					linkFileObject,
					DeviceObject,
					FSCTL_SET_REPARSE_POINT,
					reparseBuffer,
					FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
					NULL,				//  Output buffer
					0,					//  Output buffer length
					NULL);				//  returned output buffer length

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);

			//
			// Abort the refcount update.
			//
			SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				csFile,
				FALSE,
				TRUE);

			SipDereferencePerLink(perLink);
			perLink = NULL;

			goto Error;
		}

		//
		// Complete the refcount update.
		//
		status = SipCompleteCSRefcountChange(
					perLink,
					&perLink->Index,
					perLink->CsFile,
					TRUE,
					TRUE);

		SipDereferencePerLink(perLink);
		perLink = NULL;

		if (!NT_SUCCESS(status)) {
			//
			// Now what?
			//
			SIS_MARK_POINT_ULONG(status);
		}

		if (csFile->FileSize.QuadPart >= deviceExtension->FilesystemBytesPerFileRecordSegment.QuadPart) {

			//
			// Zero the file, which will both deallocate its space, and also force its ValidDataLength to
			// end of file.
			//
			zeroDataInformation->FileOffset.QuadPart = 0;
			zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

			status = SipFsControlFile(
						linkFileObject,
						DeviceObject,
						FSCTL_SET_ZERO_DATA,
						zeroDataInformation,
						sizeof(FILE_ZERO_DATA_INFORMATION),
						NULL,					// output buffer
						0,						// o.b. length
						NULL);					// returned length

			if (!NT_SUCCESS(status)) {
				SIS_MARK_POINT_ULONG(status);
				goto Error;
			}
		}

		//
		// Reset the times
		//
                        
		status = SipSetInformationFile( 
					linkFileObject,
					DeviceObject,
					FileBasicInformation,
					sizeof(FILE_BASIC_INFORMATION),
					linkBasicInfo);

		//
		// Just ignore an error on this.
		//
#if             DBG
		if (!NT_SUCCESS(status)) {
			DbgPrint("SIS: SipLinkFiles: set basic info failed\n");
		}
#endif  // DBG
	}	// else one is SIS and one isn't

//Exit:
Error:

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	if (STATUS_PENDING != status) {

		if (abortEvent) {
			ObDereferenceObject(abortEvent);
		}

		for (i = 0; i < 2; ++i) {
			if (fileObject[i]) {
				ObDereferenceObject(fileObject[i]);
			}
		}

		if (NULL != mergeRequest) {
			ExFreePool(mergeRequest);
		}
	}

	return status;
#undef  reparseBuffer
}

NTSTATUS
SipVerifyNoMap(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp,
	IN PSIS_LINK_FILES	linkFiles)
/*++

Routine Description:

	Check out a file to see if there is a mapped section to it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the verify_no_map request

Return Value:

	STATUS_SUCCESS if the file has no mapped section.

	STATUS_SHARING_VIOLATION if it has one.

	Another error status if the handle is bogus, etc.

--*/

{
	PFILE_OBJECT	fileObject = NULL;
	NTSTATUS		status;
	LARGE_INTEGER	zero;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

	ASSERT(SIS_LINK_FILES_OP_VERIFY_NO_MAP == linkFiles->operation);

	status = ObReferenceObjectByHandle(
				linkFiles->u.VerifyNoMap.file,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				&fileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	zero.QuadPart = 0;

	if ((NULL != fileObject->SectionObjectPointer) 
		&& MmCanFileBeTruncated(fileObject->SectionObjectPointer, &zero)) {

		status = STATUS_SUCCESS;
	} else {
		status = STATUS_SHARING_VIOLATION;
	}

done:
        
	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
	}

	return status;
}


NTSTATUS
SipMergeFileWithCSFile(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PSIS_LINK_FILES		linkFiles)
/*++

Routine Description:

	Merge a file into a common store file given the CSID of the common store file.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

	linkFiles - the merge_with_cs request

Return Value:

	status of the operation.

--*/
{
	PFILE_OBJECT				fileObject = NULL;
	NTSTATUS					status;
	PSIS_CS_FILE				CSFile = NULL;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_SCB					scb;
	PSIS_PER_LINK				perLink = NULL;
	LINK_INDEX					linkIndex;
	FILE_BASIC_INFORMATION		basicInfo[1];
	FILE_INTERNAL_INFORMATION	internalInfo[1];
	FILE_STANDARD_INFORMATION	standardInfo[1];
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN						prepared = FALSE;
	BOOLEAN						isSis;
	FILE_ZERO_DATA_INFORMATION	zeroDataInformation[1];
	CHAR						reparseBufferBuffer[SIS_REPARSE_DATA_SIZE];
#define reparseBuffer ((PREPARSE_DATA_BUFFER)reparseBufferBuffer)

	ASSERT(SIS_LINK_FILES_OP_MERGE_CS == linkFiles->operation);

	status = ObReferenceObjectByHandle(
				linkFiles->u.MergeWithCS.file1,
				FILE_READ_DATA,
				*IoFileObjectType,
				UserMode,
				&fileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (IoGetRelatedDeviceObject(fileObject) != 
		IoGetRelatedDeviceObject(irpSp->FileObject)) {

		SIS_MARK_POINT();
		status = STATUS_NOT_SAME_DEVICE;

		goto done;
	}

	isSis = SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb);

	if (isSis && (IsEqualGUID(&scb->PerLink->CsFile->CSid, &linkFiles->u.MergeWithCS.CSid))) {
		//
		// We're linking to the CS file that already backs this link file.
		// Declare victory.
		//
		SIS_MARK_POINT_ULONG(CSFile);

		status = STATUS_SUCCESS;
		goto done;
	}

	//
	// Get at the CS file.
	//
	CSFile = SipLookupCSFile(
				&linkFiles->u.MergeWithCS.CSid,
				NULL,
				DeviceObject);

	if (NULL == CSFile) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	status = SipAssureCSFileOpen(CSFile);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		goto done;
	}

	if (isSis) {
		//
		// This is relinking from one CS file to another.
		//
		SIS_MARK_POINT_ULONG(scb);

		status = SipRelinkFile(scb, fileObject, CSFile);

        goto done;
    }

	//
	// It's a normal file.  Relink it.  First query its info.
	//
	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileBasicInformation,
				sizeof(FILE_BASIC_INFORMATION),
				basicInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipQueryInformationFile(
				fileObject,
				DeviceObject,
				FileStandardInformation,
				sizeof(FILE_STANDARD_INFORMATION),
				standardInfo,
				NULL);							// returned length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	//
	// Don't merge files with hard links.
	//
	if (1 != standardInfo->NumberOfLinks) {
		SIS_MARK_POINT_ULONG(standardInfo->NumberOfLinks);

		status = STATUS_INVALID_PARAMETER;
		goto done;
	}

	//
	// Don't merge non-SIS link files with unallocated sparse regions.
	//
	if (basicInfo->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
		FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
		FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
		ULONG							returnedLength;

		inArb->FileOffset.QuadPart = 0;
		inArb->Length.QuadPart = MAXLONGLONG;

		status = SipFsControlFile(
					fileObject,
					DeviceObject,
					FSCTL_QUERY_ALLOCATED_RANGES,
					inArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					outArb,
					sizeof(FILE_ALLOCATED_RANGE_BUFFER),
					&returnedLength);

		if ((returnedLength == 0) 
			|| (outArb->FileOffset.QuadPart != 0) 
			|| (outArb->Length.QuadPart < standardInfo->EndOfFile.QuadPart)) {

			//
			// It's not fully allocated.  Disallow the copy.
			//
			status = STATUS_OBJECT_TYPE_MISMATCH;
			SIS_MARK_POINT();
			goto done;
		}
	}
	

	status = SipPrepareRefcountChangeAndAllocateNewPerLink(
				CSFile,
				&internalInfo->IndexNumber,
				DeviceObject,
				&linkIndex,
				&perLink,
				&prepared);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

    //
    // Fill in the reparse point data.
    //

    reparseBuffer->ReparseDataLength = SIS_MAX_REPARSE_DATA_VALUE_LENGTH;

    if (!SipIndicesIntoReparseBuffer(
			reparseBuffer,
			&CSFile->CSid,
			&linkIndex,
			&CSFile->CSFileNtfsId,
			&internalInfo->IndexNumber,
			&CSFile->Checksum,
			TRUE)) {

		SIS_MARK_POINT();
                        
        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto done;

    }

	//
	// Set the reparse point information and increment the CS file refcount.
	// This needs to proceed using the prepare/act/finish protocol for updating
	// the reference count.  Note that we do this before zeroing the file
	// so as not to lose the contents in the event of a failure later on.
	//

    status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_REPARSE_POINT,
				reparseBuffer,
				FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + reparseBuffer->ReparseDataLength,
				NULL,				//  Output buffer
				0,					//  Output buffer length
				NULL);				//  returned output buffer length

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	status = SipCompleteCSRefcountChange(
				perLink,
				&perLink->Index,
				CSFile,
				TRUE,
				TRUE);

	if (!NT_SUCCESS(status)) {
		//
		// We're probably headed for a volume check here.  Ignore it for now.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: complete refcount change failed 0x%x\n",status);
#endif  // DBG
	}

	prepared = FALSE;

	//
	// Set the file sparse, and zero it.
	//

	status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_SPARSE,
				NULL,				// input buffer
				0,					// i.b. length
				NULL,				// output buffer
				0,					// o.b. length
				NULL);				// returned o.b. length

	if (!NT_SUCCESS(status)) {
		//
		// If we can't set the file sparse, we'll leave it as a totally dirty
		// SIS file.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: unable to set sparse, 0x%x\n",status);
#endif  // DBG

		status = STATUS_SUCCESS;
		goto done;
	}

	zeroDataInformation->FileOffset.QuadPart = 0;
	zeroDataInformation->BeyondFinalZero.QuadPart = MAXLONGLONG;

	status = SipFsControlFile(
				fileObject,
				DeviceObject,
				FSCTL_SET_ZERO_DATA,
				zeroDataInformation,
				sizeof(*zeroDataInformation),
				NULL,							// output buffer
				0,								// o.b. length
				NULL);							// returned o.b. length

    if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		//
		// Just ignore this error and reset the times anyway.
		//
		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: zero data failed, 0x%x\n",status);
#endif  // DBG
	}

	//
	// Reset the file times that are contained in the basic information.
	//

	status = SipSetInformationFile(
				fileObject,
				DeviceObject,
				FileBasicInformation,
				sizeof(FILE_BASIC_INFORMATION),
				basicInfo);

	if (!NT_SUCCESS(status)) {
		//
		// Just ignore this one, too.
		//

		SIS_MARK_POINT_ULONG(status);

#if             DBG
		DbgPrint("SIS: SipMergeFileWithCSFile: unable to reset basic info, 0x%x\n",status);
#endif  // DBG
	}

	status = STATUS_SUCCESS;

done:

	if (NULL != fileObject) {
		ObDereferenceObject(fileObject);
	}

	if (NULL != CSFile) {
		SipDereferenceCSFile(CSFile);
	}

	if (prepared) {
		ASSERT(!NT_SUCCESS(status));

		SipCompleteCSRefcountChange(NULL,NULL,CSFile,FALSE,TRUE);
	}

	if (NULL != perLink) {
		SipDereferencePerLink(perLink);
	}

	return status;

#undef  reparseBuffer
}

NTSTATUS
SipLinkFiles(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp)
/*++

Routine Description:

	This fsctrl function is the generic groveler interface to the filter
	driver.  It currently provides four functions: merge two files together,
	merge a file into a common store file, a hint from the groveler that
	all references to a given common store file are gone, and a request
	to verify that there are no mapped segments to a file.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;
	PSIS_LINK_FILES			linkFiles;
	NTSTATUS				status;
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN					grovelerFileHeld = FALSE;

	if (!SipCheckPhase2(deviceExtension)) {
		//
		// SIS couldn't initialize.  This probably isn't a SIS-enabled volume, so punt
		// the request.
		//

		SIS_MARK_POINT();

		status = STATUS_INVALID_DEVICE_REQUEST;
		goto done;

	}

	//
	// Make sure the MaxIndex file is already open.  We need to do this
	// to prevent a deadlock if someone perversely wants to do a link
	// with the MaxIndex file itself as the source.  We could probably
	// trust the groveler not to do this, but better safe than sorry.
	//
	status = SipAssureMaxIndexFileOpen(deviceExtension);

	if (!NT_SUCCESS(status)) {

		SIS_MARK_POINT_ULONG(status);

		goto done;

	}

	linkFiles = (PSIS_LINK_FILES)Irp->AssociatedIrp.SystemBuffer;

	if ((NULL == linkFiles)
		|| (irpSp->Parameters.FileSystemControl.InputBufferLength != sizeof(SIS_LINK_FILES))
		|| (irpSp->Parameters.FileSystemControl.OutputBufferLength  != 0)) {

		SIS_MARK_POINT();

		status = STATUS_INVALID_PARAMETER_1;
		goto done;
	}

	//
	// Check to be sure that this file is the GrovelerFile.
	//
	KeEnterCriticalRegion();
	ExAcquireResourceSharedLite(deviceExtension->GrovelerFileObjectResource, TRUE);
	grovelerFileHeld = TRUE;

	if (NULL == deviceExtension->GrovelerFileObject) {
		//
		// If we don't have a GrovelerFileObject, we were unable to
		// open or reference the GrovelerFile when Stage2 ran.  In this
		// case, link files is unavailable until reboot.
		//

		SIS_MARK_POINT();
		status = STATUS_DRIVER_INTERNAL_ERROR;
		goto done;
	}

	if (((NULL == irpSp->FileObject) 
		|| (irpSp->FileObject->FsContext != deviceExtension->GrovelerFileObject->FsContext))
#if             DBG
		&& !(BJBDebug & 0x00400000)
#endif  // DBG
		) {

		//
		// The user didn't use a handle to the right file for this.  Fail the call.
		//
		status = STATUS_ACCESS_DENIED;
		goto done;
	}

	ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
	KeLeaveCriticalRegion();
	grovelerFileHeld = FALSE;

	switch (linkFiles->operation) {

		case SIS_LINK_FILES_OP_MERGE:
			status = SipMergeFiles(DeviceObject, Irp, linkFiles);
			break;

		case SIS_LINK_FILES_OP_MERGE_CS:
			status = SipMergeFileWithCSFile(DeviceObject, Irp, linkFiles);
			break;

#if             0       // Not yet implemented
		case SIS_LINK_FILES_OP_HINT_NO_REFS:
			status = SipHintNoRefs(DeviceObject, Irp, linkFiles);
			status = STATUS_NOT_IMPLEMENTED;
			break;
#endif  // 0

		case SIS_LINK_FILES_OP_VERIFY_NO_MAP:
			status = SipVerifyNoMap(DeviceObject, Irp, linkFiles);
			break;

		case SIS_LINK_FILES_CHECK_VOLUME:
			status = SipCheckVolume(deviceExtension);
			break;

		default: 
			SIS_MARK_POINT();
			status = STATUS_INVALID_PARAMETER_2;
			break;
	}

done:
	if (grovelerFileHeld) {
		ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
		grovelerFileHeld = FALSE;
		KeLeaveCriticalRegion();
	}

	if (STATUS_PENDING != status) {
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sifastio.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    sifastio.c

Abstract:

	Fast IO routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:

--*/

#include "sip.h"

BOOLEAN scEnableFastIo = FALSE;

//
//  Macro to test if FASI_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))


//
//  Pragma definitions
//

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SiFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SiFastIoRead)
#pragma alloc_text(PAGE, SiFastIoLock)
#pragma alloc_text(PAGE, SiFastIoUnlockSingle)
#pragma alloc_text(PAGE, SiFastIoUnlockAll)
#pragma alloc_text(PAGE, SiFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SiFastIoDeviceControl)
#pragma alloc_text(PAGE, SiFastIoDetachDevice)
#pragma alloc_text(PAGE, SiFastIoMdlRead)
#pragma alloc_text(PAGE, SiFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SiFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, SiFastIoReadCompressed)
#pragma alloc_text(PAGE, SiFastIoWriteCompressed)
#pragma alloc_text(PAGE, SiFastIoQueryOpen)
#endif	// ALLOC_PRAGMA



BOOLEAN
SiFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {
            PSIS_PER_FILE_OBJECT        perFO;
            PSIS_SCB                    scb;
	        PFILE_OBJECT				FileObjectForNTFS;
	        BOOLEAN						UpdateCurrentByteOffset;
	        BOOLEAN						worked;
		    SIS_RANGE_DIRTY_STATE		dirtyState;

            //
            //  See if this is an SIS'd file
            //

	        if (SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                //
                //  For now this is always FALSE so we are never doing this path
                //

		        if (!scEnableFastIo) {

			        return FALSE;
		        }

		        SIS_MARK_POINT_ULONG(scb);

                //
                // SipGetRangeDirty can block.
                //

		        if (Wait) {

		            return FALSE;
		        }

		        SipAcquireScb(scb);

		        //
		        // This is a synchronous user cached read, and we don't have to check for
		        // locks or oplocks.  Figure out which file object to send it down on and
		        // then forward the request to NTFS.  
		        //

		        dirtyState = SipGetRangeDirty(
						        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
						        scb,
						        FileOffset,
						        Length,
						        TRUE);			// FaultedIsDirty

		        //
		        //  We never have to update the faulted ranges on this call,
		        //  because this isn't a pagingIO read, so it won't put stuff
		        //  into the faulted area.  On the other hand, this can
		        //  generate a page fault, which will in turn put something into
		        //  the faulted area, but that gets handled by the mainline
		        //  SipCommonRead code.
		        //

		        SipReleaseScb(scb);

		        if (dirtyState == Mixed) {
			        //
			        // Take the slow path.
			        //

			        return FALSE;
		        }

		        if (dirtyState == Dirty) {
			        //
			        // The range is dirty, so we want to go to the copied file, which
			        // is the file we're called with.
			        //

			        FileObjectForNTFS = FileObject;
			        UpdateCurrentByteOffset = FALSE;

		        } else {
			        //
			        // The range is clean, so we want to go to the CS file.  Switch it
			        // here.
			        //
			
			        FileObjectForNTFS = scb->PerLink->CsFile->UnderlyingFileObject;
			        UpdateCurrentByteOffset = TRUE;
		        }

		        worked = (fastIoDispatch->FastIoRead)(
		                        FileObjectForNTFS,
                                FileOffset,
                                Length,
                                Wait,
                                LockKey,
                                Buffer,
                                IoStatus,
                                nextDeviceObject);

		        if (worked 
			        && UpdateCurrentByteOffset
			        && (IoStatus->Status == STATUS_SUCCESS ||
				        IoStatus->Status == STATUS_BUFFER_OVERFLOW ||
				        IoStatus->Status == STATUS_END_OF_FILE)) {
			        //
			        // The fast read worked, and we revectored it to a different
			        // file object, so we need to update the CurrentByteOffset.
			        //

			        FileObject->CurrentByteOffset.QuadPart = 
				        FileOffset->QuadPart + IoStatus->Information;
		        }

		        SIS_MARK_POINT_ULONG(scb);

                return worked;

	        } else {

                return (fastIoDispatch->FastIoRead)(
                            FileObject,
                            FileOffset,
                            Length,
                            Wait,
                            LockKey,
                            Buffer,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB				scb;
	        KIRQL					OldIrql;

            //
            //  See if this is an SIS'd file
            //

	        if (SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                //
                //  For now this is always FALSE so we are never doing this path
                //

                if (!scEnableFastIo) {

                    return FALSE;
                }
        
                SIS_MARK_POINT_ULONG(scb);

                //
                // SipAddRangeToFaultedList may block.
                //
		        if (Wait) {

                    return FALSE;
		        }

		        //
		        // Send the write down to the underlying filesystem.  We always
		        // send it on the same file object we got, because writes always
		        // go to the copied file, not the common store file.
		        //

		        SIS_MARK_POINT();

		        if (!(fastIoDispatch->FastIoWrite)(
					        FileObject,
					        FileOffset,
					        Length,
					        Wait,
					        LockKey,
					        Buffer,
					        IoStatus,
					        nextDeviceObject)) {

			        SIS_MARK_POINT();

#if DBG
                    DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_ERROR_LEVEL,
                                "SIS: SiFastIoWrite failed, %#x\n", IoStatus->Status);
#endif
			        //
			        // It didn't work, so the call to us also didn't work.
			        //

			        return FALSE;
		        }

		        SIS_MARK_POINT();

		        //
		        // We need to update the written range to include the newly written area.
		        //

		        SipAcquireScb(scb);

		        SipAddRangeToFaultedList(
				        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
				        scb,
				        FileOffset,
				        IoStatus->Information);

		        SipReleaseScb(scb);

		        KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
		        scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
		        KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

		        return TRUE;

	        } else {

                return (fastIoDispatch->FastIoWrite)(
                            FileObject,
                            FileOffset,
                            Length,
                            Wait,
                            LockKey,
                            Buffer,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {
        	PSIS_PER_FILE_OBJECT		perFO;
        	PSIS_SCB					scb;
	        BOOLEAN                     fixItUp = FALSE;
	        KIRQL                       OldIrql;

	        if (SipIsFileObjectSIS(FileObject, DeviceObject, FindActive, &perFO, &scb)) {

		        KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

			    //
			    // It's a SIS file and it wasn't opened as a reparse point, 
			    // we need to fix up the result.
			    //

		        fixItUp = (!(perFO->Flags & SIS_PER_FO_OPEN_REPARSE));

		        KeReleaseSpinLock(perFO->SpinLock, OldIrql);
	        }

            //
            //  Make the call, return if it failed
            //

            if (!(fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject )) {

		        return FALSE;
	        }

            //
            //  It was successful, remove the REPARSE and SPARSE information
            //

	        if (fixItUp) {

		        ASSERT(NULL != Buffer);
		        Buffer->FileAttributes &= ~(FILE_ATTRIBUTE_REPARSE_POINT|FILE_ATTRIBUTE_SPARSE_FILE);

		        if (0 == Buffer->FileAttributes) {

			        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
		        }
	        }

            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					worked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if (!GCHEnableFastIo && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoLock)(
                                    FileObject,
                                    FileOffset,
                                    Length,
                                    ProcessId,
                                    Key,
                                    FailImmediately,
                                    ExclusiveLock,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        SipAcquireScb(scb);

	        //
	        //  Now call the FsRtl routine to do the actual processing of the
	        //  Lock request
	        //
	        worked = FsRtlFastLock(&scb->FileLock,
					          FileObject,
					          FileOffset,
					          Length,
					          ProcessId,
					          Key,
					          FailImmediately,
					          ExclusiveLock,
					          IoStatus,
					          NULL,
					          FALSE);

	        SipReleaseScb(scb);

	        return worked;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if ((!GCHEnableFastIo) && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoUnlockSingle)(
                                    FileObject,
                                    FileOffset,
                                    Length,
                                    ProcessId,
                                    Key,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);
	
	        SipAcquireScb(scb);

	        //
            //  Now call the FsRtl routine to do the actual processing of the
            //  Lock request.  The call will always succeed.
	        //

	        IoStatus->Information = 0;
            IoStatus->Status = FsRtlFastUnlockSingle(&scb->FileLock,
											         FileObject,
											         FileOffset,
											         Length,
											         ProcessId,
											         Key,
											         NULL,
											         FALSE);

	        SipReleaseScb(scb);

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {
	            PSIS_PER_FILE_OBJECT	perFO;
	            PSIS_SCB 				scb;
	            BOOLEAN					calldownWorked;
	            BOOLEAN					isSISFile;

	            isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	            if ((!GCHEnableFastIo) && isSISFile) {

		            return FALSE;
	            }

                calldownWorked = (fastIoDispatch->FastIoUnlockAll)(
                                        FileObject,
                                        ProcessId,
                                        IoStatus,
                                        nextDeviceObject );

	            if (!calldownWorked || !isSISFile) {

		            return calldownWorked;
	            }

	            SIS_MARK_POINT_ULONG(scb);

	            //		
	            //  Acquire exclusive access to the scb this operation can always wait
	            //

	            SipAcquireScb(scb);

                //  Now call the FsRtl routine to do the actual processing of the
                //  Lock request.  The call will always succeed.

                IoStatus->Status = FsRtlFastUnlockAll(&scb->FileLock,
										              FileObject,
										              ProcessId,
										              NULL);
		
	            SipReleaseScb(scb);

	            return TRUE;
            }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB 				scb;
	        BOOLEAN					calldownWorked;
	        BOOLEAN					isSISFile;

	        isSISFile = SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb);

	        if ((!GCHEnableFastIo) && isSISFile) {

		        return FALSE;
	        }

            calldownWorked = (fastIoDispatch->FastIoUnlockAllByKey)(
                                    FileObject,
                                    ProcessId,
                                    Key,
                                    IoStatus,
                                    nextDeviceObject );

	        if (!calldownWorked || !isSISFile) {

		        return calldownWorked;
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        //
	        //  Acquire exclusive access to the scb this operation can always wait
	        //

	        SipAcquireScb(scb);

            //  Now call the FsRtl routine to do the actual processing of the
            //  Lock request.  The call will always succeed.

            IoStatus->Status = FsRtlFastUnlockAllByKey(&scb->FileLock,
											           FileObject,
											           ProcessId,
											           Key,
											           NULL);

	        SipReleaseScb(scb);

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->FastIoDeviceControl)(
                            FileObject,
                            Wait,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            IoControlCode,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


VOID
SiFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    //
    //  Display name information
    //

#if DBG 
    {
        PDEVICE_EXTENSION devExt = SourceDevice->DeviceExtension;

        SipCacheDeviceName( SourceDevice );
        DbgPrintEx( DPFLTR_SIS_ID, DPFLTR_VOLNAME_TRACE_LEVEL,
                    "SIS: Detaching from volume          \"%wZ\"\n",
                    &devExt->Name );
    }
#endif

    //
    //  Detach from the file system's volume device object.
    //

    IoDetachDevice( TargetDevice );
    SipCleanupDeviceExtension( SourceDevice );
    IoDeleteDevice( SourceDevice );
}


BOOLEAN
SiFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {
	        PSIS_PER_FILE_OBJECT		perFO;
	        PSIS_SCB					scb;
	        BOOLEAN						fixItUp = FALSE;
	        KIRQL						OldIrql;

	        if (SipIsFileObjectSIS(FileObject, DeviceObject, FindActive, &perFO, &scb)) {

		        KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

			    //
			    // It's a SIS file and it wasn't opened as a reparse point, we need to fix up
			    // the result.
			    //

		        fixItUp = (!(perFO->Flags & SIS_PER_FO_OPEN_REPARSE));

		        KeReleaseSpinLock(perFO->SpinLock, OldIrql);
	        }

            if (!(fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject )) {

                return FALSE;   // The fastIO failed, so pass the failure up.
            }

            //
            //  It was successful, remove the REPARSE and SPARSE information
            //

	        if (fixItUp) {

		        ASSERT(NULL != Buffer);
		        Buffer->FileAttributes &= ~(FILE_ATTRIBUTE_REPARSE_POINT|FILE_ATTRIBUTE_SPARSE_FILE);

		        if (0 == Buffer->FileAttributes) {

			        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
		        }
	        }

	        return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {
	        PSIS_PER_FILE_OBJECT	perFO;
	        PSIS_SCB				scb;
	        SIS_RANGE_DIRTY_STATE	dirtyState;

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {
                return (fastIoDispatch->MdlRead)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        if (!GCHEnableFastIo) {

		        return FALSE;
	        }

	        SipAcquireScb(scb);

	        dirtyState = SipGetRangeDirty(
					        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					        scb,
					        FileOffset,
					        Length,
					        TRUE);			// FaultedIsDirty

	        SipReleaseScb(scb);

	        if (dirtyState == Clean) {

                return (fastIoDispatch->MdlRead)(
                            scb->PerLink->CsFile->UnderlyingFileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {
	        PSIS_PER_FILE_OBJECT	perFO;
            PSIS_SCB                scb;

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,&perFO,&scb)) {

                return (fastIoDispatch->MdlReadComplete)(
                            FileObject,
                            MdlChain,
                            nextDeviceObject );
	        }

	        SIS_MARK_POINT_ULONG(scb);

	        if (!GCHEnableFastIo) {

		        return FALSE;
	        }

            return (fastIoDispatch->MdlReadComplete)(
                        scb->PerLink->CsFile->UnderlyingFileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->PrepareMdlWrite)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            MdlChain,
                            IoStatus,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->MdlWriteComplete)(
                            FileObject,
                            FileOffset,
                            MdlChain,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast Io routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


BOOLEAN
SiFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

	        if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {

                return (fastIoDispatch->FastIoReadCompressed)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            Buffer,
                            MdlChain,
                            IoStatus,
                            CompressedDataInfo,
                            CompressedDataInfoLength,
                            nextDeviceObject );
	        }

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

        	if (!SipIsFileObjectSIS(FileObject,DeviceObject,FindActive,NULL,NULL)) {
                return (fastIoDispatch->FastIoWriteCompressed)(
                            FileObject,
                            FileOffset,
                            Length,
                            LockKey,
                            Buffer,
                            MdlChain,
                            IoStatus,
                            CompressedDataInfo,
                            CompressedDataInfoLength,
                            nextDeviceObject );
        	}

	        // 
	        // Not supported on SIS files for now.
	        //
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SiFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
            return result;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siinfo.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siinfo.c

Abstract:

	Set/Query info routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

//
// The parameters for a SipRenameOverCheck call.
//
// 

typedef struct _SIS_CHECK_OVERWRITE_REQUEST {

	//
	// The WORK_QUEUE_ITEM needed to get the request posted.
	//
	WORK_QUEUE_ITEM					workItem[1];

	//
	// An event to set to signify completion
	//
	KEVENT							event[1];

	//
	// The per link for the target file.
	//
	PSIS_PER_LINK					perLink;

	//
	// The file ID for the target file.
	//
	PFILE_INTERNAL_INFORMATION		internalInfo;

	//
	// The DeviceObject on which we were called.
	//
	PDEVICE_OBJECT					DeviceObject;

	//
	// The thread that called SipPrepareCSRefcountChange
	//
	ERESOURCE_THREAD				thread;

} SIS_CHECK_OVERWRITE_REQUEST, *PSIS_CHECK_OVERWRITE_REQUEST;

VOID
SipRenameOverCheck(
	PVOID					parameter)
/*++

Routine Description:

	Someone did a replace-if-exists NtSetInformationFile call, the target was
	a SIS link, and NTFS completed the request successfully.  The caller posted
	to a worker thread to make the final determination if the file is really
	gone, and this function is the worker routine that makes that check.

	We open the target SIS file by ID, and if it's still there we check to see
	if it's still the same SIS file.  If it is, we abort the refcount update,
	otherwise we complete it.

Arguments:

	parameter	- a PSIS_CHECK_OVERWRITE_REQUEST.  See the structure definition for
					a description of the fields.

Return Value:

	void

--*/
{
	PSIS_CHECK_OVERWRITE_REQUEST	checkRequest = parameter;
	PDEVICE_OBJECT					DeviceObject = checkRequest->DeviceObject;
	PDEVICE_EXTENSION				deviceExtension = DeviceObject->DeviceExtension;
	IO_STATUS_BLOCK					Iosb[1];
	NTSTATUS						status;
	OBJECT_ATTRIBUTES				Obja[1];
	UNICODE_STRING					fileIdString[1];
	HANDLE							dstFileHandle = NULL;
	PFILE_OBJECT					dstFileObject = NULL;
	BOOLEAN							fileGone = FALSE;
	PSIS_PER_FILE_OBJECT			perFO;
	PSIS_SCB						scb;
	KIRQL							OldIrql;

	fileIdString->Length = fileIdString->MaximumLength = sizeof(LARGE_INTEGER);
	fileIdString->Buffer = (PWCHAR)&checkRequest->internalInfo->IndexNumber;

	InitializeObjectAttributes(
				Obja,
				fileIdString,
				OBJ_CASE_INSENSITIVE,
				deviceExtension->GrovelerFileHandle,
				NULL);

	status = NtCreateFile(
				&dstFileHandle,
				0,
				Obja,
				Iosb,
				NULL,					// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | 
					FILE_SHARE_WRITE | 
					FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,					// EA buffer
				0);						// EA length

	if (!NT_SUCCESS(status)) {
		//
		// We couldn't open the file.  open-by-id creates fail with invalid parameter
		// when there is no file with that id.  If that's what happened, then the file's
		// gone and we can delete the backpointer.  If it failed for some other reason,
		// then we'll err on the side of conservatism and leave it be.
		//

		SIS_MARK_POINT_ULONG(status);

		if ((STATUS_INVALID_PARAMETER == status) || 
			(STATUS_OBJECT_NAME_NOT_FOUND == status) ||
			(STATUS_OBJECT_PATH_NOT_FOUND == status)) {
			fileGone = TRUE;
		}

		goto done;
	}

	//
	// We opened a file with the right file ID.  See if it's still a SIS file.
	//

	status = ObReferenceObjectByHandle(
				dstFileHandle,
				0,
				*IoFileObjectType,
				KernelMode,
				&dstFileObject,
				NULL);

	if (!NT_SUCCESS(status)) {
		//
		// The file's there, but for some reason we can't access the file object.
		// Be conservative and assume that it's still the link.
		//
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

	if (!SipIsFileObjectSIS(dstFileObject, DeviceObject, FindActive, &perFO, &scb)) {
		//
		// The file exists, but it's not a SIS file.
		//
		SIS_MARK_POINT();
		fileGone = TRUE;

		goto done;
	}

	//
	// The file exists, and it's a SIS file.  See if it's a reference to the same file,
	// or to a different one.  We don't have to worry about it's being a new reference to the
	// same file, because we hold the refcount update resource for the common store file.
	//

	if (scb->PerLink != checkRequest->perLink) {
		SIS_MARK_POINT();
		fileGone = TRUE;
	} else {
		//
		// It's still there.  Presumably someone renamed it before the rename that we're
		// tracking could blow it away.
		//
	}

done:

	SIS_MARK_POINT_ULONG(checkRequest->perLink->CsFile);

	if (fileGone) {
		KeAcquireSpinLock(checkRequest->perLink->SpinLock, &OldIrql);
		checkRequest->perLink->Flags |= SIS_PER_LINK_FILE_DELETED;
		KeReleaseSpinLock(checkRequest->perLink->SpinLock, OldIrql);
		
	}

	SipCompleteCSRefcountChangeForThread(
		checkRequest->perLink,
		&checkRequest->perLink->Index,
		checkRequest->perLink->CsFile,
		fileGone,
		FALSE,
		checkRequest->thread);

	SipDereferencePerLink(checkRequest->perLink);

	if (NULL != dstFileObject) {
		ObDereferenceObject(dstFileObject);
	}

	if (NULL != dstFileHandle) {
		NtClose(dstFileHandle);
	}

	KeSetEvent(checkRequest->event, IO_NO_INCREMENT, FALSE);

	return;
}

NTSTATUS
SiRenameOverCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				context)
/*++

Routine Description:

	An IRP completion routine for a rename call with a SIS link as a target.
	This function just resynchronizes with the calling thread by clearing
	PendingReturned and setting an event.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing rename request.


Return Value:

	STATUS_MORE_PROCESSING_REQUIRED

--*/
{
	PKEVENT					event = (PKEVENT)context;

    UNREFERENCED_PARAMETER( DeviceObject );

	Irp->PendingReturned = FALSE;

	KeSetEvent(event, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SipReplaceIfExistsRename(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp)
/*++

Routine Description:

	Someone did a replace-if-exists NtSetInformationFile call.  We need to
	figure out if the target is a SIS link, and if so remove the backpointer
	for the file.  This function does about half of the work, and then posts
	to a worker thread (SipRenameOverCheck) to do the final check to see if 
	the SIS file was really overwritten.

	It is the responsibility of this function to complete the irp.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing rename request.


Return Value:

	The status of the request

--*/
{
	HANDLE						dstFileHandle = NULL;
	OBJECT_ATTRIBUTES			Obja[1];
	PFILE_RENAME_INFORMATION	renameInfo = Irp->AssociatedIrp.SystemBuffer;
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION			nextIrpSp;
	UNICODE_STRING				dstFileName[1];
	NTSTATUS					status;
	IO_STATUS_BLOCK				Iosb[1];
	PFILE_OBJECT				dstFileObject = NULL;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_SCB					scb;
	FILE_INTERNAL_INFORMATION	internalInfo[1];
	PSIS_PER_LINK				perLink;
	KEVENT						event[1];
	SIS_CHECK_OVERWRITE_REQUEST	checkRequest[1];
	PDEVICE_EXTENSION			deviceExtension = DeviceObject->DeviceExtension;

	ASSERT(IRP_MJ_SET_INFORMATION == irpSp->MajorFunction);
	ASSERT(renameInfo->ReplaceIfExists);

	//
	// The basic strategy here is similar to what we do in the overwrite/supersede open
	// case: we figure out if the file is a SIS file, and if so which one, let the
	// rename proceed and then see if the suspected target is gone.  Like overwrite/supersede,
	// we're subject to a race in the case where someone renames a SIS link under the
	// destination after we do our local check.  If that race goes the wrong way, we'll
	// lose the refcount decrement.  This won't ever result in user data loss, but we
	// won't be able to reclaim the common store file until we do a volume check.  C'est la vie.
	//

	//
	// The first step is to open the target file and see if it is a SIS link.
	//

	//
	// We have to be careful in dealing with the string lengths in the renameInfo buffer,
	// because they have not been checked anywhere.
	//

	if (renameInfo->FileNameLength + FIELD_OFFSET(FILE_RENAME_INFORMATION,FileName) > 
			irpSp->Parameters.SetFile.Length) {
		//
		// It's bogus, just let NTFS deal with it.
		//
		SIS_MARK_POINT();

		goto PassThrough;
	}

	//
	// The length is OK, so build up an object attributes for this file.
	//
	dstFileName->Length = (USHORT)renameInfo->FileNameLength;
	dstFileName->MaximumLength = (USHORT)renameInfo->FileNameLength;
	dstFileName->Buffer = renameInfo->FileName;

	InitializeObjectAttributes(
				Obja,
				dstFileName,
				OBJ_CASE_INSENSITIVE,
				renameInfo->RootDirectory,
				NULL);

	//
	// Open the file.  It's somewhat unusual to open a file with kernel privs in the
	// user context, but it's OK in this case for the following reasons:
	//		1) We're opening the file for no access, so the user can't do anything
	//		   aisde from close the handle.
	//		2) If the user does close the handle before we reference it, the worst
	// 		   that happens is that we miss the loss of a SIS link, which could happen
	//		   via the rename race anyway.
	//

	status = ZwCreateFile(
				&dstFileHandle,
				0,						// desired access; avoid sharing violations
				Obja,
				Iosb,
				NULL,					// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | 
					FILE_SHARE_WRITE | 
					FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,					// EA buffer
				0);						// EA length

	if (!NT_SUCCESS(status)) {
		//
		// For whatever reason, we couldn't open the file.  It probably doesn't exist.
		// Just pass the request through.
		//
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	status = ObReferenceObjectByHandle(
				dstFileHandle,
				0,
				*IoFileObjectType,
				KernelMode,
				&dstFileObject,
				NULL);					// handle info

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	//
	// See if this file is on the same device as we're being called on.
	//
	if (IoGetRelatedDeviceObject(dstFileObject) !=
		IoGetRelatedDeviceObject(irpSp->FileObject)) {

		//
		// They're not.  This call will most likely fail in NTFS since cross-volume
		// renames aren't supported at the NT interface level.  We'll just pass it
		// through.
		//

		SIS_MARK_POINT();
		goto PassThrough;
	}

	if (!SipCheckPhase2(deviceExtension)) {
		SIS_MARK_POINT();
		goto PassThrough;
	}

	if (!SipIsFileObjectSIS(dstFileObject, DeviceObject, FindActive, &perFO, &scb)) {
		//
		// It exists, but it's not a SIS file object.  Pass through.
		//
		SIS_MARK_POINT();

		goto PassThrough;
	}

	perLink = scb->PerLink;

	//
	// This is a rename-over with a destination that's a SIS file object.  Get the file
	// id of the destination file, prepare a refcount change, and close our handle to the
	// file.
	//

	status = SipQueryInformationFile(
				dstFileObject,
				DeviceObject,
				FileInternalInformation,
				sizeof(FILE_INTERNAL_INFORMATION),
				internalInfo,
				NULL);								// returnedLength

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	status = SipPrepareCSRefcountChange(
				perLink->CsFile,
				&perLink->Index,
				&internalInfo->IndexNumber,
				SIS_REFCOUNT_UPDATE_LINK_DELETED);		// rename-over destroys the destination file ID, so it's DELETED, not OVERWRITTEN

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto PassThrough;
	}

	SipReferencePerLink(perLink);

	ObDereferenceObject(dstFileObject);
	ZwClose(dstFileHandle);

	dstFileObject = NULL;
	dstFileHandle = NULL;

	//
	// Now call NTFS and resynchronize with the irp when it completes.
	//

	KeInitializeEvent(event,NotificationEvent,FALSE);

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));
				
	IoSetCompletionRoutine(	Irp,
							SiRenameOverCompletion,
							event,
							TRUE,
							TRUE,
							TRUE);

	status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);

	if (STATUS_PENDING == status) {
		KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
	}

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// It failed, so the SIS link target wasn't destroyed.
		//
		SIS_MARK_POINT_ULONG(status);

		goto NoOverwrite;
	}

	//
	// The rename completed successfully.  See if the destination file is still there.
	// Unfortunately, we have to post to do this, because we can't open the file by
	// name, lest someone rename it away from the rename-over that just completed (this
	// is a different race than the one that's left open, and would cause the backpointer
	// to go away when the file still exists, which is a much worse problem).  In order
	// to open it by ID, we need a handle to a file on this volume, which we have in the
	// device extension, but it's in the system process context.
	//
	// We need to take an extra reference to the PerLink before handing off to the
	// worker thread.  This is because we need to call SipHandoffBackpointerResource
	// after posting our work request, but in posting the work request we lose our
	// original reference to the per link, so there's no way to guarantee that the
	// csfile still exists after the post happens.
	//

	SipReferencePerLink(perLink);

	KeInitializeEvent(checkRequest->event, NotificationEvent, FALSE);
	checkRequest->perLink = perLink;
	checkRequest->internalInfo = internalInfo;
	checkRequest->DeviceObject = DeviceObject;
	checkRequest->thread = ExGetCurrentResourceThread();

	ExInitializeWorkItem(
		checkRequest->workItem,
		SipRenameOverCheck,
		checkRequest);

	ExQueueWorkItem(
		checkRequest->workItem,
		CriticalWorkQueue);

	//
	// The worker thread now will complete the refcount change, so we
	// need to say that we've handed off, and also drop the extra perLink
	// reference that we took.
	//

	SipHandoffBackpointerResource(perLink->CsFile);
	SipDereferencePerLink(perLink);

	KeWaitForSingleObject(checkRequest->event, Executive, KernelMode, FALSE, NULL);

	//
	// Now it's all done, just complete the irp.
	//

	status = Irp->IoStatus.Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;


PassThrough:

	//
	// Something went wrong (or this just isn't a SIS file or doesn't exist or whatever).
	// Clean up and pass the request down.
	//

	if (NULL != dstFileObject) {
		ObDereferenceObject(dstFileObject);
	}

	if (NULL != dstFileHandle) {
		ZwClose(dstFileHandle);
	}

	SipDirectPassThroughAndReturn(DeviceObject, Irp);

NoOverwrite:

	//
	// We got far enough to prepare the refcount change, but have decided that the
	// file wasn't overwritten.  Get out.  Note that we need to complete the irp
	// ourselves here, because we've already called into NTFS and stopped the
	// irp completion processing.
	//

	SipCompleteCSRefcountChange(
		perLink,
		&perLink->Index,
		perLink->CsFile,
		FALSE,
		FALSE);

	SipDereferencePerLink(perLink);

	status = Irp->IoStatus.Status;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	ASSERT(NULL == dstFileObject);
	ASSERT(NULL == dstFileHandle);

	return status;
				
}

NTSTATUS
SiDeleteCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
{
	PSIS_PER_LINK	 				perLink = (PSIS_PER_LINK)Context;
	KIRQL							OldIrql;
	PFILE_DISPOSITION_INFORMATION	disposition;

    UNREFERENCED_PARAMETER( DeviceObject );

	if (Irp->PendingReturned) {
		IoMarkIrpPending(Irp);
	}

	disposition = Irp->AssociatedIrp.SystemBuffer;
	ASSERT(NULL != disposition);

    // We just sent a delete setInformation call down to the link file.  If it worked,
	// we need to decrement the reference count on the underlying CS file (the file, not
	// the SIS_CS_FILE object).

	SIS_MARK_POINT_ULONG(perLink);

	if (NT_SUCCESS(Irp->IoStatus.Status)) {

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

		if (disposition->DeleteFile) {
			perLink->Flags |= SIS_PER_LINK_DELETE_DISPOSITION_SET;
		} else {
			perLink->Flags &= ~SIS_PER_LINK_DELETE_DISPOSITION_SET;
		}

		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

	} 

	SipEndDeleteModificationOperation(perLink,disposition->DeleteFile);

	SIS_MARK_POINT_ULONG(perLink);
	return STATUS_SUCCESS;
}

NTSTATUS
SiSetEofCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A SetFileInformation with class FileEndOfFileInformation has completed.
	We hold the scb for this file.  Release it.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the set EOF request.

    Context - Context parameter, a PSI_SET_EOF_COMPLETION_CONTEXT.

Return Value:

    The function value for this routine is always success.

--*/
{
	PIO_STACK_LOCATION				irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT					fileObject;
	PSIS_SCB						scb = (PSIS_SCB)Context;
	PFILE_END_OF_FILE_INFORMATION	eofInfo;
	LONGLONG						newLength;
	KIRQL							OldIrql;

    UNREFERENCED_PARAMETER( DeviceObject );

	fileObject = irpSp->FileObject;
	eofInfo = Irp->AssociatedIrp.SystemBuffer;
	ASSERT(eofInfo);
	newLength = eofInfo->EndOfFile.QuadPart;

	SipAcquireScb(scb);

	//
	// If the set EOF succeeded, update our internal data structures to
	// record the new file length.
	//
	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		ASSERT(Irp->IoStatus.Status != STATUS_PENDING);

		if (newLength != scb->SizeBackedByUnderlyingFile) {
			//
			// This call set the length to something other than the size of the
			// underlying file, which means that the file is now dirty.  Indicate so.
			//
			PSIS_PER_LINK perLink = scb->PerLink;

			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
			perLink->Flags |= SIS_PER_LINK_DIRTY;
			KeReleaseSpinLock(perLink->SpinLock, OldIrql);
		}

		if (newLength < scb->SizeBackedByUnderlyingFile) {

			//
			// This truncated the file.  
			//
			SipTruncateScb(scb,newLength);

		}

	} 

	SipReleaseScb(scb);

    //
    // Propogate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;
}

NTSTATUS
SiSetInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	This is invoked on all NtSetInformationFile calls.  We need to catch delete requests for files in
	the common store, which need to be turned into delete requests for the links (and also result in
	decrementing the ref count for the common store object, possibly deleting that as well.)  All other
	set information calls are handled by the normal parts of the driver stack.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the set file information request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation( Irp );
	PDEVICE_EXTENSION 		deviceExtension;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
    FILE_INFORMATION_CLASS 	FileInformationClass;
	NTSTATUS 				status;
	PSIS_SCB				scb;
	PSIS_PER_FILE_OBJECT	perFO;
	PIO_STACK_LOCATION		nextIrpSp;

	SipHandleControlDeviceObject(DeviceObject, Irp);

    FileInformationClass = irpSp->Parameters.SetFile.FileInformationClass;

	if (FileRenameInformation == FileInformationClass) {
		//
		// We need to deal with the case where the target of a rename replace-if-exists
		// is a SIS link.  So, regardless of what type of file the source is, if this
		// rename has replace-if-exists set, we have to deal with it.
		//

		PFILE_RENAME_INFORMATION	fileRenameInfo = Irp->AssociatedIrp.SystemBuffer;

		if (fileRenameInfo->ReplaceIfExists) {
			//
			// This is a replace-if-exists rename request.  Let our special code handle it.
			// 

			return SipReplaceIfExistsRename(DeviceObject, Irp);
		}
	}

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		// This isn't a SIS file, just pass the call through to NTFS

		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	ASSERT(scb);
	
	SIS_MARK_POINT_ULONG(FileInformationClass);
	SIS_MARK_POINT_ULONG(scb);
	
	switch (FileInformationClass) {

		case FileLinkInformation: {
			//
			// Don't allow hard links to SIS files.
			//
			status = STATUS_OBJECT_TYPE_MISMATCH;

			SIS_MARK_POINT();
			
			Irp->IoStatus.Status = status;
			Irp->IoStatus.Information = 0;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);

			SIS_MARK_POINT();
			return status;
		}

		case  FileDispositionInformation: {
			PFILE_DISPOSITION_INFORMATION 	disposition;
			PSIS_PER_LINK 					perLink;

			perLink = scb->PerLink;

			disposition = Irp->AssociatedIrp.SystemBuffer;

			SipBeginDeleteModificationOperation(perLink, disposition->DeleteFile);

			//
			// Send the delete irp down on the link/copied file.
			//
			nextIrpSp = IoGetNextIrpStackLocation( Irp );
			RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));
				
			IoSetCompletionRoutine(	Irp,
									SiDeleteCompletion,
									perLink,
									TRUE,
									TRUE,
									TRUE);

			SIS_MARK_POINT_ULONG(scb);
			status = IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
			return status;
		}

		case FilePositionInformation: {
				PFILE_POSITION_INFORMATION 		position = Irp->AssociatedIrp.SystemBuffer;
				
				
		        //
        		//  Check if the file uses intermediate buffering.  If it does
		        //  then the new position we're supplied must be aligned properly 
				//  for the device
		        //
				if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)
					&& position->CurrentByteOffset.LowPart % deviceExtension->FilesystemVolumeSectorSize) {

					status = STATUS_INVALID_PARAMETER;
				} else {
					//
					// Just set the offset, regardless of whether it's beyond EOF.
					//
					fileObject->CurrentByteOffset = position->CurrentByteOffset;
					status = STATUS_SUCCESS;
				}

				Irp->IoStatus.Status = status;
				Irp->IoStatus.Information = 0;
				IoCompleteRequest(Irp, IO_NO_INCREMENT);

				SIS_MARK_POINT();
				return status;
		}

		case FileEndOfFileInformation: {
				PFILE_END_OF_FILE_INFORMATION	endOfFile = Irp->AssociatedIrp.SystemBuffer;

				SIS_MARK_POINT_ULONG(endOfFile->EndOfFile.LowPart);

#if		DBG
				if (BJBDebug & 0x10000) {
					DbgPrint("SIS: SiSetInfo: set EOF information scb %p, AO %d, eof.lp 0x%x\n",
								scb,irpSp->Parameters.SetFile.AdvanceOnly,endOfFile->EndOfFile.LowPart);
				}
#endif	// DBG

				if (irpSp->Parameters.SetFile.AdvanceOnly) {
					//
					// This is the lazywriter advancing valid data length, so it's guaranteed
					// not to truncate the file, so we don't need to pay attention to it.
					// Just pass it down to NTFS unattended.
					//
					SIS_MARK_POINT_ULONG(scb);
					SipDirectPassThroughAndReturn(DeviceObject,Irp);
				}

				nextIrpSp = IoGetNextIrpStackLocation(Irp);
				RtlMoveMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

				//
				// We've completed the copy on write.  Pass the call down on the copied file object.
				// Hold the Scb while the call goes down, and release it in the completion routine.
				//

				IoSetCompletionRoutine(
					Irp,
					SiSetEofCompletion,
					scb,
					TRUE,
					TRUE,
					TRUE);

				return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
		}

		default: {
			// Just pass it down

			SIS_MARK_POINT();
			SipDirectPassThroughAndReturn(DeviceObject, Irp);
		}
	}

	/*NOTREACHED*/
	ASSERT(FALSE && "NOTREACHED");
	SIS_MARK_POINT();
	SipDirectPassThroughAndReturn(DeviceObject, Irp);

}

NTSTATUS
SiQueryBasicInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileBasicInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query basic information
			request.

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_BASIC_INFORMATION basicInfo = (PFILE_BASIC_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != basicInfo);

	SIS_MARK_POINT_ULONG(Irp);

	basicInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);
	
	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == basicInfo->FileAttributes) {
		basicInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryAllInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileAllInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query all information
			request

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_ALL_INFORMATION allInfo = (PFILE_ALL_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != allInfo);

	SIS_MARK_POINT_ULONG(Irp);

	allInfo->BasicInformation.FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == allInfo->BasicInformation.FileAttributes) {
		allInfo->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryNetworkOpenInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileNetworkOpenInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query network open information
			request

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_NETWORK_OPEN_INFORMATION netOpenInfo = (PFILE_NETWORK_OPEN_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != netOpenInfo);

	SIS_MARK_POINT_ULONG(Irp);

	netOpenInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == netOpenInfo->FileAttributes) {
		netOpenInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryAttributeTagInfoCompletion(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp,
	IN PVOID				Context)
/*++

Routine Description:

	A QueryInformationFile with class FileAttributeTagInformation has completed successfully
	for a non-FILE_OPEN_REPARSE_POINT file.  Clear out the reparse and sparse flags, and set
	the reparse tag as if it were not a reparse point.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query attribute tag request.

    Context - Context parameter, a PSIS_PER_FILE_OBJECT.

Return Value:

	STATUS_SUCCESS.

--*/
{
	PFILE_ATTRIBUTE_TAG_INFORMATION attributeTagInfo = (PFILE_ATTRIBUTE_TAG_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(DeviceObject);

	ASSERT(NULL != attributeTagInfo);

	SIS_MARK_POINT_ULONG(Irp);

	attributeTagInfo->FileAttributes &= ~(FILE_ATTRIBUTE_SPARSE_FILE|FILE_ATTRIBUTE_REPARSE_POINT);
	attributeTagInfo->ReparseTag = IO_REPARSE_TAG_RESERVED_ZERO;

	//
	// If there are no remaining attributes set, explicitly set FILE_ATTRIBUTE_NORMAL.
	//
	if (0 == attributeTagInfo->FileAttributes) {
		attributeTagInfo->FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SiQueryInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	The top level entry point for a query information irp.  We do special
	processing for a few of these, check to see if it's one and dispatch
	appropriately.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the query request.

Return Value:

	status of the request, typically returned from NTFS

--*/
{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation( Irp );
	PIO_STACK_LOCATION		nextIrpSp;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PIO_COMPLETION_ROUTINE	completionRoutine;
	KIRQL					OldIrql;
	BOOLEAN					openedAsReparsePoint;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;
	
	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,NULL)) {
		// This isn't a SIS file, just pass the call through to NTFS
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);
	openedAsReparsePoint = (perFO->Flags & SIS_PER_FO_OPEN_REPARSE) ? TRUE : FALSE;
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	if (openedAsReparsePoint) {
		//
		// This was opened as a reparse point, so let the user see the real truth.
		//
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT_ULONG(irpSp->Parameters.QueryFile.FileInformationClass);
	SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);

#if		DBG
	if (BJBDebug & 0x10) {
		DbgPrint("SIS: SiQueryInfo: InformationClass %d\n",
			 irpSp->Parameters.QueryFile.FileInformationClass);
	}
#endif	// DBG

	// Handle the request.
	//
	switch (irpSp->Parameters.QueryFile.FileInformationClass) {

	case FileDirectoryInformation:						// 1	// diretory-only call, let NTFS reject it
	case FileFullDirectoryInformation:					// 2	// diretory-only call, let NTFS reject it
	case FileBothDirectoryInformation:					// 3	// diretory-only call, let NTFS reject it
														// 4	// FileBasicInfo handled separately
	case FileStandardInformation:						// 5
	case FileInternalInformation:						// 6
	case FileEaInformation:								// 7
	case FileAccessInformation:							// 8
	case FileNameInformation:							// 9
	case FileRenameInformation:							// 10	// rename isn't valid for query, but we'll let NTFS reject it
	case FileLinkInformation:							// 11	// link isn't valid for query, but we'll let NTFS reject it
	case FileNamesInformation:							// 12	// diretory-only call, let NTFS reject it
	case FileDispositionInformation:					// 13
	case FilePositionInformation:						// 14
	case FileFullEaInformation:							// 15	// NTFS doesn't support this, but we'll let it reject it
	case FileModeInformation:							// 16
	case FileAlignmentInformation:						// 17
														// 18	// FileAllInformation handled separately
	case FileAllocationInformation:						// 19
	case FileEndOfFileInformation:						// 20
	case FileAlternateNameInformation:					// 21
	case FileStreamInformation:							// 22
	case FilePipeInformation:							// 23	// NTFS doesn't support this, but we'll let it reject it
	case FilePipeLocalInformation:						// 24	// NTFS doesn't support this, but we'll let it reject it
	case FilePipeRemoteInformation:						// 25	// NTFS doesn't support this, but we'll let it reject it
	case FileMailslotQueryInformation:					// 26	// NTFS doesn't support this, but we'll let it reject it
	case FileMailslotSetInformation:					// 27	// NTFS doesn't support this, but we'll let it reject it
	case FileCompressionInformation:					// 28
	case FileObjectIdInformation:						// 29
	case FileCompletionInformation:						// 30	// NTFS doesn't support this, but we'll let it reject it
														// 31	FileMoveCluserInformation - intentionally failed for SIS files (+ not supported by NTFS)
	case FileQuotaInformation:							// 32	// diretory-only call, let NTFS reject it
	case FileReparsePointInformation:					// 33	// diretory-only call, let NTFS reject it
														// 34	// FileNetworkOpenInformation handled separately
														// 35	// FileAttributeTagInformation handled separately
	case FileTrackingInformation:						// 36	// NTFS doesn't support this, but we'll let it reject it

			//
			// Set the completion routine to NULL, which says that we never want to
			// catch completions on these calls.
			//
			completionRoutine = NULL;
			break;



	case FileBasicInformation:							// 4
			completionRoutine = SiQueryBasicInfoCompletion;
			break;

	case FileAllInformation:							// 18
			completionRoutine = SiQueryAllInfoCompletion;
			break;

	case FileNetworkOpenInformation:					// 34
			completionRoutine = SiQueryNetworkOpenInfoCompletion;
			break;

	case FileAttributeTagInformation:					// 35
			completionRoutine = SiQueryAttributeTagInfoCompletion;
			break;

	case FileMoveClusterInformation:					// 31	// NTFS doesn't implement this, but it's too scary to pass through anyway

		//
		// Reject these calls, for now.
		//

		SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);
		
#if		DBG
		DbgPrint("SIS: SiQueryInfo: aborting FileInformationClass %d\n",irpSp->Parameters.QueryFile.FileInformationClass);
#endif	// DBG

		Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return STATUS_INVALID_PARAMETER;

	default:

		//
		// It's an unknown or invalid information class.  Assume that it's newly added and
		// benign, and pass it down to NTFS unmodified.
		//

		SIS_MARK_POINT_ULONG(perFO->fc->primaryScb);
		SIS_MARK_POINT_ULONG(irpSp->Parameters.QueryFile.FileInformationClass);
		completionRoutine = NULL;

#if		DBG
		DbgPrint("SIS: SiQueryInfo: passing though unknown FileInformationClass %d\n",irpSp->Parameters.QueryFile.FileInformationClass);
#endif	// DBG
		break;

	}

	if (NULL == completionRoutine) {
		//
		// This call doesn't require fixup on completion.  Pass it through.
		//
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	} else {
		//
		// This call requires fixup on the way out.  Only invoke the
		// completion routine on success; else, there's nothing to fix up.
		//
		nextIrpSp = IoGetNextIrpStackLocation( Irp );
		RtlMoveMemory(nextIrpSp, irpSp, sizeof (IO_STACK_LOCATION));

		IoSetCompletionRoutine(
			Irp,
			completionRoutine,
			perFO,
			TRUE,
			FALSE,
			FALSE);

		return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
	}
	
}

VOID
SipTruncateScb(
	IN OUT PSIS_SCB						scb,
	IN LONGLONG							newLength)
{
	LONGLONG				newLengthInSectors;
	PDEVICE_EXTENSION		deviceExtension;

	deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;

	newLengthInSectors = (newLength + deviceExtension->FilesystemVolumeSectorSize - 1) /
							deviceExtension->FilesystemVolumeSectorSize;

	ASSERT(newLength < scb->SizeBackedByUnderlyingFile);	// else this isn't a truncation

	FsRtlTruncateLargeMcb(scb->Ranges,newLengthInSectors);

	scb->SizeBackedByUnderlyingFile = newLength;
}

VOID
SipBeginDeleteModificationOperation(
	IN OUT PSIS_PER_LINK				perLink,
	IN BOOLEAN							delete)
/*++

Routine Description:

	We are beginning a delete or undelete operation on the given
	per-link.  If there is the opposite kind of operation in
	progress, wait for it to complete.  Otherwise, indicate that
	the new operation is in progress and continue.

	Must be called at IRQL < DISPATCH_LEVEL.

Arguments:

	perLink - the per link for the file on which we're doing the (un)delete.

	delete - TRUE for delete, FALSE for undelete

Return Value:

	void

--*/
{
	KIRQL		OldIrql;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

	while ((perLink->PendingDeleteCount > 0) &&
			((delete && (perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS)) ||
			(((!delete) && !(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS))))) {
		//
		// The wrong kind of operation is happening now, so we need to block.
		//
		if (!(perLink->Flags & SIS_PER_LINK_DELETE_WAITERS)) {
			KeClearEvent(perLink->DeleteEvent);
			perLink->Flags |= SIS_PER_LINK_DELETE_WAITERS;
		}
		KeReleaseSpinLock(perLink->SpinLock, OldIrql);

		KeWaitForSingleObject(perLink->DeleteEvent, Executive, KernelMode, FALSE, NULL);

		KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
	}

	if (!delete) {
		ASSERT((perLink->PendingDeleteCount == 0) || (perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
		perLink->Flags |= SIS_PER_LINK_UNDELETE_IN_PROGRESS;
	} else {
		ASSERT(!(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
	}

	perLink->PendingDeleteCount++;

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);
}

VOID
SipEndDeleteModificationOperation(
	IN OUT PSIS_PER_LINK				perLink,
	IN BOOLEAN							delete)
/*++

Routine Description:

	We just finished a delete/undelete operation.  Decrement our count and
	if appropriate wake up any waiters.

	Must be called with IRQL <= DISPATCH_LEVEL.

Arguments:

	perLink - the per link for the file on which we're doing the (un)delete.

	delete - TRUE for delete, FALSE for undelete

Return Value:

	void

--*/
{
	KIRQL		OldIrql;

	KeAcquireSpinLock(perLink->SpinLock, &OldIrql);

	ASSERT(perLink->PendingDeleteCount > 0);

	perLink->PendingDeleteCount--;

#if		DBG
	if (delete) {
		ASSERT(!(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS));
	} else {
		ASSERT(perLink->Flags & SIS_PER_LINK_UNDELETE_IN_PROGRESS);
	}
#endif	// DBG

	if (0 == perLink->PendingDeleteCount) {

		if (perLink->Flags & SIS_PER_LINK_DELETE_WAITERS) {
			perLink->Flags &= ~SIS_PER_LINK_DELETE_WAITERS;
			KeSetEvent(perLink->DeleteEvent, IO_NO_INCREMENT, FALSE);
		}
		if (!delete) {
			perLink->Flags &= ~SIS_PER_LINK_UNDELETE_IN_PROGRESS;
		}
	}

	KeReleaseSpinLock(perLink->SpinLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\silock.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    silock.c

Abstract:

	File locking routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SiLockControl)
#endif

NTSTATUS
SiCompleteLockIrpRoutine(
	IN PVOID				Context,
	IN PIRP					Irp)
/*++

Routine Description:

	FsRtl has decided to complete a lock request irp.  We don't want to really
	complete the irp because we're going to send it to NTFS to set up the parallel
	lock structure.  So, we use this routine as the "CompleteLockIrp" routine for
	fsrtl, and then we don't really complete the irp.

Arguments:
	Context			- our context parameter (unused)

	irp				- the create irp, which contains the create request in the
					  current stack location.

Return Value:

	the status from the irp

--*/
{
	UNREFERENCED_PARAMETER(Context);

	return Irp->IoStatus.Status;
}

NTSTATUS
SiLockControl(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp)
{
	NTSTATUS				status;
	PSIS_SCB				scb;
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PFILE_OBJECT			fileObject = irpSp->FileObject;
	PSIS_PER_FILE_OBJECT	perFO;
	PDEVICE_EXTENSION		deviceExtension = DeviceObject->DeviceExtension;

	PAGED_CODE();

	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	SIS_MARK_POINT();

	//  Now call the FsRtl routine to do the actual processing of the
	//  Lock request
	status = FsRtlProcessFileLock( &scb->FileLock, Irp, NULL );

	//
	// Now, pass the request down on the link/copied file so that NTFS will also
	// maintain the file lock.
	//

    Irp->CurrentLocation++;
    Irp->Tail.Overlay.CurrentStackLocation++;
	
    return IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\silog.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    silog.c

Abstract:

	Logging support for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(PAGE, SipComputeChecksum)
#pragma alloc_text(PAGE, SipDrainLogFile)
#endif	// ALLOC_PRAGMA



#if	DBG
VOID
SipDBGDumpLogRecord(
	PSIS_LOG_HEADER			header)
{
    DbgPrint("log record: type %d, size %d, index 0x%x.0x%x\n",
				header->Type,
				header->Size,
				header->Index.HighPart,
				header->Index.LowPart);

	switch (header->Type) {
	}
}
#endif	// DBG

NTSTATUS
SipMakeLogEntry(
	IN OUT PDEVICE_EXTENSION			deviceExtension,
	IN USHORT							type,
	IN USHORT							size,
	IN PVOID							record)
/*++

Routine Description:

	Make an entry in the SIS log.  Creates the header, computes the
	checksum and then writes the log entry to the log file for this
	volume.  A successful return guarantees that the log record is
	flushed to disk.  This routine blocks.

Arguments:

	deviceExtension - the device extension for the volume onto which we're
		logging.

	type - the type of the record we're writing.

	size - the size of the record we're writing (not counting the header)

	record - the log record data to write to the file.

Return Value:

	Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
#if		ENABLE_LOGGING
    PSIS_LOG_HEADER						header = NULL;
	NTSTATUS							status;
	PIRP								irp;
	KEVENT								event[1];
	PIO_STACK_LOCATION					irpSp;
	BOOLEAN								mutantAcquired = FALSE;
	IO_STATUS_BLOCK						Iosb[1];


	if (deviceExtension->LogFileHandle == NULL) {
		SIS_MARK_POINT();
		return STATUS_DRIVER_INTERNAL_ERROR;
	}

	header = ExAllocatePoolWithTag(PagedPool, size + sizeof(SIS_LOG_HEADER), ' siS');

	if (!header) {
		SIS_MARK_POINT();
		status =  STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	ASSERT(size % 4 == 0);	// The log drain code relies on this

	header->Magic = SIS_LOG_HEADER_MAGIC;
	header->Type = type;
	header->Size = size + sizeof(SIS_LOG_HEADER);

	status = SipAllocateIndex(deviceExtension, &header->Index);
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		return status;
	}

	//
	// Copy the log record into the newly alloated header+record area.
	//
	RtlMoveMemory(header + 1, record, size);

	//
	// Compute the checksum.  We need to set the checksum field in the header
	// to 0 before we do the computation so that whatever's there isn't
	// part of the checksum (and then overwritten with the real checksum).
	//
	header->Checksum.QuadPart = 0;
	SipComputeChecksum(header, header->Size, &header->Checksum.QuadPart);

	//
	// Acquire the log mutant to serialize writing to the log file.
	//

	status = KeWaitForSingleObject(deviceExtension->LogFileMutant, Executive, KernelMode, FALSE, NULL);
	ASSERT(status == STATUS_SUCCESS);
	mutantAcquired = TRUE;

	ASSERT(deviceExtension->LogFileHandle != NULL && deviceExtension->LogFileObject != NULL);	// Should have happened in phase 2 initialization

	//
	// Create an irp to do the write.  We don't want to just use ZwWriteFile because we want to
	// avoid the context switch to the process where we hold the log handle.
	//

	irp = IoBuildAsynchronousFsdRequest(
				IRP_MJ_WRITE,
				deviceExtension->FileSystemDeviceObject,
				header,
				header->Size,
				&deviceExtension->LogWriteOffset,
				Iosb);

	if (!irp) {
		SIS_MARK_POINT();
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	irpSp = IoGetNextIrpStackLocation(irp);
	irpSp->FileObject = deviceExtension->LogFileObject;

	//
	// Initialize the event on which we'll wait for the write to complete.
	//
	KeInitializeEvent(event,NotificationEvent,FALSE);

	IoSetCompletionRoutine(
			irp, 
			SiDeleteAndSetCompletion,
			event,
			TRUE, 
			TRUE, 
			TRUE);

	//
	// Make sure that this request is really write through all the way to the disk
	// medium.
	//
	irpSp->Flags |= SL_WRITE_THROUGH;


	status = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

	// At this point, we have released the mutant in the complete
	// routine.

#if		DBG
	irp = NULL; irpSp = NULL;  // The completion routine may have already deallocated the irp.
#endif	// DBG

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event,Executive,KernelMode,FALSE,NULL);
		ASSERT(status == STATUS_SUCCESS);
		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
#if		DBG
		DbgPrint("SiMakeLogEntry: Log entry failed after write wait, 0x%x\n",status);
#endif	// DBG
		SIS_MARK_POINT_ULONG(status);
		goto done;
	} else {
		ASSERT(Iosb->Information == header->Size);
		deviceExtension->LogWriteOffset.QuadPart += header->Size;
	}

done:
	if (header != NULL) {
		ExFreePool(header);
	}

	if (mutantAcquired) {
		KeReleaseMutant(
				deviceExtension->LogFileMutant,
				IO_NO_INCREMENT,
				FALSE,
				FALSE);
	}

	return status;
#else	// ENABLE_LOGGING
    UNREFERENCED_PARAMETER( deviceExtension );
    UNREFERENCED_PARAMETER( type );
    UNREFERENCED_PARAMETER( size );
    UNREFERENCED_PARAMETER( record );

	return STATUS_SUCCESS;
#endif	// ENABLE_LOGGING
}
	
VOID
SipComputeChecksum(
	IN PVOID							buffer,
	IN ULONG							size,
	IN OUT PLONGLONG					checksum)
/*++

Routine Description:

	Compute a checksum for a buffer.  We use the "131 hash," which
	work by keeping a 64 bit running total, and for each 32 bits of
	data multiplying the 64 bits by 131 and adding in the next 32
	bits.  Must be called at PASSIVE_LEVEL, and all aruments
	may be pagable.

Arguments:

	buffer - pointer to the data to be checksummed

	size - size of the data to be checksummed

	checksum - pointer to large integer to receive the checksum.  This
		may be within the buffer, and SipComputeChecksum guarantees that
		the initial value will be used in computing the checksum.

Return Value:

	void
--*/
{
	LONGLONG runningTotal;
	ULONG *ptr = (unsigned *)buffer;
	ULONG bytesRemaining = size;

	PAGED_CODE();

	//
	// NB: code in volume check assumes that the checksum of the empty bit string is
	// 0.  If this is ceases to be true, be sure to fix the code there.
	//

	runningTotal = *checksum;

	while (bytesRemaining >= sizeof(*ptr)) {
		runningTotal = runningTotal * 131 + *ptr;
		bytesRemaining -= sizeof(*ptr);
		ptr++;
	}

	if (bytesRemaining > 0) {
		ULONG extra;

		ASSERT(bytesRemaining < sizeof (ULONG));
		extra = 0;
		RtlMoveMemory(&extra, ptr, bytesRemaining);
		
		runningTotal = runningTotal * 131 + extra;
	}

	*checksum = runningTotal;
}

NTSTATUS
SipOpenLogFile(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
/*++

Routine Description:

	Open the log file for this volume.  Must not already be opened.  Must be called
	exactly once per volume, and must be called on a worker thread.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to open the log file.

Return Value:

	Returns status of the open.
--*/
{
#if		ENABLE_LOGGING
	NTSTATUS 					status;
	OBJECT_ATTRIBUTES			Obja[1];
	UNICODE_STRING				fileName;
	IO_STATUS_BLOCK				Iosb[1];

	SIS_MARK_POINT();

	ASSERT(deviceExtension->LogFileHandle == NULL);
	ASSERT(deviceExtension->LogFileObject == NULL);

	fileName.Length = 0;
	fileName.MaximumLength = deviceExtension->CommonStorePathname.Length + LOG_FILE_NAME_LEN;
	fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' siS');

	if (!fileName.Buffer) {
#if		DBG
		DbgPrint("SIS: SipOpenLogFile: unable to allocate filename buffer.  We're toast.\n");
#endif	// DBG

		SIS_MARK_POINT();

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
	}

	RtlCopyUnicodeString(
		&fileName,
		&deviceExtension->CommonStorePathname);

	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length);

	status = RtlAppendUnicodeToString(
					&fileName,
					LOG_FILE_NAME);

	ASSERT(status == STATUS_SUCCESS);
	ASSERT(fileName.Length == deviceExtension->CommonStorePathname.Length + LOG_FILE_NAME_LEN);	// or else you changed LOG_FILE_NAME without changing LOG_FILE_NAME_LEN

	InitializeObjectAttributes(
		Obja,
		&fileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

	status = NtCreateFile(
				&deviceExtension->LogFileHandle,
				GENERIC_READ | GENERIC_WRITE,
				Obja,
				Iosb,
				NULL,								// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ,					// share access
				FILE_OPEN_IF,
				FILE_WRITE_THROUGH,
				NULL,								// EA buffer
				0);									// EA length

	if (!NT_SUCCESS(status)) {
#if	DBG
		DbgPrint("SipOpenLogFile: ZwCreate failed, 0x%x\n",status);
#endif	// DBG
		SIS_MARK_POINT_ULONG(status);
		goto done;
	} else {
		status = ObReferenceObjectByHandle(
					deviceExtension->LogFileHandle,
					FILE_READ_DATA | FILE_WRITE_DATA,
					*IoFileObjectType,
					KernelMode,
					&deviceExtension->LogFileObject,
					NULL);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
#if		DBG
			DbgPrint("SipOpenLogFile: ObReferenceObjectByHandle failed, 0x%x\n",status);
#endif	// DBG

			NtClose(deviceExtension->LogFileHandle);
			deviceExtension->LogFileHandle = NULL;
			goto done;
		}
	}


	SipDrainLogFile(deviceExtension);

	SIS_MARK_POINT();

done:

	if (fileName.Buffer) {
		ExFreePool(fileName.Buffer);
#if		DBG
		fileName.Buffer = NULL;
#endif	// DBG
	}
	
	return status;

#undef	LOG_FILE_NAME
#undef	LOG_FILE_NAME_LEN
#else	// ENABLE_LOGGING

    UNREFERENCED_PARAMETER( deviceExtension );
	return STATUS_SUCCESS;
#endif	// ENABLE_LOGGING
}

VOID
SipDrainLogFile(
	PDEVICE_EXTENSION					deviceExtension)
/*++

Routine Description:

	Drain the log file for this volume and assure that all of the operations in it
	have happened or not happened atomically.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to drain the log file.

Return Value:

	VOID
--*/
{
#if		ENABLE_LOGGING
	FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
	FILE_ALLOCATED_RANGE_BUFFER		outArb[1];
	NTSTATUS						status;
	HANDLE							eventHandle = NULL;
	PKEVENT							event = NULL;
	IO_STATUS_BLOCK					Iosb[1];
	LARGE_INTEGER					fileOffset;
	PCHAR							buffer = NULL;
#define	BUFFER_SIZE	16384
	PULONG							bufferPointer;
	PSIS_LOG_HEADER					logHeader;
	LARGE_INTEGER					stashedChecksum, computedChecksum;
	BOOLEAN							clearLog = FALSE;

	PAGED_CODE();

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	buffer = ExAllocatePoolWithTag(PagedPool, BUFFER_SIZE, ' siS');

	if (NULL == buffer) {
		SIS_MARK_POINT();
		goto done;
	}

	status = SipCreateEvent(
				NotificationEvent,
				&eventHandle,
				&event);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		goto done;
	}

#if		DBG
	deviceExtension->LogWriteOffset.QuadPart = -1;
#endif	// DBG

	//
	// Figure out where the log file starts.
	//
	inArb->FileOffset.QuadPart = 0;
	inArb->Length.QuadPart = MAXLONGLONG;

	status = NtFsControlFile(
				deviceExtension->LogFileHandle,
				eventHandle,
				NULL,							// APC routine
				NULL,							// ApcContext
				Iosb,
				FSCTL_QUERY_ALLOCATED_RANGES,
				inArb,
				sizeof(FILE_ALLOCATED_RANGE_BUFFER),
				outArb,
				sizeof(FILE_ALLOCATED_RANGE_BUFFER));

	if (STATUS_PENDING == status) {
		status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
		ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
		status = Iosb->Status;
	}

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
		clearLog = TRUE;
		goto done;
	}

	if (0 == Iosb->Information) {
		//
		// The file is empty.  We're done.
		//
		SIS_MARK_POINT_ULONG(deviceExtension);
		clearLog = TRUE;
		goto done;
	}

	//
	// Skip over any leading unallocated range, starting at the beginning of the first allocated range.
	//
	fileOffset = outArb->FileOffset;

	//
	// Find the first log entry by searching for the first occurance of the magic number.
	//

	for (;;) {

		KeClearEvent(event);
	
		status = ZwReadFile(
					deviceExtension->LogFileHandle,
					eventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					buffer,
					BUFFER_SIZE,
					&fileOffset,
					NULL);							// key

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
			status = Iosb->Status;
		}

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			clearLog = TRUE;
			goto done;
		}

		if (0 == Iosb->Information) {
			SIS_MARK_POINT();
			clearLog = TRUE;
			goto done;
		}

		//
		// Cruise through the buffer looking for the magic number
		//
		for (bufferPointer = (PULONG)buffer; bufferPointer < ((PULONG)buffer) + BUFFER_SIZE/sizeof(ULONG); bufferPointer++) {
			if (SIS_LOG_HEADER_MAGIC == *bufferPointer) {
				fileOffset.QuadPart += (bufferPointer - ((PULONG)buffer)) * sizeof(ULONG);
				goto startLogReading;
			}
		}

		//
		// We didn't find it, read in the next chunk.
		//

		fileOffset.QuadPart += BUFFER_SIZE;
	}

startLogReading:

	for (;;) {
		KeClearEvent(event);

		status = ZwReadFile(
					deviceExtension->LogFileHandle,
					eventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					buffer,
					BUFFER_SIZE,
					&fileOffset,
					NULL);							// key

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);	// must succeed because Iosb is on the stack
			status = Iosb->Status;
		}

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			deviceExtension->LogWriteOffset = fileOffset;
			goto done;
		}

		if (0 == Iosb->Information) {
			SIS_MARK_POINT();
			deviceExtension->LogWriteOffset = fileOffset;
			goto done;
		}

		ASSERT(Iosb->Information <= BUFFER_SIZE);

		logHeader = (PSIS_LOG_HEADER)buffer;

		while ((((PCHAR)logHeader) - buffer) + sizeof(SIS_LOG_HEADER) <= Iosb->Information) {
			//
			// We know that we've got enough space for the log header.  
			//

			//
			// Check the header to see if it looks valid (ie., if it's got a good magic
			// number).  
			//
			if (SIS_LOG_HEADER_MAGIC != logHeader->Magic) {
				//
				// This log record is corrupt.  Start writing the new log records here, and 
				// punt the readback.
				//
				SIS_MARK_POINT();
				deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
				goto done;
			}

			//
			// See if we have enough space for the whole record.
			//
			if (((ULONG)(((PCHAR)logHeader - buffer) + logHeader->Size)) > Iosb->Information) {
				if (logHeader->Size > BUFFER_SIZE) {
					//
					// The log is corrupt.  Punt reading it.
					//
					SIS_MARK_POINT();
					deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
					goto done;
				}

				//
				// The log record isn't contained entirely within the buffer we've read.  Advance the buffer.
				//
				break;
			}

			//
			// We've got a whole log record.  Process it.
			//

			//
			// Make sure that the log record checkum matches.  First, we have to stash the checksum out of
			// the header and then set the header space to 0, because that's what it was when the checksum
			// was computed in the first place.
			//
			stashedChecksum = logHeader->Checksum;
			logHeader->Checksum.QuadPart = 0;
			computedChecksum.QuadPart = 0;

			SipComputeChecksum(logHeader, logHeader->Size, &computedChecksum.QuadPart);

			if (computedChecksum.QuadPart != stashedChecksum.QuadPart) {
				//
				// eventlog an error.
				//
#if		DBG
				DbgPrint("SIS: SipDrainLogFile: log record checksum doesn't match, 0x%x.0x%x != 0x%x.0x%x\n",
							computedChecksum.HighPart,computedChecksum.LowPart,
							stashedChecksum.HighPart,stashedChecksum.LowPart);
#endif	// DBG
				deviceExtension->LogWriteOffset.QuadPart = fileOffset.QuadPart + (((PCHAR)logHeader) - buffer);
				goto done;
			}

			//
			// The log record looks good.  Process it.
			//
			switch (logHeader->Type) {
				case SIS_LOG_TYPE_REFCOUNT_UPDATE: {
					PSIS_LOG_REFCOUNT_UPDATE refcountLogRecord = (PSIS_LOG_REFCOUNT_UPDATE)(logHeader + 1);

					SipProcessRefcountUpdateLogRecord(deviceExtension,refcountLogRecord);

/*BJB*/				DbgPrint("SIS: SipDrainLog: RC update UT %d, LF NTFS id 0x%x.0x%x, LI 0x%x.0x%x, CSid <whatever>\n",
								refcountLogRecord->UpdateType,refcountLogRecord->LinkFileNtfsId.HighPart,
								refcountLogRecord->LinkFileNtfsId.LowPart,refcountLogRecord->LinkIndex.HighPart,
								refcountLogRecord->LinkIndex.LowPart);

					break;
				}

				default: {
#if		DBG
					DbgPrint("SIS: SipDrainLog: Unknown log record type %d, ignoring.\n",logHeader->Type);
#endif	// DBG
					break;
				}
			}

			logHeader = (PSIS_LOG_HEADER)(((PCHAR)logHeader) + logHeader->Size);
		}

		//
		// Advance within the file to the beginning of the next record, loop around and reread the buffer.
		//
		fileOffset.QuadPart += ((PCHAR)logHeader) - buffer;
	}

done:

	if (clearLog) {
		SipClearLogFile(deviceExtension);
	}

	if (NULL != event) {
		ObDereferenceObject(event);
		event = NULL;
	}

	if (NULL != eventHandle) {
		NtClose(eventHandle);
		eventHandle = NULL;
	}

	if (NULL != buffer) {
		ExFreePool(buffer);
	}

	ASSERT(-1 != deviceExtension->LogWriteOffset.QuadPart);	// This should have been reset somewhere here.

#undef	BUFFER_SIZE	
#else
    UNREFERENCED_PARAMETER( deviceExtension );
#endif	// ENABLE_LOGGING
}

VOID
SipClearLogFile(
	PDEVICE_EXTENSION				deviceExtension)
/*++

Routine Description:

	Clear out the contents of the log file.  Must be called during initialization 
	when we're guaranteed to be serialized.  Also sets the log file sparse.

Arguments:

	deviceExtension - the device extension for the volume for which we're
		to clear the log file.

Return Value:

	VOID
--*/
{
#if		ENABLE_LOGGING
	FILE_END_OF_FILE_INFORMATION 		eofInfo[1];
	LARGE_INTEGER						byteOffset;
	NTSTATUS							status;
	IO_STATUS_BLOCK						Iosb[1];

	ASSERT(NULL != deviceExtension->LogFileObject);

	eofInfo->EndOfFile.QuadPart = 0;

	status = SipSetInformationFile(
				deviceExtension->LogFileObject,
				deviceExtension->DeviceObject,
				FileEndOfFileInformation,
				sizeof(FILE_END_OF_FILE_INFORMATION),
				eofInfo);

	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);
#if		DBG
		DbgPrint("SipClearLogFile: unable to set EOF to 0, status 0x%x\n",status);
#endif	// DBG
		return;
	}

	deviceExtension->LogWriteOffset.QuadPart = 0;

	status = SipFsControlFile(
				deviceExtension->LogFileObject,
				deviceExtension->DeviceObject,
				FSCTL_SET_SPARSE,
				NULL,							// input buffer
				0,								// input buffer length
				NULL,							// output buffer
				0,								// output buffer length
				NULL);							// returned output buffer length

#if		DBG
	if (!NT_SUCCESS(status)) {
		SIS_MARK_POINT_ULONG(status);

		DbgPrint("SIS: SipClearLogFile: set sparse failed 0x%x\n",status);
	}
#endif	// DBG

#else
    UNREFERENCED_PARAMETER( deviceExtension );
#endif	// ENABLE_LOGGING
}

#if		ENABLE_LOGGING
VOID
SipAcquireLog(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
{
	NTSTATUS status;
	status = KeWaitForSingleObject(deviceExtension->LogFileMutant, Executive, KernelMode, FALSE, NULL);
	ASSERT(status == STATUS_SUCCESS || status == STATUS_ABANDONED);
}

VOID
SipReleaseLog(
	IN OUT PDEVICE_EXTENSION			deviceExtension)
{
	KeReleaseMutant(deviceExtension->LogFileMutant, IO_NO_INCREMENT, TRUE, FALSE);
}

typedef	struct _TRIM_ENTRY {
	HANDLE				logHandle;
	LARGE_INTEGER		firstValidAddress;

	struct _TRIM_ENTRY	*next;
} TRIM_ENTRY, *PTRIM_ENTRY;

HANDLE		trimEventHandle = NULL;
PKEVENT		trimEvent = NULL;
#endif	// ENABLE_LOGGING

VOID
SiTrimLogs(
	IN PVOID			parameter)
/*++

Routine Description:

	Run through the list of SIS volumes on this system, and trim the log files
	for each of them.  This function should be called with a period greater than
	the longest time we expect log entries to be meaningful.

	Note: this routine is NOT thread safe; it can only be called once at a time.
	Since it reschedules itself, this should not be an issue.

Arguments:

	the parameter is ignored

Return Value:

	none
--*/
{
#if		ENABLE_LOGGING
	KIRQL							OldIrql;
	PTRIM_ENTRY						trimEntries = NULL;
	PDEVICE_EXTENSION				deviceExtension;
	NTSTATUS						status;
	FILE_ZERO_DATA_INFORMATION		zeroDataInfo[1];
	IO_STATUS_BLOCK					Iosb[1];
	LARGE_INTEGER					dueTime;

	UNREFERENCED_PARAMETER(parameter);

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	SIS_MARK_POINT();

	if (NULL == trimEventHandle) {
		status = SipCreateEvent(
					SynchronizationEvent,
					&trimEventHandle,
					&trimEvent);

		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
#if		DBG
			DbgPrint("SIS: SipTrimLogs: can't allocate event, 0x%x\n",status);
#endif	// DBG
			goto done;
		}
	}

	//
	// First cruise the device extensions and build up a list of trim entries for them.
	// We need to do it this way (rather than running the list of device extensions directly)
	// because we need to handle the case where a volume is dismounted while we're in progress.
	// If it happens, then we'll have an invalid LogFileHandle, which will cause an error return
	// from the fsctl, which we'll ignore.
	//

	KeAcquireSpinLock(deviceExtensionListLock, &OldIrql);

	for (deviceExtension = deviceExtensionListHead->Next;
		 deviceExtension != deviceExtensionListHead;
		 deviceExtension = deviceExtension->Next) {

		if (deviceExtension->Phase2InitializationComplete && (NULL != deviceExtension->LogFileHandle)) {
			//
			// This is a device with a log file.  Make a new trim entry for it.
			//
			PTRIM_ENTRY	newEntry = ExAllocatePoolWithTag(NonPagedPool, sizeof(TRIM_ENTRY), ' siS');
			if (NULL == newEntry) {
				//
				// Just punt the rest of the volumes.
				//
				break;
			}

			newEntry->next = trimEntries;
			trimEntries = newEntry;

			newEntry->firstValidAddress = deviceExtension->PreviousLogWriteOffset;
			newEntry->logHandle = deviceExtension->LogFileHandle;

			//
			// Now update the device extension so that we'll trim to the current pointer on the
			// next pass.
			//
			deviceExtension->PreviousLogWriteOffset = deviceExtension->LogWriteOffset;
		}
	}

	KeReleaseSpinLock(deviceExtensionListLock, OldIrql);

	//
	// Now we're back at PASSIVE_LEVEL.  Cruise the trim entries and truncate each log file as appropriate.
	//
	zeroDataInfo->FileOffset.QuadPart = 0;

	while (NULL != trimEntries) {
		PTRIM_ENTRY	thisEntry;

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: SipTrimLogs: trimming log with LFH 0x%x.\n",trimEntries->logHandle);
	}
#endif	// DBG

		zeroDataInfo->BeyondFinalZero = trimEntries->firstValidAddress;

		status = ZwFsControlFile(
					trimEntries->logHandle,
					trimEventHandle,
					NULL,							// APC routine
					NULL,							// APC context
					Iosb,
					FSCTL_SET_ZERO_DATA,
					zeroDataInfo,
					sizeof(FILE_ZERO_DATA_INFORMATION),
					NULL,
					0);

		if (STATUS_PENDING == status) {
			status = KeWaitForSingleObject(trimEvent, Executive, KernelMode, FALSE, NULL);
			ASSERT(STATUS_SUCCESS == status);		// Iosb is on the stack, so we can't let this fail
			status = Iosb->Status;
		}

#if		DBG
		if (!NT_SUCCESS(status)) {
			SIS_MARK_POINT_ULONG(status);
			DbgPrint("SIS: SipTrimLogs: FSCTL_ZERO_DATA failed, 0x%x\n",status);
		}
#endif	// DBG

		thisEntry = trimEntries;
		trimEntries = thisEntry->next;

		ExFreePool(thisEntry);
	}

	//
	// We've trimmed every log file in the system.  Rechedule ourselves.
	//

done:

	dueTime.QuadPart = LOG_TRIM_TIMER_INTERVAL;

	KeSetTimerEx(
		LogTrimTimer,
		dueTime,
		0,
		LogTrimDpc);

	return;

#else	// ENABLE_LOGGING

    UNREFERENCED_PARAMETER( parameter );
#endif	// ENABLE_LOGGING
}

VOID
SiLogTrimDpcRoutine(
	IN PKDPC		dpc,
	IN PVOID		context,
	IN PVOID		systemArg1,
	IN PVOID		systemArg2)
{
#if		ENABLE_LOGGING
	ExQueueWorkItem(LogTrimWorkItem,DelayedWorkQueue);

#if		DBG
	if (BJBDebug & 0x20000) {
		DbgPrint("SIS: LogTrimDpcRoutine: queued up log trim.\n");
	}
#endif	// DBG

#else	// ENABLE_LOGGING
    UNREFERENCED_PARAMETER( dpc );
    UNREFERENCED_PARAMETER( context );
    UNREFERENCED_PARAMETER( systemArg1 );
    UNREFERENCED_PARAMETER( systemArg2 );
#endif	// ENABLE_LOGGING
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siread.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siread.c

Abstract:

	Read routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

VOID
SiReadUpdateRanges(
	PVOID					Parameter)
{
	PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext = Parameter;
	PSIS_SCB								scb = updateContext->scb;

	SIS_MARK_POINT_ULONG(updateContext);
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SipAcquireScb(scb);
	
	SipAddRangeToFaultedList(
		updateContext->deviceExtension,
		scb,
		&updateContext->offset,
		updateContext->length);

	scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

	SipReleaseScb(scb);

	SipDereferenceScb(scb,RefsReadCompletion);

	ExFreePool(updateContext);

	return;
}

typedef struct _SI_MULTI_COMPLETE_CONTEXT {
	KEVENT					event[1];
	ULONG					associatedIrpCount;
	KSPIN_LOCK				SpinLock[1];
	IO_STATUS_BLOCK			Iosb[1];
	PIRP					finalAssociatedIrp;
	PDEVICE_EXTENSION		deviceExtension;
	PSIS_SCB				scb;
} SI_MULTI_COMPLETE_CONTEXT, *PSI_MULTI_COMPLETE_CONTEXT;

NTSTATUS
SiMultiReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
	)
{
	PSI_MULTI_COMPLETE_CONTEXT 	Context = (PSI_MULTI_COMPLETE_CONTEXT)Contxt;
	PIO_STACK_LOCATION			irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN						truncated;
	KIRQL						OldIrql;

	SIS_MARK_POINT_ULONG(irpSp->Parameters.Read.ByteOffset.LowPart);
	SIS_MARK_POINT_ULONG(Irp->IoStatus.Information);

	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = Context->scb->PerLink->CsFile->DeviceObject;

	truncated = (irpSp->Parameters.Read.Length != Irp->IoStatus.Information);

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
//		DbgPrint("SIS: SiMultiReadCompletion: failed status 0x%x\n",Irp->IoStatus.Status);
#endif	// DBG

		KeAcquireSpinLock(Context->SpinLock, &OldIrql);
		*Context->Iosb = Irp->IoStatus;
		KeReleaseSpinLock(Context->SpinLock, OldIrql);
	} else if (Irp->Flags & IRP_PAGING_IO) {
		//
		// We need to update the faulted range for the file.  If we're at
		// dispatch level, we can't acquire the SCB in order to do it, so
		// we'll "post" the work.
		//
		if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
			PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;
		
			SIS_MARK_POINT();

			updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
			if (NULL == updateContext) {
				//
				// Just fail the whole thing.
				//
				SIS_MARK_POINT();
				KeAcquireSpinLock(Context->SpinLock, &OldIrql);
				Context->Iosb->Status = STATUS_INSUFFICIENT_RESOURCES;
				KeReleaseSpinLock(Context->SpinLock, OldIrql);

				goto done;
			}

			SIS_MARK_POINT_ULONG(updateContext);
			ASSERT(DeviceObject);

			SipReferenceScb(Context->scb,RefsReadCompletion);

			updateContext->scb = Context->scb;
			updateContext->offset = irpSp->Parameters.Write.ByteOffset;
			updateContext->length = (ULONG)Irp->IoStatus.Information;
			updateContext->deviceExtension = DeviceObject->DeviceExtension;

			ExInitializeWorkItem(
				updateContext->workQueueItem,
				SiReadUpdateRanges,
				(PVOID)updateContext);

			ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
				
		} else {
			SipAcquireScb(Context->scb);

			SipAddRangeToFaultedList(
				Context->deviceExtension,
				Context->scb,
				&irpSp->Parameters.Read.ByteOffset,
				Irp->IoStatus.Information);

			Context->scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			SipReleaseScb(Context->scb);
		}

		if (truncated) {
			SIS_MARK_POINT_ULONG(Context->scb);

#if		DBG
			DbgPrint("SIS: SiMultiReadCompletion: truncated scb 0x%x\n",Context->scb);
#endif	// DBG

			KeAcquireSpinLock(Context->SpinLock, &OldIrql);
			if (Irp != Context->finalAssociatedIrp) {
				Context->Iosb->Status = STATUS_END_OF_FILE;	// What's the right status for this?
			}
			Context->Iosb->Information -= (irpSp->Parameters.Read.Length - Irp->IoStatus.Information);
			KeReleaseSpinLock(Context->SpinLock, OldIrql);
		}
	}

done:

	if (InterlockedDecrement(&Context->associatedIrpCount) == 0) {
		KeSetEvent(Context->event, IO_NO_INCREMENT, FALSE);
	}

	IoFreeMdl(Irp->MdlAddress);
	IoFreeIrp(Irp);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SiReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

	A read has completed.  This completion routine is only used when we may need to
	add a range into the faulted list for a file (we may not because there may have
	been an overlapping read or write that already added it to the list).  We're
	passed an SCB (and a reference to the SCB) as our context pointer.

Arguments:

    DeviceObject - Pointer to the device on which the file was read

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - The scb for the file stream that's being read.

Return Value:

	STATUS_SUCCESS

--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PSIS_SCB				scb = (PSIS_SCB)Context;

	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = scb->PerLink->CsFile->DeviceObject;

	SIS_MARK_POINT_ULONG(scb);

	//
	// If the read failed, it can't have faulted in anything, so we can
	// ignore it.  Otherwise, add the read region into the faulted list.
	//
	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		if (Irp->Flags & IRP_PAGING_IO) {
			//
			// We need to update the faulted range for the file.  If we're at
			// dispatch level, we can't acquire the SCB in order to do it, so
			// we'll "post" the work.
			//
			if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
				PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;

				updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
				if (NULL == updateContext) {
					//
					// Just fail the irp.
					//
					SIS_MARK_POINT();
					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					Irp->IoStatus.Information = 0;

					goto done;
				}

				SipReferenceScb(scb,RefsReadCompletion);

				SIS_MARK_POINT_ULONG(updateContext);
				ASSERT(DeviceObject);

				updateContext->scb = scb;
				updateContext->offset = irpSp->Parameters.Write.ByteOffset;
				updateContext->length = (ULONG)Irp->IoStatus.Information;
				updateContext->deviceExtension = DeviceObject->DeviceExtension;

				ExInitializeWorkItem(
					updateContext->workQueueItem,
					SiReadUpdateRanges,
					(PVOID)updateContext);

				ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
				
			} else {

				//
				// Now add the newly read range to the "faulted" area for this stream.
				// This call won't do any harm if some of the read is already faulted
				// or written.  
				//

				SipAcquireScb(scb);
	
				SipAddRangeToFaultedList(
					(PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					scb,
					&irpSp->Parameters.Read.ByteOffset,
					Irp->IoStatus.Information);

				scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

				SipReleaseScb(scb);
			}
		} else {
			//
			// If the file object is synchronous, we need to update
			// the CurrentByteOffset.
			//
			PFILE_OBJECT fileObject = irpSp->FileObject;

			if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
				fileObject->CurrentByteOffset.QuadPart =
					irpSp->Parameters.Read.ByteOffset.QuadPart +
					Irp->IoStatus.Information;
			}
		}
	} else {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);

#if		DBG
//		DbgPrint("SIS: SiReadCompletion failed with status 0x%x\n",Irp->IoStatus.Status);
#endif	// DBG
	}

done:

	//
	// Drop the reference to the scb that SiRead acquired for us.
	//
	SipDereferenceScb(scb, RefsRead);

    //
    // Propogate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;
	
}

NTSTATUS
SipWaitForOpbreak(
	IN PSIS_PER_FILE_OBJECT			perFO,
	IN BOOLEAN						Wait)
/*++

Routine Description:

	We need to wait for an oplock break to happen on this per-FO.  If necessary,
	allocate an event, and then wait for the break to happen.

	Must be called with IRQL < DISPATCH_LEVEL

Arguments:

	perFO - the perFO for the file object on which we're to wait.

Return Value:

	status of the wait
--*/
{
	KIRQL					OldIrql;
	NTSTATUS				status;

	KeAcquireSpinLock(perFO->SpinLock, &OldIrql);

	ASSERT(OldIrql < DISPATCH_LEVEL);

	if (!(perFO->Flags & SIS_PER_FO_OPBREAK)) {
		//
		// If we ever see this clear, we'll never see it set again, because it
		// can only get set when the perFO is created.
		//

//		SIS_MARK_POINT_ULONG(perFO);
		KeReleaseSpinLock(perFO->SpinLock, OldIrql);

		return STATUS_SUCCESS;
	}

	SIS_MARK_POINT_ULONG(perFO);

	if (!Wait) {
#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SipWaitForOpbreak: can't wait for perFO %p, FO %p\n",perFO,perFO->fileObject);
		}
#endif	// DBG

		KeReleaseSpinLock(perFO->SpinLock, OldIrql);

		return STATUS_CANT_WAIT;
	}

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SipWaitForOpbreak: waiting for perFO %p, FO %p\n",perFO,perFO->fileObject);
	}
#endif	// DBG

	if (NULL == perFO->BreakEvent) {

		ASSERT(!(perFO->Flags & SIS_PER_FO_OPBREAK_WAITERS));

		perFO->BreakEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'BsiS');

		if (NULL == perFO->BreakEvent) {
			KeReleaseSpinLock(perFO->SpinLock, OldIrql);
			SIS_MARK_POINT_ULONG(perFO);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

#if		DBG
		if (BJBDebug & 0x2000) {
			DbgPrint("SIS: SipWaitForOpbreak: allocated event for perFO %p at %p\n",perFO,perFO->BreakEvent);
		}
#endif	// DBG

		KeInitializeEvent(perFO->BreakEvent, NotificationEvent, FALSE);
	}
	perFO->Flags |= SIS_PER_FO_OPBREAK_WAITERS;
	ASSERT(NULL != perFO->BreakEvent);

	//
	// Drop the lock on the perFO and wait for the oplock break to complete.
	//
	KeReleaseSpinLock(perFO->SpinLock, OldIrql);

	status = KeWaitForSingleObject(perFO->BreakEvent, Executive, KernelMode, FALSE, NULL);

#if		DBG
	if (BJBDebug & 0x2000) {
		DbgPrint("SIS: SipWaitForOpbreak: break completed, status %x, perFO %p\n",status,
					perFO);
	}
#endif	// DBG


	if (status != STATUS_SUCCESS) {
		SIS_MARK_POINT_ULONG(status);
		return status;
	}

	SIS_MARK_POINT_ULONG(perFO);

	return STATUS_SUCCESS;
}

#define	ASSOCIATED_IRPS_PER_BLOCK		5
typedef struct _ASSOCIATED_IRP_BLOCK {
	PIRP							irps[ASSOCIATED_IRPS_PER_BLOCK];
	struct _ASSOCIATED_IRP_BLOCK	*Next;
} ASSOCIATED_IRP_BLOCK, *PASSOCIATED_IRP_BLOCK;

NTSTATUS
SipCommonRead(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
	IN BOOLEAN				Wait)

/*++

Routine Description:

	This function handles read operations.  Check to see if the file object is a
	SIS file.  If so, handle the read, otherwise pass it through.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the result of the read, or the
	status of the call to the file system's entry point in the case of a
	pass-through call.

--*/

{
    PIO_STACK_LOCATION 		irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION		nextIrpSp;
	PFILE_OBJECT 			fileObject = irpSp->FileObject;
	PDEVICE_EXTENSION		deviceExtension;
	LARGE_INTEGER 			byteOffset;
	ULONG 					readLength;
	PSIS_SCB 				scb;
	NTSTATUS 				status;
	PSIS_CS_FILE			CSFile;
	PSIS_PER_LINK			perLink;
	PSIS_PER_FILE_OBJECT	perFO;
    BOOLEAN 				PagingIo;
    BOOLEAN 				NonCachedIo;
	BOOLEAN					ToCSFile;
	SIS_RANGE_DIRTY_STATE 	rangeDirty;
	KIRQL					OldIrql;
	ASSOCIATED_IRP_BLOCK	HeaderBlock[1];

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;
    NonCachedIo = (Irp->Flags & IRP_NOCACHE) ? TRUE : FALSE;

	if (!PagingIo) {	
		//
		// Check to be sure that this file object isn't a complete-if-oplocked
		// create that hasn't yet had the oplock break ack'ed.  We need to do this
		// here because we might want to redirect the call to the common store
		// file, which doesn't have an oplock on it.
		//

		status = SipWaitForOpbreak(perFO, Wait);

		if (STATUS_CANT_WAIT == status) {
			//
			// Post the request.
			//
			SIS_MARK_POINT_ULONG(scb);

			ASSERT(!Wait);

			goto Post;
		}

		if (!NT_SUCCESS(status)) {
			//
			// The check for opbreak failed, probably because of a memory allocation failure.
			// Fail the entire read with the same status.
			//
			SIS_MARK_POINT_ULONG(status);

			goto fail;
		}
	}

	perLink = scb->PerLink;
	CSFile = perLink->CsFile;

	byteOffset = irpSp->Parameters.Read.ByteOffset;
	readLength = irpSp->Parameters.Read.Length;

	SIS_MARK_POINT_ULONG(scb);
	SIS_MARK_POINT_ULONG(byteOffset.LowPart);
	SIS_MARK_POINT_ULONG(readLength);
	SIS_MARK_POINT_ULONG(PagingIo << 1 | NonCachedIo);

#if		DBG
	if (BJBDebug & 0x4000) {
		DbgPrint("SIS: SiRead: perFO %p, scb %p, bo.Low 0x%x, rel 0x%x, PIO %d, NC %d\n",
				perFO,scb,byteOffset.LowPart,readLength,PagingIo, NonCachedIo);
	}
#endif	// DBG

	//
	// Figure out if there's anything in the copied file.  If not, then redirect the read to
	// the CS file.  If there is, then cached reads go to the copied file and noncached reads
	// depend on whether the range is dirty.
	//
	SipAcquireScb(scb);

	if (!(scb->Flags & SIS_SCB_ANYTHING_IN_COPIED_FILE)) {
		//
		// There's nothing in the copied file, 
		// so we just go to the CS file.
		//

		//
		// Since we're redirecting to the common store file, we need to check for file locks
		// ourself, since NTFS's version of the locks are only on the link/copied file.
		//

		// We have to check for read access according to the current
		// state of the file locks.
		
		if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
			SipReleaseScb(scb);

			status = STATUS_FILE_LOCK_CONFLICT;
			Irp->IoStatus.Information = 0;
			
			SIS_MARK_POINT_ULONG(scb);
			goto fail;
		}

		SipReleaseScb(scb);

		SIS_MARK_POINT_ULONG(scb);

		ToCSFile = TRUE;
	} else if (!NonCachedIo) {
		//
		// This is a cached read into a file that's got something in the copied file.
		// Send the read to the copied file.
		//
		SipReleaseScb(scb);

		SIS_MARK_POINT_ULONG(scb);

		ASSERT(!PagingIo);
		ToCSFile = FALSE;
	} else {
		//
		// The file's dirty and we're doing noncached IO to it.  Decide which way to send
		// the request depending on where there have been writes.
		//

		rangeDirty = SipGetRangeDirty(
						deviceExtension,
						scb,
						&byteOffset,
						(LONGLONG)readLength,
						FALSE);					// faultedIsDirty

		if ((Mixed == rangeDirty)
			&& (byteOffset.QuadPart < scb->SizeBackedByUnderlyingFile) 
			&& (byteOffset.QuadPart + readLength > scb->SizeBackedByUnderlyingFile)) {

			//
			// This is a noncached read that crosses SizeBacked, and that reports Mixed.  For paging IO, we know
			// that we can just send this to the CS file.  For user noncached reads we need to assure that
			// the file is clean (because otherwise we could lose coherence between cached writes and noncached
			// reads).
			//
			if (PagingIo) {
				SIS_MARK_POINT_ULONG(scb);
				rangeDirty = Clean;
			} else {
				//
				// Check to see if the file is dirty.  
				// NTRAID#65194-2000/03/10-nealch  The DIRTY flag should be in the scb, not the per link
				//
				KeAcquireSpinLock(perLink->SpinLock, &OldIrql);
				if (!(perLink->Flags & SIS_PER_LINK_DIRTY)) {
					SIS_MARK_POINT_ULONG(scb);
					rangeDirty = Clean;
				}
				KeReleaseSpinLock(perLink->SpinLock, OldIrql);
			}
		}

		if (rangeDirty == Dirty) {
			SIS_MARK_POINT_ULONG(scb);

			SipReleaseScb(scb);

			ToCSFile = FALSE;
		} else if (rangeDirty == Clean) {
			//
			// The entire range is clean, so we can read it in just one run from the CS file.
			//
			SIS_MARK_POINT_ULONG(scb);

			//
			// Since we're redirecting to the common store file, we need to check for file locks
			// ourself, since NTFS's version of the locks are only on the link/copied file.
			//

			// We have to check for read access according to the current
			// state of the file locks.
		
			if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
				SipReleaseScb(scb);

				status = STATUS_FILE_LOCK_CONFLICT;
				Irp->IoStatus.Information = 0;
			
				SIS_MARK_POINT_ULONG(scb);
				goto fail;
			}

			SipReleaseScb(scb);

			ToCSFile = TRUE;
		} else {
			//
			// Some of the range is in the copied file and some is in the CS file.  Break the
			// request into pieces and send it down appropriately.
			//

			LONGLONG					currentOffset;
			PASSOCIATED_IRP_BLOCK		currentBlock = HeaderBlock;
			ULONG						blockIndex = 0;
			ULONG						associatedIrpCount = 0;
			SI_MULTI_COMPLETE_CONTEXT	Context[1];
			PIO_STACK_LOCATION			ourIrpSp;

			SIS_MARK_POINT_ULONG(scb);

			// We have to check for read access according to the current
			// state of the file locks.
		
			if (!PagingIo && !FsRtlCheckLockForReadAccess(&scb->FileLock, Irp)) {
				SipReleaseScb(scb);

				status = STATUS_FILE_LOCK_CONFLICT;
				Irp->IoStatus.Information = 0;
			
				SIS_MARK_POINT_ULONG(scb);
				goto fail;
			}

			ASSERT(rangeDirty == Mixed);

			status = SipLockUserBuffer(Irp,IoWriteAccess,readLength);
			if (!NT_SUCCESS(status)) {
				SipReleaseScb(scb);
				SIS_MARK_POINT_ULONG(status);
				goto fail;
			}

			RtlZeroMemory(HeaderBlock, sizeof(ASSOCIATED_IRP_BLOCK));

			//
			// Loop over all  of the ranges in the request, building up an associated Irp
			// for each of them.
			//
			currentOffset = byteOffset.QuadPart;
			while (currentOffset < byteOffset.QuadPart + readLength) {
				LONGLONG			rangeLength;
				SIS_RANGE_STATE		rangeState;
				PMDL				Mdl;
				PIRP				localIrp;

				associatedIrpCount++;

				if (blockIndex == ASSOCIATED_IRPS_PER_BLOCK) {
                    currentBlock->Next = ExAllocatePoolWithTag(NonPagedPool,
                                                               sizeof(ASSOCIATED_IRP_BLOCK),
                                                               ' siS');

					if (currentBlock->Next == NULL) {
						status = STATUS_INSUFFICIENT_RESOURCES;
						SIS_MARK_POINT();
						break;
					}
					currentBlock = currentBlock->Next;
					blockIndex = 0;
					RtlZeroMemory(currentBlock, sizeof(ASSOCIATED_IRP_BLOCK));
				}

				if (currentOffset >= scb->SizeBackedByUnderlyingFile) {
					//
					// We're looking at data that's exclusively beyond the portion of the
					// file that's not backed by the underlying file.  It's "Written" and extends
					// all the way to the end of the read.
					//

					SIS_MARK_POINT_ULONG(currentOffset);

					rangeState = Written;
					rangeLength = byteOffset.QuadPart + readLength - currentOffset;
				} else {
					BOOLEAN 			foundRange;

					foundRange = SipGetRangeEntry(
									deviceExtension,
									scb,
									currentOffset,
									&rangeLength,
									&rangeState);

					if (!foundRange) {
						SIS_MARK_POINT_ULONG(currentOffset);

						rangeState = Untouched;
						rangeLength = byteOffset.QuadPart + readLength - currentOffset;
					} else if (currentOffset + rangeLength > byteOffset.QuadPart + readLength) {
						//
						// The range extends beyond the end of the read.  Truncate it.
						//
						rangeLength = byteOffset.QuadPart + readLength - currentOffset;
					}
				}
				ASSERT(rangeLength > 0 && rangeLength <= byteOffset.QuadPart + readLength - currentOffset);
				ASSERT(rangeLength < MAXULONG);

				localIrp = currentBlock->irps[blockIndex] = 
							IoMakeAssociatedIrp(
									Irp, 
									(CCHAR)(DeviceObject->StackSize + 1));

				if (NULL == localIrp) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}

				//
				// Set the paging, noncached and synchronous paging flags in the associated irp, if appropriate.
				//
				if (PagingIo) {
					localIrp->Flags |= IRP_PAGING_IO;
				}
				if (NonCachedIo) {
					localIrp->Flags |= IRP_NOCACHE;
				}
				if (Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO) {
					localIrp->Flags |= IRP_SYNCHRONOUS_PAGING_IO;
				}

				//
				// Setup the UserBuffer address in the associated irp.
				//
				localIrp->UserBuffer = (PCHAR)Irp->UserBuffer + (ULONG)(currentOffset - byteOffset.QuadPart);


				Mdl = IoAllocateMdl(
						(PCHAR)Irp->UserBuffer +
							(ULONG)(currentOffset - byteOffset.QuadPart),
						(ULONG)rangeLength,
						FALSE,
						FALSE,
						localIrp);
							

				if (Mdl == NULL) {
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}

				ASSERT(Mdl == localIrp->MdlAddress);

				IoBuildPartialMdl(
					Irp->MdlAddress,
					Mdl,
					(PCHAR)Irp->UserBuffer +
						(ULONG)(currentOffset - byteOffset.QuadPart),
					(ULONG)rangeLength);


				IoSetNextIrpStackLocation(localIrp);
				ourIrpSp = IoGetCurrentIrpStackLocation(localIrp);
				ourIrpSp->Parameters.Read.Length = (ULONG)rangeLength;
				ourIrpSp->Parameters.Read.ByteOffset.QuadPart = currentOffset;

				nextIrpSp = IoGetNextIrpStackLocation(localIrp);

				RtlCopyMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

				nextIrpSp->Parameters.Read.Length = (ULONG)rangeLength;
				nextIrpSp->Parameters.Read.ByteOffset.QuadPart = currentOffset;

				if ((rangeState == Untouched) || (rangeState == Faulted)) {
					//
					// This range needs to go down to the CS file.
					//
					SIS_MARK_POINT_ULONG(currentOffset);

					nextIrpSp->FileObject = CSFile->UnderlyingFileObject;
				} else {
					SIS_MARK_POINT_ULONG(currentOffset);
				}

				IoSetCompletionRoutine(
					localIrp,
					SiMultiReadCompletion,
					Context,
					TRUE,
					TRUE,
					TRUE);
		
				Context->finalAssociatedIrp = localIrp;

				blockIndex++;
				currentOffset += rangeLength;
			}

			SipReleaseScb(scb);

			if (NT_SUCCESS(status)) {
				//
				// Everything that could have failed has been tried, and didn't
				// fail.  Send the irps down.
				//
				Irp->AssociatedIrp.IrpCount = associatedIrpCount;

				KeInitializeEvent(Context->event, NotificationEvent, FALSE);
				Context->associatedIrpCount = associatedIrpCount;
				KeInitializeSpinLock(Context->SpinLock);
				Context->Iosb->Status = STATUS_SUCCESS;
				Context->Iosb->Information = readLength;
				Context->deviceExtension = deviceExtension;
				Context->scb = scb;

				if (Wait || 1 /*BJB - fixme*/) {
					//
					// If we're waiting, then we're going to complete the
					// master Irp, and so we want to prevent the IO system
					// from doing it for us.
					//
					Irp->AssociatedIrp.IrpCount++;
				}

				currentBlock = HeaderBlock;
				while (currentBlock) {
					for (blockIndex = 0; blockIndex < ASSOCIATED_IRPS_PER_BLOCK; blockIndex++) {
						if (currentBlock->irps[blockIndex]) {
							IoCallDriver(
								deviceExtension->AttachedToDeviceObject,
								currentBlock->irps[blockIndex]);
						} else {
							ASSERT(NULL == currentBlock->Next);
							break;
						}
					}
					currentBlock = currentBlock->Next;
				}
			}

			//
			// Free any extra associated irp blocks we may have allocated.
			//
			while (NULL != HeaderBlock->Next) {
				PASSOCIATED_IRP_BLOCK next = HeaderBlock->Next;

				//
				// If the allocation failed, free any Irps and MDLs as well as the
				// blocks.
				//
				if (!NT_SUCCESS(status)) {
					ULONG i;
					for (i = 0; i < ASSOCIATED_IRPS_PER_BLOCK; i++) {
						if (next->irps[i]) {
							if (next->irps[i]->MdlAddress) {
								IoFreeMdl(next->irps[i]->MdlAddress);
							}
							IoFreeIrp(next->irps[i]);
						}
					}
				}

				HeaderBlock->Next = next->Next;
				ExFreePool(next);
			}

			if (!NT_SUCCESS(status)) {
				goto fail;
			}

			if (Wait || 1 /*BJB - fixme*/) {
				KeWaitForSingleObject(Context->event, Executive, KernelMode, FALSE, NULL);

				Irp->IoStatus = *Context->Iosb;
				IoCompleteRequest(Irp, IO_NO_INCREMENT);
				return Context->Iosb->Status;
			} else {
				return STATUS_PENDING;
			}
		}
	}


	//
	// Now forward the read down to NTFS on the file object that we decided
	// above.  Note that we're intentionally not truncating the read size,
	// even if we did so above, because NTFS will do its own truncation
	// and its own synchronization on the file object.
	//

	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlCopyMemory(nextIrpSp, irpSp, sizeof(IO_STACK_LOCATION));

	if (ToCSFile) {
		nextIrpSp->FileObject = CSFile->UnderlyingFileObject;
		ASSERT(NULL != nextIrpSp->FileObject);
	} else if (NonCachedIo) {
		SIS_MARK_POINT_ULONG(scb);
	}

	//
	// Tell the IO system that we need to see completions on this irp.
	// Grab a reference to the scb for the completion routine.
	//

	SipReferenceScb(scb, RefsRead);

	IoSetCompletionRoutine(
		Irp, 
		SiReadCompletion, 
		scb,
		TRUE, 
		TRUE, 
		TRUE);

	//
	// And send it to NTFS.
	//
	return IoCallDriver(
				deviceExtension->AttachedToDeviceObject, 
				Irp);

fail:

	SIS_MARK_POINT_ULONG(scb);

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;

Post:

	SIS_MARK_POINT_ULONG(scb);

	status = SipPostRequest(
				DeviceObject,
				Irp,
				FSP_REQUEST_FLAG_NONE);

	if (!NT_SUCCESS(status)) {
		//
		// We couldn't post the irp.  Fail the read.
		//
		SIS_MARK_POINT_ULONG(status);

		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;

		IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return status;
	}

	return STATUS_PENDING;
}

NTSTATUS
SiRead(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp)
{
	SipHandleControlDeviceObject(DeviceObject, Irp);

	return SipCommonRead(DeviceObject,Irp,IoIsOperationSynchronous(Irp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sip.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    sip.h

Abstract:

    Private data structure definitions for the Single Instance Store.

Author:

    Bill Bolosky        [bolosky]       July 1997

Revision History:

--*/

#ifndef     _SIp_
#define     _SIp_


#include "ntifs.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "ntiologc.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "sis.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

//
//  Debug definitions
//

#define ENABLE_LOGGING                  0   // enable support for transaction logging and failure recovery
#define ENABLE_PARTIAL_FINAL_COPY       0   // enable copying out only into allocated ranges
#define INTERRUPTABLE_FINAL_COPY        1   // allow final copies (in cow.c) to stop in progress
#define TIMING                          0   // timing instrumentation (should be off in most builds)
#define RANDOMLY_FAILING_MALLOC         0   // debugging code to test what happens when ExAllocatePool fails randomly (off in most builds)
#define COUNTING_MALLOC                 0   // debugging code to track dynamic memory usage (off in most builds)


#ifndef INLINE
#define INLINE __inline
#endif


//
// this is a COPY of ntfs\nodetype.h data. this MUST be cleaned up
// NTRAID#65193-2000/03/10-nealch  Remove NTFS_NTC_SCB_DATA definition
//
#define NTFS_NTC_SCB_DATA   ((CSHORT)0x0705)

//
// Memory Pool tags used by SIS.
//

// BsiS -   BreakEvent in a perFO
// CsiS -   CSFile objects
// FsiS -   per file object
// LsiS -   per link objects
// SsiS -   SCB

#define SIS_POOL_TAG    ' siS'          // anything else


//
//  Local name buffer size (in WCHAR's)
//

#define MAX_DEVNAME_LENGTH  256


//
//  Our local DbgPrintEx() filter flag values
//

#define DPFLTR_VOLNAME_TRACE_LEVEL      31  //  trace volume name
#define DPFLTR_FSCONTROL_TRACE_LEVEL    30  //  trace FSCONTROL's   (0x00000400)
#define DPFLTR_DISMOUNT_TRACE_LEVEL     29  //  trace DISMOUNTS     (0x08000000)

//
//  Internal debug information
//

#if     DBG
extern PVOID    BJBMagicFsContext;
extern unsigned BJBDebug;
// BJB Debug Bits       0x00000001  Print all SiClose calls
//                      0x00000002  Print all create completions
//                      0x00000004  Print when SipIsFileObjectSIS allocates a new perFO
//                      0x00000008  Intentionally fail copies of alternate streams
//                      0x00000010  Prints in siinfo
//                      0x00000020  Prints all scbs going through cleanup
//                      0x00000040  Prints all filenames coming into create
//                      0x00000080  Always fail opens as if DELETE_IN_PROGRESS
//                      0x00000100  Allow opens with bogus checksum
//                      0x00000200  Print out CS file checksum info
//                      0x00000400  Breakpoint when SiFsControl is called with an unknown control code
//                      0x00000800  Prints in copyfile
//                      0x00001000  Print all fscontrol calls
//                      0x00002000  Print stuff related to complete-if-oplocked
//                      0x00004000  Print all reads
//                      0x00008000  Print all writes
//                      0x00010000  Print setEof calls
//                      0x00020000  Print stuff in TrimLog code
//                      0x00040000  Print out unexpected cleanups
//                      0x00080000  Assert on volume check initiation
//                      0x00100000  Print newly opened dirty files
//                      0x00200000  Disable final copy (for testing purposes)
//                      0x00400000  Don't check security in LINK_FILES fsctl.
//                      0x00800000  Intentionally fail SET_REPARSE_POINT calls
//                      0x01000000  Intentionally fail final copy
//                      0x02000000  Don't Print out all intentionally failed mallocs
//                      0x04000000  Always post filter context freed callbacks
//                      0x08000000  Print on dismount actions
//                      0x10000000  Open with FILE_SHARE_WRITE attribute

//                      0x0817fa77  Value to set if you want all debug prints
#endif  // DBG


// IoFileObjectType is a data import, and hence is a pointer in this module's
// import address table referring to the actual variable in ntoskrnl.exe.
//

extern POBJECT_TYPE *IoFileObjectType;          // shouldn't this come from somewhere else??

#define GCH_MARK_POINT_STRLEN       80
#define GCH_MARK_POINT_ROLLOVER     512
extern LONG GCHEnableFastIo;
extern LONG GCHEnableMarkPoint;
extern LONG GCHMarkPointNext;
extern CHAR GCHMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];
extern KSPIN_LOCK MarkPointSpinLock[1];

#if     DBG
#define SIS_MARK_POINT()        SipMarkPoint(__FILE__, __LINE__)
#define SIS_MARK_POINT_ULONG(value) SipMarkPointUlong(__FILE__, __LINE__, (ULONG_PTR)(value));
#else
#define SIS_MARK_POINT()
#define SIS_MARK_POINT_ULONG(value)
#endif

#if     TIMING
#define SIS_TIMING_POINT_SET(n) SipTimingPoint(__FILE__, __LINE__, n)
#define SIS_TIMING_POINT()  SipTimingPoint(__FILE__, __LINE__, 0)

//
// Timimg classes.  These can be enabled and disabled dynamically.
// They must be limited to 0-31.  Class 0 is resrved for the
// "unnamed" class, and is accessed by using SIS_TIMING_POINT()
// (ie., by not specifying a class in the timing point).
//
#define SIS_TIMING_CLASS_CREATE     1
#define SIS_TIMING_CLASS_COPYFILE   2

#else   // TIMING
#define SIS_TIMING_POINT_SET(n)
#define SIS_TIMING_POINT()
#endif  // TIMING

#if     RANDOMLY_FAILING_MALLOC
#define ExAllocatePoolWithTag(poolType, size, tag)  SipRandomlyFailingExAllocatePoolWithTag((poolType),(size),(tag),__FILE__,__LINE__)

VOID *
SipRandomlyFailingExAllocatePoolWithTag(
    IN POOL_TYPE        PoolType,
    IN ULONG            NumberOfBytes,
    IN ULONG            Tag,
    IN PCHAR            File,
    IN ULONG            Line);

VOID
SipInitFailingMalloc(void);

#elif   COUNTING_MALLOC
//
// This is the definition of ExAllocatePoolWithTag for COUNTING_MALLOC and not RANDOMLY_FAILING_MALLOC.
// If both are on, the user calls RANDOMLY_FAILING_MALLOC, which in turn calls the counting malloc
// directly.
//
#define ExAllocatePoolWithTag(poolType, size, tag)  SipCountingExAllocatePoolWithTag((poolType),(size),(tag), __FILE__, __LINE__)
#endif  // RANDOMLY_FAILING_MALLOC / COUNTING_MALLOC

#if     COUNTING_MALLOC
#define ExFreePool(p) SipCountingExFreePool((p))

VOID *
SipCountingExAllocatePoolWithTag(
    IN POOL_TYPE        PoolType,
    IN ULONG            NumberOfBytes,
    IN ULONG            Tag,
    IN PCHAR            File,
    IN ULONG            Line);

VOID
SipCountingExFreePool(
    PVOID               p);

VOID
SipInitCountingMalloc(void);

VOID
SipDumpCountingMallocStats(void);
#endif  // COUNTING_MALLOC

#if DBG

#undef ASSERT
#undef ASSERTMSG

VOID
SipAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    ((!(exp)) ? SipAssert( #exp, __FILE__, __LINE__, NULL ) : ((void)0))

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? SipAssert( #exp, __FILE__, __LINE__, msg ) : ((void)0))

#endif // DBG

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) (!memcmp((guid1),(guid2), sizeof(GUID)))
#endif  // IsEqualGUID


extern PDRIVER_OBJECT FsDriverObject;
extern PDEVICE_OBJECT FsNtfsDeviceObject;
extern PDEVICE_OBJECT SisControlDeviceObject;

//
// Splay tree support.
//

//
//  The comparison function takes as input a pointer to a user defined
//  key structure, and a pointer to a tree node.  It returns the results
//  of comparing the key and the node.
//

typedef
LONG
(NTAPI *PSIS_TREE_COMPARE_ROUTINE) (
    PVOID Key,
    PVOID Node
    );

typedef struct _SIS_TREE {

    PRTL_SPLAY_LINKS            TreeRoot;
    PSIS_TREE_COMPARE_ROUTINE   CompareRoutine;

} SIS_TREE, *PSIS_TREE;

//
// Define the device extension structure for this driver's extensions.
//

typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// SIS structure for a common store file opened by SIS.
//
typedef struct _SIS_CS_FILE {
    //
    // This structure is stored in a splay tree.  The splay links must be first.
    //
    RTL_SPLAY_LINKS                     Links;

    //
    // Count of the number of SIS_PER_LINKs that reference this common store file.  Protected by
    // the CSFileSpinLock in the device extension.
    //
    unsigned                            RefCount;

    //
    // A spin lock to protect some of the fields here.
    //
    KSPIN_LOCK                          SpinLock[1];

    //
    // The file object for the actual NTFS common store file.
    //
    PFILE_OBJECT                        UnderlyingFileObject;
    HANDLE                              UnderlyingFileHandle;

    //
    // A handle and file object for the backpointer stream.  This also contains the contents
    // checksum.
    //
    HANDLE                              BackpointerStreamHandle;
    PFILE_OBJECT                        BackpointerStreamFileObject;

    //
    // Various one-bit flags.  Protected by SpinLock.
    //
    ULONG                               Flags;

#define CSFILE_NTFSID_SET                       0x00000001  // Is CSFileNtfsId set in the structure?
#define CSFILE_FLAG_DELETED                     0x00000002  // The common store contents have been deleted
#define CSFILE_NEVER_HAD_A_REFERENCE            0x00000004  // Is this a newly created CS file that has never had a reference to it?
#define CSFILE_FLAG_CORRUPT                     0x00000008  // The backpointer stream is corrupt

    //
    // The size of the file.
    //
    LARGE_INTEGER                       FileSize;

    //
    // The SIS common store file id (which is also the name of the file within the
    // common store directory).
    //
    CSID                                CSid;

    //
    // The NTFS file index for the common store file.
    //
    LARGE_INTEGER                       CSFileNtfsId;

    //
    // The checksum for the contents of the common store file.
    //
    LONGLONG                            Checksum;

    //
    // A cache of recently validated backpointers for this file and an index that
    // represents the next entry to overwrite.
    //
#define SIS_CS_BACKPOINTER_CACHE_SIZE   5
    SIS_BACKPOINTER                     BackpointerCache[SIS_CS_BACKPOINTER_CACHE_SIZE];
    ULONG                               BPCacheNextSlot;

    PDEVICE_OBJECT                      DeviceObject;

    //
    // The number of entries allocated to the backpointer stream.  Note that this
    // is NOT the same as the file reference count, as some of these entries may
    // be deallocated.  Note also that this count is not necessarily 100% accurate,
    // but rather may refer to anywhere in the last sector of the file.
    //
    ULONG                               BPStreamEntries;

    //
    // A resource for controlling access to the backpoionter stream.
    //
    ERESOURCE                           BackpointerResource[1];

    KMUTANT                             UFOMutant[1];
} SIS_CS_FILE, *PSIS_CS_FILE;

//
// The per-link-file object.  There is one of these for each open SIS link file
// in the system, regardless of the number of times that link file is opened.
// This is roughly analogous to an FCB in NTFS.
//
typedef struct _SIS_PER_LINK {
    //
    // This structure is stored in a splay tree.  The splay links must be first.
    //
    RTL_SPLAY_LINKS                     Links;

    //
    // Pointer to the SIS_CS_FILE object for this link file.
    //
    PSIS_CS_FILE                        CsFile;

    //
    // The index of this link file.
    //
    LINK_INDEX                          Index;

    //
    // The NTFS file index for the link file object.
    //
    LARGE_INTEGER                       LinkFileNtfsId;

    //
    // Reference count (number of SCB objects that point at this link object).
    //
    ULONG                               RefCount;

    //
    // Various 1-bit long things
    //
    ULONG                               Flags;

    //
    // The thread that's doing the copy-on-write operation on this file.
    //
    PETHREAD                            COWingThread;


    KSPIN_LOCK                          SpinLock[1];

    //
    // We keep track of the count of threads executing delete or undelete requests in order to
    // make sure that we only have one kind of request in the system at a time.  We need to
    // serialize them so that we're sure what NTFS thinks the delete disposition is when it
    // comes time to delete a file.  If we need to block, we set the SIS_PER_LINK_DELETE_WAITERS
    // flag and wait on perLink->Event.  If the count is non-zero, it represents undeletes if
    // and only if the SIS_PER_LINK_UNDELETE_IN_PROGRESS flag is set.
    //
    ULONG                               PendingDeleteCount;

    //
    // An event that's set when the final copy is completed if there
    // are any final copy waiters.
    //
    KEVENT                              Event[1];

    //
    // An event used to serialize delete operations.
    //
    KEVENT                              DeleteEvent[1];

} SIS_PER_LINK, *PSIS_PER_LINK;

//
// Values for the SIS_PER_LINK Flags field.
//
#define SIS_PER_LINK_BACKPOINTER_GONE           0x00000001      // Have we removed the backpointer for this file
#define SIS_PER_LINK_FINAL_COPY                 0x00000002      // A final copy is in progress (or finished)
#define SIS_PER_LINK_FINAL_COPY_DONE            0x00000004      // A final copy is finished
#define SIS_PER_LINK_DIRTY                      0x00000008      // Has a write ever been done to any stream of this link?
#define SIS_PER_LINK_FINAL_COPY_WAITERS         0x00000010      // Are any threads blocked waiting final copy to be cleared
#define SIS_PER_LINK_OVERWRITTEN                0x00000020      // File's entire contents have been modified
#define SIS_PER_LINK_FILE_DELETED               0x00000040      // Has the file been deleted by SetInformationFile, delete-on-close or rename over?
#define SIS_PER_LINK_DELETE_DISPOSITION_SET     0x00000080      // Does NTFS think that the delete disposition is set on this file?
#define SIS_PER_LINK_DELETE_WAITERS             0x00000100      // Is anyone waiting for PendingDeleteCount to get to zero?
#define SIS_PER_LINK_UNDELETE_IN_PROGRESS       0x00000200      // Set iff PendingDeleteCount represents undelete operations
#define SIS_PER_LINK_FINAL_DELETE_IN_PROGRESS   0x00000400      // We've sent what we think is the final delete to NTFS; don't allow creates
#define SIS_PER_LINK_BACKPOINTER_VERIFIED       0x00000800      // Have we assured that this per link has a CSFile backpointer

typedef struct _SIS_FILTER_CONTEXT {
    //
    // This structure must start off with an FSRTL_FILTER_CONTEXT in order to be able
    // to use the FsRtlFilterContext routines.
    //
    FSRTL_PER_STREAM_CONTEXT ContextCtrl;

    //
    // The primary scb.  There may be other scb's associated with this filter
    // context (identified via the perFO's), but they must all be defunct,
    // i.e. marked SIS_PER_LINK_CAN_IGNORE.  New file objects always attach
    // to the primary scb.
    //
    struct _SIS_SCB                 *primaryScb;

    //
    // Linked list of all the perFO's associated with this file.
    //
    struct _SIS_PER_FILE_OBJECT     *perFOs;

    //
    // Number of perFO's attached to this filter context.
    //
    ULONG                           perFOCount;

    // Counting for OpLocks.
    ULONG                           UncleanCount;

    //
    // A fast mutex to protect the filter context.
    //
    FAST_MUTEX                      FastMutex[1];

#if     DBG
    //
    // The owner of the fast mutex.
    //
    ERESOURCE_THREAD                MutexHolder;
#endif

} SIS_FILTER_CONTEXT, *PSIS_FILTER_CONTEXT;

typedef struct _SIS_PER_FILE_OBJECT {
    //
    // A pointer to the filter context for this file.
    //
    struct _SIS_FILTER_CONTEXT      *fc;

    //
    // A pointer to the SCB holding the reference for this file.
    //
    struct _SIS_SCB                 *referenceScb;

    //
    // A pointer back to the file object that refers to this perFO.
    //
    PFILE_OBJECT                    fileObject;

    //
    // 1-bit stuff
    //
    ULONG                           Flags;
#define SIS_PER_FO_UNCLEANUP        0x00000001  // do we expect to see a cleanup on this perFO?
#define SIS_PER_FO_DELETE_ON_CLOSE  0x00000002  // The file was opened delete-on-close
#define SIS_PER_FO_OPBREAK          0x00000004  // This file was opened COMPLETE_IF_OPLOCKED,
                                                // it returned STATUS_OPLOCK_BREAK_IN_PROGRESS,
                                                // and the oplock break hasn't yet been acked.
#define SIS_PER_FO_OPBREAK_WAITERS  0x00000008  // Is anyone wating for the opbreak to complete?
#define SIS_PER_FO_OPEN_REPARSE     0x00000010  // Was this per-FO opened FILE_OPEN_REPARSE_POINT

#if DBG
#define SIS_PER_FO_NO_CREATE        0x80000000  // Was this perFO allocated by SipIsFileObjectSIS
#define SIS_PER_FO_CLEANED_UP       0x40000000  // Has this perFO already come through cleanup?
#endif  // DBG

    //
    // A spin lock to protect the flags
    //
    KSPIN_LOCK                      SpinLock[1];

    //
    // Linked list pointers for the perFOs associated
    // with a particular filter context.
    //
    struct _SIS_PER_FILE_OBJECT     *Next, *Prev;

    //
    // An event that's used for opbreak waiters.  Only alloated when SIS_PER_FO_OPBREAK
    // is set.
    //
    PKEVENT                         BreakEvent;

#if     DBG
    //
    // The FsContext (NTFS scb) for the file object pointed to by
    // this perFO.
    //
    PVOID                           FsContext;

    //
    // If this was allocated by SipIsFileObjectSIS, then the file and line number
    // of the call that allocated it.
    //
    PCHAR                           AllocatingFilename;
    ULONG                           AllocatingLineNumber;
#endif  // DBG


} SIS_PER_FILE_OBJECT, *PSIS_PER_FILE_OBJECT;

//
// Reference types for references held to SCBs.
//

typedef enum _SCB_REFERENCE_TYPE {
        RefsLookedUp            = 0,        // NB: the code assumes this is the first  reference type
        RefsPerFO,
        RefsPredecessorScb,
        RefsFinalCopy,
        RefsCOWRequest,
        RefsRead,
        RefsWrite,
        RefsWriteCompletion,
        RefsReadCompletion,
        RefsEnumeration,
        RefsFinalCopyRetry,
        RefsFc,
        NumScbReferenceTypes
} SCB_REFERENCE_TYPE, *PSCB_REFERENCE_TYPE;

#if     DBG
extern ULONG            totalScbReferences;
extern ULONG            totalScbReferencesByType[];
#endif  // DBG

//
// The SCB for a SIS-owned file.  These are one per stream for a particular link file.
// They are pointed to by FileObject->FsContext.
//
typedef struct _SIS_SCB {
    RTL_SPLAY_LINKS                     Links;

    // Need something to contain the stream name.

    PSIS_PER_LINK                       PerLink;

    //
    // List of predecessor scb's.  Any SCB's that are predecessors must be
    // defunct (ie., have CAN_IGNORE set).
    //
    struct _SIS_SCB                     *PredecessorScb;

    //
    // Reference count (number of file objects that point to this SCB structure)
    //
    ULONG                               RefCount;

    //
    // All scb's are on a volume global list for enumeration during volume check.
    //
    LIST_ENTRY                          ScbList;

    //
    // The first byte that must be from the copied file rather than from the
    // underlying file.  scb->Ranges is only maintained up to this address.
    // This starts out at the size of the underlying file at copy-on-write time,
    // and gets reduced if the file is truncated, but not increased if its
    // extended.
    //
    LONGLONG                            SizeBackedByUnderlyingFile;

    //
    // The count of failed final copy retries.
    //
    ULONG                               ConsecutiveFailedFinalCopies;

    //
    // Various 1-bit things
    //
    ULONG                               Flags;
#define SIS_SCB_MCB_INITIALIZED             0x00000001
#define SIS_SCB_INITIALIZED                 0x00000004      // is the SCB itself initialized
#define SIS_SCB_ANYTHING_IN_COPIED_FILE     0x00000008      // Is there possibly something in the copied file or its data section?
#define SIS_SCB_RANGES_INITIALIZED          0x00000010      // Have we checked allocated ranges for this file?
#define SIS_SCB_BACKING_FILE_OPENED_DIRTY   0x00000020      // did the backing file stream have anything in it when it was opened?

    //
    // A fast mutex to protect the SCB.
    //
    FAST_MUTEX                          FastMutex[1];

    // File locking structures
    FILE_LOCK                           FileLock;

    //
    // A large MCB to use for the written/faulted ranges.
    //
    LARGE_MCB                           Ranges[1];

#if     DBG
    //
    // The owner of the fast mutex.
    //
    ERESOURCE_THREAD                    MutexHolder;

    //
    // A count of references by type.
    //

    ULONG                               referencesByType[NumScbReferenceTypes];
#endif  // DBG

} SIS_SCB, *PSIS_SCB;

//
// A request to open a common store file. The caller must hold
// the UFOMutant for this file.  Status is returned in openStatus
// and then event is set.  It's the caller's responsibility to
// initialize the event and then deallocate the SI_OPEN_CS_FILE
// after it's completed.
//
typedef struct _SI_OPEN_CS_FILE {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PSIS_CS_FILE            CSFile;
    NTSTATUS                openStatus;
    BOOLEAN                 openByName;
    KEVENT                  event[1];
} SI_OPEN_CS_FILE, *PSI_OPEN_CS_FILE;

//
// A request to close a handle(s) in the PsInitialProcess context. (sent to a worker thread)
//
typedef struct _SI_CLOSE_HANDLES {
    WORK_QUEUE_ITEM         workQueueItem[1];
    HANDLE                  handle1;
    HANDLE                  handle2;                OPTIONAL
    NTSTATUS                status;
    PERESOURCE              resourceToRelease;      OPTIONAL
    ERESOURCE_THREAD        resourceThreadId;       OPTIONAL
} SI_CLOSE_HANDLES, *PSI_CLOSE_HANDLES;

//
// A request to allocate more index space for a particular device.
//
typedef struct _SI_ALLOCATE_INDICES {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PDEVICE_EXTENSION       deviceExtension;
} SI_ALLOCATE_INDICES, *PSI_ALLOCATE_INDICES;

typedef struct _SI_COPY_THREAD_REQUEST {
    LIST_ENTRY              listEntry[1];
    PSIS_SCB                scb;
    BOOLEAN                 fromCleanup;
} SI_COPY_THREAD_REQUEST, *PSI_COPY_THREAD_REQUEST;

typedef struct _SI_FSP_REQUEST {
    WORK_QUEUE_ITEM         workQueueItem[1];
    PIRP                    Irp;
    PDEVICE_OBJECT          DeviceObject;
    ULONG                   Flags;
} SI_FSP_REQUEST, *PSI_FSP_REQUEST;

#define FSP_REQUEST_FLAG_NONE               0x00000000  // Just a define so that we don't have to use "0" in calls
#define FSP_REQUEST_FLAG_WRITE_RETRY        0x00000001

typedef struct _RW_COMPLETION_UPDATE_RANGES_CONTEXT {
        WORK_QUEUE_ITEM         workQueueItem[1];
        PSIS_SCB                scb;
        LARGE_INTEGER           offset;
        ULONG                   length;
        PDEVICE_EXTENSION       deviceExtension;
        BOOLEAN                 NonCached;
} RW_COMPLETION_UPDATE_RANGES_CONTEXT, *PRW_COMPLETION_UPDATE_RANGES_CONTEXT;

typedef struct _SIS_CREATE_CS_FILE_REQUEST {
        WORK_QUEUE_ITEM             workQueueItem[1];
        PDEVICE_EXTENSION           deviceExtension;
        PCSID                       CSid;
        PFILE_OBJECT                srcFileObject;
        PLARGE_INTEGER              NtfsId;
        PKEVENT                     abortEvent;
        PLONGLONG                   CSFileChecksum;
        KEVENT                      doneEvent[1];
        NTSTATUS                    status;
} SIS_CREATE_CS_FILE_REQUEST, *PSIS_CREATE_CS_FILE_REQUEST;


#ifndef COPYFILE_SIS_LINK       // This is in ntioapi.h; leaving this here conditionally allows for compiling with both old and new ntioapi.h
//
// FSCTL_SIS_COPYFILE support
// Source and destination file names are passed in the FileNameBuffer.
// Both strings are null terminated, with the source name starting at
// the beginning of FileNameBuffer, and the destination name immediately
// following.  Length fields include terminating nulls.
//

typedef struct _SI_COPYFILE {
    ULONG SourceFileNameLength;
    ULONG DestinationFileNameLength;
    ULONG Flags;
    WCHAR FileNameBuffer[1];    // NB: Code in the filter requires that this is the final field
} SI_COPYFILE, *PSI_COPYFILE;
#endif  // COPYFILE_SIS_LINK

#define COPYFILE_SIS_LINK       0x0001              // Copy only if source is SIS
#define COPYFILE_SIS_REPLACE    0x0002              // Replace destination if it exists, otherwise don't.
#define COPYFILE_SIS_FLAGS      0x0003
// NB: in DBG systems, the high bit is reserved for "checkpoint log"

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj)->DriverObject == FsDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))

//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == SisControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == FsDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    ((_type) == FILE_DEVICE_DISK_FILE_SYSTEM)


//#define SIS_DEVICE_TYPE /*(CSHORT)*/0xbb00

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT                  AttachedToDeviceObject/*FileSystemDeviceObject*/;
    PDEVICE_OBJECT                  RealDeviceObject;

    //
    //  A pointer to the device object associated with this extension
    //

    PDEVICE_OBJECT                  DeviceObject;

    //
    // A list of all of the SIS device extensions in the system.
    //

    LIST_ENTRY                      DevExtLink;

    //
    // The absolute pathname of the common store directory.  This includes
    // the trailing "\"
    //

    UNICODE_STRING                  CommonStorePathname;

    //
    // The absolute pathname of the filesystem root.  This does include
    // a trailing "\"
    //

    UNICODE_STRING                  FilesystemRootPathname;

#if DBG
    //
    //  A cached copy of the name of the device we are attached to.
    //  - If it is a file system device object it will be the name of that
    //    device object.
    //  - If it is a mounted volume device object it will be the name of the
    //    real device object (since mounted volume device objects don't have
    //    names).
    //

    UNICODE_STRING Name;
#endif

    //
    // A count of outstanding final copy retries for this volume.  When this
    // count starts getting too large, we reduce the number of times
    // that we retry final copies in order to preserve memory.
    //
    ULONG                           OutstandingFinalCopyRetries;

    //
    // The volume sector size and the "bytes per file record."  Bytes per file
    // record is a number that's big enough that any file with
    // this allocation size is guaranteed to not be a resident attribute.
    // We store BytesPerFileRecordSegment in a large integer for convenience,
    // because we need to pass it into a call that takes a large integer
    // argument.
    //
    ULONG                           FilesystemVolumeSectorSize;
    LARGE_INTEGER                   FilesystemBytesPerFileRecordSegment;

    //
    // A handle to \SIS Common Store\GrovelerFile.  This is used
    // for two purposes.  First, it is used when we need a handle
    // to do open-by-id; for that purpose any handle on the
    // volume will do.  Second, it is used to check for security
    // on the FSCTL_LINK_FILES fsctl.  Any calls on any file
    // other than the one opened by GrovelerFileHandle will
    // fail; in this way, we can prevent non-privileged users
    // from making this call.
    //

    HANDLE                          GrovelerFileHandle;
    PFILE_OBJECT                    GrovelerFileObject;

    //
    // Various 1 bit flags related to this volume, and a spin lock to protect them.
    //
    KSPIN_LOCK                      FlagsLock[1];
    ULONG                           Flags;
#define SIP_EXTENSION_FLAG_PHASE_2_STARTED  0x00000001          // Phase 2 initialization is started
#define SIP_EXTENSION_FLAG_VCHECK_EXCLUSIVE 0x00000002          // In volume check backpointer resource exclusive phase
#define SIP_EXTENSION_FLAG_VCHECK_PENDING   0x00000004          // A volume check is pending
#define SIP_EXTENSION_FLAG_VCHECK_NODELETE  0x00000008          // In volume check no-delete phase
#define SIP_EXTENSION_FLAG_CORRUPT_MAXINDEX 0x00000010          // invalid maxindex--volume check is fixing it

#define SIP_EXTENSION_FLAG_INITED_CDO       0x40000000          // inited as control device object
#define SIP_EXTENSION_FLAG_INITED_VDO       0x80000000          // inited as volume device object

    //
    // The splay tree for per-link structures for this volume.
    //
    SIS_TREE                        PerLinkTree[1];

    //
    // Spin lock for accessing the per-link list.  Ordered before the CSFileSpinLock.
    //
    KSPIN_LOCK                      PerLinkSpinLock[1];

    //
    // A splay tree and spin lock for the common store file stuructures, just like the per-link ones above.
    // The spin lock is ordered after the PerLinkSpinLock, meaning that once we have the
    // CSFileSpinLock, we cannot try to acquire the PerLinkSpinLock (but do not necessarily need
    // to hold it in the first place).
    //
    SIS_TREE                        CSFileTree[1];
    KSPIN_LOCK                      CSFileSpinLock[1];

    //
    // A resource that protects against a race between the handles being closed on a CS file after
    // the last reference goes away, and someone re-opening a reference to that CS file.  Everyone
    // closing a CS file takes this resource shared.  When an opener gets a sharing violation on the
    // backpointer stream, it takes the resource exclusively and retries.
    //
    ERESOURCE                       CSFileHandleResource[1];

    //
    // The splay tree for SCBs
    //
    SIS_TREE                        ScbTree[1];
    KSPIN_LOCK                      ScbSpinLock[1];

    //
    // Doubly linked list of all scb structures for this volume.
    //
    LIST_ENTRY                      ScbList;

    //
    // State for the LINK_INDEX value generator for this volume.  Keep track of how many are allocated (ie., we've
    // recorded on the disk that they can't be used) and how many are actually used now.  Must hold the
    // IndexSpinLock to access these variables.
    //
    LINK_INDEX                      MaxAllocatedIndex;
    LINK_INDEX                      MaxUsedIndex;
    KSPIN_LOCK                      IndexSpinLock[1];

    //
    // Control for the index allocator.  If there are no unused, allocated indices, a thread sets the
    // IndexAllocationInProgress flag, clears the event, queues up the allocator and blocks
    // on the IndexEvent (a Notification event).  Any subequent threads just block on the event.
    // The allocator gets new indices, updates the variable and sets the event.  When the
    // waiting threads wake up, they just retry the allocation.
    //
    BOOLEAN                         IndexAllocationInProgress;
    KEVENT                          IndexEvent[1];

    //
    // A handle (in the PsInitialSystemProcess context) to the index file.  Only accessed by the index allocator.
    //
    HANDLE                          IndexHandle;
    HANDLE                          IndexFileEventHandle;
    PKEVENT                         IndexFileEvent;

    //
    // The status that came back from the attempt to allocate new indices.
    //
    NTSTATUS                        IndexStatus;

#if     ENABLE_LOGGING
    //
    // Stuff for the SIS log file.  A handle in the PsInitialSystemProcessContext as well as an object
    // that we reference to the file for use in other contexts.
    //
    HANDLE                          LogFileHandle;
    PFILE_OBJECT                    LogFileObject;
    KMUTANT                         LogFileMutant[1];
    LARGE_INTEGER                   LogWriteOffset;
    LARGE_INTEGER                   PreviousLogWriteOffset; // The logwriteoffset from when the trimmer last ran.
#endif  // ENABLE_LOGGING

    //
    // Phase 2 initialization takes place after the mount has completed when we can do full-fledged
    // ZwCreateFile calls and whatnot.  This flag indicates whether it's happened.  Once it's set,
    // it can never be cleared.
    //
    BOOLEAN                         Phase2InitializationComplete;
    KEVENT                          Phase2DoneEvent[1];

    //
    // The thread that's handing phase2 initialization.
    //
    HANDLE                          Phase2ThreadId;

    //
    // The number of backpointer entries per sector (sectorSize / sizeof(SIS_BACKPOINTER).
    //
    ULONG                           BackpointerEntriesPerSector;

    //
    // Taken when a link index collision is being repaired.
    //
    KMUTEX                          CollisionMutex[1];

    //
    // A resource that's used to mediate access to the GrovelerFileObject.  This needs to
    // be taken shared to assure that the GrovelerFileObject isn't messed with.  When the volume
    // is dismounted, the dismount code takes it exclusively in order to blow away the GrovelerFileObject.
    //
    ERESOURCE                       GrovelerFileObjectResource[1];

} DEVICE_EXTENSION;

//
// The spin lock used to maintain the list of device extensions.
//

extern KSPIN_LOCK DeviceExtensionListLock;
extern LIST_ENTRY DeviceExtensionListHead;

//
// Global stuff for the log trimmer.  This uses a timer to fire a DPC, which in turn queues up the real
// log trimmer on a worker thread.  The trimmer then reschedules the DPC when it's done.
//
extern KTIMER              LogTrimTimer[1];
extern KDPC                LogTrimDpc[1];
extern WORK_QUEUE_ITEM     LogTrimWorkItem[1];
#define LOG_TRIM_TIMER_INTERVAL  -10 * 1000 * 1000 * 60     // 1 minute trim interval

//
// Offsets used for the SCB ranges
//
#define FAULTED_OFFSET          1000
#define WRITTEN_OFFSET          2000

//
// A macro to get SIS out of the driver stack.  This should be called from
// a dispatch routine when we don't want to hear about this particular Irp
// again.  It is morally equivalent to calling SiPassThrough, only without
// the procedure call overhead.  Note that the return in this macro returns
// from the caller's function, not just from the "macro function."
//
#define SipDirectPassThroughAndReturn(DeviceObject,Irp)                                         \
{                                                                                               \
    (Irp)->CurrentLocation++;                                                                   \
    (Irp)->Tail.Overlay.CurrentStackLocation++;                                                 \
                                                                                                \
    return IoCallDriver(                                                                        \
        ((PDEVICE_EXTENSION)((DeviceObject)->DeviceExtension))->AttachedToDeviceObject,         \
        (Irp));                                                                                 \
}

//
// This function assures that phase 2 initialization is complete for a volume.  It might
// block, but only during initialization.
//
#define SipCheckPhase2(deviceExtension)                                                         \
        ((deviceExtension)->Phase2InitializationComplete ?                                      \
                TRUE : SipHandlePhase2((deviceExtension)))

//
// Test to see if this file object is our primary device object rather than
// an actual filesystem device.  If so, then complete the irp and return from the
// calling function.
//

#define SipHandleControlDeviceObject(DeviceObject,Irp)                                          \
{                                                                                               \
    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {                                            \
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;                                   \
        Irp->IoStatus.Information = 0;                                                          \
                                                                                                \
        IoCompleteRequest(Irp, IO_NO_INCREMENT);                                                \
                                                                                                \
        return STATUS_INVALID_DEVICE_REQUEST;                                                   \
    }                                                                                           \
}

//
// A debugging routine to determine if a SCB is held exclusively.  Does NOT assert
// that it's held by the current thread, just that it's held by someone
//
#if     DBG && defined (_X86_)
#define SipAssertScbHeld(scb)                                                                   \
{                                                                                               \
    ASSERT((scb)->MutexHolder != 0);                                                            \
}
#else   // DBG
#define SipAssertScbHeld(scb)
#endif  // DBG

//
// A debugging routine to determine if a SCB is held exclusively by a particular thread.
//
#if     DBG && defined (_X86_)
#define SipAssertScbHeldByThread(scb,thread)                                                    \
{                                                                                               \
    ASSERT((scb)->MutexHolder == (thread));                                                     \
}
#else   // DBG
#define SipAssertScbHeldByThread(scb,thread)
#endif  // DBG

//
// Acquire a filter context exclusively
//
#if     DBG
#define SipAcquireFc(fc)                                                                        \
{                                                                                               \
    ExAcquireFastMutex((fc)->FastMutex);                                                        \
    (fc)->MutexHolder = ExGetCurrentResourceThread();                                           \
}
#else   DBG
#define SipAcquireFc(fc)                                                                        \
{                                                                                               \
    ExAcquireFastMutex((fc)->FastMutex);                                                        \
}
#endif  // DBG

//
// Release a filter context
//
#if     DBG
#define SipReleaseFc(fc)                                                                        \
{                                                                                               \
    (fc)->MutexHolder = 0;                                                                      \
    ExReleaseFastMutex((fc)->FastMutex);                                                        \
}
#else   // DBG
#define SipReleaseFc(fc)                                                                        \
{                                                                                               \
    ExReleaseFastMutex((fc)->FastMutex);                                                        \
}
#endif  // DBG

//
// Acquire an SCB exclusively
//
#if     DBG
#define SipAcquireScb(scb)                                                                      \
{                                                                                               \
    ExAcquireFastMutex((scb)->FastMutex);                                                       \
    (scb)->MutexHolder = ExGetCurrentResourceThread();                                          \
}
#else   DBG
#define SipAcquireScb(scb)                                                                      \
{                                                                                               \
    ExAcquireFastMutex((scb)->FastMutex);                                                       \
}
#endif  // DBG

//
// Release a SCB
//
#if     DBG
#define SipReleaseScb(scb)                                                                      \
{                                                                                               \
    (scb)->MutexHolder = 0;                                                                     \
    ExReleaseFastMutex((scb)->FastMutex);                                                       \
}
#else   // DBG
#define SipReleaseScb(scb)                                                                      \
{                                                                                               \
    ExReleaseFastMutex((scb)->FastMutex);                                                       \
}
#endif  // DBG

//
// A header for any log entry in the SIS log file.
//
typedef struct _SIS_LOG_HEADER {
    //
    // A magic number.  This needs to be first for the log reading code.
    //
    ULONG                       Magic;

    //
    // The type of the log record (ie., copy-on-write, COW completed, etc.)
    //
    USHORT                      Type;

    //
    // The size of the log record, including the size of the header record itself.
    //
    USHORT                      Size;

    //
    // An SIS index unique to this log record.  This is here to help insure log
    // consistency.  First, all log records must be in ascending index order.
    // Second, all log records will look slightly different because they
    // will have different indices, and so will have different checksums, making
    // stale log records more likely to be detected.
    //
    LINK_INDEX                  Index;

    //
    // A checksum of the log record, including the header.  When the checksum is
    // computed, the checksum field is set to zero.
    //
    LARGE_INTEGER               Checksum;

} SIS_LOG_HEADER, *PSIS_LOG_HEADER;

#define SIS_LOG_HEADER_MAGIC    0xfeedf1eb

//
// The various types of log records
//
#define SIS_LOG_TYPE_TEST                   1
#define SIS_LOG_TYPE_REFCOUNT_UPDATE        2

//
// Possible values for UpdateType in SipPrepareRefcountChange and in the
// SIS_LOG_REFCOUNT_UPDATE log record.
//
#define SIS_REFCOUNT_UPDATE_LINK_DELETED        2
#define SIS_REFCOUNT_UPDATE_LINK_CREATED        3
#define SIS_REFCOUNT_UPDATE_LINK_OVERWRITTEN    4

//
// A common store file reference count update, either because of a new copy or
// a deletion.  copies-on-write are handled with different log records.
//
typedef struct _SIS_LOG_REFCOUNT_UPDATE {
    //
    // What type of update is this (create, delete or overwrite?)
    //
    ULONG                       UpdateType;

    //
    // If this is a delete, is the link file going away, or has it been
    // overwritten/final copied?
    //
    BOOLEAN                     LinkFileBeingDeleted;

    //
    // The NTFS file Id of the link file.
    //
    LARGE_INTEGER               LinkFileNtfsId;

    //
    // The link and common store indices for this link
    //
    LINK_INDEX                  LinkIndex;
    CSID                        CSid;
} SIS_LOG_REFCOUNT_UPDATE, *PSIS_LOG_REFCOUNT_UPDATE;

//
// Enums for the code that keeps track of whether ranges of a file
// are written, faulted or untouched.
//
typedef enum _SIS_RANGE_DIRTY_STATE {
                    Clean,
                    Mixed,
                    Dirty}
        SIS_RANGE_DIRTY_STATE, *PSIS_RANGE_DIRTY_STATE;

typedef enum _SIS_RANGE_STATE {
                    Untouched,
                    Faulted,
                    Written}
        SIS_RANGE_STATE, *PSIS_RANGE_STATE;


extern LIST_ENTRY CopyList[];
extern KSPIN_LOCK CopyListLock[];
extern KSEMAPHORE CopySemaphore[];

typedef struct _SCB_KEY {
    LINK_INDEX      Index;
} SCB_KEY, *PSCB_KEY;

typedef struct _PER_LINK_KEY {
    LINK_INDEX      Index;
} PER_LINK_KEY, *PPER_LINK_KEY;

typedef struct _CS_FILE_KEY {
    CSID            CSid;
} CS_FILE_KEY, *PCS_FILE_KEY;

//
//  Following macro is used to initialize UNICODE strings, stolen from ntfsstru.h
//

#ifndef CONSTANT_UNICODE_STRING
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#endif

extern const UNICODE_STRING NtfsDataString;

//
//  Miscellaneous support macros (stolen from private\ntos\cntfs\ntfsproc.h).
//
//      ULONG_PTR
//      WordAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      LongAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      QuadAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      UCHAR
//      CopyUchar1 (
//          IN PUCHAR Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar2 (
//          IN PUSHORT Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar4 (
//          IN PULONG Destination,
//          IN PUCHAR Source
//          );
//
//      PVOID
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define WordAlign(P) (             \
    ((((ULONG_PTR)(P)) + 1) & (-2)) \
)

#define LongAlign(P) (             \
    ((((ULONG_PTR)(P)) + 3) & (-4)) \
)

#define QuadAlign(P) (             \
    ((((ULONG_PTR)(P)) + 7) & (-8)) \
)

#define IsWordAligned(P)    ((ULONG_PTR)(P) == WordAlign( (P) ))

#define IsLongAligned(P)    ((ULONG_PTR)(P) == LongAlign( (P) ))

#define IsQuadAligned(P)    ((ULONG_PTR)(P) == QuadAlign( (P) ))


/////////////////////////////////////////////////////////////////////////////
//
//                      Functions Prototypes
//
/////////////////////////////////////////////////////////////////////////////

//
//  Routines in SIINIT.C
//

VOID
SipCleanupDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SipMountCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

NTSTATUS
SipLoadFsCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

VOID
SipFsNotification(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN BOOLEAN                          FsActive
    );

NTSTATUS
SipInitializeDeviceExtension(
    IN PDEVICE_OBJECT                   deviceObject
    );

VOID
SipUninitializeDeviceExtension(
    IN PDEVICE_OBJECT                   deviceObject
    );

VOID
SipGetBaseDeviceObjectName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SipGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

#if DBG
VOID
SipCacheDeviceName (
    IN PDEVICE_OBJECT OurDeviceObject
    );
#endif
//
//  ROutines in SIFASTIO.C
//

BOOLEAN
SiFastIoCheckIfPossible(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    IN BOOLEAN                          CheckForReadOperation,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoRead(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    OUT PVOID                           Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoWrite(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN BOOLEAN                          Wait,
    IN ULONG                            LockKey,
    IN PVOID                            Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryBasicInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_BASIC_INFORMATION         Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryStandardInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_STANDARD_INFORMATION      Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoLock(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PLARGE_INTEGER                   Length,
    PEPROCESS                           ProcessId,
    ULONG                               Key,
    BOOLEAN                             FailImmediately,
    BOOLEAN                             ExclusiveLock,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockSingle(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PLARGE_INTEGER                   Length,
    PEPROCESS                           ProcessId,
    ULONG                               Key,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockAll(
    IN PFILE_OBJECT                     FileObject,
    PEPROCESS                           ProcessId,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoUnlockAllByKey(
    IN PFILE_OBJECT                     FileObject,
    PVOID                               ProcessId,
    ULONG                               Key,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoDeviceControl(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    IN PVOID                            InputBuffer OPTIONAL,
    IN ULONG                            InputBufferLength,
    OUT PVOID                           OutputBuffer OPTIONAL,
    IN ULONG                            OutputBufferLength,
    IN ULONG                            IoControlCode,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

VOID
SiFastIoDetachDevice(
    IN PDEVICE_OBJECT                   SourceDevice,
    IN PDEVICE_OBJECT                   TargetDevice
    );

BOOLEAN
SiFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT                     FileObject,
    IN BOOLEAN                          Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION  Buffer,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlRead(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlReadComplete(
    IN PFILE_OBJECT                     FileObject,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoPrepareMdlWrite(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlWriteComplete(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoReadCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    OUT PVOID                           Buffer,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    OUT PCOMPRESSED_DATA_INFO           CompressedDataInfo,
    IN ULONG                            CompressedDataInfoLength,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoWriteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN ULONG                            Length,
    IN ULONG                            LockKey,
    IN PVOID                            Buffer,
    OUT PMDL                            *MdlChain,
    OUT PIO_STATUS_BLOCK                IoStatus,
    IN PCOMPRESSED_DATA_INFO            CompressedDataInfo,
    IN ULONG                            CompressedDataInfoLength,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT                     FileObject,
    IN PLARGE_INTEGER                   FileOffset,
    IN PMDL                             MdlChain,
    IN PDEVICE_OBJECT                   DeviceObject
    );

BOOLEAN
SiFastIoQueryOpen(
    IN PIRP                             Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION  NetworkInformation,
    IN PDEVICE_OBJECT                   DeviceObject
    );



//
// Declarations for various SIS internal/external functions.
//


BOOLEAN
SipAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
SipAttachToMountedDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT NewDeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject);



VOID
SipInitializeTree (
    IN PSIS_TREE                        Tree,
    IN PSIS_TREE_COMPARE_ROUTINE        CompareRoutine);


PVOID
SipInsertElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Node,
    IN PVOID                            Key);


VOID
SipDeleteElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Node);

PVOID
SipLookupElementTree (
    IN PSIS_TREE                        Tree,
    IN PVOID                            Key);

LONG
SipScbTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

LONG
SipPerLinkTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

LONG
SipCSFileTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node);

VOID
SipReferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType);

VOID
SipDereferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType);

#if		DBG
VOID
SipTransferScbReferenceType(
	IN PSIS_SCB							scb,
	IN SCB_REFERENCE_TYPE				oldReferenceType,
	IN SCB_REFERENCE_TYPE				newReferenceType);
#else	// DBG
#define	SipTransferScbReferenceType(scb,oldReferenceType,newReferenceType)	// We don't track reference types in free builds
#endif	// DBG

PSIS_SCB
SipLookupScb(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PUNICODE_STRING                  StreamName,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread        OPTIONAL,
    OUT PBOOLEAN                        FinalCopyInProgress,
    OUT PBOOLEAN                        LinkIndexCollision);

PSIS_PER_LINK
SipLookupPerLink(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread        OPTIONAL,
    OUT PBOOLEAN                        FinalCopyInProgress);

VOID
SipReferencePerLink(
    IN PSIS_PER_LINK                    PerLink);

VOID
SipDereferencePerLink(
    IN PSIS_PER_LINK                    PerLink);

PSIS_SCB
SipEnumerateScbList(
    PDEVICE_EXTENSION                   deviceExtension,
    PSIS_SCB                            prevScb);

VOID
SipUpdateLinkIndex(
    PSIS_SCB                            Scb,
    PLINK_INDEX                         LinkIndex);

PSIS_CS_FILE
SipLookupCSFile(
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   CSFileNtfsId            OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject);

VOID
SipReferenceCSFile(
    IN PSIS_CS_FILE                     CSFile);

VOID
SipDereferenceCSFile(
    IN PSIS_CS_FILE                     CsFile);

NTSTATUS
SiPrePostIrp(
    IN OUT PIRP                         Irp);

NTSTATUS
SipLockUserBuffer(
    IN OUT PIRP                         Irp,
    IN LOCK_OPERATION                   Operation,
    IN ULONG                            BufferLength);

NTSTATUS
SipPostRequest(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN OUT PIRP                         Irp,
    IN ULONG                            Flags);

VOID
SiCopyThreadStart(
    IN PVOID                            parameter);

NTSTATUS
SipPrepareCSRefcountChange(
    IN PSIS_CS_FILE                     CSFile,
    IN OUT PLINK_INDEX                  LinkIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN ULONG                            UpdateType);

NTSTATUS
SipCompleteCSRefcountChangeForThread(
    IN OUT PSIS_PER_LINK                PerLink,
    IN PLINK_INDEX                      LinkIndex,
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Success,
    IN BOOLEAN                          Increment,
    IN ERESOURCE_THREAD                 thread);

NTSTATUS
SipCompleteCSRefcountChange(
    IN OUT PSIS_PER_LINK                PerLink,
    IN PLINK_INDEX                      LinkIndex,
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Success,
    IN BOOLEAN                          Increment);

NTSTATUS
SipDeleteCSFile(
    PSIS_CS_FILE                        CSFile);

NTSTATUS
SipAllocateIndex(
    IN PDEVICE_EXTENSION                DeviceExtension,
    OUT PLINK_INDEX                     Index);

NTSTATUS
SipGetMaxUsedIndex(
    IN PDEVICE_EXTENSION                DeviceExtension,
    OUT PLINK_INDEX                     Index);

NTSTATUS
SipIndexToFileName(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PCSID                            CSid,
    IN ULONG                            appendBytes,
    IN BOOLEAN                          mayAllocate,
    OUT PUNICODE_STRING                 fileName);

BOOLEAN
SipFileNameToIndex(
    IN PUNICODE_STRING                  fileName,
    OUT PCSID                           CSid);

BOOLEAN
SipIndicesFromReparseBuffer(
    IN PREPARSE_DATA_BUFFER             reparseBuffer,
    OUT PCSID                           CSid,
    OUT PLINK_INDEX                     LinkIndex,
    OUT PLARGE_INTEGER                  CSFileNtfsId,
    OUT PLARGE_INTEGER                  LinkFileNtfsId,
    OUT PLONGLONG                       CSFileChecksum OPTIONAL,
    OUT PBOOLEAN                        EligibleForPartialFinalCopy OPTIONAL,
    OUT PBOOLEAN                        ReparseBufferCorrupt OPTIONAL);

BOOLEAN
SipIndicesIntoReparseBuffer(
    OUT PREPARSE_DATA_BUFFER            reparseBuffer,
    IN PCSID                            CSid,
    IN PLINK_INDEX                      LinkIndex,
    IN PLARGE_INTEGER                   CSFileNtfsId,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLONGLONG                        CSFileChecksum,
    IN BOOLEAN                          EligibleForPartialFinalCopy);

NTSTATUS
SipCompleteCopy(
    IN PSIS_SCB                         scb,
    IN BOOLEAN                          fromCleanup);

NTSTATUS
SipCloseHandles(
    IN HANDLE                           handle1,
    IN HANDLE                           handle2                 OPTIONAL,
    IN OUT PERESOURCE                   resourceToRelease       OPTIONAL
    );

NTSTATUS
SiPassThrough(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiCreate(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiClose(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiCleanup(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiRead(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiWrite(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiSetInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiQueryInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiFsControl(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SiLockControl(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );


NTSTATUS
SiOplockCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context
    );

VOID
SipOpenLinkFile(
    IN PVOID                            Parameter
    );

VOID
SipChangeCSRefcountWork(
    IN PVOID                            Parameter
    );

BOOLEAN
SiAcquireForLazyWrite(
    IN PVOID                            Context,
    IN BOOLEAN                          Wait
    );

VOID
SiReleaseFromLazyWrite(
    IN PVOID                            Context
    );

BOOLEAN
SiAcquireForReadAhead(
    IN PVOID                            Context,
    IN BOOLEAN                          Wait
    );

VOID
SiReleaseFromReadAhead(
    IN PVOID                            Context
    );

NTSTATUS
SipOpenBackpointerStream(
    IN PSIS_CS_FILE                     csFile,
    IN ULONG                            CreateDisposition
    );

NTSTATUS
SipOpenCSFileWork(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          openByName,
    IN BOOLEAN                          volCheck,
    IN BOOLEAN                          openForDelete,
    OUT PHANDLE                         openedFileHandle OPTIONAL
    );

VOID
SipOpenCSFile(
    IN OUT PSI_OPEN_CS_FILE             openRequest
    );

VOID
SiThreadCreateNotifyRoutine(
    IN HANDLE                           ProcessId,
    IN HANDLE                           ThreadId,
    IN BOOLEAN                          Create
    );

VOID
SipCloseHandlesWork(
    IN PVOID                            parameter
    );

NTSTATUS
SipQueryInformationFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            InformationClass,
    IN ULONG                            Length,
    OUT PVOID                           Information,
    OUT PULONG                          ReturnedLength      OPTIONAL
    );

NTSTATUS
SipQueryInformationFileUsingGenericDevice(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            InformationClass,
    IN ULONG                            Length,
    OUT PVOID                           Information,
    OUT PULONG                          ReturnedLength      OPTIONAL
    );

NTSTATUS
SipSetInformationFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN FILE_INFORMATION_CLASS           FileInformationClass,
    IN ULONG                            Length,
    IN PVOID                            FileInformation
    );

NTSTATUS
SipSetInformationFileUsingGenericDevice(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN FILE_INFORMATION_CLASS           FileInformationClass,
    IN ULONG                            Length,
    IN PVOID                            FileInformation
    );

NTSTATUS
SipCommonCreate(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonRead(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonSetInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonQueryInfo(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipCommonLockControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

NTSTATUS
SipCommonCleanup(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN BOOLEAN                          Wait
    );

NTSTATUS
SipFsCopyFile(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

NTSTATUS
SipInitialCopy(
    PSIS_PER_FILE_OBJECT                perFO);

NTSTATUS
SipBltRange(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN HANDLE                           sourceHandle,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipBltRange(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN HANDLE                           sourceHandle,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipBltRangeByObject(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PFILE_OBJECT                     srcFileObject,
    IN OUT HANDLE                       dstHandle,
    IN LONGLONG                         startingOffset,
    IN LONGLONG                         length,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          copyEvent,
    IN PKEVENT                          oplockEvent,
    OUT PLONGLONG                       checksum);

NTSTATUS
SipComputeCSChecksum(
    IN PSIS_CS_FILE                     csFile,
    IN OUT PLONGLONG                    csFileChecksum,
    HANDLE                              eventHandle,
    PKEVENT                             event);

NTSTATUS
SipCompleteCopyWork(
    IN PSIS_SCB                         scb,
    IN HANDLE                           eventHandle,
    IN PKEVENT                          event,
    IN BOOLEAN                          fromCleanup);

NTSTATUS
SipMakeLogEntry(
    IN OUT PDEVICE_EXTENSION            deviceExtension,
    IN USHORT                           type,
    IN USHORT                           size,
    IN PVOID                            record);

#if     ENABLE_LOGGING
VOID
SipAcquireLog(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

VOID
SipReleaseLog(
    IN OUT PDEVICE_EXTENSION            deviceExtension);
#endif  // ENABLE_LOGGING

VOID
SipComputeChecksum(
    IN PVOID                            buffer,
    IN ULONG                            size,
    IN OUT PLONGLONG                    checksum);

NTSTATUS
SipOpenLogFile(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

VOID
SipDrainLogFile(
    PDEVICE_EXTENSION                   deviceExtension);

BOOLEAN
SipHandlePhase2(
    PDEVICE_EXTENSION                   deviceExtension);

VOID
SipClearLogFile(
    PDEVICE_EXTENSION                   deviceExtension);

NTSTATUS
SiCheckOplock (
    IN POPLOCK                          Oplock,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

NTSTATUS
SiCheckOplockWithWait (
    IN POPLOCK                          Oplock,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp);

VOID
SipProcessCowLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PVOID                            logRecord,
    IN OUT PVOID                        *cowReplayPointer);

VOID
SipProcessCowDoneLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PVOID                            logRecord,
    IN OUT PVOID                        *cowReplayPointer);

NTSTATUS
SipFinalCopy(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PLARGE_INTEGER                   linkFileNtfsId,
    IN OUT PSIS_SCB                     scb,
    IN HANDLE                           copyEventHandle,
    IN PKEVENT                          event);

VOID
SipCowAllLogRecordsSent(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN OUT PVOID                        *cowReplayPointer);

NTSTATUS
SipCreateEvent(
    IN EVENT_TYPE                       eventType,
    OUT PHANDLE                         eventHandle,
    OUT PKEVENT                         *event);

VOID
SipMarkPoint(
    IN PCHAR                            pszFile,
    IN ULONG                            nLine
    );

VOID
SipMarkPointUlong(
    IN PCHAR                            pszFile,
    IN ULONG                            nLine,
    IN ULONG_PTR                        value
    );

NTSTATUS
SipLinkFiles(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp
    );

NTSTATUS
SipCreateCSFile(
    IN PDEVICE_EXTENSION                deviceExtension,
    OUT PCSID                           CSid,
    IN HANDLE                           SrcHandle,
    OUT PLARGE_INTEGER                  NtfsId,
    IN PKEVENT                          oplockEvent OPTIONAL,
    OUT PLONGLONG                       CSFileChecksum
    );

VOID
SipCreateCSFileWork(
    PVOID                               parameter
    );

VOID
SipAddRangeToFaultedList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    );

NTSTATUS
SipAddRangeToWrittenList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    );

SIS_RANGE_DIRTY_STATE
SipGetRangeDirty(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length,
    IN BOOLEAN                          faultedIsDirty
    );

BOOLEAN
SipGetRangeEntry(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN LONGLONG                         startingOffset,
    OUT PLONGLONG                       length,
    OUT PSIS_RANGE_STATE                state);

typedef enum {
    FindAny,                            // find active or defunct scb
    FindActive                          // find only active scb
} SIS_FIND_TYPE;

#if     DBG

#define SipIsFileObjectSIS(fileObject, DeviceObject, findType, perFO, scb) \
        SipIsFileObjectSISInternal(fileObject, DeviceObject, findType, perFO, scb, __FILE__, __LINE__)

BOOLEAN
SipIsFileObjectSISInternal(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL,
    IN PCHAR                            fileName,
    IN ULONG                            fileLine
    );

#else   // DBG

BOOLEAN
SipIsFileObjectSIS(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL
    );

#endif  // DBG

NTSTATUS
SipClaimFileObject(
    IN OUT PFILE_OBJECT                 fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PSIS_SCB                         scb
    );

VOID
SipUnclaimFileObject(
    IN OUT PFILE_OBJECT                 fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN OUT PSIS_SCB                     scb
    );

PSIS_PER_FILE_OBJECT
SipAllocatePerFO(
    IN PSIS_FILTER_CONTEXT              fc,
    IN PFILE_OBJECT                     fileObject,
    IN PSIS_SCB                         scb,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PBOOLEAN                        newPerFO OPTIONAL
    );

PSIS_PER_FILE_OBJECT
SipCreatePerFO(
    IN PFILE_OBJECT                     fileObject,
    IN PSIS_SCB                         scb,
    IN PDEVICE_OBJECT                   DeviceObject
    );

VOID
SipDeallocatePerFO(
    IN OUT PSIS_PER_FILE_OBJECT         perFO,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipInitializePrimaryScb(
    IN PSIS_SCB                         primaryScb,
    IN PSIS_SCB                         defunctScb,
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipFsControlFile(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            ioControlCode,
    IN PVOID                            inputBuffer,
    IN ULONG                            inputBufferLength,
    OUT PVOID                           outputBuffer,
    IN ULONG                            outputBufferLength,
    OUT PULONG                          returnedOutputBufferLength  OPTIONAL
    );

NTSTATUS
SipFsControlFileUsingGenericDevice(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN ULONG                            ioControlCode,
    IN PVOID                            inputBuffer,
    IN ULONG                            inputBufferLength,
    OUT PVOID                           outputBuffer,
    IN ULONG                            outputBufferLength,
    OUT PULONG                          returnedOutputBufferLength  OPTIONAL
    );

NTSTATUS
SipFlushBuffersFile(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject
    );

NTSTATUS
SipAcquireUFO(
    IN PSIS_CS_FILE                     CSFile/*,
    IN BOOLEAN                          Wait*/);

VOID
SipReleaseUFO(
    IN PSIS_CS_FILE                     CSFile);

NTSTATUS
SipAcquireCollisionLock(
    IN PDEVICE_EXTENSION                DeviceExtension);

VOID
SipReleaseCollisionLock(
    IN PDEVICE_EXTENSION                DeviceExtension);

VOID
SipTruncateScb(
    IN OUT PSIS_SCB                     scb,
    IN LONGLONG                         newLength);

NTSTATUS
SipOpenFileById(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PLARGE_INTEGER                   linkFileNtfsId,
    IN ACCESS_MASK                      desiredAccess,
    IN ULONG                            shareAccess,
    IN ULONG                            createOptions,
    OUT PHANDLE                         openedFileHandle);

NTSTATUS
SipWriteFile(
    IN PFILE_OBJECT                     FileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PIO_STATUS_BLOCK                Iosb,
    IN PVOID                            Buffer,
    IN ULONG                            Length,
    IN PLARGE_INTEGER                   ByteOffset);

BOOLEAN
SipAssureNtfsIdValid(
    IN  PSIS_PER_FILE_OBJECT            PerFO,
    IN OUT PSIS_PER_LINK                PerLink);

BOOLEAN
SipAbort(
    IN PKEVENT event
    );

VOID
SipBeginDeleteModificationOperation(
    IN OUT PSIS_PER_LINK                perLink,
    IN BOOLEAN                          delete);

VOID
SipEndDeleteModificationOperation(
    IN OUT PSIS_PER_LINK                perLink,
    IN BOOLEAN                          delete);

NTSTATUS
SiCompleteLockIrpRoutine(
    IN PVOID                            Context,
    IN PIRP                             Irp);

PVOID
SipMapUserBuffer(
    IN OUT PIRP                         Irp);


NTSTATUS
SipAssureCSFileOpen(
    IN PSIS_CS_FILE                     CSFile);

NTSTATUS
SipCheckVolume(
    IN OUT PDEVICE_EXTENSION            deviceExtension);

NTSTATUS
SipCheckBackpointer(
    IN PSIS_PER_LINK                    PerLink,
    IN BOOLEAN                          Exclusive,
    OUT PBOOLEAN                        foundMatch      OPTIONAL);

NTSTATUS
SipAddBackpointer(
    IN PSIS_CS_FILE                     CSFile,
    IN PLINK_INDEX                      LinkFileIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId);

NTSTATUS
SipRemoveBackpointer(
    IN PSIS_CS_FILE                     CSFile,
    IN PLINK_INDEX                      LinkIndex,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    OUT PBOOLEAN                        ReferencesRemain);

NTSTATUS
SiDeleteAndSetCompletion(
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PIRP                             Irp,
    IN PVOID                            Context);

VOID
SiTrimLogs(
    IN PVOID                            parameter);

VOID
SiLogTrimDpcRoutine(
    IN PKDPC                            dpc,
    IN PVOID                            context,
    IN PVOID                            systemArg1,
    IN PVOID                            systemArg2);

VOID
SipProcessRefcountUpdateLogRecord(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_LOG_REFCOUNT_UPDATE         logRecord);

NTSTATUS
SipAssureMaxIndexFileOpen(
    IN PDEVICE_EXTENSION                deviceExtension);

VOID
SipDereferenceObject(
    IN PVOID                            object);

BOOLEAN
SipAcquireBackpointerResource(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Exclusive,
    IN BOOLEAN                          Wait);

VOID
SipHandoffBackpointerResource(
    IN PSIS_CS_FILE                     CSFile);

VOID
SipReleaseBackpointerResource(
    IN PSIS_CS_FILE                     CSFile);

VOID
SipReleaseBackpointerResourceForThread(
    IN PSIS_CS_FILE                     CSFile,
    IN ERESOURCE_THREAD                 thread);

NTSTATUS
SipPrepareRefcountChangeAndAllocateNewPerLink(
    IN PSIS_CS_FILE                     CSFile,
    IN PLARGE_INTEGER                   LinkFileFileId,
    IN PDEVICE_OBJECT                   DeviceObject,
    OUT PLINK_INDEX                     newLinkIndex,
    OUT PSIS_PER_LINK                   *perLink,
    OUT PBOOLEAN                        prepared);

#if TIMING
VOID
SipTimingPoint(
    IN PCHAR                            file,
    IN ULONG                            line,
    IN ULONG                            n);

VOID
SipDumpTimingInfo();

VOID
SipClearTimingInfo();

VOID
SipInitializeTiming();
#endif  // TIMING

#if DBG
VOID
SipCheckpointLog();
#endif  // DBG
#endif      _SIp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sis.c ===
/*++

Copyright (c) 1989-1993, 1997-1999  Microsoft Corporation

Module Name:

    sis.c

Abstract:

    Code for the single instance store (SIS) filter driver.  Initially based on Darryl
    Havens' sfilter module.

Authors:

    Bill Bolosky & Scott Cutshall, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

LONG GCHEnableFastIo = 0;

#if     DBG
LONG        GCHEnableMarkPoint = 0;
LONG        GCHMarkPointNext = 0;
KSPIN_LOCK  MarkPointSpinLock[1];
CHAR        GCHMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];
PVOID       BJBMagicFsContext;
unsigned    BJBDebug = 0;
#endif  // DBG


//
// Global storage for this file system filter driver.
//

PDEVICE_OBJECT FsNtfsDeviceObject = NULL;

PDRIVER_OBJECT FsDriverObject;

LIST_ENTRY FsDeviceQueue;

ERESOURCE FsLock;

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SiPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementers:  This routine actually "passes"
    through the request by taking this driver out of the loop.  If the driver
    would like to pass the I/O request through, but then also see the result,
    then rather than essentially taking itself out of the loop it could keep
    itself in by copying the caller's parameters to the next stack location
    and then set its own completion routine.  Note that it's important to not
    copy the caller's I/O completion routine into the next stack location, or
    the caller's routine will get invoked twice.

    Hence, this code could do the following:

        deviceExtension = DeviceObject->DeviceExtension;

        IoCopyCurrentIrpStackLocationToNext( Irp );
        IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

        return IoCallDriver( deviceExtension->AttachedToDeviceObject, Irp );

    This example actually NULLs out the caller's I/O completion routine, but
    this driver could set its own completion routine so that it could be
    notified when the request was completed.

    Note also that the following code to get the current driver out of the loop
    is not really kosher, but it does work and is much more efficient than the
    above.

--*/

{
    //
    //  If this is for our control device object, fail the operation
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}



NTSTATUS
SipCloseHandles(
    IN HANDLE           handle1,
    IN HANDLE           handle2             OPTIONAL,
    IN OUT PERESOURCE   resourceToRelease   OPTIONAL)
/*++

Routine Description:

    Close one or two handles in the PsInitialSystemProcess context.  Optionally takes
    a resource to be released when the close finishes.  Does not wait for the close
    to complete.

    Even if the call fails, the resource is still released.

Arguments:

    The handle(s) to be closed and the resource to be released.

Return Value:

    a failure or status pending.  There is no way provided to synchronize with the
    completion.

--*/

{
    PSI_CLOSE_HANDLES closeRequest;

    closeRequest = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_CLOSE_HANDLES), ' siS');

    if (NULL == closeRequest) {
        if (NULL != resourceToRelease) {
            ExReleaseResourceLite(resourceToRelease);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    closeRequest->handle1 = handle1;
    closeRequest->handle2 = handle2;
    closeRequest->resourceToRelease = resourceToRelease;
    closeRequest->resourceThreadId = ExGetCurrentResourceThread();

    ExInitializeWorkItem(closeRequest->workQueueItem, SipCloseHandlesWork, closeRequest);

    ExQueueWorkItem(closeRequest->workQueueItem, CriticalWorkQueue);

    return STATUS_PENDING;
}

VOID
SipCloseHandlesWork(
    IN PVOID        parameter)
/*++

Routine Description:

    ExWorkerThread routine to close a handle or two in the PsInitialProcess context.

Arguments:

    parameter - pointer to a SI_CLOSE_HANDLES structure

Return Value:

    None.

--*/

{
    PSI_CLOSE_HANDLES closeRequest = (PSI_CLOSE_HANDLES)parameter;

    SIS_MARK_POINT_ULONG(closeRequest);

    closeRequest->status = NtClose(closeRequest->handle1);

    if (NT_SUCCESS(closeRequest->status) && (NULL != closeRequest->handle2)) {
        closeRequest->status = NtClose(closeRequest->handle2);
    }

    if (NULL != closeRequest->resourceToRelease) {
        ExReleaseResourceForThreadLite(closeRequest->resourceToRelease, closeRequest->resourceThreadId);
    }

    ExFreePool(closeRequest);

    return;
}

NTSTATUS
SipOpenBackpointerStream(
    IN PSIS_CS_FILE csFile,
    IN ULONG CreateDisposition
    )
/*++

Routine Description:

    Open a the backpointer stream of a common store file.  We must hold the
    UFOMutant to call this routine.

    Open the backpointer stream as a relative open to the main data stream.
    We open it write-through because we rely on backpointer writes really
    happening when we're told they are.

    Must be called in the PsInitialSystemProcess context.

Arguments:

    CSFile - The CSFile structure describing the underlying file to open

Return Value:

    The function value is the status of the operation.

--*/
{
    OBJECT_ATTRIBUTES               Obja;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 Iosb;
    UNICODE_STRING                  streamName;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    ASSERT(NULL == csFile->BackpointerStreamHandle);
    ASSERT(NULL == csFile->BackpointerStreamFileObject);
    ASSERT(NULL != csFile->UnderlyingFileHandle);
//    ASSERT(IS_SYSTEM_THREAD(PsGetCurrentThread()));

    streamName.Buffer = BACKPOINTER_STREAM_NAME;
    streamName.MaximumLength = BACKPOINTER_STREAM_NAME_SIZE;
    streamName.Length = BACKPOINTER_STREAM_NAME_SIZE;

    InitializeObjectAttributes(
        &Obja,
        &streamName,
        OBJ_CASE_INSENSITIVE,
        csFile->UnderlyingFileHandle,
        NULL);

    status = NtCreateFile(
                &csFile->BackpointerStreamHandle,
                GENERIC_READ | GENERIC_WRITE,
                &Obja,
                &Iosb,
                NULL,                   // Allocation Size
                0,                      // File Attributes
#if DBG
                (BJBDebug & 0x10000000) ?
                    FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                       FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                CreateDisposition,
    /*BJB*/ FILE_SYNCHRONOUS_IO_NONALERT |
                FILE_NON_DIRECTORY_FILE,
                NULL,                   // EA Buffer
                0);                     // EA Length

    if (STATUS_SHARING_VIOLATION == status) {
        PDEVICE_EXTENSION   deviceExtension = csFile->DeviceObject->DeviceExtension;

        //
        // We may be getting a sharing violation with ourselves as we try to close
        // the handles on this file.  Take the device-wide CSFileHandleResource
        // exclusively and retry the create.
        //

        SIS_MARK_POINT_ULONG(csFile);

        ExAcquireResourceExclusiveLite(deviceExtension->CSFileHandleResource, TRUE);

        status = NtCreateFile(
                    &csFile->BackpointerStreamHandle,
                    GENERIC_READ | GENERIC_WRITE,
                    &Obja,
                    &Iosb,
                    NULL,                   // Allocation Size
                    0,                      // File Attributes
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    CreateDisposition,
    /*BJB*/ FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_NON_DIRECTORY_FILE,
                    NULL,                   // EA Buffer
                    0);                     // EA Length

        //
        // If it failed this time, it's something else and we can let the whole thing fail.
        //

        ExReleaseResourceLite(deviceExtension->CSFileHandleResource);
    }

    return status;
}


NTSTATUS
SipOpenCSFileWork(
    IN PSIS_CS_FILE     CSFile,
    IN BOOLEAN          openByName,
    IN BOOLEAN          volCheck,
    IN BOOLEAN          openForDelete,
    OUT PHANDLE         openedFileHandle OPTIONAL
    )
/*++

Routine Description:

    Open a file in the common store.  We must hold the UFOMutant to call this routine,
    and must be in the PsInitialSystemProcess context.

Arguments:

    CSFile     - The CSFile structure describing the underlying file to open

    openByName - If TRUE, then the file will be opened by name, otherwise it will
                 be opened by ID.

    volCheck   - If TRUE, then a backpointer stream open failure will not
                 cause entire open to abort.

    openForDelete -
                Should we open the file with DELETE permission?

    openedFileHandle - pointer to a variable to receive the opened handle.  If this is
                 specified, the UFOHandle and UnderlyingFileObject in the CSFile will
                 NOT be affected, and we will not take a reference to the file object
                 or fill in the file size info in the CSFile structure or open the
                 backpointer stream and read in the CS file checksum.

Return Value:

    The function value is the status of the operation.

--*/
{
    OBJECT_ATTRIBUTES               Obja;
    PDEVICE_EXTENSION               deviceExtension;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 Iosb;
    FILE_STANDARD_INFORMATION       standardFileInfo[1];
    HANDLE                          localHandle = NULL;
    HANDLE                          ioEventHandle = NULL;
    PKEVENT                         ioEvent = NULL;
    LARGE_INTEGER                   zero;
    SIS_BACKPOINTER_STREAM_HEADER   backpointerStreamHeader[1];
    FILE_INTERNAL_INFORMATION       internalInfo[1];
    KIRQL                           OldIrql;
    BOOLEAN                         retry = FALSE;
    ULONG                           sectorFill;
    LONGLONG                        csFileChecksum;
    BOOLEAN                         grovelerFileHeld = FALSE;

    //
    // Note that we're overloading nameBuffer as both the fileName buffer
    // and the FILE_NAME_INFORMATION buffer.
    //

#define FN_STACK_BUFFER_LENGTH 240

    UNICODE_STRING              fileName;
    union {
        FILE_NAME_INFORMATION   nameFileInfo[1];
        WCHAR                   nameBuffer[FN_STACK_BUFFER_LENGTH];
    } nameFile;


    UNREFERENCED_PARAMETER( volCheck );

    //
    // Restart here after repairing the backpointer stream.
    //
Restart:

    ASSERT(openByName || !openForDelete);   // can't delete files opened by ID, so we shouldn't be asking for that

/*BJB*/ openByName = TRUE;  // just ignore the NTFS id for the CS file for now.

    if (NULL == openedFileHandle) {
        //
        // If we've already got the file partially open (which can happen primarily in
        // backup/restore situations), then close what we've got and retry.
        //
        if (NULL != CSFile->UnderlyingFileHandle) {
            NtClose(CSFile->UnderlyingFileHandle);
            CSFile->UnderlyingFileHandle = NULL;
        }

        if (NULL != CSFile->UnderlyingFileObject) {
            ObDereferenceObject(CSFile->UnderlyingFileObject);
            CSFile->UnderlyingFileObject = NULL;
        }

        if (NULL != CSFile->BackpointerStreamFileObject) {
            ObDereferenceObject(CSFile->BackpointerStreamFileObject);
            CSFile->BackpointerStreamFileObject = NULL;
        }

        if (NULL != CSFile->BackpointerStreamHandle) {
            NtClose(CSFile->BackpointerStreamHandle);
            CSFile->BackpointerStreamHandle = NULL;
        }
    }


    if (!(CSFile->Flags & CSFILE_NTFSID_SET)) {
        //
        // We don't know the file id, so we have to open by name.
        //
        openByName = TRUE;
    }

    SIS_MARK_POINT_ULONG(((ULONG_PTR)CSFile)|(ULONG)openByName);

    deviceExtension = CSFile->DeviceObject->DeviceExtension;

    fileName.Buffer = nameFile.nameBuffer;
    fileName.MaximumLength = FN_STACK_BUFFER_LENGTH * sizeof(WCHAR);

    // NB: we can't goto Cleanup until here, because it assumes that
    // fileName.Buffer is initialized.

    //
    // We're going to eventually need to verify that the opened common store file
    // is on the right volume.  We do this by checking to see if it matches
    // with the groveler file object.  If, for some reason, we don't have a groveler
    // file object, then just punt now.  We don't need to disable APCs, because
    // we're in a system thread.
    //

//    ASSERT(IS_SYSTEM_THREAD(PsGetCurrentThread()));
    ExAcquireResourceSharedLite(deviceExtension->GrovelerFileObjectResource, TRUE);
    grovelerFileHeld = TRUE;

    if (NULL == deviceExtension->GrovelerFileObject) {
        SIS_MARK_POINT();

        status = STATUS_DRIVER_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (!openByName) {
        //
        // Try to open the file by ID first.
        //

        status = SipOpenFileById(
                    deviceExtension,
                    &CSFile->CSFileNtfsId,
                    GENERIC_READ,                       // can't have !openByName && openForDelete
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    FILE_NON_DIRECTORY_FILE,
                    &localHandle);

        if (!NT_SUCCESS(status)) {
            //
            // Open by id didn't work, so we'll just try opening by name instead.
            //
            openByName = TRUE;
        } else {

            //
            // Verify that the file we opened is what we think it is.  Do that
            // by verifing its name.
            //
            // OPTIMIZATION: is this faster than just opening-by-name?
            //

            status = NtQueryInformationFile(
                        localHandle,
                        &Iosb,
                        nameFile.nameFileInfo,
                        sizeof(nameFile),
                        FileNameInformation);

            if (NT_SUCCESS(status)) {
                SIZE_T  rc;

                //
                // Compare the directory component first.
                //

                rc = RtlCompareMemory(
                        nameFile.nameFileInfo->FileName,
                        SIS_CSDIR_STRING,
                        min(SIS_CSDIR_STRING_SIZE, nameFile.nameFileInfo->FileNameLength));

                if (rc == SIS_CSDIR_STRING_SIZE) {
                    CSID CSid;

                    //
                    // That matched, now compare the file name component.
                    //

                    fileName.Buffer = nameFile.nameFileInfo->FileName + SIS_CSDIR_STRING_NCHARS;
                    fileName.Length = (USHORT) nameFile.nameFileInfo->FileNameLength - SIS_CSDIR_STRING_SIZE;

                    if (SipFileNameToIndex(&fileName, &CSid) &&
                        IsEqualGUID(&CSid,&CSFile->CSid)) {

                        //
                        // They match.
                        //
                        openByName = FALSE;
                    } else {
                        //
                        // This is some other file, just open by name.
                        //
                        openByName = TRUE;
                    }

                    fileName.Buffer = nameFile.nameBuffer;
                }

            } else {

#if     DBG
                DbgPrint("SIS: SipOpenCSFile: NtQueryInformationFile(1) failed, 0x%x\n",status);
#endif  // DBG

                //
                // Re-try using the name.  Also, reset the CSID valid bit, since it obviously ain't.
                //
                openByName = TRUE;

                KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
                CSFile->Flags &= ~CSFILE_NTFSID_SET;
                KeReleaseSpinLock(CSFile->SpinLock, OldIrql);
            }

            //
            // Close the file if we got a failure above.
            //
            if (openByName) {
                NtClose(localHandle);
#if DBG
                DbgPrint("SIS: SipOpenCSFile: Open by ID failed.\n");
#endif
            }
        }
    }

    if (openByName) {

        //
        // We were unable to open the file by id.  Try opening it by name.
        //
        //  NTRAID#65196-2000/03/10-nealch  If the open-by-ID failed and open-by-name succeeds, 
        //  we should update the ID in the link file reparse info.
        //

        status = SipIndexToFileName(
                    deviceExtension,
                    &CSFile->CSid,
                    0,                      // append bytes
                    TRUE,                   // may allocate
                    &fileName);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        InitializeObjectAttributes(
            &Obja,
            &fileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        status = NtCreateFile(
                    &localHandle,
                    GENERIC_READ | (openForDelete ? DELETE : 0),
                    &Obja,
                    &Iosb,
                    NULL,                               // Allocation Size
                    0,                                  // File Attributes (ignored since we're not creating)
#if DBG
                    (BJBDebug & 0x10000000) ?
                        FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE :
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
#else
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
#endif
                    FILE_OPEN,                          // Don't create if it doesn't already exist
                    FILE_NON_DIRECTORY_FILE,            // Asynchornous (ie., doesn't specify synchronous)
                    NULL,                               // EA buffer
                    0);                                 // EA length

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            localHandle = NULL;
#if     DBG
            if (STATUS_OBJECT_NAME_NOT_FOUND != status) {
                DbgPrint("SIS: SipOpenCSFile: NtCreateFile failed, 0x%x\n",status);
            }
#endif  // DBG
            goto Cleanup;
        }
    }

    if (NULL != openedFileHandle) {
        *openedFileHandle = localHandle;
    } else {
        //
        // See if we need to read in the file id.
        //
        if (!(CSFile->Flags & CSFILE_NTFSID_SET)) {
            status = NtQueryInformationFile(
                        localHandle,
                        &Iosb,
                        internalInfo,
                        sizeof(*internalInfo),
                        FileInternalInformation);

            if (NT_SUCCESS(status)) {

                KeAcquireSpinLock(CSFile->SpinLock, &OldIrql);
                CSFile->Flags |= CSFILE_NTFSID_SET;
                CSFile->CSFileNtfsId = internalInfo->IndexNumber;
                KeReleaseSpinLock(CSFile->SpinLock, OldIrql);

            } else {
                //
                // Just ignore the error and leave the NTFS id invalid.
                //
                SIS_MARK_POINT_ULONG(status);
            }
        }

        CSFile->UnderlyingFileHandle = localHandle;
        CSFile->UnderlyingFileObject = NULL;        // Filled in later

        status = NtQueryInformationFile(
                    localHandle,
                    &Iosb,
                    standardFileInfo,
                    sizeof(*standardFileInfo),
                    FileStandardInformation);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipOpenCSFile: NtQueryInformationFile(2) failed, 0x%x\n",status);
#endif  // DBG
            goto Cleanup;
        }

        CSFile->FileSize = standardFileInfo->EndOfFile;

        // Now we've got a handle, and we really need a pointer to the file object.  Get it.
        status = ObReferenceObjectByHandle(
                    CSFile->UnderlyingFileHandle,
                    0,                                  // Desired access
                    *IoFileObjectType,
                    KernelMode,
                    &CSFile->UnderlyingFileObject,
                    NULL);                              // Handle information

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
#if     DBG
            DbgPrint("SIS: SipOpenCSFile: ObReferenceObjectByHandle failed, 0x%x\n",status);
#endif  // DBG
            goto Cleanup;
        }

        //
        // Veriy that the common store file object is on the right volume.
        //
        if (IoGetRelatedDeviceObject(CSFile->UnderlyingFileObject) !=
            IoGetRelatedDeviceObject(deviceExtension->GrovelerFileObject)) {

            SIS_MARK_POINT();
            status = STATUS_NOT_SAME_DEVICE;

            goto Cleanup;
        }

        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileHeld = FALSE;

        status = SipCreateEvent(
                    SynchronizationEvent,
                    &ioEventHandle,
                    &ioEvent);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        //
        // We need to get the checksum from the file.  First, open the
        // backpointer stream.
        //
        status = SipOpenBackpointerStream(CSFile, FILE_OPEN);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            ASSERT(NULL == CSFile->BackpointerStreamHandle);

            if ((STATUS_OBJECT_NAME_NOT_FOUND == status) ||
                (STATUS_OBJECT_PATH_INVALID == status)) {
                    //
                    // The backpointer stream is just gone.
                    //
                    goto InvalidBPStream;
            }

            goto Cleanup;
        }

        status = ObReferenceObjectByHandle(
                    CSFile->BackpointerStreamHandle,
                    0,                                      // Desired access
                    *IoFileObjectType,
                    KernelMode,
                    &CSFile->BackpointerStreamFileObject,
                    NULL);                                  // Handle Information

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            goto Cleanup;
        }

        zero.QuadPart = 0;

        status = NtReadFile(
                    CSFile->BackpointerStreamHandle,
                    ioEventHandle,
                    NULL,                   // APC routine
                    NULL,                   // APC context
                    &Iosb,
                    backpointerStreamHeader,
                    sizeof(*backpointerStreamHeader),
                    &zero,
                    NULL);                  // key

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == status);

            status = Iosb.Status;
        }

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            if (STATUS_END_OF_FILE == status) {
                //
                // There's nothing in the backpointer stream.
                //
                goto InvalidBPStream;
            }

            goto Cleanup;
        }

        //
        // Check that we got what we thought we should get.
        //
        if (Iosb.Information < sizeof(*backpointerStreamHeader)) {
            //
            // The backpointer stream is gone.  Volume check.  In the interim we can't allow
            // this file open to proceed because we can't verify the checksum, so fail this
            // create.
            //

            status = STATUS_FILE_INVALID;
            goto InvalidBPStream;

        } else if (BACKPOINTER_MAGIC != backpointerStreamHeader->Magic) {
            SIS_MARK_POINT();

            status = STATUS_FILE_INVALID;
            goto InvalidBPStream;

        } else if (BACKPOINTER_STREAM_FORMAT_VERSION != backpointerStreamHeader->FormatVersion) {
            SIS_MARK_POINT();

            status = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }

        CSFile->Checksum = backpointerStreamHeader->FileContentChecksum;

        //
        // Guesstimate the BPStreamEntries value by looking at the length of the BP stream.
        //

        status = NtQueryInformationFile(
                    CSFile->BackpointerStreamHandle,
                    &Iosb,
                    standardFileInfo,
                    sizeof(*standardFileInfo),
                    FileStandardInformation);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            goto Cleanup;
        }

        CSFile->BPStreamEntries = (ULONG)(standardFileInfo->EndOfFile.QuadPart / sizeof(SIS_BACKPOINTER) - SIS_BACKPOINTER_RESERVED_ENTRIES);

        if (CSFile->BPStreamEntries < 1) {
            SIS_MARK_POINT_ULONG(CSFile->BPStreamEntries);
            SipCheckVolume(deviceExtension);
        }

        //
        // If the backpointer stream is not a multiple of sector size, make it so.
        // Fill the end of the last sector with MAXLONGLONG fields.
        //
        sectorFill = (ULONG) (standardFileInfo->EndOfFile.QuadPart % deviceExtension->FilesystemVolumeSectorSize);

        if (sectorFill != 0) {
            SIS_BACKPOINTER fillBP[1];
            LARGE_INTEGER ef = {FILE_WRITE_TO_END_OF_FILE, -1};
            PCHAR sectorFillBuffer;
            PCHAR s, d;
            int i, c;

            SIS_MARK_POINT_ULONG(standardFileInfo->EndOfFile.LowPart);

            fillBP->LinkFileIndex.QuadPart = MAXLONGLONG;
            fillBP->LinkFileNtfsId.QuadPart = MAXLONGLONG;

            //
            // Convert from # bytes used to # bytes free.
            //
            sectorFill = deviceExtension->FilesystemVolumeSectorSize - sectorFill;

            sectorFillBuffer = ExAllocatePoolWithTag(PagedPool, sectorFill, ' siS');
            if (NULL == sectorFillBuffer) {
                SIS_MARK_POINT();
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Fill the buffer from back to front, since we know the
            // back end is aligned and the front may not be.
            //
            c = min(sectorFill, sizeof(SIS_BACKPOINTER));

            d = sectorFillBuffer + sectorFill - c;
            s = (PCHAR) (fillBP + 1) - c;
            memcpy(d, s, c);

            s = sectorFillBuffer + sectorFill;
            s--; d--;

            for (i = sectorFill - c; i > 0; --i) {
                *d-- = *s--;
            }

            ASSERT(d+1 == sectorFillBuffer);

            status = NtWriteFile(
                        CSFile->BackpointerStreamHandle,
                        ioEventHandle,
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &Iosb,
                        sectorFillBuffer,
                        sectorFill,
                        &ef,
                        NULL);                  // key

            if (STATUS_PENDING == status) {
                status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
                ASSERT(STATUS_SUCCESS == status);

                status = Iosb.Status;
            }

            ExFreePool(sectorFillBuffer);

            if (!NT_SUCCESS(status)) {
                SIS_MARK_POINT_ULONG(status);
                goto Cleanup;
            }

            CSFile->BPStreamEntries = (ULONG)
                ((standardFileInfo->EndOfFile.QuadPart + deviceExtension->FilesystemVolumeSectorSize - 1) /
                    deviceExtension->FilesystemVolumeSectorSize) * deviceExtension->BackpointerEntriesPerSector -
                    SIS_BACKPOINTER_RESERVED_ENTRIES;
        }

#if DBG
        if (BJBDebug & 0x200) {
            DbgPrint("SIS: SipOpenCSFileWork: CS file has checksum 0x%x.%x\n",
                        (ULONG)(CSFile->Checksum >> 32),(ULONG)CSFile->Checksum);
        }
#endif  // DBG

        ASSERT((CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) % deviceExtension->BackpointerEntriesPerSector == 0);
    }

    status = STATUS_SUCCESS;

Cleanup:

    if (grovelerFileHeld) {
        ExReleaseResourceLite(deviceExtension->GrovelerFileObjectResource);
        grovelerFileHeld = FALSE;
    }

    if (!NT_SUCCESS(status)) {
        if (NULL != localHandle) {
            NtClose(localHandle);
            localHandle = NULL;

            if (NULL != openedFileHandle) {
                *openedFileHandle = NULL;
            } else {
                CSFile->UnderlyingFileHandle = NULL;
                if (NULL != CSFile->UnderlyingFileObject) {
                    ObDereferenceObject(CSFile->UnderlyingFileObject);
                    CSFile->UnderlyingFileObject = NULL;
                }
            }
        }

        if ((NULL != CSFile->BackpointerStreamHandle) && (NULL == openedFileHandle)) {
            NtClose(CSFile->BackpointerStreamHandle);

            if (NULL != CSFile->BackpointerStreamFileObject) {
                ObDereferenceObject(CSFile->BackpointerStreamFileObject);
            }

            CSFile->BackpointerStreamHandle = NULL;
            CSFile->BackpointerStreamFileObject = NULL;
        }
    }

    if (fileName.Buffer != nameFile.nameBuffer) {
        ExFreePool(fileName.Buffer);
    }

    if (NULL != ioEvent) {
        ObDereferenceObject(ioEvent);
        ioEvent = NULL;
    }

    if (NULL != ioEventHandle) {
        NtClose(ioEventHandle);
        ioEventHandle = NULL;
    }

    if (retry) {
        retry = FALSE;
        goto Restart;
    }

    ASSERT((CSFile->BPStreamEntries + SIS_BACKPOINTER_RESERVED_ENTRIES) % deviceExtension->BackpointerEntriesPerSector == 0 ||
            ((CSFile->Flags & (CSFILE_FLAG_DELETED|CSFILE_FLAG_CORRUPT)) && 0 == CSFile->BPStreamEntries) ||
            !NT_SUCCESS(status));

    return status;


InvalidBPStream:

    //
    // The backpointer stream is corrupt, attempt to fix it.
    //
    ASSERT(NULL != CSFile->UnderlyingFileHandle);
    ASSERT(NULL != ioEventHandle && NULL != ioEvent);

    switch (status) {
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_INVALID:
        //
        // The backpointer stream is missing.  Create it.
        //
        ASSERT(NULL == CSFile->BackpointerStreamHandle);

        status = SipOpenBackpointerStream(CSFile, FILE_CREATE);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            break;
        }

    case STATUS_FILE_INVALID:
    case STATUS_END_OF_FILE:
        //
        // The backpointer stream header is corrupt, ie. the stream is
        // smaller than the header, or the magic number is invalid.
        // Rebuild it.
        //
        ASSERT(NULL != CSFile->BackpointerStreamHandle);

        status = SipComputeCSChecksum(
                    CSFile,
                    &csFileChecksum,
                    ioEventHandle,
                    ioEvent);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);
            break;
        }

        //
        // Initialize the backpointer sector.  First write the header,
        // then fill in the remainder of the backpointer entries.
        //

        backpointerStreamHeader->FormatVersion = BACKPOINTER_STREAM_FORMAT_VERSION;
        backpointerStreamHeader->Magic = BACKPOINTER_MAGIC;
        backpointerStreamHeader->FileContentChecksum = csFileChecksum;

        //
        // Write the stream header to disk.
        //

        zero.QuadPart = 0;

        status = ZwWriteFile(
                        CSFile->BackpointerStreamHandle,
                        ioEventHandle,
                        NULL,                   // APC Routine
                        NULL,                   // APC Context
                        &Iosb,
                        backpointerStreamHeader,
                        sizeof *backpointerStreamHeader,
                        &zero,
                        NULL);                  // key

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(ioEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(status == STATUS_SUCCESS); // Since we've got this pointed at our stack, it must succeed.

            status = Iosb.Status;
        }

        //
        // If all repairs have succeeded, retry from the top.
        //
        if (NT_SUCCESS(status))
            retry = TRUE;

        break;

    default:
        ASSERT(!"SipOpenCSFileWork: Internal Error");
    }

    goto Cleanup;
#undef  FN_STACK_BUFFER_LENGTH
}

VOID
SipOpenCSFile(
    IN OUT PSI_OPEN_CS_FILE     openRequest
    )
/*++

Routine Description:

    Open a file in the common store.  We must hold the UFOMutant to call this routine.

Arguments:

    openRequest - Argument packet.

Return Value:

    None

--*/
{
    openRequest->openStatus = SipOpenCSFileWork(
                                    openRequest->CSFile,
                                    openRequest->openByName,
                                    FALSE,                      // volcheck
                                    FALSE,                      // openForDelete
                                    NULL);

    KeSetEvent(openRequest->event,IO_NO_INCREMENT,FALSE);
}

PVOID
SipMapUserBuffer(
    IN OUT PIRP                         Irp)
{
    PVOID SystemBuffer;
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        //
        //  MM can return NULL if there are no system ptes.  We just pass it through, and let the
        //  caller deal with it.
        //

        SystemBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );

        return SystemBuffer;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                              Debug Support
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if     DBG
LONG
SipAllocateMarkPoint(void)
{
    LONG    MarkPointThis;
    KIRQL   OldIrql;

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);
    MarkPointThis = GCHMarkPointNext;
    GCHMarkPointNext = (GCHMarkPointNext + 1)%GCH_MARK_POINT_ROLLOVER;
    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);

    RtlZeroMemory(GCHMarkPointStrings[MarkPointThis],GCH_MARK_POINT_STRLEN);

    return MarkPointThis;
}

VOID
SipMarkPointUlong(
    IN PCHAR pszFile,
    IN ULONG nLine,
    IN ULONG_PTR value
    )
{
    LONG MarkPointThis = SipAllocateMarkPoint();
    PCHAR sp = strrchr(pszFile, '\\');
    LARGE_INTEGER tickCount;
    PCHAR buffer = GCHMarkPointStrings[MarkPointThis];
    int ccnt;

    ASSERT((buffer - GCHMarkPointStrings[0]) % GCH_MARK_POINT_STRLEN == 0);

    if (sp)
        pszFile = sp + 1;

    KeQueryTickCount(&tickCount);

    ccnt = sprintf(buffer, "%-12s\t%4d\tT: %p\tTC:%d\t%p",
                    pszFile,
                    nLine,
                    PsGetCurrentThread(),
                    tickCount.LowPart,
                    value);

    ASSERT(ccnt < GCH_MARK_POINT_STRLEN);

    if (GCHEnableMarkPoint > 0)
        DbgPrint("SIS:  %s\n", GCHMarkPointStrings[MarkPointThis]);

}
#endif  // DBG

#if     DBG
VOID SipMarkPoint(
    IN PCHAR pszFile,
    IN ULONG nLine
    )
{
    LONG MarkPointThis = SipAllocateMarkPoint();
    PCHAR sp = strrchr(pszFile, '\\');
    LARGE_INTEGER tickCount;
    PCHAR buffer = GCHMarkPointStrings[MarkPointThis];
    int ccnt;

    ASSERT((buffer - GCHMarkPointStrings[0]) % GCH_MARK_POINT_STRLEN == 0);

    if (sp)
        pszFile = sp + 1;

    KeQueryTickCount(&tickCount);

    ccnt = sprintf(buffer, "%-12s\t%4d\tT: %p\tTC:%d",
                    pszFile,
                    nLine,
                    PsGetCurrentThread(),
                    tickCount.LowPart);

    ASSERT(ccnt < GCH_MARK_POINT_STRLEN);

    if (GCHEnableMarkPoint > 0)
        DbgPrint("SIS:  %s\n", buffer);
}



ULONG DisplayIndexMin = 0;
ULONG DisplayIndexMax = 0;

BOOLEAN DumpCheckpointLog = FALSE;

ULONG CheckpointMarkPointNext = 0;
CHAR  CheckpointMarkPointStrings[GCH_MARK_POINT_ROLLOVER][GCH_MARK_POINT_STRLEN];


VOID
SipCheckpointLog()
{
    KIRQL       OldIrql;

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);

    RtlCopyMemory(CheckpointMarkPointStrings, GCHMarkPointStrings, sizeof(CHAR) * GCH_MARK_POINT_ROLLOVER * GCH_MARK_POINT_STRLEN);

    CheckpointMarkPointNext = GCHMarkPointNext;
    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);
}

VOID
SipAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    KIRQL   OldIrql;
    ULONG   i;

    //
    // Take the MarkPointSpinLock.  This will stop other processors from
    // messing with the debug log, and will also effectively stop all of
    // the other processors pretty quickly as they try to make debug log
    // entries.
    //

    KeAcquireSpinLock(MarkPointSpinLock, &OldIrql);

    DisplayIndexMin = DisplayIndexMax = GCHMarkPointNext;

    DbgPrint("***  SIS assertion failed: %s\n",FailedAssertion);
    DbgPrint("***    Source File: %s, line %d\n",FileName,LineNumber);
    if (NULL != Message) {
        DbgPrint("%s\n",Message);
    }
    DbgBreakPoint();

    if (DumpCheckpointLog) {
        DisplayIndexMin = (CheckpointMarkPointNext + 1) % GCH_MARK_POINT_ROLLOVER;
        DisplayIndexMax = CheckpointMarkPointNext;
    }

    while (DisplayIndexMin != DisplayIndexMax) {
        for (   i = DisplayIndexMin;
                i != DisplayIndexMax % GCH_MARK_POINT_ROLLOVER;
                i = (i+1)%GCH_MARK_POINT_ROLLOVER
            ) {
                if (DumpCheckpointLog) {
                    DbgPrint(   "%d\t%s\n",
                            (i + GCH_MARK_POINT_ROLLOVER - CheckpointMarkPointNext) % GCH_MARK_POINT_ROLLOVER,
                            CheckpointMarkPointStrings[i]);
                } else {
                    DbgPrint(   "%d\t%s\n",
                            (i + GCH_MARK_POINT_ROLLOVER - GCHMarkPointNext) % GCH_MARK_POINT_ROLLOVER,
                            GCHMarkPointStrings[i]);
                }
        }

        DisplayIndexMin = DisplayIndexMax = GCHMarkPointNext;
        DumpCheckpointLog = FALSE;

        DbgBreakPoint();
    }

    KeReleaseSpinLock(MarkPointSpinLock, OldIrql);
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sis.h ===
/*++

Copyright (c) 1997, 1998	Microsoft Corporation

Module Name:

	sis.h

Abstract:

	Exported data structure definitions for the Single Instance Store.  Note: these definitions
	are only exported to other NT components (in particular sisbackup), not to external users.

Author:

	Bill Bolosky		[bolosky]		March 1998

Revision History:

--*/

typedef	GUID CSID, *PCSID;

typedef union _LINK_INDEX {
    struct {
        ULONG       LowPart;
        ULONG       HighPart : 31;
    };
    struct {
        ULONGLONG   QuadPart : 63,
                    Check    : 1;
    };
} LINK_INDEX, *PLINK_INDEX;

//
// The maximum length of the filename part of a file with an index name.  The
// filename format is <guid>.sis where ".sis" is a literal and <guid>
// is the standard striung representation of the GUID that is the common store
// id for the file with the curly braces stripped off.
//
#define	INDEX_MAX_NUMERIC_STRING_LENGTH (40 * sizeof(WCHAR)) // 36 for the guid (without "{}" and 4 for ".sis"

//
// Definitions for the checksum stream on a SIS file.
//
#define	BACKPOINTER_STREAM_NAME			L":sisBackpointers$"
#define	BACKPOINTER_STREAM_NAME_SIZE	(17 * sizeof(WCHAR))

//
// A backpointer entry, mapping LinkFileIndex -> LinkFileNtfsId.
//
typedef struct _SIS_BACKPOINTER {
	LINK_INDEX							LinkFileIndex;

	LARGE_INTEGER						LinkFileNtfsId;
} SIS_BACKPOINTER, *PSIS_BACKPOINTER;

#define	SIS_BACKPOINTER_RESERVED_ENTRIES	1		// # entries in the first sector reserved for other junk

//
// The header that fits in the space saved by "SIS_BACKPOINTER_RESERVED_ENTRIES" at the
// beginning of each backpointer stream.
//
typedef struct _SIS_BACKPOINTER_STREAM_HEADER {
	//
	// The format of the backpointer stream.  Incremented when we change this or
	// SIS_BACKPOINTER.
	//
	ULONG								FormatVersion;

	//
	// A magic number to identify that this is really what we think it is.
	//
	ULONG								Magic;

	//
	// A checksum of the contents of the file; used to verify that reparse
	// points are valid.
	//
	LONGLONG							FileContentChecksum;
} SIS_BACKPOINTER_STREAM_HEADER, *PSIS_BACKPOINTER_STREAM_HEADER;

#define	BACKPOINTER_STREAM_FORMAT_VERSION	1
#define	BACKPOINTER_MAGIC					0xf1ebf00d

#if 0
//
// Version 1 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V1 {
	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 1.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;
} SI_REPARSE_BUFFER_V1, *PSI_REPARSE_BUFFER_V1;

//
// Version 2 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V2 {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 2.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER_V2, *PSI_REPARSE_BUFFER_V2;

//
// Version 3 of the SIS reparse point buffer.
//
typedef struct _SI_REPARSE_BUFFER_V3 {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 3.
	//
	ULONG							ReparsePointFormatVersion;

	//
	// The index of the common store file.
	//
	CSINDEX							CSIndex;

	//
	// The index of this link file.
	//
	CSINDEX							LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER_V3, *PSI_REPARSE_BUFFER_V3;
#endif

//
// Version 4 and version 5 of the reparse point buffer are
// identical in structure.  The only difference is that version
// 5 reparse points were created after the problems with
// allocated ranges in the source files of small copies was fixed,
// and so are eligible for partial final copy.  Version 4 files
// are not.
//

//
// The bits that are actually in a SIS reparse point.  Version 5.
//
typedef struct _SI_REPARSE_BUFFER {

	//
	// A version number so that we can change the reparse point format
	// and still properly handle old ones.  This structure describes
	// version 4.
	//
	ULONG							ReparsePointFormatVersion;

	ULONG							Reserved;

	//
	// The id of the common store file.
	//
	CSID							CSid;

	//
	// The index of this link file.
	//
	LINK_INDEX						LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

	//
	// A "131 hash" checksum of the contents of the
	// common store file.
	//
	LONGLONG						CSChecksum;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SI_REPARSE_BUFFER, *PSI_REPARSE_BUFFER;

#define	SIS_REPARSE_BUFFER_FORMAT_VERSION			5
#define	SIS_MAX_REPARSE_DATA_VALUE_LENGTH (sizeof(SI_REPARSE_BUFFER))
#define SIS_REPARSE_DATA_SIZE (FIELD_OFFSET(REPARSE_DATA_BUFFER,GenericReparseBuffer)+SIS_MAX_REPARSE_DATA_VALUE_LENGTH)

#define SIS_CSDIR_STRING            		L"\\SIS Common Store\\"
#define SIS_CSDIR_STRING_NCHARS     		18
#define SIS_CSDIR_STRING_SIZE       		(SIS_CSDIR_STRING_NCHARS * sizeof(WCHAR))

#define	SIS_GROVELER_FILE_STRING			L"GrovelerFile"
#define	SIS_GROVELER_FILE_STRING_NCHARS		12
#define	SIS_GROVELER_FILE_STRING_SIZE		(SIS_GROVELER_FILE_STRING_NCHARS * sizeof(WCHAR))

#define	SIS_VOLCHECK_FILE_STRING			L"VolumeCheck"
#define	SIS_VOLCHECK_FILE_STRING_NCHARS		11
#define	SIS_VOLCHECK_FILE_STRING_SIZE		(SIS_VOLCHECK_FILE_STRING_NCHARS * sizeof(WCHAR))

typedef struct _SIS_LINK_FILES {
	ULONG					operation;
	union {
			struct {
				HANDLE			file1;
				HANDLE			file2;
				HANDLE			abortEvent;
			} Merge;

			struct {
				HANDLE			file1;
				HANDLE			abortEvent;
				CSID			CSid;
			} MergeWithCS;

			struct {
				CSID			CSid;
			} HintNoRefs;

			struct {
				HANDLE			file;
			} VerifyNoMap;
	} u;
} SIS_LINK_FILES, *PSIS_LINK_FILES;


#define	SIS_LINK_FILES_OP_MERGE				0xb0000001
#define	SIS_LINK_FILES_OP_MERGE_CS			0xb0000002
#define	SIS_LINK_FILES_OP_HINT_NO_REFS		0xb0000003
#define	SIS_LINK_FILES_OP_VERIFY_NO_MAP		0xb0000004
#define	SIS_LINK_FILES_CHECK_VOLUME			0xb0000005

#define	LOG_FILE_NAME		L"LogFile"
#define	LOG_FILE_NAME_LEN	(7 * sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sisuprt.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sisuprt.c

Abstract:

    General support routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

#if     DBG
//
// Counts of how many of these things are active in the system.
//
ULONG           outstandingCSFiles = 0;
ULONG           outstandingPerLinks = 0;
ULONG           outstandingSCBs = 0;
ULONG           outstandingPerFOs = 0;
ULONG           totalScbReferences = 0;
ULONG           totalScbReferencesByType[NumScbReferenceTypes];

//
// Setting this forces an assert the next time we go through SipIsFileObjectSIS.
//
ULONG BJBAssertNow = 0;
#endif  // DBG

#if     TIMING
ULONG   BJBDumpTimingNow = 0;
ULONG   BJBClearTimingNow = 0;
#endif  // TIMING

#if     COUNTING_MALLOC
ULONG   BJBDumpCountingMallocNow = 0;
#endif  // COUNTING_MALLOC

#if     DBG
VOID
SipVerifyTypedScbRefcounts(
    IN PSIS_SCB                 scb)
/*++

Routine Description:

    Check to see that the total of all of the different typed refcounts
    in the scb is the same as the scb's overall reference count.

    The caller must hold the ScbSpinLock for the volume.

Arguments:

    scb - the scb to check

Return Value:

    VOID

--*/
{
    ULONG               totalReferencesByType = 0;
    SCB_REFERENCE_TYPE  referenceTypeIndex;

    //
    // Verify that the typed ref counts match the total ref count.
    //
    for (   referenceTypeIndex = RefsLookedUp;
            referenceTypeIndex < NumScbReferenceTypes;
            referenceTypeIndex++) {

            ASSERT(scb->referencesByType[referenceTypeIndex] <= scb->RefCount); // essentially checking for negative indices

            totalReferencesByType += scb->referencesByType[referenceTypeIndex];
    }

    ASSERT(totalReferencesByType == scb->RefCount);
}
#endif  // DBG

PSIS_SCB
SipLookupScb(
    IN PLINK_INDEX                      PerLinkIndex,
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   LinkFileNtfsId,
    IN PLARGE_INTEGER                   CSFileNtfsId,
    IN PUNICODE_STRING                  StreamName,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN PETHREAD                         RequestingThread,
    OUT PBOOLEAN                        FinalCopyInProgress,
    OUT PBOOLEAN                        LinkIndexCollision)
/*++

Routine Description:

    Find an SCB based on the per link index, cs index, stream name
    and volume (represented by the device object).  If an SCB already
    exists for the desired stream then we return it, otherwise we create
    and initialize it.  In any case, the caller gets a reference to it
    which must eventually be destroyed by calling SipDereferenceScb.

    We set the "final copy" boolean according as the file is in a final
    copy state at the time that the lookup is performed.

    This routine must be called at PASSIVE_LEVEL (ie., APCs can't be
    masked).

Arguments:

    PerLinkIndex        - The index of the link for this scb

    CSid                - The id of the common store file for this scb

    LinkFileNtfsId      - The link file's id

    CSFileNtfsId        - The common store file's id

    StreamName          - The name of the particular stream we're using

    DeviceObject        - The D.O. for the volume on which this stream lives

    RequestingThread    - The thread that launched the irp that's causing us to
                            do this lookup.  If this is the COWing thread,
                            we won't set FinalCopyInProgress

    FinalCopyInProgress - Returns TRUE iff there is a final copy in progress
                            on this file.

Return Value:

    A pointer to the SCB, or NULL if one couldn't be found or allocated
    (most likely because of out of memory).

--*/
{
    PSIS_SCB                scb;
    KIRQL                   OldIrql;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE               scbTree = deviceExtension->ScbTree;
    SCB_KEY                 scbKey[1];

    UNREFERENCED_PARAMETER( StreamName );
    UNREFERENCED_PARAMETER( LinkIndexCollision );
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the search key with the link index.
    //
    scbKey->Index = *PerLinkIndex;

    //
    // Lock out other table modifications/queries.
    //
    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    //
    // Search for an existing scb.
    //
    scb = SipLookupElementTree(scbTree, scbKey);

    if (!scb) {
        //
        // There is no scb matching this index & name.  Make one.
        //

        scb = ExAllocatePoolWithTag( NonPagedPool, sizeof (SIS_SCB), 'SsiS');
        if (!scb) {
            SIS_MARK_POINT();
            KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
            return NULL;
        }

#if     DBG
        InterlockedIncrement(&outstandingSCBs);
#endif  // DBG

        RtlZeroMemory(scb,sizeof(SIS_SCB));

        SIS_MARK_POINT_ULONG(scb);

        scb->PerLink = SipLookupPerLink(
                           PerLinkIndex,
                           CSid,
                           LinkFileNtfsId,
                           CSFileNtfsId,
                           DeviceObject,
                           RequestingThread,
                           FinalCopyInProgress);

        if (!scb->PerLink) {
            goto releaseAndPunt;
        }

        ASSERT(scb->PerLink->Index.QuadPart == PerLinkIndex->QuadPart);

        scb->RefCount = 1;

#if     DBG
        scb->referencesByType[RefsLookedUp] = 1;
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsLookedUp]);
#endif  // DBG

        ExInitializeFastMutex(scb->FastMutex);

        //
        // Add it to the tail of the scb list.
        //
        InsertTailList(&deviceExtension->ScbList, &scb->ScbList);

#if DBG
        {
        PSIS_SCB scbNew =
#endif

        SipInsertElementTree(scbTree, scb, scbKey);

#if DBG
        ASSERT(scbNew == scb);
        }
#endif

    } else {
        //
        // An scb matching this index & name was found.
        //

        scb->RefCount++;

        SIS_MARK_POINT_ULONG(scb);

#if     DBG
        //
        // Increment the appropriate refs-by-type count, and then assert that the total
        // refs-by-type is the same as the overall reference count.
        //
        scb->referencesByType[RefsLookedUp]++;
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsLookedUp]);
#endif  // DBG


        //
        // Handle final-copy-in-progress processing.
        //

        SIS_MARK_POINT_ULONG(scb->PerLink->COWingThread);
        SIS_MARK_POINT_ULONG(RequestingThread);

        if (RequestingThread != scb->PerLink->COWingThread || NULL == RequestingThread) {
            KeAcquireSpinLockAtDpcLevel(scb->PerLink->SpinLock);
            if (scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY) {

                *FinalCopyInProgress = TRUE;
                if (!(scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS)) {
                    //
                    // We're the first waiter.  Set the bit and clear the event.
                    //
                    SIS_MARK_POINT_ULONG(scb);

                    scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY_WAITERS;
                    KeClearEvent(scb->PerLink->Event);
                } else {
                    SIS_MARK_POINT_ULONG(scb);
                }
            } else {
                *FinalCopyInProgress = FALSE;
            }
            KeReleaseSpinLockFromDpcLevel(scb->PerLink->SpinLock);
        }
    }

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    //
    // We need to assure that the SCB is properly initialized.  Acquire the SCB
    // and check the initialized bit.
    //
    SipAcquireScb(scb);

    if (scb->Flags & SIS_SCB_INITIALIZED) {
        SIS_MARK_POINT();
        SipReleaseScb(scb);
        return scb;
    }

    //
    // Now handle the part of the initialization that can't happen at
    // DISPATCH_LEVEL.
    //

    //  Initialize the scb's file lock record
    FsRtlInitializeFileLock( &scb->FileLock, SiCompleteLockIrpRoutine, NULL );

    //
    // Initialize the Ranges large mcb.  We probably should postpone
    // doing this until we do copy-on-write or take a fault on
    // the file, but for now we'll just do it off the bat.
    //
    FsRtlInitializeLargeMcb(scb->Ranges,NonPagedPool);
    scb->Flags |= SIS_SCB_MCB_INITIALIZED|SIS_SCB_INITIALIZED;

    //
    // Don't bother to initialize the FileId field
    // until copy-on-write time.
    //

    SipReleaseScb(scb);

//  SIS_MARK_POINT_ULONG(scb);

    return scb;

releaseAndPunt:

    // We can only come here before the scb has been inserted into the tree.

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    if (scb->PerLink) {
        SipDereferencePerLink(scb->PerLink);
    }

#if     DBG
    InterlockedDecrement(&outstandingSCBs);
#endif  // DBG

    ExFreePool(scb);

    return NULL;
}

VOID
SipReferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType)
{
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                   OldIrql;
#if DBG
    ULONG               totalReferencesByType = 0;
#endif  // DBG

    UNREFERENCED_PARAMETER( referenceType );

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    ASSERT(scb->RefCount > 0);

    scb->RefCount++;

#if     DBG
    //
    // Update the typed ref counts
    //
    scb->referencesByType[referenceType]++;

    SipVerifyTypedScbRefcounts(scb);

    InterlockedIncrement(&totalScbReferencesByType[referenceType]);
    InterlockedIncrement(&totalScbReferences);
#endif  // DBG

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
}

typedef struct _SI_DEREFERENCE_SCB_REQUEST {
    WORK_QUEUE_ITEM         workItem[1];
    PSIS_SCB                scb;
    SCB_REFERENCE_TYPE      referenceType;
} SI_DEREFERENCE_SCB_REQUEST, *PSI_DEREFERENCE_SCB_REQUEST;

VOID
SiPostedDereferenceScb(
    IN PVOID                            parameter)
/*++

Routine Description:

    Someone tried to remove the final reference from an SCB at elevated IRQL.  Since
    that's not directly possible, the request has been posted.  We're on a worker thread
    at PASSIVE_LEVEL now, so we can drop the reference.

Arguments:

    parameter - a PVOID PSI_DEREFERENCE_SCB_REQUEST.


Return Value:

    void

--*/
{
    PSI_DEREFERENCE_SCB_REQUEST request = parameter;

    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    SipDereferenceScb(request->scb,request->referenceType);

    ExFreePool(request);
}

VOID
SipDereferenceScb(
    IN PSIS_SCB                         scb,
    IN SCB_REFERENCE_TYPE               referenceType)
/*++

Routine Description:

    Drop a reference to an SCB.  If appropriate, clean up the SCB, etc.

    This function must be called at IRQL <= DISPATCH_LEVEL.

Arguments:

    scb - the scb to which we want to drop our reference

    referenceType   - the type of the reference we're dropping; only used in DBG code.

Return Value:

    void

--*/
{

    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL               InitialIrql;
#if DBG
    ULONG               totalReferencesByType = 0;
#endif  // DBG

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &InitialIrql);

    ASSERT(InitialIrql <= DISPATCH_LEVEL);

    ASSERT(scb->RefCount != 0);

	if ((1 == scb->RefCount) && ((DISPATCH_LEVEL == InitialIrql) || (IoGetRemainingStackSize() < 4096))) {
		PSI_DEREFERENCE_SCB_REQUEST	request;

        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

        SIS_MARK_POINT_ULONG(scb);

        //
        // We're at elevated IRQL and this is the last reference.  Post the dereference of the scb.
        //
        request = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREFERENCE_SCB_REQUEST), ' siS');
        if (NULL == request) {

            //
            // We're basically hosed here.  Just dribble the scb reference.
            // This is way bad, partly because we're leaking nonpaged memory
            // while we're out of memory, and partly because we'll never remove
            // the last scb reference and so possibly never do final copy.
            // BUGBUGBUG : This must be fixed.
            //
            SIS_MARK_POINT();
#if     DBG
            DbgPrint("SIS: SipDereferenceScb: couldn't allocate an SI_DEREFERENCE_SCB_REQUEST.  Dribbling SCB 0x%x\n",scb);
#endif  // DBG
            return;
        }

        request->scb = scb;
        request->referenceType = referenceType;

        ExInitializeWorkItem(request->workItem, SiPostedDereferenceScb, request);
        ExQueueWorkItem(request->workItem, CriticalWorkQueue);

        return;
    }

    scb->RefCount--;

#if     DBG
    //
    // Update the typed ref counts
    //
    ASSERT(scb->referencesByType[referenceType] != 0);
    scb->referencesByType[referenceType]--;
    SipVerifyTypedScbRefcounts(scb);

    InterlockedDecrement(&totalScbReferencesByType[referenceType]);
    InterlockedDecrement(&totalScbReferences);
#endif  // DBG

    if (scb->RefCount == 0) {
        PDEVICE_EXTENSION   deviceExtension = scb->PerLink->CsFile->DeviceObject->DeviceExtension;
        KIRQL               NewIrql;
        PSIS_TREE           scbTree = deviceExtension->ScbTree;

        SIS_MARK_POINT_ULONG(scb);

        //
        // Before freeing this SCB, we need to see if we have to do a final copy on it.
        // Really, this should happen based on the perLink not the SCB, but for now...
        //
        KeAcquireSpinLock(scb->PerLink->SpinLock, &NewIrql);

        ASSERT((scb->PerLink->Flags & SIS_PER_LINK_FINAL_COPY) == 0);

        if ((scb->PerLink->Flags & (SIS_PER_LINK_DIRTY|SIS_PER_LINK_FINAL_COPY_DONE)) == SIS_PER_LINK_DIRTY) {

            scb->PerLink->Flags |= SIS_PER_LINK_FINAL_COPY;

            KeReleaseSpinLock(scb->PerLink->SpinLock, NewIrql);

            //
            // Restore a reference, which we're handing to SipCompleteCopy
            //
            scb->RefCount = 1;

#if     DBG
            scb->referencesByType[RefsFinalCopy] = 1;

            InterlockedIncrement(&totalScbReferences);
            InterlockedIncrement(&totalScbReferencesByType[RefsFinalCopy]);
#endif  // DBG

            KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

            //
            // Now send the SCB off to complete copy.  Because of the flag we
            // just set in the per link, no one will be able to open this file
            // until the copy completes.
            //

            SIS_MARK_POINT_ULONG(scb);

            SipCompleteCopy(scb,FALSE);

            return;
        }

        //
        // The final copy is finished or isn't needed.  Either way, we can
        // proceed with releasing the scb.
        //
        KeReleaseSpinLock(scb->PerLink->SpinLock, NewIrql);

        //
        // Pull the SCB out of the tree.
        //
#if DBG // Make sure it's in the tree before we remove it.
        {
        SCB_KEY scbKey[1];
        scbKey->Index = scb->PerLink->Index;

        ASSERT(scb == SipLookupElementTree(scbTree, scbKey));
        }
#endif
        SipDeleteElementTree(scbTree, scb);

        //
        // Remove the scb from the scb list.
        //
        RemoveEntryList(&scb->ScbList);

        // Now no one can reference the structure but us, so we can drop the lock

        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);

        //
        //  Uninitialize the byte range file locks and opportunistic locks
        //
        FsRtlUninitializeFileLock(&scb->FileLock);

        if (scb->Flags & SIS_SCB_MCB_INITIALIZED) {
            FsRtlUninitializeLargeMcb(scb->Ranges);
            scb->Flags &= ~SIS_SCB_MCB_INITIALIZED;
        }

        SipDereferencePerLink(scb->PerLink);

        //
        // If there is a predecessor scb, we need to drop our reference to it.
        //
        if (scb->PredecessorScb) {
            SipDereferenceScb(scb->PredecessorScb, RefsPredecessorScb);
        }

        SIS_MARK_POINT_ULONG(scb);

#if     DBG
        InterlockedDecrement(&outstandingSCBs);
#endif  // DBG

        ExFreePool(scb);
    } else {
        KeReleaseSpinLock(deviceExtension->ScbSpinLock, InitialIrql);
    }
//  SIS_MARK_POINT_ULONG(scb);
}

#if		DBG
VOID
SipTransferScbReferenceType(
	IN PSIS_SCB							scb,
	IN SCB_REFERENCE_TYPE				oldReferenceType,
	IN SCB_REFERENCE_TYPE				newReferenceType)
/*++

Routine Description:

	Transfer a reference to a scb from one type to another.
	This is only defined in the checked build, because we don't
	track reference types in free builds (they're only for debugging,
	all we need for proper execution is the reference count, which
	isn't changed by this call).  In the free build this is a macro
	that expands to nothing.

Arguments:

	scb - the scb for which we want to transfer our reference

	oldReferenceType	- the type of the reference we're dropping
	newReferenceType	- the type of the reference we're adding

Return Value:

	void

--*/
{
	PDEVICE_EXTENSION		deviceExtension = (PDEVICE_EXTENSION)scb->PerLink->CsFile->DeviceObject->DeviceExtension;
	KIRQL					OldIrql;

	KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

	ASSERT(scb->RefCount > 0);
	ASSERT(0 < scb->referencesByType[oldReferenceType]);
	scb->referencesByType[oldReferenceType]--;
	scb->referencesByType[newReferenceType]++;

	SipVerifyTypedScbRefcounts(scb);

	InterlockedDecrement(&totalScbReferencesByType[oldReferenceType]);
	InterlockedIncrement(&totalScbReferencesByType[newReferenceType]);

	KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);
}
#endif	// DBG

LONG
SipScbTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PSCB_KEY scbKey = (PSCB_KEY) Key;
    PSIS_SCB scb = (PSIS_SCB) Node;
    LONGLONG r;

    r = scbKey->Index.QuadPart - scb->PerLink->Index.QuadPart;

    if (r > 0)
        return 1;
    else if (r < 0)
        return -1;
    else
        return 0;
}

PSIS_PER_LINK
SipLookupPerLink(
    IN PLINK_INDEX                  PerLinkIndex,
    IN PCSID                        CSid,
    IN PLARGE_INTEGER               LinkFileNtfsId,
    IN PLARGE_INTEGER               CSFileNtfsId,
    IN PDEVICE_OBJECT               DeviceObject,
    IN PETHREAD                     RequestingThread OPTIONAL,
    OUT PBOOLEAN                    FinalCopyInProgress)
{
    PSIS_PER_LINK       perLink;
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE           perLinkTree = DeviceExtension->PerLinkTree;
    PER_LINK_KEY        perLinkKey[1];

    perLinkKey->Index = *PerLinkIndex;

    KeAcquireSpinLock(DeviceExtension->PerLinkSpinLock, &OldIrql);

    SIS_MARK_POINT_ULONG(PerLinkIndex->HighPart);
    SIS_MARK_POINT_ULONG(PerLinkIndex->LowPart);

    perLink = SipLookupElementTree(perLinkTree, perLinkKey);

    if (perLink) {
        SIS_MARK_POINT_ULONG(perLink);
        SIS_MARK_POINT_ULONG(perLink->CsFile);

        perLink->RefCount++;

        if (perLink->COWingThread != RequestingThread || NULL == RequestingThread) {
            //
            // Handle setting "FinalCopyInProgress."  If there's a final copy outstanding
            // now, clear the final copy wakeup event, and if necessary set the bit
            // requesting a final copy wakeup, and set the boolean.
            // Otherwise, clear the boolean.
            //

            KeAcquireSpinLockAtDpcLevel(perLink->SpinLock);

            if (perLink->Flags & SIS_PER_LINK_FINAL_COPY) {

                *FinalCopyInProgress = TRUE;
                if (!(perLink->Flags & SIS_PER_LINK_FINAL_COPY_WAITERS)) {
                    perLink->Flags |= SIS_PER_LINK_FINAL_COPY_WAITERS;
                    KeClearEvent(perLink->Event);
                }
            } else {
                *FinalCopyInProgress = FALSE;
            }

            KeReleaseSpinLockFromDpcLevel(perLink->SpinLock);
        }

        KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);
        return(perLink);
    }

    perLink = ExAllocatePoolWithTag( NonPagedPool, sizeof(SIS_PER_LINK), 'LsiS');

    if (!perLink) {
        goto insufficient;
    }

#if     DBG
    InterlockedIncrement(&outstandingPerLinks);
#endif  // DBG

    RtlZeroMemory(perLink,sizeof(SIS_PER_LINK));
    KeInitializeSpinLock(perLink->SpinLock);

    perLink->CsFile = SipLookupCSFile(
                        CSid,
                        CSFileNtfsId,
                        DeviceObject);
    if (!perLink->CsFile) {
        KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

#if     DBG
        InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

        ExFreePool(perLink);
        return NULL;
    }

    SIS_MARK_POINT_ULONG(perLink);
    SIS_MARK_POINT_ULONG(perLink->CsFile);

    perLink->RefCount = 1;
    perLink->Index = *PerLinkIndex;
    perLink->LinkFileNtfsId = *LinkFileNtfsId;

    //
    // Now add it to the tree.
    //

#if DBG
    {
    PSIS_PER_LINK perLinkNew =
#endif

    SipInsertElementTree(perLinkTree, perLink, perLinkKey);

#if DBG
    ASSERT(perLinkNew == perLink);
    }
#endif

    KeInitializeEvent(perLink->Event,NotificationEvent,FALSE);
    KeInitializeEvent(perLink->DeleteEvent,NotificationEvent,FALSE);

    KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

    //
    // Since we're the first reference to this per link, there can't
    // be a final copy in progress.  Indicate so.
    //
    *FinalCopyInProgress = FALSE;

    return perLink;

insufficient:
    KeReleaseSpinLock(DeviceExtension->PerLinkSpinLock, OldIrql);

    if (!perLink) return NULL;

#if     DBG
    InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

    ExFreePool(perLink);

    return NULL;
}

VOID
SipReferencePerLink(
    IN PSIS_PER_LINK                    perLink)
{
    PDEVICE_EXTENSION           deviceExtension = perLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                       OldIrql;

    KeAcquireSpinLock(deviceExtension->PerLinkSpinLock, &OldIrql);

    //
    // The caller must already have a reference.  Assert that.
    //
    ASSERT(perLink->RefCount > 0);

    perLink->RefCount++;
    KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);
}

VOID
SipDereferencePerLink(
    IN PSIS_PER_LINK                    PerLink)
{
    PDEVICE_EXTENSION           deviceExtension = PerLink->CsFile->DeviceObject->DeviceExtension;
    KIRQL                       OldIrql;

    KeAcquireSpinLock(deviceExtension->PerLinkSpinLock, &OldIrql);
    ASSERT(OldIrql < DISPATCH_LEVEL);

    ASSERT(PerLink->RefCount != 0);

    PerLink->RefCount--;

    if (PerLink->RefCount == 0) {
        PSIS_TREE perLinkTree = deviceExtension->PerLinkTree;

        //
        // Pull the perlink out of the tree.
        //

#if DBG     // Make sure it's in the tree before we remove it.
        {
        PER_LINK_KEY perLinkKey[1];
        perLinkKey->Index = PerLink->Index;

        ASSERT(PerLink == SipLookupElementTree(perLinkTree, perLinkKey));
        }
#endif
        SipDeleteElementTree(perLinkTree, PerLink);

        KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);

        //
        // Release the reference that this link held to the CsFile.
        //

        SipDereferenceCSFile(PerLink->CsFile);

        //
        // And return the memory for the per link.
        //

#if     DBG
        InterlockedDecrement(&outstandingPerLinks);
#endif  // DBG

        SIS_MARK_POINT_ULONG(PerLink);

        ExFreePool(PerLink);    // Probably should cache a few of these
    } else {
        KeReleaseSpinLock(deviceExtension->PerLinkSpinLock, OldIrql);
    }
}

PSIS_SCB
SipEnumerateScbList(
    PDEVICE_EXTENSION deviceExtension,
    PSIS_SCB curScb)
{
    KIRQL           OldIrql;
    BOOLEAN         deref;
    PLIST_ENTRY     nextListEntry, listHead;
    PSIS_SCB        scb;

    listHead = &deviceExtension->ScbList;

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql);

    if (NULL == curScb) {               // start at the head
        nextListEntry = listHead->Flink;
    } else {
        nextListEntry = curScb->ScbList.Flink;
    }

    if (nextListEntry == listHead) {    // stop at the tail
        scb = NULL;
    } else {
        scb = CONTAINING_RECORD(nextListEntry, SIS_SCB, ScbList);
    }

    //
    // We've got the next scb on the list, now we need to add a reference
    // to scb, and remove a reference from curScb.
    //
    if (scb) {
        ASSERT(scb->RefCount > 0);

        scb->RefCount++;

#if     DBG
        ++scb->referencesByType[RefsEnumeration];
        SipVerifyTypedScbRefcounts(scb);

        InterlockedIncrement(&totalScbReferences);
        InterlockedIncrement(&totalScbReferencesByType[RefsEnumeration]);
#endif
    }

    deref = FALSE;

    if (curScb) {
        ASSERT(curScb->RefCount > 0);

        if (curScb->RefCount > 1) {
            curScb->RefCount--;

#if     DBG
            --curScb->referencesByType[RefsEnumeration];
            SipVerifyTypedScbRefcounts(curScb);

            InterlockedDecrement(&totalScbReferences);
            InterlockedDecrement(&totalScbReferencesByType[RefsEnumeration]);
#endif

        } else {
            deref = TRUE;
        }
    }

    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql);

    if (deref) {

        //
        // Take the long path.
        //
        SipDereferenceScb(curScb, RefsEnumeration);
    }

    return scb;
}

VOID
SipUpdateLinkIndex(
    PSIS_SCB scb,
    PLINK_INDEX LinkIndex)
{
    PDEVICE_EXTENSION           deviceExtension = scb->PerLink->CsFile->DeviceObject->DeviceExtension;
    PSIS_PER_LINK               perLink = scb->PerLink;
    PSIS_TREE                   perLinkTree = deviceExtension->PerLinkTree;
    PSIS_TREE                   scbTree = deviceExtension->ScbTree;
    KIRQL                       OldIrql1;
    PER_LINK_KEY                perLinkKey[1];
    SCB_KEY                     scbKey[1];

    SIS_MARK_POINT_ULONG(scb);

    KeAcquireSpinLock(deviceExtension->ScbSpinLock, &OldIrql1);
    KeAcquireSpinLockAtDpcLevel(deviceExtension->PerLinkSpinLock);

    //
    // Pull the SCB out of the tree.
    //
#if DBG     // Make sure it's in the tree before we remove it.
    {
    SCB_KEY scbKey[1];
    scbKey->Index = perLink->Index;

    ASSERT(scb == SipLookupElementTree(scbTree, scbKey));
    }
#endif
    SipDeleteElementTree(scbTree, scb);

    //
    // Pull the perlink out of the tree.
    //
#if DBG     // Make sure it's in the tree before we remove it.
    {
    perLinkKey->Index = perLink->Index;

    ASSERT(perLink == SipLookupElementTree(perLinkTree, perLinkKey));
    }
#endif

    SipDeleteElementTree(perLinkTree, perLink);

    //
    // Set the new index.
    //
    perLink->Index = *LinkIndex;

    //
    // Now add the perLink back into the tree.
    //
    perLinkKey->Index = *LinkIndex;

#if DBG
    {
    PSIS_PER_LINK perLinkNew =
#endif

    SipInsertElementTree(perLinkTree, perLink, perLinkKey);

#if DBG
    ASSERT(perLinkNew == perLink);
    }
#endif

    //
    // And add the scb back into its tree.
    //
    scbKey->Index = perLink->Index;

#if DBG
    {
    PSIS_SCB scbNew =
#endif

    SipInsertElementTree(scbTree, scb, scbKey);

#if DBG
    ASSERT(scbNew == scb);
    }
#endif

    KeReleaseSpinLockFromDpcLevel(deviceExtension->PerLinkSpinLock);
    KeReleaseSpinLock(deviceExtension->ScbSpinLock, OldIrql1);

    return;
}

LONG
SipPerLinkTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PPER_LINK_KEY perLinkKey = (PPER_LINK_KEY) Key;
    PSIS_PER_LINK perLink = Node;
    LONGLONG r;

    r = perLinkKey->Index.QuadPart - perLink->Index.QuadPart;

    if (r > 0)
        return 1;
    else if (r < 0)
        return -1;
    else
        return 0;
}


PSIS_CS_FILE
SipLookupCSFile(
    IN PCSID                            CSid,
    IN PLARGE_INTEGER                   CSFileNtfsId        OPTIONAL,
    IN PDEVICE_OBJECT                   DeviceObject)
{
    PSIS_CS_FILE        csFile;
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PSIS_TREE           csFileTree = DeviceExtension->CSFileTree;
    CS_FILE_KEY         csFileKey[1];
    ULONG               i;

    csFileKey->CSid = *CSid;

    KeAcquireSpinLock(DeviceExtension->CSFileSpinLock, &OldIrql);

    csFile = SipLookupElementTree(csFileTree, csFileKey);

    if (csFile) {
        csFile->RefCount++;
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);

        if (NULL != CSFileNtfsId) {
            KeAcquireSpinLock(csFile->SpinLock, &OldIrql);
            if (csFile->Flags & CSFILE_NTFSID_SET) {
                if (csFile->CSFileNtfsId.QuadPart != CSFileNtfsId->QuadPart) {
                    //
                    // It's only a hint, so it's OK if it's wrong.  If one of them
                    // is zero, take the other one.  Otherwise, just keep the older one
                    // because it's more likely to have come from the real file.
                    //
#if     DBG
                    if (0 != CSFileNtfsId->QuadPart) {
                        DbgPrint("SIS: SipLookupCSFile: non matching CSFileNtfsId 0x%x.0x%x != 0x%x.0x%x\n",
                            csFile->CSFileNtfsId.HighPart,csFile->CSFileNtfsId.LowPart,
                            CSFileNtfsId->HighPart,CSFileNtfsId->LowPart);
                    }
#endif  // DBG
                    if (0 == csFile->CSFileNtfsId.QuadPart) {
                        csFile->CSFileNtfsId = *CSFileNtfsId;
                    }
                }
            } else {
                csFile->CSFileNtfsId = *CSFileNtfsId;
            }
            KeReleaseSpinLock(csFile->SpinLock, OldIrql);
        }

        return(csFile);
    }

    csFile = ExAllocatePoolWithTag( NonPagedPool, sizeof(SIS_CS_FILE), 'CsiS');

    if (!csFile) {
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
        return NULL;
    }

#if     DBG
    InterlockedIncrement(&outstandingCSFiles);
#endif  // DBG

    RtlZeroMemory(csFile,sizeof(SIS_CS_FILE));
    csFile->RefCount = 1;
    csFile->UnderlyingFileObject = NULL;
    csFile->CSid = *CSid;
    csFile->DeviceObject = DeviceObject;
    for (i = 0; i < SIS_CS_BACKPOINTER_CACHE_SIZE; i++) {
        csFile->BackpointerCache[i].LinkFileIndex.QuadPart = -1;
    }
    KeInitializeMutant(csFile->UFOMutant,FALSE);
    ExInitializeResourceLite(csFile->BackpointerResource);

    if (NULL != CSFileNtfsId) {
        csFile->CSFileNtfsId = *CSFileNtfsId;
        csFile->Flags |= CSFILE_NTFSID_SET;
    }

    // Now add it to the tree.

#if DBG
    {
    PSIS_CS_FILE csFileNew =
#endif

    SipInsertElementTree(csFileTree, csFile, csFileKey);

#if DBG
    ASSERT(csFileNew == csFile);
    }
#endif

    KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
    return csFile;
}

VOID
SipReferenceCSFile(
    IN PSIS_CS_FILE                     CSFile)
{
    PDEVICE_EXTENSION               deviceExtension = CSFile->DeviceObject->DeviceExtension;
    KIRQL                           OldIrql;

    KeAcquireSpinLock(deviceExtension->CSFileSpinLock, &OldIrql);

    //
    // The caller must already have a reference in order to add one.  Assert so.
    //
    ASSERT(CSFile->RefCount > 0);
    CSFile->RefCount++;

    KeReleaseSpinLock(deviceExtension->CSFileSpinLock, OldIrql);
}

VOID
SipDereferenceCSFile(
    IN PSIS_CS_FILE                     CSFile)
{
    PDEVICE_EXTENSION   DeviceExtension = CSFile->DeviceObject->DeviceExtension;
    KIRQL               OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Grab the CSFileHandleResource shared.  We need to do this to prevent a race between when
    // the backpointer stream handle gets closed and someone else opening the file (and hence
    // the backpointer stream).  That race results in a sharing violation for the opener.
    // Because we're acquiring a resource in a user thread, we must block APCs.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(DeviceExtension->CSFileHandleResource,TRUE);

    KeAcquireSpinLock(DeviceExtension->CSFileSpinLock, &OldIrql);

    ASSERT(CSFile->RefCount > 0);
    CSFile->RefCount--;

    if (CSFile->RefCount == 0) {
        PSIS_TREE csFileTree = DeviceExtension->CSFileTree;
        //
        // Pull the CSFile out of the tree.
        //
#if DBG     // Make sure it's in the tree before we remove it.
        {
        CS_FILE_KEY csFileKey[1];
        csFileKey->CSid = CSFile->CSid;

        ASSERT(CSFile == SipLookupElementTree(csFileTree, csFileKey));
       }
#endif
        SipDeleteElementTree(csFileTree, CSFile);

        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);

        // Close the underlying file object.
        if (CSFile->UnderlyingFileObject != NULL) {
            ObDereferenceObject(CSFile->UnderlyingFileObject);
#if     DBG
            CSFile->UnderlyingFileObject = NULL;
#endif  // DBG
        }

        if (NULL != CSFile->BackpointerStreamFileObject) {
            ObDereferenceObject(CSFile->BackpointerStreamFileObject);
#if     DBG
            CSFile->BackpointerStreamFileObject = NULL;
#endif  // DBG
        }

        //
        // Now close the underlying file and backpointer stream handles.
        //
        if (NULL != CSFile->UnderlyingFileHandle) {

            SipCloseHandles(
                    CSFile->UnderlyingFileHandle,
                    CSFile->BackpointerStreamHandle,
                    DeviceExtension->CSFileHandleResource);

        } else {
            ASSERT(NULL == CSFile->BackpointerStreamHandle);

            ExReleaseResourceLite(DeviceExtension->CSFileHandleResource);
        }
        //
        // We've either handed off responsibility for the CSFileHandleResource to a system thread,
        // or we have released it, so we can drop our disabling of APCs.
        //
        KeLeaveCriticalRegion();

        ExDeleteResourceLite(CSFile->BackpointerResource);

#if     DBG
        InterlockedDecrement(&outstandingCSFiles);
#endif  // DBG

        SIS_MARK_POINT_ULONG(CSFile);

        ExFreePool(CSFile); // Probably should cache a few of these
    } else {
        KeReleaseSpinLock(DeviceExtension->CSFileSpinLock, OldIrql);
        ExReleaseResourceLite(DeviceExtension->CSFileHandleResource);
        KeLeaveCriticalRegion();
    }
}

//
// This function relies on the fact that a GUID is the same size as two longlongs.  There
// is an assert to that effect in DriverEntry.
//
LONG
SipCSFileTreeCompare (
    IN PVOID                            Key,
    IN PVOID                            Node)
{
    PCS_FILE_KEY csFileKey = (PCS_FILE_KEY) Key;
    PSIS_CS_FILE csFile = (PSIS_CS_FILE)Node;

    PLONGLONG keyValue1 = (PLONGLONG)&csFileKey->CSid;
    PLONGLONG keyValue2 = keyValue1 + 1;
    PLONGLONG nodeValue1 = (PLONGLONG)&csFile->CSid;
    PLONGLONG nodeValue2 = nodeValue1 + 1;

    if (*keyValue1 < *nodeValue1) {
        return -1;
    } else if (*keyValue1 > *nodeValue1) {
        return 1;
    } else {
        if (*keyValue2 < *nodeValue2) {
            return -1;
        } else if (*keyValue2 > *nodeValue2) {
            return 1;
        } else {
            ASSERT(IsEqualGUID(&csFileKey->CSid, &csFile->CSid));
            return 0;
        }
    }
}

NTSTATUS
SipCreateEvent(
    IN EVENT_TYPE                       eventType,
    OUT PHANDLE                         eventHandle,
    OUT PKEVENT                         *event)
{

    NTSTATUS        status;

    status = ZwCreateEvent(
                eventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                eventType,
                FALSE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("SipCreateEvent: Unable to allocate event, 0x%x\n",status);
        *eventHandle = NULL;
        *event = NULL;
        return status;
    }

    status = ObReferenceObjectByHandle(
                *eventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                KernelMode,
                event,
                NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("SipCreateEvent: Unable to reference event, 0x%x\n",status);
        ZwClose(*eventHandle);

        *eventHandle = NULL;
        *event = NULL;
    }

    return status;
}

VOID
SipAddRangeToFaultedList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    )
/*++

Routine Description:

    Adds a range to the faulted list for a given stream.  If the range
    (or part of it) is already written, we leave it that way.  It's also
    OK for some or all of the range to already be faulted.

    The caller must hold the scb, and we'll return without
    dropping it.

Arguments:
    deviceExtension - the D.E. for the volume on which this file lives

    scb - Pointer to the scb for the file

    offset - pointer to the offset of the beginning of the read range

    Length - Length of the read range

Return Value:

    VOID
--*/
{
    BOOLEAN         inMappedRange;
    LONGLONG        mappedTo;
    LONGLONG        mappedSectorCount;
    LONGLONG        currentOffset = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    //
    // Loop looking up filled in ranges and setting them appropriately.
    //

    while (lengthInSectors != 0) {
        inMappedRange = FsRtlLookupLargeMcbEntry(
                            scb->Ranges,
                            currentOffset,
                            &mappedTo,
                            &mappedSectorCount,
                            NULL,               // LargeStartingLbn
                            NULL,               // LargeCountFromStartingLbn
                            NULL);              // Index

        if (!inMappedRange) {
            //
            // Not only isn't there a mapping for this range, but it's beyond
            // the largest thing mapped in the MCB, so we can just do the whole
            // mapping at once.  Set the variables appropriately and fall
            // through.
            mappedTo = 0;
            mappedSectorCount = lengthInSectors;
        } else {

            ASSERT(mappedSectorCount > 0);

            //
            // If the mapped (or unmapped, as the case may be) range extends beyond
            // the just faulted region, reduce our idea of its size.
            //
            if (mappedSectorCount > lengthInSectors) {
                mappedSectorCount = lengthInSectors;
            }
        }

        //
        // Check to see whether this is mapped to x + FAULTED_OFFSET (in which case it's
        // already faulted) or mapped to x + WRITTEN_OFFSET (in which case it's written and
        // should be left alone).  Otherwise, fill it in as faulted.
        //

        if ((mappedTo != currentOffset + FAULTED_OFFSET)
            && (mappedTo != currentOffset + WRITTEN_OFFSET)) {
            BOOLEAN worked =
                    FsRtlAddLargeMcbEntry(
                        scb->Ranges,
                        currentOffset,
                        currentOffset + FAULTED_OFFSET,
                        mappedSectorCount);

            //
            // FsRtlAddLargeMcbEntry is only supposed to fail if you're adding to a range
            // that's already in the MCB, which we should never be doing.  Assert that.
            //
            ASSERT(worked);
        }

        ASSERT(mappedSectorCount <= lengthInSectors);
        lengthInSectors -= mappedSectorCount;
        currentOffset += mappedSectorCount;
    }
}

NTSTATUS
SipAddRangeToWrittenList(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length
    )
/*++

Routine Description:

    Adds a range to the written list for a given stream.  If the range
    (or part of it) is already faulted, we change it to written.  It's also
    OK for some or all of the range to already be written.

    The caller must hold the scb, and we'll return without
    dropping it.

Arguments:

    scb - Pointer to the scb for the file

    offset - pointer to the offset of the beginning of the write range

    Length - Length of the write range

Return Value:

    status of the operation
--*/
{
    BOOLEAN         worked;
    LONGLONG        offsetInSectors = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    if (0 == lengthInSectors) {
        //
        // Sometimes FsRtl doesn't like being called with a zero length.  We know it's
        // a no-op, so just immediately return success.
        //

        SIS_MARK_POINT();

        return STATUS_SUCCESS;
    }

    //
    // First, blow away any mappings that might already exist for the
    // range we're marking as written.  We need to use a try-except
    // because FsRtlRemoveLargeMcbEntry can raise.
    //

    try {
        FsRtlRemoveLargeMcbEntry(
                scb->Ranges,
                offsetInSectors,
                lengthInSectors);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Now, add the region as written.
    //
    worked = FsRtlAddLargeMcbEntry(
                scb->Ranges,
                offsetInSectors,
                offsetInSectors + WRITTEN_OFFSET,
                lengthInSectors);
    //
    // This is only supposed to fail if you're adding to a range that's
    // already mapped, which we shouldn't be doing because we just
    // unmapped it.  Assert so.
    //
    ASSERT(worked);

    return STATUS_SUCCESS;
}

SIS_RANGE_DIRTY_STATE
SipGetRangeDirty(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN PLARGE_INTEGER                   offset,
    IN LONGLONG                         length,
    IN BOOLEAN                          faultedIsDirty
    )
/*++

Routine Description:

    This routine may be called while synchronized for cached write, to
    test for a possible Eof update, and return with a status if Eof is
    being updated and with the previous FileSize to restore on error.
    All updates to Eof are serialized by waiting in this routine.  If
    this routine returns TRUE, then NtfsFinishIoAtEof must be called.

    This routine must be called while synchronized with the FsRtl header.

    This code is stolen from NTFS, and modified to deal only with FileSize
    rather than  ValidDataLength.

Arguments:

    deviceExtension - the D.E. for the volume this file lives on

    scb - Pointer to the scb for the file

    offset - A pointer to the offset within the file of the beginning of the range

    length - the length of the range

    faultedIsDirty - Should faulted (as opposed to written) regions be
        treated as dirty or clean

Return Value:

    Clean, Dirty or Mixed.
--*/
{
    BOOLEAN         inMappedRange;
    LONGLONG        currentOffsetInSectors = offset->QuadPart / deviceExtension->FilesystemVolumeSectorSize;
    BOOLEAN         seenDirty = FALSE;
    BOOLEAN         seenClean = FALSE;
    LONGLONG        lengthInSectors;

    SipAssertScbHeld(scb);

    //
    // Handle the case where we're being asked about parts beyond the backed region.
    // Bytes from the end of the mapped range to the end of the backed region
    // are untouched.  Bytes beyond the end of the backed region are dirty.
    //
    if (offset->QuadPart >= scb->SizeBackedByUnderlyingFile) {
        //
        // The whole region's beyond the backed section. It's all dirty.
        //
        return Dirty;
    } else if (offset->QuadPart + length > scb->SizeBackedByUnderlyingFile) {
        //
        // Some of the region's betond the backed section.  We've seen dirty,
        // plus we need to truncate the length.
        //
        seenDirty = TRUE;
        length = scb->SizeBackedByUnderlyingFile - offset->QuadPart;
    }

    lengthInSectors = (length + deviceExtension->FilesystemVolumeSectorSize - 1) /
                        deviceExtension->FilesystemVolumeSectorSize;

    //
    // Loop though the range specified getting the mappings from the MCB.
    //
    while (lengthInSectors > 0) {
        LONGLONG        mappedTo;
        LONGLONG        sectorCount;

        inMappedRange = FsRtlLookupLargeMcbEntry(
                            scb->Ranges,
                            currentOffsetInSectors,
                            &mappedTo,
                            &sectorCount,
                            NULL,           // starting LBN
                            NULL,           // count from starting LBN
                            NULL);          // index

        if (!inMappedRange) {
            //
            // We're beyond the end of the range.  Fix stuff up so it looks normal.
            //
            sectorCount = lengthInSectors;
            mappedTo = 0;

        } else {
            ASSERT(sectorCount > 0);
            //
            // If the mapped (or unmapped, as the case may be) range extends beyond
            // the just faulted region, reduce our idea of its size.
            //
            if (sectorCount > lengthInSectors) {
                sectorCount = lengthInSectors;
            }
        }

        //
        // Decide whether this range is clean or dirty.  Written is always dirty,
        // not mapped is always clean, and faulted is dirty iff faultedIsDirty.
        if ((mappedTo == currentOffsetInSectors + WRITTEN_OFFSET)
            || (faultedIsDirty && mappedTo == (currentOffsetInSectors + FAULTED_OFFSET))) {
            //
            // It's dirty.
            //
            if (seenClean) {
                //
                // We've seen clean, and now we've seen dirty, so it's mixed and we can
                // quit looking.
                //
                return Mixed;
            }
            seenDirty = TRUE;
        } else {
            //
            // It's clean.
            //
            if (seenDirty) {
                //
                // We've seen dirty, and now we've seen clean, so it's mixed and we can
                // quit looking.
                //
                return Mixed;
            }
            seenClean = TRUE;
        }

        currentOffsetInSectors += sectorCount;
        lengthInSectors -= sectorCount;
    }

    //
    // Assert that we haven't seen both clean and dirty regions.  If we had,
    // then we should have already returned.
    //
    ASSERT(!seenClean || !seenDirty);

    return seenDirty ? Dirty : Clean;
}

BOOLEAN
SipGetRangeEntry(
    IN PDEVICE_EXTENSION                deviceExtension,
    IN PSIS_SCB                         scb,
    IN LONGLONG                         startingOffset,
    OUT PLONGLONG                       length,
    OUT PSIS_RANGE_STATE                state)
{
    BOOLEAN         inRange;
    LONGLONG        mappedTo;
    LONGLONG        sectorCount;
    LONGLONG        startingSectorOffset = startingOffset / deviceExtension->FilesystemVolumeSectorSize;

    SipAssertScbHeld(scb);

    if (!(scb->Flags & SIS_SCB_MCB_INITIALIZED)) {
        return FALSE;
    }

    ASSERT(startingOffset < scb->SizeBackedByUnderlyingFile);

    inRange = FsRtlLookupLargeMcbEntry(
                    scb->Ranges,
                    startingSectorOffset,
                    &mappedTo,
                    &sectorCount,
                    NULL,                       // LargeStartingLbn
                    NULL,                       // LargeCountFromStartingLbn
                    NULL);                      // index

    if (!inRange) {
        return FALSE;
    }

    *length = sectorCount * deviceExtension->FilesystemVolumeSectorSize;

    if (mappedTo == -1) {
        *state = Untouched;
    } else if (mappedTo == startingSectorOffset + FAULTED_OFFSET) {
        *state = Faulted;
    } else {
        ASSERT(mappedTo == startingSectorOffset + WRITTEN_OFFSET);
        *state = Written;
    }

    return TRUE;
}

#if     DBG

BOOLEAN
SipIsFileObjectSISInternal(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL,
    IN PCHAR                            fileName,
    IN ULONG                            fileLine
    )

#else   // DBG

BOOLEAN
SipIsFileObjectSIS(
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject,
    IN SIS_FIND_TYPE                    findType,
    OUT PSIS_PER_FILE_OBJECT            *perFO OPTIONAL,
    OUT PSIS_SCB                        *scbReturn OPTIONAL
    )

#endif  // DBG
/*++

Routine Description:

    Given a file object, find out if it is an SIS file object.
    If it is, then return the PER_FO pointer for the object.

    We use the FsRtl FilterContext support for this operation.

Arguments:

    fileObject - The file object that we're considering.

    DeviceObject - the SIS DeviceObject for this volume.

    findType - look for active only, or active & defunct scb.

    perFO - returns a pointer to the perFO for this file object
            if it is a SIS file object.

Return Value:

    FALSE - This is not an SIS file object.
    TRUE - This is an SIS file object, and perFO
            has been set accordingly.

--*/
{
    PSIS_FILTER_CONTEXT     fc;
    PSIS_SCB                scb;
    PSIS_PER_FILE_OBJECT    localPerFO;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    //PSIS_PER_LINK           perLink;
    BOOLEAN                 rc;
    BOOLEAN                 newPerFO;

	//
	// It's possible to get some calls with a NULL file object.  Clearly, no file object
	// at all isn't a SIS file object, so say so before we dereference the file object pointer.
	//
	if (NULL == fileObject) {
		SIS_MARK_POINT();
		rc = FALSE;
		goto Done2;
	}

#if     DBG
    if (BJBAssertNow != 0) {
        BJBAssertNow = 0;
        ASSERT(!"You asked for this");
    }

	if ((NULL != BJBMagicFsContext) && (fileObject->FsContext == BJBMagicFsContext)) {
		ASSERT(!"Hit on BJBMagicFsContext");
	}
#endif	// DBG

#if     TIMING
    if (BJBDumpTimingNow) {
        SipDumpTimingInfo();
        BJBDumpTimingNow = 0;
    }
    if (BJBClearTimingNow) {
        SipClearTimingInfo();
        BJBClearTimingNow = 0;
    }
#endif  // TIMING

#if     COUNTING_MALLOC
    if (BJBDumpCountingMallocNow) {
        SipDumpCountingMallocStats();
        //      BJBDumpCountingMallocNow  is cleared in SipDumpCountingMallocStats
    }
#endif  // COUNTING_MALLOC

    //
    // We should have already verified that this isn't our primary device object.
    //
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject));

    ASSERT(fileObject->Type == IO_TYPE_FILE);
    ASSERT(fileObject->Size == sizeof(FILE_OBJECT));

    //
    // The filter context won't go away while we hold the resource, because as long
    // as the file exists the NTFS SCB will exists, and NTFS won't call the
    // "remove filter context" callback.
    //

    //
    // Call FsRtl to see if this file object has a context registered for it.
    // We always use our DeviceObject as the OwnerId.
    //
    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                    FsRtlGetPerStreamContextPointer(fileObject),
                                    DeviceObject,
                                    NULL);

    //
    // If FsRtl didn't find what we want, then this isn't one of our file objects.
    //
    if (NULL == fc) {
        rc = FALSE;
        goto Done2;
    }

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fileObject);
//  SIS_MARK_POINT_ULONG(scb);

    //
    // Assert that what we got back is the right kind of thing.
    //
    ASSERT(fc->ContextCtrl.OwnerId == DeviceObject && fc->ContextCtrl.InstanceId == NULL);

	SipAcquireFc(fc);
    scb = fc->primaryScb;

    //
    // If we're looking for an active scb only and the primary scb is defunct,
    // we're done.
    //
    if ((FindActive == findType) && (scb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE)) {

#if     DBG
        {
            //
            // Keep track of the last scb that got marked coming through here, and only
            // do a mark point if this one is different.  This keeps the log polution to
            // a minimum when the stress test beats on a file that's got a defunct scb.
            // We don't bother with proper synchronization around this variable, because
            // we don't really care all that much if this works perfectly.
            //
            static PSIS_SCB lastMarkedScb = NULL;

            if (scb != lastMarkedScb) {
                SIS_MARK_POINT_ULONG(scb);
                lastMarkedScb = scb;
            }
        }
#endif  // DBG

        rc = FALSE;
        goto Done;

    }

    //
    //  Locate the existing PerFO (if we have one) or allocate a new one
    //

    localPerFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject, &newPerFO);

    if (!localPerFO) {
        ASSERT("SIS: SipIsFileObjectSIS: unable to allocate new perFO.\n");

        SIS_MARK_POINT();
        rc = FALSE;
        goto Done;
    }

#if DBG
    //
    //  If this was newly allocated, handle it
    //

    if (newPerFO) {

        if (BJBDebug & 0x4) {
            DbgPrint("SIS: SipIsFileObjectSIS: Allocating new perFO for fileObject %p, scb %p\n",fileObject,scb);
            if (!(fileObject->Flags & FO_STREAM_FILE)) {
                DbgPrint("SIS: SipIsFileObjectSIS: the allocated file object wasn't a stream file (%s %u)\n",fileName,fileLine);
            }
        }

        localPerFO->Flags |= SIS_PER_FO_NO_CREATE;
        localPerFO->AllocatingFilename = fileName;
        localPerFO->AllocatingLineNumber = fileLine;
    }
#endif  // DBG


//	//
//	// Cruise down the perFO list and see if there is a perFO that
//	// corresponds to this file object.
//	//
//
//    if (NULL != fc->perFOs) {
//
//        for (   localPerFO = fc->perFOs;
//                localPerFO->fileObject != fileObject && localPerFO->Next != fc->perFOs;
//                localPerFO = localPerFO->Next) {
//
//            // Intentionally empty loop body.
//        }
//    }
//
//    if ((NULL == fc->perFOs) || (localPerFO->fileObject != fileObject)) {
//        //
//        // We don't have a perFO for this file object associated with this
//        // SCB.  We're most likely dealing with a stream file object that
//        // got created underneath us.  Allocate one and add it into the list.
//        //
////        perLink = scb->PerLink;
//
//#if     DBG
//        if (BJBDebug & 0x4) {
//            DbgPrint("SIS: SipIsFileObjectSIS: Allocating new perFO for fileObject %p, scb %p\n",fileObject,scb);
//            if (!(fileObject->Flags & FO_STREAM_FILE)) {
//                DbgPrint("SIS: SipIsFileObjectSIS: the allocated file object wasn't a stream file (%s %u)\n",fileName,fileLine);
//            }
//        }
//
//        SIS_MARK_POINT_ULONG(fileName);
//        SIS_MARK_POINT_ULONG(fileLine);
//#endif  // DBG
//
//        localPerFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject);
//
//        SIS_MARK_POINT_ULONG(scb);
//        SIS_MARK_POINT_ULONG(fileObject);
//
//        if (!localPerFO) {
//            ASSERT("SIS: SipIsFileObjectSIS: unable to allocate new perFO.\n");
//
//            SIS_MARK_POINT();
//            rc = FALSE;
//            goto Done;
//        }
//
//#if     DBG
//        localPerFO->Flags |= SIS_PER_FO_NO_CREATE;
//        localPerFO->AllocatingFilename = fileName;
//        localPerFO->AllocatingLineNumber = fileLine;
//#endif  // DBG
//    }

    rc = TRUE;

Done:
    SipReleaseFc(fc);
Done2:

    //
    // Return the PerFO if the user wanted it.
    //
    if (ARGUMENT_PRESENT(perFO)) {
        *perFO = rc ? localPerFO : NULL;
    }
    if (ARGUMENT_PRESENT(scbReturn)) {
        *scbReturn = rc ? scb : NULL;
    }
//  SIS_MARK_POINT_ULONG(localPerFO);

    return rc;
}

typedef struct _SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK {
    WORK_QUEUE_ITEM         workItem[1];
    PSIS_FILTER_CONTEXT     fc;
} SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK, *PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK;

VOID
SiPostedFilterContextFreed(
    IN PVOID                            context)
/*++

Routine Description:

    NTFS informed us that a filter context was freed, and we had to post
    processing the request in order to avoid a deadlock.  Drop the
    reference to the SCB held by the filter context, and then free the
    filter context and the posted request itself.

Arguments:

    context - the posted request to dereference the filter context.

Return Value:

    void

--*/
{
    PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK    request = context;

    SIS_MARK_POINT_ULONG(request->fc);

    SipDereferenceScb(request->fc->primaryScb, RefsFc);

    ExFreePool(request->fc);
    ExFreePool(request);

    return;
}

VOID
SiFilterContextFreedCallback (
    IN PVOID context
    )
/*++

Routine Description:

    This function is called when a file with a SIS filter context
    attached is about to be destroyed.

    For now, we don't do anything, but once this functionality is really
    enabled, we'll detach from the file here and only here.

Arguments:

    context - the filter context to be detached.

Return Value:

    void

--*/
{
    PSIS_FILTER_CONTEXT fc = context;
    PDEVICE_EXTENSION   deviceExtension;

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fc->primaryScb);

    //
    // This can't be freed if there's still a file object referring to it.
    //

    ASSERT(NULL != fc);
    ASSERT(0 == fc->perFOCount);
    ASSERT(NULL != fc->primaryScb);

    deviceExtension = fc->primaryScb->PerLink->CsFile->DeviceObject->DeviceExtension;

    ASSERT(fc->ContextCtrl.OwnerId == deviceExtension->DeviceObject);
    ASSERT(NULL == fc->ContextCtrl.InstanceId);

    //
    // We're in a callback from NTFS.  The rules of this callback are that we
    // can't block acquiring resources.  If this happens to be the last access
    // to the given CS file, we'll try to acquire the volume-wide CSFileHandleResource
    // shared inside SipDereferenceScb.  This could potentially block, which can lead
    // to a deadlock if NTFS is doing a volume-wide checkpoint.  To avoid this,
    // take the resource here, and take it Wait == FALSE.  If we can't get it,
    // then post this request.
    //

    //
    // Enter a critical region before (possibly) taking a resource in what might be a user thread.
    //
    KeEnterCriticalRegion();
    if (
#if DBG
        (BJBDebug & 0x04000000) ||
#endif  // DBG
        !ExAcquireResourceSharedLite(deviceExtension->CSFileHandleResource, FALSE)
       ) {

        PSI_POSTED_FILTER_CONTEXT_FREED_CALLBACK    request;

        SIS_MARK_POINT_ULONG(fc);

        request = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(SI_POSTED_FILTER_CONTEXT_FREED_CALLBACK),
                    ' siS');

        if (NULL == request) {
            SIS_MARK_POINT_ULONG(fc);
            //
            // This is pretty bad.  Dribble the request.
            // BUGBUGBUG : This must be fixed.
            //
        }
        else {
            request->fc = fc;
            ExInitializeWorkItem(request->workItem, SiPostedFilterContextFreed, request);
            ExQueueWorkItem(request->workItem, CriticalWorkQueue);
        }
    } else {
        SipDereferenceScb(fc->primaryScb, RefsFc);

        ExReleaseResourceLite(deviceExtension->CSFileHandleResource);

        ExFreePool(fc);
    }

    //
    // We're done with the resource, release our APC block.
    //

    KeLeaveCriticalRegion();
}


PSIS_PER_FILE_OBJECT
SipAllocatePerFO(
    IN PSIS_FILTER_CONTEXT      fc,
    IN PFILE_OBJECT             fileObject,
    IN PSIS_SCB                 scb,
    IN PDEVICE_OBJECT           DeviceObject,
    OUT PBOOLEAN                newPerFO OPTIONAL
    )
/*++

Routine Description:

    Allocate a per file-object structure, initialize it and associate
    it with a filter context and scb.  A filter context must already exist.

Arguments:

    fc - a pointer to the filter context associated with this file.

    fileObject - The file object that we're claiming.

    scb - a pointer to the SIS scb for this file.

    DeviceObject - the SIS DeviceObject for this volume

    newPerFO - boolean to say if this was a newly allocated structure (only
                set in DEBUG version)

Return Value:


    A pointer to the perFO for this file object if successful, else NULL.

--*/
{
    PSIS_PER_FILE_OBJECT perFO;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( newPerFO );

    SIS_MARK_POINT_ULONG(fc);
    SIS_MARK_POINT_ULONG(fileObject);

#if DBG
    if (ARGUMENT_PRESENT(newPerFO)) {

        *newPerFO = FALSE;
    }
#endif
                
	//
	//  See if we already have a perFO structure for this fileObject.  If so
    //  return it instead of allocating a new one.
	//

    if (NULL != fc->perFOs) {

        perFO = fc->perFOs;
        do {

            ASSERT(perFO->fc == fc);
            ASSERT(perFO->FsContext == fileObject->FsContext);

            if (perFO->fileObject == fileObject) {

                //
                //  We found one, return it
                //

#if DBG
                if (BJBDebug & 0x4) {
                    DbgPrint("SIS: SipAllocatePerFO: Found existing perFO\n");
                }
#endif
                SIS_MARK_POINT_ULONG(perFO);
                return perFO;
            }

            //
            //  Advance to the next link
            //

            perFO = perFO->Next;

        } while (perFO != fc->perFOs);
    }

//#if DBG
//
//    ASSERT(scb == fc->primaryScb);
//
//    //
//    // Cruise the list of perFOs for this filter context and assert that
//    // there's not already one there for this file object.  Furthermore,
//    // assert that all of the perFOs on the list point at the same FsContext.
//    //
//
//    if (fc->perFOs) {
//
//        PSIS_PER_FILE_OBJECT    otherPerFO;
//        PVOID                   FsContext = fileObject->FsContext;
//
//        otherPerFO = fc->perFOs;
//
//        do {
//
//            ASSERT(otherPerFO->fc == fc);
//            ASSERT(otherPerFO->fileObject != fileObject);
//            ASSERT(otherPerFO->FsContext == FsContext);
//
//            otherPerFO = otherPerFO->Next;
//
//        } while (otherPerFO != fc->perFOs);
//    }
//
//#endif  // DBG

    perFO = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_PER_FILE_OBJECT), 'FsiS');

    if (!perFO) {
#if     DBG
        DbgPrint("SIS: SipAllocatePerFO: unable to allocate perFO\n");
#endif  // DBG
        goto Error;
    }

#if DBG
    if (ARGUMENT_PRESENT(newPerFO)) {

        *newPerFO = TRUE;
    }
#endif

    SIS_MARK_POINT_ULONG(perFO);

    RtlZeroMemory(perFO, sizeof(SIS_PER_FILE_OBJECT));

    perFO->fc = fc;
    perFO->referenceScb = scb;
    perFO->fileObject = fileObject;
#if DBG
    perFO->FsContext = fileObject->FsContext;   // Just keep track of this for consistency checking
#endif  // DBG
    KeInitializeSpinLock(perFO->SpinLock);

    //
    // Insert this per-FO on the linked list in the filter context.
    //

    if (!fc->perFOs) {

        ASSERT(0 == fc->perFOCount);

        fc->perFOs = perFO;

        perFO->Prev = perFO;
        perFO->Next = perFO;

    } else {

        perFO->Prev = fc->perFOs->Prev;
        perFO->Next = fc->perFOs;

        perFO->Next->Prev = perFO;
        perFO->Prev->Next = perFO;

    }

#if DBG
    InterlockedIncrement(&outstandingPerFOs);
#endif  // DBG

    fc->perFOCount++;

    //
    // Grab a reference for this file object to this scb.
    //
    SipReferenceScb(scb, RefsPerFO);

//  SIS_MARK_POINT_ULONG(perFO);

Error:

    return perFO;
}


PSIS_PER_FILE_OBJECT
SipCreatePerFO(
    IN PFILE_OBJECT             fileObject,
    IN PSIS_SCB                 scb,
    IN PDEVICE_OBJECT           DeviceObject)
/*++

Routine Description:

    Create a per file-object structure, initialize it and associate
    it with an scb.  A filter context will also be created and
    registered if one does not already exist.  The caller must hold the
    scb, and it will still be held on return.

Arguments:

    fileObject - The file object that we're claiming.

    scb - a pointer to the SIS scb for this file.

    DeviceObject - the SIS DeviceObject for this volume

Return Value:


    A pointer to the perFO for this file object if successful, else NULL.

--*/
{
    PDEVICE_EXTENSION           deviceExtension = DeviceObject->DeviceExtension;
    PSIS_FILTER_CONTEXT         fc;
    PSIS_PER_FILE_OBJECT        perFO;
    NTSTATUS                    status;

    //
    // This scb must be the primary scb.  If a filter context already exists,
    // either this scb is already attached to it as the primary scb, or else
    // it will become the new primary scb.
    //

    SipAssertScbHeld(scb);

    //
    // Lookup the filter context.
    //

    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                            FsRtlGetPerStreamContextPointer(fileObject), 
                                            DeviceObject, 
                                            NULL);

    if (!fc) {

        //
        // A filter context doesn't already exist.  Create one.
        //

        fc = ExAllocatePoolWithTag(NonPagedPool, sizeof(SIS_FILTER_CONTEXT), 'FsiS');

        if (!fc) {
#if     DBG
            DbgPrint("SIS: SipCreatePerFO: unable to allocate filter context\n");
#endif  // DBG

            perFO = NULL;
            goto Error;

        }

        SIS_MARK_POINT_ULONG(fc);

        RtlZeroMemory(fc, sizeof(SIS_FILTER_CONTEXT));

        //
        // Fill in the fields in the FSRTL_FILTER_CONTEXT within the fc.
        //

        FsRtlInitPerStreamContext( &fc->ContextCtrl,
                                   DeviceObject,
                                   NULL,
                                   SiFilterContextFreedCallback );
        fc->primaryScb = scb;

        SipReferenceScb(scb, RefsFc);

        ExInitializeFastMutex(fc->FastMutex);

        //
        // And insert it as a filter context.
        //
        status = FsRtlInsertPerStreamContext(
                            FsRtlGetPerStreamContextPointer(fileObject), 
                            &fc->ContextCtrl);

        ASSERT(STATUS_SUCCESS == status);

        SipAcquireFc(fc);

    } else {
        SipAcquireFc(fc);

        SIS_MARK_POINT_ULONG(fc);

        if (fc->primaryScb != scb) {

            PSIS_SCB    defunctScb = fc->primaryScb;

            //
            // A filter context exists along with another scb.  It must be a
            // defunct scb.
            //

            ASSERT(defunctScb->PerLink->Flags & SIS_PER_LINK_BACKPOINTER_GONE);

            //
            // Switch the reference for the defunct scb from RefsFc to
            // RefsDefunct.  Add a reference from the fc to the new scb, and
            // from the new scb to the defunct one.
            //

            SipReferenceScb(defunctScb, RefsPredecessorScb);
            SipDereferenceScb(defunctScb, RefsFc);

            SipReferenceScb(scb, RefsFc);
            scb->PredecessorScb = defunctScb;

            fc->primaryScb = scb;
        }
    }

    //
    // Now add a perFO to the filter context.
    //

    perFO = SipAllocatePerFO(fc, fileObject, scb, DeviceObject, NULL);
    SipReleaseFc(fc);

Error:

    return perFO;
}

VOID
SipDeallocatePerFO(
    IN OUT PSIS_PER_FILE_OBJECT         perFO,
    IN PDEVICE_OBJECT                   DeviceObject)
{
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PSIS_FILTER_CONTEXT     fc;
    PFILE_OBJECT            fileObject = perFO->fileObject;

    SIS_MARK_POINT_ULONG(perFO);

    //
    // This perFO holds a reference to its scb, therefore we know its scb
    // pointer is valid.
    //
    ASSERT(perFO->referenceScb);

    //
    // The perFO also holds a reference to the filter context, and therefore
    // we know the filter context pointer is valid.
    //
    fc = perFO->fc;
    ASSERT(fc && fc->perFOCount > 0);

    SipAcquireFc(fc);
    ASSERT(*(ULONG volatile *)&fc->perFOCount > 0);

    //
    // Remove the perFO from the filter context's linked list.  If this is the last
    // perFO, then we just zero the fc's perFO pointer.
    //

    if (1 == fc->perFOCount) {
        ASSERT(fc->perFOs == perFO);
        fc->perFOs = NULL;
    } else {

        perFO->Prev->Next = perFO->Next;
        perFO->Next->Prev = perFO->Prev;

        if (perFO == fc->perFOs) {
            fc->perFOs = perFO->Next;
        }
    }

    ASSERT(perFO != fc->perFOs);

    //
    // Decrement the count of per-FOs for this filter context.
    //
    fc->perFOCount--;

    SipReleaseFc(fc);

    //
    // Assert that we don't have an outstanding opbreak for this file object.  (We guarantee
    // that this can't happen by taking a reference to the file object when we launch the
    // FSCTL_OPLOCK_BREAK_NOTIFY.)  Free the break event if one has been allocated.
    //

    ASSERT(!(perFO->Flags & (SIS_PER_FO_OPBREAK|SIS_PER_FO_OPBREAK_WAITERS)));

    if (NULL != perFO->BreakEvent) {

        ExFreePool(perFO->BreakEvent);
#if     DBG
        perFO->BreakEvent = NULL;
#endif  // DBG

    }

    //
    // Now we're safe to drop our reference to the SCB (and possibly have it be
    // deallocated, which in turn may cause other scb's that were previously part
    // of this filter context to be deallocated).
    //

    SipDereferenceScb(perFO->referenceScb, RefsPerFO);

    //
    // Free the memory for the perFO that we just deleted.
    //
    ExFreePool(perFO);

#if     DBG
    InterlockedDecrement(&outstandingPerFOs);
#endif  // DBG
}

NTSTATUS
SipInitializePrimaryScb(
    IN PSIS_SCB                         primaryScb,
    IN PSIS_SCB                         defunctScb,
    IN PFILE_OBJECT                     fileObject,
    IN PDEVICE_OBJECT                   DeviceObject)
/*++

Routine Description:

    Installs the primaryScb on the filter context scb chain identified via
    fileObject and adjusts reference counts appropriately.  This requires
	a RefsLookedUp reference type to the primary Scb, and consumes it (the
	primary scb is then referred to by the filter context for the fileObject,
	so the caller can rely on its still existing iff the fileObject continues
	to exist).

Arguments:

    primaryScb - pointer to the scb to become the primary scb.

    defunctScb - pointer to the current primary scb that will become defunct.

    fileObject - pointer to the file object that references defunctScb.

    DeviceObject - the device object holding the specified file object.

Return Value:

    The status of the request

--*/
{
    PSIS_FILTER_CONTEXT fc;
    NTSTATUS            status;

    //
    // We need to acquire only the primaryScb lock.  The only thing we will do
    // to defunctScb is adjust its reference count, and we know that the
    // filter context already holds a reference to it (unless a thread race
    // has already done this work--which we check below).
    //

    SipAcquireScb(primaryScb);

    //
    // Lookup the filter context.
    //

    fc = (PSIS_FILTER_CONTEXT) FsRtlLookupPerStreamContext(
                                        FsRtlGetPerStreamContextPointer(fileObject), 
                                        DeviceObject, 
                                        NULL);

    ASSERT(fc);

    if (!fc) {
        status = STATUS_INTERNAL_ERROR;
        goto Error;
    }

    SipAcquireFc(fc);

    if (NULL == primaryScb->PredecessorScb) {

        //
        // No other threads have beaten us to this.  Do the initialization.
        //

        ASSERT(defunctScb == fc->primaryScb);

        //
        // Switch the reference for the defunct scb from RefsFc to RefsDefunct.  Add a reference
        // from the fc to the new scb, and from the new scb to the defunct one.
        //

        SipReferenceScb(defunctScb, RefsPredecessorScb);
        SipDereferenceScb(defunctScb, RefsFc);

        SipTransferScbReferenceType(primaryScb, RefsLookedUp, RefsFc);
        primaryScb->PredecessorScb = defunctScb;

        fc->primaryScb = primaryScb;

    } else {
		SipDereferenceScb(primaryScb, RefsLookedUp);
	}

    ASSERT(defunctScb == primaryScb->PredecessorScb);

    SipReleaseFc(fc);

    status = STATUS_SUCCESS;

Error:
    SipReleaseScb(primaryScb);

    return status;
}

NTSTATUS
SipAcquireUFO(
    IN PSIS_CS_FILE                     CSFile
    )
{
    NTSTATUS status;

    //
    // Caller better be at APC_LEVEL or have APCs blocked or be in a system thread.
    //

    ASSERT((KeGetCurrentIrql() == APC_LEVEL) ||
        (PsIsSystemThread(PsGetCurrentThread())) ||
        KeAreApcsDisabled());

    status = KeWaitForSingleObject(
                    CSFile->UFOMutant,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

    ASSERT((status == STATUS_SUCCESS) || (status == STATUS_ABANDONED));
    if ((status != STATUS_SUCCESS) && (status != STATUS_ABANDONED)) {

        return status;
    }

    return STATUS_SUCCESS;
}

VOID
SipReleaseUFO(
    IN PSIS_CS_FILE                 CSFile)
{
    //
    // We use abandon rather than just plain wait, because we're not guaranteed to be
    // in the thread that acquired the mutant.
    //
    KeReleaseMutant(CSFile->UFOMutant, IO_NO_INCREMENT, TRUE, FALSE);
}

NTSTATUS
SipAcquireCollisionLock(
    PDEVICE_EXTENSION DeviceExtension)
{
    NTSTATUS status;

    status = KeWaitForSingleObject(
                    DeviceExtension->CollisionMutex,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

    ASSERT((status == STATUS_SUCCESS) || (status == STATUS_ABANDONED));
    if ((status != STATUS_SUCCESS) && (status != STATUS_ABANDONED)) {

        return status;
    }

    return STATUS_SUCCESS;
}

VOID
SipReleaseCollisionLock(
    PDEVICE_EXTENSION DeviceExtension)
{
    KeReleaseMutex(DeviceExtension->CollisionMutex, FALSE);
}

typedef struct _SI_DEREFERENCE_OBJECT_REQUEST {
    WORK_QUEUE_ITEM         workItem[1];
    PVOID                   object;
} SI_DEREFERENCE_OBJECT_REQUEST, *PSI_DEREFERENCE_OBJECT_REQUEST;

VOID
SiPostedDereferenceObject(
    IN PVOID                parameter)
{
    PSI_DEREFERENCE_OBJECT_REQUEST request = parameter;

    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    ObDereferenceObject(request->object);

    ExFreePool(request);
}

VOID
SipDereferenceObject(
    IN PVOID                object)
/*++

Routine Description:

    This is just like ObDereferenceObject except that it can be called at
    Irql <= DISPATCH_LEVEL.

Arguments:

    object - the object to dereference

Return Value:

    void

--*/
{
    KIRQL       Irql;

    Irql = KeGetCurrentIrql();
    ASSERT(Irql <= DISPATCH_LEVEL);

    if (Irql == PASSIVE_LEVEL) {
        //
        // We're already on passive level, just do it inline.
        //
        ObDereferenceObject(object);
    } else {
        //
        // The DDK doc says that you can't call ObDereferenceObject at APC_LEVEL, so we'll
        // be safe and post those along with the DISPATCH_LEVEL calls.
        //
        PSI_DEREFERENCE_OBJECT_REQUEST  request;

        SIS_MARK_POINT_ULONG(object);

        request = ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_DEREFERENCE_OBJECT_REQUEST), ' siS');
        if (NULL == request) {
            SIS_MARK_POINT();

#if     DBG
            DbgPrint("SIS: SipDereferenceObject: unable to allocate an SI_DEREFERENCE_OBJECT_REQUEST.  Dribbling object 0x0%x\n",object);
#endif  // DBG

            //
            // This is pretty bad.  Dribble the request.
            // BUGBUGBUG : This must be fixed.
            //
            return;
        }

        request->object = object;
        ExInitializeWorkItem(request->workItem, SiPostedDereferenceObject, request);
        ExQueueWorkItem(request->workItem, CriticalWorkQueue);
    }
}

BOOLEAN
SipAcquireBackpointerResource(
    IN PSIS_CS_FILE                     CSFile,
    IN BOOLEAN                          Exclusive,
    IN BOOLEAN                          Wait)
/*++

Routine Description:

    Acquire the backpointer resource for a common store file.  If not in a system thread,
    enters a critical region in order to block APCs that might suspend the thread while it's
    holding the resource.  In order to hand off the resource to a system thread, the user must
    call SipHandoffBackpointerResource.  In order to release it, call
    SipReleaseBackpointerResource.

Arguments:

    CSFile      - The common store file who's backpointer resource we wish to acquire
    Exclusive   - Do we want to acquire it exclusively or shared
    Wait        - Block or fail on a contested acquire

Return Value:

    TRUE iff the resource was acquired.

--*/
{
    BOOLEAN     result;

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeEnterCriticalRegion();
    }

    if (Exclusive) {
        result = ExAcquireResourceExclusiveLite(CSFile->BackpointerResource,Wait);
    } else {
        result = ExAcquireResourceSharedLite(CSFile->BackpointerResource, Wait);
    }

    return result;
}

VOID
SipReleaseBackpointerResource(
    IN PSIS_CS_FILE                     CSFile)
{
    SipReleaseBackpointerResourceForThread(CSFile,ExGetCurrentResourceThread());
}

VOID
SipReleaseBackpointerResourceForThread(
    IN PSIS_CS_FILE                     CSFile,
    IN ERESOURCE_THREAD                 thread)
{
    ExReleaseResourceForThreadLite(CSFile->BackpointerResource,thread);

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeLeaveCriticalRegion();
    }
}

VOID
SipHandoffBackpointerResource(
    IN PSIS_CS_FILE                     CSFile)
{
    UNREFERENCED_PARAMETER( CSFile );

    if (!PsIsSystemThread(PsGetCurrentThread())) {
        KeLeaveCriticalRegion();
    }
}

NTSTATUS
SipPrepareRefcountChangeAndAllocateNewPerLink(
    IN PSIS_CS_FILE             CSFile,
    IN PLARGE_INTEGER           LinkFileFileId,
    IN PDEVICE_OBJECT           DeviceObject,
    OUT PLINK_INDEX             newLinkIndex,
    OUT PSIS_PER_LINK           *perLink,
    OUT PBOOLEAN                prepared)
/*++

Routine Description:

    We want to make a new link to a common store file.  Prepare a refcount change
    on the common store file, and allocate a new link index and per link for
    the file.  Handles the bizarre error case where a "newly allocated" link index
    already has a perLink existing for it by retrying with a new link index.

Arguments:

    CSFile          - The common store file to which the new link will point

    LinkFileFileId  - The file ID for the link that's being created

    DeviceObject    - The SIS device object for this volume

    newLinkIndex    - Returns the newly allocated link index

    perLink         - Returns the newly allocated per link

    prepared        - Set iff we've prepared a refcount change when we return.
                      Always set on success, may or may not be set on failure.
                      If this is set, it is the caller's responsibility to
                      complete the refcount change.


Return Value:

    status of the request

--*/
{
    NTSTATUS        status;
    ULONG           retryCount;
    BOOLEAN         finalCopyInProgress;

    //
    // We need to do this in a retry loop in order to handle the case where
    // the "newly allocated" link index already exists in the system.  This
    // can happen when bogus reparse points get written on the volume with the
    // SIS filter disabled.  It could also happen if someone munges the MaxIndex
    // file, or because of bugs in the SIS filter.
    //
    for (retryCount = 0; retryCount < 500; retryCount++) {  //This retry count was made up
        //
        // Now, prepare a refcount change, which will allocate a link index.
        //
        status = SipPrepareCSRefcountChange(
                    CSFile,
                    newLinkIndex,
                    LinkFileFileId,
                    SIS_REFCOUNT_UPDATE_LINK_CREATED);

        if (!NT_SUCCESS(status)) {
            SIS_MARK_POINT_ULONG(status);

            *prepared = FALSE;
            return status;
        }

        *prepared = TRUE;

        *perLink = SipLookupPerLink(
                        newLinkIndex,
                        &CSFile->CSid,
                        LinkFileFileId,
                        &CSFile->CSFileNtfsId,
                        DeviceObject,
                        NULL,
                        &finalCopyInProgress);

        if (NULL == *perLink) {
            SIS_MARK_POINT();

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (CSFile == (*perLink)->CsFile) {
            //
            // This is the normal case.
            //
            break;
        }

#if     DBG
        DbgPrint("SIS: SipPrepareRefcountChangeAndAllocateNewPerLink: retrying 0x%x due to collision, %d\n",CSFile,retryCount);
#endif  // DBG

        //
        // Somehow, we got a conflict on a perLink that should have been newly allocated.
        // Back out the prepare and try again.
        //
        SipCompleteCSRefcountChange(
            NULL,
            NULL,
            CSFile,
            FALSE,
            TRUE);

        *prepared = FALSE;

        SipDereferencePerLink(*perLink);
    }

    if (NULL == *perLink) {
        //
        // This is the failure-after-retry case.  Give up.
        //
        SIS_MARK_POINT_ULONG(CSFile);

        return STATUS_DRIVER_INTERNAL_ERROR;
    }

    ASSERT(IsEqualGUID(&(*perLink)->CsFile->CSid, &CSFile->CSid));

    //
    // Since this link file doesn't even exist until now, we can't have final copy in
    // progress.
    //
    ASSERT(!finalCopyInProgress);

    return STATUS_SUCCESS;
}


#if     DBG
BOOLEAN
SipAssureNtfsIdValid(
    IN PSIS_PER_FILE_OBJECT     PerFO,
    IN OUT PSIS_PER_LINK        PerLink)
{
    NTSTATUS                    status;
    FILE_INTERNAL_INFORMATION   internalInfo[1];
    ULONG                       returnedLength;

    ASSERT(PerFO->fc->primaryScb->PerLink == PerLink);

    status = SipQueryInformationFile(
                PerFO->fileObject,
                PerLink->CsFile->DeviceObject,
                FileInternalInformation,
                sizeof(FILE_INTERNAL_INFORMATION),
                internalInfo,
                &returnedLength);

    if (!NT_SUCCESS(status)) {
        SIS_MARK_POINT_ULONG(status);
        return FALSE;
    }

    ASSERT(status != STATUS_PENDING);
    ASSERT(returnedLength == sizeof(FILE_INTERNAL_INFORMATION));

    return internalInfo->IndexNumber.QuadPart == PerLink->LinkFileNtfsId.QuadPart;
}
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\centctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    centctrl.cpp

Abstract:

	SIS Groveler central controller

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

const _TCHAR total_processor_time_path[] = _T("\\Processor(_Total#0)\\% Processor Time");

CentralController::CentralController(
	int num_partitions,
	Groveler *grovelers,
	GrovelStatus *groveler_statuses,
	ReadParameters *read_parameters,
	WriteParameters *write_parameters,
	ReadDiskInformation **read_disk_info,
	WriteDiskInformation **write_disk_info,
	int *num_excluded_paths,
	const _TCHAR ***excluded_paths)
:	hash_match_ratio_filter(read_parameters->sis_efficacy_history_size,
		write_parameters->hash_match_ratio),
	compare_match_ratio_filter(read_parameters->sis_efficacy_history_size,
		write_parameters->compare_match_ratio),
	dequeue_hash_ratio_filter(read_parameters->log_winnow_history_size,
		write_parameters->dequeue_hash_ratio)
{
	ASSERT(this != 0);
	unsigned int current_time = GET_TICK_COUNT();
	this->num_partitions = num_partitions;
	ASSERT(num_partitions > 0);
	this->grovelers = grovelers;
	ASSERT(grovelers != 0);
	base_grovel_interval = read_parameters->base_grovel_interval;
	ASSERT(base_grovel_interval > 0);
	max_grovel_interval = read_parameters->max_grovel_interval;
	ASSERT(max_grovel_interval > 0);
	ASSERT(max_grovel_interval >= base_grovel_interval);
	max_response_lag = read_parameters->max_response_lag;
	ASSERT(max_response_lag > 0);
	working_grovel_interval = read_parameters->working_grovel_interval;
	ASSERT(working_grovel_interval > 0);
	ASSERT(base_grovel_interval >= working_grovel_interval);
	grovel_duration = read_parameters->grovel_duration;
	ASSERT(grovel_duration > 0);
	ASSERT(grovel_duration <= base_grovel_interval);
	ASSERT(grovel_duration <= max_grovel_interval);
	ASSERT(grovel_duration <= working_grovel_interval);
	hash_match_ratio = &write_parameters->hash_match_ratio;
	ASSERT(hash_match_ratio != 0);
	ASSERT(*hash_match_ratio >= 0.0);
	ASSERT(*hash_match_ratio <= 1.0);
	compare_match_ratio = &write_parameters->compare_match_ratio;
	ASSERT(compare_match_ratio != 0);
	ASSERT(*compare_match_ratio >= 0.0);
	ASSERT(*compare_match_ratio <= 1.0);
	dequeue_hash_ratio = &write_parameters->dequeue_hash_ratio;
	ASSERT(dequeue_hash_ratio != 0);
	ASSERT(*dequeue_hash_ratio >= 0.0);
	ASSERT(*dequeue_hash_ratio <= 1.0);
	foreground_partition_index = 0;
	num_alive_partitions = 0;
	bool some_groveler_dead = false;

    //
    //  Create the control structure for each partion
    //

	part_controllers = new PartitionController*[num_partitions];
	for (int index = 0; index < num_partitions; index++)
	{
		part_controllers[index] = new PartitionController(
			&grovelers[index],
			groveler_statuses[index],
			read_parameters->target_entries_per_extraction,
			read_parameters->max_extraction_interval,
			base_grovel_interval,
			max_grovel_interval,
			read_parameters->low_confidence_grovel_interval,
			read_parameters->low_disk_space_grovel_interval,
			read_parameters->partition_info_update_interval,
			read_parameters->base_restart_extraction_interval,
			read_parameters->max_restart_extraction_interval,
			read_parameters->base_restart_groveling_interval,
			read_parameters->max_restart_groveling_interval,
			read_parameters->base_regrovel_interval,
			read_parameters->max_regrovel_interval,
			read_parameters->volscan_regrovel_threshold,
			read_parameters->partition_balance_time_constant,
			read_parameters->read_time_increase_history_size,
			read_parameters->read_time_decrease_history_size,
			read_parameters->file_size_history_size,
			read_disk_info[index]->error_retry_log_extraction,
			read_disk_info[index]->error_retry_groveling,
			read_disk_info[index]->base_usn_log_size,
			read_disk_info[index]->max_usn_log_size,
			read_parameters->sample_group_size,
			read_parameters->acceptance_p_value,
			read_parameters->rejection_p_value,
			read_parameters->base_use_multiplier,
			read_parameters->max_use_multiplier,
			read_parameters->peak_finder_accuracy,
			read_parameters->peak_finder_range,
			read_parameters->base_cpu_load_threshold,
			read_parameters->max_cpu_load_threshold,
			hash_match_ratio,
			compare_match_ratio,
			dequeue_hash_ratio,
			&write_disk_info[index]->partition_hash_read_time_estimate,
			&write_disk_info[index]->partition_compare_read_time_estimate,
			&write_disk_info[index]->mean_file_size,
			&write_disk_info[index]->read_time_confidence,
			&write_disk_info[index]->volume_serial_number,
			index,
			read_parameters->read_report_discard_threshold,
			read_disk_info[index]->min_file_size,
			read_disk_info[index]->min_file_age,
			read_disk_info[index]->allow_compressed_files,
			read_disk_info[index]->allow_encrypted_files,
			read_disk_info[index]->allow_hidden_files,
			read_disk_info[index]->allow_offline_files,
			read_disk_info[index]->allow_temporary_files,
			num_excluded_paths[index],
			excluded_paths[index]);
		if (groveler_statuses[index] != Grovel_disable)
		{
			if (groveler_statuses[index] == Grovel_ok ||
				groveler_statuses[index] == Grovel_new ||
				read_disk_info[index]->error_retry_groveling)
			{
				num_alive_partitions++;
			}
			else
			{
				ASSERT(groveler_statuses[index] == Grovel_error);
				some_groveler_dead = true;
			}
		}
	}
	if (num_alive_partitions == 0)
	{
		if (some_groveler_dead)
		{
			eventlog.report_event(GROVMSG_ALL_GROVELERS_DEAD, 0);
		}
		else
		{
			eventlog.report_event(GROVMSG_ALL_GROVELERS_DISABLED, 0);
		}
		return;
	}

	cpu_load_determinable = false;
	PDH_STATUS status = PdhOpenQuery(0, 0, &qhandle);
	if (status == ERROR_SUCCESS)
	{
		ASSERT(qhandle != 0);
		status = PdhAddCounter(qhandle, total_processor_time_path, 0, &ctr_handle);
		if (status == ERROR_SUCCESS)
		{
			ASSERT(ctr_handle != 0);
			cpu_load_determinable = true;
			get_cpu_load();
		}
		else
		{
			PRINT_DEBUG_MSG(
				(_T("GROVELER: PdhAddCounter returned error.  PDH_STATUS = %lx\n"),
				status));
		}
	}
	else
	{
		PRINT_DEBUG_MSG((_T("GROVELER: PdhOpenQuery returned error.  PDH_STATUS = %lx\n"),
			status));
	}
	last_invokation_time = current_time;
	event_timer.schedule(current_time + base_grovel_interval,
		(void *)this, control_groveling);
}

CentralController::~CentralController()
{
	ASSERT(this != 0);
	ASSERT(num_partitions > 0);
	if (cpu_load_determinable)
	{
		ASSERT(qhandle != 0);
		PDH_STATUS status = PdhCloseQuery(qhandle);
		if (status != ERROR_SUCCESS)
		{
			PRINT_DEBUG_MSG(
				(_T("GROVELER: PdhCloseQuery returned error.  PDH_STATUS = %lx\n"),
				status));
		}
		qhandle = 0;
	}
	for (int index = 0; index < num_partitions; index++)
	{
		ASSERT(part_controllers[index] != 0);
		delete part_controllers[index];
		part_controllers[index] = 0;
	}
	ASSERT(part_controllers != 0);
	delete[] part_controllers;
	part_controllers = 0;
}

bool
CentralController::any_grovelers_alive()
{
	ASSERT(this != 0);
	return num_alive_partitions > 0;
}

void
CentralController::demarcate_foreground_batch(
	int partition_index)
{
	ASSERT(this != 0);
	ASSERT(partition_index >= 0);
	ASSERT(partition_index < num_partitions);
	part_controllers[partition_index]->demarcate_foreground_batch();
}

void
CentralController::command_full_volume_scan(
	int partition_index)
{
	ASSERT(this != 0);
	ASSERT(partition_index >= 0);
	ASSERT(partition_index < num_partitions);
	part_controllers[partition_index]->command_full_volume_scan();
}

void
CentralController::control_groveling(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_centctrl, 3, (_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_centctrl, 3, (_T("\tCCcg -\tcontrolling groveling\n")));
	CentralController *me = (CentralController *)context;
	ASSERT(me->num_partitions > 0);
	ASSERT(me->num_alive_partitions > 0);
	if (SERVICE_GROVELING_PAUSED() || SERVICE_FOREGROUND_GROVELING())
	{
		TRACE_PRINTF(TC_centctrl, 1, (_T("\tCCcg -\tsuspending controller\n")));
		SERVICE_SUSPENDING_CONTROLLER();
		return;  // return without scheduling another control_groveling()
	}
	int partition_index = -1;
	double top_priority = DBL_MAX;
	unsigned int time_delta = invokation_time - me->last_invokation_time;
	ASSERT(signed(time_delta) >= 0);
	for (int index = 0; index < me->num_partitions; index++)
	{
		me->part_controllers[index]->advance(time_delta);
		if (me->part_controllers[index]->wait() == 0)
		{
			double partition_priority = me->part_controllers[index]->priority();
			if (partition_priority < top_priority)
			{
				partition_index = index;
				top_priority = partition_priority;
			}
		}
	}
	if (partition_index >= 0)
	{
		ASSERT(partition_index < me->num_partitions);
		TRACE_PRINTF(TC_centctrl, 5,
			(_T("\tCCcg -\tgroveling partition %d\n"), partition_index));
		me->grovel_partition(partition_index);
	}
	else
	{
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCcg -\tno partition controllers ready to grovel.\n")));
	}
	int grovel_interval = me->max_response_lag;
	ASSERT(grovel_interval > 0);
	for (index = 0; index < me->num_partitions; index++)
	{
		int wait = me->part_controllers[index]->wait();
		if (wait < grovel_interval)
		{
			grovel_interval = wait;
		}
	}
	if (grovel_interval < me->working_grovel_interval)
	{
		grovel_interval = me->working_grovel_interval;
	}
	TRACE_PRINTF(TC_centctrl, 5,
		(_T("\tCCcg -\tgrovel interval = %d\n"), grovel_interval));
	me->last_invokation_time = invokation_time;
	ASSERT(grovel_interval > 0);
	event_timer.schedule(invokation_time + grovel_interval,
		context, control_groveling);
}

void
CentralController::exhort_groveling(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_centctrl, 3, (_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_centctrl, 3, (_T("\tCCcg -\texhorting groveling\n")));
	CentralController *me = (CentralController *)context;
	ASSERT(me->num_partitions > 0);
	ASSERT(me->num_alive_partitions > 0);
	if (SERVICE_GROVELING_PAUSED() || !SERVICE_FOREGROUND_GROVELING())
	{
		TRACE_PRINTF(TC_centctrl, 1, (_T("\tCCcg -\tsuspending exhorter\n")));
		SERVICE_SUSPENDING_EXHORTER();
		return;  // return without scheduling another exhort_groveling()
	}
	for (int index = 0; index < me->num_partitions; index++)
	{
		me->foreground_partition_index =
			(me->foreground_partition_index + 1) % me->num_partitions;
		if (SERVICE_PARTITION_IN_FOREGROUND(me->foreground_partition_index))
		{
			break;
		}
	}
	ASSERT(me->foreground_partition_index >= 0);
	ASSERT(me->foreground_partition_index < me->num_partitions);
	ASSERT(SERVICE_PARTITION_IN_FOREGROUND(me->foreground_partition_index));
	TRACE_PRINTF(TC_centctrl, 5, (_T("\tCCcg -\tgroveling partition %d\n"),
		me->foreground_partition_index));
	me->grovel_partition(me->foreground_partition_index);
	event_timer.schedule(invokation_time + me->working_grovel_interval,
		context, exhort_groveling);
}

double
CentralController::get_cpu_load()
{
	ASSERT(this != 0);
	if (!cpu_load_determinable)
	{
		return 0.0;
	}
	ASSERT(qhandle != 0);
	ASSERT(ctr_handle != 0);
	PDH_STATUS status = PdhCollectQueryData(qhandle);
	if (status != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG(
			(_T("GROVELER: PdhCollectQueryData returned error.  PDH_STATUS = %lx\n"),
			status));
		return 0.0;
	}
	PDH_FMT_COUNTERVALUE pdh_value;
	status =
		PdhGetFormattedCounterValue(ctr_handle, PDH_FMT_LONG, 0, &pdh_value);
	if (status != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG(
			(_T("GROVELER: PdhGetFormattedCounterValue returned error.  PDH_STATUS = %lx\n"),
			status));
		return 0.0;
	}
	if (pdh_value.CStatus != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: PDH_FMT_COUNTERVALUE::CStatus = %lx\n"), status));
		return 0.0;
	}
	double cpu_load = double(pdh_value.longValue) / 100.0;
	if (cpu_load < 0.0)
	{
		cpu_load = 0.0;
	}
	if (cpu_load > 1.0)
	{
		cpu_load = 1.0;
	}
	return cpu_load;
}

void
CentralController::grovel_partition(
	int partition_index)
{
	ASSERT(this != 0);
	DWORD count_of_files_hashed;
	DWORDLONG bytes_of_files_hashed;
	DWORD count_of_files_matching;
	DWORDLONG bytes_of_files_matching;
	DWORD count_of_files_compared;
	DWORDLONG bytes_of_files_compared;
	DWORD count_of_files_merged;
	DWORDLONG bytes_of_files_merged;
	DWORD count_of_files_enqueued;
	DWORD count_of_files_dequeued;
	double cpu_load = get_cpu_load();
	TRACE_PRINTF(TC_centctrl, 4, (_T("\tCCgp -\tcpu load = %f\n"), cpu_load));
	ASSERT(cpu_load >= 0.0);
	ASSERT(cpu_load <= 1.0);
	bool ok = part_controllers[partition_index]->
		control_operation(grovel_duration,
		&count_of_files_hashed, &bytes_of_files_hashed,
		&count_of_files_matching, &bytes_of_files_matching,
		&count_of_files_compared, &bytes_of_files_compared,
		&count_of_files_merged, &bytes_of_files_merged,
		&count_of_files_enqueued, &count_of_files_dequeued,
		cpu_load);
	if (ok)
	{
		ASSERT(bytes_of_files_hashed >= count_of_files_hashed);
		ASSERT(bytes_of_files_matching >= count_of_files_matching);
		ASSERT(bytes_of_files_compared >= count_of_files_compared);
		ASSERT(bytes_of_files_merged >= count_of_files_merged);
		ASSERT(count_of_files_hashed >= count_of_files_matching);
		ASSERT(bytes_of_files_hashed >= bytes_of_files_matching);
		ASSERT(count_of_files_compared >= count_of_files_merged);
		ASSERT(bytes_of_files_compared >= bytes_of_files_merged);
		ASSERT(count_of_files_dequeued >= count_of_files_hashed);
		TRACE_PRINTF(TC_centctrl, 3, 
			(_T("\tCCgp -\tpartition %d groveled.\n"), partition_index));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles hashed = %d\n"), count_of_files_hashed));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tbytes hashed = %I64d\n"), bytes_of_files_hashed));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles matching = %d\n"), count_of_files_matching));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tbytes matching = %I64d\n"),
			bytes_of_files_matching));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles compared = %d\n"), count_of_files_matching));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tbytes compared = %I64d\n"),
			bytes_of_files_matching));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles merged = %d\n"), count_of_files_merged));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tbytes merged = %I64d\n"), bytes_of_files_merged));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles enqueued = %d\n"), count_of_files_enqueued));
		TRACE_PRINTF(TC_centctrl, 4,
			(_T("\tCCgp -\tfiles dequeued = %d\n"), count_of_files_dequeued));
		if (bytes_of_files_hashed > 0)
		{
			double sample_hash_match_ratio =
				double(__int64(bytes_of_files_matching))
				/ double(__int64(bytes_of_files_hashed));
			ASSERT(sample_hash_match_ratio >= 0.0);
			ASSERT(sample_hash_match_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 4,
				(_T("\tCCgp -\tsample hash match ratio = %f\n"),
				sample_hash_match_ratio));
			hash_match_ratio_filter.update_value(
				sample_hash_match_ratio, count_of_files_hashed);
			*hash_match_ratio = hash_match_ratio_filter.retrieve_value();
			ASSERT(*hash_match_ratio >= 0.0);
			ASSERT(*hash_match_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 3,
				(_T("\tCCgp -\tfiltered hash match ratio = %f\n"),
				*hash_match_ratio));
		}
		if (bytes_of_files_compared > 0)
		{
			double sample_compare_match_ratio =
				double(__int64(bytes_of_files_merged))
				/ double(__int64(bytes_of_files_compared));
			ASSERT(sample_compare_match_ratio >= 0.0);
			ASSERT(sample_compare_match_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 4,
				(_T("\tCCgp -\tsample compare match ratio = %f\n"),
				sample_compare_match_ratio));
			compare_match_ratio_filter.update_value(
				sample_compare_match_ratio, count_of_files_compared);
			*compare_match_ratio = compare_match_ratio_filter.retrieve_value();
			ASSERT(*compare_match_ratio >= 0.0);
			ASSERT(*compare_match_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 3,
				(_T("\tCCgp -\tfiltered compare match ratio = %f\n"),
				*compare_match_ratio));
		}
		if (count_of_files_dequeued > 0)
		{
			double sample_dequeue_hash_ratio =
				double(__int64(count_of_files_hashed))
				/ double(__int64(count_of_files_dequeued));
			ASSERT(sample_dequeue_hash_ratio >= 0.0);
			ASSERT(sample_dequeue_hash_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 4,
				(_T("\tCCgp -\tsample dequeue hash ratio = %f\n"),
				sample_dequeue_hash_ratio));
			dequeue_hash_ratio_filter.update_value(
				sample_dequeue_hash_ratio, count_of_files_dequeued);
			*dequeue_hash_ratio = dequeue_hash_ratio_filter.retrieve_value();
			ASSERT(*dequeue_hash_ratio >= 0.0);
			ASSERT(*dequeue_hash_ratio <= 1.0);
			TRACE_PRINTF(TC_centctrl, 3,
				(_T("\tCCgp -\tfiltered dequeue hash ratio = %f\n"),
				*dequeue_hash_ratio));
		}
	}
	else
	{
		TRACE_PRINTF(TC_centctrl, 1,
			(_T("\tCCgp -\tpartition %d groveler dead.\n"), partition_index));
		num_alive_partitions--;
		if (num_alive_partitions <= 0)
		{
			ASSERT(num_alive_partitions == 0);
			eventlog.report_event(GROVMSG_ALL_GROVELERS_DEAD, 0);
			event_timer.halt();
			return;
		}
	}
//	get_cpu_load();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\sitree.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sitree.c

Abstract:

    This module implements a splay tree package based on the Rtl
    splay routines.  Adapted from the Rtl generic table package.

--*/

#include "sip.h"


//
// This enumerated type is used as the function return
// value of the function that is used to search the tree
// for a key.  SisFoundNode indicates that the function found
// the key.  SisInsertAsLeft indicates that the key was not found
// and the node should be inserted as the left child of the
// parent.  SisInsertAsRight indicates that the key was not found
// and the node should be inserted as the right child of the
// parent.
//

typedef enum _SIS_SEARCH_RESULT{
    SisEmptyTree,
    SisFoundNode,
    SisInsertAsLeft,
    SisInsertAsRight
} SIS_SEARCH_RESULT;


static
SIS_SEARCH_RESULT
FindNodeOrParent(
    IN PSIS_TREE Tree,
    IN PVOID Key,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is private to the tree package and will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Tree        - The  tree to search for the key.

    Key          - Pointer to a buffer holding the key.  The tree
                   package doesn't examine the key itself.  It leaves
                   this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is SisEmptyTree.

Return Value:

    SIS_SEARCH_RESULT - SisEmptyTree: The tree was empty.  NodeOrParent
                                      is *not* altered.

                    SisFoundNode: A node with the key is in the tree.
                                  NodeOrParent points to that node.

                    SisInsertAsLeft: Node with key was not found.
                                     NodeOrParent points to what would be
                                     parent.  The node would be the left
                                     child.

                    SisInsertAsRight: Node with key was not found.
                                      NodeOrParent points to what would be
                                      parent.  The node would be the right
                                      child.

--*/

{

    if (Tree->TreeRoot == NULL) {

        return SisEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the  tree.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Tree->TreeRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        int Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Tree->CompareRoutine(
                         Key,
                         NodeToExamine
                         );

            if (Result < 0) {

                if (Child = RtlLeftChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsLeft;

                }

            } else if (Result > 0) {

                if (Child = RtlRightChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsRight;

                }


            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == 0);
                *NodeOrParent = NodeToExamine;
                return SisFoundNode;

            }

        }

    }

}


VOID
SipInitializeTree (
    IN PSIS_TREE Tree,
    IN PSIS_TREE_COMPARE_ROUTINE CompareRoutine
    )

/*++

Routine Description:

    The procedure InitializeTree prepares a tree for use.
    This must be called for every individual tree variable before
    it can be used.

Arguments:

    Tree - Pointer to the  tree to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     tree.

Return Value:

    None.

--*/

{

    Tree->TreeRoot = NULL;
    Tree->CompareRoutine = CompareRoutine;

}


PVOID
SipInsertElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipInsertElementTree will insert a new element in a tree.
    If an element with the same key already exists in the tree the return
    value is a pointer to the old element.  Otherwise, the return value is
    a pointer to the new element.  Note that this differs from the Rtl
    generic table package in that the actual node passed in is inserted in
    the tree, whereas the table package inserts a copy of the node.

Arguments:

    Tree - Pointer to the tree in which to (possibly) insert the
           node.

    Node - Pointer to the node to insert in the tree.  Will not be inserted
           if a node with a matching key is found.

    Key - Passed to the user comparasion routine.

Return Value:

    PVOID - Pointer to the new node or the existing node if one exists.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //
    PRTL_SPLAY_LINKS NodeToReturn = (PRTL_SPLAY_LINKS) Node;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup != SisFoundNode) {

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node in the tree.
        //

        if (Lookup == SisEmptyTree) {

            Tree->TreeRoot = NodeToReturn;

        } else {

            if (Lookup == SisInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            }

        }

    } else {

        NodeToReturn = NodeOrParent;

    }

    //
    // Always splay the (possibly) new node.
    //

    Tree->TreeRoot = RtlSplay(NodeToReturn);

    return NodeToReturn;
}


VOID
SipDeleteElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node
    )

/*++

Routine Description:

    The function SipDeleteElementTree will remove an element
    from a tree.  Note that the memory associated with the node
    is not actually freed.

Arguments:

    Tree - Pointer to the tree in which to remove the specified node.

    Node - Node of tree to remove.

Return Value:

    None.

--*/

{

    PRTL_SPLAY_LINKS NodeToDelete = (PRTL_SPLAY_LINKS) Node;

    //
    // Delete the node from the tree.  Note that RtlDelete
    // will splay the tree.
    //

    Tree->TreeRoot = RtlDelete(NodeToDelete);

}


PVOID
SipLookupElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipLookupElementTree will find an element in a
    tree.  If the element is located the return value is a pointer to
    the element, otherwise if the element is not located the return
    value is NULL.

Arguments:

    Tree - Pointer to the users tree to search for the key.

    Key - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup == SisEmptyTree) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.  Note that we do this irregardless
        // of whether the node was found.
        //

        Tree->TreeRoot = RtlSplay(NodeOrParent);

        //
        // Return a pointer to the user data.
        //

        if (Lookup == SisFoundNode) {

            return NodeOrParent;

        } else {

            return NULL;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\confest.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confest.cpp

Abstract:

	SIS Groveler confidence estimator

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/


#include "all.hxx"

ConfidenceEstimator::ConfidenceEstimator(
	int num_groups,
	double initial_value)
{
	ASSERT(this != 0);
	ASSERT(num_groups > 0);
	ASSERT(initial_value >= 0.0);
	ASSERT(initial_value <= 1.0);
	this->num_groups = num_groups;
	group_values = new double[num_groups];
	confidence_value = initial_value;
	reset(initial_value);
}

ConfidenceEstimator::~ConfidenceEstimator()
{
	ASSERT(this != 0);
	ASSERT(num_groups > 0);
	ASSERT(confidence_value >= 0.0);
	ASSERT(confidence_value <= 1.0);
	ASSERT(group_values != 0);
	delete[] group_values;
	group_values = 0;
}

void
ConfidenceEstimator::reset(
	double reset_value)
{
	ASSERT(this != 0);
	ASSERT(num_groups > 0);
	ASSERT(confidence_value >= 0.0);
	ASSERT(confidence_value <= 1.0);
	ASSERT(group_values != 0);
	ASSERT(reset_value >= 0.0);
	ASSERT(reset_value <= 1.0);
	for (int index = 0; index < num_groups; index++)
	{
		group_values[index] = reset_value;
	}
	confidence_value = reset_value;
}

void
ConfidenceEstimator::update(
	int group_index,
	double value)
{
	ASSERT(this != 0);
	ASSERT(num_groups > 0);
	ASSERT(confidence_value >= 0.0);
	ASSERT(confidence_value <= 1.0);
	ASSERT(group_values != 0);
	ASSERT(group_index >= 0);
	ASSERT(group_index < num_groups);
	if (value > group_values[group_index])
	{
		group_values[group_index] = value;
		confidence_value = 1.0;
		for (int index = 0; index < num_groups; index++)
		{
			if (group_values[index] < confidence_value)
			{
				confidence_value = group_values[index];
			}
		}
	}
	ASSERT(confidence_value >= 0.0);
	ASSERT(confidence_value <= 1.0);
}

double
ConfidenceEstimator::confidence() const
{
	ASSERT(this != 0);
	ASSERT(num_groups > 0);
	ASSERT(confidence_value >= 0.0);
	ASSERT(confidence_value <= 1.0);
	ASSERT(group_values != 0);
	return confidence_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\confest.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confest.h

Abstract:

	SIS Groveler confidence estimator include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_CONFEST

#define _INC_CONFEST

class ConfidenceEstimator
{
public:

	ConfidenceEstimator(
		int num_groups,
		double initial_value = 0.0);

	~ConfidenceEstimator();

	void reset(
		double reset_value = 0.0);

	void update(
		int group_index,
		double value);

	double confidence() const;

private:

	int num_groups;
	double confidence_value;
	double *group_values;
};

#endif	/* _INC_CONFEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\filter\siwrite.c ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    siwrite.c

Abstract:

	Write routines for the single instance store

Authors:

    Bill Bolosky, Summer, 1997

Environment:

    Kernel mode


Revision History:


--*/

#include "sip.h"

VOID
SiWriteUpdateRanges(
	PVOID					Parameter)
{
	PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext = Parameter;
	KIRQL									OldIrql;
	PSIS_SCB								scb = updateContext->scb;

	SIS_MARK_POINT_ULONG(updateContext);
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	SipAcquireScb(scb);

	//
	// Mark the range as written.
	//
	SipAddRangeToWrittenList(
			updateContext->deviceExtension,
			scb,
			&updateContext->offset,
			updateContext->length);

	scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

	SipReleaseScb(scb);

	KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
	scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
	KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);

	SipDereferenceScb(scb,RefsWriteCompletion);

	ExFreePool(updateContext);

	return;
}

NTSTATUS
SipWriteCommonCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PSIS_SCB				scb,
	IN ULONG				length)
/*++

Routine Description:

	A write has completed to an SIS file.  Update the written ranges,
	posting if necessary to do this.  This function is called both from the
	normal and Mdl completion routines after they've figured out the appropriate
	write length to use.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	scb - the scb for this operation

	length - the length of the write that completed.

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	BOOLEAN					PagingIo;
	KIRQL					OldIrql;
	LARGE_INTEGER			byteOffset;
	
	//
	// We don't necessarily have a valid DeviceObject parameter, so just fill it in
	// from our internal data structures.
	//
	DeviceObject = scb->PerLink->CsFile->DeviceObject;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;

	byteOffset = irpSp->Parameters.Write.ByteOffset;

	if (NT_SUCCESS(Irp->IoStatus.Status)) {

//		SIS_MARK_POINT_ULONG(length);

		//
		// We need to update the written range.  To do that, we need to
		// acquire the scb, which we can only do if we're at less than
		// dispatch level.  If we are at dispatch level or greater, then
		// we'll just post off the work to do the range update.
		// NB: This can possibly cause slightly strange semantics for
		// users, because they could see a write completion, send down
		// a read for the same range, and have it redirected to the
		// common store file because the posted work hasn't happened yet...
		//

		if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
			PRW_COMPLETION_UPDATE_RANGES_CONTEXT	updateContext;

			SIS_MARK_POINT_ULONG(scb);

			updateContext = ExAllocatePoolWithTag(NonPagedPool,sizeof(*updateContext),' siS');
			if (NULL == updateContext) {
				//
				// Just fail the irp.
				//
				Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
				Irp->IoStatus.Information = 0;

				goto done;
			}

			SipReferenceScb(scb,RefsWriteCompletion);

			updateContext->scb = scb;
			updateContext->offset = byteOffset;
			updateContext->length = length;
			updateContext->deviceExtension = DeviceObject->DeviceExtension;

			ExInitializeWorkItem(
				updateContext->workQueueItem,
				SiWriteUpdateRanges,
				(PVOID)updateContext);

			ExQueueWorkItem(updateContext->workQueueItem,CriticalWorkQueue);
			
		} else {

			SipAcquireScb(scb);

			//
			// Mark the range as written.
			//
			SipAddRangeToWrittenList(
					(PDEVICE_EXTENSION)DeviceObject->DeviceExtension,
					scb,
					&byteOffset,
					length);

			scb->Flags |= SIS_SCB_ANYTHING_IN_COPIED_FILE;

			SipReleaseScb(scb);

			KeAcquireSpinLock(scb->PerLink->SpinLock, &OldIrql);
			scb->PerLink->Flags |= SIS_PER_LINK_DIRTY;
			KeReleaseSpinLock(scb->PerLink->SpinLock, OldIrql);
		}

		//
		// If appropriate, update the file pointer.
		//
		if (!PagingIo && (irpSp->FileObject->Flags & FO_SYNCHRONOUS_IO)) {

			irpSp->FileObject->CurrentByteOffset.QuadPart =
				irpSp->Parameters.Write.ByteOffset.QuadPart +
				length;
		}
	} else {
		//
		// The write failed, don't mark anything dirty.
		//
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
	}

done:

	SipDereferenceScb(scb, RefsWrite);

    //
    // Propogate the IRP pending flag.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

	return STATUS_SUCCESS;

}

typedef struct _SI_MDL_WRITE_COMPLETION_CONTEXT {
	PSIS_SCB			scb;
	ULONG				length;
} SI_MDL_WRITE_COMPLETION_CONTEXT, *PSI_MDL_WRITE_COMPLETION_CONTEXT;

NTSTATUS
SiWriteMdlCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PVOID 				Context)
/*++

Routine Description:

	An MDL write complete has completed on an SIS file.  Grab the write length
	from the context and pass it off to the common completion routine.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	Context - a pointer to the SI_MDL_WRITE_COMPLETION_CONTEXT for this write.

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PSI_MDL_WRITE_COMPLETION_CONTEXT completionContext = Context;
	ULONG							 length	= completionContext->length;
	PSIS_SCB						 scb = completionContext->scb;
#if		DBG
	PIO_STACK_LOCATION				 irpSp = IoGetCurrentIrpStackLocation(Irp);

	ASSERT(irpSp->MinorFunction == IRP_MN_COMPLETE_MDL);
#endif	// DBG

	if (!NT_SUCCESS(Irp->IoStatus.Status)) {
		SIS_MARK_POINT_ULONG(Irp->IoStatus.Status);
		length = 0;
	}

	ExFreePool(completionContext);

	return SipWriteCommonCompletion(DeviceObject,Irp,scb,length);
}


NTSTATUS
SiWriteCompletion(
    IN PDEVICE_OBJECT 		DeviceObject,
    IN PIRP 				Irp,
    IN PVOID 				Context)
/*++

Routine Description:

	A non-MDL write has completed.  Extract the length and scb from the irp
	and context pointers, and call the common completion routine.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

	Context - a pointer to the scb

Return Value:

	Returns STATUS_SUCCESS.
--*/
{
	PIO_STACK_LOCATION		irpSp = IoGetCurrentIrpStackLocation(Irp);
	ULONG					length;

	ASSERT(Irp->IoStatus.Status != STATUS_PENDING);

	if (NT_SUCCESS(Irp->IoStatus.Status)) {
		//
		// Figure out how much data was written.  For normal writes, this
		// is just the Information field of the Irp.  For MDL writes, its
		// the length of the region mapped by the MDL.
		//
		ASSERT(irpSp->MinorFunction != IRP_MN_COMPLETE_MDL);
		if (irpSp->MinorFunction == IRP_MN_MDL) {
			//
			// This was a write prepare.  Ignore it.
			//
			SipDereferenceScb((PSIS_SCB)Context, RefsWrite);
			return STATUS_SUCCESS;
		} else if (irpSp->MinorFunction == IRP_MN_NORMAL) {
			length = (ULONG)Irp->IoStatus.Information;
		} else {
			SIS_MARK_POINT_ULONG(Irp);
			SIS_MARK_POINT_ULONG(irpSp);

			DbgPrint("SIS: SiWriteCompletion: unknown minor function code 0x%x, irp 0x%x, irpSp 0x%x\n",
						irpSp->MinorFunction,Irp,irpSp);

			ASSERT(FALSE && "SiWriteComplete: unknown irp minor function");

			SipDereferenceScb((PSIS_SCB)Context, RefsWrite);

			return STATUS_SUCCESS;
		}
	} else {
		length = 0;
	}

	return SipWriteCommonCompletion(DeviceObject,Irp,Context,length);

}


NTSTATUS
SiWrite(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp)
/*++

Routine Description:

	This function handles write operations.  Check to see if the file object is a
	SIS file.  If so, handle the write (possibly forcing a copy-on-write), otherwise
	pass it through to NTFS.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the result of the read, or the
	status of the call to the file system's entry point in the case of a
	pass-through call.

--*/
{
    PIO_STACK_LOCATION 			irpSp = IoGetCurrentIrpStackLocation(Irp);
	PIO_STACK_LOCATION			nextIrpSp;
	PFILE_OBJECT 				fileObject = irpSp->FileObject;
	PSIS_SCB 					scb;
	ULONG						writeLength;
	LONGLONG					byteOffset;
    BOOLEAN 					PagingIo;
	PDEVICE_EXTENSION			deviceExtension;
	PSIS_PER_FILE_OBJECT		perFO;
	PSIS_PER_LINK				perLink;
	PSIS_CS_FILE				csFile;

	SipHandleControlDeviceObject(DeviceObject, Irp);

	if (!SipIsFileObjectSIS(fileObject,DeviceObject,FindActive,&perFO,&scb)) {
		SipDirectPassThroughAndReturn(DeviceObject, Irp);
	}

	ASSERT(perFO->fileObject == fileObject);

	perLink = scb->PerLink;
	csFile = perLink->CsFile;

	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PagingIo = (Irp->Flags & IRP_PAGING_IO) ? TRUE : FALSE;
	
	byteOffset = irpSp->Parameters.Write.ByteOffset.QuadPart;
	writeLength = irpSp->Parameters.Write.Length;

	SIS_MARK_POINT_ULONG(perFO);
	SIS_MARK_POINT_ULONG(scb);

#if		DBG
	if (0 != byteOffset) {
		SIS_MARK_POINT_ULONG(byteOffset);
	}

	if (0x200 != writeLength) {
		SIS_MARK_POINT_ULONG(writeLength);
	}

	if (PagingIo || (Irp->Flags & IRP_NOCACHE)) {
		SIS_MARK_POINT_ULONG((PagingIo << 1) | ((Irp->Flags & IRP_NOCACHE) != 0));
	}

	if (BJBDebug & 0x00008000) {
		DbgPrint("SIS: SiWrite: perFO %p, scb %p, bo.Low 0x%x, rel 0x%x, PIO %d, NC %d MF 0x%x\n",
				perFO,scb,(ULONG)byteOffset,writeLength,PagingIo, (Irp->Flags & IRP_NOCACHE) != 0, irpSp->MinorFunction);
	}
#endif	// DBG

	//
	// Setup the next irp stack location for the underlying filesystem on the
	// copied file (which is the same file object with which we were called)
	//
	nextIrpSp = IoGetNextIrpStackLocation(Irp);
	RtlMoveMemory(nextIrpSp,irpSp,sizeof(IO_STACK_LOCATION));

	//
	// Grab a reference to the SCB for the write completion routine.
	//
	SipReferenceScb(scb, RefsWrite);

	if (irpSp->MinorFunction == IRP_MN_COMPLETE_MDL) {
		//
		// This is an MDL completion, grab the length from the MDL here, because it
		// will be gone on the way back up.
		//
		PSI_MDL_WRITE_COMPLETION_CONTEXT completionContext = 
				ExAllocatePoolWithTag(NonPagedPool, sizeof(SI_MDL_WRITE_COMPLETION_CONTEXT),' siS');

		if (NULL == completionContext) {
			SIS_MARK_POINT();
			Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
			Irp->IoStatus.Information = 0;

			SipDereferenceScb(scb, RefsWrite);

			IoCompleteRequest(Irp, IO_NO_INCREMENT);
	
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		ASSERT(NULL != Irp->MdlAddress);
		completionContext->scb = scb;
		completionContext->length = MmGetMdlByteCount(Irp->MdlAddress);

		IoSetCompletionRoutine(
				Irp,
				SiWriteMdlCompletion,
				completionContext,
				TRUE,
				TRUE,
				TRUE);
	} else {

		IoSetCompletionRoutine(
				Irp,
				SiWriteCompletion,
				scb,
				TRUE,
				TRUE,
				TRUE);
	}

	//
	// Hand the request down to the underlying filesystem.
	//
	
	return IoCallDriver(deviceExtension->AttachedToDeviceObject, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\centctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    centctrl.h

Abstract:

	SIS Groveler central controller include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_CENTCTRL

#define _INC_CENTCTRL

class CentralController
{
public:

	CentralController(
		int num_partitions,
		Groveler *grovelers,
		GrovelStatus *groveler_statuses,
		ReadParameters *read_parameters,
		WriteParameters *write_parameters,
		ReadDiskInformation **read_disk_info,
		WriteDiskInformation **write_disk_info,
		int *num_excluded_paths,
		const _TCHAR ***excluded_paths);

	~CentralController();

	bool any_grovelers_alive();

	void demarcate_foreground_batch(
		int partition_index);

	void command_full_volume_scan(
		int partition_index);

	static void control_groveling(
		void *context);

	static void exhort_groveling(
		void *context);

private:

	double get_cpu_load();

	void grovel_partition(
		int partition_index);

	int num_partitions;
	int num_alive_partitions;
	Groveler *grovelers;
	PartitionController **part_controllers;

	IncidentFilter hash_match_ratio_filter;
	IncidentFilter compare_match_ratio_filter;
	IncidentFilter dequeue_hash_ratio_filter;

	double *hash_match_ratio;
	double *compare_match_ratio;
	double *dequeue_hash_ratio;

	bool cpu_load_determinable;
	HQUERY qhandle;
	HCOUNTER ctr_handle;

	int base_grovel_interval;
	int max_grovel_interval;
	int max_response_lag;
	int working_grovel_interval;
	int grovel_duration;
	unsigned int last_invokation_time;

	int foreground_partition_index;
};

#endif	/* _INC_CENTCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\debug.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.h

Abstract:

	SIS Groveler debug print include file

Authors:

	John Douceur,    1998
	Cedric Krumbein, 1998

Environment:

	User Mode

Revision History:

--*/

#ifndef _INC_DEBUG

#define _INC_DEBUG

#undef ASSERT

#if DBG

INT __cdecl PrintDebugMsg(
	TCHAR *format,
	...);

#define PRINT_DEBUG_MSG(args) PrintDebugMsg ## args

#define ASSERT(cond) \
	((!(cond)) ? \
		(PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s\n"), \
			_T(__FILE__), __LINE__, _T(#cond)), \
		 DbgBreakPoint()) : \
        ((void)0))

#define ASSERT_ERROR(cond) \
	((!(cond)) ? \
		(PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s: %lu\n"), \
			_T(__FILE__), __LINE__, _T(#cond), GetLastError()), \
    	 DbgBreakPoint()) : \
        ((void)0))

#define ASSERT_PRINTF(cond, args) \
	((!(cond)) ? \
		(PrintDebugMsg(_T("ASSERT FAILED (%s:%d) %s "), \
			_T(__FILE__), __LINE__, _T(#cond)), \
		 PrintDebugMsg ## args , \
         DbgBreakPoint()) : \
        ((void)0))

#else // DBG

#define PRINT_DEBUG_MSG(args)

#define ASSERT(cond) ((void)0)

#define ASSERT_ERROR(cond) ((void)0)

#define ASSERT_PRINTF(cond, args) ((void)0)

#endif

#endif	/* _INC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\debug.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

	SIS Groveler debug print file

Authors:

	John Douceur,    1998
	Cedric Krumbein, 1998

Environment:

	User Mode

Revision History:

--*/

#include "all.hxx"

#if DBG

INT __cdecl PrintDebugMsg(
	TCHAR *format,
	...)
{
	TCHAR debugStr[1024];
	va_list ap;
	va_start(ap, format);
	INT result = _vstprintf(debugStr, format, ap);
	OutputDebugString(debugStr);
	va_end(ap);
	return result;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\database.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    database.cpp

Abstract:

    SIS Groveler Jet-Blue database front-end

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode


Revision History:

--*/

#include "all.hxx"

/*****************************************************************************/
/*************** SGDatabase class static value initializations ***************/
/*****************************************************************************/

DWORD SGDatabase::numInstances = 0;

JET_INSTANCE SGDatabase::instance = 0;

BOOL SGDatabase::jetInitialized = FALSE;

TCHAR * SGDatabase::logDir = NULL;

/*****************************************************************************/
/****************** SGDatabase class private static methods ******************/
/*****************************************************************************/

BOOL SGDatabase::set_log_drive(const _TCHAR *drive_name)
{
    int drive_name_len = _tcslen(drive_name);
    int cs_dir_path_len = _tcslen(CS_DIR_PATH);

    ASSERT(NULL == logDir);
    logDir = new TCHAR[drive_name_len + cs_dir_path_len + 1 - 1];
    ASSERT(NULL != logDir);

    _tcsncpy(SGDatabase::logDir, drive_name, drive_name_len - 1);
    _tcscpy(&SGDatabase::logDir[drive_name_len-1], CS_DIR_PATH);

    return TRUE;
}

BOOL SGDatabase::InitializeEngine()
{
    DWORD_PTR maxVerPages;
    DWORD_PTR minCacheSize;
    DWORD_PTR newCacheSize;
    DWORDLONG cacheSize;
    DWORD circularLog;
    MEMORYSTATUSEX memStatus;
    SYSTEM_INFO sysInfo;

    JET_ERR jetErr;

    ASSERT(!jetInitialized);
    ASSERT(logDir);

    if (!SetCurrentDirectory(logDir)) {
        DPRINTF((_T("SGDatabase::InitializeEngine: can't cd to \"%s\", %ld\n"), logDir, GetLastError()));
        return FALSE;
    }

    circularLog = 1;
    jetErr = JetSetSystemParameter(&instance, 0,
        JET_paramCircularLog, circularLog, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(2) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    //
    // Set the maximum cache size used by the database engine to min(4% phys mem, 6M).
    //

    jetErr = JetGetSystemParameter(instance, 0,
        JET_paramCacheSizeMin, &minCacheSize, NULL, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetGetSystemParameter: jetErr=%ld\n"), jetErr));
        TerminateEngine();
        return FALSE;
    }

    memStatus.dwLength = sizeof memStatus;
    GlobalMemoryStatusEx(&memStatus);   // get total physical memory
    GetSystemInfo(&sysInfo);            // get page size

    cacheSize = memStatus.ullTotalPhys / 25;    // 4%
    newCacheSize = (DWORD) min(cacheSize, MAX_DATABASE_CACHE_SIZE);
    newCacheSize = newCacheSize / sysInfo.dwPageSize;

    if (newCacheSize < minCacheSize)
        newCacheSize = minCacheSize;

    jetErr = JetSetSystemParameter(&instance, 0,
        JET_paramCacheSizeMax, newCacheSize, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(3) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    //
    //  Set Version Cache size
    //

    jetErr = JetGetSystemParameter(instance, 0,
        JET_paramMaxVerPages, &maxVerPages, NULL, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("(2) JetGetSystemParameter: jetErr=%ld\n"), jetErr));
        TerminateEngine();
        return FALSE;
    }

    if (maxVerPages >= MIN_VER_PAGES) {
        DPRINTF((_T("JetGetSystemParameter(instance=%lu): MaxVerPages=%lu\n"),
            instance, maxVerPages));
    } else {
        maxVerPages = MIN_VER_PAGES;
        jetErr = JetSetSystemParameter(&instance, 0,
            JET_paramMaxVerPages, maxVerPages, NULL);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("(4) JetSetSystemParameter: jetErr=%ld\n"), jetErr));
            TerminateEngine();
            return FALSE;
        }
        DPRINTF((_T("JetSetSystemParameter(instance=%lu, MaxVerPages)=%lu\n"),
            instance, maxVerPages));
    }

    //
    //  Initialize Jet
    //

    jetErr = JetInit(&instance);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetInit: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    jetInitialized = TRUE;
    DPRINTF((_T("JetInit: instance=%lu\n"), instance));

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::TerminateEngine()
{
    JET_ERR jetErr;
    BOOL  rc;

    ASSERT(jetInitialized);

    jetErr = JetTerm(instance);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetTerm: jetErr=%ld\n"), jetErr));
        rc = FALSE;
    } else {
        rc = TRUE;

// Delete no longer needed jet files.

        if (logDir) {
            WIN32_FIND_DATA findData;
            HANDLE fHandle;
            BOOL success;
            TFileName fName,
                      delName;

            delName.assign(logDir);
            delName.append(_T("\\"));
            delName.append(DATABASE_DELETE_RES_FILE_NAME);

            fHandle = FindFirstFile(delName.name, &findData);

            if (fHandle != INVALID_HANDLE_VALUE) {
                do {
                    if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                        success = GetParentName(delName.name, &fName);
                        ASSERT(success);      // internal error if failed

                        fName.append(_T("\\"));
                        fName.append(findData.cFileName);

                        if (!DeleteFile(fName.name)) {
                            DPRINTF((_T("SGDatabase::Close: can't delete \"%s\", %d\n"), delName.name, GetLastError()));
					    }
                    }
                } while (FindNextFile(fHandle, &findData));

                success = FindClose(fHandle);
                ASSERT(success);
                fHandle = NULL;
            }
        }
    }

    jetInitialized = FALSE;
    DPRINTF((_T("JetTerm\n")));
    return rc;
}

/*****************************************************************************/
/********************** SGDatabase class private methods *********************/
/*****************************************************************************/

BOOL SGDatabase::CreateTable(
    const CHAR   *tblName,
    DWORD         numColumns,
    ColumnSpec  **columnSpecs,
    JET_COLUMNID *columnIDs,
    JET_TABLEID  *tblID)
{
    JET_COLUMNDEF columnDef;

    JET_COLUMNID colIDcount;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    DWORD i, j;

    ASSERT(sesID != ~0);
    ASSERT(dbID  != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetCreateTable(sesID, dbID, tblName,
        TABLE_PAGES, TABLE_DENSITY, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCreateTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }
    DPRINTF((_T("JetCreateTable: tblID=%lu colIDs={"), *tblID));

    columnDef.cbStruct = sizeof(JET_COLUMNDEF);
    columnDef.wCountry = COUNTRY_CODE;
    columnDef.langid   = LANG_ID;
    columnDef.cp       = CODE_PAGE;
    columnDef.wCollate = COLLATE;
    colIDcount         = 1;

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        columnDef.columnid = colIDcount;
        columnDef.coltyp   = columnSpec->coltyp;
        columnDef.cbMax    = columnSpec->size;
        columnDef.grbit    = columnSpec->grbit;

        jetErr = JetAddColumn(sesID, *tblID, columnSpec->name,
            &columnDef, NULL, 0, &columnIDs[i]);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("\nJetAddColumn: jetErr=%ld\n"), jetErr));
            return FALSE;
        }

        DPRINTF((_T(" %lu"), columnIDs[i]));

        if (i+1 < numColumns && colIDcount == columnIDs[i]) {
            ColIDCollision:
            colIDcount++;
            for (j = 0; j < i; j++)
                if (colIDcount == columnIDs[j])
                    goto ColIDCollision;
        }
    }

    DPRINTF((_T(" }\n")));
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CreateIndex(
    JET_TABLEID  tblID,
    const CHAR  *keyName,
    DWORD        numKeys,
    ColumnSpec **keyColumnSpecs)
{
    JET_ERR jetErr;

    CHAR indexStr[MAX_PATH];

    ColumnSpec *keyColumnSpec;

    DWORD indexStrLen,
          i;

    ASSERT(sesID   != ~0);
    ASSERT(numKeys <= MAX_KEYS);

    indexStrLen = 0;

    for (i = 0; i < numKeys; i++) {
        keyColumnSpec = keyColumnSpecs[i];
        indexStr[indexStrLen++] = '+';
        strcpy(indexStr + indexStrLen, keyColumnSpec->name);
        indexStrLen += strlen(keyColumnSpec->name) + 1;
    }

    indexStr[indexStrLen++] = '\0';

    jetErr = JetCreateIndex(sesID, tblID, keyName, 0,
        indexStr, indexStrLen, TABLE_DENSITY);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCreateIndex: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::OpenTable(
    const CHAR   *tblName,
    DWORD         numColumns,
    ColumnSpec  **columnSpecs,
    JET_COLUMNID *columnIDs,
    JET_TABLEID  *tblID)
{
    JET_COLUMNDEF columnDef;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    DWORD i;

    ASSERT(sesID != ~0);
    ASSERT(dbID  != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetOpenTable(sesID, dbID, tblName, NULL, 0, 0, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetOpenTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }
    DPRINTF((_T("JetOpenTable: tblID=%lu colIDs={"), *tblID));

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        jetErr = JetGetTableColumnInfo(sesID, *tblID, columnSpec->name,
            &columnDef, sizeof(JET_COLUMNDEF), JET_ColInfo);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("\nJetGetTableColumnInfo: jetErr=%ld\n"), jetErr));
            return FALSE;
        }
        columnIDs[i] = columnDef.columnid;
        DPRINTF((_T(" %lu"), columnIDs[i]));
    }

    DPRINTF((_T(" }\n")));
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CloseTable(JET_TABLEID tblID)
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);
    ASSERT(tblID != ~0);

    jetErr = JetCloseTable(sesID, tblID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCloseTable: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursor(
    JET_TABLEID  tblID,
    const CHAR  *keyName,
    const VOID  *entry,
    DWORD        numKeys,
    ColumnSpec **keyColumnSpecs) const
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *keyColumnSpec;

    const BYTE *dataPtr[MAX_KEYS];

    DWORD cbData[MAX_KEYS],
          i;

    ASSERT(sesID   != ~0);
    ASSERT(numKeys <= MAX_KEYS);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    for (i = 0; i < numKeys; i++) {
        keyColumnSpec = keyColumnSpecs[i];
        coltyp = keyColumnSpec->coltyp;
        dataPtr[i] = (const BYTE *)entry + keyColumnSpec->offset;

        if (coltyp == JET_coltypBinary) {
            dataPtr[i] = *(BYTE **)dataPtr[i];
            ASSERT(dataPtr[i] != NULL);
            cbData[i] = (_tcslen((const TCHAR *)dataPtr[i]) + 1) * sizeof(TCHAR);
        } else
            cbData[i] = keyColumnSpec->size;

        jetErr = JetMakeKey(sesID, tblID, dataPtr[i], cbData[i],
            i == 0 ? JET_bitNewKey : 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetMakeKey: jetErr=%ld\n"), jetErr));
            return -1;
        }
    }

    jetErr = JetSeek(sesID, tblID, JET_bitSeekEQ);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errRecordNotFound)
            return 0;
        DPRINTF((_T("JetSeek: jetErr=%ld\n"), jetErr));
        return -1;
    }

    for (i = 0; i < numKeys; i++) {
        jetErr = JetMakeKey(sesID, tblID, dataPtr[i], cbData[i],
            i == 0 ? JET_bitNewKey : 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetMakeKey: jetErr=%ld\n"), jetErr));
            return -1;
        }
    }

    jetErr = JetSetIndexRange(sesID, tblID,
        JET_bitRangeUpperLimit | JET_bitRangeInclusive);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetIndexRange: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorFirst(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    jetErr = JetMove(sesID, tblID, JET_MoveFirst, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorNext(JET_TABLEID tblID) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetMove(sesID, tblID, JET_MoveNext, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::PositionCursorLast(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;

    ASSERT(sesID != ~0);

    jetErr = JetSetCurrentIndex(sesID, tblID, keyName);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetSetCurrentIndex: jetErr=%ld\n"), jetErr));
        return -1;
    }

    jetErr = JetMove(sesID, tblID, JET_MoveLast, 0);
    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetMove: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return 1;
}

/*****************************************************************************/

BOOL SGDatabase::PutData(
    JET_TABLEID         tblID,
    const VOID         *entry,
    DWORD               numColumns,
    ColumnSpec        **columnSpecs,
    const JET_COLUMNID *columnIDs)
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    const BYTE *dataPtr;

    DWORD cbData,
          i;

    ASSERT(sesID != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

    jetErr = JetPrepareUpdate(sesID, tblID, JET_prepInsert);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetPrepareUpdate: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    for (i = 0; i < numColumns; i++) {
        columnSpec = columnSpecs[i];
        coltyp     = columnSpec->coltyp;

        if (columnSpec->grbit != JET_bitColumnAutoincrement) {
            dataPtr = (const BYTE *)entry + columnSpec->offset;
            if (coltyp == JET_coltypBinary
             || coltyp == JET_coltypLongBinary) {
                dataPtr = *(BYTE **)dataPtr;
                cbData  = dataPtr != NULL
                        ? (_tcslen((const TCHAR *)dataPtr) + 1) * sizeof(TCHAR)
                        : 0;
            } else
                cbData  = columnSpec->size;

// May want to convert to JetSetColumns

            jetErr = JetSetColumn(sesID, tblID, columnIDs[i],
                dataPtr, cbData, 0, NULL);
            if (jetErr != JET_errSuccess) {
                DPRINTF((_T("JetSetColumn: jetErr=%ld\n"), jetErr));
                return FALSE;
            }
        }
    }

    jetErr = JetUpdate(sesID, tblID, NULL, 0, NULL);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetUpdate: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::RetrieveData(
    JET_TABLEID         tblID,
    VOID               *entry,
    DWORD               numColumns,
    ColumnSpec        **columnSpecs,
    const JET_COLUMNID *columnIDs,
    DWORD               includeMask) const
{
    JET_COLTYP coltyp;

    JET_ERR jetErr;

    ColumnSpec *columnSpec;

    BYTE *dataPtr;

    DWORD cbData,
          cbActual,
          i;

    BOOL varCol;

    ASSERT(sesID != ~0);

    ASSERT(numColumns <= MAX_COLUMNS);

// May want to convert to JetRetrieveColumns

    for (i = 0; i < numColumns; i++)
        if ((includeMask & (1U << i)) != 0) {
            columnSpec = columnSpecs[i];
            coltyp = columnSpec->coltyp;
            varCol = coltyp == JET_coltypBinary
                  || coltyp == JET_coltypLongBinary;

            dataPtr = (BYTE *)entry + columnSpec->offset;
            if (varCol)
                dataPtr = *(BYTE **)dataPtr;

            if (dataPtr != NULL) {
                jetErr = JetRetrieveColumn(sesID, tblID, columnIDs[i],
                    dataPtr, columnSpec->size, &cbActual, 0, NULL);

                if (jetErr == JET_errSuccess)
                    cbData = varCol
                           ? (_tcslen((TCHAR *)dataPtr) + 1) * sizeof(TCHAR)
                           : columnSpec->size;
                else if (varCol && jetErr == JET_wrnColumnNull) {
                    *(TCHAR *)dataPtr = _T('\0');
                    cbData = 0;
                } else {
                    DPRINTF((_T("JetRetrieveColumn: jetErr=%ld\n"), jetErr));
                    return FALSE;
                }

                if (cbActual != cbData) {
                    DPRINTF((_T("JetRetrieveColumn: cbActual=%lu!=%lu\n"),
                        cbActual, cbData));
                    return FALSE;
                }
            }
        }

    return TRUE;
}

/*****************************************************************************/

LONG SGDatabase::Delete(JET_TABLEID tblID)
{
    JET_ERR jetErr;

    LONG count,
         status;

    count = 0;

    ASSERT(sesID != ~0);

    while (TRUE) {
        jetErr = JetDelete(sesID, tblID);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetDelete: jetErr=%ld\n"), jetErr));
            return -1;
        }

        count++;

        status = PositionCursorNext(tblID);
        if (status <  0)
            return status;
        if (status == 0)
            return count;
    }
}

/*****************************************************************************/

LONG SGDatabase::Count(
    JET_TABLEID tblID,
    const CHAR *keyName) const
{
    JET_ERR jetErr;
    LONG    count,
            status;

    count = 0;

    status = PositionCursorFirst(tblID, keyName);

    if (status <  0)
        return status;
    if (status == 0)
        return 0;

    ASSERT(sesID != ~0);

    jetErr = JetIndexRecordCount(sesID, tblID, (ULONG *) &count, MAXLONG);

    if (jetErr != JET_errSuccess) {
        if (jetErr == JET_errNoCurrentRecord)
            return 0;
        DPRINTF((_T("JetIndexRecordCount: jetErr=%ld\n"), jetErr));
        return -1;
    }

    return count;
}

/*****************************************************************************/
/********************** SGDatabase class public methods **********************/
/*****************************************************************************/

SGDatabase::SGDatabase()
{
    fileName = NULL;

    sesID   =
    tableID =
    queueID =
    stackID =
    listID  = ~0U;
    dbID    = ~0U;

    numTableEntries =
    numQueueEntries =
    numStackEntries =
    numListEntries  = 0;

    numUncommittedTableEntries =
    numUncommittedQueueEntries =
    numUncommittedStackEntries =
    numUncommittedListEntries  = 0;

    inTransaction = FALSE;

    if (!jetInitialized)
        InitializeEngine();

    numInstances++;
}

/*****************************************************************************/

SGDatabase::~SGDatabase()
{
    Close();

    ASSERT(fileName == NULL);

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    if (--numInstances == 0 && jetInitialized) {
        TerminateEngine();
    }
}

/*****************************************************************************/

BOOL SGDatabase::Create(const TCHAR *dbName)
{
    CHAR szConnect[MAX_PATH];

    DWORD strLen1,
          strLen2;

    JET_ERR jetErr;

    ASSERT(fileName == NULL);

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    if (!jetInitialized && !InitializeEngine())
        return FALSE;
    ASSERT(jetInitialized);

    jetErr = JetBeginSession(instance, &sesID, USERNAME, PASSWORD);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginSession: jetErr=%ld\n"), jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("JetBeginSession: sesID=%lu\n"), sesID));

    ASSERT(fileName == NULL);
    strLen1 = _tcslen(dbName);
    fileName = new CHAR[strLen1+1];
    ASSERT(fileName != NULL);

#ifdef _UNICODE
    strLen2 = sprintf(fileName, "%S", dbName);
#else
    strLen2 = sprintf(fileName, "%s", dbName);
#endif
    ASSERT(strLen1 == strLen2);

    sprintf(szConnect, ";COUNTRY=%u;LANGID=0x%04x;CP=%u",
        COUNTRY_CODE, LANG_ID, CODE_PAGE);

    //
    //  Create the database
    //

    jetErr = JetCreateDatabase(sesID, fileName, szConnect, &dbID, 0);
    if (jetErr == JET_errSuccess) {
        DPRINTF((_T("JetCreateDatabase(\"%s\"): dbID=%lu\n"),dbName, dbID));
    } else {
        if (jetErr != JET_errDatabaseDuplicate) {
            DPRINTF((_T("JetCreateDatabase(\"%s\"): jetErr=%ld\n"),
                dbName, jetErr));
            Close();
            return FALSE;
        }

        if (!DeleteFile(dbName)) {
            DPRINTF((_T("JetCreateDatabase: \"%s\" already exists and can't be deleted: %lu\n"),
                dbName, GetLastError()));
            Close();
            return FALSE;
        }

        jetErr = JetCreateDatabase(sesID, fileName, szConnect, &dbID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetCreateDatabase: deleted old \"%s\"; jetErr=%ld\n"),
                dbName, jetErr));
            Close();
            return FALSE;
        }

        DPRINTF((_T("JetCreateDatabase: deleted old \"%s\"; new dbID=%lu\n"),
            dbName, dbID));
    }

    if (!CreateTable(TABLE_NAME, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs, &tableID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(tableID, TABLE_KEY_NAME_FILE_ID,
        TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID)
     || !CreateIndex(tableID, TABLE_KEY_NAME_ATTR,
        TABLE_KEY_NCOLS_ATTR, tableKeyAttr)
     || !CreateIndex(tableID, TABLE_KEY_NAME_CSID,
        TABLE_KEY_NCOLS_CSID, tableKeyCSID)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(QUEUE_NAME, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, &queueID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(queueID, QUEUE_KEY_NAME_READY_TIME,
        QUEUE_KEY_NCOLS_READY_TIME, queueKeyReadyTime)
     || !CreateIndex(queueID, QUEUE_KEY_NAME_FILE_ID,
        QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID)
     || !CreateIndex(queueID, QUEUE_KEY_NAME_ORDER,
        QUEUE_KEY_NCOLS_ORDER, queueKeyOrder)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(STACK_NAME, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, &stackID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(stackID, STACK_KEY_NAME_FILE_ID,
        STACK_KEY_NCOLS_FILE_ID, stackKeyFileID)
     || !CreateIndex(stackID, STACK_KEY_NAME_ORDER,
        STACK_KEY_NCOLS_ORDER, stackKeyOrder)) {
        Close();
        return FALSE;
    }

    if (!CreateTable(LIST_NAME, LIST_NCOLS,
        listColumnSpecs, listColumnIDs, &listID)) {
        Close();
        return FALSE;
    }

    if (!CreateIndex(listID, LIST_KEY_NAME_NAME,
        LIST_KEY_NCOLS_NAME, listKeyName)) {
        Close();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::Open(const TCHAR *dbName, BOOL is_log_drive)
{
    SGNativeStackEntry stackEntry;

    JET_ERR jetErr;

    DWORD strLen1;
#ifdef _UNICODE
    DWORD strLen2;
#endif

    LONG status;

    ASSERT(sesID   == ~0U);
    ASSERT(dbID    == ~0U);
    ASSERT(tableID == ~0U);
    ASSERT(queueID == ~0U);
    ASSERT(stackID == ~0U);
    ASSERT(listID  == ~0U);

    ASSERT(numTableEntries == 0);
    ASSERT(numQueueEntries == 0);
    ASSERT(numStackEntries == 0);
    ASSERT(numListEntries  == 0);

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    ASSERT(!inTransaction);

    // If this isn't the log drive, delete any log files that may exist
    // from a previous run.  This is an abnormal condition that can arise
    // when the log drive is changing because of problems detected during
    // a previous startup.

    if (!is_log_drive) {
        WIN32_FIND_DATA findData;
        HANDLE fHandle;
        BOOL success;
        TFileName fName,
                  delName;

        delName.assign(logDir);
        delName.append(_T("\\"));
        delName.append(DATABASE_DELETE_LOG_FILE_NAME);

        fHandle = FindFirstFile(delName.name, &findData);

        if (fHandle != INVALID_HANDLE_VALUE) {
            do {
                if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                    success = GetParentName(delName.name, &fName);
                    ASSERT(success);      // internal error if failed

                    fName.append(_T("\\"));
                    fName.append(findData.cFileName);

                    if (!DeleteFile(fName.name)) {
                        DPRINTF((_T("SGDatabase::Open: can't delete \"%s\", %d\n"), delName.name, GetLastError()));
					}
                }
            } while (FindNextFile(fHandle, &findData));

            success = FindClose(fHandle);
            ASSERT(success);
            fHandle = NULL;
        }
    }

    if (!jetInitialized && !InitializeEngine()) {
        Close();
        return FALSE;
    }
    ASSERT(jetInitialized);

    jetErr = JetBeginSession(instance, &sesID, USERNAME, PASSWORD);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginSession: jetErr=%ld\n"), jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("JetBeginSession: sesID=%lu\n"), sesID));

    ASSERT(fileName == NULL);
    strLen1 = _tcslen(dbName);
    fileName = new CHAR[strLen1 + 1];
    ASSERT(fileName != NULL);

#ifdef _UNICODE
    strLen2 = sprintf(fileName, "%S", dbName);
#else
    strLen2 = sprintf(fileName, "%s", dbName);
#endif
    ASSERT(strLen1 == strLen2);

    //
    //  Open the database
    //

    jetErr = JetAttachDatabase(sesID, fileName, 0);
    if (jetErr != JET_errSuccess && jetErr != JET_wrnDatabaseAttached) {
        if (jetErr == JET_errFileNotFound) {
            DPRINTF((_T("JetAttachDatabase: \"%s\" not found\n"), dbName));
        } else {
            DPRINTF((_T("JetAttachDatabase(\"%s\"): jetErr=%ld\n"),
                dbName, jetErr));
        }
        Close();
        return FALSE;
    }

    jetErr = JetOpenDatabase(sesID, fileName, NULL, &dbID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetOpenDatabase(\"%s\"): jetErr=%ld\n"), dbName, jetErr));
        Close();
        return FALSE;
    }
    DPRINTF((_T("JetOpenDatabase(\"%s\"): dbID=%lu\n"), dbName, dbID));

    if (!OpenTable(TABLE_NAME, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, &tableID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(QUEUE_NAME, QUEUE_NCOLS, queueColumnSpecs,
        queueColumnIDs, &queueID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(STACK_NAME, STACK_NCOLS, stackColumnSpecs,
        stackColumnIDs, &stackID)) {
        Close();
        return FALSE;
    }

    if (!OpenTable(LIST_NAME, LIST_NCOLS, listColumnSpecs,
        listColumnIDs, &listID)) {
        Close();
        return FALSE;
    }

    if ((numTableEntries = Count(tableID, TABLE_KEY_NAME_FILE_ID))    < 0
     || (numQueueEntries = Count(queueID, QUEUE_KEY_NAME_READY_TIME)) < 0
     || (numStackEntries = Count(stackID, STACK_KEY_NAME_FILE_ID))    < 0
     || (numListEntries  = Count(listID,  LIST_KEY_NAME_NAME))        < 0) {
        Close();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::Close()
{
    JET_ERR jetErr;
    int strLen;
    BOOL success = TRUE;

    if (inTransaction) {
        success = CommitTransaction();
        inTransaction = FALSE;
    }

    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    if (tableID != ~0U) {
        if (!CloseTable(tableID))
            success = FALSE;
        tableID = ~0U;
    }

    if (queueID != ~0U) {
        if (!CloseTable(queueID))
            success = FALSE;
        queueID = ~0U;
    }

    if (stackID != ~0U) {
        if (!CloseTable(stackID))
            success = FALSE;
        stackID = ~0U;
    }

    if (listID != ~0U) {
        if (!CloseTable(listID))
            success = FALSE;
        listID = ~0U;
    }

    if (dbID != ~0U) {
        ASSERT(fileName != NULL);
        ASSERT(sesID    != ~0U);

        jetErr = JetCloseDatabase(sesID, dbID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetCloseDatabase: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }

        jetErr = JetDetachDatabase(sesID, fileName);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetDetachDatabase: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }

        dbID = ~0U;
    }

    if (sesID != ~0U) {
        jetErr = JetEndSession(sesID, 0);
        if (jetErr != JET_errSuccess) {
            DPRINTF((_T("JetEndSession: jetErr=%ld\n"), jetErr));
            success = FALSE;
        }
        sesID = ~0U;
    }

    if (fileName != NULL) {
        delete[] fileName;
        fileName = NULL;
    }

    numTableEntries =
    numQueueEntries =
    numStackEntries =
    numListEntries  = 0;

    return success;
}

/*****************************************************************************/

BOOL SGDatabase::BeginTransaction()
{
    JET_ERR jetErr;

    ASSERT(!inTransaction);
    ASSERT(numUncommittedTableEntries == 0);
    ASSERT(numUncommittedQueueEntries == 0);
    ASSERT(numUncommittedStackEntries == 0);
    ASSERT(numUncommittedListEntries  == 0);

    if (sesID == ~0U)
        return -1;

    jetErr = JetBeginTransaction(sesID);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetBeginTransaction: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    inTransaction = TRUE;
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::CommitTransaction()
{
    JET_ERR jetErr;

    ASSERT(inTransaction);

    if (sesID == ~0U)
        return -1;

    jetErr = JetCommitTransaction(sesID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetCommitTransaction: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    numTableEntries += numUncommittedTableEntries;
    numQueueEntries += numUncommittedQueueEntries;
    numStackEntries += numUncommittedStackEntries;
    numListEntries  += numUncommittedListEntries;

    numUncommittedTableEntries = 0;
    numUncommittedQueueEntries = 0;
    numUncommittedStackEntries = 0;
    numUncommittedListEntries  = 0;

    inTransaction = FALSE;
    return TRUE;
}

/*****************************************************************************/

BOOL SGDatabase::AbortTransaction()
{
    JET_ERR jetErr;

    ASSERT(inTransaction);
    inTransaction = FALSE;

    if (sesID == ~0U)
        return -1;

    jetErr = JetRollback(sesID, 0);
    if (jetErr != JET_errSuccess) {
        DPRINTF((_T("JetRollback: jetErr=%ld\n"), jetErr));
        return FALSE;
    }

    numUncommittedTableEntries = 0;
    numUncommittedQueueEntries = 0;
    numUncommittedStackEntries = 0;
    numUncommittedListEntries  = 0;

    return TRUE;
}

/******************************* Table methods *******************************/

LONG SGDatabase::TablePut(const SGNativeTableEntry *entry)
{
    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(tableID, entry, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByFileID(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_FILE_ID,
        entry, TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_FILE_ID_MASK ) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByAttr(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_ATTR,
        entry, TABLE_KEY_NCOLS_ATTR, tableKeyAttr);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_ATTR_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetFirstByCSIndex(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursor(tableID, TABLE_KEY_NAME_CSID,
        entry, TABLE_KEY_NCOLS_CSID, tableKeyCSID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS, tableColumnSpecs,
        tableColumnIDs, TABLE_EXCLUDE_CS_INDEX_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableGetNext(SGNativeTableEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    status = PositionCursorNext(tableID);
    if (status <= 0)
        return status;

    return RetrieveData(tableID, entry, TABLE_NCOLS,
        tableColumnSpecs, tableColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::TableDeleteByFileID(DWORDLONG fileID)
{
    SGNativeTableEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(tableID, TABLE_KEY_NAME_FILE_ID,
        &entry, TABLE_KEY_NCOLS_FILE_ID, tableKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(tableID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::TableDeleteByCSIndex(const CSID *csIndex)
{
    SGNativeTableEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(csIndex != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    entry.csIndex = *csIndex;
    status = PositionCursor(tableID, TABLE_KEY_NAME_CSID,
        &entry, TABLE_KEY_NCOLS_CSID, tableKeyCSID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(tableID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedTableEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::TableCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || tableID == ~0U)
        return -1;

    numEntries = numTableEntries + numUncommittedTableEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(tableID, TABLE_KEY_NAME_FILE_ID) == numEntries);

    return numEntries;
}

/******************************* Queue methods *******************************/

LONG SGDatabase::QueuePut(SGNativeQueueEntry *entry)
{
    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetFirst(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursorFirst(queueID, QUEUE_KEY_NAME_READY_TIME);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetFirstByFileID(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursor(queueID, QUEUE_KEY_NAME_FILE_ID,
        entry, QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS, queueColumnSpecs,
        queueColumnIDs, QUEUE_EXCLUDE_FILE_ID_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueGetNext(SGNativeQueueEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    status = PositionCursorNext(queueID);
    if (status <= 0)
        return status;

    return RetrieveData(queueID, entry, QUEUE_NCOLS,
        queueColumnSpecs, queueColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::QueueDelete(DWORD order)
{
    SGNativeQueueEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(sesID   != ~0U);
    ASSERT(dbID    != ~0U);
    ASSERT(queueID != ~0U);

    entry.order = order;
    status = PositionCursor(queueID, QUEUE_KEY_NAME_ORDER,
        &entry, QUEUE_KEY_NCOLS_ORDER, queueKeyOrder);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(queueID);
    ASSERT(status <= 1);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::QueueDeleteByFileID(DWORDLONG fileID)
{
    SGNativeQueueEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(queueID, QUEUE_KEY_NAME_FILE_ID,
        &entry, QUEUE_KEY_NCOLS_FILE_ID, queueKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(queueID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedQueueEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::QueueCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || queueID == ~0U)
        return -1;

    numEntries = numQueueEntries + numUncommittedQueueEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(queueID, QUEUE_KEY_NAME_READY_TIME) == numEntries);

    return numEntries;
}

/******************************* Stack methods *******************************/

LONG SGDatabase::StackPut(DWORDLONG fileID, BOOL done)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    if (done)
        entry.order = 0;
    else {
        status = PositionCursorLast(stackID, STACK_KEY_NAME_ORDER);
        if (status < 0)
            return -1;
        if (status == 0)
            entry.order = 1;
        else {
            if (!RetrieveData(stackID, &entry, STACK_NCOLS,
                stackColumnSpecs, stackColumnIDs, STACK_GET_ORDER_ONLY_MASK))
                return -1;
            entry.order++;
        }
    }

    entry.fileID = fileID;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    if (!PutData(stackID, &entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetTop(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursorLast(stackID, STACK_KEY_NAME_ORDER);
    if (status <= 0)
        return status;

    status = RetrieveData(stackID, entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, GET_ALL_MASK);
    if (status < 0)
        return status;
    ASSERT(status == 1);

    return entry->order == 0 ? 0 : 1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetFirstByFileID(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursor(stackID, STACK_KEY_NAME_FILE_ID,
        entry, STACK_KEY_NCOLS_FILE_ID, stackKeyFileID);
    if (status <= 0)
        return status;

    return RetrieveData(stackID, entry, STACK_NCOLS, stackColumnSpecs,
        stackColumnIDs, STACK_EXCLUDE_FILE_ID_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::StackGetNext(SGNativeStackEntry *entry) const
{
    LONG status;

    ASSERT(entry != NULL);

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    status = PositionCursorNext(stackID);
    if (status <= 0)
        return status;

    return RetrieveData(stackID, entry, STACK_NCOLS,
        stackColumnSpecs, stackColumnIDs, GET_ALL_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::StackDelete(DWORD order)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    entry.order = order;
    status = PositionCursor(stackID, STACK_KEY_NAME_ORDER,
        &entry, STACK_KEY_NCOLS_ORDER, stackKeyOrder);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(stackID);
    ASSERT(order == 0 || status <= 1);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::StackDeleteByFileID(DWORDLONG fileID)
{
    SGNativeStackEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    entry.fileID = fileID;
    status = PositionCursor(stackID, STACK_KEY_NAME_FILE_ID,
        &entry, STACK_KEY_NCOLS_FILE_ID, stackKeyFileID);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(stackID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    numUncommittedStackEntries -= status;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return status;
}

/*****************************************************************************/

LONG SGDatabase::StackCount() const
{
    LONG numEntries;

    if (sesID   == ~0U
     || dbID    == ~0U
     || stackID == ~0U)
        return -1;

    numEntries = numStackEntries + numUncommittedStackEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(stackID, STACK_KEY_NAME_ORDER) == numEntries);

    return numEntries;
}

/******************************* List methods ********************************/

LONG SGDatabase::ListWrite(const SGNativeListEntry *entry)
{
    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(entry       != NULL);
    ASSERT(entry->name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

// May want to overwrite the entry directly instead of deleting and inserting

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = ListDelete(entry->name);
    ASSERT(status <= 1);
    if (status < 0
     || !PutData(listID, entry, LIST_NCOLS,
            listColumnSpecs, listColumnIDs)) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    if (status == 0)
        numUncommittedListEntries++;

    if (!alreadyInTransaction && !CommitTransaction())
        return -1;

    return 1;
}

/*****************************************************************************/

LONG SGDatabase::ListRead(SGNativeListEntry *entry) const
{
    LONG status;

    ASSERT(entry       != NULL);
    ASSERT(entry->name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    status = PositionCursor(listID, LIST_KEY_NAME_NAME,
        entry, LIST_KEY_NCOLS_NAME, listKeyName);
    if (status <= 0)
        return status;

    return RetrieveData(listID, entry, LIST_NCOLS, listColumnSpecs,
        listColumnIDs, LIST_EXCLUDE_NAME_MASK) ? 1 : -1;
}

/*****************************************************************************/

LONG SGDatabase::ListDelete(const TCHAR *name)
{
    SGNativeListEntry entry;

    LONG status;

    BOOL alreadyInTransaction = inTransaction;

    ASSERT(name != NULL);

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    entry.name  = name;
    entry.value = NULL;

    status = PositionCursor(listID, LIST_KEY_NAME_NAME,
        &entry, LIST_KEY_NCOLS_NAME, listKeyName);
    if (status <= 0)
        return status;

    if (!inTransaction && !BeginTransaction())
        return -1;

    ASSERT(inTransaction);

    status = Delete(listID);
    if (status < 0) {
        if (!alreadyInTransaction)
            AbortTransaction();
        return -1;
    }

    return status;
}

/*****************************************************************************/

LONG SGDatabase::ListCount() const
{
    LONG numEntries;

    if (sesID  == ~0U
     || dbID   == ~0U
     || listID == ~0U)
        return -1;

    numEntries = numListEntries + numUncommittedListEntries;

    ASSERT(numEntries >= 0);
    ASSERT(Count(listID, LIST_KEY_NAME_NAME) == numEntries);

    return numEntries;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\database.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	database.h

Abstract:

	SIS Groveler Jet-Blue database include file

Authors:

	Cedric Krumbein, 1998

Environment:

	User Mode


Revision History:

--*/

#define USERNAME ""
#define PASSWORD ""

#define TABLE_PAGES    50
#define TABLE_DENSITY  50
#define MIN_VER_PAGES 128
#define	MAX_DATABASE_CACHE_SIZE (6*1024*1024)

#define COUNTRY_CODE      1
#define LANG_ID      0x0409
#define CODE_PAGE      1252
#define COLLATE           0

#define MAX_KEYS            3
#define MAX_COLUMNS         8
#define MAX_LIST_NAME_LEN 255

#define GET_ALL_MASK (~0U)

typedef struct {
	CHAR      *name;
	DWORD      size;
	DWORD      offset;
	JET_COLTYP coltyp;
	JET_GRBIT  grbit;
} ColumnSpec;

/***************************** Table parameters ******************************/

#define TABLE_NAME "SGTable"

typedef DWORDLONG Signature;
typedef GUID      CSID;

typedef struct _SGNativeTableEntry {
	DWORDLONG fileID;
	DWORDLONG fileSize;
	Signature signature;
	DWORD     attributes;
	CSID      csIndex;
	DWORDLONG createTime;
	DWORDLONG writeTime;
} SGNativeTableEntry;

#define TABLE_COL_NUM_FILE_ID 0
#define TABLE_COL_NUM_SIZE    1
#define TABLE_COL_NUM_SIG     2
#define TABLE_COL_NUM_ATTR    3
#define TABLE_COL_NUM_CSIDLO  4
#define TABLE_COL_NUM_CSIDHI  5
#define TABLE_COL_NUM_CR_TIME 6
#define TABLE_COL_NUM_WR_TIME 7
#define TABLE_NCOLS           8

#define TABLE_COL_NAME_FILE_ID "FileID"
#define TABLE_COL_NAME_SIZE    "FileSize"
#define TABLE_COL_NAME_SIG     "Signature"
#define TABLE_COL_NAME_ATTR    "Attributes"
#define TABLE_COL_NAME_CSIDLO  "CSIndexLo"
#define TABLE_COL_NAME_CSIDHI  "CSIndexHi"
#define TABLE_COL_NAME_CR_TIME "CreateTime"
#define TABLE_COL_NAME_WR_TIME "WriteTime"

#define TABLE_KEY_NAME_FILE_ID "FileIDKey"
#define TABLE_KEY_NAME_ATTR    "AttributeKey"
#define TABLE_KEY_NAME_CSID    "CSIndexKey"

#define TABLE_KEY_NCOLS_FILE_ID 1
#define TABLE_KEY_NCOLS_ATTR    3
#define TABLE_KEY_NCOLS_CSID    2

#define TABLE_EXCLUDE_FILE_ID_MASK \
	(~(1U << TABLE_COL_NUM_FILE_ID))

#define TABLE_EXCLUDE_ATTR_MASK \
	(~(1U << TABLE_COL_NUM_SIZE \
	 | 1U << TABLE_COL_NUM_SIG  \
	 | 1U << TABLE_COL_NUM_ATTR))

#define TABLE_EXCLUDE_CS_INDEX_MASK \
	(~(1U << TABLE_COL_NUM_CSIDLO  \
	 | 1U << TABLE_COL_NUM_CSIDHI))

static ColumnSpec
	tableColDefFileID = {
		TABLE_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, fileID),
		JET_coltypCurrency,
		0
	},
	tableColDefSize = {
		TABLE_COL_NAME_SIZE,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, fileSize),
		JET_coltypCurrency,
		0
	},
	tableColDefSig = {
		TABLE_COL_NAME_SIG,
		sizeof(Signature),
		offsetof(SGNativeTableEntry, signature),
		JET_coltypCurrency,
		0
	},
	tableColDefAttr = {
		TABLE_COL_NAME_ATTR,
		sizeof(DWORD),
		offsetof(SGNativeTableEntry, attributes),
		JET_coltypLong,
		0
	},
	tableColDefCSIDlo = {
		TABLE_COL_NAME_CSIDLO,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, csIndex),
		JET_coltypCurrency,
		0
	},
	tableColDefCSIDhi = {
		TABLE_COL_NAME_CSIDHI,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, csIndex) + sizeof(DWORDLONG),
		JET_coltypCurrency,
		0
	},
	tableColDefCrTime = {
		TABLE_COL_NAME_CR_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, createTime),
		JET_coltypCurrency,
		0
	},
	tableColDefWrTime = {
		TABLE_COL_NAME_WR_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeTableEntry, writeTime),
		JET_coltypCurrency,
		0
	},
	*tableColumnSpecs[TABLE_NCOLS] = {
		&tableColDefFileID,
		&tableColDefSize,
		&tableColDefSig,
		&tableColDefAttr,
		&tableColDefCSIDlo,
		&tableColDefCSIDhi,
		&tableColDefCrTime,
		&tableColDefWrTime
	},
	*tableKeyFileID[TABLE_KEY_NCOLS_FILE_ID] = {
		&tableColDefFileID
	},
	*tableKeyAttr[TABLE_KEY_NCOLS_ATTR] = {
		&tableColDefSize,
		&tableColDefSig,
		&tableColDefAttr,
	},
	*tableKeyCSID[TABLE_KEY_NCOLS_CSID] = {
		&tableColDefCSIDlo,
		&tableColDefCSIDhi,
	};

/***************************** Queue parameters ******************************/

#define QUEUE_NAME "SGQueue"

typedef struct _SGNativeQueueEntry {
	DWORDLONG fileID;
	DWORDLONG parentID;
	DWORD     reason;
	DWORD     order;
	DWORDLONG readyTime;
	DWORDLONG retryTime;
	TCHAR    *fileName;
} SGNativeQueueEntry;

#define QUEUE_COL_NUM_FILE_ID    0
#define QUEUE_COL_NUM_PARENT_ID  1
#define QUEUE_COL_NUM_REASON     2
#define QUEUE_COL_NUM_ORDER      3
#define QUEUE_COL_NUM_READY_TIME 4
#define QUEUE_COL_NUM_RETRY_TIME 5
#define QUEUE_COL_NUM_NAME       6
#define QUEUE_NCOLS              7

#define QUEUE_COL_NAME_FILE_ID    "FileID"
#define QUEUE_COL_NAME_PARENT_ID  "ParentID"
#define QUEUE_COL_NAME_REASON     "Reason"
#define QUEUE_COL_NAME_ORDER      "Order"
#define QUEUE_COL_NAME_READY_TIME "ReadyTime"
#define QUEUE_COL_NAME_RETRY_TIME "RetryTime"
#define QUEUE_COL_NAME_NAME       "FileName"

#define QUEUE_KEY_NAME_READY_TIME "ReadyTimeKey"
#define QUEUE_KEY_NAME_FILE_ID    "FileIDKey"
#define QUEUE_KEY_NAME_ORDER      "Order"

#define QUEUE_KEY_NCOLS_READY_TIME 1
#define QUEUE_KEY_NCOLS_FILE_ID    1
#define QUEUE_KEY_NCOLS_ORDER      1

#define QUEUE_EXCLUDE_FILE_ID_MASK \
	(~(1U << QUEUE_COL_NUM_FILE_ID))

static ColumnSpec
	queueColDefFileID = {
		QUEUE_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, fileID),
		JET_coltypCurrency,
		0
	},
	queueColDefParentID = {
		QUEUE_COL_NAME_PARENT_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, parentID),
		JET_coltypCurrency,
		0
	},
	queueColDefReason = {
		QUEUE_COL_NAME_REASON,
		sizeof(DWORD),
		offsetof(SGNativeQueueEntry, reason),
		JET_coltypLong,
		0
	},
	queueColDefOrder = {
		QUEUE_COL_NAME_ORDER,
		sizeof(DWORD),
		offsetof(SGNativeQueueEntry, order),
		JET_coltypLong,
		JET_bitColumnAutoincrement
	},
	queueColDefReadyTime = {
		QUEUE_COL_NAME_READY_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, readyTime),
		JET_coltypCurrency,
		0
	},
	queueColDefRetryTime = {
		QUEUE_COL_NAME_RETRY_TIME,
		sizeof(DWORDLONG),
		offsetof(SGNativeQueueEntry, retryTime),
		JET_coltypCurrency,
		0
	},
	queueColDefName = {
		QUEUE_COL_NAME_NAME,
		MAX_PATH * sizeof(TCHAR),
		offsetof(SGNativeQueueEntry, fileName),
		JET_coltypLongBinary,
		0
	},
	*queueColumnSpecs[QUEUE_NCOLS] = {
		&queueColDefFileID,
		&queueColDefParentID,
		&queueColDefReason,
		&queueColDefOrder,
		&queueColDefReadyTime,
		&queueColDefRetryTime,
		&queueColDefName
	},
	*queueKeyReadyTime[QUEUE_KEY_NCOLS_READY_TIME] = {
		&queueColDefReadyTime
	},
	*queueKeyFileID[QUEUE_KEY_NCOLS_FILE_ID] = {
		&queueColDefFileID
	},
	*queueKeyOrder[QUEUE_KEY_NCOLS_ORDER] = {
		&queueColDefOrder
	};

/***************************** Stack parameters ******************************/

#define STACK_NAME "SGStack"

typedef struct _SGNativeStackEntry {
	DWORDLONG fileID;
	DWORD     order;
} SGNativeStackEntry;

#define STACK_COL_NUM_FILE_ID 0
#define STACK_COL_NUM_ORDER   1
#define STACK_NCOLS           2

#define STACK_COL_NAME_FILE_ID "FileID"
#define STACK_COL_NAME_ORDER   "Order"

#define STACK_KEY_NAME_FILE_ID "FileIDKey"
#define STACK_KEY_NAME_ORDER   "Order"

#define STACK_KEY_NCOLS_FILE_ID 1
#define STACK_KEY_NCOLS_ORDER   1

#define STACK_EXCLUDE_FILE_ID_MASK \
	(~(1U << STACK_COL_NUM_FILE_ID))

#define STACK_GET_ORDER_ONLY_MASK \
	  (1U << STACK_COL_NUM_ORDER)

static ColumnSpec
	stackColDefFileID = {
		STACK_COL_NAME_FILE_ID,
		sizeof(DWORDLONG),
		offsetof(SGNativeStackEntry, fileID),
		JET_coltypCurrency,
		0
	},
	stackColDefOrder = {
		STACK_COL_NAME_ORDER,
		sizeof(DWORD),
		offsetof(SGNativeStackEntry, order),
		JET_coltypLong,
		0
	},
	*stackColumnSpecs[STACK_NCOLS] = {
		&stackColDefFileID,
		&stackColDefOrder
	},
	*stackKeyFileID[STACK_KEY_NCOLS_FILE_ID] = {
		&stackColDefFileID
	},
	*stackKeyOrder[STACK_KEY_NCOLS_ORDER] = {
		&stackColDefOrder
	};

/****************************** List parameters ******************************/

#define LIST_NAME "SGList"

typedef struct _SGNativeListEntry {
	const TCHAR *name;
	TCHAR       *value;
} SGNativeListEntry;

#define LIST_COL_NUM_NAME  0
#define LIST_COL_NUM_VALUE 1
#define LIST_NCOLS         2

#define LIST_COL_NAME_NAME  "Name"
#define LIST_COL_NAME_VALUE "Value"

#define LIST_KEY_NAME_NAME "NameKey"

#define LIST_KEY_NCOLS_NAME 1

#define LIST_EXCLUDE_NAME_MASK \
	(~(1U << LIST_COL_NUM_NAME))

static ColumnSpec
	listColDefName = {
		LIST_COL_NAME_NAME,
		MAX_LIST_NAME_LEN,
		offsetof(SGNativeListEntry, name),
		JET_coltypBinary,
		0
	},
	listColDefValue = {
		LIST_COL_NAME_VALUE,
		MAX_PATH * sizeof(TCHAR),
		offsetof(SGNativeListEntry, value),
		JET_coltypLongBinary,
		0
	},
	*listColumnSpecs[LIST_NCOLS] = {
		&listColDefName,
		&listColDefValue,
	},
	*listKeyName[LIST_KEY_NCOLS_NAME] = {
		&listColDefName
	};

/************************ SGDatabase class declaration ***********************/

class SGDatabase {

private:

	static DWORD numInstances;

	static JET_INSTANCE instance;

	static BOOL jetInitialized;

    static TCHAR *logDir;

	CHAR *fileName;         // fully qualified database file name

	JET_SESID sesID;

	JET_DBID dbID;

	JET_TABLEID tableID,
	            queueID,
	            stackID,
	             listID;

	JET_COLUMNID tableColumnIDs[TABLE_NCOLS],
	             queueColumnIDs[QUEUE_NCOLS],
	             stackColumnIDs[STACK_NCOLS],
	              listColumnIDs[ LIST_NCOLS];

	LONG numTableEntries,
	     numQueueEntries,
	     numStackEntries,
	     numListEntries,
	     numUncommittedTableEntries,
	     numUncommittedQueueEntries,
	     numUncommittedStackEntries,
	     numUncommittedListEntries;

	BOOL inTransaction;

// Static methods

	static BOOL InitializeEngine();

	static BOOL TerminateEngine();

// Table / queue / stack / list methods

	BOOL CreateTable(
		const CHAR   *tblName,
		DWORD         numColumns,
		ColumnSpec  **columnSpecs,
		JET_COLUMNID *columnIDs,
		JET_TABLEID  *tblID);

	BOOL CreateIndex(
		JET_TABLEID  tblID,
		const CHAR  *keyName,
		DWORD        numKeys,
		ColumnSpec **keyColumnSpecs);

	BOOL OpenTable(
		const CHAR   *tblName,
		DWORD         numColumns,
		ColumnSpec  **columnSpecs,
		JET_COLUMNID *columnIDs,
		JET_TABLEID  *tblID);

	BOOL CloseTable(JET_TABLEID tblID);

	LONG PositionCursor(
		JET_TABLEID  tblID,
		const CHAR  *keyName,
		const VOID  *entry,
		DWORD        numKeys,
		ColumnSpec **keyColumnSpecs) const;

	LONG PositionCursorFirst(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

	LONG PositionCursorNext(JET_TABLEID tblID) const;

	LONG PositionCursorLast(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

	BOOL PutData(
		JET_TABLEID         tblID,
		const VOID         *entry,
		DWORD               numColumns,
		ColumnSpec        **columnSpecs,
		const JET_COLUMNID *columnIDs);

	BOOL SGDatabase::RetrieveData(
		JET_TABLEID         tblID,
		VOID               *entry,
		DWORD               numColumns,
		ColumnSpec        **columnSpecs,
		const JET_COLUMNID *columnIDs,
		DWORD               includeMask) const;

	LONG Delete(JET_TABLEID tblID);

	LONG Count(
		JET_TABLEID tblID,
		const CHAR *keyName) const;

public:

// General methods

	SGDatabase();

	~SGDatabase();

	BOOL Create(const TCHAR *dbName);

	BOOL Open(const TCHAR *dbName, BOOL is_log_drive);

	BOOL Close();

	BOOL BeginTransaction();

	BOOL CommitTransaction();

	BOOL AbortTransaction();

    static BOOL set_log_drive(const _TCHAR *drive_name);

// Table methods

	LONG TablePut(const SGNativeTableEntry *entry);

	LONG TableGetFirstByFileID(SGNativeTableEntry *entry) const;

	LONG TableGetFirstByAttr(SGNativeTableEntry *entry) const;

	LONG TableGetFirstByCSIndex(SGNativeTableEntry *entry) const;

	LONG TableGetNext(SGNativeTableEntry *entry) const;

	LONG TableDeleteByFileID(DWORDLONG fileID);

	LONG TableDeleteByCSIndex(const CSID *csIndex);

	LONG TableCount() const;

// Queue methods

	LONG QueuePut(SGNativeQueueEntry *entry);

	LONG QueueGetFirst(SGNativeQueueEntry *entry) const;

	LONG QueueGetFirstByFileID(SGNativeQueueEntry *entry) const;

	LONG QueueGetNext(SGNativeQueueEntry *entry) const;

	LONG QueueDelete(DWORD order);

	LONG QueueDeleteByFileID(DWORDLONG fileID);

	LONG QueueCount() const;

// Stack methods

	LONG StackPut(DWORDLONG fileID, BOOL done);

	LONG StackGetTop(SGNativeStackEntry *entry) const;

	LONG StackGetFirstByFileID(SGNativeStackEntry *entry) const;

	LONG StackGetNext(SGNativeStackEntry *entry) const;

	LONG StackDelete(DWORD order);

	LONG StackDeleteByFileID(DWORDLONG fileID);

	LONG StackCount() const;

// List methods

	LONG ListWrite(const SGNativeListEntry *entry);

	LONG ListRead(SGNativeListEntry *entry) const;

	LONG ListDelete(const TCHAR *name);

	LONG ListCount() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\decayacc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    decayacc.h

Abstract:

	SIS Groveler decaying accumulator include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_DECAYACC

#define _INC_DECAYACC

class DecayingAccumulator
{
public:

	DecayingAccumulator(
		unsigned int time_constant);

	void increment(
		int increase = 1);

	double retrieve_value() const;

private:

	double time_constant;
	double decaying_accumulation;
	unsigned int update_time;
};

#endif	/* _INC_DECAYACC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\diskinfo.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    diskinfo.cpp

Abstract:

	SIS Groveler disk information class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR *disks_ini_filename = _T("grovel.ini");
static const _TCHAR *disks_ini_section = _T("Disk Info");

ReadDiskInformation::ReadDiskInformation(
	const _TCHAR *drive_name)
{
	ASSERT(this != 0);
	EntrySpec registry_entries[registry_entry_count] =
	{
		{_T("minimum merge file size"),		entry_int,		_T("32768"),	&min_file_size},
		{_T("minimum merge file age"),		entry_int,		_T("0"),		&min_file_age},
		{_T("enable groveling"),			entry_bool,		_T("1"),		&enable_groveling},
		{_T("error retry log extraction"),	entry_bool,		_T("1"),		&error_retry_log_extraction},
		{_T("error retry groveling"),		entry_bool,		_T("1"),		&error_retry_groveling},
		{_T("merge compressed files"),		entry_bool,		_T("1"),		&allow_compressed_files},
		{_T("merge encrypted files"),		entry_bool,		_T("0"),		&allow_encrypted_files},
		{_T("merge hidden files"),			entry_bool,		_T("1"),		&allow_hidden_files},
		{_T("merge offline files"),			entry_bool,		_T("0"),		&allow_offline_files},
		{_T("merge temporary files"),		entry_bool,		_T("0"),		&allow_temporary_files},
		{_T("base USN log size"),			entry_int64,	_T("1048576"),	&base_usn_log_size},
		{_T("max USN log size"),			entry_int64,	_T("16777216"),	&max_usn_log_size}
	};

	_TCHAR *ini_file_partition_path = new _TCHAR[SIS_CSDIR_STRING_NCHARS
		+ _tcslen(disks_ini_filename) + MAX_PATH];
	_tcscpy(ini_file_partition_path, drive_name);
	int drive_name_length = _tcslen(drive_name);
	_tcscpy(&ini_file_partition_path[drive_name_length - 1], SIS_CSDIR_STRING);
	_tcscat(ini_file_partition_path, disks_ini_filename);

	IniFile::read(ini_file_partition_path, disks_ini_section,
		registry_entry_count, registry_entries);

#if WRITE_ALL_PARAMETERS

	bool ini_file_overwrite_ok =
		IniFile::overwrite(ini_file_partition_path, disks_ini_section,
		registry_entry_count, registry_entries);
	if (!ini_file_overwrite_ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: IniFile::overwrite() failed\n")));
	}

#endif // WRITE_ALL_PARAMETERS

	ASSERT(ini_file_partition_path != 0);
	delete[] ini_file_partition_path;
	ini_file_partition_path = 0;
}

WriteDiskInformation::WriteDiskInformation(
	const _TCHAR *drive_name,
	int backup_interval)
{
	ASSERT(this != 0);
	ASSERT(backup_interval >= 0);
	this->backup_interval = backup_interval;

	EntrySpec registry_entries[registry_entry_count] =
	{
		{_T("hash read time estimate"),		entry_double,	_T("0.0"),		&partition_hash_read_time_estimate},
		{_T("compare read time estimate"),	entry_double,	_T("0.0"),		&partition_compare_read_time_estimate},
		{_T("mean file size"),				entry_double,	_T("65536.0"),	&mean_file_size},
		{_T("read time confidence"),		entry_double,	_T("0.0"),		&read_time_confidence},
		{_T("volume serial number"),		entry_int,		_T("0"),		&volume_serial_number}
	};

	for (int index = 0; index < registry_entry_count; index++)
	{
		this->registry_entries[index] = registry_entries[index];
	}

	ini_file_partition_path = new _TCHAR[SIS_CSDIR_STRING_NCHARS
		+ _tcslen(disks_ini_filename) + MAX_PATH];
	_tcscpy(ini_file_partition_path, drive_name);
	int drive_name_length = _tcslen(drive_name);
	_tcscpy(&ini_file_partition_path[drive_name_length - 1], SIS_CSDIR_STRING);
	_tcscat(ini_file_partition_path, disks_ini_filename);

	IniFile::read(ini_file_partition_path, disks_ini_section,
		registry_entry_count, registry_entries);

	if (backup_interval > 0)
	{
		backup((void *)this);
	}
}

WriteDiskInformation::~WriteDiskInformation()
{
	ASSERT(this != 0);
	ASSERT(backup_interval >= 0);
	ASSERT(ini_file_partition_path != 0);
	backup((void *)this);
	delete[] ini_file_partition_path;
	ini_file_partition_path = 0;
}

void
WriteDiskInformation::backup(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	WriteDiskInformation *me = (WriteDiskInformation *)context;
	ASSERT(me->backup_interval >= 0);
	ASSERT(me->ini_file_partition_path != 0);
	bool ini_file_overwrite_ok =
		IniFile::overwrite(me->ini_file_partition_path, disks_ini_section,
		registry_entry_count, me->registry_entries);
	if (!ini_file_overwrite_ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: IniFile::overwrite() failed\n")));
	}
	event_timer.schedule(invokation_time + me->backup_interval,
		context, backup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\decayacc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    decayacc.cpp

Abstract:

	SIS Groveler decaying accumulator

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/
#include "all.hxx"

DecayingAccumulator::DecayingAccumulator(
	unsigned int time_constant)
{
	ASSERT(this != 0);
	this->time_constant = double(time_constant);
	ASSERT(this->time_constant >= 0.0);
	decaying_accumulation = 0.0;
	update_time = GET_TICK_COUNT();
}

void
DecayingAccumulator::increment(
	int increase)
{
	ASSERT(this != 0);
	ASSERT(time_constant >= 0.0);
	ASSERT(decaying_accumulation >= 0.0);
	ASSERT(increase >= 0);
	unsigned int current_time = GET_TICK_COUNT();
	unsigned int elapsed_time = current_time - update_time;
	ASSERT(signed(elapsed_time) >= 0);
	double coefficient = 0.0;
	if (time_constant > 0.0)
	{
		coefficient = exp(-double(elapsed_time)/time_constant);
	}
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient <= 1.0);
	decaying_accumulation =
		coefficient * decaying_accumulation + double(increase);
	ASSERT(decaying_accumulation >= 0.0);
	update_time = current_time;
}

double
DecayingAccumulator::retrieve_value() const
{
	ASSERT(this != 0);
	ASSERT(time_constant >= 0.0);
	ASSERT(decaying_accumulation >= 0.0);
	unsigned int current_time = GET_TICK_COUNT();
	unsigned int elapsed_time = current_time - update_time;
	ASSERT(signed(elapsed_time) >= 0);
	double coefficient = 0.0;
	if (time_constant > 0.0)
	{
		coefficient = exp(-double(elapsed_time)/time_constant);
	}
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient <= 1.0);
	return coefficient * decaying_accumulation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\etimer.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    etimer.h

Abstract:

	SIS Groveler event timer include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_ETIMER

#define _INC_ETIMER

typedef void (*EventCallback)(void *);

class EventTimer
{
public:

	EventTimer();

	~EventTimer();

	void run();

	void halt();

	void schedule(
		unsigned int event_time,
		void *context,
		EventCallback callback);

private:

	struct Event
	{
		unsigned int event_time;
		void *context;
		EventCallback callback;
	};

	struct HeapSegment
	{
		HeapSegment *previous;
		HeapSegment *next;
		Event events[1];
	};

	HeapSegment *first_segment, *last_segment;
	int population;
	int segment_size;
	bool heap_ok;
	bool running;
};

#endif	/* _INC_ETIMER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\diskinfo.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    diskinfo.h

Abstract:

	SIS Groveler disk information include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_DISKINFO

#define _INC_DISKINFO

struct ReadDiskInformation
{
	ReadDiskInformation(
		const _TCHAR *drive_name);

	int min_file_size;
	int min_file_age;
	bool enable_groveling;
	bool error_retry_log_extraction;
	bool error_retry_groveling;
	bool allow_compressed_files;
	bool allow_encrypted_files;
	bool allow_hidden_files;
	bool allow_offline_files;
	bool allow_temporary_files;
	__int64 base_usn_log_size;
	__int64 max_usn_log_size;

private:

	enum {registry_entry_count = 12};
};

struct WriteDiskInformation
{
	WriteDiskInformation(
		const _TCHAR *drive_name,
		int backup_interval);

	~WriteDiskInformation();

	double partition_hash_read_time_estimate;
	double partition_compare_read_time_estimate;
	double mean_file_size;
	double read_time_confidence;
	int volume_serial_number;

private:

	enum {registry_entry_count = 5};

	static void backup(
		void *context);

	int backup_interval;
	EntrySpec registry_entries[registry_entry_count];
	_TCHAR *ini_file_partition_path;
};

#endif	/* _INC_DISKINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\event.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    event.cpp

Abstract:

	SIS Groveler sync event class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

SyncEvent::SyncEvent(
	bool initial_state,
	bool manual_reset)
{
	ASSERT(this != 0);
	event_handle = CreateEvent(0, manual_reset, initial_state, 0);
	if (event_handle == 0)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: CreateEvent() failed with error %d\n"), err));
		throw exception_create_event;
	}
}

SyncEvent::~SyncEvent()
{
	ASSERT(this != 0);
	ASSERT(event_handle != 0);
	int ok = CloseHandle(event_handle);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
	}
	event_handle = 0;
}

bool
SyncEvent::set()
{
	ASSERT(this != 0);
	ASSERT(event_handle != 0);
	BOOL ok = SetEvent(event_handle);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetEvent() failed with error %d\n"), err));
	}
	return (ok != 0);
}

bool
SyncEvent::reset()
{
	ASSERT(this != 0);
	ASSERT(event_handle != 0);
	BOOL ok = ResetEvent(event_handle);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: ResetEvent() failed with error %d\n"), err));
	}
	return (ok != 0);
}

bool
SyncEvent::wait(
	unsigned int timeout)
{
	ASSERT(this != 0);
	ASSERT(event_handle != 0);
	ASSERT(signed(timeout) >= 0);
	DWORD result = WAIT_FOR_SINGLE_OBJECT(event_handle, timeout);
	if (result != WAIT_TIMEOUT && result != WAIT_OBJECT_0)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: WaitForSingleObject() returned error %d\n"),
			result));
	}
	return (result == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\etimer.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    etimer.cpp

Abstract:

	SIS Groveler event timer

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

#define NEW_HeapSegment(segment_size) \
	((HeapSegment *)(new BYTE[sizeof(HeapSegment) + \
	((segment_size) - 1) * sizeof(Event)]))

#define DELETE_HeapSegment(heap_segment) delete[] ((BYTE *)(heap_segment))

EventTimer::EventTimer()
{
	ASSERT(this != 0);
	first_segment = NEW_HeapSegment(1);
	first_segment->previous = 0;
	first_segment->next = 0;
	last_segment = first_segment;
	population = 0;
	segment_size = 1;
	heap_ok = false;
}

EventTimer::~EventTimer()
{
	ASSERT(this != 0);
	ASSERT(first_segment != 0);
	ASSERT(last_segment != 0);
	ASSERT(population >= 0);
	ASSERT(segment_size > 0);
	ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
	ASSERT(population >= segment_size - 1);
	ASSERT(!heap_ok || population >= segment_size);
	ASSERT(population < 2 * segment_size);
	ASSERT(first_segment != last_segment || segment_size == 1);
	ASSERT(first_segment == last_segment || segment_size > 1);
	while (first_segment != 0)
	{
		HeapSegment *next_segment = first_segment->next;
		ASSERT(first_segment != 0);
		DELETE_HeapSegment(first_segment);
		first_segment = next_segment;
	}
}

void
EventTimer::run()
{
	ASSERT(this != 0);
	running = true;
	while (running && population > 0)
	{
		ASSERT(first_segment != 0);
		ASSERT(last_segment != 0);
		ASSERT(population >= 0);
		ASSERT(segment_size > 0);
		ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
		ASSERT(population >= segment_size - 1);
		ASSERT(!heap_ok || population >= segment_size);
		ASSERT(population < 2 * segment_size);
		ASSERT(first_segment != last_segment || segment_size == 1);
		ASSERT(first_segment == last_segment || segment_size > 1);
		if (!heap_ok)
		{
			int final_position = (population + 1) % segment_size;
			unsigned int final_time =
				last_segment->events[final_position].event_time;
			HeapSegment *segment = first_segment;
			HeapSegment *next_segment = segment->next;
			int position = 0;
			int next_position = 0;
			while (segment != last_segment
				&& (next_segment != last_segment
				|| next_position < final_position))
			{
				if ((next_segment != last_segment ||
					next_position + 1 < final_position) &&
					signed(next_segment->events[next_position].event_time -
					next_segment->events[next_position + 1].event_time) > 0)
				{
					next_position++;
				}
				if (signed(final_time -
					next_segment->events[next_position].event_time) <= 0)
				{
					break;
				}
				segment->events[position] = next_segment->events[next_position];
				segment = next_segment;
				next_segment = segment->next;
				position = next_position;
				next_position = 2 * position;
			}
			segment->events[position] = last_segment->events[final_position];
			if (population < segment_size)
			{
				segment_size /= 2;
				last_segment = last_segment->previous;
			}
			heap_ok = true;
		}
		ASSERT(first_segment != 0);
		ASSERT(last_segment != 0);
		ASSERT(population >= 0);
		ASSERT(segment_size > 0);
		ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
		ASSERT(population >= segment_size - 1);
		ASSERT(!heap_ok || population >= segment_size);
		ASSERT(population < 2 * segment_size);
		ASSERT(first_segment != last_segment || segment_size == 1);
		ASSERT(first_segment == last_segment || segment_size > 1);
		unsigned int current_time = GET_TICK_COUNT();
		int sleep_time = __max(
			signed(first_segment->events[0].event_time - current_time), 0);
		do
		{
			bool event_triggered = sync_event.wait(sleep_time);
			if (event_triggered)
			{
				SERVICE_FOLLOW_COMMAND();
				if (!running)
				{
					return;
				}
			}
			current_time = GET_TICK_COUNT();
			sleep_time = __max(
				signed(first_segment->events[0].event_time - current_time), 0);
		} while (sleep_time > 0);
		heap_ok = false;
		population--;
		(*first_segment->events[0].callback)(first_segment->events[0].context);
		bool ok = shared_data->send_values();
		if (!ok)
		{
			PRINT_DEBUG_MSG((_T("GROVELER: SharedData::send_values() failed\n")));
		}
	}
}

void
EventTimer::halt()
{
	ASSERT(this != 0);
	ASSERT(first_segment != 0);
	ASSERT(last_segment != 0);
	ASSERT(population >= 0);
	ASSERT(segment_size > 0);
	ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
	ASSERT(population >= segment_size - 1);
	ASSERT(!heap_ok || population >= segment_size);
	ASSERT(population < 2 * segment_size);
	ASSERT(first_segment != last_segment || segment_size == 1);
	ASSERT(first_segment == last_segment || segment_size > 1);
	running = false;
}

void
EventTimer::schedule(
	unsigned int event_time,
	void *context,
	EventCallback callback)
{
	ASSERT(this != 0);
	ASSERT(first_segment != 0);
	ASSERT(last_segment != 0);
	ASSERT(population >= 0);
	ASSERT(segment_size > 0);
	ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
	ASSERT(population >= segment_size - 1);
	ASSERT(!heap_ok || population >= segment_size);
	ASSERT(population < 2 * segment_size);
	ASSERT(first_segment != last_segment || segment_size == 1);
	ASSERT(first_segment == last_segment || segment_size > 1);
	population++;
	HeapSegment *segment;
	int position;
	if (heap_ok)
	{
		if (population >= 2 * segment_size)
		{
			segment_size *= 2;
			if (last_segment->next == 0)
			{
				last_segment->next = NEW_HeapSegment(segment_size);
				last_segment->next->previous = last_segment;
				last_segment->next->next = 0;
			}
			last_segment = last_segment->next;
		}
		segment = last_segment;
		HeapSegment *previous_segment = segment->previous;
		position = population % segment_size;
		int next_position = position >> 1;
		while (previous_segment != 0 && signed(event_time
			- previous_segment->events[next_position].event_time) < 0)
		{
			segment->events[position] = previous_segment->events[next_position];
			segment = previous_segment;
			previous_segment = segment->previous;
			position = next_position;
			next_position >>= 1;
		}
	}
	else
	{
		int final_position = population % segment_size + 1;
		segment = first_segment;
		HeapSegment *next_segment = segment->next;
		position = 0;
		int next_position = 0;
		while (segment != last_segment
			&& (next_segment != last_segment
			|| next_position < final_position))
		{
			if ((next_segment != last_segment ||
				next_position + 1 < final_position) &&
				signed(next_segment->events[next_position].event_time -
				next_segment->events[next_position + 1].event_time) > 0)
			{
				next_position++;
			}
			if (signed(event_time -
				next_segment->events[next_position].event_time) <= 0)
			{
				break;
			}
			segment->events[position] = next_segment->events[next_position];
			segment = next_segment;
			next_segment = segment->next;
			position = next_position;
			next_position = 2 * position;
		}
	}
	segment->events[position].event_time = event_time;
	segment->events[position].context = context;
	segment->events[position].callback = callback;
	heap_ok = true;
	ASSERT(first_segment != 0);
	ASSERT(last_segment != 0);
	ASSERT(population >= 0);
	ASSERT(segment_size > 0);
	ASSERT((segment_size & (segment_size - 1)) == 0);  // power of 2
	ASSERT(population >= segment_size);
	ASSERT(population < 2 * segment_size);
	ASSERT(first_segment != last_segment || segment_size == 1);
	ASSERT(first_segment == last_segment || segment_size > 1);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\event.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    event.h

Abstract:

	SIS Groveler sync event class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_EVENT

#define _INC_EVENT

class SyncEvent
{
public:

	SyncEvent(
		bool initial_state,
		bool manual_reset);

	~SyncEvent();

	bool set();

	bool reset();

	bool wait(
		unsigned int timeout);

private:

	HANDLE event_handle;
};

#endif	/* _INC_EVENT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\eventlog.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.cpp

Abstract:

	SIS Groveler eventlog interface

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

#ifndef MIN_MESSAGE_SEVERITY
#define MIN_MESSAGE_SEVERITY 0
#endif

const _TCHAR *
EventLog::service_name = _T("Groveler");

const _TCHAR *
EventLog::message_filename = _T("%SystemRoot%\\System32\\grovmsg.dll");

static const _TCHAR *
registry_log_path = 
	_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");

const DWORD
EventLog::types_supported =
	EVENTLOG_INFORMATION_TYPE |
	EVENTLOG_WARNING_TYPE |
	EVENTLOG_ERROR_TYPE;

EventLog::EventLog()
{
	ASSERT(this != 0);
	setup_registry();
	event_source_handle = RegisterEventSource(0, service_name);
	if (event_source_handle == 0)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: RegisterEventSource() failed with error %d\n"),
			err));
	}
}

EventLog::~EventLog()
{
	ASSERT(this != 0);
	if (event_source_handle != 0)
	{
		int ok = DeregisterEventSource(event_source_handle);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: DeregisterEventSource() failed with error %d\n"),
				err));
		}
	}
}

bool
EventLog::report_event(
	DWORD event_id,
	int string_count,
//	_TCHAR *string
	...)
{
	ASSERT(this != 0);
	ASSERT(event_source_handle != 0);
	ASSERT(string_count >= 0);
	if (event_source_handle == 0)
	{
		return false;
	}
	DWORD message_severity = MESSAGE_SEVERITY(event_id);
	if (message_severity < MIN_MESSAGE_SEVERITY)
	{
		return false;
	}
	const _TCHAR **strings = 0;
	if (string_count > 0)
	{
		strings = new const _TCHAR *[string_count];
		va_list ap;
		va_start(ap, string_count);
		for (int index = 0; index < string_count; index++)
		{
			strings[index] = va_arg(ap, _TCHAR *);
			ASSERT(strings[index] != 0);
		}
		va_end(ap);
	}
	WORD event_type = 0;
	switch (message_severity)
	{
	case MESSAGE_SEVERITY_SUCCESS:
		event_type = EVENTLOG_AUDIT_SUCCESS;
		break;
	case MESSAGE_SEVERITY_INFORMATIONAL:
		event_type = EVENTLOG_INFORMATION_TYPE;
		break;
	case MESSAGE_SEVERITY_WARNING:
		event_type = EVENTLOG_WARNING_TYPE;
		break;
	case MESSAGE_SEVERITY_ERROR:
		event_type = EVENTLOG_ERROR_TYPE;
		break;
	default:
		ASSERT(false);
	}
	BOOL ok = ReportEvent(event_source_handle, event_type, 0, event_id,
		0, (WORD)string_count, 0, strings, 0);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: ReportEvent() failed with error %d\n"), err));
	}
	if (strings != 0)
	{
		ASSERT(string_count > 0);
		delete[] strings;
		strings = 0;
	}
	return (ok != 0);
}

bool
EventLog::setup_registry()
{
	_TCHAR *log_path = 0;
	try
	{
		HKEY path_key = 0;
		DWORD disp;
		log_path =
			new _TCHAR[_tcslen(registry_log_path) + _tcslen(service_name) + 1];
		_stprintf(log_path, _T("%s%s"), registry_log_path, service_name);
		Registry::create_key_ex(HKEY_LOCAL_MACHINE, log_path, 0, 0,
			REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 0, &path_key, &disp);
		ASSERT(log_path != 0);
		delete[] log_path;
		log_path = 0;
		try
		{
			Registry::set_value_ex(path_key, _T("EventMessageFile"), 0,
				REG_EXPAND_SZ, (BYTE *)message_filename,
				(_tcslen(message_filename) + 1) * sizeof(_TCHAR));
			Registry::set_value_ex(path_key, _T("TypesSupported"), 0,
				REG_DWORD, (BYTE *)&types_supported, sizeof(DWORD));
		}
		catch (DWORD result)
		{
			ASSERT(result != ERROR_SUCCESS);
			PRINT_DEBUG_MSG((_T("GROVELER: Registry::set_value_ex() failed with error %d\n"),
				result));
			ASSERT(path_key != 0);
			Registry::close_key(path_key);
			path_key = 0;
			return false;
		}
		ASSERT(path_key != 0);
		Registry::close_key(path_key);
		path_key = 0;
	}
	catch (DWORD result)
	{
		if (log_path != 0)
		{
			delete[] log_path;
			log_path = 0;
		}
		ASSERT(result != ERROR_SUCCESS);
		PRINT_DEBUG_MSG((_T("GROVELER: Registry::create_key_ex() or Registry::close_key() ")
			_T("failed with error %d\n"), result));
		return false;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\extract.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    extract.cpp

Abstract:

    SIS Groveler USN journal reading functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

// NT Update Sequence Number (USN) journal definitions

#define USN_ADD_REASONS ( 0U              \
    | USN_REASON_DATA_OVERWRITE           \
    | USN_REASON_DATA_EXTEND              \
    | USN_REASON_DATA_TRUNCATION          \
    | USN_REASON_NAMED_DATA_OVERWRITE     \
    | USN_REASON_NAMED_DATA_EXTEND        \
    | USN_REASON_NAMED_DATA_TRUNCATION    \
    | USN_REASON_FILE_CREATE              \
    | USN_REASON_FILE_DELETE              \
/*  | USN_REASON_PROPERTY_CHANGE       */ \
/*  | USN_REASON_SECURITY_CHANGE       */ \
/*  | USN_REASON_RENAME_OLD_NAME       */ \
/*  | USN_REASON_RENAME_NEW_NAME       */ \
    | USN_REASON_INDEXABLE_CHANGE         \
    | USN_REASON_BASIC_INFO_CHANGE        \
/*  | USN_REASON_HARD_LINK_CHANGE      */ \
    | USN_REASON_COMPRESSION_CHANGE       \
    | USN_REASON_ENCRYPTION_CHANGE        \
    | USN_REASON_OBJECT_ID_CHANGE         \
/*  | USN_REASON_REPARSE_POINT_CHANGE  */ \
    | USN_REASON_CLOSE                    \
)

/*****************************************************************************/

// set_usn_log_size() sets the maximum size of this volume's USN journal.

GrovelStatus Groveler::set_usn_log_size(
    IN DWORDLONG usn_log_size)
{
    CREATE_USN_JOURNAL_DATA createUSN;

    DWORD transferCount;

    ASSERT(volumeHandle != NULL);

    createUSN.MaximumSize     = usn_log_size;
    createUSN.AllocationDelta = USN_PAGE_SIZE;

// Set the maximum size of the USN journal.

    if (!DeviceIoControl(
        volumeHandle,
        FSCTL_CREATE_USN_JOURNAL,
        &createUSN,
        sizeof(CREATE_USN_JOURNAL_DATA),
        NULL,
        0,
        &transferCount,
        NULL)) {
        DPRINTF((_T("%s: error setting USN journal size: %lu\n"),
            driveName, GetLastError()));
        return Grovel_error;
    }

    TPRINTF((_T("%s: set USN journal size to %I64u\n"),
        driveName, usn_log_size));

    return Grovel_ok;
}

/*****************************************************************************/

// get_usn_log_size() returns the current size of this volume's USN journal.

GrovelStatus Groveler::get_usn_log_info(
    OUT USN_JOURNAL_DATA *usnJournalData)
{
    DWORD transferCount,
          lastError;

    BOOL success;

    ASSERT(volumeHandle != NULL);

// Query the USN journal settings.

    success = DeviceIoControl(
        volumeHandle,
        FSCTL_QUERY_USN_JOURNAL,
        NULL,
        0,
        usnJournalData,
        sizeof(USN_JOURNAL_DATA),
        &transferCount,
        NULL);

    if (!success)
        lastError = GetLastError();
    else if (transferCount != sizeof(USN_JOURNAL_DATA)) {
        lastError = 0;
        success   = FALSE;
    }

    if (!success) {
        DPRINTF((_T("%s: error querying USN journal settings: %lu\n"),
            driveName, lastError));
        return Grovel_error;
    }

    TPRINTF((_T("%s: USN journal: ID=0x%I64x size=0x%I64x\n"),
        driveName, usnJournalData->UsnJournalID,
        usnJournalData->MaximumSize));

    return Grovel_ok;
}

/*****************************************************************************/

// extract_log() reads this volume's USN journal.

// If the lastUSN parameter equals zero or doesn't exist, the USN journal
// is read from the beginning. Otherwise, the lastUSN paramerer indicates
// the most recent USN entry read during the last call of extract_log().
// If the lastUSN entry is still available in the USN journal, read the
// journal beginning at the entry following the lastUSN entry. If the
// lastUSN entry is no longer available, it indicates that the USN
// journal has wrapped: read all entries from the journal.

enum USNException {
    USN_ERROR
};

enum DatabaseException {
    DATABASE_ERROR
};

GrovelStatus Groveler::extract_log2(
    OUT DWORD     *num_entries_extracted,
    OUT DWORDLONG *num_bytes_extracted,
    OUT DWORDLONG *num_bytes_skipped,
    OUT DWORD     *num_files_enqueued,
    OUT DWORD     *num_files_dequeued)
{
    struct FileEntry {
        DWORDLONG fileID,
                  parentID,
                  timeStamp;
        DWORD     attributes,
                  reason;
    } *fileEntry = NULL;

    struct DirEntry {
        DWORDLONG dirID;
    } *dirEntry = NULL;

    Table *fileTable = NULL,
          *dirTable  = NULL;

    BYTE usnBuffer[USN_PAGE_SIZE + sizeof(DWORDLONG)];

    READ_USN_JOURNAL_DATA readUSN;

    USN_RECORD *usnRecord;

    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry queueEntry;

    SGNativeStackEntry stackEntry;

    SGNativeListEntry listEntry;

    TCHAR listValue[17];

    DWORDLONG usn_log_size,
              numBytesExtracted = 0,
              numBytesSkipped   = 0,
              startUSN,
              firstUSN,
              nextUSN,
              thisUSN;

    DWORD numEntriesExtracted = 0,
          numTableDeletions   = 0,
          numQueueDeletions   = 0 ,
          numQueueAdditions   = 0,
          numActions          = 0,
          offset,
          bytesRead,
          lastError;

    LONG num;

    BOOL firstEntry = TRUE,
         deleteEntry,
         addEntry,
         success;

    GrovelStatus    status;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase != NULL);

// If we don't know the previous USN, we can't extract.

    if (lastUSN == UNINITIALIZED_USN) {
        status = Grovel_overrun;
        goto Abort;
    }
    ASSERT(usnID != UNINITIALIZED_USN);

    fileTable = new Table;
    ASSERT(fileTable != NULL);

    if (inScan) {
        dirTable = new Table;
        ASSERT(dirTable != NULL);
    }

// Set up to read the volume's USN journal.

    startUSN = lastUSN == UNINITIALIZED_USN ? 0 : lastUSN;

    readUSN.ReturnOnlyOnClose =  1;
    readUSN.Timeout           =  0;
    readUSN.BytesToWaitFor    =  0;
    readUSN.ReasonMask        = ~0U;
    readUSN.UsnJournalID      =  usnID;

// Read the USN journal one page at a time.

    try {
        while (TRUE) {
            readUSN.StartUsn = startUSN;

            if (!DeviceIoControl(
                volumeHandle,
                FSCTL_READ_USN_JOURNAL,
                &readUSN,
                sizeof(READ_USN_JOURNAL_DATA),
                usnBuffer,
                USN_PAGE_SIZE + sizeof(DWORDLONG),
                &bytesRead,
                NULL)) {

                lastError = GetLastError();


// NTRAID#65198-2000/03/10-nealch  Handle USN id change (treat as overwrite w/ unknown no. of bytes skipped)

// If the journal overflowed, report by how much.

                if (lastError == ERROR_KEY_DELETED || lastError == ERROR_JOURNAL_ENTRY_DELETED) {
                    USN_JOURNAL_DATA usnJournalData;

                    if (get_usn_log_info(&usnJournalData) != Grovel_ok)
                        return Grovel_error;

                    // The USN journal will not wrap in our lifetimes so we don't really need
                    // to handle USN Journal wrapping.
                    ASSERT((DWORDLONG) usnJournalData.FirstUsn > lastUSN);

                    numBytesSkipped = (DWORDLONG) usnJournalData.FirstUsn - lastUSN;
                    goto Overrun;
                }

                throw USN_ERROR;
            }

            lastError = 0;

            if (bytesRead < sizeof(DWORDLONG))
                throw USN_ERROR;

            nextUSN = *(DWORDLONG *)usnBuffer;
            if (nextUSN < startUSN)
                throw USN_ERROR;

            if (nextUSN == startUSN) {
                if (bytesRead != sizeof(DWORDLONG))
                    throw USN_ERROR;
                break;
            }

            bytesRead         -= sizeof(DWORDLONG);
            offset             = 0;
            numBytesExtracted += bytesRead;

// Process each USN journal entry.

            while (bytesRead > 0) {
                if (bytesRead < sizeof(USN_RECORD))
                    throw USN_ERROR;

                usnRecord = (USN_RECORD *)&usnBuffer[offset + sizeof(DWORDLONG)];

                if (usnRecord->RecordLength <
                        offsetof(USN_RECORD, FileName) + usnRecord->FileNameLength
                 || usnRecord->RecordLength > bytesRead)
                    throw USN_ERROR;

                thisUSN = (DWORDLONG)usnRecord->Usn;
                if (thisUSN < startUSN + offset)
                    throw USN_ERROR;

// If this is the first entry, check if it is the expected
// USN. If it isn't, the USN journal has wrapped.

                if (firstEntry)
                    if (startUSN == 0)
                        numBytesSkipped = thisUSN;
                    else if (thisUSN <= startUSN + usnRecord->RecordLength)
                        numBytesSkipped = 0;
                    else
                        numBytesSkipped = thisUSN - startUSN - usnRecord->RecordLength;

// Skip the first entry if the starting address is greater than zero.
// After skipping the first entry, examine each USN entry as follows:
//
// - If the entry is a directory, and a volume scan is underway,
//   add the directory's ID to the directory table.
//
// - If the entry is a file, add it to the file table. Include
//   its ID and its parent directory's ID, its most recent time
//   stamp and attributes, and its accumulated reason bits.

                if (firstEntry && startUSN > 0)
                    numBytesExtracted -= usnRecord->RecordLength;

                else {
                    if (usnRecord->      FileReferenceNumber == 0
                     || usnRecord->ParentFileReferenceNumber == 0)
                        throw USN_ERROR;

// The entry is a directory.

                    if ((usnRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                        if (dirTable != NULL) {
                            dirEntry = (DirEntry *)dirTable->Get(
                                (const VOID *)&usnRecord->FileReferenceNumber,
                                sizeof(DWORDLONG));

                            if (dirEntry != NULL) {
                                ASSERT(dirEntry->dirID == usnRecord->FileReferenceNumber);
                            } else {
                                dirEntry = new DirEntry;
                                ASSERT(dirEntry != NULL);
                                dirEntry->dirID = usnRecord->FileReferenceNumber;
                                success = dirTable->Put((VOID *)dirEntry, sizeof(DWORDLONG));
                                ASSERT(success);
                            }
                        }
                    }

// The entry is a file.  If USN_SOURCE_DATA_MANAGEMENT is set, assume this entry was created by
// the groveler during a merge operation.

                    else if ((usnRecord->SourceInfo & USN_SOURCE_DATA_MANAGEMENT) == 0) {

                        fileEntry = (FileEntry *)fileTable->Get(
                            (const VOID *)&usnRecord->FileReferenceNumber,
                            sizeof(DWORDLONG));

                        if (fileEntry != NULL) {
                            ASSERT(fileEntry->fileID == usnRecord->FileReferenceNumber);
                        } else {
                            fileEntry = new FileEntry;
                            ASSERT(fileEntry != NULL);
                            fileEntry->fileID   = usnRecord->FileReferenceNumber;
                            fileEntry->reason   = 0;
                            success = fileTable->Put((VOID *)fileEntry, sizeof(DWORDLONG));
                            ASSERT(success);
                        }

                        fileEntry->parentID   = usnRecord->ParentFileReferenceNumber;
                        fileEntry->timeStamp  = (DWORDLONG)usnRecord->TimeStamp.QuadPart;
                        fileEntry->attributes =            usnRecord->FileAttributes;

                        if ((usnRecord->Reason & USN_REASON_FILE_DELETE) != 0)
                            fileEntry->reason  = USN_REASON_FILE_DELETE;
                        else
                            fileEntry->reason |= usnRecord->Reason;
                    } else {
                        TPRINTF((_T("%s: USN_SOURCE_DATA_MANAGEMENT set on file 0x%016I64x\n"),
							driveName, usnRecord->FileReferenceNumber));
                    }

                    if (numEntriesExtracted++ == 0)
                        firstUSN = thisUSN;
                }

                lastUSN    = thisUSN;
                offset    += usnRecord->RecordLength;
                bytesRead -= usnRecord->RecordLength;
                firstEntry = FALSE;
            }

            startUSN = nextUSN;
        }
    }

// If an error occured while reading the USN journal, return an error status.

    catch (USNException usnException) {
        ASSERT(usnException == USN_ERROR);

        if (fileTable != NULL) {
            delete fileTable;
            fileTable = NULL;
        }

        if (dirTable != NULL) {
            delete dirTable;
            dirTable = NULL;
        }

        lastUSN = UNINITIALIZED_USN;

        DPRINTF((_T("%s: error reading USN journal: %lu\n"),
            driveName, lastError));
        return Grovel_error;
    }

// We've finished reading the USN journal, so update the database. Process
// each entry in the file table, and group the updates into transactions.

    try {
        while ((fileEntry = (FileEntry *)fileTable->GetFirst()) != NULL) {
            ASSERT(fileEntry->fileID != 0);

// If the file is currently open in the grovel process, skip this entry.

            if (inUseFileID1 != NULL && fileEntry->fileID == *inUseFileID1
             || inUseFileID2 != NULL && fileEntry->fileID == *inUseFileID2) {

                DPRINTF((_T("%s: extract_log/grovel collision on file 0x%016I64x\n"),
                    driveName, fileEntry->fileID));

            } else {

// Delete the file from the queue and the table...
//
// - if the file's most recent reason bits in the USN journal
//   indicate it was deleted,
//
// - if the file or the file's most recent parent directory is disallowed,
//
// - or if the file has disallowed attributes.
//
// Otherwise, update or add the file to the queue...
//
// - if the file's reason bits indicate it was changed,
//
// - or if the file isn't present in the table.

                if (fileEntry->reason == USN_REASON_FILE_DELETE
                 || !IsAllowedID(fileEntry->fileID)
                 || !IsAllowedID(fileEntry->parentID)
                 || (fileEntry->attributes & disallowedAttributes) != 0) {
                    deleteEntry = TRUE;
                    addEntry    = FALSE;
                } else {
                    deleteEntry = FALSE;
                    if ((fileEntry->reason & USN_ADD_REASONS) != 0)
                        addEntry = TRUE;
                    else {
                        tableEntry.fileID = fileEntry->fileID;
                        num = sgDatabase->TableGetFirstByFileID(&tableEntry);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 0 || num == 1);
                        addEntry = num == 0;
                    }
                }

                if (deleteEntry || addEntry) {
                    if (numActions == 0) {
                        if (sgDatabase->BeginTransaction() < 0)
                            throw DATABASE_ERROR;
                        numActions = 1;
                    }

                    queueEntry.reason = 0;

                    num = sgDatabase->TableDeleteByFileID(fileEntry->fileID);
                    if (num < 0)
                        throw DATABASE_ERROR;
                    if (num > 0) {
                        ASSERT(num == 1);
                        numTableDeletions++;
                        numActions++;
                    }

                    queueEntry.fileID   = fileEntry->fileID;
                    queueEntry.fileName = NULL;
                    num = sgDatabase->QueueGetFirstByFileID(&queueEntry);
                    if (num < 0)
                        throw DATABASE_ERROR;

                    if (num > 0) {
                        ASSERT(num == 1);
                        num = sgDatabase->QueueDeleteByFileID(fileEntry->fileID);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 1);
                        numQueueDeletions++;
                        numActions++;
                    }

                    if (addEntry) {
                        queueEntry.fileID    = fileEntry->fileID;
                        queueEntry.parentID  = 0;
                        queueEntry.reason   |= fileEntry->reason;
                        queueEntry.readyTime = fileEntry->timeStamp + minFileAge;
                        queueEntry.retryTime = 0;
                        queueEntry.fileName  = NULL;

                        num = sgDatabase->QueuePut(&queueEntry);
                        if (num < 0)
                            throw DATABASE_ERROR;
                        ASSERT(num == 1);

#ifdef DEBUG_USN_REASON
                        if (numQueueAdditions == 0) {
                            DPRINTF((_T("--> __REASON__ _____FILE_ID______\n")));
                        }
                        DPRINTF((_T("    0x%08lx 0x%016I64x\n"),
                            fileEntry->reason, fileEntry->fileID));
#endif

                        numQueueAdditions++;
                        numActions++;
                    }

                    if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                        if (!sgDatabase->CommitTransaction())
                            throw DATABASE_ERROR;
                        TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                            driveName, numActions, databaseName));
                        numActions = 0;
                    }
                }
            }

            delete fileEntry;
            fileEntry = NULL;
        }

        delete fileTable;
        fileTable = NULL;

// Process each entry in the directory table. If the directory hasn't already
// been scanned or isn't on the list to be scanned, add it to the list.

        if (dirTable != NULL) {
            ASSERT(inScan);

            while ((dirEntry = (DirEntry *)dirTable->GetFirst()) != NULL) {
                ASSERT(dirEntry->dirID != 0);

                stackEntry.fileID = dirEntry->dirID;
                num = sgDatabase->StackGetFirstByFileID(&stackEntry);
                if (num < 0)
                    throw DATABASE_ERROR;

                if (num == 0) {
                    if (numActions == 0) {
                        if (sgDatabase->BeginTransaction() < 0)
                            throw DATABASE_ERROR;
                        numActions = 1;
                    }

                    num = sgDatabase->StackPut(dirEntry->dirID, FALSE);
                    if (num < 0)
                        throw DATABASE_ERROR;
                    ASSERT(num == 1);
                    numActions++;

                    if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                        if (!sgDatabase->CommitTransaction())
                            throw DATABASE_ERROR;
                        TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                            driveName, numActions, databaseName));
                        numActions = 0;
                    }
                }

                delete dirEntry;
                dirEntry = NULL;
            }

            delete dirTable;
            dirTable = NULL;
        }

// Update the last USN number in the database, then commit the changes.  If we're
// doing a volume scan, don't update the lastUSN until the scan is complete.

        if (!inScan) {
            _stprintf(listValue, _T("%016I64x"), lastUSN);
            listEntry.name  = LAST_USN_NAME;
            listEntry.value = listValue;
            num = sgDatabase->ListWrite(&listEntry);
            if (num <= 0)
                throw DATABASE_ERROR;
        }

        if (numActions > 0) {
            if (!sgDatabase->CommitTransaction())
                throw DATABASE_ERROR;
            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                driveName, numActions, databaseName));
            numActions = 0;
        }
    }

// If a database error occured, return an error status.

    catch (DatabaseException databaseException) {

        ASSERT(databaseException == DATABASE_ERROR);

        if (numActions > 0) {
            sgDatabase->AbortTransaction();
            numActions = 0;
        }

        if (fileTable != NULL) {
            delete fileTable;
            fileTable = NULL;
        }

        if (dirTable != NULL) {
            delete dirTable;
            dirTable = NULL;
        }

        return Grovel_error;
    }

    Overrun:

    status = numBytesSkipped == 0 ? Grovel_ok : Grovel_overrun;

    Abort:

// Return the performance statistics.

    if (num_entries_extracted != NULL)
        *num_entries_extracted = numEntriesExtracted;
    if (num_bytes_extracted   != NULL)
        *num_bytes_extracted   = numBytesExtracted;
    if (num_bytes_skipped     != NULL)
        *num_bytes_skipped     = numBytesSkipped;
    if (num_files_enqueued    != NULL)
        *num_files_enqueued    = numQueueAdditions;
    if (num_files_dequeued    != NULL)
        *num_files_dequeued    = numQueueDeletions;

#if DBG
    if (numEntriesExtracted > 0 && firstUSN < lastUSN) {
        TRACE_PRINTF(TC_extract, 2,
            (_T("%s: USN 0x%I64x-%I64x\n"), driveName, firstUSN, lastUSN));
    } else {
        TRACE_PRINTF(TC_extract, 2,
            (_T("%s: USN 0x%I64x\n"),       driveName, lastUSN));
    }
    TRACE_PRINTF(TC_extract, 2,
        (_T("   NumEntriesExtracted=%lu NumBytesExtracted=%I64u NumBytesSkipped=%I64u\n"),
        numEntriesExtracted, numBytesExtracted, numBytesSkipped));
    TRACE_PRINTF(TC_extract, 2,
        (_T("   NumTableDeletions=%lu NumQueueDeletions=%lu NumQueueAdditions=%lu\n"),
        numTableDeletions, numQueueDeletions, numQueueAdditions));
#endif

    return status;

}

GrovelStatus Groveler::extract_log(
    OUT DWORD     *num_entries_extracted,
    OUT DWORDLONG *num_bytes_extracted,
    OUT DWORDLONG *num_bytes_skipped,
    OUT DWORD     *num_files_enqueued,
    OUT DWORD     *num_files_dequeued)
{
	GrovelStatus status;

#ifdef _CRTDBG
_CrtMemState s1, s2, sdiff;

_CrtMemCheckpoint(&s1);
#endif

	status = extract_log2(
				num_entries_extracted,
				num_bytes_extracted,
				num_bytes_skipped,
				num_files_enqueued,
				num_files_dequeued);

#ifdef _CRTDBG
_CrtMemCheckpoint(&s2);
if (_CrtMemDifference(&sdiff, &s1, &s2))
	_CrtMemDumpStatistics(&sdiff);
#endif

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\eventlog.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.h

Abstract:

	SIS Groveler event log interface include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_EVENTLOG

#define _INC_EVENTLOG

class EventLog
{
public:

	EventLog();

	~EventLog();

	static bool setup_registry();

	bool report_event(
		DWORD event_id,
		int string_count,
	//	_TCHAR *string
		...);

private:

	static const _TCHAR *service_name;
	static const _TCHAR *message_filename;
	static const DWORD types_supported;

	HANDLE event_source_handle;
};

#endif	/* _INC_EVENTLOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\filter.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    filter.h

Abstract:

	SIS Groveler temporal filter include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_FILTER

#define _INC_FILTER

class TemporalFilter
{
public:

	TemporalFilter(
		unsigned int time_constant,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	double retrieve_value() const;

private:

	double time_constant;
	double filtered_value;
	unsigned int update_time;
};

class DirectedTemporalFilter
{
public:

	DirectedTemporalFilter(
		unsigned int increase_time_constant,
		unsigned int decrease_time_constant,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	double retrieve_value() const;

private:

	double increase_time_constant;
	double decrease_time_constant;
	double filtered_value;
	unsigned int update_time;
};

class IncidentFilter
{
public:

	IncidentFilter(
		int mean_history_length,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	void update_value(
		double value,
		int weight);

	double retrieve_value() const;

private:

	double coefficient;
	double filtered_value;
};

class DirectedIncidentFilter
{
public:

	DirectedIncidentFilter(
		int increase_mean_history_length,
		int decrease_mean_history_length,
		double initial_value = 0.0);

	void reset(
		double reset_value = 0.0);

	void update_value(
		double value);

	void update_value(
		double value,
		int weight);

	double retrieve_value() const;

private:

	double increase_coefficient;
	double decrease_coefficient;
	double filtered_value;
};

#endif	/* _INC_FILTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\grovctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovctrl.h

Abstract:

	SIS Groveler controller primary include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_GROVCTRL

#define _INC_GROVCTRL

typedef int (* Function)(int, int, _TCHAR **);

struct Action
{
	_TCHAR *arg;
	int min_character_count;
	Function function;
	int flag;
	_TCHAR *help;
};

enum {CTRL_stop, CTRL_pause, CTRL_continue};
enum {CMD_foreground, CMD_background, CMD_volscan};

int install_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int remove_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int set_service_interaction(
	int interactive,
	int argc,
	_TCHAR **argv);
int start_service(
	int dummy,
	int argc,
	_TCHAR **argv);
int control_service(
	int control,
	int argc,
	_TCHAR **argv);
int command_service(
	int command,
	int argc,
	_TCHAR **argv);
int load_counters();
int unload_counters();

#endif	/* _INC_GROVCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\grovctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovctrl.cpp

Abstract:

	SIS Groveler controller main function

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR *service_name = _T("Groveler");
static _TCHAR *service_path = _T("%SystemRoot%\\System32\\grovel.exe");

static const int num_actions = 11;

static Action actions[num_actions] =
{
	{_T("background"),	1,	command_service,			CMD_background,	_T(" [drive_letter ...]")},
	{_T("continue"),	1,	control_service,			CTRL_continue,	_T("")},
	{_T("foreground"),	1,	command_service,			CMD_foreground,	_T(" [drive_letter ...]")},
	{_T("install"),		3,	install_service,			0,				_T("")},
	{_T("interact"),	3,	set_service_interaction,	TRUE,			_T("")},
	{_T("nointeract"),	1,	set_service_interaction,	FALSE,			_T("")},
	{_T("pause"),		1,	control_service,			CTRL_pause,		_T("")},
	{_T("remove"),		1,	remove_service,				0,				_T("")},
	{_T("start"),		3,	start_service,				0,				_T("")},
	{_T("stop"),		3,	control_service,			CTRL_stop,		_T("")},
	{_T("volscan"),		1,	command_service,			CMD_volscan,	_T(" [drive_letter ...]")}
};

static const int perf_value_count = 4;

static _TCHAR *perf_tags[perf_value_count] =
{
	_T("Library"),
	_T("Open"),
	_T("Collect"),
	_T("Close")
};

static _TCHAR *perf_values[perf_value_count] =
{
	_T("grovperf.dll"),
	_T("OpenGrovelerPerformanceData"),
	_T("CollectGrovelerPerformanceData"),
	_T("CloseGrovelerPerformanceData")
};

void
usage(
	_TCHAR *progname,
	_TCHAR *prefix = 0)
{
	int prefixlen;
	if (prefix == 0)
	{
		prefixlen = 0;
		_ftprintf(stderr, _T("usage:\n"));
	}
	else
	{
		prefixlen = _tcslen(prefix);
		_ftprintf(stderr, _T("unrecognized or ambiguous command: %s\n"),
			prefix);
	}
	for (int index = 0; index < num_actions; index++)
	{
		_TCHAR *arg = actions[index].arg;
		int min_chars = actions[index].min_character_count;
		if (_tcsncicmp(prefix, arg, prefixlen) == 0)
		{
			_ftprintf(stderr, _T("\t%s %.*s[%s]%s\n"), progname, min_chars,
				arg, &arg[min_chars], actions[index].help);
		}
	}
}

void
display_error(
	DWORD err = 0)
{
	void *buffer = 0;
	if (err == 0)
	{
		err = GetLastError();
	}
	DWORD lang = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
	DWORD result = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM
		| FORMAT_MESSAGE_IGNORE_INSERTS, 0, err, lang, (LPTSTR) &buffer, 0, 0);
	if (result != 0)
	{
		ASSERT(buffer != 0);
		_ftprintf(stderr, (_TCHAR *)buffer);
	}
	else
	{
		_ftprintf(stderr, _T("error number = %d\n"), err);
	}
	if (buffer != 0)
	{
		LocalFree(buffer);
	}
}

extern "C" __cdecl _tmain(int argc, _TCHAR **argv)
{
	if (argc < 2)
	{
		usage(argv[0]);
		return 1;
	}
	int arglen = _tcslen(argv[1]);
	for (int index = 0; index < num_actions; index++)
	{
		if (arglen >= actions[index].min_character_count &&
			_tcsncicmp(argv[1], actions[index].arg, arglen) == 0)
		{
			break;
		}
	}
	if (index < num_actions)
	{
		Function function = actions[index].function;
		int flag = actions[index].flag;
		ASSERT(function != 0);
		int exit_code = (*function)(flag, argc - 2, &argv[2]);
		return exit_code;
	}
	else
	{
		usage(argv[0], argv[1]);
		return 1;
	}
}

int
install_service(
	int dummy,
	int argc,
	_TCHAR **argv)
{
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_HANDLE service = CreateService(sc_manager, service_name,
		service_name, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, service_path,
		0, 0, 0, 0, 0);
	if (service == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	_ftprintf(stderr, _T("Service installed\n"));
	CloseServiceHandle(service);
	CloseServiceHandle(sc_manager);
#if DBG
	load_counters();
#endif // DBG
	return 0;
}

int remove_service(
	int dummy,
	int argc,
	_TCHAR **argv)
{
#if DBG
	unload_counters();
#endif // DBG
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_HANDLE service =
		OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
	if (service == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	SERVICE_STATUS status;
	int ok = QueryServiceStatus(service, &status);
	if (ok && status.dwCurrentState != SERVICE_STOPPED)
	{
		ok = ControlService(service, SERVICE_CONTROL_STOP, &status);
		while (ok && status.dwCurrentState == SERVICE_STOP_PENDING)
		{
			Sleep(100);
			ok = QueryServiceStatus(service, &status);
		}
		if (!ok)
		{
			display_error();
			CloseServiceHandle(service);
			CloseServiceHandle(sc_manager);
			return 1;
		}
		else if (status.dwCurrentState != SERVICE_STOPPED)
		{
			_ftprintf(stderr,
				_T("Unable to stop service\nService not removed\n"));
			CloseServiceHandle(service);
			CloseServiceHandle(sc_manager);
			return 1;
		}
	}
	ok = DeleteService(service);
	if (!ok)
	{
		display_error();
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	_ftprintf(stderr, _T("Service removed\n"));
	CloseServiceHandle(service);
	CloseServiceHandle(sc_manager);
	return 0;
}

int
set_service_interaction(
	int interactive,
	int argc,
	_TCHAR **argv)
{
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_LOCK sc_lock = LockServiceDatabase(sc_manager);
	if (sc_lock == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	SC_HANDLE service =
		OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
	if (service == 0)
	{
		display_error();
		UnlockServiceDatabase(sc_lock);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	DWORD service_type = SERVICE_WIN32_OWN_PROCESS;
	if (interactive)
	{
		service_type |= SERVICE_INTERACTIVE_PROCESS;
	}
	int ok = ChangeServiceConfig(service, service_type,
		SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, 0, 0, 0, 0, 0, 0, 0);
	if (!ok)
	{
		display_error();
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	if (interactive)
	{
		_ftprintf(stderr, _T("Service configured for interaction\n"));
	}
	else
	{
		_ftprintf(stderr, _T("Service configured for no interaction\n"));
	}
	CloseServiceHandle(service);
	UnlockServiceDatabase(sc_lock);
	CloseServiceHandle(sc_manager);
	return 0;
}

int start_service(
	int dummy,
	int argc,
	_TCHAR **argv)
{
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_HANDLE service =
		OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
	if (service == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	SERVICE_STATUS status;
	int ok = StartService(service, 0, 0);
	if (!ok)
	{
		display_error();
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	ok = QueryServiceStatus(service, &status);
	while (ok && status.dwCurrentState == SERVICE_START_PENDING)
	{
		Sleep(100);
		ok = QueryServiceStatus(service, &status);
	}
	if (!ok)
	{
		display_error();
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	else if (status.dwCurrentState != SERVICE_RUNNING)
	{
		_ftprintf(stderr, _T("Service not started"));
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	_ftprintf(stderr, _T("Service started\n"));
	CloseServiceHandle(service);
	CloseServiceHandle(sc_manager);
	return 0;
}

int control_service(
	int control,
	int argc,
	_TCHAR **argv)
{
	DWORD control_code;
	DWORD pending_state;
	DWORD target_state;
	_TCHAR *good_message;
	_TCHAR *bad_message;
	switch (control)
	{
	case CTRL_stop:
		control_code = SERVICE_CONTROL_STOP;
		pending_state = SERVICE_STOP_PENDING;
		target_state = SERVICE_STOPPED;
		good_message = _T("Service stopped\n");
		bad_message = _T("Service not stopped\n");
		break;
	case CTRL_pause:
		control_code = SERVICE_CONTROL_PAUSE;
		pending_state = SERVICE_PAUSE_PENDING;
		target_state = SERVICE_PAUSED;
		good_message = _T("Service paused\n");
		bad_message = _T("Service not paused\n");
		break;
	case CTRL_continue:
		control_code = SERVICE_CONTROL_CONTINUE;
		pending_state = SERVICE_CONTINUE_PENDING;
		target_state = SERVICE_RUNNING;
		good_message = _T("Service continued\n");
		bad_message = _T("Service not continued\n");
		break;
	default:
		return 1;
	}
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_HANDLE service =
		OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
	if (service == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	SERVICE_STATUS status;
	int ok = ControlService(service, control_code, &status);
	while (ok && status.dwCurrentState == pending_state)
	{
		Sleep(100);
		ok = QueryServiceStatus(service, &status);
	}
	if (!ok)
	{
		display_error();
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	else if (status.dwCurrentState != target_state)
	{
		_ftprintf(stderr, bad_message);
		CloseServiceHandle(service);
		CloseServiceHandle(sc_manager);
		return 1;
	}
	_ftprintf(stderr, good_message);
	CloseServiceHandle(service);
	CloseServiceHandle(sc_manager);
	return 0;
}

int command_service(
	int command,
	int argc,
	_TCHAR **argv)
{
	DWORD control_code;
	_TCHAR *message;
	switch (command)
	{
	case CMD_foreground:
		control_code = SERVICE_CONTROL_FOREGROUND;
		message = _T("Service mode set to foreground");
		break;
	case CMD_background:
		control_code = SERVICE_CONTROL_BACKGROUND;
		message = _T("Service mode set to background");
		break;
	case CMD_volscan:
		control_code = SERVICE_CONTROL_VOLSCAN;
		message = _T("Volume scan initiated");
		break;
	default:
		return 1;
	}
	SC_HANDLE sc_manager = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (sc_manager == 0)
	{
		display_error();
		return 1;
	}
	SC_HANDLE service =
		OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS);
	if (service == 0)
	{
		display_error();
		CloseServiceHandle(sc_manager);
		return 1;
	}
	int exit_code = 0;
	SERVICE_STATUS status;
	if (argc > 0)
	{
		for (int index = 0; index < argc; index++)
		{
			_TCHAR drive_letter = argv[index][0];
			ASSERT(drive_letter != 0);
			if (drive_letter >= _T('a') && drive_letter <= _T('z')
				|| drive_letter >= _T('A') && drive_letter <= _T('Z'))
			{
				DWORD drive_spec = SERVICE_CONTROL_PARTITION_MASK &
					(DWORD)(_totlower(drive_letter) - _T('a'));
				int ok = ControlService(service,
					control_code | drive_spec, &status);
				if (ok)
				{
					_ftprintf(stderr, _T("%s on drive %c\n"),
						message, drive_letter);
				}
				else
				{
					display_error();
					exit_code++;
				}
			}
			else
			{
				_ftprintf(stderr, _T("Invalid drive letter: %c\n"),
					drive_letter);
				exit_code++;
			}
		}
	}
	else
	{
		int ok = ControlService(service,
			control_code | SERVICE_CONTROL_ALL_PARTITIONS, &status);
		if (ok)
		{
			_ftprintf(stderr, _T("%s on all drives\n"), message);
		}
		else
		{
			display_error();
			exit_code++;
		}
	}
	CloseServiceHandle(service);
	CloseServiceHandle(sc_manager);
	return 0;
}

int load_counters()
{
	HKEY grovperf_key = 0;
	HKEY perflib_key = 0;
	_TCHAR grovperf_path[1024];
	_stprintf(grovperf_path,
		_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
		service_name);
	bool ok = Registry::write_string_set(HKEY_LOCAL_MACHINE, grovperf_path,
		perf_value_count, perf_values, perf_tags);
	if (!ok)
	{
		display_error();
		_ftprintf(stderr, _T("Unable to configure performance counters\n"));
		return 1;
	}
	_ftprintf(stderr, _T("Adding counter names and explain text for %s\n"),
		service_name);
	try
	{
		Registry::open_key_ex(HKEY_LOCAL_MACHINE, grovperf_path, 0,
			KEY_ALL_ACCESS, &grovperf_key);
		Registry::open_key_ex(HKEY_LOCAL_MACHINE,
			_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"),
			0, KEY_ALL_ACCESS, &perflib_key);
		DWORD last_counter = 0;
		DWORD ctr_size = sizeof(DWORD);
		Registry::query_value_ex(perflib_key, _T("Last Counter"), 0, 0,
			(BYTE *)&last_counter, &ctr_size);
		DWORD last_help = 0;
		ctr_size = sizeof(DWORD);
		Registry::query_value_ex(perflib_key, _T("Last Help"), 0, 0,
			(BYTE *)&last_help, &ctr_size);
		DWORD current_counter;
		DWORD current_help;
		for (int language = 0; language < num_languages; language++)
		{
			HKEY lang_key = 0;
			BYTE *counter_text = 0;
			BYTE *help_text = 0;
			try
			{
				Registry::open_key_ex(perflib_key, language_codes[language], 0,
					KEY_ALL_ACCESS, &lang_key);
				DWORD ctr_size;
				Registry::query_value_ex(lang_key, _T("Counter"), 0, 0, 0,
					&ctr_size);
				counter_text =
					new BYTE[ctr_size + num_perf_counters * 64];
				Registry::query_value_ex(lang_key, _T("Counter"), 0, 0,
					counter_text, &ctr_size);
				DWORD help_size;
				Registry::query_value_ex(lang_key, _T("Help"), 0, 0, 0,
					&help_size);
				help_text = new BYTE[help_size + num_perf_counters * 256];
				Registry::query_value_ex(lang_key, _T("Help"), 0, 0,
					help_text, &help_size);
				current_counter = last_counter;
				current_help = last_help;
				_TCHAR *counter_point =
					(_TCHAR *)(counter_text + ctr_size - sizeof(_TCHAR));
				_TCHAR *help_point =
					(_TCHAR *)(help_text + help_size - sizeof(_TCHAR));
				current_counter += 2;
				int chars_written =
					_stprintf(counter_point, _T("%d%c%s%c"), current_counter,
					0, object_info.text[language].counter_name, 0);
				counter_point += chars_written;
				ctr_size += chars_written * sizeof(_TCHAR);
				current_help += 2;
				chars_written =
					_stprintf(help_point, _T("%d%c%s%c"), current_help, 0,
					object_info.text[language].counter_help, 0);
				help_point += chars_written;
				help_size += chars_written * sizeof(_TCHAR);
				for (int index = 0; index < num_perf_counters; index++)
				{
					current_counter += 2;
					chars_written = _stprintf(counter_point, _T("%d%c%s%c"),
						current_counter, 0,
						counter_info[index].text[language].counter_name, 0);
					counter_point += chars_written;
					ctr_size += chars_written * sizeof(_TCHAR);
					current_help += 2;
					chars_written = _stprintf(help_point, _T("%d%c%s%c"),
						current_help, 0,
						counter_info[index].text[language].counter_help, 0);
					help_point += chars_written;
					help_size += chars_written * sizeof(_TCHAR);
				}
				Registry::set_value_ex(lang_key, _T("Counter"), 0,
					REG_MULTI_SZ, counter_text, ctr_size);
				Registry::set_value_ex(lang_key, _T("Help"), 0,
					REG_MULTI_SZ, help_text, help_size);
				delete[] counter_text;
				delete[] help_text;
				RegCloseKey(lang_key);
				lang_key = 0;
				_ftprintf(stderr, _T("Updating text for language %s\n"),
					language_codes[language]);
			}
			catch (DWORD)
			{
				if (counter_text != 0)
				{
					delete[] counter_text;
					counter_text = 0;
				}
				if (help_text != 0)
				{
					delete[] help_text;
					help_text = 0;
				}
				if (lang_key != 0)
				{
					RegCloseKey(lang_key);
					lang_key = 0;
				}
			}
		}
		Registry::set_value_ex(perflib_key, _T("Last Counter"), 0, REG_DWORD,
			(BYTE *)&current_counter, sizeof(DWORD));
		Registry::set_value_ex(perflib_key, _T("Last Help"), 0, REG_DWORD,
			(BYTE *)&current_help, sizeof(DWORD));
		DWORD first_counter = last_counter + 2;
		DWORD first_help = last_help + 2;
		Registry::set_value_ex(grovperf_key, _T("First Counter"), 0, REG_DWORD,
			(BYTE *)&first_counter, sizeof(DWORD));
		Registry::set_value_ex(grovperf_key, _T("First Help"), 0, REG_DWORD,
			(BYTE *)&first_help, sizeof(DWORD));
		Registry::set_value_ex(grovperf_key, _T("Last Counter"), 0, REG_DWORD,
			(BYTE *)&current_counter, sizeof(DWORD));
		Registry::set_value_ex(grovperf_key, _T("Last Help"), 0, REG_DWORD,
			(BYTE *)&current_help, sizeof(DWORD));
		Registry::close_key(grovperf_key);
		grovperf_key = 0;
		Registry::close_key(perflib_key);
		perflib_key = 0;
	}
	catch (DWORD)
	{
		if (grovperf_key != 0)
		{
			RegCloseKey(grovperf_key);
			grovperf_key = 0;
		}
		if (perflib_key != 0)
		{
			RegCloseKey(perflib_key);
			perflib_key = 0;
		}
		_ftprintf(stderr, _T("Unable to configure performance counters\n"));
		return 1;
	}
	return 0;
}

int unload_counters()
{
	STARTUPINFO startupinfo;
	PROCESS_INFORMATION process_information;
	startupinfo.cb = sizeof(STARTUPINFO);
	startupinfo.lpReserved = 0;
	startupinfo.lpDesktop = 0;
	startupinfo.lpTitle = 0;
	startupinfo.dwFlags = 0;
	startupinfo.cbReserved2 = 0;
	startupinfo.lpReserved2 = 0;
	int pathlen = GetSystemDirectory(0, 0);
	if (pathlen == 0)
	{
		display_error();
		return 1;
	}
	_TCHAR *command_line = new _TCHAR[pathlen + 64];
	pathlen = GetSystemDirectory(command_line, pathlen);
	if (pathlen == 0)
	{
		delete[] command_line;
		display_error();
		return 1;
	}
	_stprintf(&command_line[pathlen], _T("\\unlodctr.exe \"%s\""),
		service_name);
	BOOL ok = CreateProcess(0, command_line,
		0, 0, FALSE, 0, 0, 0, &startupinfo, &process_information);
	if (!ok)
	{
		delete[] command_line;
		display_error();
		return 1;
	}
	delete[] command_line;
	DWORD result = WaitForSingleObject(process_information.hProcess, 5000);
	_tprintf(_T("\n"));
	if (result != WAIT_OBJECT_0)
	{
		return 1;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\filter.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    filter.cpp

Abstract:

	SIS Groveler temporal filter classes

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

TemporalFilter::TemporalFilter(
	unsigned int time_constant,
	double initial_value)
{
	ASSERT(this != 0);
	this->time_constant = double(time_constant);
	ASSERT(this->time_constant > 0.0);
	filtered_value = initial_value;
	update_time = GET_TICK_COUNT();
}

void
TemporalFilter::reset(
	double reset_value)
{
	ASSERT(this != 0);
	filtered_value = reset_value;
	update_time = GET_TICK_COUNT();
}

void
TemporalFilter::update_value(
	double value)
{
	ASSERT(this != 0);
	ASSERT(time_constant > 0.0);
	unsigned int current_time = GET_TICK_COUNT();
	unsigned int elapsed_time = current_time - update_time;
	ASSERT(signed(elapsed_time) >= 0);
	double coefficient = 1.0 - exp(-double(elapsed_time)/time_constant);
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient <= 1.0);
	filtered_value += coefficient * (value - filtered_value);
	update_time = current_time;
}

double
TemporalFilter::retrieve_value() const
{
	ASSERT(this != 0);
	return filtered_value;
}

DirectedTemporalFilter::DirectedTemporalFilter(
	unsigned int increase_time_constant,
	unsigned int decrease_time_constant,
	double initial_value)
{
	ASSERT(this != 0);
	this->increase_time_constant = double(increase_time_constant);
	this->decrease_time_constant = double(decrease_time_constant);
	ASSERT(this->increase_time_constant > 0.0);
	ASSERT(this->decrease_time_constant > 0.0);
	filtered_value = initial_value;
	update_time = GET_TICK_COUNT();
}

void
DirectedTemporalFilter::reset(
	double reset_value)
{
	ASSERT(this != 0);
	filtered_value = reset_value;
	update_time = GET_TICK_COUNT();
}

void
DirectedTemporalFilter::update_value(
	double value)
{
	ASSERT(this != 0);
	ASSERT(increase_time_constant > 0.0);
	ASSERT(decrease_time_constant > 0.0);
	unsigned int current_time = GET_TICK_COUNT();
	unsigned int elapsed_time = current_time - update_time;
	ASSERT(signed(elapsed_time) >= 0);
	double coefficient;
	if(value > filtered_value)
	{
		coefficient = 1.0 - exp(-double(elapsed_time)/increase_time_constant);
	}
	else
	{
		coefficient = 1.0 - exp(-double(elapsed_time)/decrease_time_constant);
	}
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient <= 1.0);
	filtered_value += coefficient * (value - filtered_value);
	update_time = current_time;
}

double
DirectedTemporalFilter::retrieve_value() const
{
	ASSERT(this != 0);
	return filtered_value;
}

IncidentFilter::IncidentFilter(
	int mean_history_length,
	double initial_value)
{
	ASSERT(this != 0);
	ASSERT(mean_history_length > 0);
	coefficient = 1.0 - exp(-1.0 / double(mean_history_length));
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient < 1.0);
	filtered_value = initial_value;
}

void
IncidentFilter::reset(
	double reset_value)
{
	ASSERT(this != 0);
	filtered_value = reset_value;
}

void
IncidentFilter::update_value(
	double value)
{
	ASSERT(this != 0);
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient < 1.0);
	filtered_value += coefficient * (value - filtered_value);
}

void
IncidentFilter::update_value(
	double value,
	int weight)
{
	ASSERT(this != 0);
	ASSERT(coefficient >= 0.0);
	ASSERT(coefficient < 1.0);
	ASSERT(weight >= 0);
	double weighted_coefficient = 1.0 - pow(1.0 - coefficient, double(weight));
	ASSERT(weighted_coefficient >= 0.0);
	ASSERT(weighted_coefficient <= 1.0);
	filtered_value += weighted_coefficient * (value - filtered_value);
}

double
IncidentFilter::retrieve_value() const
{
	ASSERT(this != 0);
	return filtered_value;
}

DirectedIncidentFilter::DirectedIncidentFilter(
	int increase_mean_history_length,
	int decrease_mean_history_length,
	double initial_value)
{
	ASSERT(this != 0);
	ASSERT(increase_mean_history_length > 0);
	ASSERT(decrease_mean_history_length > 0);
	increase_coefficient =
		1.0 - exp(-1.0 / double(increase_mean_history_length));
	ASSERT(increase_coefficient >= 0.0);
	ASSERT(increase_coefficient < 1.0);
	decrease_coefficient =
		1.0 - exp(-1.0 / double(decrease_mean_history_length));
	ASSERT(decrease_coefficient >= 0.0);
	ASSERT(decrease_coefficient < 1.0);
	filtered_value = initial_value;
}

void
DirectedIncidentFilter::reset(
	double reset_value)
{
	ASSERT(this != 0);
	filtered_value = reset_value;
}

void
DirectedIncidentFilter::update_value(
	double value)
{
	ASSERT(this != 0);
	if(value > filtered_value)
	{
		ASSERT(increase_coefficient >= 0.0);
		ASSERT(increase_coefficient < 1.0);
		filtered_value += increase_coefficient * (value - filtered_value);
	}
	else
	{
		ASSERT(decrease_coefficient >= 0.0);
		ASSERT(decrease_coefficient < 1.0);
		filtered_value += decrease_coefficient * (value - filtered_value);
	}
}

void
DirectedIncidentFilter::update_value(
	double value,
	int weight)
{
	ASSERT(this != 0);
	ASSERT(weight >= 0);
	double weighted_coefficient;
	if(value > filtered_value)
	{
		ASSERT(increase_coefficient >= 0.0);
		ASSERT(increase_coefficient < 1.0);
		weighted_coefficient =
			1.0 - pow(1.0 - increase_coefficient, double(weight));
	}
	else
	{
		ASSERT(decrease_coefficient >= 0.0);
		ASSERT(decrease_coefficient < 1.0);
		weighted_coefficient =
			1.0 - pow(1.0 - decrease_coefficient, double(weight));
	}
	ASSERT(weighted_coefficient >= 0.0);
	ASSERT(weighted_coefficient <= 1.0);
	filtered_value += weighted_coefficient * (value - filtered_value);
}

double
DirectedIncidentFilter::retrieve_value() const
{
	ASSERT(this != 0);
	return filtered_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\grovperf.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovperf.h

Abstract:

	SIS Groveler performance DLL primary include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_GROVPERF

#define _INC_GROVPERF

#define WIN32_LEAN_AND_MEAN 1

extern "C" DWORD CALLBACK OpenGrovelerPerformanceData(LPWSTR lpDeviceNames);

extern "C" DWORD WINAPI CloseGrovelerPerformanceData();

extern "C" DWORD WINAPI CollectGrovelerPerformanceData(
	LPWSTR lpwszValue,
	LPVOID *lppData,
    LPDWORD lpcbBytes,
	LPDWORD lpcObjectTypes);

int space_needed_for_data(
	int num_partitions);

void build_part_object_info_block(
	LPVOID *lppData,
	int num_partitions,
	int data_size);

void build_part_instance_info_block(
	LPVOID *lppData,
	int partition_index,
	SharedDataRecord *records);

void build_total_instance_info_block(
	LPVOID *lppData,
	int num_partitions,
	SharedDataRecord *records);

#pragma pack (8)

const int partition_name_length = 32;
const int total_name_length = 7;

struct PartitionData
{
	PERF_COUNTER_BLOCK counter_block;
	LARGE_INTEGER counter[num_perf_counters];
};

struct PartitionObjectInformationBlock
{
	PERF_OBJECT_TYPE object_type;
	PERF_COUNTER_DEFINITION definition[num_perf_counters];
};

struct PartitionInstanceInformationBlock
{
	PERF_INSTANCE_DEFINITION instance_def;
	_TCHAR instance_name[partition_name_length];
	PartitionData partition_data;
};

struct TotalInstanceInformationBlock
{
	PERF_INSTANCE_DEFINITION instance_def;
	_TCHAR instance_name[total_name_length];
	PartitionData partition_data;
};

#pragma pack ()

#endif	/* _INC_GROVPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\groveler.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    groveler.cpp

Abstract:

    SIS Groveler file groveling functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

#define CLEAR_FILE(FILE) ( \
    (FILE).entry.fileID           = 0, \
    (FILE).entry.fileSize         = 0, \
    (FILE).entry.signature        = 0, \
    (FILE).entry.attributes       = 0, \
    (FILE).entry.csIndex          = nullCSIndex, \
    (FILE).entry.createTime       = 0, \
    (FILE).entry.writeTime        = 0, \
    (FILE).parentID               = 0, \
    (FILE).retryTime              = 0, \
    (FILE).startTime              = 0, \
    (FILE).stopTime               = 0, \
    (FILE).readSynch.Internal     = 0, \
    (FILE).readSynch.InternalHigh = 0, \
    (FILE).readSynch.Offset       = 0, \
    (FILE).readSynch.OffsetHigh   = 0, \
    (FILE).fileName[0]            = _T('\0') )

#define CLEAR_OVERLAPPED(OVERLAPPED) ( \
    (OVERLAPPED).Internal     = 0, \
    (OVERLAPPED).InternalHigh = 0, \
    (OVERLAPPED).Offset       = 0, \
    (OVERLAPPED).OffsetHigh   = 0 )

// Is CS index set?

static const CSID nullCSIndex = {
    0, 0, 0,
    _T('\0'), _T('\0'), _T('\0'), _T('\0'),
    _T('\0'), _T('\0'), _T('\0'), _T('\0')
};

#define HasCSIndex(CSID) \
    (memcmp(&(CSID), &nullCSIndex, sizeof(CSID)) != 0)

#define SameCSIndex(CSID1, CSID2) \
    (memcmp(&(CSID1), &(CSID2), sizeof(CSID)) == 0)

// Exceptions

enum TerminalException {
    INITIALIZE_ERROR,
    DATABASE_ERROR,
    MEMORY_ERROR,
    TERMINATE
};

enum TargetException {
    TARGET_INVALID,
    TARGET_ERROR
};

enum MatchException {
    MATCH_INVALID,
    MATCH_ERROR,
    MATCH_STALE
};

/*****************************************************************************/
/************************** Miscellaneous functions **************************/
/*****************************************************************************/

// NewHandler() is installed by _set_new_handler() to throw an
// exception when the system can't allocate any more memory.

static INT __cdecl NewHandler(size_t size)
{
    throw MEMORY_ERROR;
    return 0; // Dummy return
}

/*****************************************************************************/

// FileIDCompare() is used by qsort() and bsearch()
// to sort or look up a matching file ID.

static INT __cdecl FileIDCompare(
    const VOID *id1,
    const VOID *id2)
{
    DWORDLONG fileID1 = *(DWORDLONG *)id1,
              fileID2 = *(DWORDLONG *)id2;

    return fileID1 < fileID2 ? -1
         : fileID1 > fileID2 ? +1
         :                      0;
}

/*****************************************************************************/

// qsStringCompare() is used by qsort() to sort an array of character strings.

static INT __cdecl qsStringCompare(
    const VOID *str1,
    const VOID *str2)
{
    return _tcsicmp(*(TCHAR **)str1, *(TCHAR **)str2);
}

/*****************************************************************************/

// bsStringCompare() is used by bsearch() look up a matching character string.
// It is assumed that str1 is the path name string we are searching for and
// str2 is the excluded path name string in the excluded paths list.  Note
// that if the excluded path is \a\b, then we return a match on anything that
// is in this directory or subdirectory, as well as an exact match.
// E.g.:  \a\b\c\d.foo & \a\b\foo will match, but \a\b.foo will not.

static INT __cdecl bsStringCompare(
    const VOID *str1,
    const VOID *str2)
{
    TCHAR *s1 = *(TCHAR **) str1;
    TCHAR *s2 = *(TCHAR **) str2;

// str2 is the excluded name.  Make sure we catch subdirectories under it,
// but make sure we don't confuse \a\bx with \a\b

    size_t l = _tcslen(s2);
    INT r = _tcsnicmp(s1, s2, l);

    if (0 == r)
        if (_tcslen(s1) > l && _T('\\') != s1[l])
            r = 1;

    return r;
}

/*****************************************************************************/
/********************** Groveler class private methods ***********************/
/*****************************************************************************/

// IsAllowedID() returns FALSE if the directory or file ID
// is on the list of disallowed IDs, and TRUE otherwise.

BOOL Groveler::IsAllowedID(DWORDLONG fileID) const
{
    ASSERT(fileID != 0);

    if (numDisallowedIDs == 0) {
        ASSERT(disallowedIDs == NULL);
        return TRUE;
    }

    ASSERT(disallowedIDs != NULL);
    return bsearch(
        &fileID,
        disallowedIDs,
        numDisallowedIDs,
        sizeof(DWORDLONG),
        FileIDCompare) == NULL;
}

/*****************************************************************************/

// IsAllowedName() returns FALSE if the directory or file name
// is on the list of disallowed names, and TRUE otherwise.

BOOL Groveler::IsAllowedName(TCHAR *fileName) const
{
    ASSERT(fileName != NULL);

    if (numDisallowedNames == 0) {
        ASSERT(disallowedNames == NULL);
        return TRUE;
    }

    ASSERT(disallowedNames != NULL);
    return bsearch(
        &fileName,
        disallowedNames,
        numDisallowedNames,
        sizeof(TCHAR *),
        bsStringCompare) == NULL;
}

/*****************************************************************************/

// WaitForEvent suspends the thread until the specified event is set.

VOID Groveler::WaitForEvent(HANDLE event)
{
    DWORD eventNum;

    BOOL success;

    ASSERT(event != NULL);

    eventNum = WaitForSingleObject(event, INFINITE);
    ASSERT_ERROR(eventNum == WAIT_OBJECT_0);

    success = ResetEvent(event);
    ASSERT_ERROR(success);
}

/*****************************************************************************/

// OpenFileByID() opens the file with the given volumeHandle and fileID.

BOOL Groveler::OpenFileByID(
    FileData *file,
    BOOL      writeEnable)
{
    UNICODE_STRING fileIDString;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS ntStatus;

    ASSERT(volumeHandle       != NULL);
    ASSERT(file               != NULL);
    ASSERT(file->entry.fileID != 0);
    ASSERT(file->handle       == NULL);

    fileIDString.Length        = sizeof(DWORDLONG);
    fileIDString.MaximumLength = sizeof(DWORDLONG);
    fileIDString.Buffer        = (WCHAR *)&file->entry.fileID;

    objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
    objectAttributes.RootDirectory            = volumeHandle;
    objectAttributes.ObjectName               = &fileIDString;
    objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
    objectAttributes.SecurityDescriptor       = NULL;
    objectAttributes.SecurityQualityOfService = NULL;

    ntStatus = NtCreateFile(
        &file->handle,
        GENERIC_READ |
        (writeEnable ? GENERIC_WRITE : 0),
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        0,
        FILE_SHARE_READ   |
        FILE_SHARE_DELETE |
        (writeEnable ? FILE_SHARE_WRITE : 0),
        FILE_OPEN,
        FILE_OPEN_BY_FILE_ID    |
        FILE_OPEN_REPARSE_POINT |
        FILE_NO_INTERMEDIATE_BUFFERING,
        NULL,
        0);

    if (ntStatus == STATUS_SUCCESS) {
        DWORD bytesReturned;
        MARK_HANDLE_INFO markHandleInfo =
            {USN_SOURCE_DATA_MANAGEMENT, volumeHandle, 0};

// Mark the handle so the usn entry for the merge operation (if completed)
// can be detected and skipped.

        BOOL rc = DeviceIoControl(
                    file->handle,
                    FSCTL_MARK_HANDLE,
                    &markHandleInfo,
                    sizeof markHandleInfo,
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);

        if (!rc) {
            DPRINTF((_T("%s: FSCTL_MARK_HANDLE failed, %lu\n"),
                driveLetterName, GetLastError()));
        }

#if DBG

// Get the file name

        ASSERT(file->fileName[0] == _T('\0'));

        struct TFileName2 {
            ULONG nameLen;
            TCHAR name[MAX_PATH+1];
        } tFileName[1];

        ntStatus = NtQueryInformationFile(
            file->handle,
            &ioStatusBlock,
            tFileName,
            sizeof tFileName,
            FileNameInformation);

        if (ntStatus == STATUS_SUCCESS) {
            int c = min(MAX_PATH, tFileName->nameLen / sizeof(TCHAR));
            memcpy(file->fileName, tFileName->name, c * sizeof(TCHAR));
            file->fileName[c] = _T('\0');
        } else {
            memcpy(file->fileName, _T("<unresolved name>"), 18 * sizeof(TCHAR));
        }
#endif

        return TRUE;
    }

    ASSERT(file->handle == NULL);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return FALSE;
}

/*****************************************************************************/

// OpenFileByName() opens the file with the given fileName.

BOOL Groveler::OpenFileByName(
    FileData *file,
    BOOL      writeEnable,
    TCHAR    *fileName)
{
    UNICODE_STRING dosPathName,
                   ntPathName;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS ntStatus;

    ASSERT(file         != NULL);
    ASSERT(file->handle == NULL);

    if (fileName == NULL)
        fileName = file->fileName;
    ASSERT(fileName[0] != _T('\0'));

#ifdef _UNICODE
    dosPathName.Buffer = fileName;
#else
    if (!RtlCreateUnicodeStringFromAsciiz(&dosPathName, fileName)) {
        ntStatus = STATUS_NO_MEMORY;
        goto Error;
    }
#endif

    if (RtlDosPathNameToNtPathName_U(dosPathName.Buffer, &ntPathName, NULL, NULL)) {

        objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
        objectAttributes.RootDirectory            = NULL;
        objectAttributes.ObjectName               = &ntPathName;
        objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
        objectAttributes.SecurityDescriptor       = NULL;
        objectAttributes.SecurityQualityOfService = NULL;

        ntStatus = NtCreateFile(
            &file->handle,
            GENERIC_READ |
            (writeEnable ? GENERIC_WRITE : 0),
            &objectAttributes,
            &ioStatusBlock,
            NULL,
            0,
            FILE_SHARE_READ   |
            FILE_SHARE_DELETE |
            (writeEnable ? FILE_SHARE_WRITE : 0),
            FILE_OPEN,
            FILE_OPEN_REPARSE_POINT |
            FILE_NO_INTERMEDIATE_BUFFERING,
            NULL,
            0);

        RtlFreeUnicodeString(&ntPathName);

    } else {
        ntStatus = STATUS_NO_MEMORY;
    }

#ifndef _UNICODE
    RtlFreeUnicodeString(&dosPathName);
#endif

    if (ntStatus == STATUS_SUCCESS) {
        DWORD bytesReturned;
        MARK_HANDLE_INFO markHandleInfo =
            {USN_SOURCE_DATA_MANAGEMENT, volumeHandle, 0};

// Mark the handle so the usn entry for the merge operation (if completed)
// can be detected and skipped.

        BOOL rc = DeviceIoControl(
                    file->handle,
                    FSCTL_MARK_HANDLE,
                    &markHandleInfo,
                    sizeof markHandleInfo,
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);

        if (!rc) {
            DPRINTF((_T("%s: FSCTL_MARK_HANDLE failed, %lu\n"),
                driveLetterName, GetLastError()));
        }
        return TRUE;
    }

    ASSERT(file->handle == NULL);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return FALSE;
}

/*****************************************************************************/

// IsFileMapped() checks if the file is mapped by another user.

BOOL Groveler::IsFileMapped(FileData *file)
{
    _SIS_LINK_FILES sisLinkFiles;

    DWORD transferCount;

    BOOL success;

    ASSERT(grovHandle != NULL);
    ASSERT(file->handle != NULL);

    sisLinkFiles.operation          = SIS_LINK_FILES_OP_VERIFY_NO_MAP;
    sisLinkFiles.u.VerifyNoMap.file = file->handle;

    success = DeviceIoControl(
        grovHandle,
        FSCTL_SIS_LINK_FILES,
        (VOID *)&sisLinkFiles,
        sizeof(_SIS_LINK_FILES),
        NULL,
        0,
        &transferCount,
        NULL);

    if (success)
        return FALSE;

    ASSERT(GetLastError() == ERROR_SHARING_VIOLATION);
    return TRUE;
}

/*****************************************************************************/

// SetOplock() sets an oplock on the open file.

BOOL Groveler::SetOplock(FileData *file)
{
    BOOL success;

    ASSERT(file                      != NULL);
    ASSERT(file->handle              != NULL);
    ASSERT(file->oplock.Internal     == 0);
    ASSERT(file->oplock.InternalHigh == 0);
    ASSERT(file->oplock.Offset       == 0);
    ASSERT(file->oplock.OffsetHigh   == 0);
    ASSERT(file->oplock.hEvent       != NULL);
    ASSERT(IsReset(file->oplock.hEvent));

    success = DeviceIoControl(
        file->handle,
        FSCTL_REQUEST_BATCH_OPLOCK,
        NULL,
        0,
        NULL,
        0,
        NULL,
        &file->oplock);

    if (success) {
        ASSERT(IsSet(file->oplock.hEvent));
        success = ResetEvent(file->oplock.hEvent);
        ASSERT_ERROR(success);
        CLEAR_OVERLAPPED(file->oplock);
        SetLastError(0);
        return FALSE;
    }

    if (GetLastError() != ERROR_IO_PENDING) {
        ASSERT(IsReset(file->oplock.hEvent));
        CLEAR_OVERLAPPED(file->oplock);
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

// CloseFile() closes the file if it is still open. If an oplock was
// set on the file, it then waits for and resets the oplock break
// event triggered by the closing of the file or by an outside access.

VOID Groveler::CloseFile(FileData *file)
{
    BOOL success;

    ASSERT(file                != NULL);
    ASSERT(file->oplock.hEvent != NULL);

    if (file->handle == NULL) {
        ASSERT(file->oplock.Internal     == 0);
        ASSERT(file->oplock.InternalHigh == 0);
        ASSERT(file->oplock.Offset       == 0);
        ASSERT(file->oplock.OffsetHigh   == 0);
        ASSERT(IsReset(file->oplock.hEvent));
    } else {
        success = CloseHandle(file->handle);
        ASSERT_ERROR(success);
        file->handle = NULL;

        if (file->oplock.Internal     != 0
         || file->oplock.InternalHigh != 0
         || file->oplock.Offset       != 0
         || file->oplock.OffsetHigh   != 0) {
            WaitForEvent(file->oplock.hEvent);
            CLEAR_OVERLAPPED(file->oplock);
        }
    }
}

/*****************************************************************************/

//  CreateDatabase() creates the database.  Initialize it such that if
//  extract_log is called before scan_volume, it will return Grovel_overrun
//  without attempting any USN extraction.  Also, the first time scan_volume
//  is called (with or without start_over), it will know to initialize
//  lastUSN and do a full volume scan.

BOOL Groveler::CreateDatabase(void)
{
    USN_JOURNAL_DATA usnJournalData;

    TFileName tempName;
    TCHAR listValue[17];

    DWORDLONG rootID;

    SGNativeListEntry listEntry;

    LONG num;

    tempName.assign(driveName);
    tempName.append(_T("\\"));

    rootID = GetFileID(tempName.name);
    if (rootID == 0) {
        DPRINTF((_T("%s: CreateDatabase: can't get root directory ID\n"),
            driveLetterName));
        goto Error;
    }

    if (get_usn_log_info(&usnJournalData) != Grovel_ok) {
        DWORD lastError = GetLastError();

        if (lastError == ERROR_JOURNAL_NOT_ACTIVE) {
            DPRINTF((_T("%s: CreateDatabase: journal not active\n"), driveLetterName));
            if (set_usn_log_size(65536) != Grovel_ok ||
                get_usn_log_info(&usnJournalData) != Grovel_ok) {
                DPRINTF((_T("%s: CreateDatabase: can't initialize USN journal\n"),
                    driveLetterName));
                goto Error;
            }
        } else {
            DPRINTF((_T("%s: CreateDatabase: can't initialize last USN\n"),
                driveLetterName));
            goto Error;
        }
    }
    lastUSN = usnJournalData.NextUsn;
    usnID   = usnJournalData.UsnJournalID;

    sgDatabase->Close();
    if (!sgDatabase->Create(databaseName)) {
        DPRINTF((_T("%s: CreateDatabase: can't create database \"%s\": %lu\n"),
            driveLetterName, databaseName));
        goto Error;
    }

    num = sgDatabase->StackPut(rootID, FALSE);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

// Write UNINITIALIZED_USN into the database now, to be replaced when scan_volume
// is complete.  This will be a flag to indicate if the database contents are valid.

    _stprintf(listValue, _T("%016I64x"), UNINITIALIZED_USN);
    listEntry.name  = LAST_USN_NAME;
    listEntry.value = listValue;
    num = sgDatabase->ListWrite(&listEntry);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

    _stprintf(listValue, _T("%016I64x"), usnID);
    listEntry.name  = USN_ID_NAME;
    listEntry.value = listValue;
    num = sgDatabase->ListWrite(&listEntry);
    if (num < 0)
        goto Error;
    ASSERT(num == 1);

    return TRUE;

    Error:

    lastUSN = usnID = UNINITIALIZED_USN;
    return FALSE;
}

/*****************************************************************************/

#define MAX_ACTIONS 5

// DoTransaction() performs the specified operations
// on the database within a single transaction.

VOID Groveler::DoTransaction(
    DWORD               numActions,
    DatabaseActionList *actionList)
{
    DatabaseActionList *action;

    DWORD i;

    LONG num;

    ASSERT(sgDatabase != NULL);
    ASSERT(actionList != NULL);

    if (sgDatabase->BeginTransaction() < 0)
        throw DATABASE_ERROR;

    for (i = 0; i < numActions; i++) {
        action = &actionList[i];
        switch(action->type) {

            case TABLE_PUT:

                ASSERT(action->u.tableEntry != NULL);
                num = sgDatabase->TablePut(action->u.tableEntry);
                ASSERT(num < 0 || num == 1);
                break;

            case TABLE_DELETE_BY_FILE_ID:

                ASSERT(action->u.fileID != 0);
                num = sgDatabase->TableDeleteByFileID(action->u.fileID);
                break;

            case QUEUE_PUT:

                ASSERT(action->u.queueEntry != NULL);
                num = sgDatabase->QueuePut(action->u.queueEntry);
                ASSERT(num < 0 || num == 1);
                if (num == 1)
                    numFilesEnqueued++;
                break;

            case QUEUE_DELETE:

                ASSERT(action->u.queueIndex != 0);
                num = sgDatabase->QueueDelete(action->u.queueIndex);
                ASSERT(num <= 1);
                if (num == 1)
                    numFilesDequeued++;
#if DBG
                else
                    DPRINTF((_T("DoTransaction: QUEUE_DELETE unsuccessful (%d)"), num));
#endif
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("type=%lu\n"), action->type));
        }

        if (num < 0) {
            sgDatabase->AbortTransaction();
            throw DATABASE_ERROR;
        }
    }

    if (!sgDatabase->CommitTransaction()) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }
}

/*****************************************************************************/

// EnqueueCSIndex() deletes all entries with the specified CS index from the
// table and enqueues them to be re-groveled, all within a single transaction.

VOID Groveler::EnqueueCSIndex(CSID *csIndex)
{
    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry oldQueueEntry,
                       newQueueEntry;

    DWORD count;

    LONG num;

    ASSERT(csIndex != NULL);
    ASSERT(HasCSIndex(*csIndex));

    newQueueEntry.parentID  = 0;
    newQueueEntry.reason    = 0;
    newQueueEntry.readyTime = GetTime() + grovelInterval;
    newQueueEntry.retryTime = 0;
    newQueueEntry.fileName  = NULL;

    oldQueueEntry.fileName  = NULL;

    count = 0;

    if (sgDatabase->BeginTransaction() < 0)
        throw DATABASE_ERROR;

    tableEntry.csIndex = *csIndex;
    num = sgDatabase->TableGetFirstByCSIndex(&tableEntry);

    while (num > 0) {
        ASSERT(num == 1);
        count++;

        oldQueueEntry.fileID = tableEntry.fileID;
        num = sgDatabase->QueueGetFirstByFileID(&oldQueueEntry);
        if (num < 0)
            break;
        ASSERT(num == 1);

        if (num == 0) {
            newQueueEntry.fileID = tableEntry.fileID;
            num = sgDatabase->QueuePut(&newQueueEntry);
            if (num < 0)
                break;
            ASSERT(num == 1);
            numFilesEnqueued++;
        }

        num = sgDatabase->TableGetNext(&tableEntry);
    }

    if (num < 0) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }

    num = sgDatabase->TableDeleteByCSIndex(csIndex);
    if (num < 0) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }

    ASSERT(count == (DWORD)num);

    if (!sgDatabase->CommitTransaction()) {
        sgDatabase->AbortTransaction();
        throw DATABASE_ERROR;
    }
}

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define TARGET_READ_DONE    1
#define GROVEL_START        2
#define NUM_EVENTS          3

// SigCheckPoint suspends the thread until the target file completes its read
// operation. If the time allotment expires before the operation completes,
// the grovelStart event is set to signal grovel() to awaken, and this method
// won't return until grovel() sets the grovelStart event. If the file's
// oplock breaks before this method returns, the file will be closed.

VOID Groveler::SigCheckPoint(
    FileData *target,
    BOOL      targetRead)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime;

    BOOL targetOplockBroke     = FALSE,
         waitingForGrovelStart = FALSE,
         success;

    ASSERT(target                   != NULL);
    ASSERT(target->handle           != NULL);
    ASSERT(target->oplock   .hEvent != NULL);
    ASSERT(target->readSynch.hEvent != NULL);
    ASSERT(grovelStartEvent         != NULL);
    ASSERT(grovelStopEvent          != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock   .hEvent;
    events[TARGET_READ_DONE]    = target->readSynch.hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = targetRead ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = targetRead ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!targetRead) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                DPRINTF((_T("%s: target file %s oplock broke during hash\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + TARGET_READ_DONE:

                ASSERT(targetRead);
                targetRead = FALSE;
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                if (targetOplockBroke) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!targetRead) {
                    if (terminate)
                        throw TERMINATE;
                    if (targetOplockBroke)
                        throw TARGET_ERROR;
                    return;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef TARGET_READ_DONE
#undef GROVEL_START
#undef NUM_EVENTS

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define MATCH_OPLOCK_BREAK  1
#define TARGET_READ_DONE    2
#define MATCH_READ_DONE     3
#define GROVEL_START        4
#define NUM_EVENTS          5

// CmpCheckPoint suspends the thread until the target file, the
// match file, or both complete their read operations. If the time
// allotment expires before the operations complete, the grovelStart
// event is set to signal grovel() to awaken, and this method won't
// return until grovel() sets the grovelStart event. If either file's
// oplock breaks before this method returns, the file will be closed.

VOID Groveler::CmpCheckPoint(
    FileData *target,
    FileData *match,
    BOOL      targetRead,
    BOOL      matchRead)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime;

    BOOL targetOplockBroke     = FALSE,
         matchOplockBroke      = FALSE,
         waitingForGrovelStart = FALSE,
         success;

    ASSERT(target                   != NULL);
    ASSERT(match                    != NULL);
    ASSERT(target->handle           != NULL);
    ASSERT(match ->handle           != NULL);
    ASSERT(target->oplock   .hEvent != NULL);
    ASSERT(match ->oplock   .hEvent != NULL);
    ASSERT(target->readSynch.hEvent != NULL);
    ASSERT(match ->readSynch.hEvent != NULL);
    ASSERT(grovelStartEvent         != NULL);
    ASSERT(grovelStopEvent          != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock   .hEvent;
    events[MATCH_OPLOCK_BREAK]  = match ->oplock   .hEvent;
    events[TARGET_READ_DONE]    = target->readSynch.hEvent;
    events[MATCH_READ_DONE]     = match ->readSynch.hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = targetRead || matchRead ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = targetRead || matchRead
                        ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!targetRead) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                DPRINTF((_T("%s: target file %s oplock broke during compare\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + MATCH_OPLOCK_BREAK:

                ASSERT(!matchOplockBroke);
                matchOplockBroke = TRUE;
                success = ResetEvent(match->oplock.hEvent);
                ASSERT_ERROR(success);
                if (!matchRead) {
                    CLEAR_OVERLAPPED(match->oplock);
                    CloseFile(match);
                }
                DPRINTF((_T("%s: match file %s oplock broke during compare\n"),
                    driveLetterName, match->fileName));
                break;

            case WAIT_OBJECT_0 + TARGET_READ_DONE:

                ASSERT(targetRead);
                targetRead = FALSE;
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                if (targetOplockBroke) {
                    CLEAR_OVERLAPPED(target->oplock);
                    CloseFile(target);
                }
                break;

            case WAIT_OBJECT_0 + MATCH_READ_DONE:

                ASSERT(matchRead);
                matchRead = FALSE;
                success = ResetEvent(match->readSynch.hEvent);
                ASSERT_ERROR(success);
                match->stopTime = eventTime;
                if (matchOplockBroke) {
                    CLEAR_OVERLAPPED(match->oplock);
                    CloseFile(match);
                }
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!targetRead && !matchRead) {
                    if (terminate)
                        throw TERMINATE;
                    if (targetOplockBroke)
                        throw TARGET_ERROR;
                    if (matchOplockBroke)
                        throw MATCH_ERROR;
                    return;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef MATCH_OPLOCK_BREAK
#undef TARGET_READ_DONE
#undef MATCH_READ_DONE
#undef GROVEL_START
#undef NUM_EVENTS

/*****************************************************************************/

#define TARGET_OPLOCK_BREAK 0
#define MATCH_OPLOCK_BREAK  1
#define MERGE_DONE          2
#define GROVEL_START        3
#define NUM_EVENTS          4

// MergeCheckPoint suspends the thread until the merge operation is completed.
// If the time allotment expires before the merge is completed, the
// grovelStart event is set to signal grovel() to awaken, and this method
// won't return until grovel() sets the grovelStart event. If either file's
// oplock breaks before the merge is completed, the abortMerge event is set.

BOOL Groveler::MergeCheckPoint(
    FileData   *target,
    FileData   *match,
    OVERLAPPED *mergeSynch,
    HANDLE      abortMergeEvent,
    BOOL        merge)
{
    HANDLE events[NUM_EVENTS];

    DWORD elapsedTime,
          timeOut,
          eventNum,
          eventTime,
          lastError = STATUS_TIMEOUT;

    BOOL targetOplockBroke     = FALSE,
         matchOplockBroke      = FALSE,
         waitingForGrovelStart = FALSE,
         mergeSuccess          = FALSE,
         success;

    ASSERT(target                != NULL);
    ASSERT(target->handle        != NULL);
    ASSERT(target->oplock.hEvent != NULL);

    ASSERT(match                != NULL);
    ASSERT(match->handle        != NULL);
    ASSERT(match->oplock.hEvent != NULL);

    ASSERT(mergeSynch         != NULL);
    ASSERT(mergeSynch->hEvent != NULL);

    ASSERT(abortMergeEvent  != NULL);
    ASSERT(grovelStartEvent != NULL);
    ASSERT(grovelStopEvent  != NULL);

    ASSERT(grovHandle != NULL);

    events[TARGET_OPLOCK_BREAK] = target->oplock.hEvent;
    events[MATCH_OPLOCK_BREAK]  = match ->oplock.hEvent;
    events[MERGE_DONE]          = mergeSynch->   hEvent;
    events[GROVEL_START]        = grovelStartEvent;

    while (TRUE) {
        if (waitingForGrovelStart)
            timeOut = INFINITE;
        else if (timeAllotted == INFINITE)
            timeOut = merge ? INFINITE : 0;
        else {
            elapsedTime = GetTickCount() - startAllottedTime;
            if (timeAllotted > elapsedTime)
                timeOut = merge ? timeAllotted - elapsedTime : 0;
            else {
                waitingForGrovelStart = TRUE;
                timeOut = INFINITE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
            }
        }

        eventNum  = WaitForMultipleObjects(NUM_EVENTS, events, FALSE, timeOut);
        eventTime = GetTickCount();

        switch (eventNum) {

            case WAIT_OBJECT_0 + TARGET_OPLOCK_BREAK:

                ASSERT(!targetOplockBroke);
                targetOplockBroke = TRUE;
                success = ResetEvent(target->oplock.hEvent);
                ASSERT_ERROR(success);
                CLEAR_OVERLAPPED(target->oplock);
                if (merge) {
                    success = SetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                }
                DPRINTF((_T("%s: target file %s oplock broke during merge\n"),
                    driveLetterName, target->fileName));
                break;

            case WAIT_OBJECT_0 + MATCH_OPLOCK_BREAK:

                ASSERT(!matchOplockBroke);
                matchOplockBroke = TRUE;
                success = ResetEvent(match->oplock.hEvent);
                ASSERT_ERROR(success);
                CLEAR_OVERLAPPED(match->oplock);
                if (merge) {
                    success = SetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                }
                DPRINTF((_T("%s: match file %s oplock broke during merge\n"),
                    driveLetterName, match->fileName));
                break;

            case WAIT_OBJECT_0 + MERGE_DONE:

                ASSERT(merge);
                merge = FALSE;
                success = ResetEvent(mergeSynch->hEvent);
                ASSERT_ERROR(success);
                target->stopTime = eventTime;
                mergeSuccess = GetOverlappedResult(
                    grovHandle,
                    mergeSynch,
                    &lastError,
                    FALSE);
                if (!mergeSuccess)
                    lastError = GetLastError();
                else if (lastError != ERROR_SUCCESS)
                    mergeSuccess = FALSE;
                else {
                    GetCSIndex(target->handle, &target->entry.csIndex);
                    if (!HasCSIndex(match->entry.csIndex))
                        GetCSIndex(match->handle, &match->entry.csIndex);
                }
                CloseFile(target);
                CloseFile(match);
                break;

            case WAIT_OBJECT_0 + GROVEL_START:

                ASSERT(waitingForGrovelStart);
                waitingForGrovelStart = FALSE;
                success = ResetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                break;

            case WAIT_TIMEOUT:

                ASSERT(!waitingForGrovelStart);
                if (!merge) {
                    success = ResetEvent(abortMergeEvent);
                    ASSERT_ERROR(success);
                    if (terminate)
                        throw TERMINATE;
                    if (!mergeSuccess)
                        SetLastError(lastError);
                    return mergeSuccess;
                }
                waitingForGrovelStart = TRUE;
                grovelStatus = Grovel_pending;
                ASSERT(IsReset(grovelStopEvent));
                success = SetEvent(grovelStopEvent);
                ASSERT_ERROR(success);
                break;

            default:

                ASSERT_PRINTF(FALSE, (_T("eventNum=%lu\n"), eventNum));
        }
    }
}

#undef TARGET_OPLOCK_BREAK
#undef MATCH_OPLOCK_BREAK
#undef GROVEL_START
#undef MERGE_DONE
#undef NUM_EVENTS

/*****************************************************************************/

// The following seven methods (GetTarget(), CalculateSignature(),
// GetMatchList(), GetCSFile(), GetMatch(), Compare(), and Merge())
// implement the phases of the groveling process.

// Structures used by the methods.

struct MatchListEntry {
    DWORDLONG fileID,
              createTime,
              writeTime;
};

struct CSIndexEntry {
    CSID  csIndex;
    TCHAR name[1];
};

/*****************************************************************************/

// GetTarget() is the first phase of groveling a file. It dequeues
// a file to be groveled (the "target" file), opens it, checks that
// it meets all criteria, then passes it on to the next phases.

BOOL Groveler::GetTarget(
    FileData *target,
    DWORD    *queueIndex)
{
    SGNativeTableEntry tableEntry;

    SGNativeQueueEntry queueEntry,
                       otherQueueEntry;

    TFileName targetName,
              parentName;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    DWORD lastError;

    DWORDLONG currentTime,
              readyTime;

#if DBG
    DWORD earliestTime;
#endif

    ULARGE_INTEGER word;

    LONG num;

    BOOL byName,
         success;

    TPRINTF((_T("GETTarget: entered\n")));

    ASSERT(target               != NULL);
    ASSERT(target->handle       == NULL);
    ASSERT(target->entry.fileID == 0);
    ASSERT(target->fileName[0]  == _T('\0'));
    ASSERT(!HasCSIndex(target->entry.csIndex));

    ASSERT(queueIndex != NULL);
    ASSERT(sgDatabase != NULL);

// Dequeue a file to be groveled. If the queue is empty or if no
// entry's ready time has been reached, return Grovel_ok to grovel().

    queueEntry.fileName = target->fileName;
    num = sgDatabase->QueueGetFirst(&queueEntry);
    if (num < 0)
        throw DATABASE_ERROR;
    if (num == 0) {
        DPRINTF((_T("%s: queue is empty\n"), driveLetterName));
        return FALSE;
    }
    ASSERT(num == 1);

    currentTime = GetTime();
    if (queueEntry.readyTime > currentTime) {
#if DBG
        earliestTime = (DWORD)((queueEntry.readyTime - currentTime) / 10000);
        DPRINTF((_T("%s: earliest queue entry ready to be groveled in %lu.%03lu sec\n"),
            driveLetterName, earliestTime / 1000, earliestTime % 1000));
#endif
        return FALSE;
    }

    *queueIndex          = queueEntry.order;
    target->entry.fileID = queueEntry.fileID;
    target->parentID     = queueEntry.parentID;
    target->retryTime    = queueEntry.retryTime;

// Open the file by ID or name, and check by name
// that the file and its parent directory are allowed.

    byName = target->entry.fileID == 0;
    if (byName) {

        ASSERT(target->parentID    != 0);
        ASSERT(target->fileName[0] != _T('\0'));

#ifdef DEBUG_USN_REASON
        DPRINTF((_T("--> 0x%08lx 0x%016I64x:\"%s\"\n"),
            queueEntry.reason, target->parentID, target->fileName));
#endif

        if (!GetFileName(volumeHandle, target->parentID, &parentName)) {
            DPRINTF((_T("%s: can't get name for directory 0x%016I64x\n"),
                driveLetterName, target->parentID));
            throw TARGET_INVALID;
        }

        targetName.assign(parentName.name);
        targetName.append(_T("\\"));
        targetName.append(target->fileName);

        if (!IsAllowedName(targetName.name)) {
            DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
                driveLetterName, targetName.name));
            throw TARGET_INVALID;
        }

        targetName.assign(driveName);
        targetName.append(parentName.name);
        targetName.append(_T("\\"));
        targetName.append(target->fileName);

        if (!OpenFileByName(target, FALSE, targetName.name)) {
            lastError = GetLastError();
            if (lastError == ERROR_FILE_NOT_FOUND
             || lastError == ERROR_PATH_NOT_FOUND) {
                DPRINTF((_T("%s: target file \"%s\" doesn\'t exist\n"),
                    driveLetterName, targetName.name));
                throw TARGET_INVALID;
            }
            DPRINTF((_T("%s: can't open target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, lastError));
            throw TARGET_ERROR;
        }

// Set an oplock on the target file.

        if (!SetOplock(target)) {
            DPRINTF((_T("%s: can't set oplock on target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, GetLastError()));
            throw TARGET_ERROR;
        }

    } else {

        ASSERT(target->parentID    == 0);
        ASSERT(target->fileName[0] == _T('\0'));

        target->parentID = 0;

#ifdef DEBUG_USN_REASON
        DPRINTF((_T("--> 0x%08lx 0x%016I64x 0x%016I64x\n"),
            queueEntry.reason, target->entry.fileID, target->parentID));
#endif

        TPRINTF((_T("GETTarget: Opening %s:0x%016I64x by ID\n"),
                driveName,target->entry.fileID));

        if (!OpenFileByID(target, FALSE)) {
            lastError = GetLastError();
            if (lastError == ERROR_FILE_NOT_FOUND
             || lastError == ERROR_PATH_NOT_FOUND
			 || lastError == ERROR_INVALID_PARAMETER) {

                DPRINTF((_T("%s: target file 0x%016I64x doesn\'t exist: %lu\n"),
                    driveLetterName, target->entry.fileID, lastError));

                throw TARGET_INVALID;
            }

            DPRINTF((_T("%s: can't open target file 0x%016I64x: %lu\n"),
                driveLetterName, target->entry.fileID, lastError));

            throw TARGET_ERROR;
        }

// Set an oplock on the target file.
        TPRINTF((_T("GETTarget: Successfully opened %s:0x%016I64x by ID\n"),
                driveName,target->entry.fileID));

        if (!SetOplock(target)) {
            DPRINTF((_T("%s: can't set oplock on target file %s: %lu\n"),
                driveLetterName, target->fileName, GetLastError()));
            throw TARGET_ERROR;
        }

        if (!GetFileName(target->handle, &targetName)) {
            DPRINTF((_T("%s: can't get name for target file %s\n"),
                driveLetterName, target->fileName));
            throw TARGET_ERROR;
        }

        if (!IsAllowedName(targetName.name)) {
            DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
                driveLetterName, targetName.name));
            throw TARGET_INVALID;
        }
    }

// Get the information on the target file.

    if (!GetFileInformationByHandle(target->handle, &fileInfo)) {
#if DBG
        if (byName) {
            DPRINTF((_T("%s: can't get information on target file \"%s\": %lu\n"),
                driveLetterName, targetName.name, GetLastError()));
        } else {
            DPRINTF((_T("%s: can't get information on target file %s: %lu\n"),
                driveLetterName, target->fileName, GetLastError()));
        }
#endif
        throw TARGET_ERROR;
    }

    word.HighPart = fileInfo.nFileIndexHigh;
    word.LowPart  = fileInfo.nFileIndexLow;
    if (byName)
        target->entry.fileID = word.QuadPart;
    else {
        ASSERT(target->entry.fileID == word.QuadPart);
    }

    target->parentID = 0; // We don't need the parent ID any more.

// If the target file was opened by name, check
// if it currently has an entry in the queue by ID.

    if (byName) {
        otherQueueEntry.fileID   = target->entry.fileID;
        otherQueueEntry.fileName = NULL;
        num = sgDatabase->QueueGetFirstByFileID(&otherQueueEntry);
        if (num < 0)
            throw DATABASE_ERROR;

        if (num > 0) {
            ASSERT(num == 1);
            DPRINTF((_T("%s: target file \"%s\" is already in queue as 0x%016I64x\n"),
                driveLetterName, targetName.name, target->entry.fileID));
            target->entry.fileID = 0; // Prevent the table entry from being deleted.
            throw TARGET_INVALID;
        }
    }

// Fill in the target file's remaining information values.

    word.HighPart = fileInfo.nFileSizeHigh;
    word.LowPart  = fileInfo.nFileSizeLow;
    target->entry.fileSize = word.QuadPart;

    target->entry.attributes = fileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED;

    word.HighPart = fileInfo.ftCreationTime.dwHighDateTime;
    word.LowPart  = fileInfo.ftCreationTime.dwLowDateTime;
    target->entry.createTime = word.QuadPart;

    word.HighPart = fileInfo.ftLastWriteTime.dwHighDateTime;
    word.LowPart  = fileInfo.ftLastWriteTime.dwLowDateTime;
    target->entry.writeTime = word.QuadPart;

// If the target file is a reparse point, check if it
// is a SIS reparse point. If it is, get the CS index.

    if ((fileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
        target->entry.csIndex = nullCSIndex;
    else if (!GetCSIndex(target->handle, &target->entry.csIndex)) {
        DPRINTF((_T("%s: target file %s is a non-SIS reparse point\n"),
            driveLetterName, target->fileName));
        throw TARGET_INVALID;
    }

// Check if the target file is too small or has any disallowed attributes.

    if ((fileInfo.dwFileAttributes & disallowedAttributes) != 0
     ||  fileInfo.nNumberOfLinks != 1
     ||  target->entry.fileSize  <  minFileSize) {
        DPRINTF((_T("%s: target file \"%s\" is disallowed\n"),
            driveLetterName, target->fileName));
        throw TARGET_INVALID;
    }

// If a table entry exists for the target file, check if it is
// consistent with the information we have on the file. If it is, and
// the file was opened by name, or if the queue entry was the result
// of a SIS merge, close the file and go on to grovel the next target.

    tableEntry.fileID = target->entry.fileID;
    num = sgDatabase->TableGetFirstByFileID(&tableEntry);
    if (num < 0)
        throw DATABASE_ERROR;

    if (num > 0) {
        ASSERT(num == 1);
        ASSERT(tableEntry.fileID == target->entry.fileID);

        if             (target->entry.fileSize   == tableEntry.fileSize
         &&             target->entry.attributes == tableEntry.attributes
         && SameCSIndex(target->entry.csIndex,      tableEntry.csIndex)
         &&             target->entry.createTime == tableEntry.createTime
         &&             target->entry.writeTime  == tableEntry.writeTime) {

            if (byName) {
                DPRINTF((_T("%s: target file \"%s\" has already been groveled\n"),
                    driveLetterName, targetName.name));
                target->entry.fileID = 0; // Prevent the table entry from being deleted.
                throw TARGET_INVALID;
            }

            if (queueEntry.reason == USN_REASON_BASIC_INFO_CHANGE) {
                DPRINTF((_T("%s: queue entry for file %s is the result of a SIS merge\n"),
                    driveLetterName, target->fileName));
                target->entry.fileID = 0; // Prevent the table entry from being deleted.
                throw TARGET_INVALID;
            }
        }
    }

// Check if the time since the target file was last modified is too short.
// If it is, close the file and go on to grovel the next target file.

    readyTime = (target->entry.createTime > target->entry.writeTime
               ? target->entry.createTime : target->entry.writeTime) + minFileAge;
    currentTime = GetTime();
    if (currentTime < readyTime)
        throw TARGET_ERROR;

// Check if the target file is mapped by another user.

    if (IsFileMapped(target)) {
        DPRINTF((_T("%s: target file %s is already mapped\n"),
            driveLetterName, target->fileName));
        throw TARGET_ERROR;
    }

    TPRINTF((_T("GETTarget: returning\n")));

    return TRUE;
}

/*****************************************************************************/

// CalculateSignature() calculates the target file's signature. It reads two
// pages, 1/3 and 2/3 through the file, and calculates the signature on each
// page.

VOID Groveler::CalculateSignature(FileData *target)
{
    DWORD lastPageSize,
          bytesToRead,
          prevBytesToRead,
          bytesToRequest,
          prevBytesToRequest,
          bytesRead,
          toggle,
          lastError;

    DWORDLONG numPages,
              pageNum,
              prevPageNum,
              lastPageNum,
              firstPageToRead,
              lastPageToRead;

    ULARGE_INTEGER offset;

    BOOL targetReadDone,
         success;

    INT i,
        nPagesToRead;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->handle         != NULL);

    target->entry.signature = 0;

    if (0 == target->entry.fileSize)
        return;

    numPages     =         (target->entry.fileSize - 1) / SIG_PAGE_SIZE  + 1;
    lastPageSize = (DWORD)((target->entry.fileSize - 1) % SIG_PAGE_SIZE) + 1;
    lastPageNum  = numPages - 1;

    ASSERT(numPages > 0);

    firstPageToRead = (numPages + 2) / 3 - 1;
    lastPageToRead = lastPageNum - firstPageToRead;

    if (lastPageToRead > firstPageToRead)
        nPagesToRead = 2;
    else
        nPagesToRead = 1;

    toggle = 0;
    pageNum = firstPageToRead;

// We'll read at most two pages, but make at most three passes through the loop
// since we're doing asynchronous reads.

    for (i = 0; i <= nPagesToRead; ++i) {

// Unless this is the first pass through the loop,
// wait for the previous read of the target file to complete.

        if (i > 0) {
            SigCheckPoint(target, !targetReadDone);

            success = GetOverlappedResult(
                target->handle,
                &target->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
                DPRINTF((_T("%s: error getting target file %s read results: %lu\n"),
                    driveLetterName, target->fileName, GetLastError()));
                throw TARGET_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
                DPRINTF((_T("%s: sig read only %lu of %lu bytes from target file %s\n"),
                    driveLetterName, bytesRead, prevBytesToRequest, target->fileName));
                throw TARGET_ERROR;
            }

            if (bytesRead >= sigReportThreshold) {
                hashReadCount++;
                hashReadTime += target->stopTime - target->startTime;
            }
        }

// Unless we've read all of the pages, begin reading the next page.

        if (i < nPagesToRead) {
            offset.QuadPart              = pageNum * SIG_PAGE_SIZE;
            target->readSynch.Offset     = offset.LowPart;
            target->readSynch.OffsetHigh = offset.HighPart;

            bytesToRead     = pageNum == lastPageNum ? lastPageSize : SIG_PAGE_SIZE;
            bytesToRequest  = bytesToRead    + sectorSize - 1;
            bytesToRequest -= bytesToRequest % sectorSize;

            target->startTime = GetTickCount();
            targetReadDone    = ReadFile(target->handle, target->buffer[toggle],
                bytesToRequest, NULL, &target->readSynch);
            target->stopTime  = GetTickCount();
            lastError         = GetLastError();

            if (targetReadDone) {
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
                DPRINTF((_T("%s: error reading target file %s: %lu\n"),
                    driveLetterName, target->fileName, lastError));
                throw TARGET_ERROR;
            }
        }

// Unless this is the first pass through the loop,
// calculate the signature of the target file page just read.

        if (i > 0)
            target->entry.signature = Checksum((VOID *)target->buffer[1-toggle],
                prevBytesToRead, prevPageNum * SIG_PAGE_SIZE, target->entry.signature);

        prevPageNum         = pageNum;
        prevBytesToRead     = bytesToRead;
        prevBytesToRequest  = bytesToRequest;
        toggle              = 1-toggle;
        pageNum             = lastPageToRead;

    }
}

/*****************************************************************************/

// GetMatchList() looks for file entries in the database ("match" files)
// with the same size, signature, and attributes as the target file.

VOID Groveler::GetMatchList(
    FileData *target,
    FIFO     *matchList,
    Table    *csIndexTable)
{
    SGNativeTableEntry tableEntry;

    MatchListEntry *matchListEntry;

    CSIndexEntry *csIndexEntry;

    TCHAR *csName;

    DWORD nameLen;

    LONG num;

    BOOL success;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(matchList           != NULL);
    ASSERT(matchList->Number() == 0);

    ASSERT(csIndexTable           != NULL);
    ASSERT(csIndexTable->Number() == 0);

    ASSERT(sgDatabase != NULL);

    tableEntry.fileSize   = target->entry.fileSize;
    tableEntry.signature  = target->entry.signature;
    tableEntry.attributes = target->entry.attributes;

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> {%I64u, 0x%016I64x, 0x%lx}\n"),
        tableEntry.fileSize, tableEntry.signature, tableEntry.attributes));
#endif

    num = sgDatabase->TableGetFirstByAttr(&tableEntry);

    while (num > 0) {

        ASSERT(num == 1);
        ASSERT(tableEntry.fileID     != 0);
        ASSERT(tableEntry.fileSize   == target->entry.fileSize);
        ASSERT(tableEntry.signature  == target->entry.signature);
        ASSERT(tableEntry.attributes == target->entry.attributes);

        if (!HasCSIndex(tableEntry.csIndex)) {

            matchListEntry = new MatchListEntry;
            ASSERT(matchListEntry != NULL);

            matchListEntry->fileID     = tableEntry.fileID;
            matchListEntry->createTime = tableEntry.createTime;
            matchListEntry->writeTime  = tableEntry.writeTime;
            matchList->Put((VOID *)matchListEntry);

#ifdef DEBUG_GET_BY_ATTR
            DPRINTF((_T("    0x%016I64x\n"), tableEntry.fileID));
#endif

        } else {

            csIndexEntry = (CSIndexEntry *)csIndexTable->Get
                ((const VOID *)&tableEntry.csIndex, sizeof(CSID));

            if (csIndexEntry == NULL) {
                csName = GetCSName(&tableEntry.csIndex);
                ASSERT(csName != NULL);
                nameLen = _tcslen(csName);

                csIndexEntry = (CSIndexEntry *)
                    (new BYTE[sizeof(CSIndexEntry) + nameLen * sizeof(TCHAR)]);
                ASSERT(csIndexEntry != NULL);

                csIndexEntry->csIndex = tableEntry.csIndex;
                _tcscpy(csIndexEntry->name, csName);
                FreeCSName(csName);
                csName = NULL;

                success = csIndexTable->Put
                    ((VOID *)csIndexEntry, sizeof(CSID));
                ASSERT_ERROR(success);
            }

#ifdef DEBUG_GET_BY_ATTR
            DPRINTF((_T("    0x%016I64x %s\n"),
                match->entry.fileID, csIndexEntry->name));
#endif
        }

        num = sgDatabase->TableGetNext(&tableEntry);
    }

    if (num < 0)
        throw DATABASE_ERROR;
}

/*****************************************************************************/

// GetCSFile() pops the first entry from the CS index table and opens it.

BOOL Groveler::GetCSFile(
    FileData *target,
    FileData *match,
    Table    *csIndexTable)
{
    CSIndexEntry *csIndexEntry;

    TFileName csFileName;

    DWORD lastError;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    ULARGE_INTEGER fileSize;

    LONG num;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(match                   != NULL);
    ASSERT(match->entry.fileID     == 0);
    ASSERT(match->entry.fileSize   == 0);
    ASSERT(match->entry.signature  == 0);
    ASSERT(match->entry.attributes == 0);
    ASSERT(!HasCSIndex(match->entry.csIndex));
    ASSERT(match->entry.createTime == 0);
    ASSERT(match->entry.writeTime  == 0);
    ASSERT(match->handle           == NULL);
    ASSERT(match->parentID         == 0);
    ASSERT(match->retryTime        == 0);
    ASSERT(match->fileName[0]      == _T('\0'));

    ASSERT(csIndexTable != NULL);
    ASSERT(sgDatabase   != NULL);

// Pop the first entry from the CS index table. If the entry's CS
// index is the same as the target file's, skip to the next entry.

    do {
        csIndexEntry = (CSIndexEntry *)csIndexTable->GetFirst();
        if (csIndexEntry == NULL) {
            match->entry.csIndex = nullCSIndex;
            match->fileName[0]   = _T('\0');
            return FALSE;
        }

        ASSERT(HasCSIndex(csIndexEntry->csIndex));

        match->entry.csIndex = csIndexEntry->csIndex;
        _tcscpy(match->fileName, csIndexEntry->name);

        delete csIndexEntry;
        csIndexEntry = NULL;
    } while (SameCSIndex(target->entry.csIndex, match->entry.csIndex));

    match->entry.fileSize   = target->entry.fileSize;
    match->entry.signature  = target->entry.signature;
    match->entry.attributes = target->entry.attributes;

    csFileName.assign(driveName);
    csFileName.append(CS_DIR_PATH);
    csFileName.append(_T("\\"));
    csFileName.append(match->fileName);
    csFileName.append(_T(".sis"));

// Open the CS file. If the file doesn't exist, remove all entries
// from the table that point to this file. If the file can't be
// opened for any other reason, mark that the target file may
// need to be groveled again, then go on to the next match file.

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> %s\n"), match->fileName));
#endif

    if (!OpenFileByName(match, FALSE, csFileName.name)) {
        lastError = GetLastError();
        if (lastError == ERROR_FILE_NOT_FOUND
         || lastError == ERROR_PATH_NOT_FOUND) {
            DPRINTF((_T("%s: CS file %s doesn't exist\n"),
                driveLetterName, match->fileName));
            throw MATCH_INVALID;
        }
        DPRINTF((_T("%s: can't open CS file %s: %lu\n"),
            driveLetterName, match->fileName, lastError));
        throw MATCH_ERROR;
    }

// Get the information on the CS file. If this fails,
// close the file, mark that the target file may need to
// be groveled again, then go on to the next match file.

    if (!GetFileInformationByHandle(match->handle, &fileInfo)) {
        DPRINTF((_T("%s: can't get information on CS file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

// If the CS file's information doesn't match its expected values, close the
// CS file, delete the match file entry from the table, and go on to the
// next match file. Otherwise, go on to compare the target and CS files.

    fileSize.HighPart = fileInfo.nFileSizeHigh;
    fileSize.LowPart  = fileInfo.nFileSizeLow;

    if (match->entry.fileSize != fileSize.QuadPart) {
        DPRINTF((_T("%s: CS file %s doesn't have expected information\n"),
            driveLetterName, match->fileName));
        throw MATCH_STALE;
    }

    return TRUE;
}

/*****************************************************************************/

// GetMatch() pops the first entry from the match list and opens it.

BOOL Groveler::GetMatch(
    FileData *target,
    FileData *match,
    FIFO     *matchList)
{
    SGNativeQueueEntry queueEntry;

    MatchListEntry *matchListEntry;

    DWORD attributes,
          lastError;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    ULARGE_INTEGER fileID,
                   fileSize,
                   createTime,
                   writeTime;

    LONG num;

    ASSERT(target                 != NULL);
    ASSERT(target->entry.fileID   != 0);
    ASSERT(target->entry.fileSize >  0);
    ASSERT(target->handle         != NULL);

    ASSERT(match                   != NULL);
    ASSERT(match->entry.fileID     == 0);
    ASSERT(match->entry.fileSize   == 0);
    ASSERT(match->entry.signature  == 0);
    ASSERT(match->entry.attributes == 0);
    ASSERT(!HasCSIndex(match->entry.csIndex));
    ASSERT(match->entry.createTime == 0);
    ASSERT(match->entry.writeTime  == 0);
    ASSERT(match->handle           == NULL);
    ASSERT(match->parentID         == 0);
    ASSERT(match->retryTime        == 0);
    ASSERT(match->fileName[0]      == _T('\0'));

    ASSERT(matchList  != NULL);
    ASSERT(sgDatabase != NULL);

// Pop the first entry from the match list. If the entry's file ID is
// the same as the target file's, or if the entry is on the queue after
// having been enqueued by extract_log(), skip to the next entry.

    while (TRUE) {
        matchListEntry = (MatchListEntry *)matchList->Get();
        if (matchListEntry == NULL) {
            match->entry.fileID     = 0;
            match->entry.createTime = 0;
            match->entry.writeTime  = 0;
            return FALSE;
        }

        match->entry.fileID     = matchListEntry->fileID;
        match->entry.createTime = matchListEntry->createTime;
        match->entry.writeTime  = matchListEntry->writeTime;

        delete matchListEntry;
        matchListEntry = NULL;

        ASSERT(match->entry.fileID != 0);

        if (target->entry.fileID == match->entry.fileID)
            continue;

        queueEntry.fileID   = match->entry.fileID;
        queueEntry.fileName = NULL;
        num = sgDatabase->QueueGetFirstByFileID(&queueEntry);
        if (num < 0)
            throw DATABASE_ERROR;
        if (num > 0) {
            ASSERT(num == 1);
            if (queueEntry.reason != 0) {
                DPRINTF((_T("%s: match file 0x%016I64x is in the queue from USN\n"),
                    driveLetterName, match->entry.fileID));
                continue;
            }
        }

        break;
    }

    match->entry.fileSize   = target->entry.fileSize;
    match->entry.signature  = target->entry.signature;
    match->entry.attributes = target->entry.attributes;

// Open the match file. If it doesn't exist, remove its entry from the table.
// If the file can't be opened for any other reason, mark that the target
// file may need to be groveled again, then go on to the next match file.

#ifdef DEBUG_GET_BY_ATTR
    DPRINTF((_T("--> 0x%016I64x\n"), match->entry.fileID));
#endif

    if (!OpenFileByID(match, FALSE)) {
        lastError = GetLastError();
        if (lastError == ERROR_FILE_NOT_FOUND
         || lastError == ERROR_PATH_NOT_FOUND
		 || lastError == ERROR_INVALID_PARAMETER) {
            DPRINTF((_T("%s: match file 0x%016I64x doesn\'t exist: %lu\n"),
                driveLetterName, match->entry.fileID, lastError));
            throw MATCH_INVALID;
        }

        DPRINTF((_T("%s: can't open match file 0x%016I64x: %lu\n"),
            driveLetterName, match->entry.fileID, lastError));
        throw MATCH_ERROR;
    }

// Set an oplock on the match file.

    if (!SetOplock(match)) {
        DPRINTF((_T("%s: can't set oplock on match file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

// Get the information on the match file. If this fails,
// close the file, mark that the target file may need to
// be groveled again, then go on to the next match file.

    if (!GetFileInformationByHandle(match->handle, &fileInfo)) {
        DPRINTF((_T("%s: can't get information on match file %s: %lu\n"),
            driveLetterName, match->fileName, GetLastError()));
        throw MATCH_ERROR;
    }

    fileID.HighPart = fileInfo.nFileIndexHigh;
    fileID.LowPart  = fileInfo.nFileIndexLow;
    ASSERT(match->entry.fileID == fileID.QuadPart);

    fileSize.HighPart = fileInfo.nFileSizeHigh;
    fileSize.LowPart  = fileInfo.nFileSizeLow;

    attributes = fileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED;

    createTime.HighPart = fileInfo.ftCreationTime.dwHighDateTime;
    createTime.LowPart  = fileInfo.ftCreationTime.dwLowDateTime;

    writeTime.HighPart = fileInfo.ftLastWriteTime.dwHighDateTime;
    writeTime.LowPart  = fileInfo.ftLastWriteTime.dwLowDateTime;

// If the match file's information isn't consistent with its table entry, close
// the file, enqueue it to be re-groveled, and go on to the next match file.

    if (match->entry.fileSize   != fileSize  .QuadPart
     || match->entry.attributes != attributes
     || match->entry.createTime != createTime.QuadPart
     || match->entry.writeTime  != writeTime .QuadPart) {
        DPRINTF((_T("%s: match file %s doesn't match its information\n"),
            driveLetterName, match->fileName));
        throw MATCH_STALE;
    }

    if ((fileInfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {
        if (GetCSIndex(match->handle, &match->entry.csIndex)) {
            DPRINTF((_T("%s: match file %s is a SIS reparse point\n"),
                driveLetterName, match->fileName));
            throw MATCH_STALE;
        }

        DPRINTF((_T("%s: match file %s is a non-SIS reparse point\n"),
            driveLetterName, match->fileName));
        throw MATCH_INVALID;
    }

// Check if the match file is mapped by another user.

    if (IsFileMapped(match)) {
        DPRINTF((_T("%s: match file %s is already mapped\n"),
            driveLetterName, match->fileName));
        throw MATCH_ERROR;
    }

    return TRUE;
}

/*****************************************************************************/

// Compare() compares the target and match files. It reads each file
// one page (64 kB) at a time and compares each pair of pages.

BOOL Groveler::Compare(
    FileData *target,
    FileData *match)
{
    DWORD lastPageSize,
          bytesToRead = 0,
          prevBytesToRead,
          bytesToRequest = 0,
          prevBytesToRequest,
          bytesRead,
          toggle,
          targetTime,
          matchTime,
          lastError;

    DWORDLONG numPages,
              pageNum,
              prevPageNum;

    ULARGE_INTEGER offset;

    BOOL targetReadDone,
         matchReadDone,
         filesMatch,
         success;

    ASSERT(target               != NULL);
    ASSERT(target->handle       != NULL);
    ASSERT(target->entry.fileID != 0);

    ASSERT(match         != NULL);
    ASSERT(match->handle != NULL);
    ASSERT(    match->entry.fileID != 0
           && !HasCSIndex(match->entry.csIndex)
        ||     match->entry.fileID == 0
           &&  match->fileName[0]  != _T('\0')
           &&  HasCSIndex(match->entry.csIndex));

    ASSERT(target->entry.fileSize   == match->entry.fileSize);
    ASSERT(target->entry.signature  == match->entry.signature);
    ASSERT(target->entry.attributes == match->entry.attributes);

    numPages     =         (target->entry.fileSize - 1) / CMP_PAGE_SIZE  + 1;
    lastPageSize = (DWORD)((target->entry.fileSize - 1) % CMP_PAGE_SIZE) + 1;

    toggle     = 0;
    filesMatch = TRUE;

    for (pageNum = 0; pageNum <= numPages; pageNum++) {

// Unless this is the first pass through the loop,
// wait for the previous read of both files to complete.

        if (pageNum > 0) {
            CmpCheckPoint(target, match, !targetReadDone, !matchReadDone);

            success = GetOverlappedResult(
                target->handle,
                &target->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
                DPRINTF((_T("%s: error getting target file %s read results: %lu\n"),
                    driveLetterName, target->fileName, GetLastError()));
                throw TARGET_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
                DPRINTF((_T("%s: cmp read only %lu of %lu bytes from target file %s\n"),
                    driveLetterName, bytesRead, prevBytesToRequest, target->fileName));
                throw TARGET_ERROR;
            }

            success = GetOverlappedResult(
                match->handle,
                &match->readSynch,
                &bytesRead,
                FALSE);
            if (!success) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error getting match file %s read results: %lu\n"),
                        driveLetterName, match->fileName, GetLastError()));
                } else {
                    DPRINTF((_T("%s: error getting CS file %s read results: %lu\n"),
                        driveLetterName, match->fileName, GetLastError()));
                }
#endif
                throw MATCH_ERROR;
            }

            if (bytesRead != prevBytesToRequest &&
                bytesRead != prevBytesToRead) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: read only %lu of %lu bytes from match file %s\n"),
                        driveLetterName, bytesRead, prevBytesToRequest, match->fileName));
                } else {
                    DPRINTF((_T("%s: read only %lu of %lu bytes from CS file %s\n"),
                        driveLetterName, bytesRead, prevBytesToRequest, match->fileName));
                }
#endif
                throw MATCH_ERROR;
            }

            if (bytesRead >= cmpReportThreshold) {
                compareReadCount += 2;
                if (targetReadDone) { // Non-overlapped
                    targetTime = target->stopTime - target->startTime;
                    matchTime  = match ->stopTime - match ->startTime;
                    compareReadTime += targetTime + matchTime;
                } else {              // Overlapped
                    targetTime = target->stopTime - target->startTime;
                    matchTime  = match ->stopTime - target->startTime;
                    compareReadTime += targetTime > matchTime ? targetTime : matchTime;
                }
            }

            if (!filesMatch)
                break;
        }

// Unless all pages of the target file have already been read,
// begin reading the next page of the file.

        if (pageNum < numPages) {
            offset.QuadPart             = pageNum * CMP_PAGE_SIZE;
            target->readSynch.Offset     =
            match ->readSynch.Offset     = offset.LowPart;
            target->readSynch.OffsetHigh =
            match ->readSynch.OffsetHigh = offset.HighPart;

            bytesToRead     = pageNum < numPages-1 ? CMP_PAGE_SIZE : lastPageSize;
            bytesToRequest  = bytesToRead    + sectorSize - 1;
            bytesToRequest -= bytesToRequest % sectorSize;

            target->startTime = GetTickCount();
            targetReadDone    = ReadFile(target->handle, target->buffer[toggle],
                bytesToRequest, NULL, &target->readSynch);
            target->stopTime  = GetTickCount();
            lastError         = GetLastError();

            if (targetReadDone) {
                success = ResetEvent(target->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
                DPRINTF((_T("%s: error reading target file %s: %lu\n"),
                    driveLetterName, target->fileName, lastError));
                throw TARGET_ERROR;
            }

            match->startTime = GetTickCount();
            matchReadDone    = ReadFile(match->handle, match->buffer[toggle],
                bytesToRequest, NULL, &match->readSynch);
            match->stopTime  = GetTickCount();
            lastError        = GetLastError();

            if (matchReadDone) {
                success = ResetEvent(match->readSynch.hEvent);
                ASSERT_ERROR(success);
            } else if (lastError != ERROR_IO_PENDING) {
#if DBG
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error reading match file %s: %lu\n"),
                        driveLetterName, match->fileName, lastError));
                } else {
                    DPRINTF((_T("%s: error reading CS file %s: %lu\n"),
                        driveLetterName, match->fileName, lastError));
                }
#endif
                throw MATCH_ERROR;
            }
        }

// Unless this is the first pass through the loop,
// compare the target and match file pages just read.

        if (pageNum > 0)
            filesMatch = memcmp(target->buffer[1-toggle],
                                match ->buffer[1-toggle], prevBytesToRead) == 0;

        prevPageNum         = pageNum;
        prevBytesToRead     = bytesToRead;
        prevBytesToRequest  = bytesToRequest;
        toggle              = 1-toggle;
    }

    if (!filesMatch) {
#if DBG
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s:1 files %s and %s failed compare (sz: 0x%x)\n"),
                driveLetterName, target->fileName, match->fileName, target->entry.fileSize));
        } else {
            DPRINTF((_T("%s:2 files %s and %s failed compare (sz: 0x%x)\n"),
                driveLetterName, target->fileName, match->fileName, target->entry.fileSize));
        }
#endif
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************/

// Merge() calls the SIS filter to merge the target and match files.

BOOL Groveler::Merge(
    FileData   *target,
    FileData   *match,
    OVERLAPPED *mergeSynch,
    HANDLE      abortMergeEvent)
{
    _SIS_LINK_FILES sisLinkFiles;

#if DBG
    TCHAR *csName;
#endif

    DWORD transferCount,
          lastError;

    BOOL mergeDone,
         merged,
         success;

    ASSERT(target               != NULL);
    ASSERT(target->handle       != NULL);
    ASSERT(target->entry.fileID != 0);

    ASSERT(match         != NULL);
    ASSERT(match->handle != NULL);
    ASSERT(    match->entry.fileID != 0
           && !HasCSIndex(match->entry.csIndex)
        ||     match->entry.fileID == 0
           &&  match->fileName[0]  != _T('\0')
           &&  HasCSIndex(match->entry.csIndex));

    ASSERT(mergeSynch               != NULL);
    ASSERT(mergeSynch->Internal     == 0);
    ASSERT(mergeSynch->InternalHigh == 0);
    ASSERT(mergeSynch->Offset       == 0);
    ASSERT(mergeSynch->OffsetHigh   == 0);
    ASSERT(mergeSynch->hEvent       != NULL);
    ASSERT(IsReset(mergeSynch->hEvent));

    ASSERT(abortMergeEvent != NULL);
    ASSERT(IsReset(abortMergeEvent));

    ASSERT(target->entry.fileSize   == match->entry.fileSize);
    ASSERT(target->entry.signature  == match->entry.signature);
    ASSERT(target->entry.attributes == match->entry.attributes);

    ASSERT(grovHandle != NULL);

// Set up to merge the files.

    if (match->entry.fileID != 0) {
        sisLinkFiles.operation          = SIS_LINK_FILES_OP_MERGE;
        sisLinkFiles.u.Merge.file1      = target->handle;
        sisLinkFiles.u.Merge.file2      = match ->handle;
        sisLinkFiles.u.Merge.abortEvent = NULL; // Should be abortMergeEvent
    } else {
        sisLinkFiles.operation                = SIS_LINK_FILES_OP_MERGE_CS;
        sisLinkFiles.u.MergeWithCS.file1      = target->handle;
        sisLinkFiles.u.MergeWithCS.abortEvent = NULL; // Should be abortMergeEvent
        sisLinkFiles.u.MergeWithCS.CSid       = match->entry.csIndex;
    }

// Call the SIS filter to merge the files.

    target->startTime = GetTickCount();
    mergeDone = DeviceIoControl(
        grovHandle,
        FSCTL_SIS_LINK_FILES,
        (VOID *)&sisLinkFiles,
        sizeof(_SIS_LINK_FILES),
        NULL,
        0,
        NULL,
        mergeSynch);
    target->stopTime = GetTickCount();

// If the merge completed successfully before the call returned, reset
// the merge done event, get the new CS indices, and close the files.

    if (mergeDone) {
        success = ResetEvent(mergeSynch->hEvent);
        ASSERT_ERROR(success);
        mergeTime += target->stopTime - target->startTime;
        GetCSIndex(target->handle, &target->entry.csIndex);
        if (!HasCSIndex(match->entry.csIndex))
            GetCSIndex(match->handle, &match->entry.csIndex);
        CloseFile(target);
        CloseFile(match);
    }

// If the merge failed, close the files and return an error status.

    else {
        lastError = GetLastError();
        if (lastError != ERROR_IO_PENDING) {
            CloseFile(target);
            CloseFile(match);

#if DBG
            if (match->entry.fileID != 0) {
                DPRINTF((_T("%s:3 files %s and %s failed merge: %lu\n"),
                    driveLetterName, target->fileName, match->fileName, lastError));
            } else {
                DPRINTF((_T("%s:4 files %s and %s failed merge: %lu\n"),
                    driveLetterName, target->fileName, match->fileName, lastError));
            }
#endif

            return FALSE;
        }

// If the merge is in progress, wait for it to complete.
// (MergeCheckPoint() will get the new CS indices and close the files.

        else {
            merged = MergeCheckPoint(target, match, mergeSynch,
                abortMergeEvent, !mergeDone);

            if (!merged) {
#if DBG
                lastError = GetLastError();
                if (match->entry.fileID != 0) {
                    DPRINTF((_T("%s: error getting merge results of files %s and %s: %lu\n"),
                        driveLetterName, target->fileName, match->fileName, lastError));
                } else {
                    DPRINTF((_T("%s: error getting merge results of files %s and %s: %lu\n"),
                        driveLetterName, target->fileName, match->fileName, lastError));
                }
#endif

                return FALSE;
            }
        }
    }

// If the merge succeeded, analyze and report the results.

    mergeTime += target->stopTime - target->startTime;
    merged = HasCSIndex (target->entry.csIndex)
          && SameCSIndex(target->entry.csIndex, match->entry.csIndex);

#if DBG

    csName = GetCSName(&target->entry.csIndex);

    if (merged) {
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s: files %s and %s merged: CS index is %s\n"),
                driveLetterName, target->fileName, match->fileName,
                csName != NULL ? csName : _T("...")));
        } else {
            DPRINTF((_T("%s: files %s and %s merged\n"),
                driveLetterName, target->fileName, match->fileName));
        }
    } else {
        if (match->entry.fileID != 0) {
            DPRINTF((_T("%s:5 files %s and %s merged, but CS indices don't match\n"),
                driveLetterName, target->fileName, match->fileName));
        } else {
            DPRINTF((_T("%s:6 files %s and %s merged, but CS indices don't match\n"),
                driveLetterName, target->fileName, match->fileName));
        }
    }

    if (csName != NULL) {
        FreeCSName(csName);
        csName = NULL;
    }

#endif

    return merged;
}

/*****************************************************************************/

// Worker() performs the groveling processing.

VOID Groveler::Worker()
{
    FileData target,
             match;

    SGNativeQueueEntry queueEntry;

    FIFO *matchList = NULL;

    Table *csIndexTable = NULL;

    OVERLAPPED mergeSynch = { 0, 0, 0, 0, NULL };

    HANDLE abortMergeEvent = NULL;

    TCHAR *csName;

    DatabaseActionList actionList[MAX_ACTIONS];

    BYTE *buffer1 = NULL,
         *buffer2 = NULL,
         *buffer3 = NULL,
         *buffer4 = NULL;

    DWORD queueIndex,
          bufferSize,
          numCompares,
          numMatches,
          numActions;

#if DBG
    DWORD enqueueTime;
#endif

    LONG num;

    BOOL needToRetry,
         hashed,
         gotMatch,
         filesMatch,
         merged,
         success;

    CLEAR_FILE(target);
    CLEAR_OVERLAPPED(target.oplock);
    target.handle = NULL;

    CLEAR_FILE(match);
    CLEAR_OVERLAPPED(match.oplock);
    match.handle = NULL;

    _set_new_handler(NewHandler);

// Create the events.

    try {

        if ((target.oplock   .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (match .oplock   .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (target.readSynch.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (match .readSynch.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (mergeSynch      .hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
         || (abortMergeEvent         = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
            DPRINTF((_T("%s: unable to create events: %lu\n"),
                driveLetterName, GetLastError()));
            throw INITIALIZE_ERROR;
        }

// Allocate and align the file buffers.

        bufferSize = SIG_PAGE_SIZE > CMP_PAGE_SIZE ? SIG_PAGE_SIZE : CMP_PAGE_SIZE
                   + sectorSize;
        buffer1 = new BYTE[bufferSize];
        ASSERT(buffer1 != NULL);
        buffer2 = new BYTE[bufferSize];
        ASSERT(buffer2 != NULL);
        buffer3 = new BYTE[bufferSize];
        ASSERT(buffer3 != NULL);
        buffer4 = new BYTE[bufferSize];
        ASSERT(buffer4 != NULL);

        ASSERT(inUseFileID1 == NULL);
        ASSERT(inUseFileID2 == NULL);

        inUseFileID1 = &target.entry.fileID;
        inUseFileID2 = &match .entry.fileID;

        target.buffer[0] = buffer1 + sectorSize - (PtrToUlong(buffer1) % sectorSize);
        target.buffer[1] = buffer2 + sectorSize - (PtrToUlong(buffer2) % sectorSize);
        match .buffer[0] = buffer3 + sectorSize - (PtrToUlong(buffer3) % sectorSize);
        match .buffer[1] = buffer4 + sectorSize - (PtrToUlong(buffer4) % sectorSize);

// Signal to grovel() that this thread is alive,
// then wait for it to signal to start.

        grovelStatus = Grovel_ok;
        ASSERT(IsReset(grovelStopEvent));
        success = SetEvent(grovelStopEvent);
        ASSERT_ERROR(success);

        WaitForEvent(grovelStartEvent);
        if (terminate)
            throw TERMINATE;

#ifdef _CRTDBG
_CrtMemState s[2], sdiff;
int stateIndex = 0;

_CrtMemCheckpoint(&s[stateIndex]);
stateIndex = 1;
#endif

// The main loop.

        while (TRUE) {
            try {

#ifdef _CRTDBG
_CrtMemCheckpoint(&s[stateIndex]);

if (_CrtMemDifference(&sdiff, &s[stateIndex^1], &s[stateIndex]))
	_CrtMemDumpStatistics(&sdiff);
stateIndex ^= 1;
#endif

                hashed      = FALSE;
                numCompares = 0;
                numMatches  = 0;
                merged      = FALSE;
                needToRetry = FALSE;

// Get a target file.  abortGroveling is set when scan_volume is attempting to
// sync up with this thread.  We stop here, a safe place to let scan_volume
// replace the database.

                if (abortGroveling || !GetTarget(&target, &queueIndex)) {
                    CLEAR_FILE(target);

                    grovelStatus = Grovel_ok;
                    ASSERT(IsReset(grovelStopEvent));
                    success = SetEvent(grovelStopEvent);
                    ASSERT_ERROR(success);

                    WaitForEvent(grovelStartEvent);
                    if (terminate)
                        throw TERMINATE;

                    continue;
                }

// Calculate the target file's signature.

                hashed = TRUE;

                CalculateSignature(&target);

// Get a list of match files.

                ASSERT(matchList    == NULL);
                ASSERT(csIndexTable == NULL);

                matchList = new FIFO();
                ASSERT(matchList != NULL);

                csIndexTable = new Table();
                ASSERT(csIndexTable != NULL);

                GetMatchList(&target, matchList, csIndexTable);

// Compare the target file to each match file until a matching file is found
// or all comparisons fail. Try the SIS files first, then the regular files.

                while (TRUE) {
                    try {

                        gotMatch = FALSE;

                        if (!gotMatch && csIndexTable != NULL) {
                            gotMatch = GetCSFile(&target, &match, csIndexTable);
                            if (!gotMatch) {
                                delete csIndexTable;
                                csIndexTable = NULL;
                            }
                        }

                        if (!gotMatch && matchList != NULL) {
                            gotMatch = GetMatch(&target, &match, matchList);
                            if (!gotMatch) {
                                delete matchList;
                                matchList = NULL;
                            }
                        }

// After comparing the target file to every file on both
// lists, close the target file and update the database,
// then go on to process the next target file.

                        if (!gotMatch) {
                            CloseFile(&target);

                            numActions                 =  3;
                            actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                            actionList[0].u.fileID     =  target.entry.fileID;
                            actionList[1].type         =  TABLE_PUT;
                            actionList[1].u.tableEntry = &target.entry;
                            actionList[2].type         =  QUEUE_DELETE;
                            actionList[2].u.queueIndex =  queueIndex;

                            if (needToRetry) {
                                queueEntry.fileID    = target.entry.fileID;
                                queueEntry.parentID  = target.parentID;
                                queueEntry.reason    = 0;
                                queueEntry.fileName  = NULL;

                                queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                                if (queueEntry.retryTime < grovelInterval)
                                    queueEntry.retryTime = grovelInterval;
                                queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                                numActions                 =  4;
                                actionList[3].type         =  QUEUE_PUT;
                                actionList[3].u.queueEntry = &queueEntry;
                            }

#if DBG

                            if (!HasCSIndex(target.entry.csIndex)) {
                                TRACE_PRINTF(TC_groveler, 4,
                                    (_T("%s: adding file {%s, %I64u, 0x%016I64x} to table\n"),
                                    driveLetterName, target.fileName, target.entry.fileSize,
                                    target.entry.signature));
                            } else {
                                csName = GetCSName(&target.entry.csIndex);
                                TRACE_PRINTF(TC_groveler, 4,
                                    (_T("%s: adding file {%s, %I64u, 0x%016I64x, %s} to table\n"),
                                    driveLetterName, target.fileName, target.entry.fileSize,
                                    target.entry.signature, csName != NULL ? csName : _T("...")));
                                if (csName != NULL) {
                                    FreeCSName(csName);
                                    csName = NULL;
                                }
                            }

                            if (needToRetry) {
                                enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                                DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                    target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                            }

#endif

                            DoTransaction(numActions, actionList);
                            break;
                        }

// Compare the target file with this match file.

                        numCompares++;

                        ASSERT(!inCompare);
                        inCompare  = TRUE;
                        filesMatch = Compare(&target, &match);
                        inCompare  = FALSE;

                        if (!filesMatch) {
                            CloseFile(&match);
                            CLEAR_FILE(match);
                            continue;
                        }

// If the target and match files are identical, go on to merge them.

                        numMatches++;

                        merged = Merge(&target, &match, &mergeSynch, abortMergeEvent);

// Update the database as follows:
//
// - Update the target file's table entry.
//
// - If the merge succeeded and the match file was a regular file,
//   update the match file's table entry.
//
// - If the merge failed, re-enqueue the target file to be groveled again.

                        numActions                 =  3;
                        actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                        actionList[0].u.fileID     =  target.entry.fileID;
                        actionList[1].type         =  TABLE_PUT;
                        actionList[1].u.tableEntry = &target.entry;
                        actionList[2].type         =  QUEUE_DELETE;
                        actionList[2].u.queueIndex =  queueIndex;

                        if (merged) {
                            if (match.entry.fileID != 0) {
                                actionList[numActions  ].type         =  TABLE_DELETE_BY_FILE_ID;
                                actionList[numActions++].u.fileID     =  match.entry.fileID;
                                actionList[numActions  ].type         =  TABLE_PUT;
                                actionList[numActions++].u.tableEntry = &match.entry;
                            }
                        } else {
                            queueEntry.fileID    = target.entry.fileID;
                            queueEntry.parentID  = target.parentID;
                            queueEntry.reason    = 0;
                            queueEntry.fileName  = NULL;

                            queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                            if (queueEntry.retryTime < grovelInterval)
                                queueEntry.retryTime = grovelInterval;
                            queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                            actionList[numActions  ].type         =  QUEUE_PUT;
                            actionList[numActions++].u.queueEntry = &queueEntry;
                        }

#if DBG

                        if (!HasCSIndex(target.entry.csIndex)) {
                            TPRINTF((_T("%s: adding file {%s, %I64u, 0x%016I64x} to table\n"),
                                driveLetterName, target.fileName, target.entry.fileSize,
                                target.entry.signature));
                        } else {
                            csName = GetCSName(&target.entry.csIndex);
                            TPRINTF((_T("%s: adding file {%s, %I64u, 0x%016I64x, %s} to table\n"),
                                driveLetterName, target.fileName, target.entry.fileSize,
                                target.entry.signature, csName != NULL ? csName : _T("...")));
                            if (csName != NULL) {
                                FreeCSName(csName);
                                csName = NULL;
                            }
                        }

                        if (!merged) {
                            enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        }

#endif

                        DoTransaction(numActions, actionList);
                        break;
                    }

// Match exceptions

                    catch (MatchException matchException) {

                        inCompare = FALSE;

                        switch (matchException) {

// MATCH_INVALID: the match file doesn't exist or is disallowed. Close the file
// and remove its entry from the table, then go on to try the next match file.

                            case MATCH_INVALID:

                                CloseFile(&match);

                                if (match.entry.fileID != 0) {
                                    ASSERT(!HasCSIndex(match.entry.csIndex));
                                    num = sgDatabase->TableDeleteByFileID(match.entry.fileID);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num == 1);
                                } else {
                                    ASSERT(HasCSIndex(match.entry.csIndex));
                                    num = sgDatabase->TableDeleteByCSIndex(&match.entry.csIndex);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num > 0);
                                }

                                CLEAR_FILE(match);
                                break;

// MATCH_ERROR: an error occured while opening or reading the match
// file. Close the file and mark that the target file may need to be
// groveled again, then go on to try the next match file.

                            case MATCH_ERROR:

                                CloseFile(&match);
                                CLEAR_FILE(match);
                                needToRetry = TRUE;
                                break;

// MATCH_STALE: the match file table entry is invalid for some reason.
// Close the file, remove its entry from the table, enqueue
// it to be re-groveled, then go on to the next match file.

                            case MATCH_STALE:

                                CloseFile(&match);

                                if (match.entry.fileID != 0) {

                                    queueEntry.fileID    = match.entry.fileID;
                                    queueEntry.parentID  = match.parentID;
                                    queueEntry.reason    = 0;
                                    queueEntry.readyTime = GetTime() + grovelInterval;
                                    queueEntry.retryTime = 0;
                                    queueEntry.fileName  = NULL;

                                    numActions                 =  2;
                                    actionList[0].type         =  TABLE_DELETE_BY_FILE_ID;
                                    actionList[0].u.fileID     =  match.entry.fileID;
                                    actionList[1].type         =  QUEUE_PUT;
                                    actionList[1].u.queueEntry = &queueEntry;
#if DBG
                                    enqueueTime = (DWORD)(grovelInterval / 10000);
                                    DPRINTF((_T("   Enqueuing match file %s to be groveled in %lu.%03lu sec\n"),
                                        match.fileName, enqueueTime / 1000, enqueueTime % 1000));
#endif

                                    DoTransaction(numActions, actionList);

                                } else {

                                    ASSERT(HasCSIndex(match.entry.csIndex));
                                    EnqueueCSIndex(&match.entry.csIndex);

                                }

                                CLEAR_FILE(match);
                                break;

                            default:

                                ASSERT_PRINTF(FALSE, (_T("matchException=%lu\n"),
                                    matchException));
                        }
                    }
                }
            }

// Target exceptions

            catch (TargetException targetException) {

                inCompare = FALSE;

                DPRINTF((_T("WORKER: Handling TargetException %d, status=%d\n"),
                    targetException,GetLastError()));

                switch (targetException) {

// TARGET_INVALID: the target file is invalid for some reason: it doesn't
// exist, it is disallowed properties, it is in the queue by both file
// name and file ID, or it was in the queue by file name and has already
// been groveled. Close the files, remove the target file's entry from
// the table, then go on to grovel the next target file.

                    case TARGET_INVALID:

                        CloseFile(&target);
                        CloseFile(&match);

                        if (matchList != NULL) {
                            delete matchList;
                            matchList = NULL;
                        }

                        if (csIndexTable != NULL) {
                            delete csIndexTable;
                            csIndexTable = NULL;
                        }

                        numActions                 = 1;
                        actionList[0].type         = QUEUE_DELETE;
                        actionList[0].u.queueIndex = queueIndex;

                        if (target.entry.fileID != 0) {
                            numActions             = 2;
                            actionList[1].type     = TABLE_DELETE_BY_FILE_ID;
                            actionList[1].u.fileID = target.entry.fileID;
                        }

                        DoTransaction(numActions, actionList);
                        break;

// An error occured while opening or reading the target file. Close
// the files and re-enqueue the target file to be groveled again.

                    case TARGET_ERROR:

                        ASSERT(target.entry.fileID != 0
                            || target.fileName[0]  != _T('\0'));

                        CloseFile(&target);
                        CloseFile(&match);

                        queueEntry.fileID    = target.entry.fileID;
                        queueEntry.parentID  = target.parentID;
                        queueEntry.reason    = 0;
                        queueEntry.fileName  = target.entry.fileID == 0
                                             ? target.fileName : NULL;

                        queueEntry.retryTime = target.retryTime * 2; // Exponential back-off
                        if (queueEntry.retryTime < grovelInterval)
                            queueEntry.retryTime = grovelInterval;
                        queueEntry.readyTime = GetTime() + queueEntry.retryTime;

                        actionList[0].type         =  QUEUE_DELETE;
                        actionList[0].u.queueIndex =  queueIndex;
                        actionList[1].type         =  QUEUE_PUT;
                        actionList[1].u.queueEntry = &queueEntry;

#if DBG
                        enqueueTime = (DWORD)(queueEntry.retryTime / 10000);
                        if (target.entry.fileID != 0) {
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        } else {
                            DPRINTF((_T("   Re-enqueuing target file %s to be groveled in %lu.%03lu sec\n"),
                                target.fileName, enqueueTime / 1000, enqueueTime % 1000));
                        }
#endif

                        DoTransaction(2, actionList);
                        break;

                    default:

                        ASSERT_PRINTF(FALSE, (_T("targetException=%lu\n"),
                            targetException));
                }
            }

// Do some clean-up.

            ASSERT(target.handle == NULL);
            ASSERT(match .handle == NULL);

            if (matchList != NULL) {
                delete matchList;
                matchList = NULL;
            }

            if (csIndexTable != NULL) {
                delete csIndexTable;
                csIndexTable = NULL;
            }

// Update the activity counters for this target file,
// then go on to process the next file.

            if (hashed) {
                hashCount++;
                hashBytes += target.entry.fileSize;
            }

            compareCount += numCompares;
            compareBytes += numCompares * target.entry.fileSize;

            matchCount += numMatches;
            matchBytes += numMatches * target.entry.fileSize;

            if (merged) {
                mergeCount++;
                mergeBytes += target.entry.fileSize;
            }

            CLEAR_FILE(target);
            CLEAR_FILE(match);

            CLEAR_OVERLAPPED(mergeSynch);
        }
    }

// Terminal exceptions

    catch (TerminalException terminalException) {
        switch (terminalException) {

            case INITIALIZE_ERROR:
                break;

// DATABASE_ERROR: an error occured in the database. Return an error status.

            case DATABASE_ERROR:
                break;

// MEMORY_ERROR: unable to allocate memory. Return an error status.

            case MEMORY_ERROR:
                DPRINTF((_T("%s: Unable to allocate memory\n"),
                    driveLetterName));
                break;

// TERMINATE: grovel() signaled for this thread to terminate.

            case TERMINATE:
                break;

            default:
                ASSERT_PRINTF(FALSE, (_T("terminalException=%lu\n"),
                    terminalException));
        }
    }

// Close the files and clean up.

    CloseFile(&target);
    CloseFile(&target);

    CLEAR_FILE(target);
    CLEAR_FILE(match);

    if (matchList != NULL) {
        delete matchList;
        matchList = NULL;
    }

    if (csIndexTable != NULL) {
        delete csIndexTable;
        csIndexTable = NULL;
    }

    if (target.oplock.hEvent != NULL) {
        success = CloseHandle(target.oplock.hEvent);
        ASSERT_ERROR(success);
        target.oplock.hEvent = NULL;
    }
    if (match.oplock.hEvent != NULL) {
        success = CloseHandle(match.oplock.hEvent);
        ASSERT_ERROR(success);
        match.oplock.hEvent = NULL;
    }
    if (target.readSynch.hEvent != NULL) {
        success = CloseHandle(target.readSynch.hEvent);
        ASSERT_ERROR(success);
        target.readSynch.hEvent = NULL;
    }
    if (match.readSynch.hEvent != NULL) {
        success = CloseHandle(match.readSynch.hEvent);
        ASSERT_ERROR(success);
        match.readSynch.hEvent = NULL;
    }
    if (mergeSynch.hEvent != NULL) {
        success = CloseHandle(mergeSynch.hEvent);
        ASSERT_ERROR(success);
        mergeSynch.hEvent = NULL;
    }
    if (abortMergeEvent != NULL) {
        success = CloseHandle(abortMergeEvent);
        ASSERT_ERROR(success);
        abortMergeEvent = NULL;
    }

    if (buffer1 != NULL) {
        delete buffer1;
        buffer1 = NULL;
    }
    if (buffer2 != NULL) {
        delete buffer2;
        buffer2 = NULL;
    }
    if (buffer3 != NULL) {
        delete buffer3;
        buffer3 = NULL;
    }
    if (buffer4 != NULL) {
        delete buffer4;
        buffer4 = NULL;
    }

    inUseFileID1 = NULL;
    inUseFileID2 = NULL;

// Signal grovel() that this thread is terminating by
// setting the grovelStop event with an error status.

    grovelThread = NULL;

    grovelStatus = Grovel_error;
    ASSERT(IsReset(grovelStopEvent));
    success = SetEvent(grovelStopEvent);
    ASSERT_ERROR(success);
}

/*****************************************************************************/
/******************* Groveler class static private methods *******************/
/*****************************************************************************/

// WorkerThread() runs in its own thread.
// It calls Worker() to perform the groveling processing.

DWORD Groveler::WorkerThread(VOID *groveler)
{
    ((Groveler *)groveler)->Worker();
    return 0; // Dummy return value
}

/*****************************************************************************/
/*********************** Groveler class public methods ***********************/
/*****************************************************************************/

BOOL Groveler::set_log_drive(const _TCHAR *drive_name)
{
    return SGDatabase::set_log_drive(drive_name);
}

// is_sis_installed tests whether the SIS filter is
// installed on a volume by calling SIS copyfile.

BOOL Groveler::is_sis_installed(const _TCHAR *drive_name)
{
    HANDLE volHandle;

    SI_COPYFILE copyFile;

    DWORD transferCount,
          lastError;

    BOOL success;

    volHandle = CreateFile(
        drive_name,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (volHandle == INVALID_HANDLE_VALUE)
        return FALSE;

    copyFile.SourceFileNameLength      = 0;
    copyFile.DestinationFileNameLength = 0;
    copyFile.Flags                     = COPYFILE_SIS_REPLACE;

    success = DeviceIoControl(
        volHandle,
        FSCTL_SIS_COPYFILE,
        (VOID *)&copyFile,
        sizeof(SI_COPYFILE),
        NULL,
        0,
        &transferCount,
        NULL);

    lastError = GetLastError();
    ASSERT(!success);

    success = CloseHandle(volHandle);
    ASSERT_ERROR(success);

    switch (lastError) {

        case ERROR_INVALID_FUNCTION:
            return FALSE;

        case ERROR_INVALID_PARAMETER:
            return TRUE;                    //sis is installed on this volume

        default:

            ASSERT_PRINTF(FALSE, (_T("lastError=%lu\n"), lastError));
    }

    return FALSE; // Dummy return value
}

/*****************************************************************************/

// The groveler constructor creates and initializes all class variables.

Groveler::Groveler()
{
    volumeHandle        = NULL;
    grovHandle          = NULL;

    sgDatabase          = NULL;
    driveName           = NULL;
    driveLetterName     = NULL;
    databaseName        = NULL;

    numDisallowedIDs    = 0;
    numDisallowedNames  = 0;
    disallowedIDs       = NULL;
    disallowedNames     = NULL;

    grovelStartEvent    = NULL;
    grovelStopEvent     = NULL;
    grovelThread        = NULL;

    inUseFileID1        = NULL;
    inUseFileID2        = NULL;

    abortGroveling      = FALSE;
    inCompare           = FALSE;
    inScan              = FALSE;
    terminate           = TRUE;

    usnID               = lastUSN = UNINITIALIZED_USN;
}

/*****************************************************************************/

// The groveler destructor destroys all class variables.

Groveler::~Groveler()
{
// If the volume is open, call close() to close it.

    close();

    ASSERT(volumeHandle == NULL);
    ASSERT(grovHandle   == NULL);

    ASSERT(sgDatabase   == NULL);
    ASSERT(driveName    == NULL);
    ASSERT(driveLetterName == NULL);
    ASSERT(databaseName == NULL);

    ASSERT(numDisallowedIDs   == 0);
    ASSERT(numDisallowedNames == 0);
    ASSERT(disallowedIDs      == NULL);
    ASSERT(disallowedNames    == NULL);

    ASSERT(grovelStartEvent   == NULL);
    ASSERT(grovelStopEvent    == NULL);
    ASSERT(grovelThread       == NULL);

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

    ASSERT(terminate);
    ASSERT(!inCompare);
    ASSERT(!inScan);

    ASSERT(usnID == UNINITIALIZED_USN);
}

/*****************************************************************************/

// Open() opens the specified volume.

GrovelStatus Groveler::open(
	IN const TCHAR  *drive_name,
	IN const TCHAR  *drive_letterName,
    IN BOOL          is_log_drive,
    IN DOUBLE        read_report_discard_threshold,
    IN DWORD         min_file_size,
    IN DWORD         min_file_age,
    IN BOOL          allow_compressed_files,
    IN BOOL          allow_encrypted_files,
    IN BOOL          allow_hidden_files,
    IN BOOL          allow_offline_files,
    IN BOOL          allow_temporary_files,
    IN DWORD         num_excluded_paths,
    IN const TCHAR **excluded_paths,
    IN DWORD         base_regrovel_interval,
    IN DWORD         max_regrovel_interval)
{
    DWORD threadID;

    TCHAR fileStr[MAX_PATH];

    TCHAR listValue[MAX_PATH+1],
         *strPtr;

    USN_JOURNAL_DATA usnJournalData;

    SGNativeListEntry listEntry;

    DWORDLONG fileID;

    DWORD sectorsPerCluster,
          numberOfFreeClusters,
          totalNumberOfClusters,
          bufferSize,
          strLen,
          i;

    GrovelStatus openStatus;

    LONG num;

#if DBG
    BOOL wroteHeader = FALSE;
#endif

    BOOL success;

    ASSERT(volumeHandle == NULL);
    ASSERT(grovHandle   == NULL);

    ASSERT(sgDatabase   == NULL);
    ASSERT(databaseName == NULL);

    ASSERT(numDisallowedIDs   == 0);
    ASSERT(numDisallowedNames == 0);
    ASSERT(disallowedIDs      == NULL);
    ASSERT(disallowedNames    == NULL);

    ASSERT(grovelStartEvent   == NULL);
    ASSERT(grovelStopEvent    == NULL);
    ASSERT(grovelThread       == NULL);

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

    ASSERT(terminate);
    ASSERT(!inCompare);
    ASSERT(!inScan);

    ASSERT(usnID == UNINITIALIZED_USN);

#if 0
while (!IsDebuggerPresent())
    Sleep(2000);

DebugBreak();
#endif

	//
	// Make sure that the filter has run phase 2 initialization if this is
	// a SIS enabled volume.
	//
	is_sis_installed(drive_name);

    driveName = new TCHAR[_tcslen(drive_name) + 1];
	_tcscpy(driveName, drive_name);
    driveName[_tcslen(driveName)-1] = _T('\0');;     //remove trailing '\'

    driveLetterName = new TCHAR[_tcslen(drive_letterName) + 1];
	_tcscpy(driveLetterName, drive_letterName);
    strLen = _tcslen(driveLetterName);
    if (strLen > 2) {
        driveLetterName[strLen-2] = _T('\0');     //remove trailing ':\'
    }

#ifdef _CRTDBG
	// Send all reports to STDOUT
	_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
	_CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDERR );
	_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
	_CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDERR );
	_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
	_CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDERR );
#endif

// Open the volume and the GrovelerFile.  The SIS fsctl
// functions require that we pass in a handle to GrovelerFile as a means
// of proving our "privilege".  An access violation is returned if we don't.

    volumeHandle = CreateFile(
        driveName,
        GENERIC_READ    | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED|FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (volumeHandle == INVALID_HANDLE_VALUE) {
        volumeHandle = NULL;
        DPRINTF((_T("%s: Can't open volume \"%s\" %lu\n"),
                driveLetterName, driveName, GetLastError()));
        close();
        return Grovel_error;
    }

    _tcscpy(fileStr,driveName);
    _tcscat(fileStr,CS_DIR_PATH);
    _tcscat(fileStr,_T("\\"));
    _tcscat(fileStr,GROVELER_FILE_NAME);

    grovHandle = CreateFile(
        fileStr,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);
    if (grovHandle == INVALID_HANDLE_VALUE) {
        grovHandle = NULL;
        DPRINTF((_T("%s: can't open groveler file \"%s\": %lu\n"),
            driveLetterName, fileStr, GetLastError()));
        close();
        return Grovel_error;
    }

    _tcscpy(fileStr,driveName);
    _tcscat(fileStr,_T("\\"));

    success = GetDiskFreeSpace(fileStr, &sectorsPerCluster, &sectorSize,
        &numberOfFreeClusters, &totalNumberOfClusters);
    ASSERT(success);

    ASSERT(SIG_PAGE_SIZE % sectorSize == 0);
    ASSERT(CMP_PAGE_SIZE % sectorSize == 0);

    sigReportThreshold =
        (DWORD)((DOUBLE)SIG_PAGE_SIZE * read_report_discard_threshold);
    cmpReportThreshold =
        (DWORD)((DOUBLE)CMP_PAGE_SIZE * read_report_discard_threshold);

//
// Open this volume's database. If this fails, create a
// new database. If that fails, return an error status.
//

    ASSERT(databaseName == NULL);
    strLen = _tcslen(driveName) + _tcslen(CS_DIR_PATH) + _tcslen(DATABASE_FILE_NAME) + 1;     // +1 for '\'
    databaseName = new TCHAR[strLen+1];
    ASSERT(databaseName != NULL);

    _stprintf(databaseName, _T("%s%s\\%s"), driveName, CS_DIR_PATH, DATABASE_FILE_NAME);

    sgDatabase = new SGDatabase();
    if (sgDatabase == NULL) {
        DPRINTF((_T("%s: can't create database object\n"),
            driveLetterName));
        close();
        return Grovel_error;
    }

    openStatus = Grovel_ok;

    if (get_usn_log_info(&usnJournalData) != Grovel_ok) {
        DPRINTF((_T("%s: can't initialize usnID\n"),
            driveLetterName));
    } else {
        usnID = usnJournalData.UsnJournalID;

        if (!sgDatabase->Open(databaseName, is_log_drive)) {
            DPRINTF((_T("%s: can't open database \"%s\"\n"),
                driveLetterName, databaseName));
        } else {
            listValue[0]    = _T('\0');
            listEntry.name  = LAST_USN_NAME;
            listEntry.value = listValue;
            if (sgDatabase->ListRead(&listEntry) <= 0
             || _stscanf(listValue, _T("%I64x"), &lastUSN) != 1
             || lastUSN == UNINITIALIZED_USN) {
                DPRINTF((_T("%s: can't get last USN value\n"), driveLetterName));
            } else {
                DWORDLONG storedUsnID;

                listValue[0]    = _T('\0');
                listEntry.name  = USN_ID_NAME;
                listEntry.value = listValue;
                if (sgDatabase->ListRead(&listEntry) <= 0
                 || _stscanf(listValue, _T("%I64x"), &storedUsnID) != 1
                 || storedUsnID != usnID) {
                    DPRINTF((_T("%s: can't get USN ID value from database\n"), driveLetterName));
                } else {
                    num = sgDatabase->StackCount();
                    if (0 == num)
                        goto OpenedDatabase;
                }
            }
        }
    }

// Set abortGroveling to block the worker thread, and set lastUSN to block extract_log
// until scan_volume starts.

    abortGroveling = TRUE;
    lastUSN = usnID = UNINITIALIZED_USN;
    openStatus = Grovel_new;

OpenedDatabase:

// Create the disallowed directories list.

    if (num_excluded_paths == 0) {
        disallowedIDs   = NULL;
        disallowedNames = NULL;
    } else {
        disallowedIDs   = new DWORDLONG[num_excluded_paths];
        disallowedNames = new TCHAR *  [num_excluded_paths];
        ASSERT(disallowedIDs   != NULL);
        ASSERT(disallowedNames != NULL);

        for (i = 0; i < num_excluded_paths; i++) {
            ASSERT(excluded_paths[i] != NULL);

            if (excluded_paths[i][0] == _T('\\')) {
                strLen = _tcslen(excluded_paths[i]);
                while (strLen > 1 && excluded_paths[i][strLen-1] == _T('\\'))
                    strLen--;

                strPtr = new TCHAR[strLen+1];
                ASSERT(strPtr != NULL);
                disallowedNames[numDisallowedNames++] = strPtr;

                _tcsncpy(strPtr, excluded_paths[i], strLen);
                strPtr[strLen] = _T('\0');

                fileID = GetFileID(strPtr);
                if (fileID != 0)
                    disallowedIDs[numDisallowedIDs++] = fileID;
#if DBG
                else {
                    if (!wroteHeader) {
                        DPRINTF((_T("%s: can't open excluded paths\n"),
                            driveLetterName));
                        wroteHeader = TRUE;
                    }
                    DPRINTF((_T("\t%s\n"), strPtr));
                }
#endif
            }
        }

        if (numDisallowedNames == 0) {
            delete disallowedNames;
            disallowedNames = NULL;
        } else if (numDisallowedNames > 1)
            qsort(
                disallowedNames,
                numDisallowedNames,
                sizeof(TCHAR *),
                qsStringCompare);

        if (numDisallowedIDs == 0) {
            delete disallowedIDs;
            disallowedIDs = NULL;
        } else if (numDisallowedIDs > 1)
            qsort(
                disallowedIDs,
                numDisallowedIDs,
                sizeof(DWORDLONG),
                FileIDCompare);
    }

//
// Set the remaining class values.
//
// minFileAge is expressed in 10^-7 seconds, min_file_age in milliseconds.
//

    minFileSize    = min_file_size > MIN_FILE_SIZE ? min_file_size : MIN_FILE_SIZE;
    minFileAge     = min_file_age  * 10000;
    grovelInterval = minFileAge > MIN_GROVEL_INTERVAL ? minFileAge : MIN_GROVEL_INTERVAL;

    disallowedAttributes =           FILE_ATTRIBUTE_DIRECTORY
     | (allow_compressed_files ? 0 : FILE_ATTRIBUTE_COMPRESSED)
     | (allow_encrypted_files  ? 0 : FILE_ATTRIBUTE_ENCRYPTED)
     | (allow_hidden_files     ? 0 : FILE_ATTRIBUTE_HIDDEN)
     | (allow_offline_files    ? 0 : FILE_ATTRIBUTE_OFFLINE)
     | (allow_temporary_files  ? 0 : FILE_ATTRIBUTE_TEMPORARY);

//
// Create the events used to handshake with the worker thread.
//

    if ((grovelStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL
     || (grovelStopEvent  = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
        DPRINTF((_T("%s: unable to create events: %lu\n"),
            driveLetterName, GetLastError()));
        close();
        return Grovel_error;
    }

//
// Create the worker thread, then wait for it to set
// the grovelStop event to announce its existence.
//

    terminate = FALSE;

    grovelThread = CreateThread(
        NULL,
        0,
        WorkerThread,
        (VOID *)this,
        0,
        &threadID);
    if (grovelThread == NULL) {
        DPRINTF((_T("%s: can't create the worker thread: %lu\n"),
            driveLetterName, GetLastError()));
        close();
        return Grovel_error;
    }

    WaitForEvent(grovelStopEvent);

    if (grovelStatus == Grovel_error) {
        grovelThread = NULL;
        close();
        return Grovel_error;
    }
    ASSERT(grovelStatus == Grovel_ok);

    return openStatus;
}

/*****************************************************************************/

GrovelStatus Groveler::close()
{
    DWORD i;

    LONG num;

    BOOL success;

// If active, signal the worker thread to stop,
// then wait for it to acknowledge.

    terminate = TRUE;

    if (grovelThread != NULL) {
        ASSERT(grovelStartEvent != NULL);
        ASSERT(grovelStopEvent  != NULL);

        timeAllotted = INFINITE;
        do {
            ASSERT(IsReset(grovelStartEvent));
            success = SetEvent(grovelStartEvent);
            ASSERT_ERROR(success);
            WaitForEvent(grovelStopEvent);
        } while (grovelStatus != Grovel_error);

        grovelThread = NULL;
    }

    inCompare = FALSE;
    inScan    = FALSE;
    usnID     = UNINITIALIZED_USN;

    ASSERT(inUseFileID1 == NULL);
    ASSERT(inUseFileID2 == NULL);

// Close the events.

    if (grovelStartEvent != NULL) {
        success = CloseHandle(grovelStartEvent);
        ASSERT_ERROR(success);
        grovelStartEvent = NULL;
    }

    if (grovelStopEvent != NULL) {
        success = CloseHandle(grovelStopEvent);
        ASSERT_ERROR(success);
        grovelStopEvent = NULL;
    }

// If the volume or GrovelerFile are open, close them.

    if (volumeHandle != NULL) {
        success = CloseHandle(volumeHandle);
        ASSERT_ERROR(success);
        volumeHandle = NULL;
    }

    if (grovHandle != NULL) {
        success = CloseHandle(grovHandle);
        ASSERT_ERROR(success);
        grovHandle = NULL;
    }

// Close this volume's database.

    if (sgDatabase != NULL) {
        delete sgDatabase;
        sgDatabase = NULL;
    }

    if (databaseName != NULL) {
        delete[] databaseName;
        databaseName = NULL;
    }

// Deallocate the disallowed directory lists.

    if (numDisallowedNames == 0) {
        ASSERT(disallowedNames == NULL);
    } else {
        for (i = 0; i < numDisallowedNames; i++)
            delete (disallowedNames[i]);
        delete disallowedNames;
        disallowedNames    = NULL;
        numDisallowedNames = 0;
    }

    if (numDisallowedIDs == 0) {
        ASSERT(disallowedIDs == NULL);
    } else {
        delete disallowedIDs;
        disallowedIDs    = NULL;
        numDisallowedIDs = 0;
    }

    if (driveName != NULL) {
        delete[] driveName;
        driveName = NULL;
    }

    if (driveLetterName != NULL) {
        delete[] driveLetterName;
        driveLetterName = NULL;
    }

    return Grovel_ok;
}

/*****************************************************************************/

// grovel() is the front-end method for controlling the groveling
// process on each NTFS volume. The groveling process itself is
// implemented in the Worker() method. grovel() starts the groveling
// process by setting the grovelStart event. Worker() signals back to
// grovel() that it is finished or has used up its time allocation by
// setting the grovelStop event, which causes grovel() to return.

GrovelStatus Groveler::grovel(
    IN  DWORD      time_allotted,

    OUT DWORD     *hash_read_ops,
    OUT DWORD     *hash_read_time,
    OUT DWORD     *count_of_files_hashed,
    OUT DWORDLONG *bytes_of_files_hashed,

    OUT DWORD     *compare_read_ops,
    OUT DWORD     *compare_read_time,
    OUT DWORD     *count_of_files_compared,
    OUT DWORDLONG *bytes_of_files_compared,

    OUT DWORD     *count_of_files_matching,
    OUT DWORDLONG *bytes_of_files_matching,

    OUT DWORD     *merge_time,
    OUT DWORD     *count_of_files_merged,
    OUT DWORDLONG *bytes_of_files_merged,

    OUT DWORD     *count_of_files_enqueued,
    OUT DWORD     *count_of_files_dequeued)
{
    DWORD timeConsumed;

    BOOL success;

    ASSERT(volumeHandle != NULL);

    hashCount     = 0;
    hashReadCount = 0;
    hashReadTime  = 0;
    hashBytes     = 0;

    compareCount     = 0;
    compareReadCount = 0;
    compareReadTime  = 0;
    compareBytes     = 0;

    matchCount = 0;
    matchBytes = 0;

    mergeCount = 0;
    mergeTime  = 0;
    mergeBytes = 0;

    numFilesEnqueued = 0;
    numFilesDequeued = 0;

#ifdef DEBUG_UNTHROTTLED
    timeAllotted = INFINITE;
#else
    timeAllotted = time_allotted;
#endif

    startAllottedTime = GetTickCount();

    ASSERT(IsReset(grovelStartEvent));
    success = SetEvent(grovelStartEvent);
    ASSERT_ERROR(success);
    WaitForEvent(grovelStopEvent);
    timeConsumed = GetTickCount() - startAllottedTime;

// Return the performance statistics.

    if (count_of_files_hashed   != NULL)
        *count_of_files_hashed   = hashCount;
    if (hash_read_ops           != NULL)
        *hash_read_ops           = hashReadCount;
    if (hash_read_time          != NULL)
        *hash_read_time          = hashReadTime;
    if (bytes_of_files_hashed   != NULL)
        *bytes_of_files_hashed   = hashBytes;

    if (count_of_files_compared != NULL)
        *count_of_files_compared = compareCount;
    if (compare_read_ops        != NULL)
        *compare_read_ops        = compareReadCount;
    if (compare_read_time       != NULL)
        *compare_read_time       = compareReadTime;
    if (bytes_of_files_compared != NULL)
        *bytes_of_files_compared = compareBytes;

    if (count_of_files_matching != NULL)
        *count_of_files_matching = matchCount;
    if (bytes_of_files_matching != NULL)
        *bytes_of_files_matching = matchBytes;

    if (count_of_files_merged   != NULL)
        *count_of_files_merged   = mergeCount;
    if (merge_time              != NULL)
        *merge_time              = mergeTime;
    if (bytes_of_files_merged   != NULL)
        *bytes_of_files_merged   = mergeBytes;

    if (count_of_files_enqueued != NULL)
        *count_of_files_enqueued = numFilesEnqueued;
    if (count_of_files_dequeued != NULL)
        *count_of_files_dequeued = numFilesDequeued;

    TRACE_PRINTF(TC_groveler, 2,
        (_T("%s            Count   Reads   Bytes Time (sec)\n"),
        driveLetterName));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Hashings: %7lu %7lu %7I64u %4lu.%03lu    Time: %5lu.%03lu sec\n"),
        hashCount, hashReadCount, hashBytes,
        hashReadTime / 1000, hashReadTime % 1000,
        timeConsumed / 1000, timeConsumed % 1000));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Compares: %7lu %7lu %7I64u %4lu.%03lu    Enqueues: %lu\n"),
        compareCount, compareReadCount, compareBytes,
        compareReadTime / 1000, compareReadTime % 1000, numFilesEnqueued));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Matches:  %7lu         %7I64u             Dequeues: %lu\n"),
        matchCount, matchBytes, numFilesDequeued));
    TRACE_PRINTF(TC_groveler, 2,
        (_T("  Merges:   %7lu         %7I64u %4lu.%03lu\n"),
        mergeCount, mergeBytes, mergeTime / 1000, mergeTime % 1000));

    return grovelStatus;
}

/*****************************************************************************/

// count_of_files_in_queue() returns a count of the number
// of files in this volume's queue waiting to be groveled.

DWORD Groveler::count_of_files_in_queue() const
{
    LONG numEntries;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    numEntries = sgDatabase->QueueCount();
    if (numEntries < 0)
        return 0;

    TPRINTF((_T("%s: count_of_files_in_queue=%ld\n"),
        driveLetterName, numEntries));

    return (DWORD)numEntries;
}

/*****************************************************************************/

// count_of_files_to_compare() returns 1 if two files are ready to be
// compared or are in the process of being compared, and 0 otherwise.

DWORD Groveler::count_of_files_to_compare() const
{
    DWORD numCompareFiles;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    numCompareFiles = inCompare ? 1 : 0;

    TPRINTF((_T("%s: count_of_files_to_compare=%lu\n"),
        driveLetterName, numCompareFiles));

    return numCompareFiles;
}

/*****************************************************************************/

// time_to_first_file_ready() returns the time in milliseconds until
// the first entry in the queue is ready to be groveled. If the queue
// is empty, it returns INFINITE. If an error occurs, it returns 0.

DWORD Groveler::time_to_first_file_ready() const
{
    SGNativeQueueEntry queueEntry;

    DWORDLONG currentTime;

    DWORD earliestTime;

    LONG num;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);

    queueEntry.fileName = NULL;
    num = sgDatabase->QueueGetFirst(&queueEntry);
    if (num < 0)
        return 0;

    if (num == 0)
        earliestTime = INFINITE;
    else {
        ASSERT(num == 1);
        currentTime  = GetTime();
        earliestTime = queueEntry.readyTime > currentTime
                     ? (DWORD)((queueEntry.readyTime - currentTime) / 10000)
                     : 0;
    }

    TPRINTF((_T("%s: time_to_first_file_ready=%lu.%03lu\n"),
        driveLetterName, earliestTime / 1000, earliestTime % 1000));

    return earliestTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\inifile.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    inifile.cpp

Abstract:

	SIS Groveler initialization file interface

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

_TCHAR IniFile::id_buffer[id_buffer_length];

bool
IniFile::read(
	const _TCHAR *filename,
	const _TCHAR *section,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(filename != 0);
	ASSERT(section != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	for (int index = 0; index < num_entries; index++)
	{
		ASSERT(entries[index].identifier != 0);
		ASSERT(entries[index].default_value != 0);
		ASSERT(entries[index].pointer != 0);
		DWORD num_chars = GetPrivateProfileString(
			section,
			entries[index].identifier,
			entries[index].default_value,
			id_buffer,
			id_buffer_length,
			filename);
		load_string_into_value(entries[index].type, id_buffer,
			entries[index].pointer);
	}
	return true;
}

bool
IniFile::overwrite(
	const _TCHAR *filename,
	const _TCHAR *section,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(filename != 0);
	ASSERT(section != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	for (int index = 0; index < num_entries; index++)
	{
		ASSERT(entries[index].identifier != 0);
		ASSERT(entries[index].pointer != 0);
		store_value_in_string(entries[index].type, entries[index].pointer,
			id_buffer);
		BOOL success = WritePrivateProfileString(
			section,
			entries[index].identifier,
			id_buffer,
			filename);
		if (!success)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((
				_T("GROVELER: WritePrivateProvileString() failed with error %d\n"), err));
		}
	}
	return true;
}

bool
IniFile::read_string_set(
	const _TCHAR *filename,
	const _TCHAR *section,
	int *num_strings,
	_TCHAR ***strings,
	_TCHAR **buffer)
{
	ASSERT(filename != 0);
	ASSERT(section != 0);
	ASSERT(num_strings != 0);
	ASSERT(strings != 0);
	ASSERT(buffer != 0);
	*num_strings = 0;
	*strings = 0;
	*buffer = 0;
	DWORD copied_chars;
	DWORD buffer_size = 128;
	_TCHAR *string_buffer = 0;
	do
	{
		if (string_buffer != 0)
		{
			delete[] string_buffer;
		}
		buffer_size *= 2;
		string_buffer = new _TCHAR[buffer_size];
		copied_chars = GetPrivateProfileSection(
			section,
			string_buffer,
			buffer_size,
			filename);
	} while (copied_chars >= buffer_size - 2);
	int num_values = 0;
	_TCHAR **string_set = 0;
	if (string_buffer[0] != 0)
	{
		num_values = 1;
		for (int index = 0;
			string_buffer[index] != 0 || string_buffer[index + 1] != 0;
			index++)
		{
			if (string_buffer[index] == 0)
			{
				num_values++;
			}
		}
		string_set = new _TCHAR *[num_values];
		int buffer_offset = 0;
		for (index = 0; index < num_values; index++)
		{
			while (string_buffer[buffer_offset] != _T('='))
			{
				ASSERT(string_buffer[buffer_offset] != 0);
				buffer_offset++;
			}
			string_set[index] = &string_buffer[buffer_offset + 1];
			buffer_offset += _tcslen(string_set[index]) + 2;
		}
	}
	*num_strings = num_values;
	*strings = string_set;
	*buffer = string_buffer;
	return true;
}

void
IniFile::load_string_into_value(
	EntryType type,
	const _TCHAR *string,
	void *value)
{
	ASSERT(string != 0);
	ASSERT(value != 0);
	switch (type)
	{
	case entry_bool:
		*((bool *)value) = _ttoi(string) != 0;
		break;
	case entry_char:
		*((_TCHAR *)value) = string[0];
		break;
	case entry_int:
		_stscanf(string, _T("%d"), (int *)value);
		break;
	case entry_int64:
		_stscanf(string, _T("%I64d"), (__int64 *)value);
		break;
	case entry_double:
		_stscanf(string, _T("%lf"), (double *)value);
		break;
	default:
		ASSERT(false);
	}
}

void
IniFile::store_value_in_string(
	EntryType type,
	void *value,
	_TCHAR *string)
{
	ASSERT(string != 0);
	ASSERT(value != 0);
	switch (type)
	{
	case entry_bool:
		_stprintf(string, *((bool *)value) ? _T("1") : _T("0"));
		break;
	case entry_char:
		_stprintf(string, _T("%c"), *((_TCHAR *)value));
		break;
	case entry_int:
		_stprintf(string, _T("%d"), *((int *)value));
		break;
	case entry_int64:
		_stprintf(string, _T("%I64d"), *((__int64 *)value));
		break;
	case entry_double:
		_stprintf(string, _T("%g"), *((double *)value));
		break;
	default:
		ASSERT(false);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\inifile.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    inifile.h

Abstract:

	SIS Groveler initialization file interface headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_INIFILE

#define _INC_INIFILE

#ifndef _DEF_ENTRY_INFO
#define _DEF_ENTRY_INFO

enum EntryType
{
	entry_bool,
	entry_char,
	entry_int,
	entry_int64,
	entry_double
};

struct EntrySpec
{
	const _TCHAR *identifier;
	EntryType type;
	const _TCHAR *default_value;
	void *pointer;
};

#endif	/* _DEF_ENTRY_INFO */

class IniFile
{
public:

	static bool read(
		const _TCHAR *filename,
		const _TCHAR *section,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite(
		const _TCHAR *filename,
		const _TCHAR *section,
		int num_entries,
		EntrySpec *entries);

	static bool	read_string_set(
		const _TCHAR *filename,
		const _TCHAR *section,
		int *num_strings,
		_TCHAR ***strings,
		_TCHAR **buffer);

private:

	enum {id_buffer_length = 256};

	static void load_string_into_value(
		EntryType type,
		const _TCHAR *string,
		void *value);

	static void store_value_in_string(
		EntryType type,
		void *value,
		_TCHAR *string);

	IniFile() {}
	~IniFile() {}

	static _TCHAR id_buffer[id_buffer_length];
};

#endif	/* _INC_INIFILE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\groveler.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	groveler.h

Abstract:

	SIS Groveler file groveling headers

Authors:

	Cedric Krumbein, 1998

Environment:

	User Mode

Revision History:

--*/

#define CS_DIR_PATH                     _T("\\SIS Common Store")
#define GROVELER_FILE_NAME              _T("GrovelerFile")
#define DATABASE_FILE_NAME              _T("database.mdb")
#define DATABASE_DELETE_RES_FILE_NAME   _T("res*.log")
#define DATABASE_DELETE_LOG_FILE_NAME   _T("*.log")
#define LAST_USN_NAME                   _T("LastUSN")
#define USN_ID_NAME                     _T("UsnID")

#define MIN_FILE_SIZE                1
#define MIN_GROVEL_INTERVAL  600000000 // One minute
#define SIG_PAGE_SIZE             4096
#define CMP_PAGE_SIZE            65536
#define MAX_ACTIONS_PER_TRANSACTION 64

#define UNINITIALIZED_USN MAXLONGLONG


// Groveler class definitions

enum GrovelStatus {
	Grovel_ok,
	Grovel_pending,
	Grovel_error,
	Grovel_overrun,
	Grovel_new,
	Grovel_disable
};


struct FileData {
	SGNativeTableEntry entry;
	DWORDLONG          parentID,
	                   retryTime;
	HANDLE             handle;
	DWORD              startTime,
	                   stopTime;
	OVERLAPPED         readSynch,
	                   oplock;
	TCHAR              fileName[MAX_PATH+1];
	BYTE              *buffer  [2];
};

enum DatabaseActionType {
	TABLE_PUT,
	TABLE_DELETE_BY_FILE_ID,
	QUEUE_PUT,
	QUEUE_DELETE
};

struct DatabaseActionList {
	DatabaseActionType type;
	union {
		SGNativeTableEntry *tableEntry;
		DWORDLONG           fileID;
		SGNativeQueueEntry *queueEntry;
		DWORD               queueIndex;
	} u;
};


class Groveler {
private:

	TCHAR *driveName,
	      *driveLetterName,
          *databaseName,
	     **disallowedNames;

	DWORD sectorSize,
	      sigReportThreshold,
	      cmpReportThreshold,
	      numDisallowedNames,
	      numDisallowedIDs,
	      disallowedAttributes,
	      startAllottedTime,
	      timeAllotted,
	      hashCount,
	      hashReadCount,
	      hashReadTime,
	      compareCount,
	      compareReadCount,
	      compareReadTime,
	      matchCount,
	      mergeCount,
	      mergeTime,
	      numFilesEnqueued,
	      numFilesDequeued;

	DWORDLONG *disallowedIDs,
	          *inUseFileID1,
	          *inUseFileID2,
	           usnID,
	           minFileSize,
	           minFileAge,
	           grovelInterval,
	           lastUSN,
	           hashBytes,
	           compareBytes,
	           matchBytes,
	           mergeBytes;

	HANDLE volumeHandle,
           grovHandle,
	       grovelStartEvent,
	       grovelStopEvent,
	       grovelThread;

	SGDatabase *sgDatabase;

	GrovelStatus grovelStatus;

	BOOL abortGroveling,
         inScan,
	     inCompare,
	     terminate;

	BOOL IsAllowedID(DWORDLONG fileID) const;

	BOOL IsAllowedName(TCHAR *fileName) const;

	VOID WaitForEvent(HANDLE event);

	BOOL OpenFileByID(
		FileData *file,
		BOOL      writeEnable);

	BOOL OpenFileByName(
		FileData *file,
		BOOL      writeEnable,
		TCHAR    *fileName = NULL);

	BOOL IsFileMapped(FileData *file);

	BOOL SetOplock(FileData *file);

	VOID CloseFile(FileData *file);

    BOOL CreateDatabase(void);

	VOID DoTransaction(
		DWORD               numActions,
		DatabaseActionList *actionList);

	VOID EnqueueCSIndex(CSID *csIndex);

	VOID SigCheckPoint(
		FileData *target,
		BOOL      targetRead);

	VOID CmpCheckPoint(
		FileData *target,
		FileData *match,
		BOOL      targetRead,
		BOOL      matchRead);

	BOOL MergeCheckPoint(
		FileData   *target,
		FileData   *match,
		OVERLAPPED *mergeSynch,
		HANDLE      abortMergeEvent,
		BOOL        merge);

	BOOL GetTarget(
		FileData *target,
		DWORD    *queueIndex);

	VOID CalculateSignature(FileData *target);

	VOID GetMatchList(
		FileData *target,
		FIFO     *matchList,
		Table    *csIndexTable);

	BOOL GetCSFile(
		FileData *target,
		FileData *match,
		Table    *csIndexTable);

	BOOL GetMatch(
		FileData *target,
		FileData *match,
		FIFO     *matchList);

	BOOL Compare(
		FileData *target,
		FileData *match);

	BOOL Merge(
		FileData   *target,
		FileData   *match,
		OVERLAPPED *mergeSynch,
		HANDLE      abortMergeEvent);

	VOID Worker();

	GrovelStatus extract_log2(
		OUT DWORD     *num_entries_extracted,
		OUT DWORDLONG *num_bytes_extracted,
		OUT DWORDLONG *num_bytes_skipped,
		OUT DWORD     *num_files_enqueued,
		OUT DWORD     *num_files_dequeued);

	static DWORD WorkerThread(VOID *groveler);

public:

	static BOOL is_sis_installed(const _TCHAR *drive_name);

    static BOOL set_log_drive(const _TCHAR *drive_name);

	Groveler();

	~Groveler();

	GrovelStatus open(
		IN const TCHAR  *drive_name,
		IN const TCHAR  *drive_letterName,
        IN BOOL          is_log_drive,
		IN DOUBLE        read_report_discard_threshold,
		IN DWORD         min_file_size,
		IN DWORD         min_file_age,
		IN BOOL          allow_compressed_files,
		IN BOOL          allow_encrypted_files,
		IN BOOL          allow_hidden_files,
		IN BOOL          allow_offline_files,
		IN BOOL          allow_temporary_files,
		IN DWORD         num_excluded_paths,
		IN const TCHAR **excluded_paths,
		IN DWORD         base_regrovel_interval,
		IN DWORD         max_regrovel_interval);

	GrovelStatus close();

	GrovelStatus scan_volume(
		IN  DWORD  time_allotted,
		IN  BOOL   start_over,
		OUT DWORD *time_consumed,
		OUT DWORD *findfirst_count,
		OUT DWORD *findnext_count,
		OUT DWORD *count_of_files_enqueued);

	GrovelStatus set_usn_log_size(
		IN DWORDLONG usn_log_size);

    GrovelStatus get_usn_log_info(
	    OUT USN_JOURNAL_DATA *usnJournalData);

	GrovelStatus extract_log(
		OUT DWORD     *num_entries_extracted,
		OUT DWORDLONG *num_bytes_extracted,
		OUT DWORDLONG *num_bytes_skipped,
		OUT DWORD     *num_files_enqueued,
		OUT DWORD     *num_files_dequeued);

	GrovelStatus grovel(
		IN  DWORD      time_allotted,

		OUT DWORD     *hash_read_ops,
		OUT DWORD     *hash_read_time,
		OUT DWORD     *count_of_files_hashed,
		OUT DWORDLONG *bytes_of_files_hashed,

		OUT DWORD     *compare_read_ops,
		OUT DWORD     *compare_read_time,
		OUT DWORD     *count_of_files_compared,
		OUT DWORDLONG *bytes_of_files_compared,

		OUT DWORD     *count_of_files_matching,
		OUT DWORDLONG *bytes_of_files_matching,

		OUT DWORD     *merge_time,
		OUT DWORD     *count_of_files_merged,
		OUT DWORDLONG *bytes_of_files_merged,

		OUT DWORD     *count_of_files_enqueued,
		OUT DWORD     *count_of_files_dequeued);

	DWORD count_of_files_in_queue() const;

	DWORD count_of_files_to_compare() const;

	DWORD time_to_first_file_ready() const;
};

// Special debugging flags

// #define DEBUG_USN_REASON
// #define DEBUG_GET_BY_ATTR
// #define DEBUG_UNTHROTTLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\grovperf.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovperf.cpp

Abstract:

	SIS Groveler performance DLL main file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR *service_name = _T("Groveler");

static DWORD first_counter;
static DWORD first_help;
static int open_count = 0;

static SharedData *shared_data;

static const int ms_per_100ns_inv = 10000;

static __int64 total_counter[num_perf_counters];

extern "C" DWORD CALLBACK OpenGrovelerPerformanceData(LPWSTR lpDeviceNames)
{
	if (open_count == 0)
	{
		shared_data = new SharedData;
		ASSERT(shared_data != 0);
		HKEY path_key;
		_TCHAR perf_path[1024];
		_stprintf(perf_path,
			_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
			service_name);
		long result =
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, perf_path, 0, KEY_READ, &path_key);
		ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
		if (result != ERROR_SUCCESS)
		{
			return result;
		}
		ASSERT(path_key != 0);
		first_counter = 0;
		DWORD ctr_size = sizeof(DWORD);
		result = RegQueryValueEx(path_key, _T("First Counter"), 0, 0,
			(BYTE *)&first_counter, &ctr_size);
		ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
		if (result != ERROR_SUCCESS)
		{
			return result;
		}
		first_help = 0;
		ctr_size = sizeof(DWORD);
		result = RegQueryValueEx(path_key, _T("First Help"), 0, 0,
			(BYTE *)&first_help, &ctr_size);
		ASSERT_PRINTF(result == ERROR_SUCCESS, (_T("error = %d\n"), result));
		if (result != ERROR_SUCCESS)
		{
			return result;
		}
		ASSERT(path_key != 0);
		RegCloseKey(path_key);
		path_key = 0;
    }
    open_count++;
    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI CloseGrovelerPerformanceData()
{
	open_count--;
	if (open_count == 0)
	{
		ASSERT(shared_data != 0);
		delete shared_data;
		shared_data = 0;
	}
	return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI CollectGrovelerPerformanceData(
	LPWSTR lpwszValue,
	LPVOID *lppData,
    LPDWORD lpcbBytes,
	LPDWORD lpcObjectTypes)
{
	if (open_count == 0)
	{
		*lpcbBytes = 0;
		*lpcObjectTypes = 0;
		return ERROR_SUCCESS;
	}
	int num_partitions;
	SharedDataRecord records[max_shared_data_records];
	bool ok = shared_data->extract_values(&num_partitions, records);
	if (!ok)
	{
		*lpcbBytes = 0;
		*lpcObjectTypes = 0;
		return ERROR_SUCCESS;
	}
	int data_size = space_needed_for_data(num_partitions);
	if (data_size > int(*lpcbBytes))
	{
		*lpcbBytes = 0;
		*lpcObjectTypes = 0;
		return ERROR_MORE_DATA;
	}
	build_part_object_info_block(lppData, num_partitions, data_size);
	for (int index = 0; index < num_partitions; index++)
	{
		build_part_instance_info_block(lppData, index, records);
	}
	if (num_partitions > 0)
	{
		build_total_instance_info_block(lppData, num_partitions, records);
	}
	*lpcbBytes = data_size;
	*lpcObjectTypes = 1;
	return ERROR_SUCCESS;
}

int space_needed_for_data(
	int num_partitions)
{
	if (num_partitions > 0)
	{
		return sizeof(PartitionObjectInformationBlock) +
			num_partitions * sizeof(PartitionInstanceInformationBlock) +
			sizeof(TotalInstanceInformationBlock);
	}
	else
	{
		return sizeof(PartitionObjectInformationBlock);
	}
}

void build_part_object_info_block(
	LPVOID *lppData,
	int num_partitions,
	int data_size)
{
	int num_instances = 0;
	if (num_partitions > 0)
	{
		num_instances = num_partitions + 1;
	}
	PartitionObjectInformationBlock *block =
		(PartitionObjectInformationBlock *)*lppData;
	block->object_type.TotalByteLength = data_size;
	block->object_type.DefinitionLength =
		sizeof(PartitionObjectInformationBlock);
	block->object_type.HeaderLength = sizeof(PERF_OBJECT_TYPE);
	block->object_type.ObjectNameTitleIndex = first_counter;
	block->object_type.ObjectNameTitle = 0;
	block->object_type.ObjectHelpTitleIndex = first_help;
	block->object_type.ObjectHelpTitle = 0;
	block->object_type.DetailLevel = object_info.detail_level;
	block->object_type.NumCounters = num_perf_counters;
	block->object_type.DefaultCounter = 0;
	block->object_type.NumInstances = num_instances;
	block->object_type.CodePage = 0;
	for (int index = 0; index < num_perf_counters; index++)
	{
		block->definition[index].ByteLength = sizeof(PERF_COUNTER_DEFINITION);
		block->definition[index].CounterNameTitleIndex =
			first_counter + 2 * (index + 1);
		block->definition[index].CounterNameTitle = 0;
		block->definition[index].CounterHelpTitleIndex =
			first_help + 2 * (index + 1);
		block->definition[index].CounterHelpTitle = 0;
		block->definition[index].DefaultScale = 0;
		block->definition[index].DetailLevel = counter_info[index].detail_level;
		block->definition[index].CounterType = counter_info[index].counter_type;
		block->definition[index].CounterSize = sizeof(LARGE_INTEGER);
		block->definition[index].CounterOffset =
		    FIELD_OFFSET( PartitionData, counter[index] );
	}
	*lppData = (void *)(block + 1);
}

void build_part_instance_info_block(
	LPVOID *lppData,
	int partition_index,
	SharedDataRecord *records)
{
	PartitionInstanceInformationBlock *block =
		(PartitionInstanceInformationBlock *)*lppData;
	block->instance_def.ByteLength =
	    FIELD_OFFSET(PartitionInstanceInformationBlock, partition_data);
	block->instance_def.ParentObjectTitleIndex = 0;
	block->instance_def.ParentObjectInstance = 0;
	block->instance_def.UniqueID = PERF_NO_UNIQUE_ID;
	block->instance_def.NameOffset =
	    FIELD_OFFSET(PartitionInstanceInformationBlock, instance_name);
	block->instance_def.NameLength =
		sizeof(_TCHAR) * (partition_name_length);

	_stprintf(block->instance_name, _T("%-.*s"),
		        partition_name_length,
		        records[partition_index].driveName);


	block->partition_data.counter_block.ByteLength = sizeof(PartitionData);
	for (int index = 0; index < num_perf_counters; index++)
	{
		switch (counter_info[index].counter_type)
		{
		case PERF_100NSEC_TIMER:
			block->partition_data.counter[index].QuadPart = ms_per_100ns_inv *
				records[partition_index].fields[counter_info[index].source];
			break;
		default:
			block->partition_data.counter[index].QuadPart =
				records[partition_index].fields[counter_info[index].source];
			break;
		}
	}
	*lppData = (void *)(block + 1);
}

void build_total_instance_info_block(
	LPVOID *lppData,
	int num_partitions,
	SharedDataRecord *records)
{
	TotalInstanceInformationBlock *block =
		(TotalInstanceInformationBlock *)*lppData;
	block->instance_def.ByteLength =
		FIELD_OFFSET(TotalInstanceInformationBlock, partition_data);
	block->instance_def.ParentObjectTitleIndex = 0;
	block->instance_def.ParentObjectInstance = 0;
	block->instance_def.UniqueID = PERF_NO_UNIQUE_ID;
	block->instance_def.NameOffset =
		FIELD_OFFSET(TotalInstanceInformationBlock, instance_name);
	block->instance_def.NameLength =
		sizeof(_TCHAR) * (total_name_length);
	_tcscpy(block->instance_name, _T("_Total"));
	block->partition_data.counter_block.ByteLength = sizeof(PartitionData);
	for (int index = 0; index < num_perf_counters; index++)
	{
		total_counter[index] = 0;
	}
	for (int part = 0; part < num_partitions; part++)
	{
		for (index = 0; index < num_perf_counters; index++)
		{
			total_counter[index] +=
				records[part].fields[counter_info[index].source];
		}
	}
	for (index = 0; index < num_perf_counters; index++)
	{
		switch (counter_info[index].counter_type)
		{
		case PERF_100NSEC_TIMER:
			block->partition_data.counter[index].QuadPart =
				ms_per_100ns_inv * total_counter[index];
			break;
		default:
			block->partition_data.counter[index].QuadPart =
				total_counter[index];
			break;
		}
	}
	*lppData = (void *)(block + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\logdrive.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logdrive.cpp

Abstract:

	SIS Groveler logging drive class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR registry_parameter_path[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Parameters");
static const _TCHAR *log_drive_key_name = _T("log drive");

LogDrive::LogDrive()
{
    _TCHAR *guid_name;

	part_initted = 0;
	registry_written = false;
	log_drive_index = 0;
	_TCHAR reg_name[MAX_PATH + 1];
	read_registry(reg_name,sizeof(reg_name));

	int partition_count = sis_drives.partition_count();
	ASSERT(partition_count > 0);

	part_initted = new bool[partition_count];
	for (int index = 0; index < partition_count; index++)
	{
		part_initted[index] = false;
	}

	for (index = 0; index < partition_count; index++)
	{
		guid_name = sis_drives.partition_guid_name(index);
		if (_tcsicmp(reg_name, guid_name) == 0)
		{
			log_drive_index = index;
			write_registry(_T(""));
			return;
		}
	}

	__int64 log_drive_space = 0;
	for (index = 0; index < partition_count; index++)
	{
		guid_name = sis_drives.partition_guid_name(index);
		ULARGE_INTEGER my_free_bytes;
		ULARGE_INTEGER total_bytes;
		ULARGE_INTEGER free_bytes;
		int ok = GetDiskFreeSpaceEx(
			guid_name, &my_free_bytes, &total_bytes, &free_bytes);
		if (ok)
		{
			__int64 space = free_bytes.QuadPart;
			if (space > log_drive_space)
			{
				log_drive_space = space;
				log_drive_index = index;
			}
		}
		else
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: GetDiskFreeSpaceEx() failed with error %d\n"),
				err));
		}
	}
	write_registry(_T(""));
}

LogDrive::~LogDrive()
{
	if (part_initted != 0)
	{
		delete[] part_initted;
		part_initted = 0;
	}
}

void
LogDrive::partition_initialized(
	int partition_index)
{
	if (!registry_written)
	{
		int partition_count = sis_drives.partition_count();
		ASSERT(partition_index >= 0);
		ASSERT(partition_index < partition_count);
		part_initted[partition_index] = true;
		for (int index = 0; index < partition_count; index++)
		{
			if (!part_initted[index])
			{
				return;
			}
		}
		write_registry(sis_drives.partition_guid_name(log_drive_index));
		registry_written = true;
	}
}

bool
LogDrive::read_registry(
	_TCHAR *name,
	DWORD size)
{
	DWORD type;
	try
	{
		HKEY path_key = 0;
		Registry::open_key_ex(HKEY_LOCAL_MACHINE,
			registry_parameter_path, REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, &path_key);
		try
		{
			Registry::query_value_ex(path_key, log_drive_key_name, 0,
				&type, (BYTE *)name, &size);
		}
		catch (DWORD result)
		{
			ASSERT(result != ERROR_SUCCESS);
			PRINT_DEBUG_MSG((
				_T("GROVELER: Registry::query_value_ex() failed with error %d\n"),
				result));
			ASSERT(path_key != 0);
			Registry::close_key(path_key);
			path_key = 0;
            *name = 0;
			return false;
		}
		ASSERT(path_key != 0);
		Registry::close_key(path_key);
		path_key = 0;
	}
	catch (DWORD result)
	{
		ASSERT(result != ERROR_SUCCESS);
		PRINT_DEBUG_MSG((_T("GROVELER: Registry::open_key_ex() or Registry::close_key() ")
			_T("failed with error %d\n"), result));
        *name = 0;
		return false;
	}
	if (type != REG_EXPAND_SZ)
	{
        *name = 0;
		return false;
	}
	return true;
}

bool
LogDrive::write_registry(
	_TCHAR *name)
{
	try
	{
		HKEY path_key = 0;
		DWORD disp;
		Registry::create_key_ex(HKEY_LOCAL_MACHINE,
			registry_parameter_path, 0, 0, REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 0, &path_key, &disp);
		try
		{
			Registry::set_value_ex(path_key, log_drive_key_name, 0,
				REG_EXPAND_SZ, (BYTE *)name,
				(_tcslen(name) + 1) * sizeof(_TCHAR));
		}
		catch (DWORD result)
		{
			ASSERT(result != ERROR_SUCCESS);
			PRINT_DEBUG_MSG((
				_T("GROVELER: Registry::set_value_ex() failed with error %d\n"),
				result));
			ASSERT(path_key != 0);
			Registry::close_key(path_key);
			path_key = 0;
			return false;
		}
		ASSERT(path_key != 0);
		Registry::close_key(path_key);
		path_key = 0;
	}
	catch (DWORD result)
	{
		ASSERT(result != ERROR_SUCCESS);
		PRINT_DEBUG_MSG((_T("GROVELER: Registry::create_key_ex() or Registry::close_key() ")
			_T("failed with error %d\n"), result));
		return false;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\grovel.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    grovel.cpp

Abstract:

	SIS Groveler main function

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

/*
 *	The core of the groveler executable is an object of the EventTimer class.
 *	All periodic operations are registered with the global event_timer object,
 *	and they are called at appropriate times during the execution of the
 *	event_timer.run() function.
 *
 *	Errors are written to the system event log, which is accessed through
 *	member functions of the EventLog class.  The eventlog object is a global
 *	so that any function or member function of any class can log an event if
 *	necessary.
 *
 *	The service control thread synchronizes with the main groveler thread via
 *	a Windows event.  This event is encapsulated in an object of the SyncEvent
 *	class.
 *
 *	The SISDrives class determines which drives have SIS installed.
 *
 *	The SharedData class is used to write values that are read by the groveler
 *	performance DLL, so that the groveler's operation can be monitored by
 *	PerfMon.  This object needs to be global so that any function or member
 *	function of any class can record performance information.
 *
 *	The CentralController class is instantiated into a global object, rather
 *	than an object local to the main() function, so that the service controller
 *	can invoke CentralController member functions in order to affect its
 *	operation.
 *
 *	Initially, the shared_data and controller pointers are set to null, so that
 *	if an exception occurs, the code that deletes allocated objects can check
 *	for a null to determine whether or not the object has been instantiated.
 *
 */

EventTimer event_timer;
EventLog eventlog;
SyncEvent sync_event(false, false);
SISDrives sis_drives;
LogDrive *log_drive = 0;
SharedData *shared_data = 0;
CentralController *controller = 0;

/*
 *	Ordinarily, the groveler does not stop operation until it is told to by
 *	a command from the service control manager.  However, for testing, it can
 *	sometimes be useful to specify a time limit for running.  The groveler thus
 *	accepts a first argument that indicates such a time limit.  If an argument
 *	is supplied, an invokation of the halt() function is scheduled in the
 *	event_timer object for the specified time.
 *
 */

void halt(
	void *context)
{
	event_timer.halt();
};

/*
 *	The function groveler_new_handler() is installed as a new handler by the
 *	_set_new_handler() function.  Whenever a memory allocation failure occurs,
 *	it throws an exception_memory_allocation, which is caught by the catch
 *	clause in the main() function.
 *
 */

int __cdecl groveler_new_handler(
	size_t bytes)
{
	throw exception_memory_allocation;
	return 0;
}

/*
 *	This file contains the main() function and declarations for global objects
 *	for the groveler.exe program, as well as a couple of simple ancillary
 *	functions, halt() and groveler_new_handler().
 *
 *	The main() function reads configuration information, instantiates a set of
 *	primary objects -- the most significant of which are instances of the
 *	classes Groveler and CentralController -- and enters the run() member
 *	function of the event_timer object, which periodically invokes member
 *	functions of other objects, most notably those of the clasess
 *	CentralController and PartitionController.
 *
 *	Configuration information comes from objects of three classes:
 *	ReadParameters, ReadDiskInformation, and PathList.  The ReadParameters
 *	and PathList classes provide configuration information that applies to
 *	grovelers on all partitions.  The ReadDiskInformation class provides
 *	configuration information that applies to a single disk partition.  One
 *	object of the ReadDiskInformation class is instantiated for each drive
 *	that has SIS installed, as explained above.
 *
 *	For each SIS drive, the main() function instantiates an object of the
 *	ReadDiskInformation class to determine the configuration options (which
 *	ReadDiskInformation obtains from the registry) for the given disk
 *	partition.  If the drive is configured to enable groveling, then an object
 *	of the Groveler class is instantiated for that drive.
 *
 *	The main() function then instantiates an object of class CentralController,
 *	which in turn instantiates an object of class PartitionController for each
 *	SIS-enabled disk partition.  Each partition controller is assigned to one
 *	object of the Groveler class, and it controls the groveler by calling its
 *	member functions at appropriate times.
 *
 *	Nearly all of of the processing done by the groveler executable is
 *	performed within a try clause, the purpose of which is to catch errors of
 *	terminal severity.  There are two such errors (defined in all.hxx) that are
 *	expected to throw such exceptions: a memory allocation failure and a
 *	failure to create an Windows event.  If either of these conditions occurs,
 *	the program terminates.
 *
 */

_main(int argc, _TCHAR **argv)
{
	_set_new_handler(groveler_new_handler);
	SetErrorMode(SEM_FAILCRITICALERRORS);
	int exit_code = NO_ERROR;
	int num_partitions = 0;
    int index;

    //
	// Initially, these pointers are set to null, so that if an exception
	// occurs, the code that deletes allocated objects can check for a null
	// to determine whether or not the object has been instantiated.
    //

	Groveler *grovelers = 0;
	GrovelStatus *groveler_statuses = 0;
	ReadDiskInformation **read_disk_info = 0;
	WriteDiskInformation **write_disk_info = 0;

    //
	// If program tracing is being performed, and if the traces are being sent
	// to a file, the file is opened.  This call is made through a macro
	// so that no code will be generated for released builds.  Since this call
	// is made before the try clause, it is important that the function not
	// perform any operation that could throw an exception, such as a memory
	// allocation.
    //

	OPEN_TRACE_FILE();

	try
	{
        //
		// If a first argument is provided, it is the run period.
        //

		if (argc > 1)
		{
			int run_period = _ttoi(argv[1]);
			if (run_period <= 0)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: run period must be greater than zero\n")));
				return ERROR_BAD_ARGUMENTS;
			}
			unsigned int start_time = GET_TICK_COUNT();
			event_timer.schedule(start_time + run_period, 0, halt);
		}

#if DEBUG_WAIT

		// When debugging the groveler as a service, if the process is attached
		// to a debugger after it has started, then the initialization code
		// will usually be executed before the debugger has a chance to break.
		// However, by defining DEBUG_WAIT to a non-zero value, the code will
		// get stuck in the following infinite loop before doing the bulk of
		// its initialization.  (The event_timer, eventlog, and sync_event
		// objects will have been constructed, because they are declared as
		// globals.)  The debugger can then be used to set debug_wait to false,
		// and debugging can commence with the subsequent code.
		bool debug_wait = true;
		while (debug_wait)
		{
			SLEEP(100);
		};

#endif // DEBUG_WAIT

		eventlog.report_event(GROVMSG_SERVICE_STARTED, 0);
		sis_drives.open();

        //
        //  See if there were any partions to scan.  If not, quit
        //

		num_partitions = sis_drives.partition_count();
		if (num_partitions == 0)
		{
			PRINT_DEBUG_MSG((_T("GROVELER: No local partitions have SIS installed.\n")));
			eventlog.report_event(GROVMSG_NO_PARTITIONS, 0);
			eventlog.report_event(GROVMSG_SERVICE_STOPPED, 0);
			return ERROR_SERVICE_NOT_ACTIVE;
		}

        //
        //  Report the service is running
        //

		SERVICE_REPORT_START();

        //
        //  Setup shared data are between all the worker threads
        //

		num_partitions = sis_drives.partition_count();

        _TCHAR **drive_names = new _TCHAR *[num_partitions];
		for (index = 0; index < num_partitions; index++)
		{
			drive_names[index] = sis_drives.partition_mount_name(index);
		}

		shared_data = new SharedData(num_partitions, drive_names);

        delete drive_names;

        //
        //  Get READ parameters
        //

		ReadParameters read_parameters;
		ASSERT(read_parameters.parameter_backup_interval >= 0);

        //
        //  Get WRITE parameters
        //

		WriteParameters write_parameters(read_parameters.parameter_backup_interval);

        //
        //  Get excluded path list
        //

		PathList excluded_paths;

        //
        //  Setup LogDrive
        //

		log_drive = new LogDrive;

		Groveler::set_log_drive(sis_drives.partition_mount_name(log_drive->drive_index()));

        //
        //  Setup Groveler objects
        //

		grovelers = new Groveler[num_partitions];
		groveler_statuses = new GrovelStatus[num_partitions];

        //
		// Initially, the status of each partition is set to Grovel_disable so
		// that the close() member function of each Groveler object will not
		// be called unless the open() function is called first.
        //

		for (index = 0; index < num_partitions; index++)
		{
			groveler_statuses[index] = Grovel_disable;
		}

        //
		// Initially, the read_disk_info[] and write_disk_info[] arrays are set
		// to null, so that if an exception occurs, the code that deletes
		// allocated objects can check for a null to determine whether or not
		// the object has been instantiated.
        //

		read_disk_info = new ReadDiskInformation *[num_partitions];
        ZeroMemory(read_disk_info, sizeof(ReadDiskInformation *) * num_partitions);

		write_disk_info = new WriteDiskInformation *[num_partitions];
        ZeroMemory(read_disk_info, sizeof(WriteDiskInformation *) * num_partitions);

        //
        //  Now initilaize each partition
        //

		for (index = 0; index < num_partitions; index++)
		{
			read_disk_info[index] = new ReadDiskInformation(sis_drives.partition_guid_name(index));

			write_disk_info[index] = new WriteDiskInformation(sis_drives.partition_guid_name(index),read_parameters.parameter_backup_interval);

			if (read_disk_info[index]->enable_groveling)
			{
				groveler_statuses[index] = grovelers[index].open(
					        sis_drives.partition_guid_name(index),
					        sis_drives.partition_mount_name(index),
					        index == log_drive->drive_index(),
					        read_parameters.read_report_discard_threshold,
					        read_disk_info[index]->min_file_size,
					        read_disk_info[index]->min_file_age,
					        read_disk_info[index]->allow_compressed_files,
					        read_disk_info[index]->allow_encrypted_files,
					        read_disk_info[index]->allow_hidden_files,
					        read_disk_info[index]->allow_offline_files,
					        read_disk_info[index]->allow_temporary_files,
					        excluded_paths.num_paths[index],
					        excluded_paths.paths[index],
					        read_parameters.base_regrovel_interval,
					        read_parameters.max_regrovel_interval);

				ASSERT(groveler_statuses[index] != Grovel_disable);
			}

			if (groveler_statuses[index] == Grovel_ok)
			{
				log_drive->partition_initialized(index);
				eventlog.report_event(GROVMSG_GROVELER_STARTED, 1,
					sis_drives.partition_mount_name(index));
			}
			else if (groveler_statuses[index] == Grovel_disable)
			{
				eventlog.report_event(GROVMSG_GROVELER_DISABLED, 1,
					sis_drives.partition_mount_name(index));
			}
			else if (groveler_statuses[index] != Grovel_new)
			{
				ASSERT(groveler_statuses[index] == Grovel_error);
				eventlog.report_event(GROVMSG_GROVELER_NOSTART, 1,
					sis_drives.partition_mount_name(index));
			}
		}

        //
		// We have to pass a lot of information to the central controller that
		// it shouldn't really need.  However, if a groveler fails, this
		// information is needed to restart it.  It would be better if the
		// Groveler open() member function had a form that did not require
		// arguments, but rather re-used the arguments that had been passed in
		// previously.  But this is not how it currently works.
        //

		controller = new CentralController(
			num_partitions,
			grovelers,
			groveler_statuses,
			&read_parameters,
			&write_parameters,
			read_disk_info,
			write_disk_info,
			excluded_paths.num_paths,
			excluded_paths.paths);

		SERVICE_RECORD_PARTITION_INDICES();


		ASSERT(read_parameters.grovel_duration > 0);

		SERVICE_SET_MAX_RESPONSE_TIME(read_parameters.grovel_duration);

        //
		// If any grovelers are alive, tell the service control manager that
		// we have concluded the initialization, then commence running.
        //

		if (controller->any_grovelers_alive())
		{
			event_timer.run();
		}

        //
		// If tracing is being performed in delayed mode, print the trace log
		// now that the run has completed.
        //

		PRINT_TRACE_LOG();
	} catch (Exception exception) {
		switch (exception)
		{
		    case exception_memory_allocation:
			    eventlog.report_event(GROVMSG_MEMALLOC_FAILURE, 0);
			    break;

		    case exception_create_event:
			    eventlog.report_event(GROVMSG_CREATE_EVENT_FAILURE, 0);
			    break;

		    default:
			    eventlog.report_event(GROVMSG_UNKNOWN_EXCEPTION, 0);
			    break;
		}
		exit_code = ERROR_EXCEPTION_IN_SERVICE;
	}

    //
	// If program tracing is being performed, and if the traces are being sent
	// to a file, the file is closed.  This call is made through a macro
	// so that no code will be generated for released builds.  Since the trace
	// file is being closed before the objects are deleted, it is important
	// not to write trace information in the destructor of an object.
    //

	CLOSE_TRACE_FILE();

    //
	// Close each groveler object that was opened.
    //

	if (groveler_statuses != 0 && grovelers != 0)
	{
		for (int index = 0; index < num_partitions; index++)
		{
			if (groveler_statuses[index] != Grovel_disable)
			{
				grovelers[index].close();
			}
		}
	}

    //
	// Delete all objects that were allocated.
    //

	if (groveler_statuses != 0)
	{
		delete[] groveler_statuses;
		groveler_statuses = 0;
	}

	if (grovelers != 0)
	{
		delete[] grovelers;
		grovelers = 0;
	}

	if (read_disk_info != 0)
	{
		for (int index = 0; index < num_partitions; index++)
		{
			if (read_disk_info[index] != 0)
			{
				delete read_disk_info[index];
				read_disk_info[index] = 0;
			}
		}
		delete[] read_disk_info;
		read_disk_info = 0;
	}

	if (write_disk_info != 0)
	{
		for (int index = 0; index < num_partitions; index++)
		{
			if (write_disk_info[index] != 0)
			{
				delete write_disk_info[index];
				write_disk_info[index] = 0;
			}
		}
		delete[] write_disk_info;
		write_disk_info = 0;
	}

	if (controller != 0)
	{
		delete controller;
		controller = 0;
	}

	if (shared_data != 0)
	{
		delete shared_data;
		shared_data = 0;
	}

	if (log_drive != 0)
	{
		delete log_drive;
		log_drive = 0;
	}

	eventlog.report_event(GROVMSG_SERVICE_STOPPED, 0);
	return exit_code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\logdrive.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logdrive.h

Abstract:

	SIS Groveler logging drive header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_LOGDRIVE

#define _INC_LOGDRIVE

class LogDrive
{
public:

	LogDrive();

	~LogDrive();

	int drive_index() const
		{return log_drive_index;}

	void partition_initialized(
		int partition_index);

private:

	static bool read_registry(
		_TCHAR *name,
		DWORD size);

	static bool write_registry(
		_TCHAR *name);

	int log_drive_index;

	bool *part_initted;
	bool registry_written;
};

#endif	/* _INC_LOGDRIVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\mutex.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mutex.h

Abstract:

	SIS Groveler named mutex class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_MUTEX

#define _INC_MUTEX

class NamedMutex
{
public:

	NamedMutex(
		const _TCHAR *name,
		SECURITY_ATTRIBUTES *security_attributes = 0);

	~NamedMutex();

	bool release();

	bool acquire(
		unsigned int timeout);

private:

	HANDLE mutex_handle;
};

#endif	/* _INC_MUTEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\mutex.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mutex.cpp

Abstract:

	SIS Groveler named mutex class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

NamedMutex::NamedMutex(
	const _TCHAR *name,
	SECURITY_ATTRIBUTES *security_attributes)
{
	ASSERT(this != 0);
	mutex_handle = CreateMutex(security_attributes, FALSE, name);
	if (mutex_handle == 0)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: CreateMutex() failed with error %d\n"), err));
	}
}

NamedMutex::~NamedMutex()
{
	ASSERT(this != 0);
	if (mutex_handle != 0)
	{
		int ok = CloseHandle(mutex_handle);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
		}
		mutex_handle = 0;
	}
}

bool
NamedMutex::release()
{
	ASSERT(this != 0);
	if (mutex_handle == 0)
	{
		return false;
	}
	BOOL ok = ReleaseMutex(mutex_handle);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: ReleaseMutex() failed with error %d\n"), err));
	}
	return (ok != 0);
}

bool
NamedMutex::acquire(
	unsigned int timeout)
{
	ASSERT(this != 0);
	if (mutex_handle == 0)
	{
		return false;
	}
	ASSERT(signed(timeout) >= 0);
	DWORD result = WaitForSingleObject(mutex_handle, timeout);
	if (result != WAIT_TIMEOUT && result != WAIT_OBJECT_0)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: WaitForSingleObject() returned error %d\n"),
			result));
	}
	return (result == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\params.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

	SIS Groveler parameter support & defaults

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR registry_parameter_path[] =
	_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Parameters");

ReadParameters::ReadParameters()
{
	ASSERT(this != 0);
	static EntrySpec registry_entries[registry_entry_count] =
	{
		{_T("parameter backup interval"),			entry_int,		_T("600000"),	&parameter_backup_interval},
		{_T("target entries per log extraction"),	entry_int,		_T("100"),		&target_entries_per_extraction},
		{_T("max extraction interval"),				entry_int,		_T("10000"),	&max_extraction_interval},
		{_T("base grovel interval"),				entry_int,		_T("5000"),		&base_grovel_interval},
		{_T("max grovel interval"),					entry_int,		_T("600000"),	&max_grovel_interval},
		{_T("max response lag"),					entry_int,		_T("10000"),	&max_response_lag},
		{_T("low-confidence grovel interval"),		entry_int,		_T("15000"),	&low_confidence_grovel_interval},
		{_T("low-disk-space grovel interval"),		entry_int,		_T("500"),		&low_disk_space_grovel_interval},
		{_T("working grovel interval"),				entry_int,		_T("500"),		&working_grovel_interval},
		{_T("grovel duration"),						entry_int,		_T("400"),		&grovel_duration},
		{_T("partition info update interval"),		entry_int,		_T("60000"),	&partition_info_update_interval},
		{_T("base restart extraction interval"),	entry_int,		_T("10000"),	&base_restart_extraction_interval},
		{_T("max restart extraction interval"),		entry_int,		_T("3600000"),	&max_restart_extraction_interval},
		{_T("base restart groveling interval"),		entry_int,		_T("30000"),	&base_restart_groveling_interval},
		{_T("max restart groveling interval"),		entry_int,		_T("86400000"),	&max_restart_groveling_interval},
		{_T("base regrovel interval"),				entry_int,		_T("60000"),	&base_regrovel_interval},
		{_T("max regrovel interval"),				entry_int,		_T("86400000"),	&max_regrovel_interval},
		{_T("volscan regrovel threshold"),			entry_int,		_T("120000"),	&volscan_regrovel_threshold},
		{_T("partition balance time constant"),		entry_int,		_T("1800000"),	&partition_balance_time_constant},
		{_T("read time increase history size"),		entry_int,		_T("5"),		&read_time_increase_history_size},
		{_T("read time decrease history size"),		entry_int,		_T("2"),		&read_time_decrease_history_size},
		{_T("SIS efficacy history size"),			entry_int,		_T("1000"),		&sis_efficacy_history_size},
		{_T("log winnow history size"),				entry_int,		_T("1000"),		&log_winnow_history_size},
		{_T("file size history size"),				entry_int,		_T("1000"),		&file_size_history_size},
		{_T("sample group size"),					entry_int,		_T("10"),		&sample_group_size},
		{_T("acceptance P-value"),					entry_double,	_T("0.2"),		&acceptance_p_value},
		{_T("rejection P-value"),					entry_double,	_T("0.05"),		&rejection_p_value},
		{_T("base use multiplier"),					entry_double,	_T("1.0"),		&base_use_multiplier},
		{_T("max use multiplier"),					entry_double,	_T("2.0"),		&max_use_multiplier},
		{_T("peak finder accuracy"),				entry_double,	_T("0.05"),		&peak_finder_accuracy},
		{_T("peak finder range"),					entry_double,	_T("20.0"),		&peak_finder_range},
		{_T("base CPU load threshold"),				entry_double,	_T("0.50"),		&base_cpu_load_threshold},
		{_T("max CPU load threshold"),				entry_double,	_T("1.0"),		&max_cpu_load_threshold},
		{_T("read report discard threshold"),		entry_double,	_T("0.75"),		&read_report_discard_threshold}
	};

	Registry::read(HKEY_LOCAL_MACHINE, registry_parameter_path,
		registry_entry_count, registry_entries);

#if WRITE_ALL_PARAMETERS

	bool registry_write_ok =
		Registry::write(HKEY_LOCAL_MACHINE, registry_parameter_path,
		registry_entry_count, registry_entries);
	if (!registry_write_ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Registry::write() to %s failed\n"),
			registry_parameter_path));
	}

#endif // WRITE_ALL_PARAMETERS
}

WriteParameters::WriteParameters(
	int backup_interval)
{
	ASSERT(this != 0);
	ASSERT(backup_interval >= 0);
	this->backup_interval = backup_interval;

	static EntrySpec registry_entries[registry_entry_count] =
	{
		{_T("hash match ratio"),					entry_double,	_T("0.01"),		&hash_match_ratio},
		{_T("compare match ratio"),					entry_double,	_T("1.0"),		&compare_match_ratio},
		{_T("dequeue hash ratio"),					entry_double,	_T("1.0"),		&dequeue_hash_ratio}
	};

	for (int index = 0; index < registry_entry_count; index++)
	{
		this->registry_entries[index] = registry_entries[index];
	}

	Registry::read(HKEY_LOCAL_MACHINE, registry_parameter_path,
		registry_entry_count, registry_entries);

	if (backup_interval > 0)
	{
		backup((void *)this);
	}
}

WriteParameters::~WriteParameters()
{
	ASSERT(this != 0);
	ASSERT(backup_interval >= 0);
	backup((void *)this);
}

void
WriteParameters::backup(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	WriteParameters *me = (WriteParameters *)context;
	ASSERT(me->backup_interval >= 0);

	bool registry_overwrite_ok =
		Registry::overwrite(HKEY_LOCAL_MACHINE, registry_parameter_path,
		registry_entry_count, me->registry_entries);
	if (!registry_overwrite_ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Registry::overwrite() to %s failed\n"),
			registry_parameter_path));
	}

	event_timer.schedule(invokation_time + me->backup_interval,
		context, backup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\meancomp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    meancomp.h

Abstract:

	SIS Groveler mean comparitor headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_MEANCOMP

#define _INC_MEANCOMP

class MeanComparator
{
public:

	MeanComparator(
		int num_clans,
		int sample_group_size,
		double acceptance_p_value,
		double rejection_p_value,
		double tolerance);

	~MeanComparator();

	void reset();

	void sample(
		int clan,
		double value);

	bool within(
		double compare_value,
		...);

	bool exceeds(
		double compare_value,
		...);

private:

	struct PTableDescriptor
	{
		double p_value;
		int table_size;
		int *p_table;
		PTableDescriptor *next;
		PTableDescriptor *prev;
		int ref_count;
	};

	struct Sample
	{
		int clan;
		double value;
	};

	static PTableDescriptor *add_p_value(
		double p_value,
		int sample_table_size);

	static bool remove_p_value(
		PTableDescriptor *ptd);

	static const int max_sample_table_size;

	static PTableDescriptor p_list;

	int num_clans;
	int sample_group_size;
	int sample_table_size;
	PTableDescriptor *acceptance_table;
	PTableDescriptor *rejection_table;

	double tolerance;
	Sample *samples;
	double *compare_values;
	int current_offset;
	int current_group_size;
};

#endif	/* _INC_MEANCOMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\params.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    params.h

Abstract:

	SIS Groveler registry parameters headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PARAMS

#define _INC_PARAMS

struct ReadParameters
{
	ReadParameters();

	int parameter_backup_interval;
	int target_entries_per_extraction;
	int max_extraction_interval;
	int base_grovel_interval;
	int max_grovel_interval;
	int max_response_lag;
	int low_confidence_grovel_interval;
	int low_disk_space_grovel_interval;
	int working_grovel_interval;
	int grovel_duration;
	int partition_info_update_interval;
	int base_restart_extraction_interval;
	int max_restart_extraction_interval;
	int base_restart_groveling_interval;
	int max_restart_groveling_interval;
	int base_regrovel_interval;
	int max_regrovel_interval;
	int volscan_regrovel_threshold;
	int partition_balance_time_constant;
	int read_time_increase_history_size;
	int read_time_decrease_history_size;
	int sis_efficacy_history_size;
	int log_winnow_history_size;
	int file_size_history_size;
	int sample_group_size;
	double acceptance_p_value;
	double rejection_p_value;
	double base_use_multiplier;
	double max_use_multiplier;
	double peak_finder_accuracy;
	double peak_finder_range;
	double base_cpu_load_threshold;
	double max_cpu_load_threshold;
	double read_report_discard_threshold;

private:

	enum {registry_entry_count = 34};
};

struct WriteParameters
{
	WriteParameters(
		int backup_interval);

	~WriteParameters();

	double hash_match_ratio;
	double compare_match_ratio;
	double dequeue_hash_ratio;

private:

	enum {registry_entry_count = 3};

	static void backup(
		void *context);

	int backup_interval;
	EntrySpec registry_entries[registry_entry_count];
};

#endif	/* _INC_PARAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\meancomp.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    meancomp.cpp

Abstract:

	SIS Groveler mean comparitor

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

const int MeanComparator::max_sample_table_size = 20;

MeanComparator::PTableDescriptor
	MeanComparator::p_list = {-1.0, 0, 0, &p_list, &p_list, 0};

MeanComparator::MeanComparator(
	int num_clans,
	int sample_group_size,
	double acceptance_p_value,
	double rejection_p_value,
	double tolerance)
{
	ASSERT(this != 0);
	ASSERT(num_clans > 0);
	ASSERT(sample_group_size > 0);
	ASSERT(acceptance_p_value >= 0.0);
	ASSERT(acceptance_p_value <= 1.0);
	ASSERT(rejection_p_value >= 0.0);
	ASSERT(rejection_p_value <= 1.0);
	ASSERT(tolerance >= 0.0);
	ASSERT(tolerance <= 1.0);
	this->num_clans = num_clans;
	this->sample_group_size = sample_group_size;
	this->tolerance = tolerance;
	sample_table_size = __min(sample_group_size, max_sample_table_size);
	acceptance_table = add_p_value(acceptance_p_value, sample_table_size);
	ASSERT(acceptance_table != 0);
	rejection_table = add_p_value(rejection_p_value, sample_table_size);
	ASSERT(rejection_table != 0);
	samples = new Sample[sample_group_size];
	compare_values = new double[num_clans];
	current_offset = 0;
	current_group_size = 0;
}

MeanComparator::~MeanComparator()
{
	ASSERT(this != 0);
	ASSERT(acceptance_table != 0);
	remove_p_value(acceptance_table);
	acceptance_table = 0;
	ASSERT(rejection_table != 0);
	remove_p_value(rejection_table);
	rejection_table = 0;
	ASSERT(samples != 0);
	delete[] samples;
	samples = 0;
	ASSERT(compare_values != 0);
	delete[] compare_values;
	compare_values = 0;
}

void
MeanComparator::reset()
{
	ASSERT(this != 0);
	ASSERT(current_group_size >= 0);
	ASSERT(current_group_size <= sample_group_size);
	current_group_size = 0;
}

void
MeanComparator::sample(
	int clan,
	double value)
{
	ASSERT(this != 0);
	ASSERT(current_group_size >= 0);
	ASSERT(current_group_size <= sample_group_size);
	ASSERT(current_offset >= 0);
	ASSERT(current_offset < sample_group_size);
	current_offset--;
	if (current_offset < 0)
	{
		current_offset += sample_group_size;
	}
	current_group_size = __min(current_group_size + 1, sample_group_size);
	ASSERT(current_offset >= 0);
	ASSERT(current_offset < sample_group_size);
	samples[current_offset].clan = clan;
	samples[current_offset].value = value;
}

bool
MeanComparator::within(
	double compare_value,
	...)
{
	ASSERT(this != 0);
	ASSERT(num_clans > 0);
	ASSERT(current_group_size >= 0);
	ASSERT(current_group_size <= sample_group_size);
	ASSERT(current_offset >= 0);
	ASSERT(current_offset < sample_group_size);
	va_list ap;
	va_start(ap, compare_value);
	compare_values[0] = compare_value;
	for (int index = 1; index < num_clans; index++)
	{
		compare_values[index] = va_arg(ap, double);
	}
	va_end(ap);
	int sample_count = 0;
	int below_count = 0;
	int *p_table = acceptance_table->p_table;
	ASSERT(p_table != 0);
	for (index = 0;
		index < current_group_size && sample_count < sample_table_size;
		index++)
	{
		int loc = (index + current_offset) % sample_group_size;
		int clan = samples[loc].clan;
		double value = samples[loc].value;
		double compare_value = compare_values[clan];
		if (fabs(value - compare_value) > tolerance * compare_value)
		{
			sample_count++;
			if (value < compare_value)
			{
				below_count++;
				if (below_count > p_table[sample_count-1])
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool
MeanComparator::exceeds(
	double compare_value,
	...)
{
	ASSERT(this != 0);
	ASSERT(num_clans > 0);
	ASSERT(current_group_size >= 0);
	ASSERT(current_group_size <= sample_group_size);
	ASSERT(current_offset >= 0);
	ASSERT(current_offset < sample_group_size);
	va_list ap;
	va_start(ap, compare_value);
	compare_values[0] = compare_value;
	for (int index = 1; index < num_clans; index++)
	{
		compare_values[index] = va_arg(ap, double);
	}
	va_end(ap);
	int sample_count = 0;
	int above_count = 0;
	int *p_table = rejection_table->p_table;
	ASSERT(p_table != 0);
	for (index = 0;
		index < current_group_size && sample_count < sample_table_size;
		index++)
	{
		int loc = (index + current_offset) % sample_group_size;
		int clan = samples[loc].clan;
		double value = samples[loc].value;
		double compare_value = compare_values[clan];
		if (fabs(value - compare_value) > tolerance * compare_value)
		{
			sample_count++;
			if (value > compare_value)
			{
				above_count++;
				if (above_count > p_table[sample_count-1])
				{
					return true;
				}
			}
		}
	}
	return false;
}

MeanComparator::PTableDescriptor *
MeanComparator::add_p_value(
	double p_value,
	int sample_table_size)
{
	ASSERT(p_list.next != 0);
	ASSERT(p_list.prev != 0);
	PTableDescriptor *ptd = p_list.next;
	while (ptd != &p_list && ptd->p_value < p_value)
	{
		ASSERT(ptd->next == &p_list || ptd->next->p_value > ptd->p_value);
		ptd = ptd->next;
	}
	ASSERT(ptd != 0);
	if (ptd->p_value == p_value)
	{
		ASSERT(ptd != &p_list);
		ASSERT(ptd->table_size > 0);
		ASSERT(ptd->table_size <= max_sample_table_size);
		if (ptd->table_size >= sample_table_size)
		{
			ptd->ref_count++;
			return ptd;
		}
		ASSERT(ptd->p_table != 0);
		delete[] ptd->p_table;
		ptd->p_table = 0;
	}
	else
	{
		PTableDescriptor *new_ptd = new PTableDescriptor;
		new_ptd->p_value = p_value;
		new_ptd->p_table = 0;
		new_ptd->next = ptd;
		new_ptd->prev = ptd->prev;
		ptd->prev->next = new_ptd;
		ptd->prev = new_ptd;
		new_ptd->ref_count = 0;
		ptd = new_ptd;
	}
	ASSERT(ptd->prev == &p_list || ptd->prev->p_value < p_value);
	ASSERT(ptd->next == &p_list || ptd->next->p_value > p_value);
	int *p_table = new int[sample_table_size];
	ptd->table_size = sample_table_size;
	double threshold = p_value;
	for (int n = 1; n <= sample_table_size; n++)
	{
		threshold *= 2.0;
		if (1.0 > threshold)
		{
			p_table[n - 1] = n;
			continue;
		}
		__int64 numerator = 1;
		__int64 denominator = 1;
		__int64 sum = 1;
		for (int r = 1; r <= n; r++)
		{
			numerator *= n - r + 1;
			ASSERT(numerator > 0);
			denominator *= r;
			ASSERT(denominator > 0);
			sum += numerator / denominator;
			ASSERT(sum > 0);
			if (double(sum) > threshold)
			{
				break;
			}
		}
		p_table[n - 1] = n - r;
	}
	ptd->p_table = p_table;
	ptd->ref_count++;
	return ptd;
}

bool
MeanComparator::remove_p_value(
	PTableDescriptor *ptd)
{
	ASSERT(ptd != 0);
	ptd->ref_count--;
	ASSERT(ptd->ref_count >= 0);
	if (ptd->ref_count == 0)
	{
		ASSERT(ptd->p_table != 0);
		delete[] ptd->p_table;
		ptd->p_table = 0;
		ptd->prev->next = ptd->next;
		ptd->next->prev = ptd->prev;
		delete ptd;
		ptd = 0;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\partctrl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    partctrl.cpp

Abstract:

	SIS Groveler partition controller

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

PartitionController::PartitionController(
	Groveler *groveler,
	GrovelStatus groveler_status,
	int target_entries_per_extraction,
	int max_extraction_interval,
	int base_grovel_interval,
	int max_grovel_interval,
	int low_confidence_grovel_interval,
	int low_disk_space_grovel_interval,
	int partition_info_update_interval,
	int base_restart_extraction_interval,
	int max_restart_extraction_interval,
	int base_restart_groveling_interval,
	int max_restart_groveling_interval,
	int base_regrovel_interval,
	int max_regrovel_interval,
	int volscan_regrovel_threshold,
	int partition_balance_time_constant,
	int read_time_increase_history_size,
	int read_time_decrease_history_size,
	int file_size_history_size,
	bool error_retry_log_extraction,
	bool error_retry_groveling,
	__int64 base_usn_log_size,
	__int64 max_usn_log_size,
	int sample_group_size,
	double acceptance_p_value,
	double rejection_p_value,
	double base_use_multiplier,
	double max_use_multiplier,
	double peak_finder_accuracy,
	double peak_finder_range,
	double base_cpu_load_threshold,
	double max_cpu_load_threshold,
	double *hash_match_ratio,
	double *compare_match_ratio,
	double *dequeue_hash_ratio,
	double *hash_read_time_estimate,
	double *compare_read_time_estimate,
	double *mean_file_size,
	double *read_time_confidence,
	int *volume_serial_number,
	int partition_index,
	double read_report_discard_threshold,
	int min_file_size,
	int min_file_age,
	bool allow_compressed_files,
	bool allow_encrypted_files,
	bool allow_hidden_files,
	bool allow_offline_files,
	bool allow_temporary_files,
	int num_excluded_paths,
	const _TCHAR **excluded_paths)
:	read_mean_comparator(2, sample_group_size,
		acceptance_p_value, rejection_p_value, peak_finder_accuracy),
	file_size_filter(file_size_history_size, *mean_file_size),
	read_time_confidence_estimator(2, *read_time_confidence),
	partition_grovel_accumulator(partition_balance_time_constant)
{
	ASSERT(this != 0);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 1,
		(_T("\tPC -\tconstructing PartitionController for drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	ASSERT(groveler != 0);
	this->groveler = groveler;
	ASSERT(target_entries_per_extraction > 0);
	this->target_entries_per_extraction = target_entries_per_extraction;
	ASSERT(max_extraction_interval > 0);
	this->max_extraction_interval = max_extraction_interval;
	ASSERT(base_grovel_interval > 0);
	this->base_grovel_interval = base_grovel_interval;
	ASSERT(max_grovel_interval > 0);
	ASSERT(max_grovel_interval >= base_grovel_interval);
	this->max_grovel_interval = max_grovel_interval;
	ASSERT(partition_info_update_interval > 0);
	this->partition_info_update_interval = partition_info_update_interval;
	ASSERT(base_restart_extraction_interval > 0);
	this->base_restart_extraction_interval = base_restart_extraction_interval;
	ASSERT(max_restart_extraction_interval > 0);
	ASSERT(max_restart_extraction_interval >= base_restart_extraction_interval);
	this->max_restart_extraction_interval = max_restart_extraction_interval;
	ASSERT(base_restart_groveling_interval > 0);
	this->base_restart_groveling_interval = base_restart_groveling_interval;
	ASSERT(max_restart_groveling_interval > 0);
	ASSERT(max_restart_groveling_interval >= base_restart_groveling_interval);
	this->max_restart_groveling_interval = max_restart_groveling_interval;
	this->error_retry_log_extraction = error_retry_log_extraction;
	this->error_retry_groveling = error_retry_groveling;
	ASSERT(base_usn_log_size > 0);
	this->base_usn_log_size = base_usn_log_size;
	ASSERT(max_usn_log_size > 0);
	ASSERT(max_usn_log_size >= base_usn_log_size);
	this->max_usn_log_size = max_usn_log_size;
	ASSERT(hash_match_ratio != 0);
	ASSERT(*hash_match_ratio >= 0.0);
	ASSERT(*hash_match_ratio <= 1.0);
	this->hash_match_ratio = hash_match_ratio;
	ASSERT(compare_match_ratio != 0);
	ASSERT(*compare_match_ratio >= 0.0);
	ASSERT(*compare_match_ratio <= 1.0);
	this->compare_match_ratio = compare_match_ratio;
	ASSERT(dequeue_hash_ratio != 0);
	ASSERT(*dequeue_hash_ratio >= 0.0);
	ASSERT(*dequeue_hash_ratio <= 1.0);
	this->dequeue_hash_ratio = dequeue_hash_ratio;
	ASSERT(mean_file_size != 0);
	ASSERT(*mean_file_size >= 0.0);
	this->mean_file_size = mean_file_size;
	ASSERT(read_time_confidence != 0);
	ASSERT(*read_time_confidence >= 0.0);
	ASSERT(*read_time_confidence <= 1.0);
	this->read_time_confidence = read_time_confidence;
	ASSERT(base_use_multiplier > 0.0);
	this->base_use_multiplier = base_use_multiplier;
	ASSERT(partition_index >= 0);
	this->partition_index = partition_index;
	ASSERT(base_regrovel_interval > 0);
	this->base_regrovel_interval = base_regrovel_interval;
	ASSERT(max_regrovel_interval >= base_regrovel_interval);
	this->max_regrovel_interval = max_regrovel_interval;
	ASSERT(volscan_regrovel_threshold >= base_regrovel_interval);
	ASSERT(volscan_regrovel_threshold <= max_regrovel_interval);
	this->volscan_regrovel_threshold = volscan_regrovel_threshold;
	ASSERT(read_report_discard_threshold >= 0.0);
	ASSERT(read_report_discard_threshold <= 1.0);
	this->read_report_discard_threshold = read_report_discard_threshold;
	ASSERT(min_file_size >= 0);
	this->min_file_size = min_file_size;
	ASSERT(min_file_age >= 0);
	this->min_file_age = min_file_age;
	this->allow_compressed_files = allow_compressed_files;
	this->allow_encrypted_files = allow_encrypted_files;
	this->allow_hidden_files = allow_hidden_files;
	this->allow_offline_files = allow_offline_files;
	this->allow_temporary_files = allow_temporary_files;
	ASSERT(num_excluded_paths >= 0);
	this->num_excluded_paths = num_excluded_paths;
	ASSERT(excluded_paths != 0);
	this->excluded_paths = excluded_paths;
	ASSERT(peak_finder_accuracy > 0.0);
	ASSERT(peak_finder_accuracy <= 1.0);
	this->peak_finder_accuracy = peak_finder_accuracy;
	ASSERT(peak_finder_range >= 1.0);
	read_peak_finder[RT_hash] =
		new PeakFinder(peak_finder_accuracy, peak_finder_range);
	read_peak_finder[RT_compare] =
		new PeakFinder(peak_finder_accuracy, peak_finder_range);
	ASSERT(base_cpu_load_threshold >= 0.0);
	this->base_cpu_load_threshold = base_cpu_load_threshold;
	ASSERT(read_time_increase_history_size > 0);
	ASSERT(read_time_decrease_history_size > 0);
	ASSERT(hash_read_time_estimate != 0);
	ASSERT(*hash_read_time_estimate >= 0.0);
	read_time_filter[RT_hash] =
		new DirectedIncidentFilter(read_time_increase_history_size,
		read_time_decrease_history_size, *hash_read_time_estimate);
	ASSERT(compare_read_time_estimate != 0);
	ASSERT(*compare_read_time_estimate >= 0.0);
	read_time_filter[RT_compare] =
		new DirectedIncidentFilter(read_time_increase_history_size,
		read_time_decrease_history_size, *compare_read_time_estimate);
	read_time_estimate[RT_hash] = hash_read_time_estimate;
	read_time_estimate[RT_compare] = compare_read_time_estimate;
	log_max_grovel_interval = log(double(max_grovel_interval));
	ASSERT(low_confidence_grovel_interval > 0);
	log_low_confidence_slope =
		log_max_grovel_interval - log(double(low_confidence_grovel_interval));
	if (log_low_confidence_slope < 0.0)
	{
		log_low_confidence_slope = 0.0;
	}
	ASSERT(low_disk_space_grovel_interval > 0);
	low_disk_space_slope = max_grovel_interval - low_disk_space_grovel_interval;
	if (low_disk_space_slope < 0.0)
	{
		low_disk_space_slope = 0.0;
	}
	ASSERT(max_use_multiplier >= base_use_multiplier);
	use_multiplier_slope = max_use_multiplier - base_use_multiplier;
	ASSERT(max_cpu_load_threshold <= 1.0);
	ASSERT(max_cpu_load_threshold >= base_cpu_load_threshold);
	cpu_load_threshold_slope = max_cpu_load_threshold - base_cpu_load_threshold;
	ASSERT(volume_serial_number != 0);
	this->volume_serial_number = volume_serial_number;
	update_partition_info((void *)this);
	ASSERT(volume_total_bytes > 0.0);
	ASSERT(volume_free_bytes >= 0.0);
	current_usn_log_size = base_usn_log_size;
	restart_groveling_interval = base_restart_groveling_interval;
	remaining_grovel_interval = 0;
	restart_volume_scan = false;
	extended_restart_in_progress = false;
	initialize_groveling(groveler_status);
	log_extractor_dead = true;
	restart_extraction_interval = base_restart_extraction_interval;
	remaining_restart_extraction_interval = 0;
	restart_extraction((void *)this);
}

PartitionController::~PartitionController()
{
	ASSERT(read_peak_finder[RT_hash] != 0);
	delete read_peak_finder[RT_hash];
	read_peak_finder[RT_hash] = 0;
	ASSERT(read_peak_finder[RT_compare] != 0);
	delete read_peak_finder[RT_compare];
	read_peak_finder[RT_hash] = 0;
	ASSERT(read_time_filter[RT_hash] != 0);
	delete read_time_filter[RT_hash];
	read_time_filter[RT_hash] = 0;
	ASSERT(read_time_filter[RT_compare] != 0);
	delete read_time_filter[RT_compare];
	read_time_filter[RT_compare] = 0;
}

bool
PartitionController::control_operation(
	DWORD grovel_duration,
	DWORD *count_of_files_hashed,
	DWORDLONG *bytes_of_files_hashed,
	DWORD *count_of_files_matching,
	DWORDLONG *bytes_of_files_matching,
	DWORD *count_of_files_compared,
	DWORDLONG *bytes_of_files_compared,
	DWORD *count_of_files_merged,
	DWORDLONG *bytes_of_files_merged,
	DWORD *count_of_files_enqueued,
	DWORD *count_of_files_dequeued,
	double cpu_load)
{
	ASSERT(this != 0);
	ASSERT(grovel_duration > 0);
	ASSERT(count_of_files_hashed != 0);
	ASSERT(bytes_of_files_hashed != 0);
	ASSERT(count_of_files_matching != 0);
	ASSERT(bytes_of_files_matching != 0);
	ASSERT(count_of_files_compared != 0);
	ASSERT(bytes_of_files_compared != 0);
	ASSERT(count_of_files_merged != 0);
	ASSERT(bytes_of_files_merged != 0);
	ASSERT(count_of_files_enqueued != 0);
	ASSERT(count_of_files_dequeued != 0);
	ASSERT(cpu_load >= 0.0);
	ASSERT(cpu_load <= 1.0);
	ASSERT(!groveler_dead);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCco -\toperating on drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	int files_to_compare = groveler->count_of_files_to_compare();
   	ASSERT(files_to_compare >= 0);
	int files_in_queue = groveler->count_of_files_in_queue();
   	ASSERT(files_in_queue >= 0);
	int ready_time = groveler->time_to_first_file_ready();
	ASSERT(files_in_queue == 0 || ready_time >= 0);
	bool more_work_to_do = files_to_compare > 0 ||
		files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
	if (log_extractor_dead && !performing_full_volume_scan && !more_work_to_do)
	{
		initiate_full_volume_scan = true;
	}
	partition_grovel_accumulator.increment();
	ASSERT(groveler != 0);
	bool ok;
	if (initiate_full_volume_scan ||
		performing_full_volume_scan && !more_work_to_do)
	{
		if (initiate_full_volume_scan)
		{
			TRACE_PRINTF(TC_partctrl, 1,
				(_T("\tPCco -\tinitiating full volume scan\n")));
			initiate_full_volume_scan = false;
			performing_full_volume_scan = true;
			restart_volume_scan = true;
		}
		TRACE_PRINTF(TC_partctrl, 4,
			(_T("\tPCco -\tperforming full volume scan\n")));
		ok = control_volume_scan(grovel_duration, count_of_files_enqueued);
		*count_of_files_hashed = 0;
		*bytes_of_files_hashed = 0;
		*count_of_files_matching = 0;
		*bytes_of_files_matching = 0;
		*count_of_files_compared = 0;
		*bytes_of_files_compared = 0;
		*count_of_files_merged = 0;
		*bytes_of_files_merged = 0;
		*count_of_files_dequeued = 0;
	}
	else
	{
		TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCco -\tgroveling\n")));
		ok = control_groveling(grovel_duration,
			count_of_files_hashed, bytes_of_files_hashed,
			count_of_files_matching, bytes_of_files_matching,
			count_of_files_compared, bytes_of_files_compared,
			count_of_files_merged, bytes_of_files_merged,
			count_of_files_enqueued, count_of_files_dequeued,
			cpu_load);
	}
	if (groveler_dead)
	{
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCco -\tconcluding foreground batch for drive %s\n"),
			sis_drives.partition_mount_name(partition_index)));
		SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, false);
	}
	else
	{
		files_to_compare = groveler->count_of_files_to_compare();
   		ASSERT(files_to_compare >= 0);
		files_in_queue = groveler->count_of_files_in_queue();
   		ASSERT(files_in_queue >= 0);
		ready_time = groveler->time_to_first_file_ready();
		ASSERT(files_in_queue == 0 || ready_time >= 0);
		more_work_to_do = files_to_compare > 0 ||
			files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
		if (!performing_full_volume_scan && !more_work_to_do)
		{
			TRACE_PRINTF(TC_partctrl, 1,
				(_T("\tPCco -\tconcluding foreground batch for drive %s\n"),
				sis_drives.partition_mount_name(partition_index)));
			SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, false);
		}
	}
	return ok;
}

void
PartitionController::advance(
	int time_delta)
{
	ASSERT(this != 0);
	ASSERT(time_delta >= 0);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCa -\tadvancing time for drive %s by %d\n"),
		sis_drives.partition_mount_name(partition_index), time_delta));
	if (groveler_dead)
	{
		return;
	}
	ASSERT(remaining_grovel_interval >= 0);
	remaining_grovel_interval -= time_delta;
	if (remaining_grovel_interval < 0)
	{
		remaining_grovel_interval = 0;
	}
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCa -\tremaining grovel interval = %d\n"),
		remaining_grovel_interval));
}

double
PartitionController::priority() const
{
	ASSERT(this != 0);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCp -\tcalculating priority on drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	if (groveler_dead)
	{
		return DBL_MAX;
	}
	double accumulated_groveling =
		partition_grovel_accumulator.retrieve_value();
	ASSERT(accumulated_groveling >= 0.0);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCp -\taccumulated groveling = %f\n"), accumulated_groveling));
	double calculated_priority =
		(1.0 + accumulated_groveling) * (1.0 + volume_free_bytes);
	ASSERT(calculated_priority > 1.0);
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCp -\tcalculated priority = %f\n"), calculated_priority));
	return calculated_priority;
}

int
PartitionController::wait() const
{
	ASSERT(this != 0);
	ASSERT(groveler != 0);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 4, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCw -\tcalculating wait time for drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	int time_until_groveler_ready = max_grovel_interval;
	if (!groveler_dead)
	{
		int files_to_compare = groveler->count_of_files_to_compare();
   		ASSERT(files_to_compare >= 0);
		int files_in_queue = groveler->count_of_files_in_queue();
   		ASSERT(files_in_queue >= 0);
		int ready_time = groveler->time_to_first_file_ready();
		ASSERT(files_in_queue == 0 || ready_time >= 0);
		bool more_work_to_do = files_to_compare > 0 ||
			files_in_queue > 0 && ready_time < volscan_regrovel_threshold;
		if (files_to_compare > 0 ||
			initiate_full_volume_scan && !more_work_to_do ||
			performing_full_volume_scan && !more_work_to_do ||
			log_extractor_dead && !more_work_to_do)
		{
			time_until_groveler_ready = 0;
			TRACE_PRINTF(TC_partctrl, 5, (_T("\tPCw -\tgroveler ready now\n")));
		}
		else if (files_in_queue > 0)
		{
			time_until_groveler_ready = ready_time;
   			ASSERT(time_until_groveler_ready >= 0);
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCw -\ttime until groveler ready = %d\n"),
				time_until_groveler_ready));
		}
	}
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCw -\tremaining grovel interval = %d\n"),
		remaining_grovel_interval));
	int wait_time = __max(remaining_grovel_interval, time_until_groveler_ready);
	TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCw -\twait time = %d\n"), wait_time));
	return wait_time;
}

void
PartitionController::demarcate_foreground_batch()
{
	ASSERT(this != 0);
	unsigned int current_time = GET_TICK_COUNT();
	if (!groveler_dead)
	{
		TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCdfb -\tdemarcating foreground batch for drive %s\n"),
			sis_drives.partition_mount_name(partition_index)));
		SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(partition_index, true);
	}
}

void
PartitionController::command_full_volume_scan()
{
	ASSERT(this != 0);
	unsigned int current_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 1, (_T("time: %d\n"), current_time));
	TRACE_PRINTF(TC_partctrl, 1,
		(_T("\tPCcfvs -\tcommanding full volume scan for drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	initiate_full_volume_scan = true;
}

void
PartitionController::control_extraction(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
	PartitionController *me = (PartitionController *)context;
	TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCce -\textracting log on drive %s\n"),
		sis_drives.partition_mount_name(me->partition_index)));
	ASSERT(!me->log_extractor_dead);
	if (me->groveler_dead || me->restart_extraction_required)
	{
		TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCce -\trestarting extraction\n")));
		me->log_extractor_dead = true;
		me->restart_extraction_interval = me->base_restart_extraction_interval;
		me->remaining_restart_extraction_interval = 0;
		restart_extraction(context);
		return;
	}
	DWORD num_entries_extracted;
	DWORDLONG num_bytes_extracted;
	DWORDLONG num_bytes_skipped;
	DWORD num_files_enqueued;
	DWORD num_files_dequeued;
	GrovelStatus status =
		me->groveler->extract_log(&num_entries_extracted, &num_bytes_extracted,
		&num_bytes_skipped, &num_files_enqueued, &num_files_dequeued);
	unsigned int completion_time = GET_TICK_COUNT();
	if (status == Grovel_overrun)
	{
		ASSERT(signed(num_entries_extracted) >= 0);
		ASSERT(signed(num_bytes_extracted) >= 0);
		ASSERT(signed(num_bytes_skipped) >= 0);
		ASSERT(signed(num_files_enqueued) >= 0);
		ASSERT(signed(num_files_dequeued) >= 0);
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCce -\textract_log() returned Grovel_overrun\n")));
		me->initiate_full_volume_scan = true;
		eventlog.report_event(GROVMSG_USN_LOG_OVERRUN, 1,
			sis_drives.partition_mount_name(me->partition_index));
		if (!me->first_extraction)
		{
			__int64 usn_log_size = num_bytes_extracted + num_bytes_skipped;
			ASSERT(me->base_usn_log_size > 0);
			ASSERT(me->max_usn_log_size > 0);
			ASSERT(me->current_usn_log_size >= me->base_usn_log_size);
			ASSERT(me->current_usn_log_size <= me->max_usn_log_size);
			if (usn_log_size > me->current_usn_log_size &&
				me->current_usn_log_size < me->max_usn_log_size)
			{
				if (usn_log_size > me->max_usn_log_size)
				{
					usn_log_size = me->max_usn_log_size;
				}
				_TCHAR size_string[32];
				_stprintf(size_string, _T("%d"), usn_log_size);
				eventlog.report_event(GROVMSG_SET_USN_LOG_SIZE, 2,
					sis_drives.partition_mount_name(me->partition_index),
					size_string);
				TRACE_PRINTF(TC_partctrl, 2,
					(_T("\tPCce -\tincreasing USN log size from %d to %d\n"),
					me->current_usn_log_size, usn_log_size));
				me->current_usn_log_size = usn_log_size;
				GrovelStatus status = me->groveler->set_usn_log_size(usn_log_size);
				if (status == Grovel_error)
				{
					TRACE_PRINTF(TC_partctrl, 1,
						(_T("\tPCce -\tset_usn_log_size() returned error\n")));
					TRACE_PRINTF(TC_partctrl, 1,
						(_T("\t\tsuspending control_extraction()\n")));
					eventlog.report_event(GROVMSG_LOG_EXTRACTOR_DEAD, 1,
						sis_drives.partition_mount_name(me->partition_index));
					me->log_extractor_dead = true;
					me->restart_extraction_interval =
						me->base_restart_extraction_interval;
					me->remaining_restart_extraction_interval =
						me->restart_extraction_interval;
					event_timer.schedule(
						completion_time + me->max_extraction_interval,
						context, restart_extraction);
					return;
				}
			}
		}
	}
	else if (status != Grovel_ok)
	{
		ASSERT(status == Grovel_error);
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCce -\textract_log() returned error\n")));
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\t\tsuspending control_extraction()\n")));
		eventlog.report_event(GROVMSG_LOG_EXTRACTOR_DEAD, 1,
			sis_drives.partition_mount_name(me->partition_index));
		me->log_extractor_dead = true;
		me->restart_extraction_interval = me->base_restart_extraction_interval;
		me->remaining_restart_extraction_interval =
			me->restart_extraction_interval;
		event_timer.schedule(completion_time + me->max_extraction_interval,
			context, restart_extraction);
		return;
	}
	unsigned int extraction_time = completion_time - invokation_time;
	ASSERT(signed(extraction_time) >= 0);
	shared_data->increment_value(me->partition_index,
		SDF_extract_time, extraction_time);
	shared_data->increment_value(me->partition_index,
		SDF_working_time, extraction_time);
	int queue_length = me->groveler->count_of_files_in_queue();
   	ASSERT(queue_length >= 0);
	shared_data->set_value(me->partition_index, SDF_queue_length, queue_length);
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCce -\tnum entries extracted = %d\n"), num_entries_extracted));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCce -\tnum files enqueued = %d\n"), num_files_enqueued));
	ASSERT(signed(num_entries_extracted) >= 0);
	ASSERT(signed(num_bytes_extracted) >= 0);
	ASSERT(signed(num_bytes_skipped) >= 0);
	ASSERT(signed(num_files_enqueued) >= 0);
	ASSERT(signed(num_files_dequeued) >= 0);
	ASSERT(num_bytes_extracted >= num_entries_extracted);
	ASSERT(num_files_enqueued <= num_entries_extracted);
	ASSERT(status == Grovel_overrun || num_bytes_skipped == 0);
	me->first_extraction = false;
	if (num_entries_extracted < 1)
	{
		num_entries_extracted = 1;
	}
	ASSERT(me->extraction_interval > 0);
	ASSERT(me->target_entries_per_extraction > 0);
	int ideal_extraction_interval = me->extraction_interval *
		me->target_entries_per_extraction / num_entries_extracted + 1;
	ASSERT(ideal_extraction_interval > 0);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCce -\tideal extraction interval = %d\n"),
		ideal_extraction_interval));
	if (ideal_extraction_interval < me->extraction_interval)
	{
		me->extraction_interval = ideal_extraction_interval;
	}
	else
	{
		me->extraction_interval = int(sqrt(double(me->extraction_interval)
			* double(ideal_extraction_interval)));
		ASSERT(me->max_extraction_interval > 0);
		if (me->extraction_interval > me->max_extraction_interval)
		{
			me->extraction_interval = me->max_extraction_interval;
		}
	}
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCce -\textraction interval = %d\n"), me->extraction_interval));
	ASSERT(me->extraction_interval > 0);
	ASSERT(me->extraction_interval <= me->max_extraction_interval);
	event_timer.schedule(invokation_time + me->extraction_interval,
		context, control_extraction);
}

void
PartitionController::restart_extraction(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
	PartitionController *me = (PartitionController *)context;
	TRACE_PRINTF(TC_partctrl, 3,
		(_T("\tPCre -\tconsidering restart extraction on drive %s\n"),
		sis_drives.partition_mount_name(me->partition_index)));
	ASSERT(me->log_extractor_dead);
	me->remaining_restart_extraction_interval -=
		__min(me->remaining_restart_extraction_interval,
		me->max_extraction_interval);
	TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCre -\tremaining restart extraction interval = %d\n"),
		me->remaining_restart_extraction_interval));
	if (!me->groveler_dead && me->remaining_restart_extraction_interval == 0)
	{
		TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
		TRACE_PRINTF(TC_partctrl, 2,
			(_T("\tPCre -\tattempting restart extraction on drive %s\n"),
			sis_drives.partition_mount_name(me->partition_index)));
		eventlog.report_event(GROVMSG_USN_LOG_RETRY, 1,
			sis_drives.partition_mount_name(me->partition_index));
		GrovelStatus status =
			me->groveler->set_usn_log_size(me->current_usn_log_size);
		if (status == Grovel_ok || status == Grovel_new)
		{
			TRACE_PRINTF(TC_partctrl, 2,
				(_T("\tPCre -\tset_usn_log_size() returned success\n")));
			_TCHAR size_string[32];
			_stprintf(size_string, _T("%d"), me->current_usn_log_size);
			eventlog.report_event(GROVMSG_INIT_USN_LOG, 2,
				sis_drives.partition_mount_name(me->partition_index),
				size_string);
			me->restart_extraction_required = false;
			me->log_extractor_dead = false;
			me->first_extraction = true;
			control_extraction(context);
			return;
		}
		else
		{
			TRACE_PRINTF(TC_partctrl, 3,
				(_T("\tPCre -\tset_usn_log_size() returned error\n")));
			ASSERT(status == Grovel_error);
			me->remaining_restart_extraction_interval =
				me->restart_extraction_interval;
			TRACE_PRINTF(TC_partctrl, 4,
				(_T("\tPCre -\tremaining restart extraction interval = %d\n"),
				me->remaining_restart_extraction_interval));
			me->restart_extraction_interval *= 2;
			if (me->restart_extraction_interval >
				me->max_restart_extraction_interval)
			{
				me->restart_extraction_interval =
					me->max_restart_extraction_interval;
			}
			TRACE_PRINTF(TC_partctrl, 4,
				(_T("\tPCre -\tnext restart extraction interval = %d\n"),
				me->restart_extraction_interval));
		}
	}
	event_timer.schedule(invokation_time + me->max_extraction_interval,
		context, restart_extraction);
}

void
PartitionController::restart_groveling(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
	PartitionController *me = (PartitionController *)context;
	TRACE_PRINTF(TC_partctrl, 2,
		(_T("\tPCrg -\tattempting to restart groveler on drive %s\n"),
		sis_drives.partition_mount_name(me->partition_index)));
	ASSERT(me->groveler_dead);
	me->groveler->close();
	eventlog.report_event(GROVMSG_GROVELER_RETRY, 1,
		sis_drives.partition_mount_name(me->partition_index));
	GrovelStatus status = me->groveler->open(
		sis_drives.partition_guid_name(me->partition_index),
		sis_drives.partition_mount_name(me->partition_index),
		me->partition_index == log_drive->drive_index(),
		me->read_report_discard_threshold,
		me->min_file_size,
		me->min_file_age,
		me->allow_compressed_files,
		me->allow_encrypted_files,
		me->allow_hidden_files,
		me->allow_offline_files,
		me->allow_temporary_files,
		me->num_excluded_paths,
		me->excluded_paths,
		me->base_regrovel_interval,
		me->max_regrovel_interval);
	if (status == Grovel_ok)
	{
		TRACE_PRINTF(TC_partctrl, 2,
			(_T("\tPCrg -\topen() returned ok\n")));
		log_drive->partition_initialized(me->partition_index);
		eventlog.report_event(GROVMSG_GROVELER_STARTED, 1,
			sis_drives.partition_mount_name(me->partition_index));
	}
	else if (status == Grovel_new)
	{
		TRACE_PRINTF(TC_partctrl, 2,
			(_T("\tPCrg -\topen() returned new\n")));
	}
	else
	{
		ASSERT(status == Grovel_error);
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\tPCrg -\topen() returned error\n")));
	}
	me->restart_volume_scan = true;
	me->initialize_groveling(status);
}

void
PartitionController::update_partition_info(
	void *context)
{
	ASSERT(context != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
	PartitionController *me = (PartitionController *)context;
	TRACE_PRINTF(TC_partctrl, 3,
		(_T("\tPCupi -\tupdating partition info for drive %s\n"),
		sis_drives.partition_mount_name(me->partition_index)));
	ULARGE_INTEGER my_free_bytes;
	ULARGE_INTEGER total_bytes;
	ULARGE_INTEGER free_bytes;
	int ok = GetDiskFreeSpaceEx(
		sis_drives.partition_guid_name(me->partition_index),
		&my_free_bytes, &total_bytes, &free_bytes);
	if (ok)
	{
		me->volume_total_bytes = double(__int64(total_bytes.QuadPart));
		me->volume_free_bytes = double(__int64(free_bytes.QuadPart));
		ASSERT(me->volume_total_bytes > 0.0);
		ASSERT(me->volume_free_bytes >= 0.0);
		TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupi -\tvolume total bytes = %f\n"),
			me->volume_total_bytes));
		TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupi -\tvolume free bytes = %f\n"),
			me->volume_free_bytes));
	}
	else
	{
		TRACE_PRINTF(TC_partctrl, 3, (_T("\tPCupi -\tGetDiskFreeSpaceEx() returned error.\n")));
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: GetDiskFreeSpaceEx() failed with error %d\n"),
			err));
	}
	ASSERT(me->partition_info_update_interval > 0);
	event_timer.schedule(invokation_time + me->partition_info_update_interval,
		context, update_partition_info);
}

void
PartitionController::initialize_groveling(
	GrovelStatus groveler_status)
{
	ASSERT(this != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_partctrl, 3,
		(_T("\tPCig -\tinitializing groveling for drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	if (groveler_status == Grovel_ok || groveler_status == Grovel_new)
	{
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\tPCig -\tgroveler_status indicates success\n")));
		groveler_dead = false;
		DWORD serial_number;
		int ok = GetVolumeInformation(
			sis_drives.partition_guid_name(partition_index),
			0, 0, &serial_number, 0, 0, 0, 0);
		if (!ok)
		{
			DWORD err = GetLastError();
			TRACE_PRINTF(TC_partctrl, 3,
				(_T("\tPCig -\tGetVolumeInformation() returned error %d\n"),
				err));
			PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() failed with error %d\n"),
				err));
		}
		else
		{
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCig -\tGetVolumeInformation() returned ")
				_T("serial number %d\n"), serial_number));
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCig -\trecorded serial number is %d\n"),
				*volume_serial_number));
			if (volume_serial_number == 0)
			{
				TRACE_PRINTF(TC_partctrl, 3,
					(_T("\tPCig -\tGetVolumeInformation() returned ")
					_T("serial number 0\n")));
				PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() returned ")
					_T("volume serial number 0\n")));
			}
		}
		if (ok && int(serial_number) != *volume_serial_number)
		{
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCig -\tresetting read time filters\n")));
			read_time_filter[RT_hash]->reset();
			read_time_filter[RT_compare]->reset();
			read_time_confidence_estimator.reset();
			*read_time_estimate[RT_hash] =
				read_time_filter[RT_hash]->retrieve_value();
			ASSERT(*read_time_estimate[RT_hash] == 0.0);
			*read_time_estimate[RT_compare] =
				read_time_filter[RT_compare]->retrieve_value();
			ASSERT(*read_time_estimate[RT_compare] == 0.0);
			*read_time_confidence = read_time_confidence_estimator.confidence();
			ASSERT(*read_time_confidence == 0.0);
			*volume_serial_number = serial_number;
		}
		extraction_interval = max_extraction_interval;
		free_space_ratio = 0.0;
		calculate_effective_max_grovel_interval();
		ASSERT(effective_max_grovel_interval > 0);
		ASSERT(effective_max_grovel_interval <= max_grovel_interval);
		grovel_interval = base_grovel_interval;
		remaining_grovel_interval = grovel_interval;
		ok_to_record_measurement = true;
		next_untrusted_measurement_time = invokation_time;
		restart_extraction_required = true;
		if (groveler_status == Grovel_new)
		{
			TRACE_PRINTF(TC_partctrl, 4,
				(_T("\tPCig -\tinitiating full volume scan\n")));
			initiate_full_volume_scan = true;
			performing_full_volume_scan = false;
			extended_restart_in_progress = true;
		}
		else
		{
			TRACE_PRINTF(TC_partctrl, 4,
				(_T("\tPCig -\tcontinuing full volume scan\n")));
			initiate_full_volume_scan = false;
			performing_full_volume_scan = true;
			extended_restart_in_progress = false;
			restart_groveling_interval = base_restart_groveling_interval;
		}
		TRACE_PRINTF(TC_partctrl, 5,
			(_T("\tPCig -\trestart groveling interval = %d\n"),
			restart_groveling_interval));
	}
	else
	{
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\tPCig -\tgroveler_status indicates error or disable\n")));
		ASSERT(groveler_status == Grovel_error
			|| groveler_status == Grovel_disable);
		groveler_dead = true;
		if (groveler_status != Grovel_disable && error_retry_groveling)
		{
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCig -\tscheduling restart groveling\n")));
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCig -\trestart groveling interval = %d\n"),
				restart_groveling_interval));
			event_timer.schedule(invokation_time + restart_groveling_interval,
				(void *)this, restart_groveling);
		}
		restart_groveling_interval *= 2;
		if (restart_groveling_interval > max_restart_groveling_interval)
		{
			restart_groveling_interval = max_restart_groveling_interval;
		}
		TRACE_PRINTF(TC_partctrl, 5,
			(_T("\tPCig -\tnext restart groveling interval = %d\n"),
			restart_groveling_interval));
	}
}

bool
PartitionController::control_groveling(
	DWORD grovel_duration,
	DWORD *count_of_files_hashed,
	DWORDLONG *bytes_of_files_hashed,
	DWORD *count_of_files_matching,
	DWORDLONG *bytes_of_files_matching,
	DWORD *count_of_files_compared,
	DWORDLONG *bytes_of_files_compared,
	DWORD *count_of_files_merged,
	DWORDLONG *bytes_of_files_merged,
	DWORD *count_of_files_enqueued,
	DWORD *count_of_files_dequeued,
	double cpu_load)
{
	ASSERT(this != 0);
	ASSERT(grovel_duration > 0);
	ASSERT(count_of_files_hashed != 0);
	ASSERT(bytes_of_files_hashed != 0);
	ASSERT(count_of_files_matching != 0);
	ASSERT(bytes_of_files_matching != 0);
	ASSERT(count_of_files_compared != 0);
	ASSERT(bytes_of_files_compared != 0);
	ASSERT(count_of_files_merged != 0);
	ASSERT(bytes_of_files_merged != 0);
	ASSERT(count_of_files_enqueued != 0);
	ASSERT(count_of_files_dequeued != 0);
	ASSERT(cpu_load >= 0.0);
	ASSERT(cpu_load <= 1.0);
	ASSERT(!groveler_dead);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 2,
		(_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_partctrl, 2, (_T("\tPCcg -\tgroveling on drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	DWORD hash_read_ops;
	DWORD hash_read_time;
	DWORD compare_read_ops;
	DWORD compare_read_time;
	DWORD merge_time;
	GrovelStatus status = groveler->grovel(grovel_duration,
		&hash_read_ops, &hash_read_time,
		count_of_files_hashed, bytes_of_files_hashed,
		&compare_read_ops, &compare_read_time,
		count_of_files_compared, bytes_of_files_compared,
		count_of_files_matching, bytes_of_files_matching,
		&merge_time,
		count_of_files_merged, bytes_of_files_merged,
		count_of_files_enqueued, count_of_files_dequeued);
	unsigned int completion_time = GET_TICK_COUNT();
	if (status != Grovel_ok && status != Grovel_pending)
	{
		ASSERT(status == Grovel_error);
		*count_of_files_hashed = 0;
		*bytes_of_files_hashed = 0;
		*count_of_files_matching = 0;
		*bytes_of_files_matching = 0;
		*count_of_files_compared = 0;
		*bytes_of_files_compared = 0;
		*count_of_files_merged = 0;
		*bytes_of_files_merged = 0;
		*count_of_files_enqueued = 0;
		*count_of_files_dequeued = 0;
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCcg -\tgrovel() returned error -- groveler dead\n")));
		eventlog.report_event(GROVMSG_GROVELER_DEAD, 1,
			sis_drives.partition_mount_name(partition_index));
		groveler_dead = true;
		if (error_retry_groveling)
		{
			restart_groveling_interval = base_restart_groveling_interval;
			event_timer.schedule(invokation_time + restart_groveling_interval,
				(void *)this, restart_groveling);
			return true;
		}
		else
		{
			return false;
		}
	}
	ASSERT(hash_read_ops > 0 || hash_read_time == 0);
	ASSERT(compare_read_ops > 0 || compare_read_time == 0);
	ASSERT(*bytes_of_files_hashed >= *count_of_files_hashed);
	ASSERT(*bytes_of_files_matching >= *count_of_files_matching);
	ASSERT(*bytes_of_files_compared >= *count_of_files_compared);
	ASSERT(*bytes_of_files_merged >= *count_of_files_merged);
	ASSERT(*count_of_files_hashed >= *count_of_files_matching);
	ASSERT(*bytes_of_files_hashed >= *bytes_of_files_matching);
	ASSERT(*count_of_files_compared >= *count_of_files_merged);
	ASSERT(*bytes_of_files_compared >= *bytes_of_files_merged);
	ASSERT(*count_of_files_dequeued >= *count_of_files_hashed);
	unsigned int grovel_time = completion_time - invokation_time;
	ASSERT(signed(grovel_time) >= 0);
	shared_data->increment_value(partition_index,
		SDF_grovel_time, grovel_time);
	shared_data->increment_value(partition_index,
		SDF_working_time, grovel_time);
	shared_data->increment_value(partition_index,
		SDF_files_hashed, *count_of_files_hashed);
	shared_data->increment_value(partition_index,
		SDF_files_compared, *count_of_files_compared);
	shared_data->increment_value(partition_index,
		SDF_files_merged, *count_of_files_merged);
	int files_in_queue = groveler->count_of_files_in_queue();
   	ASSERT(files_in_queue >= 0);
	int files_to_compare = groveler->count_of_files_to_compare();
   	ASSERT(files_to_compare >= 0);
	shared_data->set_value(partition_index, SDF_queue_length, files_in_queue);
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcg -\thash read ops = %d\n"), hash_read_ops));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcg -\thash read time = %d\n"), hash_read_time));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcg -\tcompare read ops = %d\n"), compare_read_ops));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcg -\tcompare read time = %d\n"), compare_read_time));
	shared_data->increment_value(partition_index,
		SDF_hash_read_time, hash_read_time);
	shared_data->increment_value(partition_index,
		SDF_hash_read_ops, hash_read_ops);
	shared_data->increment_value(partition_index,
		SDF_compare_read_time, compare_read_time);
	shared_data->increment_value(partition_index,
		SDF_compare_read_ops, compare_read_ops);
	update_peak_finder(RT_hash, hash_read_time, hash_read_ops);
	update_peak_finder(RT_compare, compare_read_time, compare_read_ops);
	shared_data->set_value(partition_index,
		SDF_hash_read_estimate, __int64(*read_time_estimate[RT_hash]));
	shared_data->set_value(partition_index,
		SDF_compare_read_estimate, __int64(*read_time_estimate[RT_compare]));
	int count_of_files_groveled =
		*count_of_files_hashed + *count_of_files_compared;
	ASSERT(mean_file_size != 0);
	if (count_of_files_groveled > 0)
	{
		__int64 bytes_of_files_groveled =
			*bytes_of_files_hashed + *bytes_of_files_compared;
		double sample_mean_file_size =
			double(bytes_of_files_groveled) / double(count_of_files_groveled);
		ASSERT(sample_mean_file_size > 0.0);
		file_size_filter.update_value(sample_mean_file_size,
			count_of_files_groveled);
		*mean_file_size = file_size_filter.retrieve_value();
		ASSERT(*mean_file_size > 0.0);
	}
	ASSERT(dequeue_hash_ratio != 0);
	ASSERT(*dequeue_hash_ratio >= 0.0);
	ASSERT(*dequeue_hash_ratio <= 1.0);
	double files_to_hash = *dequeue_hash_ratio * double(files_in_queue);
	ASSERT(*mean_file_size >= 0.0);
	double bytes_to_hash = *mean_file_size * files_to_hash;
	double bytes_to_compare = *mean_file_size * double(files_to_compare);
	double expected_bytes_to_free = *compare_match_ratio *
		(bytes_to_compare + *hash_match_ratio * bytes_to_hash);
	double expected_free_bytes = volume_free_bytes + expected_bytes_to_free;
	free_space_ratio = 0;
	if (expected_free_bytes > 0)
	{
		free_space_ratio = expected_bytes_to_free / expected_free_bytes;
	}
	ASSERT(free_space_ratio >= 0.0);
	ASSERT(free_space_ratio <= 1.0);
	calculate_effective_max_grovel_interval();
	ASSERT(effective_max_grovel_interval > 0);
	ASSERT(effective_max_grovel_interval <= max_grovel_interval);
	double use_multiplier =
		base_use_multiplier + use_multiplier_slope * free_space_ratio;
	ASSERT(use_multiplier >= 0.0);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcg -\tuse multiplier = %f\n"), use_multiplier));
	double hash_comparison_time = use_multiplier * *read_time_estimate[RT_hash];
	ASSERT(hash_comparison_time >= 0.0);
	double compare_comparison_time =
		use_multiplier * *read_time_estimate[RT_compare];
	ASSERT(compare_comparison_time >= 0.0);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcg -\thash comparison time = %f\n"), hash_comparison_time));
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcg -\tcompare comparison time = %f\n"),
		compare_comparison_time));
	TRACE_PRINTF(TC_partctrl, 5, (_T("\tPCcg -\tcpu load = %f\n"), cpu_load));
	double cpu_load_threshold = base_cpu_load_threshold +
		cpu_load_threshold_slope * free_space_ratio;
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcg -\tcpu load threshold = %f\n"), cpu_load_threshold));
	ASSERT(cpu_load_threshold >= 0.0);
	ASSERT(cpu_load_threshold <= 1.0);
	if (cpu_load > cpu_load_threshold || read_mean_comparator.exceeds(
		hash_comparison_time, compare_comparison_time))
	{
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\tPCcg -\tread time exceeds acceptable bounds\n")));
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\t\tor CPU load exceeds threshold\n")));
		ASSERT(grovel_interval > 0);
		remaining_grovel_interval = grovel_interval;
		read_mean_comparator.reset();
		grovel_interval *= 2;
		ok_to_record_measurement = false;
	}
	else if (read_mean_comparator.within(hash_comparison_time,
		compare_comparison_time))
	{
		TRACE_PRINTF(TC_partctrl, 3,
			(_T("\tPCcg -\tread time within acceptable bounds\n")));
		ASSERT(base_grovel_interval > 0);
		grovel_interval = base_grovel_interval;
		ok_to_record_measurement = true;
	}
	if (grovel_interval > effective_max_grovel_interval)
	{
		ASSERT(effective_max_grovel_interval > 0);
		grovel_interval = effective_max_grovel_interval;
	}
	TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCcg -\tgrovel interval = %d\n"), grovel_interval));
	TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCcg -\tremaining grovel interval = %d\n"),
		remaining_grovel_interval));
	return true;
}

bool
PartitionController::control_volume_scan(
	int scan_duration,
	DWORD *count_of_files_enqueued)
{
	ASSERT(this != 0);
	ASSERT(scan_duration > 0);
	ASSERT(count_of_files_enqueued != 0);
	ASSERT(!groveler_dead);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 2, (_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_partctrl, 2,
		(_T("\tPCcvs -\tscanning volume on drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	DWORD time_consumed;
	DWORD findfirst_count;
	DWORD findnext_count;
	GrovelStatus status = groveler->scan_volume(scan_duration,
		restart_volume_scan, &time_consumed, &findfirst_count, &findnext_count,
		count_of_files_enqueued);
	unsigned int completion_time = GET_TICK_COUNT();
	if (status == Grovel_ok || status == Grovel_pending)
	{
		if (extended_restart_in_progress)
		{
			log_drive->partition_initialized(partition_index);
			eventlog.report_event(GROVMSG_GROVELER_STARTED, 1,
				sis_drives.partition_mount_name(partition_index));
			extended_restart_in_progress = false;
		}
		if (status == Grovel_ok)
		{
			TRACE_PRINTF(TC_partctrl, 1,
				(_T("\tPCcvs -\tcompleted volume scan\n")));
			performing_full_volume_scan = false;
		}
	}
	else
	{
		ASSERT(status == Grovel_error);
		*count_of_files_enqueued = 0;
		TRACE_PRINTF(TC_partctrl, 1,
			(_T("\tPCcvs -\tscan_volume() returned error -- groveler dead\n")));
		if (!extended_restart_in_progress)
		{
			eventlog.report_event(GROVMSG_GROVELER_DEAD, 1,
				sis_drives.partition_mount_name(partition_index));
		}
		groveler_dead = true;
		if (error_retry_groveling)
		{
			if (!extended_restart_in_progress)
			{
				restart_groveling_interval = base_restart_groveling_interval;
			}
			event_timer.schedule(invokation_time + restart_groveling_interval,
				(void *)this, restart_groveling);
			if (extended_restart_in_progress)
			{
				restart_groveling_interval *= 2;
				if (restart_groveling_interval > max_restart_groveling_interval)
				{
					restart_groveling_interval = max_restart_groveling_interval;
				}
				extended_restart_in_progress = false;
			}
			return true;
		}
		else
		{
			extended_restart_in_progress = false;
			return false;
		}
	}
   	ASSERT(signed(time_consumed) >= 0);
   	ASSERT(signed(findfirst_count) >= 0);
   	ASSERT(signed(findnext_count) >= 0);
   	ASSERT(signed(*count_of_files_enqueued) >= 0);
	unsigned int scan_time = completion_time - invokation_time;
	ASSERT(signed(scan_time) >= 0);
	shared_data->increment_value(partition_index, SDF_volscan_time, scan_time);
	shared_data->increment_value(partition_index, SDF_working_time, scan_time);
	shared_data->increment_value(partition_index,
		SDF_files_scanned, findfirst_count + findnext_count);
	int queue_length = groveler->count_of_files_in_queue();
   	ASSERT(queue_length >= 0);
	shared_data->set_value(partition_index, SDF_queue_length, queue_length);
	restart_volume_scan = false;
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcvs -\ttime consumed = %d\n"), time_consumed));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcvs -\tfindfirst count = %d\n"), findfirst_count));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcvs -\tfindnext count = %d\n"), findnext_count));
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcvs -\tcount of files enqueued = %d\n"),
		*count_of_files_enqueued));
	return true;
}

void
PartitionController::update_peak_finder(
	ReadType read_type,
	DWORD read_time,
	DWORD read_ops)
{
	ASSERT(this != 0);
	unsigned int invokation_time = GET_TICK_COUNT();
	TRACE_PRINTF(TC_partctrl, 3, (_T("time: %d\n"), invokation_time));
	TRACE_PRINTF(TC_partctrl, 3,
		(_T("\tPCupf -\tupdating peak finder for drive %s\n"),
		sis_drives.partition_mount_name(partition_index)));
	ASSERT(read_type == RT_hash || read_type == RT_compare);
	ASSERT(signed(read_time) >= 0);
	ASSERT(signed(read_ops) >= 0);
	if (read_ops > 0)
	{
		double time_per_read = double(read_time)/double(read_ops);
		ASSERT(time_per_read >= 0.0);
		TRACE_PRINTF(TC_partctrl, 4, (_T("\tPCupf -\ttime per %s read = %f\n"),
			(read_type == RT_hash ? _T("hash") : _T("compare")),
			time_per_read));
		read_mean_comparator.sample(read_type, time_per_read);
		ASSERT(read_peak_finder[read_type] != 0);
		ASSERT(read_time_filter[read_type] != 0);
		ASSERT(read_time_estimate[read_type] != 0);
		ASSERT(read_time_confidence != 0);
		if (ok_to_record_measurement ||
			signed(invokation_time - next_untrusted_measurement_time) >= 0)
		{
			TRACE_PRINTF(TC_partctrl, 2,
				(_T("\tPCupf -\trecording %s measurement for drive %s\n"),
				(read_type == RT_hash ? _T("hash") : _T("compare")),
				sis_drives.partition_mount_name(partition_index)));
			read_peak_finder[read_type]->sample(time_per_read, read_ops);
			ASSERT(untrusted_measurement_interval > 0);
			ok_to_record_measurement = true;
			next_untrusted_measurement_time =
				invokation_time + untrusted_measurement_interval;
			TRACE_PRINTF(TC_partctrl, 5,
				(_T("\tPCupf -\tnext untrusted measurement time = %d\n"),
				next_untrusted_measurement_time));
		}
		if (read_peak_finder[read_type]->found())
		{
			double peak = read_peak_finder[read_type]->median();
			TRACE_PRINTF(TC_partctrl, 1,
				(_T("\tPCupf -\t%s read peak found: %f\n"),
				(read_type == RT_hash ? _T("hash") : _T("compare")), peak));
			if (peak > 0.0)
			{
				read_time_filter[read_type]->update_value(peak);
			}
			else
			{
				PRINT_DEBUG_MSG((_T("GROVELER: update_peak_finder() peak finder returned peak of zero\n")));
			}
			read_peak_finder[read_type]->reset();
			*read_time_estimate[read_type] =
				read_time_filter[read_type]->retrieve_value();
			ASSERT(*read_time_estimate[read_type] > 0.0);
			TRACE_PRINTF(TC_partctrl, 2,
				(_T("\tPCupf -\t%s read time estimate = %f\n"),
				(read_type == RT_hash ? _T("hash") : _T("compare")),
				*read_time_estimate[read_type]));
			double sample_peak_ratio = *read_time_estimate[read_type] / peak;
			double sample_read_time_confidence =
				(sample_peak_ratio + peak_finder_accuracy - 1.0) /
				peak_finder_accuracy;
			TRACE_PRINTF(TC_partctrl, 4,
				(_T("\tPCupf -\tsample read time confidence = %f\n"),
				sample_read_time_confidence));
			read_time_confidence_estimator.update(read_type,
				sample_read_time_confidence);
			*read_time_confidence = read_time_confidence_estimator.confidence();
			ASSERT(*read_time_confidence >= 0.0);
			ASSERT(*read_time_confidence <= 1.0);
			TRACE_PRINTF(TC_partctrl, 2,
				(_T("\tPCupf -\tread time confidence = %f\n"),
				*read_time_confidence));
			calculate_effective_max_grovel_interval();
			ASSERT(effective_max_grovel_interval > 0);
			ASSERT(effective_max_grovel_interval <= max_grovel_interval);
		}
	}
}

void
PartitionController::calculate_effective_max_grovel_interval()
{
	ASSERT(this != 0);
	ASSERT(read_time_confidence != 0);
	ASSERT(*read_time_confidence >= 0.0);
	ASSERT(*read_time_confidence <= 1.0);
	TRACE_PRINTF(TC_partctrl, 4,
		(_T("\tPCcemgi -\tread time confidence = %f\n"),
		*read_time_confidence));
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcemgi -\tfree space ratio = %f\n"), free_space_ratio));
	double log_untrusted_measurement_interval = log_max_grovel_interval -
		(1.0 - *read_time_confidence) * log_low_confidence_slope;
	untrusted_measurement_interval =
		int(exp(log_untrusted_measurement_interval));
	ASSERT(untrusted_measurement_interval > 0);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcemgi -\tuntrusted measurement interval = %d\n"),
		untrusted_measurement_interval));
	int low_disk_space_interval = max_grovel_interval -
		int(free_space_ratio * low_disk_space_slope);
	ASSERT(low_disk_space_interval > 0);
	effective_max_grovel_interval =
		__min(untrusted_measurement_interval, low_disk_space_interval);
	ASSERT(effective_max_grovel_interval > 0);
	ASSERT(effective_max_grovel_interval <= max_grovel_interval);
	TRACE_PRINTF(TC_partctrl, 5,
		(_T("\tPCcemgi -\teffective max grovel interval = %d\n"),
		effective_max_grovel_interval));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\partctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    partctrl.h

Abstract:

	SIS Groveler partition controller headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PARTCTRL

#define _INC_PARTCTRL

class PartitionController
{
public:

	PartitionController(
		Groveler *groveler,
		GrovelStatus groveler_status,
		int target_entries_per_extraction,
		int max_extraction_interval,
		int base_grovel_interval,
		int max_grovel_interval,
		int low_confidence_grovel_interval,
		int low_disk_space_grovel_interval,
		int partition_info_update_interval,
		int base_restart_extraction_interval,
		int max_restart_extraction_interval,
		int base_restart_groveling_interval,
		int max_restart_groveling_interval,
		int base_regrovel_interval,
		int max_regrovel_interval,
		int volscan_regrovel_threshold,
		int partition_balance_time_constant,
		int read_time_increase_history_size,
		int read_time_decrease_history_size,
		int file_size_history_size,
		bool error_retry_log_extraction,
		bool error_retry_groveling,
		__int64 base_usn_log_size,
		__int64 max_usn_log_size,
		int sample_group_size,
		double acceptance_p_value,
		double rejection_p_value,
		double base_use_multiplier,
		double max_use_multiplier,
		double peak_finder_accuracy,
		double peak_finder_range,
		double base_cpu_load_threshold,
		double max_cpu_load_threshold,
		double *hash_match_ratio,
		double *compare_match_ratio,
		double *dequeue_hash_ratio,
		double *hash_read_time_estimate,
		double *compare_read_time_estimate,
		double *mean_file_size,
		double *read_time_confidence,
		int *volume_serial_number,
		int partition_index,
		double read_report_discard_threshold,
		int min_file_size,
		int min_file_age,
		bool allow_compressed_files,
		bool allow_encrypted_files,
		bool allow_hidden_files,
		bool allow_offline_files,
		bool allow_temporary_files,
		int num_excluded_paths,
		const _TCHAR **excluded_paths);

	~PartitionController();

	bool control_operation(
		DWORD grovel_duration,
		DWORD *count_of_files_hashed,
		DWORDLONG *bytes_of_files_hashed,
		DWORD *count_of_files_matching,
		DWORDLONG *bytes_of_files_matching,
		DWORD *count_of_files_compared,
		DWORDLONG *bytes_of_files_compared,
		DWORD *count_of_files_merged,
		DWORDLONG *bytes_of_files_merged,
		DWORD *count_of_files_enqueued,
		DWORD *count_of_files_dequeued,
		double cpu_load);

	void advance(
		int time_delta);

	double priority() const;

	int wait() const;

	void demarcate_foreground_batch();

	void command_full_volume_scan();

private:

	enum ReadType
	{
		RT_hash,
		RT_compare
	};

	static void control_extraction(
		void *context);

	static void restart_extraction(
		void *context);

	static void restart_groveling(
		void *context);

	static void update_partition_info(
		void *context);

	void initialize_groveling(
		GrovelStatus groveler_status);

	bool control_groveling(
		DWORD grovel_duration,
		DWORD *count_of_files_hashed,
		DWORDLONG *bytes_of_files_hashed,
		DWORD *count_of_files_matching,
		DWORDLONG *bytes_of_files_matching,
		DWORD *count_of_files_compared,
		DWORDLONG *bytes_of_files_compared,
		DWORD *count_of_files_merged,
		DWORDLONG *bytes_of_files_merged,
		DWORD *count_of_files_enqueued,
		DWORD *count_of_files_dequeued,
		double cpu_load);

	bool control_volume_scan(
		int scan_duration,
		DWORD *count_of_files_enqueued);

	void update_peak_finder(
		ReadType read_type,
		DWORD read_time,
		DWORD read_ops);

	void calculate_effective_max_grovel_interval();

	Groveler *groveler;
	int partition_index;

	IncidentFilter file_size_filter;
	ConfidenceEstimator read_time_confidence_estimator;
	DecayingAccumulator partition_grovel_accumulator;

	MeanComparator read_mean_comparator;
	PeakFinder *read_peak_finder[2];
	DirectedIncidentFilter *read_time_filter[2];
	double *read_time_estimate[2];

	bool initiate_full_volume_scan;
	bool performing_full_volume_scan;
	int target_entries_per_extraction;
	int max_extraction_interval;
	int extraction_interval;

	__int64 base_usn_log_size;
	__int64 max_usn_log_size;
	__int64 current_usn_log_size;

	int max_grovel_interval;
	int base_grovel_interval;
	int effective_max_grovel_interval;
	int grovel_interval;
	int remaining_grovel_interval;

	bool ok_to_record_measurement;
	int next_untrusted_measurement_time;
	int untrusted_measurement_interval;

	double log_max_grovel_interval;
	double log_low_confidence_slope;
	double low_disk_space_slope;

	double base_use_multiplier;
	double use_multiplier_slope;

	double base_cpu_load_threshold;
	double cpu_load_threshold_slope;

	bool error_retry_log_extraction;
	bool error_retry_groveling;
	bool restart_extraction_required;

	int base_restart_extraction_interval;
	int max_restart_extraction_interval;
	int base_restart_groveling_interval;
	int max_restart_groveling_interval;

	int restart_extraction_interval;
	int remaining_restart_extraction_interval;
	int restart_groveling_interval;

	double peak_finder_accuracy;

	int volscan_regrovel_threshold;
	int partition_info_update_interval;

	bool restart_volume_scan;
	bool first_extraction;
	bool log_extractor_dead;
	bool groveler_dead;
	bool extended_restart_in_progress;

	double volume_total_bytes;
	double volume_free_bytes;
	double *hash_match_ratio;
	double *compare_match_ratio;
	double *dequeue_hash_ratio;

	double *mean_file_size;
	double *read_time_confidence;
	double free_space_ratio;
	int *volume_serial_number;

	int base_regrovel_interval;
	int max_regrovel_interval;
	double read_report_discard_threshold;
	int min_file_size;
	int min_file_age;
	bool allow_compressed_files;
	bool allow_encrypted_files;
	bool allow_hidden_files;
	bool allow_offline_files;
	bool allow_temporary_files;
	int num_excluded_paths;
	const _TCHAR **excluded_paths;
};

#endif	/* _INC_PARTCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\pathlist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pathlist.h

Abstract:

	SIS Groveler path list headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PATHLIST

#define _INC_PATHLIST

struct PathList
{
	PathList();
	~PathList();

	int *num_paths;
	const _TCHAR ***paths;

private:

	int num_partitions;
	BYTE *buffer;
	_TCHAR **partition_buffers;
};

#endif	/* _INC_PATHLIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\pathlist.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pathlist.cpp

Abstract:

	SIS Groveler path list manager

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR *paths_ini_filename = _T("grovel.ini");
static const _TCHAR *paths_ini_section = _T("Excluded Paths");

static const _TCHAR *excluded_paths_path =
	_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Groveler\\Excluded Paths");

static const int default_excluded_path_count = 1;

static _TCHAR *default_path_tags[default_excluded_path_count] =
{
	_T("System Volume Information directory")
};

static _TCHAR *default_excluded_paths[default_excluded_path_count] =
{
	_T("\\System Volume Information")
};

PathList::PathList()
{
	ASSERT(this != 0);
	paths = 0;
	buffer = 0;
	num_partitions = sis_drives.partition_count();
	num_paths = new int[num_partitions];
	paths = new const _TCHAR **[num_partitions];
	partition_buffers = new _TCHAR *[num_partitions];
	for (int part_num = 0; part_num < num_partitions; part_num++)
	{
		num_paths[part_num] = 1;
		paths[part_num] = 0;
		partition_buffers[part_num] = 0;
	}
	int num_strings;
	_TCHAR **strings = 0;
	bool ok = Registry::read_string_set(HKEY_LOCAL_MACHINE,
		excluded_paths_path, &num_strings, &strings, &buffer);
	if (!ok)
	{
		Registry::write_string_set(HKEY_LOCAL_MACHINE, excluded_paths_path,
			default_excluded_path_count, default_excluded_paths,
			default_path_tags);
		num_strings = default_excluded_path_count;
		strings = default_excluded_paths;
		buffer = 0;
	}
	ASSERT(num_strings >= 0);
	ASSERT(strings != 0);

	_TCHAR *ini_file_partition_path = new _TCHAR[SIS_CSDIR_STRING_NCHARS
		+ _tcslen(paths_ini_filename) + MAX_PATH];
	int *num_partition_strings = new int[num_partitions];
	_TCHAR ***partition_strings = new _TCHAR **[num_partitions];
	for (part_num = 0; part_num < num_partitions; part_num++)
	{
		partition_strings[part_num] = 0;
		_tcscpy(ini_file_partition_path,
			sis_drives.partition_guid_name(part_num));
		int drive_name_length = _tcslen(ini_file_partition_path);
		_tcscpy(&ini_file_partition_path[drive_name_length - 1],
			SIS_CSDIR_STRING);
		_tcscat(ini_file_partition_path, paths_ini_filename);

		IniFile::read_string_set(ini_file_partition_path, paths_ini_section,
			&num_partition_strings[part_num], &partition_strings[part_num],
			&partition_buffers[part_num]);
		ASSERT(num_partition_strings[part_num] >= 0);
		ASSERT(num_partition_strings[part_num] == 0
			|| partition_strings[part_num] != 0);
	}
	delete[] ini_file_partition_path;
	ini_file_partition_path = 0;

	for (part_num = 0; part_num < num_partitions; part_num++)
	{
		paths[part_num] = new const _TCHAR *[num_strings
			+ num_partition_strings[part_num] + 1];
		paths[part_num][0] = SIS_CSDIR_STRING;
		for (int index = 0; index < num_strings; index++)
		{
			paths[part_num][num_paths[part_num]] = strings[index];
			num_paths[part_num]++;
		}
		int num_part_strings = num_partition_strings[part_num];
		_TCHAR **part_strings = partition_strings[part_num];
		for (index = 0; index < num_part_strings; index++)
		{
			paths[part_num][num_paths[part_num]] = part_strings[index];
			num_paths[part_num]++;
		}
		if (partition_strings[part_num] != 0)
		{
			delete[] partition_strings[part_num];
			partition_strings[part_num] = 0;
		}
	}
	ASSERT(num_partition_strings != 0);
	delete[] num_partition_strings;
	num_partition_strings = 0;
	ASSERT(partition_strings != 0);
	delete[] partition_strings;
	partition_strings = 0;

	if (buffer != 0)
	{
		ASSERT(strings != 0);
		ASSERT(strings != default_excluded_paths);
		delete[] strings;
		strings = 0;
	}
}

PathList::~PathList()
{
	ASSERT(this != 0);
	ASSERT(num_paths != 0);
	ASSERT(paths != 0);
	ASSERT(partition_buffers != 0);
	ASSERT(num_partitions > 0);
	for (int part_num = 0; part_num < num_partitions; part_num++)
	{
		ASSERT(paths[part_num] != 0);
		delete[] paths[part_num];
		paths[part_num] = 0;
		if (partition_buffers[part_num] != 0)
		{
			delete[] partition_buffers[part_num];
			partition_buffers[part_num] = 0;
		}
	}
	delete[] paths;
	paths = 0;
	delete[] partition_buffers;
	partition_buffers = 0;
	if (buffer != 0)
	{
		delete[] buffer;
		buffer = 0;
	}
	ASSERT(num_paths != 0);
	delete[] num_paths;
	num_paths = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\peakfind.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    peakfind.cpp

Abstract:

	SIS Groveler peak finder

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

PeakFinder::PeakFinder(
	double accuracy,
	double range)
{
	ASSERT(this != 0);
	ASSERT(accuracy > 0.0);
	ASSERT(accuracy < 1.0);
	ASSERT(range > 0.0);
	base = 1.0 + 2.0 * accuracy / (1.0 - accuracy);
	ASSERT(base >= 1.0);
	multiplier = 1.0 / log(base);
	num_bins = int(multiplier * log(range)) + 1;
	ASSERT(num_bins > 0);
	bins = new int[num_bins];
	target_sample_size = int(1.0 / (accuracy * accuracy));
	ASSERT(target_sample_size > 0);
	reset();
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
}

PeakFinder::~PeakFinder()
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
	delete[] bins;
	bins = 0;
}

void
PeakFinder::reset()
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	floor_exp = int(multiplier * log(DBL_MAX));
	floor_value = pow(base, floor_exp);
	ASSERT(floor_value >= 0.0);
	sample_size = 0;
	total_weight = 0;
}

void
PeakFinder::sample(
	double value,
	int weight)
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
	ASSERT(value >= 0);
	ASSERT(weight > 0);
	if (value <= 0.0)
	{
		return;
	}
	if (value < floor_value)
	{
		int new_exp = int(multiplier * log(value));
		double new_floor = pow(base, new_exp);
		int shift = __min(floor_exp - new_exp, num_bins);
		for (int index = num_bins - shift - 1; index >= 0; index--)
		{
			bins[index + shift] = bins[index];
		}
		for (index = 0; index < shift; index++)
		{
			bins[index] = 0;
		}
		floor_exp = new_exp;
		floor_value = new_floor;
	}
	int bin_index = __max(int(multiplier * log(value / floor_value)), 0);
	if (bin_index < num_bins)
	{
		bins[bin_index] += weight;
	}
	ASSERT(total_weight >= 0);
	total_weight += weight;
	sample_size++;
}

bool
PeakFinder::found() const
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
	return sample_size > target_sample_size;
}

double
PeakFinder::mode() const
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
	double bin_width = base - 1.0;
	int max_index = -1;
	double max_height = 0.0;
	for (int index = 0; index < num_bins; index++)
	{
		double height = double(bins[index]) / bin_width;
		if (height > max_height)
		{
			max_index = index;
			max_height = height;
		}
		bin_width *= base;
	}
	if (max_index < 0)
	{
		return 0.0;
	}
	else
	{
		return 2 * base / (base + 1.0) * floor_value * pow(base, max_index);
	}
}

double
PeakFinder::median() const
{
	ASSERT(this != 0);
	ASSERT(num_bins > 0);
	ASSERT(bins != 0);
	ASSERT(base >= 1.0);
	ASSERT(target_sample_size > 0);
	ASSERT(floor_value >= 0.0);
	ASSERT(sample_size >= 0);
	ASSERT(total_weight >= 0);
	double remaining_weight = 0.5 * double(total_weight);
	for (int index = 0; index < num_bins; index++)
	{
		double current_weight = double(bins[index]);
		if (current_weight > remaining_weight)
		{
			return (1.0 + remaining_weight * (base - 1.0) / current_weight)
				* floor_value * pow(base, index);
		}
		remaining_weight -= current_weight;
	}
	return 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\perfctrs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfctrs.h

Abstract:

	SIS Groveler performance counters header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PERFCTRS

#define _INC_PERFCTRS

#define WIN32_LEAN_AND_MEAN 1

const int num_languages = 1;

struct CounterText
{
	_TCHAR *counter_name;
	_TCHAR *counter_help;
};

struct ObjectInformation
{
	unsigned int detail_level;
	CounterText text[num_languages];
};

struct CounterInformation
{
	SharedDataField source;
	unsigned int counter_type;
	unsigned int detail_level;
	CounterText text[num_languages];
};

const int num_perf_counters = 15;

extern const _TCHAR *language_codes[num_languages];

extern ObjectInformation object_info;

extern CounterInformation counter_info[num_perf_counters];

#endif	/* _INC_PERFCTRS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\peakfind.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    peakfind.h

Abstract:

	SIS Groveler peak finder headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_PEAKFIND

#define _INC_PEAKFIND

class PeakFinder
{
public:

	PeakFinder(
		double accuracy,
		double range);

	~PeakFinder();

	void reset();

	void sample(
		double value,
		int weight);

	bool found() const;

	double mode() const;

	double median() const;

private:

	int num_bins;
	int *bins;
	double base;
	double multiplier;
	int floor_exp;
	double floor_value;
	int target_sample_size;
	int sample_size;
	int total_weight;
};

#endif	/* _INC_PEAKFIND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\perfctrs.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfctrs.cpp

Abstract:

	SIS Groveler performance counters

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

const _TCHAR *language_codes[num_languages] = {_T("009")};

extern ObjectInformation object_info =
{
	PERF_DETAIL_NOVICE,
	{
		{_T("Groveler"), _T("Single-Instance Store Groveler for one file system partition")}
	}
};

CounterInformation counter_info[num_perf_counters] =
{
	{
		SDF_grovel_time,
		PERF_100NSEC_TIMER,
		PERF_DETAIL_NOVICE,
		{
			{_T("% Time Groveling"), _T("Percentage of elapsed time spent groveling this partition")}
		}
	},
	{
		SDF_volscan_time,
		PERF_100NSEC_TIMER,
		PERF_DETAIL_NOVICE,
		{
			{_T("% Time Scanning Volume"), _T("Percentage of elapsed time spent scanning this partition volume")}
		}
	},
	{
		SDF_extract_time,
		PERF_100NSEC_TIMER,
		PERF_DETAIL_NOVICE,
		{
			{_T("% Time Extracting Log"), _T("Percentage of elapsed time spent extracting entries from the USN log of this partition")}
		}
	},
	{
		SDF_working_time,
		PERF_100NSEC_TIMER,
		PERF_DETAIL_NOVICE,
		{
			{_T("% Time Working"), _T("Percentage of elapsed time spent performing work on this partition (sum of % Time Groveling, % Time Scanning Volume, and % Time Extracting Log)")}
		}
	},
	{
		SDF_files_hashed,
		PERF_COUNTER_BULK_COUNT,
		PERF_DETAIL_NOVICE,
		{
			{_T("Files Hashed"), _T("Count of files on this partition whose hash values have been computed")}
		}
	},
	{
		SDF_files_compared,
		PERF_COUNTER_BULK_COUNT,
		PERF_DETAIL_NOVICE,
		{
			{_T("Files Compared"), _T("Count of files on this partition that have been compared against other files")}
		}
	},
	{
		SDF_files_merged,
		PERF_COUNTER_BULK_COUNT,
		PERF_DETAIL_NOVICE,
		{
			{_T("Files Merged"), _T("Count of files on this partition that have been merged with other files")}
		}
	},
	{
		SDF_files_scanned,
		PERF_COUNTER_BULK_COUNT,
		PERF_DETAIL_NOVICE,
		{
			{_T("Files Scanned"), _T("Count of files and directories on this partition that have been scanned")}
		}
	},
	{
		SDF_queue_length,
		PERF_COUNTER_LARGE_RAWCOUNT,
		PERF_DETAIL_NOVICE,
		{
			{_T("Queue Length"), _T("Count of files waiting in queue to be hashed")}
		}
	},
	{
		SDF_hash_read_time,
		PERF_AVERAGE_BULK,
		PERF_DETAIL_ADVANCED,
		{
			{_T("Measured Hash Read Time"), _T("Measured time to perform disk read for hash computation")}
		}
	},
	{
		SDF_hash_read_ops,
		PERF_AVERAGE_BASE,
		PERF_DETAIL_ADVANCED,
		{
			{_T(""), _T("")}
		}
	},
	{
		SDF_compare_read_time,
		PERF_AVERAGE_BULK,
		PERF_DETAIL_ADVANCED,
		{
			{_T("Measured Compare Read Time"), _T("Measured time to perform disk read for file comparison")}
		}
	},
	{
		SDF_compare_read_ops,
		PERF_AVERAGE_BASE,
		PERF_DETAIL_ADVANCED,
		{
			{_T(""), _T("")}
		}
	},
	{
		SDF_hash_read_estimate,
		PERF_COUNTER_LARGE_RAWCOUNT,
		PERF_DETAIL_ADVANCED,
		{
			{_T("Estimated Hash Read Time"), _T("Estimated time to perform disk read for hash computation")}
		}
	},
	{
		SDF_compare_read_estimate,
		PERF_COUNTER_LARGE_RAWCOUNT,
		PERF_DETAIL_ADVANCED,
		{
			{_T("Estimated Compare Read Time"), _T("Estimated time to perform disk read for file comparison")}
		}
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\servctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    servctrl.h

Abstract:

	SIS Groveler service control include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SERVCTRL

#define _INC_SERVCTRL

#define SERVICE_CONTROL_VOLSCAN			0x00000080
#define SERVICE_CONTROL_FOREGROUND		0x000000a0
#define SERVICE_CONTROL_BACKGROUND		0x000000c0
#define SERVICE_CONTROL_RESERVED		0x000000e0

#define SERVICE_CONTROL_COMMAND_MASK	0xffffffe0
#define SERVICE_CONTROL_PARTITION_MASK	0x0000001f

#define SERVICE_CONTROL_ALL_PARTITIONS	0x0000001f

#endif	/* _INC_SERVCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\registry.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

	SIS Groveler/registry interface

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

_TCHAR Registry::id_buffer[id_buffer_length];

bool
Registry::read(
	HKEY base_key,
	const _TCHAR *path,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	for (int index = 0; index < num_entries; index++)
	{
		load_string_into_value(entries[index].type,
			entries[index].default_value, entries[index].pointer);
	}
	HKEY path_key;
	long result = RegOpenKeyEx(base_key, path, 0, KEY_ALL_ACCESS, &path_key);
	if (result != ERROR_SUCCESS)
	{
		return false;
	}
	ASSERT(path_key != 0);
	for (index = 0; index < num_entries; index++)
	{
		DWORD data_type;
		DWORD data_length = id_buffer_length;
		result = RegQueryValueEx(path_key, entries[index].identifier, 0,
			&data_type, (BYTE *)id_buffer, &data_length);
		if (result == ERROR_SUCCESS && data_type == REG_SZ)
		{
			load_string_into_value(entries[index].type, id_buffer,
				entries[index].pointer);
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::write(
	HKEY base_key,
	const _TCHAR *path,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_entries; index++)
	{
		DWORD data_type;
		DWORD data_length = id_buffer_length;
		result = RegQueryValueEx(path_key, entries[index].identifier, 0,
			&data_type, (BYTE *)id_buffer, &data_length);
		if (result != ERROR_SUCCESS || data_type != REG_SZ)
		{
			store_value_in_string(entries[index].type, entries[index].pointer,
				id_buffer);
			result =
				RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
				(BYTE *)id_buffer, (_tcslen(id_buffer) + 1) * sizeof(_TCHAR));

			if (result != ERROR_SUCCESS)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
					result));
			}
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::overwrite(
	HKEY base_key,
	const _TCHAR *path,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_entries; index++)
	{
		store_value_in_string(entries[index].type, entries[index].pointer,
			id_buffer);
		result =
			RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
			(BYTE *)id_buffer, (_tcslen(id_buffer) + 1) * sizeof(_TCHAR));
		if (result != ERROR_SUCCESS)
		{
			PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
				result));
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::write_defaults(
	HKEY base_key,
	const _TCHAR *path,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_entries; index++)
	{
		DWORD data_type;
		DWORD data_length = id_buffer_length;
		result = RegQueryValueEx(path_key, entries[index].identifier, 0,
			&data_type, (BYTE *)id_buffer, &data_length);
		if (result != ERROR_SUCCESS)
		{
			result = RegSetValueEx(path_key, entries[index].identifier, 0,
				REG_SZ, (BYTE *)entries[index].default_value,
				(_tcslen(entries[index].default_value) + 1) * sizeof(_TCHAR));
			if (result != ERROR_SUCCESS)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
					result));
			}
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::overwrite_defaults(
	HKEY base_key,
	const _TCHAR *path,
	int num_entries,
	EntrySpec *entries)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_entries > 0);
	ASSERT(entries != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_entries; index++)
	{
		result = RegSetValueEx(path_key, entries[index].identifier, 0, REG_SZ,
			(BYTE *)entries[index].default_value,
			(_tcslen(entries[index].default_value) + 1) * sizeof(_TCHAR));
		if (result != ERROR_SUCCESS)
		{
			PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
				result));
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::read_string_set(
	HKEY base_key,
	const _TCHAR *path,
	int *num_strings,
	_TCHAR ***strings,
	BYTE **buffer)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_strings != 0);
	ASSERT(strings != 0);
	ASSERT(buffer != 0);
	HKEY path_key;
	*num_strings = 0;
	*strings = 0;
	*buffer = 0;
	long result = RegOpenKeyEx(base_key, path, 0, KEY_ALL_ACCESS, &path_key);
	if (result != ERROR_SUCCESS)
	{
		return false;
	}
	unsigned long num_values;
	unsigned long max_value_length;
	unsigned long max_string_length;
	result = RegQueryInfoKey(path_key, 0, 0, 0, 0, 0, 0,
		&num_values, &max_value_length, &max_string_length, 0, 0);
	if (result != ERROR_SUCCESS || num_values == 0)
	{
		return true;
	}
	_TCHAR *value = new _TCHAR[max_value_length + 1];
	_TCHAR **string_set = new _TCHAR *[num_values];
	BYTE *string_buffer =
		new BYTE[num_values * max_string_length * sizeof(_TCHAR)];
	int string_index = 0;
	int buffer_offset = 0;
	for (unsigned int index = 0; index < num_values; index++)
	{
		DWORD value_length = max_value_length + 1;
		DWORD string_length = max_string_length;
		DWORD data_type;
		result = RegEnumValue(path_key, index, value, &value_length, 0,
			&data_type, &string_buffer[buffer_offset], &string_length);
		if (result == ERROR_SUCCESS && data_type == REG_SZ)
		{
			ASSERT(unsigned(string_index) < num_values);
			string_set[string_index] = (_TCHAR *)&string_buffer[buffer_offset];
			string_index++;
			buffer_offset += string_length;
		}
	}
	*num_strings = string_index;
	ASSERT(value != 0);
	delete[] value;
	value = 0;
	*strings = string_set;
	*buffer = string_buffer;
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::write_string_set(
	HKEY base_key,
	const _TCHAR *path,
	int num_strings,
	_TCHAR **strings,
	_TCHAR **identifiers)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_strings > 0);
	ASSERT(strings != 0);
	ASSERT(identifiers != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_strings; index++)
	{
		DWORD data_type;
		DWORD data_length = id_buffer_length;
		result = RegQueryValueEx(path_key, identifiers[index], 0,
			&data_type, (BYTE *)id_buffer, &data_length);
		if (result != ERROR_SUCCESS || data_type != REG_SZ)
		{
			result = RegSetValueEx(
				path_key, identifiers[index], 0, REG_SZ, (BYTE *)strings[index],
				(_tcslen(strings[index]) + 1) * sizeof(_TCHAR));
			if (result != ERROR_SUCCESS)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
					result));
			}
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

bool
Registry::overwrite_string_set(
	HKEY base_key,
	const _TCHAR *path,
	int num_strings,
	_TCHAR **strings,
	_TCHAR **identifiers)
{
	ASSERT(base_key == HKEY_CLASSES_ROOT
		|| base_key == HKEY_CURRENT_CONFIG
		|| base_key == HKEY_CURRENT_USER
		|| base_key == HKEY_LOCAL_MACHINE
		|| base_key == HKEY_USERS);
	ASSERT(path != 0);
	ASSERT(num_strings > 0);
	ASSERT(strings != 0);
	ASSERT(identifiers != 0);
	HKEY path_key;
	DWORD disposition;
	long result = RegCreateKeyEx(base_key, path, 0, 0, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, 0, &path_key, &disposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		return false;
	}
	ASSERT(path_key != 0);
	for (int index = 0; index < num_strings; index++)
	{
		result = RegSetValueEx(
			path_key, identifiers[index], 0, REG_SZ, (BYTE *)strings[index],
			(_tcslen(strings[index]) + 1) * sizeof(_TCHAR));
		if (result != ERROR_SUCCESS)
		{
			PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"),
				result));
		}
	}
	ASSERT(path_key != 0);
	RegCloseKey(path_key);
	path_key = 0;
	return true;
}

void
Registry::create_key_ex(
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD Reserved,
	LPTSTR lpClass,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition)
{
	DWORD result = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions,
		samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCreateKeyEx() failed with error %d\n"),
			result));
		throw result;
	}
}

void
Registry::open_key_ex(
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult)
{
	DWORD result =
		RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
	if (result != ERROR_SUCCESS)
	{
		throw result;
	}
}

void
Registry::close_key(
	HKEY hKey)
{
	DWORD result = RegCloseKey(hKey);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegCloseKey() failed with error %d\n"), result));
		throw result;
	}
}

void
Registry::query_value_ex(
	HKEY hKey,
	LPCTSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData)
{
	DWORD result = RegQueryValueEx(hKey, lpValueName,
		lpReserved, lpType, lpData, lpcbData);
	if (result != ERROR_SUCCESS)
	{
		throw result;
	}
}

void
Registry::set_value_ex(
	HKEY hKey,
	LPCTSTR lpValueName,
	DWORD Reserved,
	DWORD dwType,
	CONST BYTE *lpData,
	DWORD cbData)
{
	DWORD result =
		RegSetValueEx(hKey, lpValueName, Reserved, dwType, lpData, cbData);
	if (result != ERROR_SUCCESS)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegSetValueEx() failed with error %d\n"), result));
		throw result;
	}
}

void
Registry::load_string_into_value(
	EntryType type,
	const _TCHAR *string,
	void *value)
{
	ASSERT(string != 0);
	ASSERT(value != 0);
	switch (type)
	{
	case entry_bool:
		*((bool *)value) = _ttoi(string) != 0;
		break;
	case entry_char:
		*((_TCHAR *)value) = string[0];
		break;
	case entry_int:
		_stscanf(string, _T("%d"), (int *)value);
		break;
	case entry_int64:
		_stscanf(string, _T("%I64d"), (__int64 *)value);
		break;
	case entry_double:
		_stscanf(string, _T("%lf"), (double *)value);
		break;
	default:
		ASSERT(false);
	}
}

void
Registry::store_value_in_string(
	EntryType type,
	void *value,
	_TCHAR *string)
{
	ASSERT(string != 0);
	ASSERT(value != 0);
	switch (type)
	{
	case entry_bool:
		_stprintf(string, *((bool *)value) ? _T("1") : _T("0"));
		break;
	case entry_char:
		_stprintf(string, _T("%c"), *((_TCHAR *)value));
		break;
	case entry_int:
		_stprintf(string, _T("%d"), *((int *)value));
		break;
	case entry_int64:
		_stprintf(string, _T("%I64d"), *((__int64 *)value));
		break;
	case entry_double:
		_stprintf(string, _T("%g"), *((double *)value));
		break;
	default:
		ASSERT(false);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\registry.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    registry.h

Abstract:

	SIS Groveler registry interface headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_REGISTRY

#define _INC_REGISTRY

#ifndef _DEF_ENTRY_INFO
#define _DEF_ENTRY_INFO

enum EntryType
{
	entry_bool,
	entry_char,
	entry_int,
	entry_int64,
	entry_double
};

struct EntrySpec
{
	const _TCHAR *identifier;
	EntryType type;
	const _TCHAR *default_value;
	void *pointer;
};

#endif	/* _DEF_ENTRY_INFO */

class Registry
{
public:

	static bool read(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool write(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool write_defaults(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool overwrite_defaults(
		HKEY base_key,
		const _TCHAR *path,
		int num_entries,
		EntrySpec *entries);

	static bool read_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int *num_strings,
		_TCHAR ***strings,
		BYTE **buffer);

	static bool write_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int num_strings,
		_TCHAR **strings,
		_TCHAR **identifiers);

	static bool overwrite_string_set(
		HKEY base_key,
		const _TCHAR *path,
		int num_strings,
		_TCHAR **strings,
		_TCHAR **identifiers);

	static void create_key_ex(
		HKEY hKey,
		LPCTSTR lpSubKey,
		DWORD Reserved,
		LPTSTR lpClass,
		DWORD dwOptions,
		REGSAM samDesired,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes,
		PHKEY phkResult,
		LPDWORD lpdwDisposition);

	static void open_key_ex(
		HKEY hKey,
		LPCTSTR lpSubKey,
		DWORD ulOptions,
		REGSAM samDesired,
		PHKEY phkResult);

	static void close_key(
		HKEY hKey);

	static void query_value_ex(
		HKEY hKey,
		LPCTSTR lpValueName,
		LPDWORD lpReserved,
		LPDWORD lpType,
		LPBYTE lpData,
		LPDWORD lpcbData);

	static void set_value_ex(
		HKEY hKey,
		LPCTSTR lpValueName,
		DWORD Reserved,
		DWORD dwType,
		CONST BYTE *lpData,
		DWORD cbData);

private:

	enum {id_buffer_length = 256};

	static void load_string_into_value(
		EntryType type,
		const _TCHAR *string,
		void *value);

	static void store_value_in_string(
		EntryType type,
		void *value,
		_TCHAR *string);

	Registry() {}
	~Registry() {}

	static _TCHAR id_buffer[id_buffer_length];
};

#endif	/* _INC_REGISTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\share.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    share.h

Abstract:

	SIS Groveler shared data class header

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SHARE

#define _INC_SHARE

#pragma pack (8)

enum SharedDataField
{
	SDF_grovel_time,
	SDF_volscan_time,
	SDF_extract_time,
	SDF_working_time,
	SDF_files_hashed,
	SDF_files_compared,
	SDF_files_merged,
	SDF_files_scanned,
	SDF_queue_length,
	SDF_hash_read_time,
	SDF_hash_read_ops,
	SDF_compare_read_time,
	SDF_compare_read_ops,
	SDF_hash_read_estimate,
	SDF_compare_read_estimate,

	num_shared_data_fields
};

struct SharedDataRecord
{
	_TCHAR *driveName;
	__int64 fields[num_shared_data_fields];
};

const int max_shared_data_records = 128;

#pragma pack ()

class SharedData
{
public:

	SharedData(
		int num_records = -1,
		_TCHAR **drive_names = 0);

	~SharedData();

	int count_of_records() const;

//	_TCHAR drive_letter(
//		int record_index) const;

	__int64 get_value(
		int record_index,
		SharedDataField field);

	void set_value(
		int record_index,
		SharedDataField field,
		__int64 value);

	void increment_value(
		int record_index,
		SharedDataField field,
		__int64 value);

	bool send_values();

	bool receive_values();

	bool extract_values(
		int *num_records,
		SharedDataRecord *records);

private:

	int local_num_records;
	int *shared_num_records;

	SharedDataRecord local_records[max_shared_data_records];
	SharedDataRecord *shared_records;

	NamedMutex *mutex;

	PSID security_identifier;
	PACL access_control_list;
	SECURITY_ATTRIBUTES security_attributes;
	SECURITY_DESCRIPTOR security_descriptor;

	bool map_ok;
	HANDLE map_handle;
	void *map_address;
};

#endif	/* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\share.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    share.cpp

Abstract:

	SIS Groveler shared data class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static const _TCHAR map_name[] = _T("Groveler Shared Memory");
static const _TCHAR mutex_name[] = _T("Groveler Shared Memory Mutex");
static const int mutex_timeout = 500;

#define ALIGN_INT64(x) \
	(((x+sizeof(__int64)-1)/sizeof(__int64))*sizeof(__int64))

SharedData::SharedData(
	int num_records,
	_TCHAR **drive_names)
{
	ASSERT(this != 0);
	ASSERT(num_records <= max_shared_data_records);
	map_ok = false;
	mutex = 0;
	map_handle = 0;
	map_address = 0;
	shared_num_records = 0;
	shared_records = 0;
	security_identifier = 0;
	access_control_list = 0;
	ZeroMemory(&security_attributes, sizeof(SECURITY_ATTRIBUTES));
	ZeroMemory(&security_descriptor, sizeof(SECURITY_DESCRIPTOR));

    //
    //  Initailize a Security descriptor so we can setup secure access
    //  to a shared file.
    //

	security_attributes.bInheritHandle = FALSE;
	security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	security_attributes.lpSecurityDescriptor = (void *)&security_descriptor;

	BOOL success = InitializeSecurityDescriptor(&security_descriptor,
		SECURITY_DESCRIPTOR_REVISION);
	if (!success)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((
			_T("GROVELER: InitializeSecurityDescriptor() failed with error %d\n"), err));
		return;
	}

	SID_IDENTIFIER_AUTHORITY sid_authority = SECURITY_NT_AUTHORITY;
	success = AllocateAndInitializeSid(
		&sid_authority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		&security_identifier);
	if (!success)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((
			_T("GROVELER: AllocateAndInitializeSid() failed with error %d\n"), err));
		return;
	}

    //
    //  Create ACL
    //

	DWORD acl_size = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE)
                                		+ GetLengthSid(security_identifier);
	access_control_list = (PACL)new BYTE[acl_size];

	success = InitializeAcl(
		access_control_list,
		acl_size,
		ACL_REVISION);
	if (!success)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: InitializeAcl() failed with error %d\n"), err));
		return;
	}

	success = AddAccessAllowedAce(
		access_control_list,
		ACL_REVISION,
		GENERIC_ALL,
		security_identifier);
	if (!success)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: AddAccessAllowedAce() failed with error %d\n"),
			err));
		return;
	}

	success = SetSecurityDescriptorDacl(
		&security_descriptor,
		TRUE,
		access_control_list,
		FALSE);
	if (!success)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetSecurityDescriptorDacl() failed with error %d\n"),
			err));
		return;
	}

    //
    //  Create a named mutex
    //

	mutex = new NamedMutex(mutex_name, &security_attributes);
	ASSERT(mutex != 0);

    //
    //  Calcualte size of mapped file
    //

	int map_size = ALIGN_INT64(sizeof(int))
        		+ ALIGN_INT64(max_shared_data_records * sizeof(SharedDataRecord));
	bool ok = mutex->acquire(mutex_timeout);
	if (!ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
		return;
	}

    //
    //  Create the mapped file.  Note that it will be backed by system paging
    //  files.
    //

	map_handle = CreateFileMapping((HANDLE)-1, &security_attributes,
		PAGE_READWRITE, 0, map_size, map_name);
	DWORD map_error = GetLastError();
	if (map_handle == 0)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: CreateFileMapping() failed with error %d\n"),
			map_error));
		return;
	}
	ASSERT(map_error == NO_ERROR || map_error == ERROR_ALREADY_EXISTS);

    //
    //  Map a view for this file
    //

	map_address =
		MapViewOfFile(map_handle, FILE_MAP_ALL_ACCESS, 0, 0, map_size);
	if (map_address == 0)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: MapViewOfFile() failed with error %d\n"), err));
		return;
	}

	shared_num_records = (int *)map_address;
	shared_records =
		(SharedDataRecord *)ALIGN_INT64((DWORD_PTR)(shared_num_records + 1));

	local_num_records = __max(num_records, 0);
	ZeroMemory(local_records, max_shared_data_records * sizeof(SharedDataRecord));

	ASSERT(local_num_records == 0 || drive_names != 0);

	for (int index = 0; index < local_num_records; index++)
	{
		local_records[index].driveName = drive_names[index];
	}

	map_ok = true;
	if (num_records >= 0 || map_error == NO_ERROR)
	{
		bool ok = send_values();
	}

	ok = mutex->release();
	if (!ok)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
	}
}

SharedData::~SharedData()
{
	ASSERT(this != 0);
	ASSERT(mutex != 0);
	delete mutex;
	mutex = 0;
	if (map_address != 0)
	{
		int ok = UnmapViewOfFile(map_address);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: UnmapViewOfFile() failed with error %d\n"),
				err));
		}
		map_address = 0;
	}
	if (map_handle != 0)
	{
		int ok = CloseHandle(map_handle);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: CloseHandle() failed with error %d\n"), err));
		}
		map_handle = 0;
	}
	if (security_identifier != 0)
	{
		FreeSid(security_identifier);
		security_identifier = 0;
	}
	if (access_control_list != 0)
	{
		delete[] access_control_list;
		access_control_list = 0;
	}
}

int
SharedData::count_of_records() const
{
	ASSERT(this != 0);
	return local_num_records;
}

//_TCHAR
//SharedData::drive_letter(
//	int record_index) const
//{
//	ASSERT(this != 0);
//	ASSERT(record_index >= 0);
//	ASSERT(record_index < max_shared_data_records);
//	ASSERT(record_index < local_num_records);
//	return local_records[record_index].drive_letter;
//}

__int64
SharedData::get_value(
	int record_index,
	SharedDataField field)
{
	ASSERT(this != 0);
	ASSERT(record_index >= 0);
	ASSERT(record_index < max_shared_data_records);
	ASSERT(record_index < local_num_records);
	ASSERT(field >= 0);
	ASSERT(field < num_shared_data_fields);
	return local_records[record_index].fields[field];
}

void
SharedData::set_value(
	int record_index,
	SharedDataField field,
	__int64 value)
{
	ASSERT(this != 0);
	ASSERT(record_index >= 0);
	ASSERT(record_index < max_shared_data_records);
	ASSERT(record_index < local_num_records);
	ASSERT(field >= 0);
	ASSERT(field < num_shared_data_fields);
	local_records[record_index].fields[field] = value;
}

void
SharedData::increment_value(
	int record_index,
	SharedDataField field,
	__int64 value)
{
	ASSERT(this != 0);
	ASSERT(record_index >= 0);
	ASSERT(record_index < max_shared_data_records);
	ASSERT(record_index < local_num_records);
	ASSERT(field >= 0);
	ASSERT(field < num_shared_data_fields);
	local_records[record_index].fields[field] += value;
}

bool
SharedData::send_values()
{
	ASSERT(this != 0);
	if (map_ok)
	{
		bool ok = mutex->acquire(mutex_timeout);
		if (ok)
		{
			ASSERT(shared_num_records != 0);
			*shared_num_records = local_num_records;
			ASSERT(shared_records != 0);
			ASSERT(local_records != 0);
			for (int index = 0; index < local_num_records; index++)
			{
				shared_records[index] = local_records[index];
			}
			ok = mutex->release();
			if (!ok)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
			}
		}
		else
		{
			PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
		}
		return ok;
	}
	else
	{
		return false;
	}
}

bool
SharedData::receive_values()
{
	ASSERT(this != 0);
	if (map_ok)
	{
		bool ok = mutex->acquire(mutex_timeout);
		if (ok)
		{
			ASSERT(shared_num_records != 0);
			local_num_records = *shared_num_records;
			ASSERT(shared_records != 0);
			ASSERT(local_records != 0);
			for (int index = 0; index < local_num_records; index++)
			{
				local_records[index] = shared_records[index];
			}
			ok = mutex->release();
			if (!ok)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
			}
		}
		else
		{
			PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
		}
		return ok;
	}
	else
	{
		return false;
	}
}

bool
SharedData::extract_values(
	int *num_records,
	SharedDataRecord *records)
{
	ASSERT(this != 0);
	if (map_ok)
	{
		bool ok = mutex->acquire(mutex_timeout);
		if (ok)
		{
			ASSERT(shared_num_records != 0);
			ASSERT(num_records != 0);
			*num_records = *shared_num_records;
			ASSERT(shared_records != 0);
			ASSERT(records != 0);
			for (int index = 0; index < *num_records; index++)
			{
				records[index] = shared_records[index];
			}
			ok = mutex->release();
			if (!ok)
			{
				PRINT_DEBUG_MSG((_T("GROVELER: Mutex::release() failed\n")));
			}
		}
		else
		{
			PRINT_DEBUG_MSG((_T("GROVELER: Mutex::acquire() failed\n")));
		}
		return ok;
	}
	else
	{
		return false;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\scan.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    scan.cpp

Abstract:

    SIS Groveler volume scanning function

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

/*****************************************************************************/

// scan_volume() creates the initial queue for a volume.
// It enters every qualified file in the volume into the
// queue by doing a depth-first search of the directory tree.

enum DatabaseException {
    DATABASE_ERROR
};

GrovelStatus Groveler::scan_volume(
    IN  DWORD  time_allotted,
    IN  BOOL   start_over,
    OUT DWORD *time_consumed,
    OUT DWORD *findfirst_count,
    OUT DWORD *findnext_count,
    OUT DWORD *count_of_files_enqueued)
{
    SGNativeQueueEntry queueEntry;

    SGNativeStackEntry parentEntry,
                       subdirEntry;

    TFileName parentName,
              tempName;

    HANDLE dirHandle = NULL;

    WIN32_FIND_DATA findData;

    DWORD timeConsumed      = 0,
          findFirstCount    = 0,
          findNextCount     = 0,
          numQueueAdditions = 0,
          numActions        = 0;

    ULARGE_INTEGER fileSize,
                   createTime,
                   writeTime;

    LONG num;

    BOOL success;

    ASSERT(volumeHandle != NULL);
    ASSERT(sgDatabase   != NULL);
    ASSERT(databaseName != NULL);

#ifdef DEBUG_UNTHROTTLED
    timeAllotted = INFINITE;
#else
    timeAllotted = time_allotted;
#endif

    startAllottedTime = GetTickCount();

// If the start_over flag is set, delete the current database, then
// prepare for the new scan by pushing this volume's root onto the stack.

    try {

        if (start_over) {

// Sync up with the worker thread.  We don't want to delete the existing database
// (if one exists) while the worker thread is in the middle of an (suspended)
// operation.

            abortGroveling = TRUE;                      // also set TRUE in open()

            while (grovelStatus != Grovel_ok){
                DWORD tmpTimeAllotted = timeAllotted;

                timeAllotted = INFINITE;
                ASSERT(IsReset(grovelStartEvent));
                success = SetEvent(grovelStartEvent);
                ASSERT_ERROR(success);
                WaitForEvent(grovelStopEvent);
                timeAllotted = tmpTimeAllotted;
            }

            if (!CreateDatabase())
                return Grovel_error;

            inScan = TRUE;
            abortGroveling = FALSE;
        }

// The main loop for the scanning process. Pop a directory ID
// from the stack, open and scan it. Continue the loop until
// the time allotted is used up or the stack is empty.

        do {
            num = sgDatabase->StackGetTop(&parentEntry);
            if (num <  0)
                throw DATABASE_ERROR;

// If there are no more to-do entries in the stack,
// discard the completed entries and exit the loop.

            if (num == 0) {
                inScan = FALSE;
                num = sgDatabase->StackDelete(0);
                if (num < 0)
                    throw DATABASE_ERROR;
                timeConsumed = GetTickCount() - startAllottedTime;
                break;
            }

            ASSERT(num == 1);
            ASSERT(parentEntry.fileID != 0);
            ASSERT(parentEntry.order  >  0);

            if (!GetFileName(volumeHandle, parentEntry.fileID, &parentName)) {

                DPRINTF((_T("%s: can't get name for directory 0x%016I64x\n"),
                    driveName, parentEntry.fileID));

            } else if (IsAllowedName(parentName.name)) {
// Open the directory.

                ASSERT(dirHandle == NULL);

                tempName.assign(driveName);
                tempName.append(parentName.name);
                tempName.append(_T("\\*"));

                dirHandle = FindFirstFile(tempName.name, &findData);

                if (dirHandle == INVALID_HANDLE_VALUE) {

                    DPRINTF((_T("%s: can't read directory \"%s\": %lu\n"),
                        driveName, parentName.name, GetLastError()));
                    dirHandle = NULL;

                } else {

                    findFirstCount++;

// Scan the directory.

                    do {
                        findNextCount++;

// Push every subdirectory not already on the stack
// onto the stack. (extract_log() also adds directories
// to the stack as they are created, renamed, or moved.)

                        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                                (findData.dwReserved0 == IO_REPARSE_TAG_MOUNT_POINT))
                                continue;
                        
                            if (_tcscmp(findData.cFileName, _T("."))  == 0
                             || _tcscmp(findData.cFileName, _T("..")) == 0)
                                continue;

                            tempName.assign(driveName);
                            tempName.append(parentName.name);
                            tempName.append(_T("\\"));
                            tempName.append(findData.cFileName);

                            subdirEntry.fileID = GetFileID(tempName.name);
                            if (subdirEntry.fileID == 0) {
                                DPRINTF((_T("%s: can't get ID for directory \"%s\"\n"),
                                    driveName, tempName.name));
                                continue;
                            }

                            num = sgDatabase->StackGetFirstByFileID(&subdirEntry);
                            if (num < 0)
                                throw DATABASE_ERROR;
                            if (num > 0) {
                                ASSERT(num == 1);
                                continue;
                            }

                            if (numActions == 0) {
                                if (sgDatabase->BeginTransaction() < 0)
                                    throw DATABASE_ERROR;
                                numActions = 1;
                            }

                            num = sgDatabase->StackPut(subdirEntry.fileID, FALSE);
                            if (num < 0)
                                throw DATABASE_ERROR;
                            ASSERT(num == 1);
                            numActions++;
                        }

// Add every allowed file to the queue.

                        else {
                            fileSize.HighPart = findData.nFileSizeHigh;
                            fileSize.LowPart  = findData.nFileSizeLow;

                            if ((findData.dwFileAttributes & disallowedAttributes) == 0
                             &&  fileSize.QuadPart >= minFileSize) {

                                tempName.assign(parentName.name);
                                tempName.append(_T("\\"));
                                tempName.append(findData.cFileName);

                                if (IsAllowedName(tempName.name)) {

                                    queueEntry.fileID    = 0;
                                    queueEntry.parentID  = parentEntry.fileID;
                                    queueEntry.reason    = 0;
                                    queueEntry.fileName  = findData.cFileName;
                                    queueEntry.retryTime = 0;

                                    createTime.HighPart  = findData.ftCreationTime .dwHighDateTime;
                                    createTime.LowPart   = findData.ftCreationTime .dwLowDateTime;
                                    writeTime .HighPart  = findData.ftLastWriteTime.dwHighDateTime;
                                    writeTime .LowPart   = findData.ftLastWriteTime.dwLowDateTime;
                                    queueEntry.readyTime = (createTime.QuadPart > writeTime.QuadPart
                                                         ?  createTime.QuadPart : writeTime.QuadPart)
                                                          + minFileAge;

                                    if (numActions == 0) {
                                        if (sgDatabase->BeginTransaction() < 0)
                                            throw DATABASE_ERROR;
                                        numActions = 1;
                                    }

                                    num = sgDatabase->QueuePut(&queueEntry);
                                    if (num < 0)
                                        throw DATABASE_ERROR;
                                    ASSERT(num == 1);
                                    numQueueAdditions++;
                                    numActions++;
                                }
                            }
                        }

                        if (numActions >= MAX_ACTIONS_PER_TRANSACTION) {
                            if (!sgDatabase->CommitTransaction())
                                throw DATABASE_ERROR;
                            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                                driveName, numActions, databaseName));
                            numActions = 0;
                        }
                    } while (FindNextFile(dirHandle, &findData));

// We've finished scanning this directory. Close the directory,
// move the stack entry from the to-do list to the completed
// list, and commit the changes to the stack and queue.

                    success = FindClose(dirHandle);
                    ASSERT(success);
                    dirHandle = NULL;
                }
            }

            if (numActions == 0) {
                if (sgDatabase->BeginTransaction() < 0)
                    throw DATABASE_ERROR;
                numActions = 1;
            }

            num = sgDatabase->StackDelete(parentEntry.order);
            if (num < 0)
                throw DATABASE_ERROR;
            ASSERT(num == 1);
            numActions++;

            num = sgDatabase->StackPut(parentEntry.fileID, TRUE);
            if (num < 0)
                throw DATABASE_ERROR;
            ASSERT(num == 1);
            numActions++;

            if (!sgDatabase->CommitTransaction())
                throw DATABASE_ERROR;
            TPRINTF((_T("%s: committing %lu actions to \"%s\"\n"),
                driveName, numActions, databaseName));
            numActions = 0;

// Continue scanning directories until the time
// allotted is used up or the stack is empty.

            timeConsumed = GetTickCount() - startAllottedTime;

        } while (timeConsumed < timeAllotted);
    }

// If a database error occured, close the directory and return an error status.

    catch (DatabaseException databaseException) {
        ASSERT(databaseException == DATABASE_ERROR);

        if (numActions > 0) {
            sgDatabase->AbortTransaction();
            numActions = 0;
        }

        if (dirHandle != NULL) {
            success = FindClose(dirHandle);
            ASSERT(success);
            dirHandle = NULL;
        }

        return Grovel_error;
    }

// Return the performance statistics.

    if (time_consumed           != NULL)
        *time_consumed           = timeConsumed;
    if (findfirst_count         != NULL)
        *findfirst_count         = findFirstCount;
    if (findnext_count          != NULL)
        *findnext_count          = findNextCount;
    if (count_of_files_enqueued != NULL)
        *count_of_files_enqueued = numQueueAdditions;

    TRACE_PRINTF(TC_scan, 2,
        (_T("%s: ScanTime=%lu.%03lu sec FindFirst=%lu FindNext=%lu FilesEnqueued=%lu%s\n"),
        driveName, timeConsumed / 1000, timeConsumed % 1000, findFirstCount,
        findNextCount, numQueueAdditions, inScan ? _T("") : _T(" DONE")));

    return inScan ? Grovel_pending : Grovel_ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\service.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

	SIS Groveler support for running as a system service

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

static _TCHAR *service_name = _T("Groveler");
static _TCHAR *service_path = _T("%SystemRoot%\\System32\\grovel.exe");

#if SERVICE

SERVICE_STATUS Service::status;
SERVICE_STATUS_HANDLE Service::status_handle = 0;
int Service::num_partitions = 0;
int Service::partition_indices[num_drive_letters];
unsigned int Service::max_response_time = 0;

volatile bool Service::pause_commanded = false;
volatile bool Service::grovel_paused = false;

volatile bool * Service::full_volume_scan_commanded;

volatile bool * Service::demarcate_foreground_batch;
volatile bool * Service::foreground_batch_in_progress;
volatile bool * Service::foreground_commanded;
volatile bool * Service::foreground_acknowledged;
volatile int Service::foreground_count = 0;

volatile bool Service::controller_suspended = false;
volatile bool Service::exhorter_suspended = true;

#endif // SERVICE

extern "C" __cdecl _tmain(int argc, _TCHAR **argv)
{

#if SERVICE

	return Service::start();

#else // SERVICE

	return _main(argc, argv);

#endif // SERVICE

}

#if SERVICE

int
Service::start()
{

#if DBG

	HKEY path_key;
	_TCHAR scm_path[1024];

    //
    //  See if the TYPE is interactive, if so then create a visible console
    //

	_stprintf(scm_path,
		_T("SYSTEM\\CurrentControlSet\\Services\\%s"), service_name);
	long result =
		RegOpenKeyEx(HKEY_LOCAL_MACHINE, scm_path, 0, KEY_READ, &path_key);
	if (result == ERROR_SUCCESS)
	{
		ASSERT(path_key != 0);
		DWORD service_type = 0;
		DWORD type_size = sizeof(DWORD);
		result = RegQueryValueEx(path_key, _T("Type"), 0, 0,
			(BYTE *)&service_type, &type_size);
		if (result == ERROR_SUCCESS)
		{
			ASSERT(type_size == sizeof(DWORD));
			if (service_type & SERVICE_INTERACTIVE_PROCESS)
			{
				FreeConsole();
				BOOL ok = AllocConsole();
				if (ok)
				{
                    //
                    //  fixup "stdout" to the new console
                    //

					HANDLE out_fs_handle = GetStdHandle(STD_OUTPUT_HANDLE);
					if (out_fs_handle != INVALID_HANDLE_VALUE)
					{
						int out_crt_handle =
							_open_osfhandle((LONG_PTR)out_fs_handle, _O_TEXT);
						if (out_crt_handle != -1)
   						{
							//*stdout = *(_tfdopen(out_crt_handle, _T("w")));   //Fixing PREFIX bug
                            FILE *myStdout = _tfdopen(out_crt_handle, _T("w"));
							if (myStdout != 0)
							{
                                *stdout = *myStdout;
								setvbuf(stdout, NULL, _IONBF, 0);
							}
							else
							{
								PRINT_DEBUG_MSG((_T("GROVELER: _tfdopen() failed\n")));
							}
						}
						else
						{
							PRINT_DEBUG_MSG((_T("GROVELER: _open_osfhandle() failed\n")));
						}
					}
					else
					{
						PRINT_DEBUG_MSG((_T("GROVELER: GetStdHandle() failed\n")));
					}

                    //
                    //  fixup "stderr" to the new console
                    //

					HANDLE err_fs_handle = GetStdHandle(STD_ERROR_HANDLE);
					if (err_fs_handle != INVALID_HANDLE_VALUE)
					{
						int err_crt_handle =
							_open_osfhandle((LONG_PTR)err_fs_handle, _O_TEXT);
						if (err_crt_handle != -1)
						{
							//*stderr = *(_tfdopen(err_crt_handle, _T("w"))); //fixing PREFIX bug
							FILE *myStderr = _tfdopen(err_crt_handle, _T("w"));
							if (myStderr != 0)
							{
                                *stderr = *myStderr;
								setvbuf(stderr, NULL, _IONBF, 0);
							}
							else
							{
								PRINT_DEBUG_MSG((_T("GROVELER: _tfdopen() failed\n")));
							}
						}
						else
						{
							PRINT_DEBUG_MSG((_T("GROVELER: _open_osfhandle() failed\n")));
						}
					}
					else
					{
						PRINT_DEBUG_MSG((_T("GROVELER: GetStdHandle() failed\n")));
					}
				}
				else
				{
					DWORD err = GetLastError();
					PRINT_DEBUG_MSG((_T("GROVELER: AllocConsole() failed with error %d\n"),
						err));
				}
			}
		}
		else
		{
			PRINT_DEBUG_MSG((_T("GROVELER: RegQueryValueEx() failed with error %d\n"),
				result));
		}
		ASSERT(path_key != 0);
		RegCloseKey(path_key);
		path_key = 0;
	}
	else
	{
		PRINT_DEBUG_MSG((_T("GROVELER: RegOpenKeyEx() failed with error %d\n"), result));
	}

#endif

	static SERVICE_TABLE_ENTRY dispatch_table[] =
	{
		{service_name, service_main},
		{0, 0}
	};

    int ok = StartServiceCtrlDispatcher(dispatch_table);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: StartServiceCtrlDispatcher() failed with error %d\n"),
			err));
	}
	return !ok;
}

void
Service::record_partition_indices()
{
    //
    //  Get how many total partitions there are
    //

	num_partitions = sis_drives.partition_count();

    //
    //  Allocate structures based on the number of partitions
    //

	full_volume_scan_commanded = new bool[num_partitions];
	demarcate_foreground_batch = new bool[num_partitions];
	foreground_batch_in_progress = new bool[num_partitions];
	foreground_commanded = new bool[num_partitions];
	foreground_acknowledged = new bool[num_partitions];

    //
    //  Allocate those structures
    //

	for (int index = 0; index < num_partitions; index++)
	{
		full_volume_scan_commanded[index] = false;
		demarcate_foreground_batch[index] = false;
		foreground_batch_in_progress[index] = false;
		foreground_commanded[index] = false;
		foreground_acknowledged[index] = false;
	}

    //
    //  Initializes indexes for each "Drive Letter" partition
    //

	for (index = 0; index < num_drive_letters; index++)
	{
		partition_indices[index] = -1;
	}

    //
    //  This initilaizes an array that is indexed by drive letter
    //  that maps that drive letter to the internal order they are
    //  stored in.
    //

	int num_lettered_partitions = sis_drives.lettered_partition_count();
	for (index = 0; index < num_lettered_partitions; index++)
	{
		_TCHAR drive_letter = sis_drives.partition_mount_name(index)[0];
		int drive_letter_index = _totlower(drive_letter) - _T('a');
		ASSERT(drive_letter_index >= 0);
		ASSERT(drive_letter_index < num_drive_letters);
		ASSERT(partition_indices[drive_letter_index] == -1);
		partition_indices[drive_letter_index] = index;
	}
}

void
Service::set_max_response_time(
	unsigned int max_response_time)
{
	ASSERT(max_response_time > 0);
	Service::max_response_time = max_response_time;
}

void
Service::checkpoint()
{
	status.dwCheckPoint++;
	int ok = SetServiceStatus(status_handle, &status);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
		eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
	}
}

void
Service::report_start()
{
	ASSERT(status.dwCurrentState == SERVICE_START_PENDING);
	status.dwCurrentState = SERVICE_RUNNING;

	int ok = SetServiceStatus(status_handle, &status);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
		eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
	}
}

bool
Service::groveling_paused()
{
	return grovel_paused;
}

bool
Service::foreground_groveling()
{
	ASSERT(foreground_count >= 0);
	ASSERT(foreground_count <= num_partitions);
	return foreground_count > 0;
}

void
Service::suspending_controller()
{
	controller_suspended = true;
}

void
Service::suspending_exhorter()
{
	exhorter_suspended = true;
}

bool
Service::partition_in_foreground(
	int partition_index)
{
	ASSERT(partition_index >= 0);
	ASSERT(partition_index < num_partitions);
	return foreground_batch_in_progress[partition_index]
		&& foreground_acknowledged[partition_index];
}

void
Service::set_foreground_batch_in_progress(
	int partition_index,
	bool value)
{
	ASSERT(partition_index >= 0);
	ASSERT(partition_index < num_partitions);
	ASSERT(foreground_count >= 0);
	ASSERT(foreground_count <= num_partitions);
	if (value)
	{
		if (!foreground_batch_in_progress[partition_index] &&
			foreground_acknowledged[partition_index])
		{
			foreground_count++;
		}
	}
	else
	{
		if (foreground_batch_in_progress[partition_index] &&
			foreground_acknowledged[partition_index])
		{
			foreground_count--;
		}
	}
	ASSERT(foreground_count >= 0);
	ASSERT(foreground_count <= num_partitions);
	foreground_batch_in_progress[partition_index] = value;
	if (!grovel_paused)
	{
		if (foreground_count == 0 && controller_suspended)
		{
			controller_suspended = false;
			CentralController::control_groveling((void *)controller);
		}
		if (foreground_count > 0 && exhorter_suspended)
		{
			exhorter_suspended = false;
			CentralController::exhort_groveling((void *)controller);
		}
	}
}

void
Service::follow_command()
{
    //
    //  If pause has been requested and we have not pause yet, do it
    //

	if (pause_commanded && !grovel_paused)
	{
		eventlog.report_event(GROVMSG_SERVICE_PAUSED, 0);
		grovel_paused = true;
		status.dwCurrentState = SERVICE_PAUSED;
		int ok = SetServiceStatus(status_handle, &status);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"),
				err));
			eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
		}
	}

    //
    //  If stop pausing has been requested and we are paused, unpause
    //

	if (!pause_commanded && grovel_paused)
	{
		eventlog.report_event(GROVMSG_SERVICE_CONTINUED, 0);
		grovel_paused = false;
		status.dwCurrentState = SERVICE_RUNNING;
		int ok = SetServiceStatus(status_handle, &status);
		if (!ok)
		{
			DWORD err = GetLastError();
			PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"),
				err));
			eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
		}
	}

    //
    //
    //

	for (int index = 0; index < num_partitions; index++)
	{
		ASSERT(foreground_count >= 0);
		ASSERT(foreground_count <= num_partitions);

		if (foreground_commanded[index] &&
			!foreground_acknowledged[index])
		{
			foreground_acknowledged[index] = true;
			if (foreground_batch_in_progress[index])
			{
				foreground_count++;
			}
		}

		if (!foreground_commanded[index] &&
			foreground_acknowledged[index])
		{
			foreground_acknowledged[index] = false;
			if (foreground_batch_in_progress[index])
			{
				foreground_count--;
			}
		}

		if (full_volume_scan_commanded[index])
		{
			controller->command_full_volume_scan(index);
			full_volume_scan_commanded[index] = false;
		}

		if (demarcate_foreground_batch[index])
		{
			controller->demarcate_foreground_batch(index);
			demarcate_foreground_batch[index] = false;
		}
	}

	ASSERT(foreground_count >= 0);
	ASSERT(foreground_count <= num_partitions);

	if (!grovel_paused)
	{
		if (foreground_count == 0 && controller_suspended)
		{
			controller_suspended = false;
			CentralController::control_groveling((void *)controller);
		}

		if (foreground_count > 0 && exhorter_suspended)
		{
			exhorter_suspended = false;
			CentralController::exhort_groveling((void *)controller);
		}
	}
}

void WINAPI
Service::control_handler(
	DWORD opcode)
{
	if (opcode == SERVICE_CONTROL_STOP || opcode == SERVICE_CONTROL_SHUTDOWN)
	{
		event_timer.halt();
		status.dwCurrentState = SERVICE_STOP_PENDING;
		status.dwWin32ExitCode = 0;
		status.dwWaitHint = max_response_time;
	}
	else if (opcode == SERVICE_CONTROL_PAUSE)
	{
		pause_commanded = true;
		status.dwCurrentState = SERVICE_PAUSE_PENDING;
		status.dwWaitHint = max_response_time;
	}
	else if (opcode == SERVICE_CONTROL_CONTINUE)
	{
		pause_commanded = false;
		status.dwCurrentState = SERVICE_CONTINUE_PENDING;
		status.dwWaitHint = max_response_time;
	}
	else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
		SERVICE_CONTROL_FOREGROUND)
	{
		int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
		if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
		{
			for (int index = 0; index < num_partitions; index++)
			{
				demarcate_foreground_batch[index] = true;
				foreground_commanded[index] = true;
			}
		}
		else if (drive_letter_index < num_drive_letters)
		{
			int partition_index = partition_indices[drive_letter_index];
			if (partition_index >= 0)
			{
				demarcate_foreground_batch[partition_index] = true;
				foreground_commanded[partition_index] = true;
			}
		}
	}
	else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
		SERVICE_CONTROL_BACKGROUND)
	{
		int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
		if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
		{
			for (int index = 0; index < num_partitions; index++)
			{
				foreground_commanded[index] = false;
			}
		}
		else if (drive_letter_index < num_drive_letters)
	{
			int partition_index = partition_indices[drive_letter_index];
			if (partition_index >= 0)
			{
				foreground_commanded[partition_index] = false;
			}
		}
	}
	else if ((opcode & SERVICE_CONTROL_COMMAND_MASK) ==
		SERVICE_CONTROL_VOLSCAN)
	{
		int drive_letter_index = opcode & SERVICE_CONTROL_PARTITION_MASK;
		if (drive_letter_index == SERVICE_CONTROL_ALL_PARTITIONS)
		{
			for (int index = 0; index < num_partitions; index++)
			{
				full_volume_scan_commanded[index] = true;
			}
		}
		else if (drive_letter_index < num_drive_letters)
		{
			int partition_index = partition_indices[drive_letter_index];
			if (partition_index >= 0)
			{
				full_volume_scan_commanded[partition_index] = true;
			}
		}
	}
	else if (opcode != SERVICE_CONTROL_INTERROGATE)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Unrecognized SCM opcode: %lx\n"), opcode));
	}

    //
    //  Return our current status
    //

	int ok = SetServiceStatus(status_handle, &status);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
		eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
	}

	sync_event.set();
}

void WINAPI
Service::service_main(
	DWORD argc,
	LPTSTR *argv)
{
    //
    //  Register the control handler
    //

	status_handle = RegisterServiceCtrlHandler(service_name, control_handler);
    if (status_handle == 0)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: RegisterServiceCtrlHandler() failed with error %d\n"),
			err));
		eventlog.report_event(GROVMSG_SERVICE_NOSTART, 0);
		return;
	}

    //
    //  Set Service status
    //

	status.dwServiceType = SERVICE_WIN32;
	status.dwCurrentState = SERVICE_START_PENDING;
	status.dwControlsAccepted = SERVICE_ACCEPT_STOP |
		    SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
	status.dwWin32ExitCode = 0;
	status.dwServiceSpecificExitCode = 0;
	status.dwCheckPoint = 0;
	status.dwWaitHint = 0;

	int ok = SetServiceStatus(status_handle, &status);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
		eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
	}

    //
    //  Start the main program of the service
    //

	int exit_code = _main(argc, argv);

    //
    //  When it returns, we are done
    //

	status.dwWin32ExitCode = exit_code;
	status.dwCurrentState  = SERVICE_STOPPED;
	ok = SetServiceStatus(status_handle, &status);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: SetServiceStatus() failed with error %d\n"), err));
		eventlog.report_event(GROVMSG_SET_STATUS_FAILURE, 0);
	}
}

#endif // SERVICE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\sisdrive.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sisdrive.h

Abstract:

	SIS Groveler SIS drive checker include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SISDRIVE

#define _INC_SISDRIVE

class SISDrives
{
public:

	SISDrives();

	void open();

	~SISDrives();

	int partition_count() const;

	int lettered_partition_count() const;

	_TCHAR *partition_guid_name(
		int partition_index) const;

	_TCHAR *partition_mount_name(
		int partition_index) const;

private:

	static bool is_sis_drive(
		_TCHAR *drive_name);

	void resize_buffer();

	int num_partitions;
	int num_lettered_partitions;
	int *partition_guid_names;
	int *partition_mount_names;

	int buffer_size;
	int buffer_index;
	_TCHAR *buffer;
};

#endif	/* _INC_SISDRIVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\sisdrive.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sisdrive.cpp

Abstract:

	SIS Groveler SIS drive checker class

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

SISDrives::SISDrives()
{
	num_partitions = 0;
	num_lettered_partitions = 0;
	partition_guid_names = 0;
	partition_mount_names = 0;

	buffer_size = 0;
	buffer_index = 0;
	buffer = 0;
}

void
SISDrives::open()
{
	num_partitions = 0;
	num_lettered_partitions = 0;
	partition_mount_names = 0;

	int name_array_size = 1;
	partition_guid_names = new int[name_array_size];

	buffer_size = 256;
	buffer_index = 0;
	buffer = new _TCHAR[buffer_size];

	SERVICE_CHECKPOINT();
	Volumes volumes;
	bool done = false;

    //
    //  Enumerate all existing volumes getting their GUID names
    //

	while (!done)
	{
		DWORD error_code =
			volumes.find(&buffer[buffer_index], buffer_size - buffer_index);
		while (error_code != NO_ERROR)
		{
			if (error_code != ERROR_INSUFFICIENT_BUFFER &&
				error_code != ERROR_BUFFER_OVERFLOW &&
				error_code != ERROR_FILENAME_EXCED_RANGE)
			{
				done = true;
				break;
			}
			resize_buffer();
			SERVICE_CHECKPOINT();
			error_code =
				volumes.find(&buffer[buffer_index], buffer_size - buffer_index);
		}
		if (!done)
		{
			if (num_partitions >= name_array_size)
			{
				name_array_size *= 2;
				int *new_name_array = new int[name_array_size];
                memcpy(new_name_array,partition_guid_names,num_partitions * sizeof(int));
				delete[] partition_guid_names;
				partition_guid_names = new_name_array;
			}
			partition_guid_names[num_partitions] = buffer_index;
			num_partitions++;
			buffer_index += _tcslen(&buffer[buffer_index]) + 1;
		}
		SERVICE_CHECKPOINT();
	}

    //
    //  Setup to scan for DRIVE LETTERS and MOUNT POINTS and correlate
    //  them with the drive letters.
    //

	partition_mount_names = new int[num_partitions];
	int *next_indices = new int[num_partitions + 3];
	int *work_list = &next_indices[num_partitions + 1];
	int *scan_list = &next_indices[num_partitions + 2];

	*scan_list = 0;
	for (int index = 0; index < num_partitions; index++)
	{
		partition_mount_names[index] = -1;
		next_indices[index] = index + 1;
	}
	next_indices[num_partitions - 1] = -1;

	*work_list = num_partitions;
	next_indices[num_partitions] = -1;
	int work_list_end = num_partitions;

    //
    //  Now that we have the GUID names, this will correlate the GUID names
    //  with the MOUNT names, this does both direct drive letters and
    //  mount point names.
    //

	while (*scan_list != -1 && *work_list != -1)
	{
		_TCHAR *mount_name = 0;
		int mount_size = 0;
		if (*work_list < num_partitions)
		{
			mount_name = &buffer[partition_mount_names[*work_list]];
			mount_size = _tcslen(mount_name);
			while (buffer_size - buffer_index <= mount_size)
			{
				resize_buffer();
			}
			_tcscpy(&buffer[buffer_index], mount_name);
		}

		VolumeMountPoints mount_points(mount_name);

        //
        //  We have the next name, scan the list looking for that name
        //

		done = false;
		while (!done)
		{
			DWORD error_code = mount_points.find(
				&buffer[buffer_index + mount_size],
				buffer_size - buffer_index - mount_size);
			while (error_code != NO_ERROR)
			{
				if (error_code != ERROR_INSUFFICIENT_BUFFER &&
					error_code != ERROR_BUFFER_OVERFLOW &&
					error_code != ERROR_FILENAME_EXCED_RANGE)
				{
					done = true;
					break;
				}
				resize_buffer();
				SERVICE_CHECKPOINT();
				error_code = mount_points.find(
					&buffer[buffer_index + mount_size],
					buffer_size - buffer_index - mount_size);
			}
			if (!done)
			{
				_TCHAR volume_guid_name[MAX_PATH + 1];

				BOOL ok = GetVolumeNameForVolumeMountPoint(
					&buffer[buffer_index], volume_guid_name, MAX_PATH + 1);
				if (!ok)
				{
					continue;
				}
				int scan_index = *scan_list;
				int prev_index = num_partitions + 2;
				while (scan_index >= 0)
				{
					_TCHAR *scan_name =
						&buffer[partition_guid_names[scan_index]];
					if (_tcscmp(scan_name, volume_guid_name) == 0)
					{
						partition_mount_names[scan_index] = buffer_index;
						buffer_index += _tcslen(&buffer[buffer_index]) + 1;
						next_indices[prev_index] = next_indices[scan_index];
						next_indices[scan_index] = -1;
						next_indices[work_list_end] = scan_index;
						work_list_end = scan_index;
                        if (mount_name) {
			                _tcscpy(&buffer[buffer_index], mount_name);     //get ready for next time through the loop
                        }
						break;
					}
					prev_index = scan_index;
					scan_index = next_indices[scan_index];
					SERVICE_CHECKPOINT();
				}
			}
			SERVICE_CHECKPOINT();
		}
		*work_list = next_indices[*work_list];
		SERVICE_CHECKPOINT();
	}
	delete[] next_indices;
	next_indices = 0;

    //
    //  We are now going to sort all of the drive letter entries to the front
    //  this does keep the driver letter/guid name correlation intact.
    //

	index = 0;
	while (index < num_partitions)
	{
		if (partition_mount_names[index] < 0 ||
			!is_sis_drive(&buffer[partition_guid_names[index]]))
		{

            //
            //  The given entry either doesn't have a name or SIS is
            //  not currently running on the volume.  Move it to the end
            //  of the list.

			int temp = partition_guid_names[index];
			partition_guid_names[index] =
				partition_guid_names[num_partitions - 1];
			partition_guid_names[num_partitions - 1] = temp;
			temp = partition_mount_names[index];
			partition_mount_names[index] =
				partition_mount_names[num_partitions - 1];
			partition_mount_names[num_partitions - 1] = temp;
			num_partitions--;
			continue;
		}
		if (buffer[partition_mount_names[index] + 3] == _T('\0'))
		{
            //
            //  If this is a drive letter (not a mount point) then
            //  it will be moved to the front of the list
            //

			int temp = partition_guid_names[index];
			partition_guid_names[index] =
				partition_guid_names[num_lettered_partitions];
			partition_guid_names[num_lettered_partitions] = temp;
			temp = partition_mount_names[index];
			partition_mount_names[index] =
				partition_mount_names[num_lettered_partitions];
			partition_mount_names[num_lettered_partitions] = temp;
			num_lettered_partitions++;
		}
		index++;
		SERVICE_CHECKPOINT();
	}

#if DBG
    TRACE_PRINTF(TC_sisdrive,2,
        (_T("Num Partitions=%d\nNum Lettered_partitions=%d\n"),
			num_partitions,
			num_lettered_partitions));
            
    for (index=0;index < num_partitions;index++)
    {
        TRACE_PRINTF(TC_sisdrive,2,
            (_T("Name=\"%s\" GuidName=\"%s\"\n"),
                &buffer[partition_mount_names[index]],
                &buffer[partition_guid_names[index]]));
    }
#endif
}

SISDrives::~SISDrives()
{
	if (partition_guid_names != 0)
	{
		delete[] partition_guid_names;
		partition_guid_names = 0;
	}
	if (partition_mount_names != 0)
	{
		delete[] partition_mount_names;
		partition_mount_names = 0;
	}
	if (buffer != 0)
	{
		delete[] buffer;
		buffer = 0;
	}
}

int SISDrives::partition_count() const
{
	return num_partitions;
}

int SISDrives::lettered_partition_count() const
{
	return num_lettered_partitions;
}

_TCHAR * SISDrives::partition_guid_name(
	int partition_index) const
{
	if (partition_index < num_partitions)
	{
		return &buffer[partition_guid_names[partition_index]];
	}
	else
	{
		return 0;
	}
}

_TCHAR * SISDrives::partition_mount_name(
	int partition_index) const
{
	if (partition_index < num_partitions)
	{
		return &buffer[partition_mount_names[partition_index]];
	}
	else
	{
		return 0;
	}
}

bool
SISDrives::is_sis_drive(
	_TCHAR *drive_name)
{
	UINT drive_type = GetDriveType(drive_name);
	if (drive_type != DRIVE_FIXED)
	{
		return false;
	}
	_TCHAR fs_name[8];
	BOOL ok = GetVolumeInformation(drive_name, 0, 0, 0, 0, 0, fs_name, 8);
	if (!ok)
	{
		DWORD err = GetLastError();
		PRINT_DEBUG_MSG((_T("GROVELER: GetVolumeInformation() failed with error %d\n"),
			err));
		return false;
	}
	if (_tcsicmp(fs_name, _T("NTFS")) != 0)
	{
		return false;
	}
	int drive_name_len = _tcslen(drive_name);
	_TCHAR *sis_directory =
		new _TCHAR[SIS_CSDIR_STRING_NCHARS + drive_name_len];
	_tcscpy(sis_directory, drive_name);
	_tcscpy(&sis_directory[drive_name_len - 1], SIS_CSDIR_STRING);
	ok = SetCurrentDirectory(sis_directory);
	delete[] sis_directory;
	sis_directory = 0;
	if (!ok)
	{
		return false;
	}
	BOOL sis_installed = Groveler::is_sis_installed(drive_name);
	if (!sis_installed)
	{
		return false;
	}
	return true;
}

void SISDrives::resize_buffer()
{
	buffer_size *= 2;
	_TCHAR *new_buffer = new _TCHAR[buffer_size];

    memcpy(new_buffer, buffer, buffer_index * sizeof(_TCHAR));

	delete[] buffer;
	buffer = new_buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\service.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    service.h

Abstract:

	SIS Groveler service headers

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_SERVICE

#define _INC_SERVICE

#if SERVICE

class Service
{
public:

	static int start();

	static void record_partition_indices();

	static void set_max_response_time(
		unsigned int max_response_time);

	static void checkpoint();

	static void report_start();

	static bool groveling_paused();

	static bool foreground_groveling();

	static void suspending_controller();

	static void suspending_exhorter();

	static bool partition_in_foreground(
		int partition_index);

	static void set_foreground_batch_in_progress(
		int partition_index,
		bool value);

	static void follow_command();

private:

	static void WINAPI control_handler(
		DWORD opcode);

	static void WINAPI service_main(
		DWORD argc,
		LPTSTR *argv);

	Service() {}
	~Service() {}

	enum {num_drive_letters = 26};

	static SERVICE_STATUS status;
	static SERVICE_STATUS_HANDLE status_handle;
	static int num_partitions;
	static int partition_indices[num_drive_letters];
	static unsigned int max_response_time;

	static volatile bool pause_commanded;
	static volatile bool grovel_paused;

	static volatile bool *full_volume_scan_commanded;

	static volatile bool *demarcate_foreground_batch;
	static volatile bool *foreground_batch_in_progress;
	static volatile bool *foreground_commanded;
	static volatile bool *foreground_acknowledged;
	static volatile int foreground_count;

	static volatile bool controller_suspended;
	static volatile bool exhorter_suspended;
};

#define SERVICE_RECORD_PARTITION_INDICES() Service::record_partition_indices();
#define SERVICE_SET_MAX_RESPONSE_TIME(time) Service::set_max_response_time(time);
#define SERVICE_CHECKPOINT() Service::checkpoint();
#define SERVICE_REPORT_START() Service::report_start();
#define SERVICE_GROVELING_PAUSED() Service::groveling_paused()
#define SERVICE_FOREGROUND_GROVELING() Service::foreground_groveling()
#define SERVICE_SUSPENDING_CONTROLLER() Service::suspending_controller()
#define SERVICE_SUSPENDING_EXHORTER() Service::suspending_exhorter()
#define SERVICE_PARTITION_IN_FOREGROUND(part_index) Service::partition_in_foreground(part_index)
#define SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(part_index, value) Service::set_foreground_batch_in_progress(part_index, value)
#define SERVICE_FOLLOW_COMMAND() Service::follow_command()

#else // SERVICE

#define SERVICE_RECORD_PARTITION_INDICES()
#define SERVICE_SET_MAX_RESPONSE_TIME(time)
#define SERVICE_CHECKPOINT()
#define SERVICE_REPORT_START()
#define SERVICE_GROVELING_PAUSED() false
#define SERVICE_FOREGROUND_GROVELING() false
#define SERVICE_SUSPENDING_CONTROLLER()
#define SERVICE_SUSPENDING_EXHORTER()
#define SERVICE_PARTITION_IN_FOREGROUND(part_index) false
#define SERVICE_SET_FOREGROUND_BATCH_IN_PROGRESS(part_index, value)
#define SERVICE_FOLLOW_COMMAND()

#endif // SERVICE

#endif	/* _INC_SERVICE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\timeseq.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    timeseq.cpp

Abstract:

	SIS Groveler time sequencer

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

#if TIME_SEQUENCE_VIRTUAL

unsigned int TimeSequencer::virtual_time = 0;

void
TimeSequencer::VirtualSleep(
	unsigned int sleep_time)
{
	ASSERT(signed(sleep_time) >= 0);
	virtual_time += sleep_time;
}

unsigned int
TimeSequencer::GetVirtualTickCount()
{
	virtual_time++;
	unsigned int reported_time = 10 * (virtual_time / 10);
	ASSERT(reported_time % 10 == 0);
	return reported_time;
}

#endif // TIME_SEQUENCE_VIRTUAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\trace.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trace.h

Abstract:

	SIS Groveler debugging trace include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_TRACE

#define _INC_TRACE

// The following lines are a temporary hack to allow the DPRINTF() and
// TPRINTF() macros in the database.cpp, extract.cpp, groveler.cpp, and
// scan.cpp files to continue to operate.  Each instance of the DPRINTF()
// or TPRINTF() macro should be replaced by an instance of the TRACE_PRINTF()
// macro, with an appropriate component parameter (TC_database, TC_extract,
// TC_groveler, or TC_scan) and an appropriate detail parameter.  Then, this
// comment block and all lines of code up to the next comment block should
// be deleted.

#define DPRINTF(args) TRACE_PRINTF(TC_groveler, 1, args)
#define TPRINTF(args) TRACE_PRINTF(TC_groveler, 2, args)

#if defined(TRACELEVEL) && DBG
#if TRACELEVEL == 3

#define TRACE_TYPE 2		// immediate printout
#define TRACE_IOSTREAM 2	// print to stderr

#define TRACE_GROVELER 1	// print DPRINTF() but not TPRINTF()

#define TRACE_DATABASE 1
#define TRACE_EXTRACT 1
#define TRACE_SCAN 1
#define TRACE_SISDRIVE 2

#endif // TRACELEVEL == 3
#endif /* TRACELEVEL */

/*
 *	Define TRACE_TYPE, TRACE_FILENAME, and TRACE_IOSTREAM in sources file.
 *	These settings take effect at compile time and cannot be changed thereafter.
 *
 *	TRACE_TYPE:
 *		If not defined, none
 *		0 == none
 *		1 == delayed
 *		2 == immediate
 *
 *	TRACE_FILENAME
 *		Name of destination file for output of trace prints.
 *		If not defined, then no output to file.
 *
 *	TRACE_IOSTREAM
 *		If not defined, no output to stream
 *		0 == no output to stream
 *		1 == stdout
 *		2 == stderr
 *
 *	Define trace contextual detail indicators in sources file if desired.
 *	These settings provide initial values for variables that may be changed by
 *	a debugger during run time.  Each contextual detail indicator indicates
 *	the level of trace detail that should be printed for that component.
 *	Greater numbers indicate greater levels of detail.  If an indicator is
 *	zero or not defined, then no trace information is printed for this
 *	component (unless the component has a TRACE_PRINTF() macro that specifies
 *	a detail level of zero, indicating that it should always be displayed in
 *	a trace).  The contextual detail indicators currently supported are:
 *		TRACE_MAIN
 *		TRACE_CENTCTRL
 *		TRACE_CONFEST
 *		TRACE_DATABASE
 *		TRACE_DECAYACC
 *		TRACE_DISKINFO
 *		TRACE_ETIMER
 *		TRACE_EVENT
 *		TRACE_EVENTLOG
 *		TRACE_EXTRACT
 *		TRACE_FILTER
 *		TRACE_GROVELER
 *		TRACE_MEANCOMP
 *		TRACE_MUTEX
 *		TRACE_PARAMS
 *		TRACE_PARTCTRL
 *		TRACE_PATHLIST
 *		TRACE_PEAKFIND
 *		TRACE_REGISTRY
 *		TRACE_SCAN
 *		TRACE_SERVICE
 *		TRACE_SHARE
 *		TRACE_SISDRIVE
 *		TRACE_UTILITY
 *
 *	To add a new component to the trace facility, follow these steps:
 *		1) add its name to the comment above
 *		2) add an entry to the TraceComponent enumeration below
 *		3) add an #ifndef-#define-#endif tuple to the list in trace.cpp
 *		4) add an initializer to the trace_components array in trace.cpp
 *
 *	To change the trace detail level for a given component during run time,
 *	set the element in the trace_detail[] array indexed by the TraceComponent
 *	enumeration for the desired component to the desired detail level.
 *
 */

#ifndef TRACE_TYPE
#define TRACE_TYPE 0
#endif /* TRACE_TYPE */

#ifndef TRACE_IOSTREAM
#define TRACE_IOSTREAM 0
#endif /* TRACE_IOSTREAM */

#if TRACE_TYPE > 0

enum TraceComponent
{
	TC_main,
	TC_centctrl,
	TC_confest,
	TC_database,
	TC_decayacc,
	TC_diskinfo,
	TC_etimer,
	TC_event,
	TC_eventlog,
	TC_extract,
	TC_filter,
	TC_groveler,
	TC_meancomp,
	TC_mutex,
	TC_params,
	TC_partctrl,
	TC_pathlist,
	TC_peakfind,
	TC_registry,
	TC_scan,
	TC_service,
	TC_share,
	TC_sisdrive,
	TC_utility,

	num_trace_components
};

class Tracer
{
public:

	static void trace_printf(
		_TCHAR *format,
		...);

#if TRACE_TYPE == 1

	static void print_trace_log();

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

	static void open_trace_file();

	static void close_trace_file();

#endif /* TRACE_FILENAME */

private:

	Tracer() {}
	~Tracer() {}

#if TRACE_TYPE == 1

	enum
	{
		trace_buffer_size = 4000,
		trace_entry_limit = 256
	};

	struct TraceBuffer;

	friend struct TraceBuffer;

	struct TraceBuffer
	{
		TraceBuffer *next;
		_TCHAR buffer[trace_buffer_size];
	};

	static int position;
	static TraceBuffer *trace_log;
	static TraceBuffer *current_buffer;
	static TraceBuffer *free_list;

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

	static FILE *file_stream;

#endif /* TRACE_FILENAME */

#if TRACE_IOSTREAM != 0

	static FILE *io_stream;

#endif // TRACE_IOSTREAM
};

extern int trace_detail[num_trace_components];

#define TRACE_PRINTF(component, detail, args) \
{ \
	if (detail <= trace_detail[component]) \
	{ \
		Tracer::trace_printf ## args ; \
	} \
}

#if TRACE_TYPE == 1

#define PRINT_TRACE_LOG() Tracer::print_trace_log()

#else // TRACE_TYPE == 1

#define PRINT_TRACE_LOG()

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

#define OPEN_TRACE_FILE() Tracer::open_trace_file()
#define CLOSE_TRACE_FILE() Tracer::close_trace_file()

#else /* TRACE_FILENAME */

#define OPEN_TRACE_FILE()
#define CLOSE_TRACE_FILE()

#endif /* TRACE_FILENAME */

#else // TRACE_TYPE > 0

#define TRACE_PRINTF(component, detail, args)
#define PRINT_TRACE_LOG()
#define OPEN_TRACE_FILE()
#define CLOSE_TRACE_FILE()

#endif // TRACE_TYPE > 0

#endif	/* _INC_TRACE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\utility.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utilities.cpp

Abstract:

    SIS Groveler utility functions

Authors:

    Cedric Krumbein, 1998

Environment:

    User Mode

Revision History:

--*/

#include "all.hxx"

/*****************************************************************************/

// GetPerformanceTime() converts the time interval
// measured using QueryPerformanceCounter() into milliseconds.

PerfTime GetPerformanceTime()
{
    LARGE_INTEGER count;
    QueryPerformanceCounter(&count);
    return (PerfTime)count.QuadPart;
}

/*****************************************************************************/

// PerformanceTimeToMSec() converts the time interval measured
// using QueryPerformanceCounter() into milliseconds.
// PerformanceTimeToUSec() converts it into microseconds.

static DOUBLE frequency = 0.0;

DWORD PerformanceTimeToMSec(PerfTime timeInterval)
{
    if (frequency == 0.0) {
        LARGE_INTEGER intFreq;
        QueryPerformanceFrequency(&intFreq);
        frequency = (DOUBLE)intFreq.QuadPart;
    }

    return (DWORD)((DOUBLE)timeInterval * 1000.0 / frequency);
}

LONGLONG PerformanceTimeToUSec(PerfTime timeInterval)
{
    if (frequency == 0.0) {
        LARGE_INTEGER intFreq;
        QueryPerformanceFrequency(&intFreq);
        frequency = (DOUBLE)intFreq.QuadPart;
    }

    return (LONGLONG)((DOUBLE)timeInterval * 1000000.0 / frequency);
}

/*****************************************************************************/

// GetTime() returns the current file time.

DWORDLONG GetTime()
{
    SYSTEMTIME systemTime;

    FILETIME fileTime;

    ULARGE_INTEGER time;

    BOOL success;

    GetSystemTime(&systemTime);

    success = SystemTimeToFileTime(&systemTime, &fileTime);
    ASSERT_ERROR(success);

    time.HighPart = fileTime.dwHighDateTime;
    time.LowPart  = fileTime.dwLowDateTime;

    return time.QuadPart;
}

/*****************************************************************************/

// PrintTime() converts the supplied file time into a printable string.

TCHAR *PrintTime(
    TCHAR    *string,
    DWORDLONG time)
{
    FILETIME fileTime;

    SYSTEMTIME systemTime;

    DWORD strLen;

    BOOL success;

    fileTime.dwHighDateTime = ((ULARGE_INTEGER *)&time)->HighPart;
    fileTime.dwLowDateTime  = ((ULARGE_INTEGER *)&time)->LowPart;

    success = FileTimeToSystemTime(&fileTime, &systemTime);
    ASSERT_ERROR(success);

    strLen = _stprintf(string, _T("%02hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu"),
        systemTime.wYear % 100,
        systemTime.wMonth,
        systemTime.wDay,
        systemTime.wHour,
        systemTime.wMinute,
        systemTime.wSecond,
        systemTime.wMilliseconds);
    ASSERT(strLen == 21);

    return string;
}

/*****************************************************************************/

// GetParentName() extracts the parent directory
// name out of a full-path file name.

BOOL GetParentName(
    const TCHAR *fileName,
    TFileName   *parentName)
{
    DWORD hi, lo;

    ASSERT(fileName   != NULL);
    ASSERT(parentName != NULL);

    if (fileName[0] == _T('\\'))
        lo = 1;
    else if (_istalpha(fileName[0])
          && fileName[1] == _T(':')
          && fileName[2] == _T('\\'))
        lo = 3;
    else
        return FALSE;

    hi = _tcslen(fileName) - 1;
    if (hi < lo)
        hi = lo;
    else
        for (; hi > lo; hi--)
            if (fileName[hi] == _T('\\'))
                break;

    parentName->assign(fileName, hi);
    return TRUE;
}

/*****************************************************************************/

// GetFileID gets the file's ID given its name.

DWORDLONG GetFileID(const TCHAR *fileName)
{
    HANDLE fileHandle;

    BY_HANDLE_FILE_INFORMATION fileInfo;

    ULARGE_INTEGER fileID;

    BOOL success;

    ASSERT(fileName != NULL && fileName[0] != _T('\0'));

    fileHandle = CreateFile(
        fileName,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);
    if (fileHandle == INVALID_HANDLE_VALUE)
        return 0;

    if (GetFileInformationByHandle(fileHandle, &fileInfo)) {
        fileID.HighPart = fileInfo.nFileIndexHigh;
        fileID.LowPart  = fileInfo.nFileIndexLow;
    } else
        fileID.QuadPart = 0;

    success = CloseHandle(fileHandle);
    ASSERT_ERROR(success);

    return fileID.QuadPart;
}

/*****************************************************************************/

// GetFileName gets the file's name given either
// an open handle to the file or the file's ID.

BOOL GetFileName(
    HANDLE     fileHandle,
    TFileName *tFileName)
#ifdef _UNICODE
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS ntStatus;

    for (int i = 2; i > 0; --i) {

        if (tFileName->nameLenMax < 8)              // sanity check
            tFileName->resize();

        ntStatus = NtQueryInformationFile(
                        fileHandle,
                        &ioStatusBlock,
                        tFileName->nameInfo,
                        tFileName->nameInfoSize,
                        FileNameInformation);

        if (ntStatus != STATUS_BUFFER_OVERFLOW)
            break;

        ASSERT(tFileName->nameInfo->FileNameLength > tFileName->nameInfoSize - sizeof(ULONG));

        tFileName->resize(tFileName->nameInfo->FileNameLength / sizeof(WCHAR) + 1);

    }

    if (ntStatus != STATUS_SUCCESS)
        return FALSE;

    tFileName->nameLen = tFileName->nameInfo->FileNameLength / sizeof(WCHAR);
    tFileName->name[tFileName->nameLen] = _T('\0');

    return TRUE;
}
#else
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS        ntStatus;
    TFileName       tempName;
    ULONG           nameLen;

    for (int i = 2; i > 0; --i) {

        ntStatus = NtQueryInformationFile(
            fileHandle,
            &ioStatusBlock,
            tempName.nameInfo,
            tempName.nameInfoSize - sizeof(WCHAR),
            FileNameInformation);

        if (ntStatus != STATUS_BUFFER_OVERFLOW)
            break;

        ASSERT(tempName.nameInfo->FileNameLength > tempName.nameInfoSize - sizeof(ULONG));

        nameLen = tempName.nameInfo->FileNameLength / sizeof(WCHAR);

        tempName.resize((tempName.nameInfo->FileNameLength + sizeof(WCHAR)) / sizeof(TCHAR));
    }

    if (ntStatus != STATUS_SUCCESS)
        return FALSE;

    tempName.nameInfo->FileName[nameLen] = UNICODE_NULL;

    if (tFileName->nameLenMax < nameLen + 1)
        tFileName->resize(nameLen + 1);

    sprintf(tFileName->name, "%S", tempName.name);
    tFileName->nameLen = nameLen;

    return TRUE;
}
#endif

BOOL GetFileName(
    HANDLE     volumeHandle,
    DWORDLONG  fileID,
    TFileName *tFileName)
{
    UNICODE_STRING fileIDString;

    OBJECT_ATTRIBUTES objectAttributes;

    IO_STATUS_BLOCK ioStatusBlock;

    HANDLE fileHandle;

    NTSTATUS ntStatus;

    BOOL success;

    fileIDString.Length        = sizeof(DWORDLONG);
    fileIDString.MaximumLength = sizeof(DWORDLONG);
    fileIDString.Buffer        = (WCHAR *)&fileID;

    objectAttributes.Length                   = sizeof(OBJECT_ATTRIBUTES);
    objectAttributes.RootDirectory            = volumeHandle;
    objectAttributes.ObjectName               = &fileIDString;
    objectAttributes.Attributes               = OBJ_CASE_INSENSITIVE;
    objectAttributes.SecurityDescriptor       = NULL;
    objectAttributes.SecurityQualityOfService = NULL;

    ntStatus = NtCreateFile(
        &fileHandle,
        GENERIC_READ,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        0,
        FILE_SHARE_VALID_FLAGS,
        FILE_OPEN,
        FILE_OPEN_BY_FILE_ID    |
        FILE_OPEN_REPARSE_POINT |
        FILE_NO_INTERMEDIATE_BUFFERING,
        NULL,
        0);
    if (ntStatus != STATUS_SUCCESS)
        return FALSE;

    success = GetFileName(fileHandle, tFileName);
    NtClose(fileHandle);
    return success;
}

/*****************************************************************************/

// GetCSIndex() returns the SIS reparse point's common store
// index. The file handle must point to an open reparse point.

BOOL GetCSIndex(
    HANDLE fileHandle,
    CSID  *csIndex)
{
    IO_STATUS_BLOCK ioStatusBlock;

    BYTE buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    REPARSE_DATA_BUFFER *reparseBuffer;

    SI_REPARSE_BUFFER *sisReparseBuffer;

    ASSERT(fileHandle != NULL);
    ASSERT(csIndex    != NULL);

    if (NtFsControlFile(
        fileHandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        FSCTL_GET_REPARSE_POINT,
        NULL,
        0,
        buffer,
        MAXIMUM_REPARSE_DATA_BUFFER_SIZE) != STATUS_SUCCESS) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    reparseBuffer = (REPARSE_DATA_BUFFER *)buffer;
    if (reparseBuffer->ReparseTag != IO_REPARSE_TAG_SIS) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    sisReparseBuffer = (SI_REPARSE_BUFFER *)
        reparseBuffer->GenericReparseBuffer.DataBuffer;

    if (sisReparseBuffer->ReparsePointFormatVersion != SIS_REPARSE_BUFFER_FORMAT_VERSION) {
        memset(csIndex, 0, sizeof(CSID));
        return FALSE;
    }

    *csIndex = sisReparseBuffer->CSid;
    return TRUE;
}

/*****************************************************************************/

// GetCSName() converts the common store
// index into a dynamically allocated string.

TCHAR *GetCSName(CSID *csIndex)
{
    TCHAR *rpcStr;

    RPC_STATUS rpcStatus;

    ASSERT(csIndex != NULL);

    rpcStatus = UuidToString(csIndex, (unsigned short **)&rpcStr);
    if (rpcStatus != RPC_S_OK) {
        ASSERT(rpcStr == NULL);
        return NULL;
    }

    ASSERT(rpcStr != NULL);
    return rpcStr;
}

/*****************************************************************************/

// FreeCSName frees the string allocated by GetCSName().

VOID FreeCSName(TCHAR *rpcStr)
{
    RPC_STATUS rpcStatus;

    ASSERT(rpcStr != NULL);

    rpcStatus = RpcStringFree((unsigned short **)&rpcStr);
    ASSERT(rpcStatus == RPC_S_OK);
}

/*****************************************************************************/

// Checksum() generates a checksum on the data supplied in the buffer.
// The checksum function used is selected at compile-time; currently
// the 131-hash and the "Bill 32" hash functions are implemented.

#define HASH131
// #define BILL32HASH

Signature Checksum(
    const VOID *buffer,
    DWORD       bufferLen,
    DWORDLONG   offset,
    Signature   firstWord)
{
    Signature *bufferPtr,
               word,
               signature;

    DWORD numWords,
          numBytes,
          rotate;

    ASSERT(buffer != NULL);

    bufferPtr = (Signature *)buffer;
    numWords  = bufferLen / sizeof(Signature);
    numBytes  = bufferLen % sizeof(Signature);
    signature = firstWord;

#ifdef BILL32HASH
    rotate = (DWORD)(offset / sizeof(Signature) % (sizeof(Signature)*8-1));
#endif

    while (numWords-- > 0) {
        word       = *bufferPtr++;
#ifdef HASH131
        signature  = signature * 131 + word;
#endif
#ifdef BILL32HASH
        signature ^= ROTATE_RIGHT(word, rotate);
        rotate     = (rotate+1) % (sizeof(Signature)*8-1);
#endif
    }

    if (numBytes > 0) {
        word       = 0;
        memcpy(&word, bufferPtr, numBytes);
#ifdef HASH131
        signature  = signature * 131 + word;
#endif
#ifdef BILL32HASH
        signature ^= ROTATE_RIGHT(word, rotate);
#endif
    }

    return signature;
}

/*****************************************************************************/
/************************ Table class private methods ************************/
/*****************************************************************************/

DWORD Table::Hash(
    const VOID *key,
    DWORD       keyLen) const
{
    USHORT *keyPtr;

    DWORD hashValue;

    if (keyLen == 0)
        return 0;

    ASSERT(key != NULL);

    if (keyLen <= sizeof(DWORD)) {
        hashValue = 0;
        memcpy(&hashValue, key, keyLen);
        return hashValue;
    }

    keyPtr    = (USHORT *)key;
    hashValue = 0;

    while (keyLen >= sizeof(USHORT)) {
        hashValue = hashValue*37 + (DWORD)*keyPtr++;
        keyLen   -= sizeof(USHORT);
    }

    if (keyLen > 0)
        hashValue = hashValue*37 + (DWORD)*(BYTE *)keyPtr;

    hashValue *= TABLE_RANDOM_CONSTANT;
    if ((LONG)hashValue < 0)
        hashValue = (DWORD)-(LONG)hashValue;
    hashValue %= TABLE_RANDOM_PRIME;

    return hashValue;
}

/*****************************************************************************/

DWORD Table::BucketNum(DWORD hashValue) const
{
    DWORD bucketNum;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

    bucketNum = hashValue & ~(~0U << level);
    if (bucketNum < expandIndex)
        bucketNum = hashValue & ~(~0U << (level+1));

    ASSERT(bucketNum < numBuckets);

    return bucketNum;
}

/*****************************************************************************/

VOID Table::Expand()
{
    TableEntry **oldSlotAddr,
               **newSlotAddr,
                *oldChain,
                *newChain,
                *entry;

    TableSegment **newDirectory,
                  *newSegment;

    DWORD oldNewMask;

#if DBG
    TableEntry *prevChain;
    DWORD       mask;
#endif

// Increase the directory size if necessary.

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);

    if (numBuckets >= dirSize * TABLE_SEGMENT_SIZE) {
        newDirectory = new TableSegment * [dirSize + TABLE_DIR_SIZE];
        ASSERT(newDirectory != NULL);
        memcpy(newDirectory, directory, sizeof(TableSegment *) * dirSize);
        memset(newDirectory+dirSize, 0, sizeof(TableSegment *) * TABLE_DIR_SIZE);
        dirSize += TABLE_DIR_SIZE;
        delete directory;
        directory = newDirectory;
    }

// Find the old bucket to be expanded.

    ASSERT(expandIndex >> TABLE_SEGMENT_BITS < dirSize);

    oldSlotAddr = &directory[expandIndex >> TABLE_SEGMENT_BITS]
                      ->slot[expandIndex &  TABLE_SEGMENT_MASK];

    ASSERT(oldSlotAddr != NULL);

// Find the new bucket, and create a new segment if necessary.

    ASSERT(numBuckets >> TABLE_SEGMENT_BITS < dirSize);

    newSegment = directory[numBuckets >> TABLE_SEGMENT_BITS];

    if (newSegment == NULL) {
        newSegment = new TableSegment;
        ASSERT(newSegment != NULL);
        memset(newSegment, 0, sizeof(TableSegment));
        directory[numBuckets >> TABLE_SEGMENT_BITS] = newSegment;
    }

    newSlotAddr = &newSegment->slot[numBuckets & TABLE_SEGMENT_MASK];

    ASSERT(*newSlotAddr == NULL);

// Relocate entries from the old to the new bucket.

    oldNewMask = 1U << level;
    oldChain   = NULL;
    newChain   = NULL;
    entry      = *oldSlotAddr;

#if DBG
    prevChain = NULL;
    mask      = ~(~0U << (level+1));
#endif

    while (entry != NULL) {
        ASSERT((entry->hashValue & ~(~0U << level)) == expandIndex);
        ASSERT( entry->prevChain == prevChain);

// This entry moves to the new bucket.

        if ((entry->hashValue & oldNewMask) != 0) {
            if (newChain == NULL) {
                *newSlotAddr = entry;
                entry->prevChain = NULL;
            } else {
                newChain->nextChain = entry;
                entry   ->prevChain = newChain;
            }

            newChain = entry;

            ASSERT((entry->hashValue & mask) == numBuckets);
        }

// This entry stays in the old bucket.

        else {
            if (oldChain == NULL) {
                *oldSlotAddr = entry;
                entry->prevChain = NULL;
            } else {
                oldChain->nextChain = entry;
                entry   ->prevChain = oldChain;
            }

            oldChain = entry;

            ASSERT((entry->hashValue & mask) == expandIndex);
        }

#if DBG
        prevChain = entry;
#endif
        entry = entry->nextChain;
    }

// Finish off each bucket chain.

    if (oldChain == NULL)
        *oldSlotAddr = NULL;
    else
        oldChain->nextChain = NULL;

    if (newChain == NULL)
        *newSlotAddr = NULL;
    else
        newChain->nextChain = NULL;

// Adjust the expand index and level, and increment the number of buckets.

    if (++expandIndex == 1U << level) {
        level++;
        expandIndex = 0;
    }
    numBuckets++;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);
}

/*****************************************************************************/

VOID Table::Contract()
{
    TableEntry **targetSlotAddr,
               **victimSlotAddr,
                *firstVictimEntry,
                *prevChain,
                *entry;

    TableSegment **newDirectory;

#if DBG
    DWORD mask;
#endif

// Adjust the expand index and level, and decrement the number of buckets.

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

    if (expandIndex > 0)
        expandIndex--;
    else
        expandIndex = (1U << --level) - 1;
    numBuckets--;

    ASSERT(expandIndex <   1U << level);
    ASSERT(numBuckets  == (1U << level) + expandIndex);

// Find the target and victim buckets.

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);

    targetSlotAddr = &directory[expandIndex >> TABLE_SEGMENT_BITS]
                         ->slot[expandIndex &  TABLE_SEGMENT_MASK];
    victimSlotAddr = &directory[numBuckets  >> TABLE_SEGMENT_BITS]
                         ->slot[numBuckets  &  TABLE_SEGMENT_MASK];

    ASSERT(targetSlotAddr != NULL);
    ASSERT(victimSlotAddr != NULL);

// If the victim buffer isn't empty, ...

    if ((firstVictimEntry = *victimSlotAddr) != NULL) {
#if DBG
        mask = ~(~0U << (level+1));
#endif
        ASSERT((firstVictimEntry->hashValue & mask) == numBuckets);
        ASSERT( firstVictimEntry->prevChain == NULL);

// ... find the end of the target bucket chain, ...

        entry     = *targetSlotAddr;
        prevChain = NULL;

        while (entry != NULL) {
            ASSERT((entry->hashValue & mask) == expandIndex);
            ASSERT( entry->prevChain == prevChain);

            prevChain = entry;
            entry     = entry->nextChain;
        }

// ... then add the victim bucket chain to the end of the target bucket chain.

        if (prevChain == NULL)
            *targetSlotAddr = firstVictimEntry;
        else {
            prevChain->nextChain = firstVictimEntry;
            firstVictimEntry->prevChain = prevChain;
        }
    }

// Delete the victim bucket, and delete the victim segment if no buckets remain.

    if ((numBuckets & TABLE_SEGMENT_MASK) == 0) {
        delete directory[numBuckets >> TABLE_SEGMENT_BITS];
        directory[numBuckets >> TABLE_SEGMENT_BITS] = NULL;
    } else
        *victimSlotAddr = NULL;

// Reduce the size of the directory if necessary.

    if (numBuckets <= (dirSize - TABLE_DIR_SIZE) * TABLE_SEGMENT_SIZE
     && dirSize > TABLE_DIR_SIZE) {
        dirSize -= TABLE_DIR_SIZE;
        newDirectory = new TableSegment * [dirSize];
        ASSERT(newDirectory != NULL);
        memcpy(newDirectory, directory, sizeof(TableSegment *) * dirSize);
        delete directory;
        directory = newDirectory;
    }
}

/*****************************************************************************/
/************************ Table class public methods *************************/
/*****************************************************************************/

Table::Table()
{
    firstEntry = NULL;
    lastEntry  = NULL;

    numEntries  = 0;
    numBuckets  = TABLE_SEGMENT_SIZE;
    expandIndex = 0;
    level       = TABLE_SEGMENT_BITS;

    dirSize   = TABLE_DIR_SIZE;
    directory = new TableSegment * [dirSize];
    ASSERT(directory != NULL);
    memset(directory, 0, sizeof(TableSegment *) * dirSize);

    directory[0] = new TableSegment;
    ASSERT(directory[0] != NULL);
    memset(directory[0], 0, sizeof(TableSegment));
}

/*****************************************************************************/

Table::~Table()
{
    TableEntry *entry,
               *prevEntry;

    DWORD numSegments,
          segmentNum,
          count;

    entry     = firstEntry;
    prevEntry = NULL;
    count     = 0;

    while (entry != NULL) {
        ASSERT(entry->prevEntry == prevEntry);
        prevEntry = entry;
        entry     = entry->nextEntry;
        delete prevEntry->data;
        delete prevEntry;
        count++;
    }
    ASSERT(count == numEntries);

    numSegments = numBuckets >> TABLE_SEGMENT_BITS;

    ASSERT(directory != NULL);
    ASSERT(dirSize >= TABLE_SEGMENT_SIZE);
    ASSERT(dirSize %  TABLE_SEGMENT_SIZE == 0);
    ASSERT(numSegments <= dirSize);

    for (segmentNum = 0; segmentNum < numSegments; segmentNum++) {
        ASSERT(directory[segmentNum] != NULL);
        delete directory[segmentNum];
    }

    delete directory;
}

/*****************************************************************************/

BOOL Table::Put(
    VOID *data,
    DWORD keyLen)
{
    TableEntry **slotAddr,
                *prevChain,
                *entry;

    DWORD hashValue,
          bucketNum;

#if DBG
    DWORD mask;
#endif

    ASSERT(data   != NULL);
    ASSERT(keyLen >  0);

// Find the bucket for this data.

    hashValue = Hash(data, keyLen);
    bucketNum = BucketNum(hashValue);

#if DBG
    mask = ~(~0U << (bucketNum < expandIndex || bucketNum >= 1U << level
                     ? level+1 : level));
#endif

    ASSERT(directory != NULL);

    slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                   ->slot[bucketNum &  TABLE_SEGMENT_MASK];

    ASSERT(slotAddr != NULL);

    entry     = *slotAddr;
    prevChain =  NULL;

// Look at each entry in the bucket to determine if the data is
// already present. If a matching entry is found, return FALSE.

    while (entry != NULL) {
        ASSERT((entry->hashValue & mask) == bucketNum);
        ASSERT( entry->prevChain == prevChain);

        if (hashValue == entry->hashValue
         && keyLen    == entry->keyLen
         && memcmp(data, entry->data, keyLen) == 0)
            return FALSE;

        prevChain = entry;
        entry     = entry->nextChain;
    }

// No entry with matching data was found in this bucket.
// Create a new entry and add it to the end of the bucket chain.

    entry = new TableEntry;
    ASSERT(entry != NULL);

    if (prevChain == NULL) {
        *slotAddr = entry;
        entry->prevChain = NULL;
    } else {
        prevChain->nextChain = entry;
        entry    ->prevChain = prevChain;
    }
    entry->nextChain = NULL;

// Add the entry to the end of the doubly-linked list.

    if (lastEntry == NULL) {
        ASSERT(firstEntry == NULL);
        ASSERT(numEntries == 0);
        firstEntry       = entry;
        entry->prevEntry = NULL;
    } else {
        ASSERT(firstEntry != NULL);
        ASSERT(numEntries >  0);
        lastEntry->nextEntry = entry;
        entry    ->prevEntry = lastEntry;
    }

    entry->nextEntry = NULL;
    lastEntry        = entry;
    numEntries++;

// Fill out the entry.

    entry->hashValue = hashValue;
    entry->keyLen    = keyLen;
    entry->data      = data;

// Expand the table if necessary.

    if (numEntries > numBuckets * TABLE_MAX_LOAD) {
        Expand();
        ASSERT(numEntries <= numBuckets * TABLE_MAX_LOAD);
    }

    return TRUE;
}

/*****************************************************************************/

VOID *Table::Get(
    const VOID *key,
    DWORD       keyLen,
    BOOL        erase)
{
    TableEntry **slotAddr,
                *entry,
                *prevChain;

    DWORD hashValue,
          bucketNum;

    VOID *dataPtr;

#if DBG
    DWORD mask;
#endif

    ASSERT(key    != NULL);
    ASSERT(keyLen >  0);

// Find the bucket for this data.

    hashValue = Hash(key, keyLen);
    bucketNum = BucketNum(hashValue);

#if DBG
    mask = ~(~0U << (bucketNum < expandIndex || bucketNum >= 1U << level
                     ? level+1 : level));
#endif

    ASSERT(directory != NULL);

    slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                   ->slot[bucketNum &  TABLE_SEGMENT_MASK];

    ASSERT(slotAddr != NULL);

    entry     = *slotAddr;
    prevChain = NULL;

// Look at each entry in the bucket.

    while (entry != NULL) {
        ASSERT((entry->hashValue & mask) == bucketNum);
        ASSERT( entry->prevChain == prevChain);

        if (hashValue == entry->hashValue
         && keyLen    == entry->keyLen
         && memcmp(key, entry->data, keyLen) == 0) {

// The entry with matching data has been found.

            dataPtr = entry->data;
            ASSERT(dataPtr != NULL);

// If erasure is disabled, remove the entry from the doubly-linked list ...

            if (erase) {
                if (entry->prevEntry == NULL) {
                    ASSERT(firstEntry == entry);
                    firstEntry = entry->nextEntry;
                } else
                    entry->prevEntry->nextEntry = entry->nextEntry;

                if (entry->nextEntry == NULL) {
                    ASSERT(lastEntry == entry);
                    lastEntry = entry->prevEntry;
                } else
                    entry->nextEntry->prevEntry = entry->prevEntry;

// ... and from the bucket chain, ...

                if (prevChain == NULL)
                    *slotAddr = entry->nextChain;
                else
                    prevChain->nextChain = entry->nextChain;

                if (entry->nextChain != NULL) {
                    ASSERT(entry->nextChain->prevChain == entry);
                    entry->nextChain->prevChain = prevChain;
                }

// ... then delete the entry.

                delete entry;

// Decrement the number of entries, and contract the table if necessary.

                numEntries--;
                if (numBuckets > TABLE_SEGMENT_SIZE
                 && numEntries < numBuckets * TABLE_MIN_LOAD) {
                    Contract();
                    ASSERT(numBuckets <= TABLE_SEGMENT_SIZE
                        || numEntries >= numBuckets * TABLE_MIN_LOAD);
                }
            }

            return dataPtr;
        }

// No entry with matching data has yet been found.
// Continue following the bucket chain.

        prevChain = entry;
        entry     = entry->nextChain;
    }

// No entry with matching data was found in this bucket.

    return NULL;
}

/*****************************************************************************/

VOID *Table::GetFirst(
    DWORD *keyLen,
    BOOL   erase)
{
    TableEntry **slotAddr,
                *entry;

    DWORD bucketNum;

    VOID *dataPtr;

// If the table is empty, then simply return.

    if (firstEntry == NULL) {
        ASSERT(lastEntry  == NULL);
        ASSERT(numEntries == 0);
        return NULL;
    }

    dataPtr = firstEntry->data;
    ASSERT(dataPtr != NULL);
    if (keyLen != NULL) {
        *keyLen = firstEntry->keyLen;
        ASSERT(firstEntry->keyLen > 0);
    }

// If erasure is enabled, remove the first entry from the doubly-linked list ...

    if (erase) {
        entry      = firstEntry;
        firstEntry = entry->nextEntry;

        if (firstEntry == NULL) {
            ASSERT(numEntries == 1);
            ASSERT(lastEntry  == entry);
            lastEntry = NULL;
        } else {
            ASSERT(numEntries >  1);
            ASSERT(firstEntry->prevEntry == entry);
            firstEntry->prevEntry = NULL;
        }

// ... and from the bucket chain, ...

        if (entry->prevChain == NULL) {
            bucketNum = BucketNum(entry->hashValue);
            ASSERT(directory != NULL);
            slotAddr = &directory[bucketNum >> TABLE_SEGMENT_BITS]
                           ->slot[bucketNum &  TABLE_SEGMENT_MASK];
            ASSERT( slotAddr != NULL);
            ASSERT(*slotAddr == entry);
            *slotAddr = entry->nextChain;
        } else {
            ASSERT(entry->prevChain->nextChain == entry);
            entry->prevChain->nextChain = entry->nextChain;
        }

        if (entry->nextChain != NULL) {
            ASSERT(entry->nextChain->prevChain == entry);
            entry->nextChain->prevChain = entry->prevChain;
        }

// ... then delete the entry.

        delete entry;

// Decrement the number of entries, and contract the table if necessary.

        numEntries--;
        if (numBuckets > TABLE_SEGMENT_SIZE
         && numEntries < numBuckets * TABLE_MIN_LOAD) {
            Contract();
            ASSERT(numBuckets <= TABLE_SEGMENT_SIZE
                || numEntries >= numBuckets * TABLE_MIN_LOAD);
        }
    }

    return dataPtr;
}

/*****************************************************************************/

DWORD Table::Number() const
{
    return numEntries;
}

/*****************************************************************************/
/************************* FIFO class public methods *************************/
/*****************************************************************************/

FIFO::FIFO()
{
    head = tail = NULL;
    numEntries = 0;
}

/*****************************************************************************/

FIFO::~FIFO()
{
    FIFOEntry *entry = head,
              *oldEntry;

    DWORD count = 0;

    while ((oldEntry = entry) != NULL) {
        entry = entry->next;
        delete oldEntry->data;
        delete oldEntry;
        count++;
    }

    ASSERT(count == numEntries);
}

/*****************************************************************************/

VOID FIFO::Put(VOID *data)
{
    FIFOEntry *newEntry;

    ASSERT(data != NULL);

    newEntry = new FIFOEntry;
    ASSERT(newEntry != NULL);
    newEntry->next = NULL;
    newEntry->data = data;

    if (tail != NULL)
        tail->next = newEntry;
    else
        head       = newEntry;
    tail = newEntry;

    numEntries++;
}

/*****************************************************************************/

VOID *FIFO::Get()
{
    FIFOEntry *oldHead;

    VOID *dataPtr;

    if (head == NULL) {
        ASSERT(tail == NULL);
        ASSERT(numEntries == 0);
        return NULL;
    }

    ASSERT(tail != NULL);
    ASSERT(numEntries > 0);

    dataPtr = head->data;

    oldHead = head;
    head    = head->next;
    delete oldHead;
    if (head == NULL)
        tail = NULL;
    numEntries--;

    return dataPtr;
}

/*****************************************************************************/

DWORD FIFO::Number() const
{
    return numEntries;
}

/*****************************************************************************/
/************************* LIFO class public methods *************************/
/*****************************************************************************/

LIFO::LIFO()
{
    top = NULL;
    numEntries = 0;
}

/*****************************************************************************/

LIFO::~LIFO()
{
    LIFOEntry *entry = top,
              *oldEntry;

    DWORD count = 0;

    while ((oldEntry = entry) != NULL) {
        entry = entry->next;
        delete oldEntry->data;
        delete oldEntry;
        count++;
    }

    ASSERT(count == numEntries);
}

/*****************************************************************************/

VOID LIFO::Put(VOID *data)
{
    LIFOEntry *newEntry;

    ASSERT(data != NULL);

    newEntry = new LIFOEntry;
    ASSERT(newEntry != NULL);
    newEntry->next = top;
    newEntry->data = data;
    top = newEntry;
    numEntries++;
}

/*****************************************************************************/

VOID *LIFO::Get()
{
    LIFOEntry *oldTop;

    VOID *dataPtr;

    if (top == NULL) {
        ASSERT(numEntries == 0);
        return NULL;
    }

    ASSERT(numEntries > 0);

    dataPtr = top->data;

    oldTop = top;
    top    = top->next;
    delete oldTop;
    numEntries--;

    return dataPtr;
}

/*****************************************************************************/

DWORD LIFO::Number() const
{
    return numEntries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\volumes.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    volumes.h

Abstract:

	SIS Groveler volume mount include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_VOLUMES

#define _INC_VOLUMES

class Volumes
{
public:

	Volumes();

	~Volumes();

	DWORD find(
		_TCHAR *volume_name,
		DWORD length);

private:

	HANDLE volume_handle;
};

class VolumeMountPoints
{
public:

	VolumeMountPoints(
		_TCHAR *volume_name);

	~VolumeMountPoints();

	DWORD find(
		_TCHAR *volume_mount_point,
		DWORD length);

private:

	_TCHAR *volume_name;
	DWORD drive_mask;
	_TCHAR drive_letter;
	HANDLE volume_handle;
};

#endif	/* _INC_VOLUMES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\timeseq.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    timeseq.h

Abstract:

	SIS Groveler time sequencer include file

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#ifndef _INC_TIMESEQ

#define _INC_TIMESEQ

#if TIME_SEQUENCE_VIRTUAL

class TimeSequencer
{
public:

	static void VirtualSleep(
		unsigned int sleep_time);

	static unsigned int GetVirtualTickCount();

private:

	TimeSequencer() {}
	~TimeSequencer() {}

	static unsigned int virtual_time;
};

#define SLEEP(stime) TimeSequencer::VirtualSleep(stime)
#define GET_TICK_COUNT() TimeSequencer::GetVirtualTickCount()
#define WAIT_FOR_SINGLE_OBJECT(handle, timeout) \
	(TimeSequencer::VirtualSleep(timeout), WAIT_TIMEOUT)

#else // TIME_SEQUENCE_VIRTUAL

#define SLEEP(stime) Sleep(stime)
#define GET_TICK_COUNT() GetTickCount()
#define WAIT_FOR_SINGLE_OBJECT(handle, timeout) \
	WaitForSingleObject(handle, timeout)

#endif // TIME_SEQUENCE_VIRTUAL

#endif	/* _INC_TIMESEQ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\volumes.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    volumes.cpp

Abstract:

	SIS Groveler SIS volume mount classes

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

Volumes::Volumes()
{
	volume_handle = INVALID_HANDLE_VALUE;
}

Volumes::~Volumes()
{
	if (volume_handle != INVALID_HANDLE_VALUE)
	{
		FindVolumeClose(volume_handle);
		volume_handle = INVALID_HANDLE_VALUE;
	}
}

DWORD
Volumes::find(
	_TCHAR *volume_name,
	DWORD length)
{
	DWORD error_code = NO_ERROR;
	if (volume_handle == INVALID_HANDLE_VALUE)
	{
		volume_handle = FindFirstVolume(volume_name, length);
		if (volume_handle == INVALID_HANDLE_VALUE)
		{
			error_code = GetLastError();
		}
	}
	else
	{
		BOOL ok = FindNextVolume(volume_handle, volume_name, length);
		if (!ok)
		{
			error_code = GetLastError();
		}
	}
	return error_code;
}


VolumeMountPoints::VolumeMountPoints(
	_TCHAR *volume_name)
{
	this->volume_name = volume_name;
	drive_mask = 0;
	drive_letter = 0;
	volume_handle = INVALID_HANDLE_VALUE;
	if (volume_name == 0)
	{
		drive_mask = GetLogicalDrives();
		_TCHAR drive_name[4];
		drive_name[0] = _T('a');
		drive_name[1] = _T(':');
		drive_name[2] = _T('\\');
		drive_name[3] = _T('\0');
		DWORD drive_bit = 1;
		while (drive_name[0] <= _T('z'))
		{
			if ((drive_mask & drive_bit) != 0)
			{
				UINT drive_type = GetDriveType(drive_name);
				if (drive_type != DRIVE_FIXED)
				{
					drive_mask &= ~drive_bit;
				}
			}
			drive_bit <<= 1;
			drive_name[0]++;
		}
		drive_mask <<= 1;
		drive_letter = _T('a') - 1;
	}
}

VolumeMountPoints::~VolumeMountPoints()
{
	if (volume_handle != INVALID_HANDLE_VALUE)
	{
		FindVolumeMountPointClose(volume_handle);
		volume_handle = INVALID_HANDLE_VALUE;
	}
}

DWORD
VolumeMountPoints::find(
	_TCHAR *volume_mount_point,
	DWORD length)
{
	if (volume_name == 0)
	{
		if ((drive_mask & 0xfffffffe) == 0)
		{
			return ERROR_NO_MORE_FILES;
		}
		if (length < 4)
		{
			return ERROR_FILENAME_EXCED_RANGE;
		}
		do
		{
			drive_mask >>= 1;
			drive_letter++;
		} while ((drive_mask & 1) == 0);
		volume_mount_point[0] = drive_letter;
		volume_mount_point[1] = _T(':');
		volume_mount_point[2] = _T('\\');
		volume_mount_point[3] = _T('\0');
		return NO_ERROR;
	}
	else
	{
		if (volume_handle == INVALID_HANDLE_VALUE)
		{
			volume_handle = FindFirstVolumeMountPoint(
				volume_name, volume_mount_point, length);
			if (volume_handle == INVALID_HANDLE_VALUE)
			{
				return GetLastError();
			}
		}
		else
		{
			BOOL ok = FindNextVolumeMountPoint(
				volume_handle, volume_mount_point, length);
			if (!ok)
			{
				return GetLastError();
			}
		}
		return NO_ERROR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\trace.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trace.cpp

Abstract:

	SIS Groveler debugging tracer

Authors:

	John Douceur, 1998

Environment:

	User Mode


Revision History:


--*/

#include "all.hxx"

#if TRACE_TYPE > 0

#ifndef TRACE_MAIN
#define TRACE_MAIN 0
#endif /* TRACE_MAIN */

#ifndef TRACE_CENTCTRL
#define TRACE_CENTCTRL 0
#endif /* TRACE_CENTCTRL */

#ifndef TRACE_CONFEST
#define TRACE_CONFEST 0
#endif /* TRACE_CONFEST */

#ifndef TRACE_DATABASE
#define TRACE_DATABASE 0
#endif /* TRACE_DATABASE */

#ifndef TRACE_DECAYACC
#define TRACE_DECAYACC 0
#endif /* TRACE_DECAYACC */

#ifndef TRACE_DISKINFO
#define TRACE_DISKINFO 0
#endif /* TRACE_DISKINFO */

#ifndef TRACE_ETIMER
#define TRACE_ETIMER 0
#endif /* TRACE_ETIMER */

#ifndef TRACE_EVENT
#define TRACE_EVENT 0
#endif /* TRACE_EVENT */

#ifndef TRACE_EVENTLOG
#define TRACE_EVENTLOG 0
#endif /* TRACE_EVENTLOG */

#ifndef TRACE_EXTRACT
#define TRACE_EXTRACT 0
#endif /* TRACE_EXTRACT */

#ifndef TRACE_FILTER
#define TRACE_FILTER 0
#endif /* TRACE_FILTER */

#ifndef TRACE_GROVELER
#define TRACE_GROVELER 0
#endif /* TRACE_GROVELER */

#ifndef TRACE_MEANCOMP
#define TRACE_MEANCOMP 0
#endif /* TRACE_MEANCOMP */

#ifndef TRACE_MUTEX
#define TRACE_MUTEX 0
#endif /* TRACE_MUTEX */

#ifndef TRACE_PARAMS
#define TRACE_PARAMS 0
#endif /* TRACE_PARAMS */

#ifndef TRACE_PARTCTRL
#define TRACE_PARTCTRL 0
#endif /* TRACE_PARTCTRL */

#ifndef TRACE_PATHLIST
#define TRACE_PATHLIST 0
#endif /* TRACE_PATHLIST */

#ifndef TRACE_PEAKFIND
#define TRACE_PEAKFIND 0
#endif /* TRACE_PEAKFIND */

#ifndef TRACE_REGISTRY
#define TRACE_REGISTRY 0
#endif /* TRACE_REGISTRY */

#ifndef TRACE_SCAN
#define TRACE_SCAN 0
#endif /* TRACE_SCAN */

#ifndef TRACE_SERVICE
#define TRACE_SERVICE 0
#endif /* TRACE_SERVICE */

#ifndef TRACE_SHARE
#define TRACE_SHARE 0
#endif /* TRACE_SHARE */

#ifndef TRACE_SISDRIVE
#define TRACE_SISDRIVE 0
#endif /* TRACE_SISDRIVE */

#ifndef TRACE_UTILITY
#define TRACE_UTILITY 0
#endif /* TRACE_UTILITY */

int trace_detail[num_trace_components] =
{
	TRACE_MAIN,
	TRACE_CENTCTRL,
	TRACE_CONFEST,
	TRACE_DATABASE,
	TRACE_DECAYACC,
	TRACE_DISKINFO,
	TRACE_ETIMER,
	TRACE_EVENT,
	TRACE_EVENTLOG,
	TRACE_EXTRACT,
	TRACE_FILTER,
	TRACE_GROVELER,
	TRACE_MEANCOMP,
	TRACE_MUTEX,
	TRACE_PARAMS,
	TRACE_PARTCTRL,
	TRACE_PATHLIST,
	TRACE_PEAKFIND,
	TRACE_REGISTRY,
	TRACE_SCAN,
	TRACE_SERVICE,
	TRACE_SHARE,
	TRACE_SISDRIVE,
	TRACE_UTILITY
};

#if TRACE_TYPE == 1

int Tracer::position = trace_buffer_size;
Tracer::TraceBuffer * Tracer::trace_log = 0;
Tracer::TraceBuffer * Tracer::current_buffer = 0;
Tracer::TraceBuffer * Tracer::free_list = 0;

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

FILE * Tracer::file_stream = 0;

#endif /* TRACE_FILENAME */

#if TRACE_IOSTREAM == 1

FILE * Tracer::io_stream = stdout;

#elif TRACE_IOSTREAM != 0

FILE * Tracer::io_stream = stderr;

#endif // TRACE_IOSTREAM

void
Tracer::trace_printf(
	_TCHAR *format,
	...)
{
	ASSERT(format != 0);
#if TRACE_TYPE == 1
	if (position >= trace_buffer_size - trace_entry_limit)
	{
		TraceBuffer *new_buffer;
		if (free_list == 0)
		{
			new_buffer = new TraceBuffer;
		}
		else
		{
			new_buffer = free_list;
			free_list = free_list->next;
		}
		ASSERT(new_buffer != 0);
		new_buffer->next = 0;
		if (current_buffer == 0)
		{
			trace_log = new_buffer;
		}
		else
		{
			current_buffer->next = new_buffer;
		}
		current_buffer = new_buffer;
		position = 0;
	}
	ASSERT(current_buffer != 0);
	va_list ap;
	va_start(ap, format);
	int result = _vsntprintf(&current_buffer->buffer[position],
		trace_entry_limit, format, ap);
	va_end(ap);
	if (result >= trace_entry_limit || result < 0)
	{
		position += trace_entry_limit;
		_tcscpy(&current_buffer->buffer[position - 4], _T("...\n"));
	}
	else
	{
		position += result;
	}
	ASSERT(position < trace_buffer_size);
#else // TRACE_TYPE == 1
	va_list ap;
#ifdef TRACE_FILENAME
	if (file_stream != 0)
	{
		va_start(ap, format);
		_vftprintf(file_stream, format, ap);
		va_end(ap);
	}
#endif /* TRACE_FILENAME */
#if TRACE_IOSTREAM != 0
	va_start(ap, format);
	_vftprintf(io_stream, format, ap);
	va_end(ap);
#endif // TRACE_IOSTREAM != 0
#endif // TRACE_TYPE == 1
}

#if TRACE_TYPE == 1

void
Tracer::print_trace_log()
{
	TraceBuffer *buffer = trace_log;
	while (buffer != 0)
	{
#ifdef TRACE_FILENAME
		if (file_stream != 0)
		{
			_ftprintf(file_stream, _T("%s"), buffer->buffer);
		}
#endif /* TRACE_FILENAME */
#if TRACE_IOSTREAM != 0
		ASSERT(io_stream != 0);
		_ftprintf(io_stream, _T("%s"), buffer->buffer);
#endif // TRACE_IOSTREAM != 0
		TraceBuffer *next_buffer = buffer->next;
		buffer->next = free_list;
		free_list = buffer;
		buffer = next_buffer;
	}
	trace_log = 0;
	current_buffer = 0;
	position = 0;
}

#endif // TRACE_TYPE == 1

#ifdef TRACE_FILENAME

void Tracer::open_trace_file()
{
	file_stream = _tfopen(_T(TRACE_FILENAME), _T("w"));
	if (file_stream == 0)
	{
		PRINT_DEBUG_MSG((_T("GROVELER: Unable to open trace file ") _T(TRACE_FILENAME)));
	}
}

void Tracer::close_trace_file()
{
	if (file_stream != 0)
	{
		fclose(file_stream);
	}
}

#endif /* TRACE_FILENAME */

#endif // TRACE_TYPE > 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\groveler\utility.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	utilities.h

Abstract:

	SIS Groveler general utilities include file

Authors:

	Cedric Krumbein, 1998

Environment:

	User Mode

Revision History:

--*/

/************************ General-purpose definitions ************************/

typedef DWORDLONG Signature;
typedef LONGLONG  PerfTime;

#define Clear(OBJECT) \
	memset(&(OBJECT), 0, sizeof(OBJECT))

#define IsSet(EVENT) \
	((EVENT) != NULL && WaitForSingleObject(EVENT, 0) == WAIT_OBJECT_0)

#define IsReset(EVENT) \
	((EVENT) != NULL && WaitForSingleObject(EVENT, 0) == WAIT_TIMEOUT)

#define ROTATE_LEFT(DATA, NUM_BITS) \
	((DATA) << (NUM_BITS) | (DATA) >> (sizeof(DATA)*8 - (NUM_BITS)))

#define ROTATE_RIGHT(DATA, NUM_BITS) \
	((DATA) >> (NUM_BITS) | (DATA) << (sizeof(DATA)*8 - (NUM_BITS)))

/************************ Utility function prototypes ************************/

#define PERF_TIME_TO_MSEC(VALUE) PerformanceTimeToMSec(VALUE)

#define PERF_TIME_TO_USEC(VALUE) PerformanceTimeToUSec(VALUE)

PerfTime GetPerformanceTime();

DWORD PerformanceTimeToMSec(PerfTime timeInterval);

LONGLONG PerformanceTimeToUSec(PerfTime timeInterval);

DWORDLONG GetTime();

TCHAR *PrintTime(TCHAR    *string,
                 DWORDLONG time);

DWORDLONG GetFileID(const TCHAR *fileName);

BOOL GetCSIndex(HANDLE fileHandle,
                CSID  *csIndex);

//
// A class to handle arbitrary length pathnames, as returned by NtQueryInformationFile()
//
class TFileName {

public:
    ULONG                   nameLenMax;                 // maximum length of name
	ULONG                   nameLen;                    // actual length of name (not including NULL terminator)
	TCHAR                  *name;                       // file name (ptr to nameInfo->FileName)
    FILE_NAME_INFORMATION  *nameInfo;                   // required by NtQueryInformationFile
    ULONG                   nameInfoSize;               // sizeof nameInfo buffer

    TFileName(void) : nameLenMax(0), nameLen(0), name(NULL), nameInfo(NULL), nameInfoSize(0) {}

    ~TFileName() {
        if (nameInfo)
            delete[] nameInfo;
    }

    void resize(int size = 900) {
        if (nameInfo)
            delete[] nameInfo;

        allocBuf(size);
    }

    void append(const TCHAR *s, int c = -1) {
        int slen;
        int n;

        if (0 == c || NULL == s)
            return;

        slen = _tcslen(s);

        if (-1 == c)
            n = slen;
        else
            n = min(slen, c);

        // If the combined size of the two strings is larger than our buffer,
        // realloc the buffer.

        if (nameLen + n + 1 > nameLenMax) {
            FILE_NAME_INFORMATION *ni = nameInfo;

            allocBuf(nameLen + n + 1 + 512);

            if (ni) {
                _tcsncpy(name, ni->FileName, nameLen);
                delete[] ni;
            }
        }

        _tcsncpy(&name[nameLen], s, n);
        nameLen += n;
        name[nameLen] = _T('\0');
    }

    void assign(const TCHAR *s, int c = -1) {
        if (nameLenMax > 0) {
            nameLen = 0;
            name[0] = _T('\0');
        }
        append(s, c);
    }

private:

    // Allocate a buffer for nameInfo of the specified size.  Note that name will 
    // point into this buffer.

    void allocBuf(int size) {
        ASSERT(size >= 0);

        nameLenMax = size;
        nameLen = 0;

        if (size > 0) {
            nameInfoSize = size * sizeof(TCHAR) + sizeof(ULONG);

            nameInfo = (PFILE_NAME_INFORMATION) new BYTE[nameInfoSize + sizeof FILE_NAME_INFORMATION]; // conservative size

            ASSERT(nameInfo);               // new_handler should raise exception on out of memory
            ASSERT((((ULONG_PTR) nameInfo) % sizeof(ULONG)) == 0); // make sure alignment is correct

            name = (TCHAR *) nameInfo->FileName;
            name[0] = _T('\0');

            ASSERT(((UINT_PTR) &nameInfo->FileName[size] - (UINT_PTR) nameInfo) == nameInfoSize);
        } else {
            nameInfo = NULL;
            name = NULL;
            nameInfoSize = 0;
        }
    }
};

BOOL GetFileName(
	HANDLE     fileHandle,
	TFileName *tFileName);

BOOL GetFileName(
	HANDLE     volumeHandle,
	DWORDLONG  fileID,
	TFileName *tFileName);

TCHAR *GetCSName(CSID *csIndex);

VOID FreeCSName(TCHAR *rpcStr);

Signature Checksum(
	const VOID *buffer,
	DWORD       bufferLen,
	DWORDLONG   offset,
	Signature   firstWord);

/*********************** Hash table class declaration ************************/

#define TABLE_MIN_LOAD 4
#define TABLE_MAX_LOAD 5

#define TABLE_RANDOM_CONSTANT 314159269
#define TABLE_RANDOM_PRIME   1000000007

#define TABLE_DIR_SIZE 256

#define TABLE_SEGMENT_BITS  8
#define TABLE_SEGMENT_SIZE (1U << TABLE_SEGMENT_BITS)
#define TABLE_SEGMENT_MASK (TABLE_SEGMENT_SIZE - 1U)

class Table {

private:

	struct TableEntry {
		TableEntry *prevEntry,
		           *nextEntry,
		           *prevChain,
		           *nextChain;

		DWORD hashValue,
		      keyLen;

		VOID *data;
	} *firstEntry,
	  *lastEntry;

	DWORD numBuckets,
	      dirSize,
	      expandIndex,
	      level,
	      numEntries;

	struct TableSegment {
		TableEntry *slot[TABLE_SEGMENT_SIZE];
	} **directory;

	DWORD Hash(const VOID *key,
	           DWORD       keyLen) const;

	DWORD BucketNum(DWORD hashValue) const;

	VOID Expand();

	VOID Contract();

public:

	Table();

	~Table();

	BOOL Put(
		VOID *data,
		DWORD keyLen);

	VOID *Get(const VOID *key,
	          DWORD       keyLen,
	          BOOL        erase = FALSE);

	VOID *GetFirst(DWORD *keyLen = NULL,
	               BOOL   erase  = TRUE);

	DWORD Number() const;
};

/************************** FIFO class declaration ***************************/

class FIFO {

private:

	struct FIFOEntry {
		FIFOEntry *next;
		DWORD      size;
		VOID      *data;
	} *head, *tail;

	DWORD numEntries;

public:

	FIFO();

	~FIFO();

	VOID Put(VOID *data);

	VOID *Get();

	DWORD Number() const;
};

/************************** LIFO class declaration ***************************/

class LIFO {

private:

	struct LIFOEntry {
		LIFOEntry *next;
		DWORD      size;
		VOID      *data;
	} *top;

	DWORD numEntries;

public:

	LIFO();

	~LIFO();

	VOID Put(VOID *data);

	VOID *Get();

	DWORD Number() const;
};

BOOL GetParentName(const TCHAR *fileName,
                   TFileName   *parentName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\sisbkup\avl.h ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	avl.h

Abstract:

	AVL tree template class implementation

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/

enum AVLBalance {
    AVLNew,			// Not yet inserted in a tree
    AVLLeft,			// Left side is one deeper than the right
    AVLBalanced,		// Left and right sides are evenly balanced
    AVLRight,			// Right side is one deeper than left
};

template<class elementClass> class AVLElement;

template<class elementClass> class AVLTree {

public:
			 AVLTree(
			    unsigned		 preallocateSize = 0);

			~AVLTree(void);

    elementClass	*findFirstLessThanOrEqualTo(
			   elementClass		*element);

    elementClass	*findFirstGreaterThan(
			    elementClass	*element);

    elementClass	*findFirstGreaterThanOrEqualTo(
			    elementClass	*element);

    elementClass	*findMin(void);

    elementClass	*findMax(void);

    int			 empty(void);

    unsigned		 size(void);

    void		 check(void);

    BOOLEAN		 insert(
			    elementClass	*element);

    void		 remove(
			    elementClass	*element);

    void		 dumpPoolStats(void);

private:

    AVLElement<elementClass>		*tree;

    Pool		*avlElementPool;

    unsigned		 insertions;
    unsigned		 deletions;
    unsigned		 singleRotations;
    unsigned		 doubleRotations;

    friend class AVLElement<elementClass>;
};


// The AVLElement class would normally be declared in the avl.cpp file, except that because it's
// a template, it needs to be in the header file.  It can only be accessed (including creation and
// destruction) by the AVLTree friend class.

template<class elementClass> class AVLElement {

private:

			 AVLElement(void);

			~AVLElement(void);

    void		 initialize(void);

    void		 insert(
			    AVLTree<elementClass>		*intoTree,
			    elementClass			*element);

    void		 remove(
			    AVLTree<elementClass>		*fromTree);

    unsigned		 checkAndReturnDepth(
			    unsigned				*countedElements);

    int			 inTree(void);    

    int			 operator<=(
			    AVLElement<elementClass>		*peer);

    int			 operator<(
			    AVLElement<elementClass>		*peer);

    int			 operator==(
			    AVLElement<elementClass>		*peer);

    int			 operator>=(
			    AVLElement<elementClass>		*peer);

    int			 operator>(
			    AVLElement<elementClass>		*peer);


    AVLElement<elementClass>
			*findFirstLessThanOrEqualTo(
			    elementClass		*element);

    AVLElement<elementClass>
			*findFirstGreaterThan(
			    elementClass		*element);

    AVLElement<elementClass>
			*findFirstGreaterThanOrEqualTo(
			    elementClass		*element);

    void		 rightAdded(
			    AVLTree<elementClass>	*tree);

    void		 leftAdded(
			    AVLTree<elementClass>	*tree);

    void		 singleRotate(
			    AVLTree<elementClass>	*tree,
			    AVLElement<elementClass>	*child,
			    AVLBalance			 whichSide);

    void		 doubleRotate(
			    AVLTree<elementClass>	*tree,
			    AVLElement<elementClass>	*child,
			    AVLElement<elementClass>	*grandchild,
			    AVLBalance			 whichSide);

    void		 gotOneShorter(
			    AVLTree<elementClass>	*tree,
			    AVLBalance			 whichSide);

    AVLBalance		 balance;

    AVLElement<elementClass>		*left;
    AVLElement<elementClass>		*right;
    AVLElement<elementClass>		*parent;
    elementClass			*element;

    friend class AVLTree<elementClass>;
};

    template<class elementClass>  elementClass *
AVLTree<elementClass>::findFirstLessThanOrEqualTo(
    elementClass			*element)
{
    assert(element);
    if (!tree) 
	return(NULL);

    AVLElement<elementClass> *avlElement = tree->findFirstLessThanOrEqualTo(element);
    if (avlElement) {
	return(avlElement->element);
    } else {
	return(NULL);
    }
}

    template<class elementClass> 
AVLTree<elementClass>::AVLTree(
    unsigned		 preallocateSize)
{
    tree = NULL;
    insertions = deletions = singleRotations = doubleRotations = 0;
    avlElementPool = new Pool(sizeof(AVLElement<elementClass>));
    if (preallocateSize && (NULL != avlElementPool)) {
		avlElementPool->preAllocate(preallocateSize);
	}
}

template<class elementClass> AVLTree<elementClass>::~AVLTree(void)
{
    assert(tree == NULL);
	
	if (NULL != avlElementPool) {
		delete avlElementPool;
	}
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstLessThanOrEqualTo                                    *
//*                                                                          *
//* Syntax:    AVLElement * findFirstLessThanOrEqualTo(                      *
//*                         elementClass * element)                          *
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a value less than or equal *
//*              to the one specified, or NULL on failure.                   *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            less than or equal to the one specified.                      *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> *
AVLElement<elementClass>::findFirstLessThanOrEqualTo(elementClass * element)
{
    AVLElement<elementClass> * retVal = NULL;
    
    if (*this->element == element) {
	// We have a direct match (equal to).  It takes precidence over the
	// "first less than" part.
	return this;
    }
    if (*this->element < element) {
	// The current element is smaller than the one specified.
	// This might be it, but try to find a bigger one.
	if (right != NULL) {
	    retVal = right->findFirstLessThanOrEqualTo(element);
	}
	
	// If nothing below us (to the right) was found, then we are the
	// next smallest one.
	if (retVal == NULL) {
	    return this;
	}
	else {
	    return retVal;
	}
    }
    else {
	// The current element is bigger than the one specified.
	// We have to find a smaller one.
	if (left != NULL) {
	    return left->findFirstLessThanOrEqualTo(element);
	}
	else {
	    return NULL;
	}
    }
}

    template<class elementClass> elementClass *
AVLTree<elementClass>::findFirstGreaterThan(
    elementClass			*element)
{
    assert(element);
    if (!tree) 
	return(NULL);

    AVLElement<elementClass> *avlElement = tree->findFirstGreaterThan(element);

    if (avlElement) {
	return(avlElement->element);
    } else {
	return(NULL);
    }
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstGreaterThan                                          *
//*                                                                          *
//* Syntax:    AVLElement * findFirstGreaterThan(elementClass * element)     *
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a vlaue greater than the   *
//*              one specified, or NULL on failure.                          *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            greater than the one specified.                               *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> * 
AVLElement<elementClass>::findFirstGreaterThan(elementClass * element)
{
    AVLElement<elementClass> * retVal = NULL;
    
    if (*this->element > element) {
	// The current element is bigger than the one specified.
	// This might be it, but try to find a smaller one.
	if (left != NULL) {
	    retVal = left->findFirstGreaterThan(element);
	}

	// If nothing below us (to the left) was found, then we are the
	// next biggest one.
	if (retVal == NULL) {
	    return this;
	}
	else {
	    return retVal;
	}
    }
    else {
	// The current element is smaller than (or equal) the one specified.
	// We have to find a bigger one.
	if (right != NULL) {
	    return right->findFirstGreaterThan(element);
	}
	else {
	    return NULL;
	}
    }
}

    template<class elementClass> elementClass *
AVLTree<elementClass>::findFirstGreaterThanOrEqualTo(
    elementClass			*element)
{
    assert(element);
    if (!tree) 
	return(NULL);

    AVLElement<elementClass> *avlElement = tree->findFirstGreaterThanOrEqualTo(element);

    if (avlElement) {
	return(avlElement->element);
    } else {
	return(NULL);
    }
}

//****************************************************************************
//*                                                                          *
//* Function:  findFirstGreaterThanOrEqualTo                                 *
//*                                                                          *
//* Syntax:    AVLElement * findFirstGreaterThanOrEqualTo(elementClass * element)
//*                                                                          *
//* Input:     elementClass * element:                                       *
//*              A pointer to an element to compare against while searching. *
//*                                                                          *
//* Output:    AVLElement *:                                                 *
//*              The element in the tree that has a vlaue greater than or    *
//*              equal to the one specified, or NULL on failure.             *
//*                                                                          *
//* Synopsis:  This function finds the element in the tree that has a value  *
//*            greater than or equal to the one specified.                   *
//*                                                                          *
//**************************************************************************** 
template<class elementClass> AVLElement<elementClass> * 
AVLElement<elementClass>::findFirstGreaterThanOrEqualTo(elementClass * element)
{
    if (*this->element == element) {
	// We have a direct match (equal to).  It takes precidence over the
	// "first less than" part.
	return this;
    }

    AVLElement<elementClass> * retVal = NULL;
    
    if (*this->element > element) {
	// The current element is bigger than the one specified.
	// This might be it, but try to find a smaller one.
	if (left != NULL) {
	    retVal = left->findFirstGreaterThanOrEqualTo(element);
	}

	// If nothing below us (to the left) was found, then we are the
	// next biggest one.
	if (retVal == NULL) {
	    return this;
	} else {
	    return retVal;
	}
    } else {
	// The current element is strictly smaller than the one specified.
	// We have to find a bigger one.
	if (right != NULL) {
	    return right->findFirstGreaterThanOrEqualTo(element);
	} else {
	    return NULL;
	}
    }
}

    template<class elementClass> int
AVLTree<elementClass>::empty(void)
{
    assert((tree == NULL) == (insertions == deletions));
    return(tree == NULL);
}

    template<class elementClass> unsigned
AVLTree<elementClass>::size(void)
{
    assert(insertions >= deletions);
    assert((tree == NULL) == (insertions == deletions));
    return(insertions - deletions);
}

    template<class elementClass> elementClass *
AVLTree<elementClass>::findMin(void)
{
    if (!tree) {
	return(NULL);
    }

    AVLElement<elementClass> *candidate = tree;
    while (candidate->left) {
	assert(*candidate->left->element <= candidate->element);
	candidate = candidate->left;
    }
    return(candidate->element);
}

    template<class elementClass> elementClass *
AVLTree<elementClass>::findMax(void)
{
    if (!tree) {
	return(NULL);
    }

    AVLElement<elementClass> *candidate = tree;
    while (candidate->right) {
	assert(*candidate->right->element >= candidate->element);
	candidate = candidate->right;
    }
    return(candidate->element);
}

    template<class elementClass> void
AVLTree<elementClass>::check(void)
{
    AVLElement<elementClass> * currElement = NULL;
    AVLElement<elementClass> * nextElement = NULL;
    AVLElement<elementClass> * oldElement = NULL;

    unsigned countedElements = 0;
    if (tree) {
	assert(tree->parent == NULL);
	unsigned overallDepth = tree->checkAndReturnDepth(&countedElements);
    }
    assert(insertions-deletions == countedElements);

    // Check every element in the tree for consistance by verifying that it is in
    // the expected order.  If not, it is most likely that the element's operators
    // are not behaving as needed.
    for(currElement = tree; currElement != NULL; currElement = nextElement) {
	// Go left if we can (and have not already been here).
	if (currElement->left && oldElement == currElement->parent) {
	    nextElement = currElement->left;
	    assert(*nextElement < currElement && "The < operator appears to be broken");
	    assert(*currElement > nextElement && "The > operator appears to be broken");
	    assert(!(*nextElement == currElement) && "The == operator appears to be broken");
	}
	// Otherwise go right if we can (and have not already been here).
	else if (currElement->right && 
	       (oldElement == currElement->left || oldElement == currElement->parent)) {
	    nextElement = currElement->right;
	    assert(*nextElement > currElement && "The > operator appears to be broken");
	    assert(*currElement < nextElement && "The < operator appears to be broken");
	    assert(!(*nextElement == currElement) && "The == operator appears to be broken");
	}
	// We are done below us, go up a node.
	else {
	    nextElement = currElement->parent;
	}

	oldElement = currElement;
	assert(*oldElement == currElement && "The == operator appears to be broken");
    }
}


    template<class elementClass> 
AVLElement<elementClass>::AVLElement(void)
{
    balance = AVLNew;
    left = right = parent = NULL;
}

    template<class elementClass> 
AVLElement<elementClass>::~AVLElement(void)
{
    assert(balance == AVLNew);
    assert(left == NULL && right == NULL && parent == NULL);
}

    template<class elementClass> unsigned
AVLElement<elementClass>::checkAndReturnDepth(
    unsigned			*countedElements)
{
    // We've been inserted and not deleted
    assert(balance != AVLNew);

    (*countedElements)++;

    // Assert that the links all match up.
    assert(!left || left->parent == this);
    assert(!right || right->parent == this);

    // The basic binary tree ordering property applies
    assert(!right || *this <= right);
    assert(!left || *this >= left);

    // The AVL balance property applies
    unsigned leftDepth;
    if (left) {
	leftDepth = left->checkAndReturnDepth(countedElements);
    } else {
	leftDepth = 0;
    }

    unsigned rightDepth;
    if (right) {
	rightDepth = right->checkAndReturnDepth(countedElements);
    } else {
	rightDepth = 0;
    }

    if (leftDepth == rightDepth) {
	assert(balance == AVLBalanced);
	return(leftDepth + 1);
    }

    if (leftDepth == rightDepth + 1) {
	assert(balance == AVLLeft);
	return(leftDepth + 1);
    }

    if (leftDepth + 1 == rightDepth) {
	assert(balance == AVLRight);
	return(rightDepth + 1);
    }

    assert(!"AVL Tree out of balance");
    return(0);
}

    template<class elementClass> void
AVLElement<elementClass>::insert(
    AVLTree<elementClass>		*intoTree,
    elementClass			*element)
{
    assert(intoTree);
    assert(left == NULL && right == NULL && parent == NULL);

    this->element = element;
    assert(this->element);

    intoTree->insertions++;

    // Special case the empty tree case.
    if (intoTree->tree == NULL) {
	intoTree->tree = this;
	balance = AVLBalanced;
	// We already know all of the links are NULL, which is correct for this case.
	return;
    }

    // Find the leaf position at which to do this insertion.

    AVLElement *currentNode = intoTree->tree;
    AVLElement *previousNode;
    while (currentNode) {
	previousNode = currentNode;
	if (*currentNode < this) {
	    currentNode = currentNode->right;
	} else if (*currentNode > this) {
	    currentNode = currentNode->left;
	} else {
	    // An AVL tree gets all whacky if you try to insert duplicate values.
	    assert(!"Trying to insert a duplicate item.  Use something other than an AVL tree.");
	}
    }

    balance = AVLBalanced;
    parent = previousNode;
    assert(parent);
    if (*previousNode <= this) {
	assert(!previousNode->right);
	previousNode->right = this;
	previousNode->rightAdded(intoTree);
//	intoTree->check();
    } else { 
	assert(!previousNode->left);
	previousNode->left = this;
	previousNode->leftAdded(intoTree);
//	intoTree->check();
    }
}

    template<class elementClass> void
AVLElement<elementClass>::rightAdded(
    AVLTree<elementClass>	*tree)
{
    //We've just gotten one deeper on our right side.
    assert(balance != AVLNew);
    
    if (balance == AVLLeft) {
	balance = AVLBalanced;
	// The depth of the subtree rooted here hasn't changed, we're done
	return;
    }
    if (balance == AVLBalanced) {
	// We've just gotten one deeper, but are still balanced.  Update and recurse up the
	// tree.
	balance = AVLRight;
	if (parent) {
	    if (parent->right == this) {
		parent->rightAdded(tree);
	    } else {
		assert(parent->left == this);
		parent->leftAdded(tree);
	    }
	}
	return;
    }
    assert(balance == AVLRight);
    // We've just gone to double right (ie, out of balance).
    assert(right);
    if (right->balance == AVLRight) {
	singleRotate(tree,right,AVLRight);
    } else {
	assert(right->balance == AVLLeft);	// Else we shouldn't have been AVLRight before the call
	doubleRotate(tree,right,right->left,AVLRight);
    }
}

    template<class elementClass> void
AVLElement<elementClass>::leftAdded(
    AVLTree<elementClass>	*tree)
{
    //We've just gotten one deeper on our right side.
    assert(balance != AVLNew);
    
    if (balance == AVLRight) {
	balance = AVLBalanced;
	// The depth of the subtree rooted here hasn't changed, we're done
	return;
    }
    if (balance == AVLBalanced) {
	// We've just gotten one deeper, but are still balanced.  Update and recurse up the
	// tree.
	balance = AVLLeft;
	if (parent) {
	    if (parent->right == this) {
		parent->rightAdded(tree);
	    } else {
		assert(parent->left == this);
		parent->leftAdded(tree);
	    }
	}
	return;
    }
    assert(balance == AVLLeft);
    // We've just gone to double left (ie, out of balance).
    assert(left);
    if (left->balance == AVLLeft) {
	singleRotate(tree,left,AVLLeft);
    } else {
	assert(left->balance == AVLRight);	// Else we shouldn't have been AVLLeft before the call
	doubleRotate(tree,left,left->right,AVLLeft);
    }
}

    template<class elementClass> void
AVLElement<elementClass>::singleRotate(
    AVLTree<elementClass>	*tree,
    AVLElement			*child,
    AVLBalance			 whichSide)
{
    // We're the parent node.

    assert(tree);
    assert(child);
    assert(whichSide == AVLRight || whichSide == AVLLeft);

    assert(whichSide != AVLRight || right == child);
    assert(whichSide != AVLLeft || left == child);

    tree->singleRotations++;

    // Promote the child to our position in the tree.

    if (parent) {
	if (parent->left == this) {
	    parent->left = child;
	    child->parent = parent;
	} else {
	    assert(parent->right == this);
	    parent->right = child;
	    child->parent = parent;
	}
    } else {
	// We're the root of the tree
	assert(tree->tree == this);
	tree->tree = child;
	child->parent = NULL;
    }

    // Attach the child's light subtree to our heavy side (ie., where the child is attached now)
    // Then, attach us to the child's light subtree
    if (whichSide == AVLRight) {
	right = child->left;
	if (right) {
	    right->parent = this;
	}

	child->left = this;
	parent = child;
    } else {
	left = child->right;
	if (left) {
	    left->parent = this;
	}

	child->right = this;
	parent = child;	
    }

    // Finally, now both our and our (former) child's balance is "balanced"
    balance = AVLBalanced;
    child->balance = AVLBalanced;
    // NB. One of the cases in delete will result in the above balance settings being incorrect.  That
    // case fixes up the settings after we return.
}

    template<class elementClass> void
AVLElement<elementClass>::doubleRotate(
    AVLTree<elementClass>	*tree,
    AVLElement			*child,
    AVLElement			*grandchild,
    AVLBalance			 whichSide)
{
    assert(tree && child && grandchild);
    assert(whichSide == AVLLeft || whichSide == AVLRight);

    assert(whichSide != AVLLeft || (left == child && child->balance == AVLRight));
    assert(whichSide != AVLRight || (right == child && child->balance == AVLLeft));

    assert(child->parent == this);
    assert(grandchild->parent == child);

    tree->doubleRotations++;

    // Write down a copy of all of the subtrees; see Knuth v3 p454 for the picture.
    // NOTE: The alpha and delta trees are never moved, so we don't store them.
    AVLElement *beta;
    AVLElement *gamma;

    if (whichSide == AVLRight) {
	beta = grandchild->left;
	gamma = grandchild->right;
    } else {
	beta = grandchild->right;
	gamma = grandchild->left;
    }

    // Promote grandchild to our position
    if (parent) {
        if (parent->left == this) {
	    parent->left = grandchild;
        } else {
	    assert(parent->right == this);
	    parent->right = grandchild;
    	}
    } else {
	assert(tree->tree == this);
	tree->tree = grandchild;
    }
    grandchild->parent = parent;

    // Attach the appropriate children to grandchild
    if (whichSide == AVLRight) {
	grandchild->right = child;
	grandchild->left = this;
    } else {
	grandchild->right = this;
	grandchild->left = child;
    }
    parent = grandchild;
    child->parent = grandchild;

    // Attach beta and gamma to us and child.
    if (whichSide == AVLRight) {
	right = beta;
	if (beta) {
	    beta->parent = this;
	}
	child->left = gamma;
	if (gamma) {
	    gamma->parent = child;
	}
    } else {
	left = beta;
	if (beta) {
	    beta->parent = this;
	}
	child->right = gamma;
	if (gamma) {
	    gamma->parent = child;
	}
    }

    // Now update the balance fields.
    switch (grandchild->balance) {
	case AVLLeft:
		if (whichSide == AVLRight) {
		    balance = AVLBalanced;
		    child->balance = AVLRight;
		} else {
		    balance = AVLRight;
		    child->balance = AVLBalanced;
		}
		break;

	case  AVLBalanced:
		balance = AVLBalanced;
		child->balance = AVLBalanced;
		break;

	case AVLRight:
		if (whichSide == AVLRight) {
		    balance = AVLLeft;
		    child->balance = AVLBalanced;
		} else {
		    balance = AVLBalanced;
		    child->balance = AVLLeft;
		}
		break;

	default:
		assert(!"Bogus balance value");
    }
    grandchild->balance = AVLBalanced;
}

    template<class elementClass> void
AVLElement<elementClass>::remove(
    AVLTree<elementClass>	*fromTree)
{
    assert(fromTree);
    assert(balance == AVLRight || balance == AVLLeft || balance == AVLBalanced);

    fromTree->deletions++;

    if (left == NULL) {
	// The right child either doesn't exist or is a leaf (because of the AVL balance property)
        assert((!right && balance == AVLBalanced) || 
	       (balance == AVLRight && right->balance == AVLBalanced && right->right == NULL && right->left == NULL));
	if (right) {
	    right->parent = parent;
	}
	if (parent) {
	    if (parent->left == this) {
		parent->left = right;
	        parent->gotOneShorter(fromTree,AVLLeft);
	    } else {
		assert(parent->right == this);
		parent->right = right;
		parent->gotOneShorter(fromTree,AVLRight);
	    }
	} else {
	    assert(fromTree->tree == this);
	    fromTree->tree = right;
	}
    } else if (right == NULL) {
	// The left child must be a left because of the AVL balance property
        assert(left && balance == AVLLeft && left->balance == AVLBalanced && left->right == NULL && left->left == NULL);
	left->parent = parent;
	if (parent) {
	    if (parent->left == this) {
		parent->left = left;
	        parent->gotOneShorter(fromTree,AVLLeft);
	    } else {
		assert(parent->right == this);
		parent->right = left;
		parent->gotOneShorter(fromTree,AVLRight);
	    }
	} else {
	    assert(fromTree->tree == this);
	    fromTree->tree = left;
	}
    } else {
	// Find the symmetric successor and promote it.  The symmetric successor is the smallest element in the right
	// subtree; it's found by following all left links in the right subtree until we find a node with no left link.
	// That node may be promoted to the place of this without corrupting the binary tree ordering properties. (We could
	// just as easily use the symmetric predecessor by finding the largest element in the right subtree, but there's
	// no point.)

	AVLElement *successorCandidate = right;
	while (successorCandidate->left) {
	    successorCandidate = successorCandidate->left;
	}

	AVLElement *shorterRoot;
	AVLBalance shorterSide;
	if (successorCandidate->parent->left == successorCandidate) {
	    // We need to promote the successor's child (if any) to its position, then
	    // promote it to our position.
	    shorterRoot = successorCandidate->parent;
	    shorterSide = AVLLeft;
	    successorCandidate->parent->left = successorCandidate->right;
	    if (successorCandidate->right) {
		successorCandidate->right->parent = successorCandidate->parent;
	    }
	    
	    successorCandidate->right = right;
	    successorCandidate->left = left;
	    successorCandidate->balance = balance;
	    successorCandidate->right->parent = successorCandidate;
	    successorCandidate->left->parent = successorCandidate;
	    if (parent) {
		if (parent->left == this) {
		    parent->left = successorCandidate;
		} else {
		    assert(parent->right == this);
		    parent->right = successorCandidate;
		}
	    } else {
		assert(fromTree->tree == this);
		fromTree->tree = successorCandidate;
	    }
	    successorCandidate->parent = parent;
	} else {
	    // The successor was our child, just directly promote it.
	    assert(successorCandidate->parent == this);
	    if (parent) {
	        if (parent->right == this) {
		    parent->right = successorCandidate;
	        } else {
		    assert(parent->left == this);
		    parent->left = successorCandidate;
	    	}
	    } else {
	 	assert(fromTree->tree == this);
		fromTree->tree = successorCandidate;
	    }
	    successorCandidate->parent = parent;
	    successorCandidate->left = left;
	    if (left) {
		left->parent = successorCandidate;
	    }
	    // We just made our right subtree shorter.
	    successorCandidate->balance = balance;
	    shorterRoot = successorCandidate;
	    shorterSide = AVLRight;
	}
	if (shorterRoot) {
	    shorterRoot->gotOneShorter(fromTree,shorterSide);
	}
    }

    balance = AVLNew;
    left = right = parent = NULL;
    element = NULL;
//    fromTree->check();
}

    template<class elementClass> void
AVLElement<elementClass>::gotOneShorter(
    AVLTree<elementClass>	*tree,
    AVLBalance			 whichSide)

{
    assert(whichSide == AVLLeft || whichSide == AVLRight);

    if (balance == AVLBalanced) {
	// We've just shrunk one subttree, but our depth has stayed the same.
	// Reset our balance indicator and punt.
	if (whichSide == AVLRight) {
	    balance = AVLLeft;
	} else {
	    balance = AVLRight;
	}
	return;
    } else if (balance == whichSide) {
	// We just shrunk our heavy side; set our balance to neutral and recurse up the tree
	balance = AVLBalanced;
	if (parent) {
	    if (parent->right == this) {
		parent->gotOneShorter(tree,AVLRight);
	    } else {
		assert(parent->left == this);
		parent->gotOneShorter(tree,AVLLeft);
	    }
	} // else we were the root; we're done
	return;
    } else {
	// We've just gone out of balance.  Figure out a rotation to do.  This is almost like having added a
	// node to the opposide side, except that the opposite side might be balanced.
	AVLBalance heavySide;
	AVLElement *heavyChild;
	AVLElement *replacement;
	if (whichSide == AVLRight) {
	    heavySide = AVLLeft;
	    heavyChild = left;
	} else {
	    heavySide = AVLRight;
	    heavyChild = right;
	}
	assert(heavyChild);
	if (heavyChild->balance == heavySide) {
	    // Typical single rotation case
	    singleRotate(tree,heavyChild,heavySide);
	    replacement = heavyChild;
	} else if (heavyChild->balance == whichSide) {
	    // Typical double rotation case
	    AVLElement *grandchild;
	    if (heavySide == AVLRight) {
		grandchild = heavyChild->left;
	    } else {
		grandchild = heavyChild->right;
	    }
	    doubleRotate(tree,heavyChild,grandchild,heavySide);
	    replacement = grandchild;
	} else {
	    assert(heavyChild->balance == AVLBalanced);
	    singleRotate(tree,heavyChild,heavySide);
	    // singleRotate has incorrectly set the balances; reset them
	    balance = heavySide;
	    heavyChild->balance = whichSide;
	    // Overall depth hasn't changed; we're done.
	    return;
	}

        // NB: we have now changed position in the tree, so parent, right & left have changed!
	if (!replacement->parent) {
	    // We just promoted our replacement to the root; we be done
	    return;
	}
	if (replacement->parent->right == replacement) {
	    replacement->parent->gotOneShorter(tree,AVLRight);
	} else {
	    assert(replacement->parent->left == replacement);
	    replacement->parent->gotOneShorter(tree,AVLLeft);
	}
	
	
    }
}

    template<class elementClass> int
AVLElement<elementClass>::inTree(void)
{
    return(balance != AVLNew);
}

    template <class elementClass> int
AVLElement<elementClass>::operator<=(
    AVLElement<elementClass>		*peer)
{
    return(*element <= peer->element);
}

    template <class elementClass> int
AVLElement<elementClass>::operator<(
    AVLElement<elementClass>		*peer)
{
    return(*element < peer->element);
}

    template <class elementClass> int
AVLElement<elementClass>::operator==(
    AVLElement<elementClass>		*peer)
{
    return(*element == peer->element);
}

    template <class elementClass> int
AVLElement<elementClass>::operator>=(
    AVLElement<elementClass>		*peer)
{
    return(*element >= peer->element);
}

    template <class elementClass> int
AVLElement<elementClass>::operator>(
    AVLElement<elementClass>		*peer)
{
    return(*element > peer->element);
}

    template <class elementClass> BOOLEAN
AVLTree<elementClass>::insert(
    elementClass	*element)
{
	if (NULL == avlElementPool) {
		return FALSE;
	}

    assert(element);
    AVLElement<elementClass> *avlElement = (AVLElement<elementClass> *)avlElementPool->allocate();
	if (NULL == avlElement) {
		return FALSE;
	}

    avlElement->initialize();
    avlElement->insert(this,element);

	return TRUE;
}

    template <class elementClass> void
AVLTree<elementClass>::remove(
    elementClass	*element)
{
   assert(element);
   AVLElement<elementClass> *candidate = tree->findFirstLessThanOrEqualTo(element);
   assert(candidate && *candidate->element == element);
   candidate->remove(this);
   assert(avlElementPool);	// if this isn't true, then we could never have had a successful insert
   avlElementPool->free((void *)candidate);
}

    template <class elementClass> void
AVLElement<elementClass>::initialize(void)
{
    balance = AVLNew;
    left = right = parent = NULL;
    element = NULL;
}

    template <class elementClass> void
AVLTree<elementClass>::dumpPoolStats(void)
{
	if (NULL == avlElementPool) {
		DbgPrint("Unable to allocate avlElementPool; this AVL tree is essentially useless\n");
	} else {
	    DbgPrint("AVLTree AVLElement pool: %d allocations, %d frees, %d news, objectSize %d\n",
			avlElementPool->numAllocations(),
			avlElementPool->numFrees(),
			avlElementPool->numNews(),
			avlElementPool->getObjectSize());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\sisbkup\pool.h ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	pool.h

Abstract:

	Fixed size memory allocator headers.

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/


struct PoolEntry;
struct PoolBlob;

class Pool {
public:
			 Pool(
			    unsigned		 		 objectSize,
			    void * (*allocator)(unsigned) 	= NULL,
			    unsigned				 blobSize = 16334,	// a little under 16K
			    void (*destructor)(void *) 		= NULL);

			 Pool(
			    unsigned		 		 objectSize,
			    void * (*allocator)(void));

			~Pool(void);

    void		 preAllocate(
			    unsigned		 n);

    void		*allocate(void);

    void		 free(
			    void		*object);

    unsigned		 numAllocations(void);

    unsigned		 numFrees(void);

    unsigned		 numNews(void);

    unsigned		 getObjectSize(void);

private:

    PoolEntry		*getEntry(void);

    void		 releaseEntry(
			    PoolEntry		*entry);

    void		 allocateMoreObjects(void);

    unsigned		 objectSize;
    void *(*countAllocator)(unsigned);
    void *(*singleAllocator)(void);
    void  (*destructor)(void *);
    struct PoolEntry	*entries;		// PoolEntries with vaid data attached to them
    struct PoolEntry	*freeEntries;		// PoolEntries without valid data attached to them
    struct PoolBlob	*entriesBlobHead;	// The head of the blob list for PoolEntries
    unsigned		 entriesPerBlob;	// How many entries in an entry blob
    struct PoolBlob	*objectsBlobHead;	// The head of the blob list for the allocated objects
    unsigned		 objectsPerBlob;	// How many objects in an object blob

    unsigned		 allocations;
    unsigned		 frees;
    unsigned		 news;

    unsigned		 numFree;		// Current size of free list
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\sisbkup\pool.cpp ===
/*++

Copyright (c) 1993-1999	Microsoft Corporation

Module Name:

	pool.cpp

Abstract:

	Fixed size memory allocator.

Author:

	Bill Bolosky		[bolosky]		1993

Revision History:

--*/

#include "sibp.h"


struct PoolEntry {
    void		*object;
    struct PoolEntry	*next;
};

struct PoolBlob {
    struct PoolBlob	*next;
    void		*data;
};

Pool::Pool(
    unsigned		 objectSize,
    void *(*allocator)(unsigned),
    unsigned		 blobSize,
    void (*destructor)(void *))
{
    assert(objectSize > 0);

    assert(!destructor || allocator);	// Can't have a destructor without an allocator.  Allocator w/o destructor leaks objects on pool destruct.

    this->countAllocator = allocator;
    this->singleAllocator = NULL;
    this->destructor = destructor;
    this->objectSize = objectSize;
    entries = NULL;
    freeEntries = NULL;
    entriesBlobHead = NULL;
    objectsBlobHead = NULL;

    entriesPerBlob = blobSize / sizeof(PoolEntry);
    assert(entriesPerBlob > 0);

    objectsPerBlob = blobSize / objectSize;
    if (!objectsPerBlob) {
	objectsPerBlob = 1;
    }

    allocations = 0;
    frees = 0;
    news = 0;

    numFree = 0;
}


// This version of the pool constructor uses the old kind of allocator function that only returns one object.  Object blobs have one object,
// and the blob size for entry blobs is smaller so that we have finer grain memory allocation.
Pool::Pool(
    unsigned		 objectSize,
    void *(*allocator)(void))
{
    assert(objectSize > 0);

    assert(!destructor || allocator);	// Can't have a destructor without an allocator; allocator w/o destructor leaks objects on pool destruct

    this->singleAllocator = allocator;
    this->countAllocator = NULL;
    this->destructor = NULL;
    this->objectSize = objectSize;
    entries = NULL;
    freeEntries = NULL;
    entriesBlobHead = NULL;
    objectsBlobHead = NULL;

    unsigned blobSize = 1024 - 50;	// Our default allocation size; we leave the 50 byte headroom for the underlying allocator

    entriesPerBlob = blobSize / sizeof(PoolEntry);
    assert(entriesPerBlob > 0);

    objectsPerBlob = 1;

    allocations = 0;
    frees = 0;
    news = 0;

    numFree = 0;
}

Pool::~Pool(void)
{
    // Just delete the blob lists.  All objects that have been allocated from this pool will be destroyed.
    
    while (entriesBlobHead) {
	PoolBlob *blob = entriesBlobHead;
	assert(blob->data);
	delete [] blob->data;
	entriesBlobHead = blob->next;
	delete blob;
    }

    while (objectsBlobHead) {
	PoolBlob *blob = objectsBlobHead;
	assert(blob->data);
	if (destructor) {
	    (*destructor)(blob->data);
	} else if (!singleAllocator && !countAllocator) {
	    delete [] blob->data;
	} // else leak the objects
	objectsBlobHead = blob->next;
	delete blob;
    }

}

    void
Pool::allocateMoreObjects(void)
{
    assert(objectsPerBlob);

    PoolBlob *blob = new PoolBlob;
    if (!blob) {
	return;
    }

    if (countAllocator) {
	blob->data = (*countAllocator)(objectsPerBlob);
    } else if (singleAllocator) {
	assert(objectsPerBlob == 1);
	blob->data = (*singleAllocator)();
    } else {
	blob->data = (void *)new char[objectSize * objectsPerBlob];
    }

    if (!blob->data) {
	delete blob;
	return;
    }

    blob->next = objectsBlobHead;
    objectsBlobHead = blob;

    // Now put them on the free list.

    for (unsigned i = 0; i < objectsPerBlob; i++) {
        PoolEntry *entry = getEntry();
	if (!entry) {
	    return;		// This is kinda bogus, because it might leave some allocated objects unreachable.
	}
	entry->object = (void *)(((char *)blob->data) + i * objectSize);
	entry->next = entries;
	entries = entry;
    }

    news += objectsPerBlob;
    numFree += objectsPerBlob;
}


// Allocate entries until the free list is of size n (or until an allocation fails).
    void
Pool::preAllocate(
    unsigned		 n)
{
    assert(n);

    while (numFree < n) {
	unsigned oldNumFree = numFree;
	allocateMoreObjects();
	if (oldNumFree == numFree) {
	    // We can't allocate more; punt
	    return;
	}
    }
}

    PoolEntry *
Pool::getEntry(void)
{
    PoolEntry *entry = NULL;
    if (freeEntries) {
	entry = freeEntries;
	freeEntries = entry->next;
	assert(entry->object == NULL);
    } else {
	// Allocate a new entry blob and fill it in.
	PoolBlob *blob = new PoolBlob;
	if (blob) {
	    PoolEntry *blobEntries = new PoolEntry[entriesPerBlob];
	    if (blobEntries) {
		blob->data = (void *)blobEntries;
		// Release all of the newly allocated entries except the first one, which we'll return.
		for (unsigned i = 1; i < entriesPerBlob; i++) {
		    releaseEntry(&blobEntries[i]);
		}
		entry = &blobEntries[0];

		// Stick the new blob on the entries blob list.
		blob->next = entriesBlobHead;
		entriesBlobHead = blob;
	    } else {
		// Give up; we couldn't get memory
		delete blob;
	    }
	}
    }
    return(entry);
}

    void
Pool::releaseEntry(
    PoolEntry 		*entry)
{
    assert(entry);
    entry->object = NULL;
    entry->next = freeEntries;
    freeEntries = entry;
}

    void *
Pool::allocate(void)
{
    allocations++;

    assert((numFree == 0) == (entries == NULL));

    if (!entries) {
	allocateMoreObjects();
    }

    if (entries) {
	// We've got something
	struct PoolEntry *thisEntry = entries;
	entries = entries->next;
	void *object = thisEntry->object;

	assert(object);

	releaseEntry(thisEntry);

	assert(numFree);
	numFree--;

	return(object);
    } else {
	// Coudn't allocate more, we're out of memory.
	assert(numFree == 0);
	return NULL;
    }
}

    void
Pool::free(
    void		*object)
{
    assert(object);

    frees++;

    // No way to assert that this is the right kind (size) of object...

    // Get a PoolEntry.
    struct PoolEntry *entry = getEntry();
    if (!entry) {
	// We couldn't get an entry, so we can't add this object to the free list.  Leak it.
	return;
    }

    numFree++;

    entry->object = object;
    entry->next = entries;
    entries = entry;
}

    unsigned
Pool::numAllocations(void)
{
    return(allocations);
}

    unsigned
Pool::numFrees(void)
{
    return(frees);
}

    unsigned
Pool::numNews(void)
{
    return(news);
}

    unsigned
Pool::getObjectSize(void)
{
    return(objectSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\sisbkup\sisbkup.cpp ===
/*++

Copyright (c) 1998-1999	Microsoft Corporation

Module Name:

	sisbackup.cpp

Abstract:

	The SIS Backup dll.

Author:

	Bill Bolosky		[bolosky]		March 1998

Revision History:

--*/


#include "sibp.h"

BOOLEAN
NonSISEnabledVolume(
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreStructure)
/*++

Routine Description:

	Figure out if restoreStructure represents a SIS enabled volume.
	First, we check to see if we've already made the check, in which
	case we return the value we already stored.  If not, then we
	open a root handle, and send down a mal-formed SIS_COPYFILE request.
	If we get back ERROR_INVALID_FUNCTION then it's not SIS enabled.  If
	we get back	ERROR_INVALID_PARAMETER, then it's a SIS-enabled volume.
	If we get back anything else, then we can't prove it's not SIS enabled,
	and we just retry the next time we're asked.

	Caller must hold the mutex in the restore volume structure.

Arguments:

	restoreStructure - A pointer to the restore structure representing
		the volume to check.

Return Value:

	Returns TRUE if this is not a SIS-enabled volume, FALSE if it is or
	if it can't be determined.
--*/
{
	if (restoreStructure->checkedForSISEnabledVolume) {
		return !restoreStructure->isSISEnabledVolume;
	}

	HANDLE volumeRootHandle;
	PWCHAR volumeRootName;

	//
	// Allocate space for a string containing the volume root name including the trailing
	// backslash.  It will be two (wide) characters longer than restoreStructure->volumeRoot
	// because of the backslash and null terminator.
	//
	volumeRootName = (PWCHAR) malloc ((wcslen(restoreStructure->volumeRoot) + 2) * sizeof(WCHAR));

	if (NULL == volumeRootName) {
		//
		// Guess we can't check, just assume it's OK.
		//
#if		DBG
		DbgPrint("SISBkup: NonSISEnabledVolume: unable to allocate space for volume root name\n");
#endif	// DBG
		return FALSE;
	}

	wcscpy(volumeRootName,restoreStructure->volumeRoot);
	wcscat(volumeRootName,L"\\");

	volumeRootHandle = CreateFileW(
						volumeRootName,
						0,													// don't need any access for this check
						FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
						NULL,												// security attributes
						OPEN_EXISTING,
						FILE_FLAG_BACKUP_SEMANTICS,							// needed to open a directory
						NULL);												// hTemplateFile


	free(volumeRootName);
	volumeRootName = NULL;

	if (INVALID_HANDLE_VALUE == volumeRootHandle) {
		return FALSE;
	}

	//
	// Send a malformed FSCTL_SIS_COPYFILE down on the handle we just opened.
	//
	DWORD bytesReturned;
	BOOL worked = DeviceIoControl(
						volumeRootHandle,
						FSCTL_SIS_COPYFILE,
						NULL,					// input buffer (this is a malformed request, after all)
						0,						// i.b. size
						NULL,					// output buffer
						0,						// o.b. size
						&bytesReturned,
						NULL);					// lap

	CloseHandle(volumeRootHandle);

	if (worked) {
		//
		// This is bizarre!
		//

#if		DBG
		DbgPrint("SISBkup: malformed FSCTL_SIS_COPYFILE worked!\n");
#endif	// DBG

		return FALSE;
	}

	if (GetLastError() == ERROR_INVALID_FUNCTION) {
		//
		// No one recognized the copyfile request, or SIS decided that
		// this isn't a SIS enabled volume.  Say no.
		//
		restoreStructure->checkedForSISEnabledVolume = TRUE;
		restoreStructure->isSISEnabledVolume = FALSE;

		return TRUE;
	}

	if (GetLastError() == ERROR_INVALID_PARAMETER) {
		//
		// This means that SIS saw the request and thinks this is
		// a SIS enabled volume.  Say so.
		//

		restoreStructure->checkedForSISEnabledVolume = TRUE;
		restoreStructure->isSISEnabledVolume = TRUE;

		return FALSE;
	}

	//
	// Else, it's some weird error.  We can't prove it's not a SIS volume.
	//

#if		DBG
	DbgPrint("SISBkup: got unexpected error from SIS_FSCTL_COPYFILE, %d\n",GetLastError());
#endif	// DBG
			

	return FALSE;
}

VOID
SipComputeChecksum(
	IN PVOID							buffer,
	IN ULONG							size,
	IN OUT PLONGLONG					checksum)
/*++

Routine Description:

	Compute a checksum for a buffer.  We use the "131 hash," which
	work by keeping a 64 bit running total, and for each 32 bits of
	data multiplying the 64 bits by 131 and adding in the next 32
	bits.  Must be called at PASSIVE_LEVEL, and all aruments
	may be pagable.

Arguments:

	buffer - pointer to the data to be checksummed

	size - size of the data to be checksummed

	checksum - pointer to large integer to receive the checksum.  This
		may be within the buffer, and SipComputeChecksum guarantees that
		the initial value will be used in computing the checksum.

Return Value:

	Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
	LONGLONG runningTotal;
	PULONG ptr = (PULONG)buffer;
	ULONG bytesRemaining = size;

	runningTotal = *checksum;

	while (bytesRemaining >= sizeof(*ptr)) {
		runningTotal = runningTotal * 131 + *ptr;
		bytesRemaining -= sizeof(*ptr);
		ptr++;
	}

	if (bytesRemaining > 0) {
		ULONG extra;

		ASSERT(bytesRemaining < sizeof (ULONG));
		extra = 0;
		RtlMoveMemory(&extra, ptr, bytesRemaining);
		
		runningTotal = runningTotal * 131 + extra;
	}

	*checksum = runningTotal;
}


void
TryOpeningFile(
	PWCHAR			fileName)
{
	HANDLE		fileHandle;

	fileHandle = CreateFileW(
					fileName,
					GENERIC_READ,
					FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
					NULL,					// security attributes
					OPEN_EXISTING,
					FILE_FLAG_BACKUP_SEMANTICS,
					NULL);					// template file

	if (INVALID_HANDLE_VALUE != fileHandle) {
		CloseHandle(fileHandle);
	}
}

LONG
CsidCompare(
	IN PCSID				id1,
	IN PCSID				id2)
{
	PLONGLONG keyValue1 = (PLONGLONG)id1;
	PLONGLONG keyValue2 = keyValue1 + 1;
	PLONGLONG nodeValue1 = (PLONGLONG)id2;
	PLONGLONG nodeValue2 = nodeValue1 + 1;

	if (*keyValue1 < *nodeValue1) {
		return -1;
	} else if (*keyValue1 > *nodeValue1) {
		return 1;
	} else {
		if (*keyValue2 < *nodeValue2) {
			return -1;
		} else if (*keyValue2 > *nodeValue2) {
			return 1;
		} else {
			return 0;
		}
	}
}

NTSTATUS
FilenameFromCSid(
	IN PCSID						CSid,
	IN PWCHAR						volumeRoot,
	OUT PWCHAR						*fileName)
{
	PWCHAR uuidString;
	RPC_STATUS status;

	*fileName = (PWCHAR)malloc(
						wcslen(volumeRoot) * sizeof(WCHAR)
						+ SIS_CSDIR_STRING_SIZE
						+ INDEX_MAX_NUMERIC_STRING_LENGTH
						+ sizeof(WCHAR));

	if (NULL == *fileName) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(*fileName,volumeRoot);
	wcscat(*fileName,SIS_CSDIR_STRING);

	status = UuidToStringW(CSid,(unsigned short **)&uuidString);
	if (RPC_S_OK != status) {
		free(*fileName);
		*fileName = NULL;
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscat(*fileName,uuidString);
	wcscat(*fileName,L".sis");

	RpcStringFreeW((unsigned short **)&uuidString);

	return STATUS_SUCCESS;
}

NTSTATUS
CSidFromFilename(
	IN PWCHAR						FileName,
	OUT PCSID						CSid)
{
#define	UUID_STRING_MAX_LENGTH	100// Should get this length from somewhere better...

	PWCHAR		trailingSlash;
	PWCHAR		dot;
	WCHAR		uuid[UUID_STRING_MAX_LENGTH];	
	DWORD		uuidChars = 0;


	trailingSlash = wcsrchr(FileName, '\\');

	if (NULL == trailingSlash) {
		//
		// Assume that it's just the CS file without the directory name, etc.
		//
		trailingSlash = FileName - 1;
	}

	dot = wcsrchr(FileName, '.');
	if (NULL != dot) {
		uuidChars = (DWORD)(dot - (trailingSlash + 1));
	}

	if ((uuidChars <= 0) || (uuidChars >= UUID_STRING_MAX_LENGTH)) {

		//
		// Something's bogus about the filename.  Give up.
		//
		return STATUS_OBJECT_NAME_INVALID;
	}

	memcpy(uuid,trailingSlash+1,uuidChars * sizeof(WCHAR));
	uuid[uuidChars] = 0;

	if (RPC_S_OK != UuidFromStringW((unsigned short *)uuid,CSid)) {
		return STATUS_OBJECT_NAME_INVALID;
	}

	return STATUS_SUCCESS;
}

NTSTATUS
SisCreateBackupStructureI(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisBackupStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup)
{
	PSIB_BACKUP_VOLUME_STRUCTURE	backupVolumeStructure;

	backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)malloc(sizeof(SIB_BACKUP_VOLUME_STRUCTURE));

	if (NULL == backupVolumeStructure) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	backupVolumeStructure->linkTree = new AVLTree<BackupFileEntry>;

	if (NULL == backupVolumeStructure->linkTree) {
		free(backupVolumeStructure);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Allocate space for our private copy of the volume root name, being sure to leave space for
	// the terminating NULL.
	//
	backupVolumeStructure->volumeRoot = (PWCHAR)malloc((wcslen(volumeRoot) + 1) * sizeof(WCHAR));
	if (NULL == backupVolumeStructure->volumeRoot) {
		delete backupVolumeStructure->linkTree;
		free(backupVolumeStructure);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(backupVolumeStructure->volumeRoot, volumeRoot);

	//
	// Allocate space for the common store root pathname that we return, being sure
	// to leave room for the terminating NULL.
	//
	*commonStoreRootPathname = (PWCHAR) malloc(SIS_CSDIR_STRING_SIZE + (wcslen(volumeRoot) + 1) * sizeof(WCHAR));
	if (NULL == *commonStoreRootPathname) {
		free(backupVolumeStructure->volumeRoot);
		delete backupVolumeStructure->linkTree;
		free(backupVolumeStructure);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(*commonStoreRootPathname,volumeRoot);
	wcscat(*commonStoreRootPathname,SIS_CSDIR_STRING);

	InitializeCriticalSection(backupVolumeStructure->criticalSection);

	*countOfCommonStoreFilesToBackup = 0;
	*commonStoreFilesToBackup = NULL;
	*sisBackupStructure = backupVolumeStructure;

	return STATUS_SUCCESS;

}

NTSTATUS
SisCSFilesToBackupForLinkI(
	IN PVOID						sisBackupStructure,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	IN PVOID						thisFileContext						OPTIONAL,
	OUT PVOID						*matchingFileContext 				OPTIONAL,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup)
{
	PREPARSE_DATA_BUFFER 			reparseDataBuffer = (PREPARSE_DATA_BUFFER)reparseData;
	PSI_REPARSE_BUFFER 				sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseDataBuffer->GenericReparseBuffer.DataBuffer;
	BackupFileEntry 				entry[1];
	BackupFileEntry 				*foundEntry, *newEntry;
	PSIB_BACKUP_VOLUME_STRUCTURE 	backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)sisBackupStructure;
	PVOID 							matchedContext = NULL;
	PWCHAR 							CSFileName[MAX_PATH];
	NTSTATUS						status;

	EnterCriticalSection(backupVolumeStructure->criticalSection);

	if (reparseDataSize != SIS_REPARSE_DATA_SIZE) {
		//
		// It's the wrong size to contain a SIS reparse buffer, so we don't
		// want to add any CS files based on it.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	if (IO_REPARSE_TAG_SIS != reparseDataBuffer->ReparseTag ||
		sizeof(SI_REPARSE_BUFFER) != reparseDataBuffer->ReparseDataLength) {
		//
		// The size or tag is wrong.  Ignore it.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	if ((SIS_REPARSE_BUFFER_FORMAT_VERSION != sisReparseBuffer->ReparsePointFormatVersion) &&
		(4 != sisReparseBuffer->ReparsePointFormatVersion)) {
		//
		// We don't understand this format SIS reparse point.  This is probably an
		// old dll version.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	//
	// The only thing we really care about is the CSIndex of the file.  See if we've
	// already backed up a file with a matching CSIndex by looking in the tree.
	//
	entry->CSid = sisReparseBuffer->CSid;
	
	foundEntry = backupVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);

	if ((NULL != foundEntry) && (*foundEntry == entry)) {
		//
		// We already returned the CS file that backs this link.  Return the caller's
		// context for that link.
		//
		matchedContext = foundEntry->callerContext;

		goto BackupNoCSFiles;
	}

	//
	// This is the first time we've seen this particular CS file, so back it up.
	//
	newEntry = new BackupFileEntry;
	if (NULL == newEntry) {
		LeaveCriticalSection(backupVolumeStructure->criticalSection);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	newEntry->callerContext = thisFileContext;
	newEntry->CSid = sisReparseBuffer->CSid;

	if (!backupVolumeStructure->linkTree->insert(newEntry)) {
		delete newEntry;

		LeaveCriticalSection(backupVolumeStructure->criticalSection);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	if (NULL != matchingFileContext) {
		*matchingFileContext = NULL;
	}
	*countOfCommonStoreFilesToBackup = 1;

	*commonStoreFilesToBackup = (PWCHAR *)malloc(sizeof(PWCHAR) * *countOfCommonStoreFilesToBackup);

	if (NULL == *commonStoreFilesToBackup) {
		backupVolumeStructure->linkTree->remove(newEntry);
		delete newEntry;
		*countOfCommonStoreFilesToBackup = 0;

		LeaveCriticalSection(backupVolumeStructure->criticalSection);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	status = FilenameFromCSid(
				&sisReparseBuffer->CSid,
				backupVolumeStructure->volumeRoot,
				&(*commonStoreFilesToBackup)[0]);
				
	LeaveCriticalSection(backupVolumeStructure->criticalSection);

	return STATUS_SUCCESS;

BackupNoCSFiles:

	if (NULL != matchingFileContext) {
		*matchingFileContext = matchedContext;
	}
	*countOfCommonStoreFilesToBackup = 0;
	*commonStoreFilesToBackup = NULL;

	LeaveCriticalSection(backupVolumeStructure->criticalSection);

	return STATUS_SUCCESS;

Error:
	
	if (NULL != matchingFileContext) {
		*matchingFileContext = matchedContext;
	}
	*countOfCommonStoreFilesToBackup = 0;
	*commonStoreFilesToBackup = NULL;

	LeaveCriticalSection(backupVolumeStructure->criticalSection);

	return status;
}

NTSTATUS
SisFreeBackupStructureI(
	IN PVOID						sisBackupStructure)
{
	PSIB_BACKUP_VOLUME_STRUCTURE backupVolumeStructure = (PSIB_BACKUP_VOLUME_STRUCTURE)sisBackupStructure;
	BackupFileEntry *entry;

	while (!backupVolumeStructure->linkTree->empty()) {
		entry = backupVolumeStructure->linkTree->findMin();

		assert(NULL != entry);

		backupVolumeStructure->linkTree->remove(entry);

		delete entry;
	}

	free(backupVolumeStructure->volumeRoot);
	delete backupVolumeStructure->linkTree;

	DeleteCriticalSection(backupVolumeStructure->criticalSection);

	free(backupVolumeStructure);

	return STATUS_SUCCESS;
}

NTSTATUS
SisCreateRestoreStructureI(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisRestoreStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore)
{
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreVolumeStructure;
	DWORD							sectorsPerCluster, freeClusters, totalClusters;

	restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)malloc(sizeof(SIB_RESTORE_VOLUME_STRUCTURE));

	if (NULL == restoreVolumeStructure) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	restoreVolumeStructure->linkTree = new AVLTree<RestoreFileEntry>;

	if (NULL == restoreVolumeStructure->linkTree) {
		free(restoreVolumeStructure);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Allocate space for our private copy of the volume root name, being sure to leave space for
	// the terminating NULL.
	//
	restoreVolumeStructure->volumeRoot = (PWCHAR)malloc((wcslen(volumeRoot) + 1) * sizeof(WCHAR));
	if (NULL == restoreVolumeStructure->volumeRoot) {
		delete restoreVolumeStructure->linkTree;
		free(restoreVolumeStructure);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(restoreVolumeStructure->volumeRoot, volumeRoot);

	//
	// Allocate space for the common store root pathname that we return, being sure
	// to leave room for the terminating NULL.
	//
	*commonStoreRootPathname = (PWCHAR) malloc(SIS_CSDIR_STRING_SIZE + (wcslen(volumeRoot) + 1) * sizeof(WCHAR));
	if (NULL == *commonStoreRootPathname) {
		free(restoreVolumeStructure->volumeRoot);
		delete restoreVolumeStructure->linkTree;
		free(restoreVolumeStructure);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(*commonStoreRootPathname,volumeRoot);
	wcscat(*commonStoreRootPathname,SIS_CSDIR_STRING);

	InitializeCriticalSection(restoreVolumeStructure->criticalSection);

	*countOfCommonStoreFilesToRestore = 0;
	*commonStoreFilesToRestore = NULL;

	if (!GetDiskFreeSpaceW(
			volumeRoot,
			&sectorsPerCluster,
			&restoreVolumeStructure->VolumeSectorSize,
			&freeClusters,
			&totalClusters)) {
		//
		// The call failed.  Just assume it's 512 bytes.
		//
		restoreVolumeStructure->VolumeSectorSize = 512;
	}

	restoreVolumeStructure->sector = (PSIS_BACKPOINTER)malloc(restoreVolumeStructure->VolumeSectorSize);
	if (NULL == restoreVolumeStructure->sector) {
		free(restoreVolumeStructure->volumeRoot);
		delete restoreVolumeStructure->linkTree;
		free(restoreVolumeStructure);

		free(*commonStoreRootPathname);
		*commonStoreRootPathname = NULL;

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	restoreVolumeStructure->alignedSectorBuffer = (PVOID)malloc(restoreVolumeStructure->VolumeSectorSize * 2);
	if (NULL == restoreVolumeStructure->alignedSectorBuffer) {
		free(restoreVolumeStructure->sector);

		free(restoreVolumeStructure->volumeRoot);
		delete restoreVolumeStructure->linkTree;
		free(restoreVolumeStructure);

		free(*commonStoreRootPathname);
		*commonStoreRootPathname = NULL;

		return STATUS_INSUFFICIENT_RESOURCES;
	}
	restoreVolumeStructure->alignedSector = (PVOID)((
			((UINT_PTR)restoreVolumeStructure->alignedSectorBuffer +
				restoreVolumeStructure->VolumeSectorSize) /
					restoreVolumeStructure->VolumeSectorSize) *
					restoreVolumeStructure->VolumeSectorSize);

	ASSERT(restoreVolumeStructure->alignedSector >= restoreVolumeStructure->alignedSectorBuffer);
	ASSERT((PCHAR)restoreVolumeStructure->alignedSectorBuffer + restoreVolumeStructure->VolumeSectorSize >= (PCHAR)restoreVolumeStructure->alignedSector);

	memset(restoreVolumeStructure->alignedSector,255,restoreVolumeStructure->VolumeSectorSize);

	*sisRestoreStructure = restoreVolumeStructure;

	return STATUS_SUCCESS;
}

NTSTATUS
SisFixValidDataLengthI(
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreVolumeStructure,
	IN HANDLE						restoredFileHandle)
{
#define	BIGGER_THAN_AN_ALLOCATION_REGION		(128 * 1024)	// should get this from somewhere else
	//
	// Figure out if we need to extend ValidDataLength.  We need to do this
	// if the final range of the file is unallocated.
	//
	FILE_STANDARD_INFORMATION		standardInfo[1];
	FILE_END_OF_FILE_INFORMATION	endOfFileInfo[1];
	FILE_ALLOCATED_RANGE_BUFFER		inArb[1];
	const unsigned					outArbSize = 10;
	FILE_ALLOCATED_RANGE_BUFFER		outArb[outArbSize];
	NTSTATUS						status;
	IO_STATUS_BLOCK					Iosb[1];
	DWORD							bytesReturned;
	LARGE_INTEGER					rangeToZero;
	FILE_BASIC_INFORMATION			basicInfo[1];
	BOOLEAN							basicInfoValid = FALSE;
	DWORD							nBytesWritten;
	unsigned						i;
	FILE_ZERO_DATA_INFORMATION		zeroInfo[1];
	LARGE_INTEGER					WriteOffset;

	status = NtQueryInformationFile(
				restoredFileHandle,
				Iosb,
				standardInfo,
				sizeof(FILE_STANDARD_INFORMATION),
				FileStandardInformation);
	if (!NT_SUCCESS(status)) {
#if		DBG
		DbgPrint("SisFixValidDataLength: unable to query standard info on link file, 0x%x\n",status);
#endif	// DBG
		return status;
	}
	ASSERT(STATUS_PENDING != status);
	endOfFileInfo->EndOfFile = standardInfo->EndOfFile;

	if (standardInfo->EndOfFile.QuadPart > BIGGER_THAN_AN_ALLOCATION_REGION) {
		rangeToZero.QuadPart = inArb->FileOffset.QuadPart = standardInfo->EndOfFile.QuadPart - BIGGER_THAN_AN_ALLOCATION_REGION;
		rangeToZero.QuadPart -= rangeToZero.QuadPart % BIGGER_THAN_AN_ALLOCATION_REGION;	// round it down.
	} else {
		rangeToZero.QuadPart = inArb->FileOffset.QuadPart = 0;
	}
	inArb->Length.QuadPart = MAXLONGLONG - inArb->FileOffset.QuadPart;

	if (!DeviceIoControl(
			restoredFileHandle,
			FSCTL_QUERY_ALLOCATED_RANGES,
			inArb,
			sizeof(FILE_ALLOCATED_RANGE_BUFFER),
			outArb,
			sizeof(FILE_ALLOCATED_RANGE_BUFFER) * outArbSize,
			&bytesReturned,
			NULL)) {						// lap
#if		DBG
		DbgPrint("SisFixValidDataLength: unable to query allocated ranges on link file, %d\n",GetLastError());
#endif	// DBG
		return STATUS_UNSUCCESSFUL;
	}

	ASSERT(bytesReturned / sizeof(FILE_ALLOCATED_RANGE_BUFFER) < outArbSize);	// this relies on knowledge about the minimum allocated range size
	ASSERT(bytesReturned % sizeof(FILE_ALLOCATED_RANGE_BUFFER) == 0);

	if (bytesReturned > 0) {
		unsigned lastElement = bytesReturned/sizeof(FILE_ALLOCATED_RANGE_BUFFER) - 1;
		ASSERT(lastElement < outArbSize);
		rangeToZero.QuadPart = outArb[lastElement].FileOffset.QuadPart + outArb[lastElement].Length.QuadPart;
	}

	status = NtQueryInformationFile(
				restoredFileHandle,
				Iosb,
				basicInfo,
				sizeof(FILE_BASIC_INFORMATION),
				FileBasicInformation);
	if (NT_SUCCESS(status)) {
		ASSERT(STATUS_PENDING != status);	// because we didn't open the file for overlapped.
		basicInfoValid = TRUE;
	} else {
#if		DBG
		DbgPrint("SisFixValidDataLength: unable to query basic info on link file, 0x%x\n",status);
#endif	// DBG
	}

	WriteOffset.QuadPart = ((standardInfo->EndOfFile.QuadPart +
							 restoreVolumeStructure->VolumeSectorSize +
							 BIGGER_THAN_AN_ALLOCATION_REGION) / restoreVolumeStructure->VolumeSectorSize) *
									restoreVolumeStructure->VolumeSectorSize;
	ASSERT(WriteOffset.QuadPart >= standardInfo->EndOfFile.QuadPart);
	ASSERT(standardInfo->EndOfFile.QuadPart + restoreVolumeStructure->VolumeSectorSize < WriteOffset.QuadPart);

	if ((WriteOffset.LowPart != SetFilePointer(
									restoredFileHandle,
									WriteOffset.LowPart,
									&WriteOffset.HighPart,
									FILE_BEGIN))
		|| (NO_ERROR != GetLastError())) {
#if		DBG
		DbgPrint("SisFixValidDataLength: unable to SetFilePointer, %d\n",GetLastError());
#endif	// DBG
		return STATUS_UNSUCCESSFUL;
	}

	if (!WriteFile(restoredFileHandle,
					restoreVolumeStructure->alignedSectorBuffer,
					restoreVolumeStructure->VolumeSectorSize,						// bytes to write
					&nBytesWritten,
					NULL)) {				// overlapped
#if		DBG
		DbgPrint("SisFixValidDataLength: unable to append a byte to advance ValidDataLength, %d\n",GetLastError());
#endif	// DBG
	}

	//
	// Truncate the file, erasing the sector we just wrote.
	//
	status = NtSetInformationFile(
				restoredFileHandle,
				Iosb,
				endOfFileInfo,
				sizeof(FILE_END_OF_FILE_INFORMATION),
				FileEndOfFileInformation);

	if (rangeToZero.QuadPart < standardInfo->EndOfFile.QuadPart) {
		//
		// Re-zero the end of the file in order to deallocate it.
		//
		zeroInfo->FileOffset = rangeToZero;
		zeroInfo->BeyondFinalZero.QuadPart = MAXLONGLONG;

		if (!DeviceIoControl(
				restoredFileHandle,
				FSCTL_SET_ZERO_DATA,
				zeroInfo,
				sizeof(FILE_ZERO_DATA_INFORMATION),
				NULL,								// output buffer
				0,									// o.b. size
				&bytesReturned,
				NULL)) {							// overlapped
#if		DBG
			DbgPrint("SisFixValidDataLength: unable to zero trailing portion of file, %d\n",GetLastError());
#endif	// DBG
		}
	}

#if		DBG
	if (!NT_SUCCESS(status)) {
		DbgPrint("SisFixValidDataLength: unable to truncate file after extending it to advance ValidDataLength, 0x%x\n",status);
	}
#endif	// DBG


	//
	// Reset the dates on the file.
	//
	status = NtSetInformationFile(
				restoredFileHandle,
				Iosb,
				basicInfo,
				sizeof(FILE_BASIC_INFORMATION),
				FileBasicInformation);
#if		DBG
	if (!NT_SUCCESS(status)) {
		DbgPrint("SisFixValidDataLength: unable to reset times after extending file to advance ValidDataLength, 0x%x\n",status);
	}
#endif	// DBG

	return status;
}


NTSTATUS
SisRestoredLinkI(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						restoredFileName,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore)
{
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
	PREPARSE_DATA_BUFFER 			reparseDataBuffer = (PREPARSE_DATA_BUFFER)reparseData;
	PSI_REPARSE_BUFFER 				sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseDataBuffer->GenericReparseBuffer.DataBuffer;
	RestoreFileEntry 				entry[1];
	RestoreFileEntry 				*foundEntry, *newEntry;
	PWCHAR							CSFileName = NULL;
	BOOLEAN							foundCSFile;
	HANDLE							fileHandle;
	BOOLEAN							openFile = TRUE;
	NTSTATUS						status;
	DWORD							bytesReturned;
	DWORD							fileAttributes;
	BOOLEAN							readonlyAttributeCleared = FALSE;

	EnterCriticalSection(restoreVolumeStructure->criticalSection);

	if (NonSISEnabledVolume(restoreVolumeStructure)) {
		//
		// This isn't a SIS enabled volume, so tell the user that.
		// There's no NT status code corresponding to ERROR_VOLUME_NOT_SIS_ENABLED,
		// so we set the win32 code and return STATUS_UNSUCCESSFUL, which makes
		// the wrapper function not change the win32 error.
		//

		SetLastError(ERROR_VOLUME_NOT_SIS_ENABLED);

		status = STATUS_UNSUCCESSFUL;
		goto Error;
	}

	//
	// Do consistency checks on the reparse point to see if we can understand it.
	//	

	if (reparseDataSize != SIS_REPARSE_DATA_SIZE) {
		//
		// It's the wrong size to contain a SIS reparse buffer, so we don't
		// want to restore any CS files based on it.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	if (IO_REPARSE_TAG_SIS != reparseDataBuffer->ReparseTag ||
		sizeof(SI_REPARSE_BUFFER) != reparseDataBuffer->ReparseDataLength) {
		//
		// The size or tag is wrong.  Ignore it.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	if ((SIS_REPARSE_BUFFER_FORMAT_VERSION != sisReparseBuffer->ReparsePointFormatVersion) &&
		(4 != sisReparseBuffer->ReparsePointFormatVersion)) {
		//
		// We don't understand this format SIS reparse point.  This is probably an
		// old dll version.
		//

		status = STATUS_INVALID_PARAMETER;
		goto Error;
	}

	//
	// The only thing we really care about is the CSid and checksum of the file.  See if we've
	// already returned a file with a matching CSid by looking in the tree.
	//
	entry->CSid = sisReparseBuffer->CSid;
	
	foundEntry = restoreVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);

	if ((NULL != foundEntry) && (*foundEntry == entry)) {
		//
		// We already returned the CS file that backs this link.  Enter the name of this file
		// on the linked list for this CS file.
		//

		PendingRestoredFile *restoredFile = new PendingRestoredFile;
		if (NULL == restoredFile) {
			LeaveCriticalSection(restoreVolumeStructure->criticalSection);

#if		DBG
			DbgPrint("couldn't allocate restored file\n");
#endif	// DBG

			return STATUS_INSUFFICIENT_RESOURCES;
		}

		restoredFile->fileName = (PWCHAR) malloc((wcslen(restoredFileName) + 1) * sizeof(WCHAR) );
		if (NULL == restoredFile->fileName) {
			delete restoredFile;

#if		DBG
			DbgPrint("couldn't allocate restored file filename\n");
#endif	// DBG
			LeaveCriticalSection(restoreVolumeStructure->criticalSection);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		wcscpy(restoredFile->fileName,restoredFileName);
		restoredFile->CSFileChecksum = sisReparseBuffer->CSChecksum;
		restoredFile->next = foundEntry->files;
		foundEntry->files = restoredFile;
		
		goto RestoreNoCSFiles;
	}

	//
	// This is the first time we've seen this particular CS file.  See if it still
	// exists in the \SIS Common Store directory.
	//

	status = FilenameFromCSid(&sisReparseBuffer->CSid,restoreVolumeStructure->volumeRoot,&CSFileName);

	if (!NT_SUCCESS(status)) {
		if (NULL != CSFileName) {
			free(CSFileName);
		}
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);
		return status;
	}

	fileHandle = CreateFileW(
					CSFileName,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if (INVALID_HANDLE_VALUE == fileHandle) {
		if (GetLastError() == ERROR_SHARING_VIOLATION) {
			//
			// The file exists, we just couldn't open it.
			//
			foundCSFile = TRUE;
		} else {
			foundCSFile = FALSE;
		}
	} else {
		foundCSFile = TRUE;
		CloseHandle(fileHandle);
	}

	if (foundCSFile) {
		//
		// We don't add it to the tree here, even though that might speed up things somewhat.
		// The reason is that someone could come along and delete all of the references to the
		// file (including the one that we just created) and then the backing file would go away.
		// If we'd entered it in the tree, and we try to restore a subsequent link to the file,
		// we'd not notice that the backing file was gone and would restore a dangling link.
		//

		openFile = FALSE;	// There's no need to open this file, since it's a good link.

		HANDLE restoredFileHandle = CreateFileW(
										restoredFileName,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
										NULL,
										OPEN_EXISTING,
										FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING|FILE_OPEN_REPARSE_POINT,
										NULL);

		if (INVALID_HANDLE_VALUE == restoredFileHandle) {
			fileAttributes = GetFileAttributesW(restoredFileName);

			if (fileAttributes & FILE_ATTRIBUTE_READONLY) {
				DWORD newFileAttributes = fileAttributes & ~FILE_ATTRIBUTE_READONLY;
				if (0 == newFileAttributes) {
					newFileAttributes = FILE_ATTRIBUTE_NORMAL;
				}

				if (!SetFileAttributesW(restoredFileName,newFileAttributes)) {
#if		DBG
					DbgPrint("sisbkup: SisRestoredLinkI: unable to reset read only attribute on link, %d\n",GetLastError());
#endif	DBG
				} else {
					readonlyAttributeCleared = TRUE;
				}

				//
				// Now that we've (tried to) cleared the read only attribute, re-try the file open.
				//
				restoredFileHandle = CreateFileW(
										restoredFileName,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
										NULL,
										OPEN_EXISTING,
										FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING|FILE_OPEN_REPARSE_POINT,
										NULL);
			}
		}

		if (INVALID_HANDLE_VALUE != restoredFileHandle) {
			
		} else {
#if		DBG
			DbgPrint("SisRestoredLinkI: Unable to open link file in order to fix ValidDataLength, %d\n",::GetLastError());
#endif	// DBG

			status = STATUS_UNSUCCESSFUL;	// This will leave the win32 error code undisturbed
			goto Error;
		}

		CHAR reparseBuffer[SIS_REPARSE_DATA_SIZE];
		
		if (!DeviceIoControl(
				restoredFileHandle,
				FSCTL_GET_REPARSE_POINT,
				0,
				NULL,
				reparseBuffer,
				SIS_REPARSE_DATA_SIZE,
				&bytesReturned,
				NULL)) {
#if		DBG
			DbgPrint("SisRestoredLinkI: Unable to get reparse point, %d\n",::GetLastError());
#endif	// DBG
			
			status = STATUS_UNSUCCESSFUL;	// This will leave the win32 error code undisturbed
			goto Error;
		}

		status = SisFixValidDataLengthI(restoreVolumeStructure,restoredFileHandle);


		if (!NT_SUCCESS(status)) {
#if		DBG
			DbgPrint("SisRestoredLink: unable to fix up valid data length, 0x%x, %d\n",status,::GetLastError());
#endif	// DBG
			CloseHandle(restoredFileHandle);
			goto Error;
		}

		//
		// Reset the reparse point, which has been destroyed by the last operation.
		//

		if (!DeviceIoControl(
				restoredFileHandle,
				FSCTL_SET_REPARSE_POINT,
				reparseData,
				reparseDataSize,
				NULL,
				0,
				&bytesReturned,
				NULL)) {
#if		DBG
			DbgPrint("SisRestoredLink: unable to reset reparse point, %d\n",::GetLastError());
#endif	// DBG
			CloseHandle(restoredFileHandle);
			status = STATUS_UNSUCCESSFUL;	// This will leave the win32 error code undisturbed

			goto Error;
		}

		CloseHandle(restoredFileHandle);

		if (readonlyAttributeCleared) {
			SetFileAttributesW(restoredFileName,fileAttributes);
			readonlyAttributeCleared = FALSE;
		}

		goto RestoreNoCSFiles;
	}

	//
	// It's not already in the common store directory.  Enter it in the tree and return it to
	// the user.
	//

	newEntry = new RestoreFileEntry;
	if (NULL == newEntry) {
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	newEntry->CSid = sisReparseBuffer->CSid;

	newEntry->files = new PendingRestoredFile;
	if (NULL == newEntry->files) {
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		delete newEntry;
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	newEntry->files->next = NULL;
	newEntry->files->fileName = (PWCHAR) malloc((wcslen(restoredFileName) + 1) * sizeof(WCHAR));
	newEntry->files->CSFileChecksum = sisReparseBuffer->CSChecksum;
	if (NULL == newEntry->files->fileName) {
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		delete newEntry->files;
		delete newEntry;

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(newEntry->files->fileName,restoredFileName);

	if (!restoreVolumeStructure->linkTree->insert(newEntry)) {
		*countOfCommonStoreFilesToRestore = 0;
		
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		delete newEntry->files;
		delete newEntry;		

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	*countOfCommonStoreFilesToRestore = 1;

	*commonStoreFilesToRestore = (PWCHAR *)malloc(sizeof(PWCHAR) * *countOfCommonStoreFilesToRestore);

	if (NULL == *commonStoreFilesToRestore) {
		restoreVolumeStructure->linkTree->remove(newEntry);
		*countOfCommonStoreFilesToRestore = 0;
		
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		delete newEntry->files;
		delete newEntry;

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	status = FilenameFromCSid(
				&sisReparseBuffer->CSid,
				restoreVolumeStructure->volumeRoot,
				&(*commonStoreFilesToRestore)[0]);

	if (!NT_SUCCESS(status)) {
		restoreVolumeStructure->linkTree->remove(newEntry);
		*countOfCommonStoreFilesToRestore = 0;
		
		LeaveCriticalSection(restoreVolumeStructure->criticalSection);

		free(*commonStoreFilesToRestore);

		delete newEntry->files;
		delete newEntry;

		return status;
	}
				
	if (openFile) {
		TryOpeningFile(restoredFileName);
	}

	LeaveCriticalSection(restoreVolumeStructure->criticalSection);

	return STATUS_SUCCESS;

RestoreNoCSFiles:

	*countOfCommonStoreFilesToRestore = 0;
	*commonStoreFilesToRestore = NULL;

	if (openFile) {
		TryOpeningFile(restoredFileName);
	}

	LeaveCriticalSection(restoreVolumeStructure->criticalSection);

	return STATUS_SUCCESS;

Error:

	*countOfCommonStoreFilesToRestore = 0;
	*commonStoreFilesToRestore = NULL;

	if (readonlyAttributeCleared) {
		SetFileAttributesW(restoredFileName,fileAttributes);
	}

	if (openFile) {
		TryOpeningFile(restoredFileName);
	}

	LeaveCriticalSection(restoreVolumeStructure->criticalSection);

	return status;
}

NTSTATUS
SisRestoredCommonStoreFileI(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						commonStoreFileName)
{
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
	HANDLE							fileHandle = INVALID_HANDLE_VALUE;
	NTSTATUS						status;
	DWORD							bytesRead, bytesWritten;
	LONGLONG						checksum;
	CSID							CSid;
	RestoreFileEntry 				entry[1];
	RestoreFileEntry 				*foundEntry, *newEntry;
	PWCHAR							BPStreamName = NULL;

	status = CSidFromFilename(commonStoreFileName,&CSid);

	if (!NT_SUCCESS(status)) {
		//
		// It was a bogus filename.  Punt.
		//

		return status;
	}

	BPStreamName = (PWCHAR) malloc((wcslen(commonStoreFileName) + 1) * sizeof(WCHAR) + BACKPOINTER_STREAM_NAME_SIZE);
	if (NULL == BPStreamName) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	wcscpy(BPStreamName, commonStoreFileName);
	wcscat(BPStreamName, BACKPOINTER_STREAM_NAME);

	//
	// We just need to reinitialize the backpointer stream for this file so that it looks like
	// it has no references.
	//

	EnterCriticalSection(restoreVolumeStructure->criticalSection);

	if (NonSISEnabledVolume(restoreVolumeStructure)) {
		//
		// This isn't a SIS enabled volume, so tell the user that.
		// There's no NT status code corresponding to ERROR_VOLUME_NOT_SIS_ENABLED,
		// so we set the win32 code and return STATUS_UNSUCCESSFUL, which makes
		// the wrapper function not change the win32 error.
		//

		SetLastError(ERROR_VOLUME_NOT_SIS_ENABLED);
		status = STATUS_UNSUCCESSFUL;
		goto Error;
	}

	//
	// Now open the file.
	//

	fileHandle = CreateFileW(
					BPStreamName,
					GENERIC_READ | GENERIC_WRITE,
					0,								// exclusive
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
					NULL);

	free(BPStreamName);
	BPStreamName = NULL;

	if (INVALID_HANDLE_VALUE == fileHandle) {
		status = STATUS_UNSUCCESSFUL;		// This will cause the C wrapper to not call SetLastError
#if		DBG
		DbgPrint("SisRestoredCommonStoreFile: unable to open common store file, %d\n",GetLastError());
#endif	// DBG
		goto Error;
	}

	//
	// Read in the first sector.
	//
	if (!ReadFile(
			fileHandle,
			restoreVolumeStructure->sector,
			restoreVolumeStructure->VolumeSectorSize,
			&bytesRead,
			NULL)) {

		status = STATUS_UNSUCCESSFUL;		// This will cause the C wrapper to not call SetLastError
#if		DBG
		DbgPrint("SisRestoredCommonStoreFile: Unable to read in first BP sector, %d\n",GetLastError());
#endif	// DBG
		goto Error;
	}

	if (bytesRead < sizeof(SIS_BACKPOINTER_STREAM_HEADER)) {

		status = STATUS_UNSUCCESSFUL;		// This will cause the C wrapper to not call SetLastError
		goto Error;
	}

#define	Header ((PSIS_BACKPOINTER_STREAM_HEADER)restoreVolumeStructure->sector)

	if ((BACKPOINTER_STREAM_FORMAT_VERSION != Header->FormatVersion) ||
		(BACKPOINTER_MAGIC != Header->Magic)) {
#undef	Header

#if		DBG
		DbgPrint("SisRectoredCommonStoreFile: restored CS file has bogus header format version/Magic\n");
#endif	// DBG
		
	} else {
		//
		// Fill in the backpointer portion of the sector with
		// null entries.
		//
		for (unsigned i = SIS_BACKPOINTER_RESERVED_ENTRIES;
			 i < (restoreVolumeStructure->VolumeSectorSize / sizeof(SIS_BACKPOINTER));
			 i++) {
			restoreVolumeStructure->sector[i].LinkFileIndex.QuadPart = MAXLONGLONG;
			restoreVolumeStructure->sector[i].LinkFileNtfsId.QuadPart = MAXLONGLONG;
		}

		//
		// Write out the new sector.
		//
		SetFilePointer(fileHandle,0,NULL,FILE_BEGIN);
	
		if (!WriteFile(
			fileHandle,
			restoreVolumeStructure->sector,
			restoreVolumeStructure->VolumeSectorSize,
			&bytesWritten,
			NULL)) {
#if		DBG	
			DbgPrint("SisRestoredCommonStoreFile: write failed %d\n",GetLastError());
#endif	// DBG
		}
	}

	//
	// Make the stream be exactly one sector long.
	//
	SetFilePointer(fileHandle,restoreVolumeStructure->VolumeSectorSize,NULL,FILE_BEGIN);
	SetEndOfFile(fileHandle);

	CloseHandle(fileHandle);
	fileHandle = INVALID_HANDLE_VALUE;

	//
	// Look up in the tree and find the files that we restored to this link.
	// Open them and rewrite their reparse points.
	//

	entry->CSid = CSid;

	foundEntry = restoreVolumeStructure->linkTree->findFirstLessThanOrEqualTo(entry);
	if ((NULL != foundEntry) && (*foundEntry == entry)) {
		//
		// We've got a match.  Cruise the list and set the reparse points on all of the
		// files.
		//


		while (NULL != foundEntry->files) {
			HANDLE					restoredFileHandle;
			PendingRestoredFile		*thisFile = foundEntry->files;
			DWORD					bytesReturned;
			DWORD					fileAttributes;
			BOOLEAN					readOnlyAttributeCleared = FALSE;

			restoredFileHandle = CreateFileW(
									thisFile->fileName,
									GENERIC_READ | GENERIC_WRITE,
									0,								// exclusive
									NULL,
									OPEN_EXISTING,
									FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING,
									NULL);

			if (INVALID_HANDLE_VALUE == restoredFileHandle) {
				//
				// Check the read only file attribute, and reset it if necessary.
				//
				fileAttributes = GetFileAttributesW(thisFile->fileName);
				if (fileAttributes & FILE_ATTRIBUTE_READONLY) {
					DWORD newFileAttributes = fileAttributes & ~FILE_ATTRIBUTE_READONLY;
					if (0 == newFileAttributes) {
						newFileAttributes = FILE_ATTRIBUTE_NORMAL;
					}
					if (!SetFileAttributesW(thisFile->fileName,newFileAttributes)) {
#if		DBG
						DbgPrint("sisbkup: unable to clear read only attribute on file %ws\n",thisFile->fileName);
#endif	// DBG
					}
					readOnlyAttributeCleared = TRUE;

					restoredFileHandle = CreateFileW(
											thisFile->fileName,
											GENERIC_READ | GENERIC_WRITE,
											0,								// exclusive
											NULL,
											OPEN_EXISTING,
											FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_NO_BUFFERING,
											NULL);

				}
			} 

			if (INVALID_HANDLE_VALUE != restoredFileHandle) {
				SisFixValidDataLengthI(restoreVolumeStructure, restoredFileHandle);
				
				//
				// Rewrite the reparse point.
				//
				CHAR reparseBuffer[SIS_REPARSE_DATA_SIZE];
				PSI_REPARSE_BUFFER sisReparseBuffer;
#define	reparseData ((PREPARSE_DATA_BUFFER)reparseBuffer)

				reparseData->ReparseTag = IO_REPARSE_TAG_SIS;
				reparseData->Reserved = 0xb010;		// ??
				reparseData->ReparseDataLength = sizeof(SI_REPARSE_BUFFER);

				sisReparseBuffer = (PSI_REPARSE_BUFFER)reparseData->GenericReparseBuffer.DataBuffer;

				sisReparseBuffer->ReparsePointFormatVersion = SIS_REPARSE_BUFFER_FORMAT_VERSION;
				sisReparseBuffer->Reserved = 0xb111b010;
				sisReparseBuffer->CSid = CSid;
				sisReparseBuffer->LinkIndex.QuadPart = 0;			// This just gets reset by the filter driver
			    sisReparseBuffer->LinkFileNtfsId.QuadPart = 0;		// This just gets reset by the filter driver
			    sisReparseBuffer->CSFileNtfsId.QuadPart	= 0;		// This just gets reset by the filter driver

				//
				// Use the CS file checksum that was read from the reparse point on the backup
				// tape.  We need this for security reasons, because otherwise a bogus backed up
				// link could suddenly become valid.
				//

				sisReparseBuffer->CSChecksum = thisFile->CSFileChecksum;

			    //
			    // Compute the checksum.
			    //
				sisReparseBuffer->Checksum.QuadPart = 0;
			    SipComputeChecksum(
				    sisReparseBuffer,
				    sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
				    &sisReparseBuffer->Checksum.QuadPart);

				//
				// Set the reparse point.
				//
				if (!DeviceIoControl(
						restoredFileHandle,
						FSCTL_SET_REPARSE_POINT,
						reparseBuffer,
						FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) +
							reparseData->ReparseDataLength,
						NULL,
						0,
						&bytesReturned,
						NULL)) {
#if		DBG
					DbgPrint("sisbackup: SisRestoredCommonStoreFile: set reparse point failed %d\n",GetLastError());
#endif	// DBG
				}

				CloseHandle(restoredFileHandle);
				
#undef	reparseData
			} else {
#if		DBG
				DbgPrint("sisbackup: unable to open link file for file %ws, %d\n",thisFile->fileName,GetLastError());
#endif	// DBG
			}

			if (readOnlyAttributeCleared) {
				if (!SetFileAttributesW(thisFile->fileName,fileAttributes)) {
#if		DBG
					DbgPrint("sisbackup: unable to reset read only attribute on %ws\n",thisFile->fileName);
#endif	// DBG
				}
			}

			foundEntry->files = thisFile->next;
			free(thisFile->fileName);
			delete thisFile;
		}

		restoreVolumeStructure->linkTree->remove(foundEntry);
		delete foundEntry;
	} else {
#if		DBG
		DbgPrint("restored common store file: didn't find tree match\n");
#endif	// DBG
	}


	LeaveCriticalSection(restoreVolumeStructure->criticalSection);

	return STATUS_SUCCESS;

Error:

	if (INVALID_HANDLE_VALUE != fileHandle) {
		CloseHandle(fileHandle);
	}

	LeaveCriticalSection(restoreVolumeStructure->criticalSection);

	return status;
}

NTSTATUS
SisFreeRestoreStructureI(
	IN PVOID						sisRestoreStructure)
{
	PSIB_RESTORE_VOLUME_STRUCTURE	restoreVolumeStructure = (PSIB_RESTORE_VOLUME_STRUCTURE)sisRestoreStructure;
	RestoreFileEntry *entry;

	//
	// Cruise the link tree and clean up any remaining file entries.
	//
	while (NULL != (entry = restoreVolumeStructure->linkTree->findMin())) {

		while (NULL != entry->files) {
			PendingRestoredFile *thisFile = entry->files;

			entry->files = thisFile->next;

			free(thisFile->fileName);
			delete thisFile;
		}

		restoreVolumeStructure->linkTree->remove(entry);
	}

	DeleteCriticalSection(restoreVolumeStructure->criticalSection);

	free(restoreVolumeStructure->sector);
	free(restoreVolumeStructure->alignedSectorBuffer);
    free(restoreVolumeStructure->volumeRoot);
	delete restoreVolumeStructure->linkTree;
	free(restoreVolumeStructure);

	return STATUS_SUCCESS;
}


extern "C" {

BOOL __stdcall
SisCreateBackupStructure(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisBackupStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup)
{
	NTSTATUS status;

	status = SisCreateBackupStructureI(
						volumeRoot,
						sisBackupStructure,
						commonStoreRootPathname,
						countOfCommonStoreFilesToBackup,
						commonStoreFilesToBackup);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}


BOOL __stdcall
SisCSFilesToBackupForLink(
	IN PVOID						sisBackupStructure,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	IN PVOID						thisFileContext						OPTIONAL,
	OUT PVOID						*matchingFileContext 				OPTIONAL,
	OUT PULONG						countOfCommonStoreFilesToBackup,
	OUT PWCHAR						**commonStoreFilesToBackup)
{
	NTSTATUS status;

	status = SisCSFilesToBackupForLinkI(
						sisBackupStructure,
						reparseData,
						reparseDataSize,
						thisFileContext,
						matchingFileContext,
						countOfCommonStoreFilesToBackup,
						commonStoreFilesToBackup);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

BOOL __stdcall
SisFreeBackupStructure(
	IN PVOID						sisBackupStructure)
{
	NTSTATUS status;

	status = SisFreeBackupStructureI(
							sisBackupStructure);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

BOOL __stdcall
SisCreateRestoreStructure(
	IN PWCHAR						volumeRoot,
	OUT PVOID						*sisRestoreStructure,
	OUT PWCHAR						*commonStoreRootPathname,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore)
{
	NTSTATUS status;

	status = SisCreateRestoreStructureI(
						volumeRoot,
						sisRestoreStructure,
						commonStoreRootPathname,
						countOfCommonStoreFilesToRestore,
						commonStoreFilesToRestore);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

BOOL __stdcall
SisRestoredLink(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						restoredFileName,
	IN PVOID						reparseData,
	IN ULONG						reparseDataSize,
	OUT PULONG						countOfCommonStoreFilesToRestore,
	OUT PWCHAR						**commonStoreFilesToRestore)
{
	NTSTATUS status;

	status = SisRestoredLinkI(
						sisRestoreStructure,
						restoredFileName,
						reparseData,
						reparseDataSize,
						countOfCommonStoreFilesToRestore,
						commonStoreFilesToRestore);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

BOOL __stdcall
SisRestoredCommonStoreFile(
	IN PVOID						sisRestoreStructure,
	IN PWCHAR						commonStoreFileName)
{
	NTSTATUS status;

	status =  SisRestoredCommonStoreFileI(
						sisRestoreStructure,
						commonStoreFileName);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

BOOL __stdcall
SisFreeRestoreStructure(
	IN PVOID						sisRestoreStructure)
{
	NTSTATUS status;

	status = SisFreeRestoreStructureI(
						sisRestoreStructure);

	if (STATUS_UNSUCCESSFUL != status) {
		SetLastError(RtlNtStatusToDosError(status));
	}
	return NT_SUCCESS(status);
}

VOID __stdcall
SisFreeAllocatedMemory(
	IN PVOID						allocatedSpace)
{
	if (NULL != allocatedSpace) {
		free(allocatedSpace);
	}
}

BOOL WINAPI DLLEntryPoint(HANDLE hDLL, DWORD dwReason, LPVOID lpReserved)
{
  return( TRUE );
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\sisbkup\sibp.h ===
/*++

Copyright (c) 1998	Microsoft Corporation

Module Name:

	sibp.h

Abstract:

	Internal headers for the SIS Backup dll.

Author:

	Bill Bolosky		[bolosky]		March 1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <rpc.h>

#include "assert.h"
#include "sisbkup.h"
#include "..\filter\sis.h"
#include "pool.h"
#include "avl.h"



LONG
CsidCompare(
	IN PCSID				id1,
	IN PCSID				id2);

class BackupFileEntry {
	public:
						BackupFileEntry(void) {}

						~BackupFileEntry(void) {}

    int					 operator<=(
					    BackupFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) <= 0);
					    }

    int					 operator<(
					    BackupFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) < 0);
					    }

    int					 operator==(
					    BackupFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) == 0);
					    }

    int					 operator>=(
					    BackupFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) >= 0);
					    }

    int					 operator>(
					    BackupFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) > 0);
					    }

	//
	// The index of the common store file.
	//
	CSID				CSid;

	PVOID				callerContext;
};

typedef struct _SIB_BACKUP_VOLUME_STRUCTURE {
	AVLTree<BackupFileEntry>					*linkTree;

	PWCHAR										volumeRoot;

	CRITICAL_SECTION							criticalSection[1];
} SIB_BACKUP_VOLUME_STRUCTURE, *PSIB_BACKUP_VOLUME_STRUCTURE;

struct PendingRestoredFile {
	PWCHAR								fileName;

	LONGLONG							CSFileChecksum;

	struct PendingRestoredFile			*next;
};


class RestoreFileEntry {
	public:
						RestoreFileEntry(void) {}

						~RestoreFileEntry(void) {}

    int					 operator<=(
					    RestoreFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) <= 0);
					    }

    int					 operator<(
					    RestoreFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) < 0);
					    }

    int					 operator==(
					    RestoreFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) == 0);
					    }

    int					 operator>=(
					    RestoreFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) >= 0);
					    }

    int					 operator>(
					    RestoreFileEntry		*peer)
					    {
							return(CsidCompare(&CSid,&peer->CSid) > 0);
					    }

	//
	// The index of the common store file.
	//
	CSID				CSid;

	//
	// The various files that have been restored that point at this CS file.
	//
	PendingRestoredFile	*files;

};

typedef struct _SIB_RESTORE_VOLUME_STRUCTURE {
	AVLTree<RestoreFileEntry>					*linkTree;

	PWCHAR										volumeRoot;

	CRITICAL_SECTION							criticalSection[1];

	//
	// The sector size for this volume.
	//
	ULONG				VolumeSectorSize;

	//
	// A sector buffer to hold the backpointer stream data.
	//
	PSIS_BACKPOINTER	sector;

	//
	// An aligned sector buffer to use in extending ValidDataLength.
	//
	PVOID				alignedSectorBuffer;
	PVOID				alignedSector;

	//
	// If we're restoring SIS links, we need to assure that this is
	// a SIS enabled volume.  We do this check only once we've restored
	// a link.
	//
	BOOLEAN				checkedForSISEnabledVolume;
	BOOLEAN				isSISEnabledVolume;

} SIB_RESTORE_VOLUME_STRUCTURE, *PSIB_RESTORE_VOLUME_STRUCTURE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\cf\cf.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cf.c


Abstract:

    This module implements a utlity that copies files using the
    Single Instance Store file system filter functionality.

Author:

    Scott Cutshall  [scottc]        8-July-1997

Revision History:

--*/

#include "cf.h"


//
//  We can have:   cf SrcPath DstPath {-o NtFileNameOfFileOnWhichToMakeTheCall}
//


#define	BUFF_SIZE 2048

void __cdecl
main(
    int argc,
    char **argv
    )

{
	NTSTATUS        Status;
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE          volHandle;
	UNICODE_STRING	srcFileName, dstFileName;
	UNICODE_STRING	srcDosFileName, dstDosFileName;
	UNICODE_STRING	callOnFileName;
	PSI_COPYFILE	copyFile;
	ULONG			NameBuffer[BUFF_SIZE];
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
	int i;

	copyFile = (PSI_COPYFILE) NameBuffer;

    if (argc != 3 && argc != 5)
	    Usage();

	if (argc == 5) {
		if (strcmp(argv[3],"-o")) {
			Usage();
		}
		
	}

    //
	// Convert the ansii names to unicode and place in the copyFile buffer.
    //

    RtlCreateUnicodeStringFromAsciiz( &srcDosFileName, argv[1] );
    RtlCreateUnicodeStringFromAsciiz( &dstDosFileName, argv[2] );

    RtlDosPathNameToNtPathName_U(
        srcDosFileName.Buffer,
        &srcFileName,
        NULL,
        NULL );

    RtlDosPathNameToNtPathName_U(
        dstDosFileName.Buffer,
        &dstFileName,
        NULL,
        NULL );

	copyFile->SourceFileNameLength = srcFileName.Length + sizeof(WCHAR);
	copyFile->DestinationFileNameLength = dstFileName.Length + sizeof(WCHAR);
	copyFile->Flags = COPYFILE_SIS_REPLACE;

	RtlCopyMemory(
		&copyFile->FileNameBuffer[0],
		srcFileName.Buffer,
		copyFile->SourceFileNameLength);

	RtlCopyMemory(
		&copyFile->FileNameBuffer[copyFile->SourceFileNameLength / sizeof(WCHAR)],
		dstFileName.Buffer,
		copyFile->DestinationFileNameLength);

#define	copyFileSize (FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +		\
					  copyFile->SourceFileNameLength +					\
					  copyFile->DestinationFileNameLength)

	if (argc == 3) {
		//
		// Get a handle to the source file's containing directory to pass into
		// FSCTL_SIS_COPYFILE,
		//

	    for (i = srcFileName.Length / sizeof(WCHAR) - 1;
			 i >= 0 && srcFileName.Buffer[i] != '\\';
			 --i)
			continue;

		srcFileName.Length = (USHORT)(i * sizeof(WCHAR));

	    InitializeObjectAttributes(
    	    &objectAttributes,
        	&srcFileName,
	        OBJ_CASE_INSENSITIVE,
    	    NULL,
        	NULL);
	} else {
		//
		// Get a handle to the NT file specified in argv[4] to send down the call on.
		//
		unsigned i;
		callOnFileName.MaximumLength = callOnFileName.Length = sizeof(WCHAR) * strlen(argv[4]);
		callOnFileName.Buffer = (PWCHAR)malloc(callOnFileName.MaximumLength);
		for (i = 0; i < strlen(argv[4]); i++) {
			callOnFileName.Buffer[i] = argv[4][i];
		}

	    InitializeObjectAttributes(
    	    &objectAttributes,
        	&callOnFileName,
	        OBJ_CASE_INSENSITIVE,
    	    NULL,
        	NULL);
	}

	Status = NtCreateFile(
                    &volHandle,
					GENERIC_READ,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    0,
					FILE_SHARE_READ|FILE_SHARE_WRITE,
					OPEN_EXISTING,
					0,
					NULL,
                    0);

	if (!NT_SUCCESS(Status)) {
		if (5 == argc) {
			fprintf(stderr, "Unable to open file, %.*ls (%x)\n",
					callOnFileName.Length / sizeof(WCHAR), callOnFileName.Buffer,  Status);
		} else {
			fprintf(stderr, "Unable to open directory, %.*ls (%x)\n",
					srcFileName.Length / sizeof(WCHAR), srcFileName.Buffer,  Status);
		}
		exit(1);
	}


    //
    //  Invoke the SIS CopyFile FsCtrl.
    //

    Status = NtFsControlFile(
                 volHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SIS_COPYFILE,
                 copyFile,		        // Input buffer
                 copyFileSize,			// Input buffer length
                 NULL,                  // Output buffer
                 0 );                   // Output buffer length

    if (NT_SUCCESS( Status )) {

        fprintf( stderr, "NtFsControlFile CopyFile succeeded\n" );

    } else {

        fprintf( stderr, "NtFsControlFile CopyFile failed %x\n", Status );

    }

    exit (0);

}  //  main


void
Usage( void )
{
    fprintf( stderr, "\n" );
    fprintf( stderr, "Usage: cf Path1 Path2 {-o NtFileNameOfFileOnWhichToMakeTheCall}\n" );
    fprintf( stderr, "       cf copies Path1 to Path2 using SIS links.\n" );
	fprintf( stderr, "          if -o is specified, opens that file to send down the call on,\n");
	fprintf( stderr, "          rather than using the directory containing the source file.\n");
    exit(1);

} // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\rpget\rpget.h ===
/*++

	Header file for reparse point stress test

	Modification History:

		08/18/97	anandn		created

--*/


//
// include system headers..
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <winioctl.h>
#include <winbase.h>
#include <wtypes.h>
#include <winver.h>

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define THREAD __declspec(thread)	//thread local storage


typedef ULONG			TAG;	// define a datatype for Tag

#define NO_GLE			ERROR_SUCCESS

#define NO_TAG_SET		IO_REPARSE_TAG_RESERVED_ZERO

#define FILE_CLOSED		INVALID_HANDLE_VALUE	


//
// #def all our constants..
//


#define FIRST_USER_TAG	(0x02) // first user tag

#define MAX_USER_TAG	((TAG) 0xFFFF) // max tag settable by user

#define MAX_ULONGLONG	(~(ULONGLONG) 0)

#define MAX_ULONG		(~(ULONG) 0)

#define PAGE_SIZE		(0x1000)	// system page size

#define LINE_LENGTH		80		// 80 chars in a line
			
#define FS_NAME_SIZE	20		// max size for a FS name.eg:"NTFS","FAT" etc..

#define DRV_NAME_SIZE	2		// size of drive name string eg: "c:" 

#define MAX_DRIVES		26			// maximum number of drive letters

#define MAX_DELAY		50			// maximum delay time in msecs



#define MAX_TEST_FILES (1000)
#define MIN_TEST_FILES (50)

#define CHAR_CODES	"."

//
// number of check values for data verification..
//

#define NUM_CHECK_BYTES	5


//
// logging options
//

#define LOG_OPTIONS 	( TLS_REFRESH | TLS_SEV2 | TLS_WARN | TLS_PASS | \
						  TLS_MONITOR | TLS_VARIATION |	\
						  TLS_SYSTEM  | TLS_INFO )

#define LOG_INFO(m)		LogMessage( m, TLS_INFO, NO_GLE );
#define LOG_WARN(m)		LogMessage( m, TLS_WARN, NO_GLE );
#define LOG_SEV2(m)		LogMessage( m, TLS_SEV2, NO_GLE );

#define LOG_INFO_GLE(m)	LogMessage( m, TLS_INFO, GetLastError() );
#define LOG_WARN_GLE(m)	LogMessage( m, TLS_WARN, GetLastError() );
#define LOG_SEV2_GLE(m)	LogMessage( m, TLS_SEV2, GetLastError() );



//
// SZE returns the number of elements in an array 
//

#define SZE(a) (sizeof(a)/sizeof(a[0]))


//
// Loops over each value in table passed in 
// WARNING: Assumption here is x is root name of both global array and 
// index variable. i.e. if x is foo, ifoo is index and gafoo is gloabl 
// array being looped over 
//

#define FOR_EACH(x) for ( i##x = 0; i##x < SZE(ga##x); i##x++ )


//
// exception code raised for sev2 logging
//

#define EXCEPTION_CODE_SEV2	(0xE0000002) 


//
// raise a severity2 exception
//

#define RAISE_EXCEPTION_SEV2	RaiseException( EXCEPTION_CODE_SEV2, 0,0,0);



//
// free a pointer if not null
//

#define FREE(ptr)		if (NULL != (ptr)) { \
							free( ptr );	 \
							ptr = NULL;		 \
						}

//
// few sleep times..
//

#define FIVE_SECS	5000
#define TWO_SECS	2000
#define ONE_SECS	1000


enum TESTFILE_STATUS { FILE_LOCKED, FILE_FREE };
enum TESTFILE_TYPE   { ITS_A_FILE, ITS_A_DIR };

//
// the Options struct is filled from command line arguments 
//

typedef struct {

	CHAR szProgramName[MAX_PATH + 1];	// name of test program (ie argv[0])
	CHAR Drive;							// drive to test
	CHAR szTestDir[MAX_PATH + 1];		// test dir to use on specified drive

	DWORD dwMaxTestFiles;
	DWORD dwMinTestFiles;
	
} OPTIONS, *POPTIONS;


//
// Central struc that holds info for a test file..
//

struct TESTFILE_INFO_NODE {
	WORD wFileStatus;
	HANDLE hFile;
	TAG RPTag;
	USHORT usDataBuffSize;
	BYTE CheckBytes[NUM_CHECK_BYTES];
	struct TESTFILE_INFO_NODE* pNext;
	WCHAR FileName[1];
};


typedef struct TESTFILE_INFO_NODE  TESTFILE_INFO_NODE;

typedef TESTFILE_INFO_NODE* PTESTFILE_INFO_NODE;





//
// function prototypes
//


VOID 
ParseArgs(INT argc, CHAR* argv[], POPTIONS pOptions);						


VOID
PrintUsage( CHAR szProgramName[], CHAR szErrorString[] );


VOID
Initialize( OPTIONS Options );


VOID 
Stress( OPTIONS Options );


VOID
Cleanup( OPTIONS Options );


VOID
ExceptionHandler( DWORD dwExceptionCode );


HANDLE
GetNewHandleIfClosed( PTESTFILE_INFO_NODE pNode );


DWORD WINAPI
CreateFileThread( LPVOID lpvThreadParam );


DWORD WINAPI
CloseOrDeleteFileThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPSetThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPGetThread( LPVOID lpvThreadParam );


DWORD WINAPI
RPDelThread( LPVOID lpvThreadParam );


BOOL 
RPSet(PTESTFILE_INFO_NODE pNode, 
	  TAG RPTag, PUCHAR pDataBuff, USHORT usDataBuffSize);

BOOL
RPGet(CHAR szFileName[], BYTE **ppOutBuff); 


BOOL
RPDel( PTESTFILE_INFO_NODE pNode );


VOID
SelectAndLockRandomNode( TESTFILE_INFO_NODE **ppNode, CHAR s[] );


VOID
ReleaseNodeLock( PTESTFILE_INFO_NODE pNode );


BOOL
AddToTestFileList( HANDLE hFile, CHAR szFileName[] );


BOOL
DeleteFromTestFileList( PTESTFILE_INFO_NODE pNode );


TAG
GetTagToSet( VOID );


VOID
DumpBuff( PBYTE pData, WORD wSize );

VOID 
GenerateTempFileName( LPSTR lpFileName );


HANDLE
CreateRPFile( CHAR szFileName[] );


HANDLE 
OpenHandleToVolume(CHAR szVolName[]);


BOOL
IsFileSysNtfs(CHAR szVolRoot[]);


VOID
StartLogSession(CHAR szProgName[]);


VOID 
EndLogSession(DWORD dwExitCode);


ULONG 
HiPart(ULONGLONG n);


ULONG 
LoPart(ULONGLONG n);


VOID
LogMessage( CHAR szLogMsg[], ULONG dwLevel, DWORD gle );


VOID 
LogAtLevel( CHAR szOutMsg[], ULONG dwLevel );



VOID
GenerateReparsePoints( VOID );


VOID
SetReparsePoint( CHAR szFileName[],
				 TAG Tag,
				 UCHAR szData[] );

TAG
GetTagToSet( VOID );


VOID
GetReparsePoint( VOID );


VOID
DeleteReparsePoint( VOID );


VOID 
PrintError(char szWhatFailed[], int flag);


HANDLE 
RPOpen (LPSTR szFileName, LPSTR szOption );


VOID
SzToWsz ( OUT WCHAR *Unicode,
          IN char *Ansi ) ;


VOID
WszToSz ( OUT char *Ansi,
		  IN WCHAR *Unicode );


NTSTATUS OpenObject (
                    WCHAR *pwszFile,
                    ULONG CreateOptions,
                    ULONG DesiredAccess,
                    ULONG ShareAccess,
                    ULONG CreateDisposition,
                    IO_STATUS_BLOCK *IoStatusBlock,
                    HANDLE *ObjectHandle);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\cf\cf.h ===
#include <stdlib.h>     //  Has exit()
#include <stdio.h>      //  Has printf() and related ...

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>    //  Needs to come after the NT header files.  Has DWORD
#include <winbase.h>

//
//  Private #defines
//

#define SHARE_ALL              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define GetFileAttributeError  0xFFFFFFFF

#define ATTRIBUTE_TYPE DWORD    //  ULONG, really

#define GET_ATTRIBUTES(FileName, Attributes) Attributes = GetFileAttributes(FileName)

#define IF_GET_ATTR_FAILS(FileName, Attributes) GET_ATTRIBUTES(FileName, Attributes); if (Attributes == GetFileAttributeError)

//
//  Global flags shared throughout.
//
//  ParseArgs is the place where they get set and verified for mutual
//  consistency.
//

BOOLEAN  fAlternateCreateDefault = FALSE;
BOOLEAN  fCopy     = FALSE;
BOOLEAN  fCreate   = FALSE;
BOOLEAN  fDelete   = FALSE;
BOOLEAN  fDisplay  = FALSE;
BOOLEAN  fModify   = FALSE;
BOOLEAN  fRename   = FALSE;
BOOLEAN  fVerbose  = FALSE;
BOOLEAN  fVVerbose = FALSE;



//
//  Signatures of internal routines.
//


void
ParseArgs(
    int argc,
    char *argv[]
    );


void
Usage(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\chksis\chksis.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chksis.cpp

Abstract:

    This module implements a utility that examines all SIS files on a volume
    looking for errors and optionally displaying file information.

Author:

    Scott Cutshall          Fall, 1997

--*/

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>

using namespace std;

bool verbose = false;

typedef LONGLONG INDEX;

//
// Convert a 32bit value to a base 36 representation in
// the caller provided string.
//

void IntegerToBase36String(ULONG val, string& s) {

    //
    // Maximum number of "digits" in a base 36 representation of a 32 bit
    // value is 7.
    //

    char rs[8];
    ULONG v = val;

    rs[7] = 0;

    for (int i = 7; i == 7 || v != 0;) {

        ULONG d = v % 36;
        v = v / 36;

        --i;
        if (d < 10)
            rs[i] = '0' + d;
        else
            rs[i] = 'a' + d - 10;

    }

    s.assign(&rs[i]);

}


//
// A put operator for INDEX types.  Implemented as IndexToSISFileName().
//

#ifndef _WIN64
ostream& operator<<(ostream& out, INDEX& index)
{

    unsigned long lo = static_cast<unsigned long> (index);
    long hi = static_cast<long> (index >> 32);
    string s("1234567");

    IntegerToBase36String(lo, s);

    out << s << '.';

    IntegerToBase36String(hi, s);

    out << s;

    return out;
}
#endif

//
// A common store file object.  Holds the file's index, name, internal refcount,
// external refcount, and identity operations.
//

class CsFile {

public:

    CsFile(INDEX i = 0, int r = 0, string n = "") :
        index(i), internalRefCount(r), name(n), externalRefCount(0) {}

    void Validate() {
        if (internalRefCount != externalRefCount) {
            cout << name << " Reference Count: " << internalRefCount;
            cout << ".  " << externalRefCount << " external references identified." << endl;
        }
    }

    friend bool operator<(const CsFile& a, const CsFile& b) {
        return a.index < b.index;
    }

    friend bool operator>(const CsFile& a, const CsFile& b) {
        return a.index > b.index;
    }

    friend bool operator==(const CsFile& a, const CsFile& b) {
        return a.index == b.index;
    }

    void IncRefCount() {
        ++externalRefCount;
    }

    void display() {
        cout << "CS Index: " << (INDEX) index << "   Ref Count: " << internalRefCount << endl;
    }

private:

    //
    // Index of this entry's file.
    //

    INDEX   index;

    //
    // The file name.  This is somewhat redundant with the index (ie. the
    // name is derived from the index), so it isn't absolutely necessary.
    //

    string  name;

    //
    // Reference count read from the file's refcount stream.
    //

    int     internalRefCount;

    //
    // Number of valid references to this file detected during scan.
    //

    int     externalRefCount;

};


//
// The SIS Common Store object.  Holds all common store file objects, and
// validation and query operations.
//

class CommonStore {

public:

    CommonStore(int vsize = 0) : maxIndex(0) {
        if (vsize > 0) csFiles.resize(vsize);
    }

    //
    // Method to create a common store on a volume.
    //

    bool Create(string& Volume);

    //
    // Validate the common store directory and initialize this class.
    //

    void Validate(string& Volume);

    //
    // Validate the reference counts. Assumes all external references
    // have been identified.
    //

    void ValidateRefCounts();

    //
    // All indices must be less than maxIndex;
    //

    bool ValidateIndex(INDEX i) {
        return i <= maxIndex;
    }

    //
    // Lookup a common store index and add a ref if found.
    //

    CsFile *Query(INDEX index);

private:

    bool FileNameToIndex(string& fileName, INDEX& csIndex);

    //
    // Index from the MaxIndex file.
    //

    INDEX   maxIndex;

    //
    // Database of content files.  All CS files are examined and added to the database,
    // sorted, and subsequently used during the SIS link scan.
    //

    vector<CsFile> csFiles;

};

//
// Various SIS file and directory names.
//

const string  maxIndexFileName("MaxIndex");
const string  logFileName("LogFile");
const string  csDir("\\SIS Common Store\\");

//
// Create a common store directory on a volume.
//
// todo:
//      - Verify that the volume is ntfs.
//      - Verify that the SIS driver is loaded.
//

bool
CommonStore::Create(string& Volume)
{
    const string CommonStoreDir = Volume + "\\SIS Common Store";
    USHORT comp = COMPRESSION_FORMAT_DEFAULT;
    DWORD transferCount;
    bool rc;

    if (! CreateDirectory(CommonStoreDir.c_str(), NULL) ) {

        cout << "Cannot create Common Store directory, " << GetLastError() << endl;
        return false;

    }

    if (verbose)
        cout << CommonStoreDir << " created" << endl;

    //
    // Open the Common Store directory and enable compression.
    //

    HANDLE CSDirHandle = CreateFile(
                            CommonStoreDir.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if (CSDirHandle == INVALID_HANDLE_VALUE) {

        cout << "Can't open Common Store directory." << endl;
        rc = false;

    } else {

        rc = 0 != DeviceIoControl(
                     CSDirHandle,
                     FSCTL_SET_COMPRESSION,
                     &comp,
                     sizeof(comp),
                     NULL,
                     0,
                     &transferCount,
                     NULL);

        CloseHandle(CSDirHandle);

    }

    if (!rc)
        cout << "Cannot enable compression on Common Store directory, " << GetLastError() << endl;

    //
    // Chdir into the common store directory.
    //

    if (SetCurrentDirectory(CommonStoreDir.c_str()) == 0) {

        //
        // Unable to chdir into the common store.
        //

        cout << "\"\\SIS Common Store\" directory not found" << endl;

        return false;

    }

    rc = true;

    //
    // Create the MaxIndex file.
    //

    HANDLE hMaxIndex = CreateFile(
                            maxIndexFileName.c_str(),
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (hMaxIndex == INVALID_HANDLE_VALUE) {

        cout << "Can't create \"\\SIS Common Store\\MaxIndex\"" << endl;

        rc = false;

    } else {

        DWORD bytesWritten;

        maxIndex = 1;

        if (! WriteFile(
                  hMaxIndex,
                  &maxIndex,
                  sizeof maxIndex,
                  &bytesWritten,
                  NULL) ||
            (bytesWritten < sizeof maxIndex)) {

            cout << "Can't write MaxIndex, " << GetLastError() << endl;

            rc = false;

        } else {

            CloseHandle(hMaxIndex);

            if (verbose)
                cout << "MaxIndex: " << (INDEX) maxIndex << endl;

            rc = true;
        }

    }

    return rc;

}


//
// Validate the common store directory.
//

void
CommonStore::Validate(string& Volume)
{

    WIN32_FIND_DATA findData;
    HANDLE findHandle;
    const string fileNameMatchAny = "*";
    const string CommonStoreDir = Volume + "\\SIS Common Store";

    cout << "Checking Common Store" << endl;

    //
    // Chdir into the common store directory.
    //

    if (SetCurrentDirectory(CommonStoreDir.c_str()) == 0) {

        //
        // Unable to chdir into the common store.
        //

        cout << "\"\\SIS Common Store\" directory not found" << endl;

        return;

    }

    //
    // Validate and read the contents of the MaxIndex file.
    //

    HANDLE hMaxIndex = CreateFile(
                            maxIndexFileName.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (hMaxIndex == INVALID_HANDLE_VALUE) {

        cout << "Can't open \"\\SIS Common Store\\MaxIndex\"" << endl;

    } else {

        DWORD bytesRead;

        if (! ReadFile(
                  hMaxIndex,
                  &maxIndex,
                  sizeof maxIndex,
                  &bytesRead,
                  NULL)) {

            cout << "Can't read MaxIndex, " << GetLastError() << endl;

        }

        if (bytesRead < sizeof maxIndex) {

            cout << "Invalid MaxIndex" << endl;

        }

        CloseHandle(hMaxIndex);

        if (verbose)
            cout << "MaxIndex: " << (INDEX) maxIndex << endl;
    }

    //
    // Enumerate and validate all files in the common store directory.
    // Save the file name and reference count for later lookup when validating
    // the SIS link files.
    //

    findHandle = FindFirstFile( fileNameMatchAny.c_str(), &findData );

    if (INVALID_HANDLE_VALUE == findHandle) {

        cout << CommonStoreDir << " is empty." << endl;
        return;

    }

    do {

        ULONG refCount;
        string fileName;

        fileName = findData.cFileName;

        if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            // Ignore . and ..
            //

            if ( findData.cFileName[0] == '.' ) {

                if (( findData.cFileName[1] == 0 ) ||
                    (( findData.cFileName[1] == '.' ) && ( findData.cFileName[2] == 0 )))

                    continue;

            }

            cout << "Common Store directory skipped: " << fileName << endl;
            continue;

        }

        if ((_stricmp(maxIndexFileName.c_str(),fileName.c_str()) == 0) ||
            (_stricmp(logFileName.c_str(),fileName.c_str()) == 0)) {

            //
            // Skip the MaxIndex and LogFile files.
            //

            continue;

        }

        //
        // Verify that:
        //    - the file name is a valid index.
        //    - this is a normal file (ie. not a reparse point).
        //    - there is a refcount stream of proper format.
        //

        INDEX csIndex;

        refCount = 0;

        if (! FileNameToIndex(fileName, csIndex)) {

            cout << "Unknown file in Common Store: " << fileName << endl;
            continue;

        }

        if (! ValidateIndex(csIndex)) {

            cout << "Invalid CSIndex: " << fileName << endl;

        }

        if ( IO_REPARSE_TAG_SIS == findData.dwReserved0 ) {

            cout << "SIS link found in Common Store: " << fileName << endl;

        } else {

            //
            // Read in the refcount;
            //

            string refName(fileName + ":sisrefs$");

            HANDLE hRefCount = CreateFile(
                                    refName.c_str(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

            if (hRefCount == INVALID_HANDLE_VALUE) {

                cout << "Can't open ref count stream, " << refName << ", " << GetLastError() << endl;

            } else {

                DWORD bytesRead;

                if (! ReadFile(
                          hRefCount,
                          &refCount,
                          sizeof refCount,
                          &bytesRead,
                          NULL)) {

                    cout << "Can't read " << refName << ", " << GetLastError() << endl;

                }

                if (bytesRead < sizeof refCount) {

                    cout << "Invalid ref count in " << refName << endl;

                }

                CloseHandle(hRefCount);

            }

            CsFile csFile(csIndex, refCount, fileName);

            //
            // Add this file to our database.  Expand the database if necessary.
            //

            if (0 == csFiles.capacity())
                csFiles.reserve(csFiles.size() + 200);

            csFiles.push_back(csFile);

            if (verbose)
                csFile.display();
        }

    } while ( FindNextFile( findHandle, &findData ) );

    FindClose( findHandle );


    //
    // Sort the database for subsequent lookups.
    //

    sort(csFiles.begin(), csFiles.end());
}


//
// Validate the reference counts. Assumes all external references
// have been identified.
//

void
CommonStore::ValidateRefCounts() {

    vector<CsFile>::iterator p;

    for (p = csFiles.begin(); p != csFiles.end(); ++p) {

        p->Validate();

    }
}

//
// Lookup the specified index in the common store.
//

CsFile *
CommonStore::Query(INDEX index)
{
    CsFile key(index);

    //
    // Use a binary search to lookup the index.
    //

    vector<CsFile>::iterator p = lower_bound(csFiles.begin(), csFiles.end(), key);

    if (p == csFiles.end() || *p > key)
        return NULL;                        // not found

    return p;
}


//
// Extract the index from a common store file name.
//

bool
CommonStore::FileNameToIndex(string& fileName, INDEX& csIndex)
{
    char c;
    const size_t len = fileName.length();
    ULONG hi = 0, lo = 0;

    //
    // Format: "_low.high", where low.high is the base 36 representation of
    // the index value.
    //

    size_t i = 0;

    if (len < 2 || fileName.at(i) != '_') {

        cout << "Invalid Common Store file name: " << fileName << endl;

        return false;

    }

    while (++i < len && (c = fileName.at(i)) != '.') {

        INDEX d;

        if (c >= '0' && c <= '9') {

            d = c - '0';

        } else if (c >= 'a' && c <= 'z') {

            d = c - 'a' + 10;

        } else {

            cout << "Invalid Common Store file name: " << fileName << endl;

            return false;

        }

        lo = lo * 36 + d;

    }

    if (c != '.') {

        cout << "Invalid Common Store file name: " << fileName << endl;

        return false;

    }

    while (++i < len) {

        INDEX d;

        c = fileName.at(i);

        if (c >= '0' && c <= '9') {

            d = c - '0';

        } else if (c >= 'a' && c <= 'z') {

            d = c - 'a' + 10;

        } else {

            cout << "Invalid Common Store file name: " << fileName << endl;

            return false;

        }

        hi = hi * 36 + d;

    }

    csIndex = (INDEX) hi << 32 | lo;

    return true;

}

class LinkFile {

public:

    LinkFile(INDEX i = 0, LONGLONG id = 0, INDEX cs = 0, int v = 0, string n = 0) :
      index(i), NtfsId(id), csIndex(cs), version(v), name(n) {}

    friend bool operator<(const LinkFile& a, const LinkFile& b) {
        return a.index < b.index;
    }

    friend bool operator>(const LinkFile& a, const LinkFile& b) {
        return a.index > b.index;
    }

    friend bool operator==(const LinkFile& a, const LinkFile& b) {
        return a.index == b.index;
    }

    INDEX& LinkIndex() {
        return index;
    }

    string& FileName() {
        return name;
    }

    void display() {
        cout << "Link: " << name <<
                "   CS Index: " << csIndex <<
                "   Link Index:" << index <<
                "   Id:" << NtfsId <<
                "   Version: " << version << endl;
    }

private:

    //
    // This file's Ntfs Id.
    //

    LONGLONG NtfsId;

    //
    // Link index associated with this file.
    //

    INDEX   index;

    //
    // The common store file (index) associated with this link.
    //

    INDEX   csIndex;

    //
    // The revision number of this link file.
    //

    ULONG   version;

    //
    // The fully qualified file name.
    //

    string  name;
};

//
// The SIS Volume object.
//

class SISVolume {

public:

    //
    // Validate all SIS files on the volume.
    //

    void Validate(string& Volume);

    //
    // Set up a volume for use with SIS.
    //

    bool Create(string& Volume);

private:

    //
    // The bits that are actually in a SIS reparse point.
    //
    //
    // Version 1
    //
    typedef struct _SI_REPARSE_BUFFER_V1 {
        //
        // A version number so that we can change the reparse point format
        // and still properly handle old ones.  This structure describes
        // version 1.
        //
        ULONG                           ReparsePointFormatVersion;

        //
        // The index of the common store file.
        //
        INDEX                           CSIndex;

        //
        // The index of this link file.
        //
        INDEX                          LinkIndex;

    } SI_REPARSE_BUFFER_V1, *PSI_REPARSE_BUFFER_V1;

    //
    // Version 2
    //
    typedef struct _SI_REPARSE_BUFFER_V2 {
	    //
	    // A version number so that we can change the reparse point format
	    // and still properly handle old ones.  This structure describes
	    // version 2.
	    //
	    ULONG							ReparsePointFormatVersion;

	    //
	    // The index of the common store file.
	    //
	    INDEX							CSIndex;

	    //
	    // The index of this link file.
	    //
	    INDEX							LinkIndex;

        //
        // The file ID of the link file.
        //
        LONGLONG                        LinkFileNtfsId;

        //
        // A "131 hash" checksum of this structure.
        // N.B.  Must be last.
        //
        LARGE_INTEGER                   Checksum;

    } SI_REPARSE_BUFFER_V2, *PSI_REPARSE_BUFFER_V2;

    //
    // The bits that are actually in a SIS reparse point.  Version 3.
    //
    typedef struct _SI_REPARSE_BUFFER {

    	//
    	// A version number so that we can change the reparse point format
    	// and still properly handle old ones.  This structure describes
    	// version 1.
    	//
    	ULONG							ReparsePointFormatVersion;

    	//
    	// The index of the common store file.
    	//
    	INDEX							CSIndex;

    	//
    	// The index of this link file.
    	//
    	INDEX							LinkIndex;

        //
        // The file ID of the link file.
        //
        LONGLONG                        LinkFileNtfsId;

        //
        // The file ID of the common store file.
        //
        LONGLONG                        CSFileNtfsId;

        //
        // A "131 hash" checksum of this structure.
        // N.B.  Must be last.
        //
        LARGE_INTEGER                   Checksum;

    } SI_REPARSE_BUFFER, *PSI_REPARSE_BUFFER;

    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION_1			1
    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION_2			2
    #define	SIS_REPARSE_BUFFER_FORMAT_VERSION			3
    #define	SIS_MAX_REPARSE_DATA_VALUE_LENGTH (sizeof(SI_REPARSE_BUFFER))
    #define SIS_REPARSE_DATA_SIZE (sizeof(REPARSE_DATA_BUFFER)+SIS_MAX_REPARSE_DATA_VALUE_LENGTH)

    void Walk(string& dirName);

    bool GetLinkInfo(string& fileName, SI_REPARSE_BUFFER& linkInfo);

    void ComputeChecksum(PVOID buffer, ULONG size, PLARGE_INTEGER checksum);

    void ValidateLink();

    //
    // The common store object associated with this volume.
    //

    CommonStore cs;

    //
    // Database of link files.  The link files are recorded to verify that
    // duplicate link indices do not occur, and also to be able to identify
    // all link files associated with a particular common store file.
    //

    vector<LinkFile> linkFiles;
};


void
SISVolume::Validate(string& Volume)
{
    string ntVolume("\\\\.\\" + Volume);

    //
    // See if we can open the volume.
    //

    HANDLE hVolume = CreateFile(
                         ntVolume.c_str(),
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hVolume == INVALID_HANDLE_VALUE) {

        cout << "Can't open " << Volume << endl;

        return;

    } else {

        CloseHandle(hVolume);

    }

    //
    // Check the common store directory and it's files.  This will also build
    // a database of common store files that will be used to validate the link
    // files.
    //

    cs.Validate(Volume);

    cout << "Checking Link Files" << endl;

    //
    // Enumerate all of the files on the volume looking for SIS links.
    //
    // if the file is a SIS reparse point then validate it:
    //     - link index (against MaxIndex and other link indices)
    //     - CS index (lookup in CommonStore)
    //

    Walk( Volume + "\\" );

    //
    // Now we can check the reference counts in the common store files.
    //

    cout << "Checking Reference Counts" << endl;

    cs.ValidateRefCounts();

    //
    // Check for duplicate link indices.
    //

    cout << "Checking Link Indices" << endl;

    sort(linkFiles.begin(), linkFiles.end());

    vector<LinkFile>::iterator p = linkFiles.begin();

    if (p != linkFiles.end()) {

        for (++p; p != linkFiles.end(); ++p) {

            if (p == (p-1)) {

                cout << "Duplicate link index (" << (INDEX) p->LinkIndex() << "): ";
                cout << p->FileName() << ", " << (p-1)->FileName() << endl;

            }

        }

    }
}


void
SISVolume::Walk(string& dirName)
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle;
    const string fileNameMatchAny = dirName + "*";

    //
    // Enumerate all files in the specified directory, looking for SIS links.
    //

    findHandle = FindFirstFile( fileNameMatchAny.c_str(), &findData );

    if (INVALID_HANDLE_VALUE == findHandle) {

        //
        // Empty directory.
        //

        return;

    }

    do {

        //
        // Check for a SIS link.
        //

        if (( findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) &&
            ( findData.dwReserved0 == IO_REPARSE_TAG_SIS )) {

            if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                //
                // File is both a directory and a SIS link -- illegal.
                //

                cout << dirName << findData.cFileName << " SIS link directory." << endl;

            }

            SI_REPARSE_BUFFER linkInfo;

            //
            // Read the reparse point data to get the link index and
            // common store index.
            //

            if (! GetLinkInfo(dirName + findData.cFileName, linkInfo)) {

                cout << dirName << findData.cFileName << " : invalid link information." << endl;

                continue;

            }

            //
            // Create a LinkFile object.
            //

            LinkFile lf(linkInfo.LinkIndex,
                        linkInfo.LinkFileNtfsId,
                        linkInfo.CSIndex,
                        linkInfo.ReparsePointFormatVersion,
                        dirName + findData.cFileName);

            //
            // And add it to our database.  Expand the database first if necessary.
            //

            if (0 == linkFiles.capacity())
                linkFiles.reserve(linkFiles.size() + 200);

            linkFiles.push_back(lf);

            if (! cs.ValidateIndex(linkInfo.LinkIndex)) {

                cout << "Invalid Link index: " << lf.FileName() << "(" << (INDEX) linkInfo.LinkIndex << ")" << endl;

            }

            //
            // Find the common store file.
            //

            CsFile *pcsFile = cs.Query(linkInfo.CSIndex);

            if (pcsFile == 0) {

                //
                // cs file was not found.
                //

                cout << "Common Store file " << (INDEX) linkInfo.CSIndex << " not found." << endl;

            } else {

                //
                // Update the external reference count on the common store file.
                //

                pcsFile->IncRefCount();

            }

            //
            // Make sure the link index isn't in use as a common store index.
            //

            pcsFile = cs.Query(linkInfo.LinkIndex);

            if (pcsFile != 0) {

                cout << "Link index collision with common store file. Link: ";
                cout << lf.FileName() << ", index: " << (INDEX) linkInfo.LinkIndex << endl;

            }

            if (verbose)
                lf.display();

        } else if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            // Ignore \. and \..
            //

            if ( findData.cFileName[0] == '.' ) {

                if (( findData.cFileName[1] == 0 ) ||
                    (( findData.cFileName[1] == '.' ) && ( findData.cFileName[2] == 0 )))

                    continue;

            }

            //
            // Walk down this directory.
            //

            Walk( dirName + findData.cFileName + "\\" );

        }

    } while ( FindNextFile( findHandle, &findData ) );

    FindClose( findHandle );

}

#define SHARE_ALL              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)

bool
SISVolume::GetLinkInfo(string& fileName, SI_REPARSE_BUFFER& linkInfo)
{
    NTSTATUS  Status = STATUS_SUCCESS;
    HANDLE    fileHandle;

    UNICODE_STRING  ufileName,
                    uNTName;

    IO_STATUS_BLOCK         IoStatusBlock;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    PREPARSE_DATA_BUFFER    ReparseBufferHeader = NULL;
    UCHAR                   ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    LARGE_INTEGER Checksum;

    //
    //  Allocate and initialize Unicode string.
    //

    RtlCreateUnicodeStringFromAsciiz( &ufileName, fileName.c_str() );

    RtlDosPathNameToNtPathName_U(
        ufileName.Buffer,
        &uNTName,
        NULL,
        NULL );

    //
    //  Open the file.
    //  Notice that if there are symbolic links in the path they are
    //  traversed silently.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uNTName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    //  Make sure that we call open with the appropriate flags for:
    //
    //    (1) directory versus non-directory
    //    (2) reparse point
    //

    ULONG OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE;

    Status = NtOpenFile(
                 &fileHandle,
                 FILE_READ_DATA | SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 SHARE_ALL,
                 OpenOptions );

    RtlFreeUnicodeString( &ufileName );

    if (!NT_SUCCESS( Status )) {

        cout << "Unable to open SIS link file: " << fileName << endl;

        return false;
    }

    //
    //  Get the reparse point.
    //

    Status = NtFsControlFile(
                 fileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_GET_REPARSE_POINT,
                 NULL,                                //  Input buffer
                 0,                                   //  Input buffer length
                 ReparseBuffer,                       //  Output buffer
                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE );  //  Output buffer length

    NtClose( fileHandle );

    if (!NT_SUCCESS( Status )) {

        cout << "FSCTL_GET_REPARSE_POINT failed, " << (ULONG)IoStatusBlock.Information << ", " << fileName << endl;

        return false;
    }

    //
    //  Copy the SIS link info from the reparse buffer to the caller's buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER) ReparseBuffer;

	if (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SIS) {

		PSI_REPARSE_BUFFER	sisReparseBuffer = (PSI_REPARSE_BUFFER) ReparseBufferHeader->GenericReparseBuffer.DataBuffer;

        linkInfo = *sisReparseBuffer;

	    //
	    // Now check to be sure that we understand this reparse point format version and
	    // that it has the correct size.
	    //
	    if (ReparseBufferHeader->ReparseDataLength != sizeof(SI_REPARSE_BUFFER)
		    || (sisReparseBuffer->ReparsePointFormatVersion != SIS_REPARSE_BUFFER_FORMAT_VERSION)) {
		    //
		    // We don't understand it, so either its corrupt or from a newer version of SIS.
		    // Either way, we can't understand it, so punt.
		    //
		    cout << "Invalid format version in " << fileName
                 << " Version: " << sisReparseBuffer->ReparsePointFormatVersion
                 << ", expected: " << SIS_REPARSE_BUFFER_FORMAT_VERSION << endl;

            return FALSE;
	    }

        //
        // Now check the checksum.
        //
        ComputeChecksum(
	        sisReparseBuffer,
	        sizeof(SI_REPARSE_BUFFER) - sizeof sisReparseBuffer->Checksum,
	        &Checksum);

        if (Checksum.QuadPart != sisReparseBuffer->Checksum.QuadPart) {

            cout << "Invalid checksum in " << fileName << endl;

            return FALSE;
        }

    } else {

        cout << "Unexpected error. " << fileName << " : expected SIS link file, tag: " << ReparseBufferHeader->ReparseTag << endl;
        return false;
    }

    return true;

}

VOID
SISVolume::ComputeChecksum(
	IN PVOID							buffer,
	IN ULONG							size,
	OUT PLARGE_INTEGER					checksum)
/*++

Routine Description:

	Compute a checksum for a buffer.  We use the "131 hash," which
	works by keeping a 64 bit running total, and for each 32 bits of
	data multiplying the 64 bits by 131 and adding in the next 32
	bits.  Must be called at PASSIVE_LEVEL, and all aruments
	may be pagable.

Arguments:

	buffer - pointer to the data to be checksummed

	size - size of the data to be checksummed

	checksum - pointer to large integer to receive the checksum.  This
		may be within the buffer, and SipComputeChecksum guarantees that
		the initial value will be used in computing the checksum.

Return Value:

	Returns STATUS_SUCCESS or an error returned from the actual disk write.
--*/
{
	LARGE_INTEGER runningTotal;
	ULONG *ptr = (ULONG *)buffer;
	ULONG bytesRemaining = size;

	runningTotal.QuadPart = 0;

	while (bytesRemaining >= sizeof(*ptr)) {
		runningTotal.QuadPart = runningTotal.QuadPart * 131 + *ptr;
		bytesRemaining -= sizeof(*ptr);
		ptr++;
	}

	if (bytesRemaining > 0) {
		ULONG extra;

		extra = 0;
		memmove(&extra, ptr, bytesRemaining);
		
		runningTotal.QuadPart = runningTotal.QuadPart * 131 + extra;
	}

	*checksum = runningTotal;
}

bool
SISVolume::Create(string& Volume)
{
    string ntVolume("\\\\.\\" + Volume);

    //
    // See if we can open the volume.
    //

    HANDLE hVolume = CreateFile(
                         ntVolume.c_str(),
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hVolume == INVALID_HANDLE_VALUE) {

        cout << "Can't open " << Volume << endl;

        return false;

    } else {

        CloseHandle(hVolume);

    }

    //
    // The common store is the only thing we need to create.
    //

    return cs.Create(Volume);

}

void
usage()
{
    cout << "Usage: chksis [-vc] [drive:]\n        -v: verbose\n        -c: create SIS volume" << endl;
}


int
__cdecl
main(int argc, char *argv[])
{
    string volume("C:");
    bool volumeArgSeen = false;
    bool create = false;
    SISVolume sis;

    for (int i = 1; i < argc; ++i) {

        if (argv[i][0] == '-') {

            if (volumeArgSeen) {
                usage();
                exit(1);
            }

            switch (argv[i][1]) {
            case 'v':
                verbose = true;
                break;
            case 'c':
                create = true;
                break;
            default:
                usage();
                exit(1);
            }

        } else {

            volumeArgSeen = true;

            volume.assign(argv[i]);

        }

    }

    if (create) {

        if (! volumeArgSeen) {
            cout << "Must specify volume with -c" << endl;
            exit(1);
        }

        sis.Create(volume);
        exit(0);

    }

    if (! volumeArgSeen)
        cout << "Checking " << volume << endl;


    sis.Validate(volume);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\refcount\refcount.cpp ===
#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <fcntl.h>
#include <string.h>

#include <assert.h>
#include "..\..\filter\sis.h"

void usage(void)
{
    fprintf(stderr,"usage: refcount CommonStoreFileName\n");
	fprintf(stderr,"          prints out the backpointer stream info for the given CS file.\n");
	exit(1);
}

void
printFileNameById(
	PLARGE_INTEGER			fileId,
	HANDLE					hFile)		// hFile is for any file on the same volume as fileId
{
	UNICODE_STRING			fileIdString[1];
	NTSTATUS				status;
	OBJECT_ATTRIBUTES		Obja[1];
	HANDLE					fileByIdHandle = NULL;
	IO_STATUS_BLOCK			Iosb[1];
    struct {
        FILE_NAME_INFORMATION   nameFileInfo[1];
        WCHAR                   nameBuffer[255];
    } nameFile;

	memset(&nameFile, 0, sizeof(nameFile));

	fileIdString->Length = fileIdString->MaximumLength = sizeof(LARGE_INTEGER);

	fileIdString->Buffer = (PWCHAR)fileId;

	InitializeObjectAttributes(
			Obja,
			fileIdString,
			OBJ_CASE_INSENSITIVE,
			hFile,
			NULL);		// security descriptor

	status = NtCreateFile(
				&fileByIdHandle,
				FILE_READ_ATTRIBUTES | SYNCHRONIZE,
				Obja,
				Iosb,
				NULL,			// allocation size
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE | FILE_OPEN_BY_FILE_ID,
				NULL,			// EA buffer
				0);				// EA length

	if (!NT_SUCCESS(status)) {
		printf("open failed 0x%x",status);
		return;
	}

	status = NtQueryInformationFile(
				fileByIdHandle,
				Iosb,
				nameFile.nameFileInfo,
				sizeof(nameFile),
				FileNameInformation);

	if (!NT_SUCCESS(status)) {
		printf("couldn't query name 0x%x",status);
		NtClose(fileByIdHandle);
		return;
	}

	printf("%ws",nameFile.nameFileInfo->FileName);

	NtClose(fileByIdHandle);

	return;
}


void __cdecl main(int argc, char **argv)
{
    if (argc != 2) usage();

	char *streamName = (char *)malloc(strlen(argv[1]) + 100);
	unsigned validReferences = 0;
	unsigned	consecutiveMaxIndicesSeen = 0;

	strcpy(streamName,argv[1]);
	strcat(streamName,":sisBackpointers$");

	HANDLE hFile = 
			CreateFile(
				streamName,
				GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				NULL, 
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		fprintf(stderr,"Unable to open backpointer stream for file %s, %d\n",streamName,GetLastError());
		exit(1);
	}

	const int backpointerEntriesPerSector = 512 / sizeof(SIS_BACKPOINTER);

	PSIS_BACKPOINTER sector = (PSIS_BACKPOINTER)  malloc(512);

	int firstEntry = TRUE;

	assert(sector);

	ULONGLONG previousLinkIndex = 0;

	for (;;) {
		unsigned long bytesRead;

		if (!ReadFile(hFile,sector,512,&bytesRead,NULL)) {
			fprintf(stderr,"readFile of sector failed %d\n",GetLastError());
			exit(1);
		}

		if (0 == bytesRead) {
			break;
		}

		if (bytesRead < 512) {
			fprintf(stderr,"*** read %d of 512 bytes\n",bytesRead);
		}

		for (unsigned i = 0 ; i < backpointerEntriesPerSector; i++) {
			if (firstEntry) {
				firstEntry = FALSE;
				PSIS_BACKPOINTER_STREAM_HEADER header = (PSIS_BACKPOINTER_STREAM_HEADER)sector;

				printf("format version %d, magic 0x%x, checksum 0x%x.0x%x\n\n",
						header->FormatVersion,header->Magic,(DWORD)(header->FileContentChecksum >> 32),
						(DWORD)header->FileContentChecksum);

			} else {
				if (MAXLONGLONG != sector[i].LinkFileNtfsId.QuadPart) {

					if (0 != consecutiveMaxIndicesSeen) {
						printf("%d consecutive MaxIndices (ie., null entries)\n",consecutiveMaxIndicesSeen);
						consecutiveMaxIndicesSeen = 0;
					}

					printf("0x%08x.0x%08x -> 0x%08x.0x%08x\t%c ",sector[i].LinkFileIndex.HighPart,sector[i].LinkFileIndex.LowPart,
							sector[i].LinkFileNtfsId.HighPart,sector[i].LinkFileNtfsId.LowPart,
							sector[i].LinkFileIndex.QuadPart >= previousLinkIndex ? ' ' : '*');
				}

				previousLinkIndex = sector[i].LinkFileIndex.QuadPart;

				if (MAXLONGLONG == sector[i].LinkFileNtfsId.QuadPart) {

					if (0 == consecutiveMaxIndicesSeen) printf("\n");

					consecutiveMaxIndicesSeen++;
				} else {
					if (sector[i].LinkFileNtfsId.LowPart != 0xffffffff || sector[i].LinkFileNtfsId.HighPart != 0x7fffffff) {
						validReferences++;

						printFileNameById(&sector[i].LinkFileNtfsId,hFile);
					}
					printf("\n");
				}
			}
		}
	}

	if (0 != consecutiveMaxIndicesSeen) {
		printf("File ends with %d consecutive MaxIndices (ie., null entries)\n", consecutiveMaxIndicesSeen);
	}

	printf("%d Total valid references\n",validReferences);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\sissetup\sissetup.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   sisSetup.c

Abstract:

   This module is used to install the SIS and GROVELER services.


Environment:

   User Mode Only

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <winioctl.h>

#include <aclapi.h>
//#include <winldap.h>


//
//  Global variables
//

SC_HANDLE scm = NULL;
BOOL MakeCommonStoreDirHidden = TRUE;
BOOL UseSystemACL = TRUE;

const wchar_t CommonStoreDirName[] = L"\\SIS Common Store";
const wchar_t MaxIndexName[] = L"\\MaxIndex";
const wchar_t BackupExludeList[] = L"\\SIS Common Store\\*.* /s" L"\000";


//
//  Functions
//
                        
VOID
DisplayUsage (
    void
    )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   None

Return Value:

   None.

--*/

{

    printf( "\nUsage:  sisSetup [/?] [/h] [/i] [/u] [/n] [drive: [...]]\n"
            "  /? /h Display usage information (default if no operation specified).\n"
            "  /i    Create the SIS and GROVELER services.\n"
            "  /u    Delete the SIS and GROVELER services.\n"
            "  /n    Do NOT make the \"SIS Common Store\" directory \"Hidden|System\".\n"
            "        Will unhide the directory if it already exists and is hidden.\n"
            "  /a    Do NOT set SYSTEM ACL on \"SIS Common Store \" directory, instead\n"
            "        set ADMINISTRATORS group ACL.\n"
            "        This will change the ACL setting for existing directories.\n"
            " drive: A list of NTFS volumes you would like initialized for SIS.\n"
            "        If no drives are specified, only the services will be installed.\n"
            "        This will only initialize local hard drives with NTFS on them.\n"
            "        The BOOT volume is never initialized.\n"
            "\n"
            "        You must reboot for the changes to take affect.\n"
            "\n"
            "Example:  sisSetup /i d: e:\n"
            "          This will create the SIS and GROVELER services and initialize the\n"
            "          \"SIS Common Store\" directory on the specified volumes.\n"
          );
}


void
DisplayError (
   DWORD Code,
   LPSTR Msg,
   ...
   )

/*++

Routine Description:

    This routine will display an error message based off of the Win32 error
    code that is passed in. This allows the user to see an understandable
    error message instead of just the code.

Arguments:

    Msg - The error message to display       
    Code - The error code to be translated.

Return Value:

    None.

--*/

{
    wchar_t errmsg[128];
    DWORD count;
    va_list ap;

    //printf("\n");
    va_start( ap, Msg );
    vprintf( Msg, ap );
    va_end( ap );

    //
    // Translate the Win32 error code into a useful message.
    //

    count = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    Code,
                    0,
                    errmsg,
                    sizeof(errmsg),
                    NULL );

    //
    // Make sure that the message could be translated.
    //

    if (count == 0) {

        printf( "(%d) Could not translate Error\n", Code );

    } else {

        //
        // Display the translated error.
        //

        printf( "(%d) %S", Code, errmsg );
    }
}


DWORD
SetRegistryValue(
    LPCTSTR RegistryKey,
    LPCTSTR DataName,
    DWORD DataType,
    CONST BYTE *Data,
    DWORD DataSize
    )
{
    HKEY regHandle = NULL;
    DWORD status;

    //
    // Get a handle to the services registry key.
    //

    status = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        RegistryKey,
                        0,
                        KEY_ALL_ACCESS,
                        &regHandle);

    if (ERROR_SUCCESS != status) {

        DisplayError(
                status,
                "Opening the registry key \"%S\", ",
                RegistryKey);
        return status;
    }

    //
    //  Set the data value
    //

    status = RegSetValueEx(
                        regHandle,
                        DataName,
                        0,
                        DataType,
                        Data,
                        DataSize);

    if (ERROR_SUCCESS != status) {
        DisplayError(
                status,
                "Setting data to the \"%S\" registry key, ",
                RegistryKey);
        return status;
    }

    return ERROR_SUCCESS;
}


DWORD
SetupService(
    LPCTSTR Name,
    LPCTSTR DisplayName,
    LPCTSTR DriverPath,
    LPCTSTR LoadOrderGroup,
    LPCTSTR Dependencies,
    DWORD ServiceType,
    DWORD StartType,
    LPCTSTR RegistryKey,
    LPCTSTR RegDescription
    )

/*++

Routine Description:

   This routine will initialize the given service.

Arguments:


Return Value:

   Status of operation

--*/

{    
    DWORD status;
    ULONG tag;
    SC_HANDLE srvHandle = NULL;
    HKEY regHandle = NULL;
    static CONST wchar_t DescriptionRegValue[] = L"Description";

    try {

        //
        // Create the given service
        //

        srvHandle = CreateService(
                        scm,
                        Name,
                        DisplayName,
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        ServiceType,
                        StartType,
                        SERVICE_ERROR_NORMAL,
                        DriverPath,
                        LoadOrderGroup,
                        ((ServiceType == SERVICE_FILE_SYSTEM_DRIVER) ? &tag : NULL),
                        Dependencies,
                        NULL,
                        NULL );

        if ( !srvHandle ) {

            status = GetLastError();
            if (ERROR_SERVICE_EXISTS != status) {

                DisplayError(
                        status,
                        "Creating the service \"%S\", ",
                        Name);
                return status;
            }
            printf( "The \"%S\" service already exists.\n", Name );
            return ERROR_SUCCESS;
        }

        //
        // Get a handle to the services registry key.
        //

        status = RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            RegistryKey,
                            0,
                            KEY_ALL_ACCESS,
                            &regHandle);

        if (ERROR_SUCCESS != status) {

            DisplayError(
                    status,
                    "Opening the registry key \"%S\", ",
                    RegistryKey);
            return status;
        }

        //
        //  Add the DESCRIPTION to the service
        //

        status = RegSetValueEx(
                            regHandle,
                            DescriptionRegValue,
                            0,
                            REG_SZ,
                            (CONST BYTE *)RegDescription,
                            (wcslen(RegDescription) * sizeof(wchar_t)));

        if (ERROR_SUCCESS != status) {
            DisplayError(
                    status,
                    "Adding \"%S\" value to the \"%S\" registry key, ",
                    DescriptionRegValue,
                    RegistryKey);
            return status;
        }

    } finally {

        if (regHandle) {

            RegCloseKey( regHandle );
        }

        if (srvHandle)  {

            CloseServiceHandle( srvHandle );
        }
    }

    printf( "The \"%S\" service was successfully added.\n", Name );
    return ERROR_SUCCESS;
}



DWORD
CreateServices (
    void
    )

/*++

Routine Description:

   This will create the SIS and GROVELER service.

Arguments:

   None

Return Value:

   None.

--*/

{
    DWORD status;

    //
    //  Create SIS service
    //

    status = SetupService(
                    L"Sis",
                    L"Single Instance Storage",
                    L"%SystemRoot%\\system32\\drivers\\sis.sys",
                    L"FSFilter System",
                    NULL,
                    SERVICE_FILE_SYSTEM_DRIVER,
                    SERVICE_BOOT_START,
                    L"SYSTEM\\CurrentControlSet\\Services\\Sis",
                    L"A File System Filter that manages duplicate copies of files on hard-disk volumes.  It copies one instance of the duplicate file into a central directory, and the duplicates are replaced with a link to the central copy in order to improve disk usage.  This service can not be stopped.  If this service is disabled, all linked files will no longer be accessible.  If the central directory is deleted, all linked files will become permanently inaccessible." );

    if (ERROR_SUCCESS != status) {

        return status;
    }


    //
    //  Create GROVELER service
    //

    status = SetupService(
                    L"Groveler",
                    L"Single Instance Storage Groveler",
                    L"%SystemRoot%\\system32\\grovel.exe",
                    NULL,
                    L"SIS\0",
                    SERVICE_WIN32_OWN_PROCESS,
                    SERVICE_AUTO_START,
                    L"SYSTEM\\CurrentControlSet\\Services\\Groveler",
                    L"Scans the hard-disk volumes on a Remote Installation Services (RIS) server for duplicate copies of files.  If found, one instance of the duplicate file is stored in a central directory, and the duplicates are replaced with a link to the central copy in order to improve disk usage. If this service is stopped, files will no longer be automatically linked in this manner, but the existing linked files will still be accessible." );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    return ERROR_SUCCESS;
}


DWORD
RemoveService(
    LPCTSTR Name
    )

/*++

Routine Description:

   This will delete the given service.  This will make sure the given
   service is stopped first.

Arguments:

    None

Return Value:

   Status of operation

--*/

{
    DWORD status;
    SC_HANDLE srvHandle = NULL;
    BOOL state;
    SERVICE_STATUS servStatus;
    int retryLimit;

#   define RETRY_TIMEOUT    500             //1/2 second
#   define RETRY_COUNT      (6*2)           //try for a few seconds


    try {

        //
        //  Open the service
        //

        srvHandle = OpenService(
                        scm,
                        Name,
                        SERVICE_ALL_ACCESS );

        if ( !srvHandle )  {

            status = GetLastError();
            if (ERROR_SERVICE_DOES_NOT_EXIST != status)  {

                DisplayError(
                        status,
                        "Opening the service \"%S\", ",
                        Name);
                return status;
            }

            printf( "The \"%S\" service does not exist.\n", Name );
            return ERROR_SUCCESS;
        }

        //
        //  Stop the service
        //

        state = ControlService(
                        srvHandle,
                        SERVICE_CONTROL_STOP,
                        &servStatus );

        if ( !state )  {

            status = GetLastError();
            if ((ERROR_SERVICE_NOT_ACTIVE != status) &&
                (ERROR_INVALID_SERVICE_CONTROL != status) )  {

                DisplayError(
                        status,
                        "Stoping the \"%S\" service, ",
                        Name);
                return status;
            }
        }

        //
        //  Wait a few seconds for the service to stop.
        //

        for (retryLimit=0;
             (SERVICE_STOPPED != servStatus.dwCurrentState);
             )  {

            Sleep( RETRY_TIMEOUT );   //wait for 1/4 second

            state = QueryServiceStatus(
                            srvHandle,
                            &servStatus );

            if ( !state )  {
                    
                status = GetLastError();
                DisplayError(
                        status,
                        "Querrying service status for the \"%S\" service, ",
                        Name);
                return status;
            }

            if (++retryLimit >= RETRY_COUNT)  {

                printf("The \"%S\" service could not be stopped.\n",Name);
                break;
            }
        }

        //
        //  Delete the service
        //

        state = DeleteService( srvHandle );

        if ( !state )  {

            status = GetLastError();
            DisplayError(
                    status,
                    "Deleting the \"%S\" service, ",
                    Name);
            return status;
        }

    } finally {

        if (srvHandle)  {

            CloseServiceHandle( srvHandle );
        }
    }

    printf( "The \"%S\" service was successfully deleted.\n", Name );
    return ERROR_SUCCESS;
}


DWORD
DeleteServices(
    void
    )

/*++

Routine Description:

   This will delete the SIS and GROVELER services from the system

Arguments:

    None

Return Value:

   Status of operation

--*/

{
    DWORD status;


    status = RemoveService( L"Groveler" );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    status = RemoveService( L"Sis" );

    if (ERROR_SUCCESS != status) {

        return status;
    }

    return ERROR_SUCCESS;
}


DWORD
InitVolume(
    char *DevName
    )
/*++

Routine Description:

    This routine will initialize SIS on the given volume.  This will verify
    that the volume is an NTFS volume and that it is not the BOOT volume.

Arguments:

    DevName - The name of the volume to init

Return Value:

   Status of operation

--*/
{
    HANDLE hVolume;
    HANDLE hCSDir;
    HANDLE hMaxIndex = INVALID_HANDLE_VALUE;
    DWORD status;
    DWORD transferCount;
    LONGLONG maxIndex;

    PSID pSid = NULL;
    PACL pAcl = NULL;
    EXPLICIT_ACCESS ExplicitEntries;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR SecDescriptor;

    BOOL state;
    USHORT compressionMode = COMPRESSION_FORMAT_DEFAULT;
    wchar_t name[MAX_PATH];
    wchar_t dirName[MAX_PATH];
    wchar_t fileSystemType[MAX_PATH];
    wchar_t uDevName[MAX_PATH];

    try {

        //
        //  Convert the DEVICE name to unicode
        //

        status = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        DevName,
                        -1,
                        uDevName,
                        (sizeof(uDevName) / sizeof(wchar_t)) );

        if (status == 0)  {
            status = GetLastError();
            DisplayError(
                    status,
                    "Translating \"%s\" to unicode, ",
                    DevName );
        }

        //
        //  Get the "SystemDrive" environemnt variable
        //

        status = GetEnvironmentVariable(
                        L"SystemDrive",
                        name,
                        (sizeof(name) / sizeof(wchar_t)));

        if (status <= 0)  {
            printf( "Unable to retrieve the environment variable \"SystemDrive\"." );
            return ERROR_INVALID_FUNCTION;
        }

        //
        //  See if they have requested the SYSTEM drive.  If so return an error
        //

        if (_wcsicmp(name,uDevName) == 0)  {

            printf( "The volume \"%s\" is the BOOT volume, SIS not initialized on it.\n", DevName );
            return ERROR_SUCCESS;
        }

        //
        //  Get the TYPE of the drive, see if it is a local HARDDISK (fixed
        //  or removable).  If not return now.
        //

        wsprintf(name,L"%s\\",uDevName);      //generate ROOTDIR name

        status = GetDriveType( name );

        if ((status == DRIVE_UNKNOWN) ||
            (status == DRIVE_NO_ROOT_DIR)) {

            printf("The volume \"%s\" does not exist.\n",DevName);
            return ERROR_SUCCESS;
        } else if ((status != DRIVE_FIXED) && 
            (status != DRIVE_REMOVABLE))  {

            printf("The volume \"%s\" is not a local hard drive, SIS not initialized on it.\n",DevName);
            return ERROR_SUCCESS;
        }

        //
        //  Get the type of the file system on the volume.  If not NTFS
        //  return now.
        //

        state = GetVolumeInformation(
                        name,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        fileSystemType,
                        sizeof(fileSystemType));

        if ( !state )  {

            status = GetLastError();
            if (ERROR_PATH_NOT_FOUND != status)  {
                DisplayError(
                        status,
                        "Opening volume \"%s\", ",
                        DevName );
                return status;
            }
            printf("The volume \"%s\" does not exist.\n",DevName);
            return ERROR_SUCCESS;
        }

        if (_wcsnicmp(fileSystemType, L"NTFS", 4 ) != 0)  {

            printf("The volume \"%s\" is not an NTFS volume, SIS not initialized on it.\n",DevName);
            return ERROR_SUCCESS;
        }

        //
        //  Create the Common Store Directory.  Keep going if the directory
        //  already exits.
        //

        wsprintf( dirName, L"%s%s", uDevName, CommonStoreDirName );

        state = CreateDirectory(dirName, NULL);

        if ( !state )  {

            status = GetLastError();
            if (ERROR_ALREADY_EXISTS != status)  {

                DisplayError(
                        status,
                        "Creating directory \"%S\", ",
                        dirName);

                return status;
            }
        }

        //
        //  Mark the directory as SYSTEM and HIDDEN if requested.
        //

        state = SetFileAttributes( dirName, 
                    ((MakeCommonStoreDirHidden) ? 
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM :
                            FILE_ATTRIBUTE_NORMAL) );
        if ( !state ) {

            status = GetLastError();
            DisplayError(
                    status,
                    "Setting attributes on directory \"%S\", ",
                    dirName);
        }

        //
        //  Set compression on the "SIS Common Store" directory
        //  Don't do it for now.
        //

//      //
//      // Open the directory
//      //
//
//      hCSDir = CreateFile(
//                  dirName,
//                  GENERIC_READ|GENERIC_WRITE,
//                  FILE_SHARE_READ | FILE_SHARE_WRITE,
//                  NULL,
//                  OPEN_EXISTING,
//                  FILE_FLAG_BACKUP_SEMANTICS,
//                  NULL);
//
//      if (INVALID_HANDLE_VALUE == hCSDir) {
//
//          DisplayError(
//                  status,
//                  "Opening directory \"%S\" to update compression, ",
//                  dirName);
//
//      } else {
//
//          //
//          //  Enable compression
//          //
//
//          state = DeviceIoControl(
//                       hCSDir,
//                       FSCTL_SET_COMPRESSION,
//                       &compressionMode,
//                       sizeof(compressionMode),
//                       NULL,
//                       0,
//                       &transferCount,
//                       NULL);
//
//          if ( !state )  {
//
//              status = GetLastError();
//              DisplayError(
//                      status,
//                      "Enabling compression on \"%S\", ",
//                      dirName);
//          }
//
//          //
//          //  Close directory handle
//          //
//
//          CloseHandle( hCSDir );
//      }

        //
        // Create the MaxIndex file
        //

        wsprintf( name, L"%s%s", dirName, MaxIndexName );

        hMaxIndex = CreateFile(
                        name,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (INVALID_HANDLE_VALUE == hMaxIndex) {

            status = GetLastError();
            if (ERROR_FILE_EXISTS != status) {

                DisplayError(
                    status,
                    "Creating file \"%S\", ",
                    name);
                return status;
            }

        } else {

            //
            //  The MaxIndex file did not exist, init it.
            //

            maxIndex = 1;

            state = WriteFile(
                          hMaxIndex,
                          &maxIndex,
                          sizeof(maxIndex),
                          &transferCount,
                          NULL);

            if ( !state || (transferCount < sizeof(maxIndex)) ) {

                status = GetLastError();
                DisplayError(
                    status,
                    "Writing file \"%S\", ",
                    name);
                return status;
            }

            //
            //  Close the file
            //

            CloseHandle( hMaxIndex );
            hMaxIndex = INVALID_HANDLE_VALUE;
        }


        //
        //  Set security information on the common store directory
        //

        //
        // build AccessEntry structure
        //

        ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

        if (UseSystemACL) {

            state = AllocateAndInitializeSid(
                        &ntSidAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pSid );
        } else {

            state = AllocateAndInitializeSid(
                        &ntSidAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0,
                        &pSid );
        }

        if ( !state || (pSid == NULL) ) {

            status = GetLastError();
            DisplayError(
                    status,
                    "Creating SID, ");
            return status;
        }

        BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );
        ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitEntries.grfAccessMode = SET_ACCESS;
        ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;

        //
        // Set the Acl with the ExplicitEntry rights
        //

        status = SetEntriesInAcl( 1,
                                  &ExplicitEntries,
                                  NULL,
                                  &pAcl );

        if ( status != ERROR_SUCCESS ) {

            DisplayError(
                    status,
                    "Creating ACL, ");
            return status;
        }

        //
        // Create the Security Descriptor
        //

        InitializeSecurityDescriptor( &SecDescriptor, SECURITY_DESCRIPTOR_REVISION );

        state = SetSecurityDescriptorDacl( &SecDescriptor, TRUE, pAcl, FALSE );

        if ( !state ) {
            status = GetLastError();
            DisplayError(
                    status,
                    "Setting Security DACL, ");            

            return status;
        }


        //
        //  SET security on the Directory
        //

        state = SetFileSecurity(dirName,
                                DACL_SECURITY_INFORMATION,
                                &SecDescriptor);

        if ( !state )  {
            status = GetLastError();
            DisplayError(
                    status,
                    "Setting File Security, ");            

            return status;
        }

    } finally {

        //
        //  Cleanup
        //

        if (hMaxIndex != INVALID_HANDLE_VALUE)  {

            CloseHandle( hMaxIndex );
        }

        if ( pSid ) {

            FreeSid( pSid );
        }

        if ( pAcl ) {

            LocalFree( pAcl );
        }
    }

    printf( "The volume \"%s\" was successfully initialized.\n", DevName );
    return ERROR_SUCCESS;
}


//DWORD
//CleanupVolume(
//    char *DevName
//    )
//
///*++
//
//Routine Description:
//
//   
//
//Arguments:
//
//    None
//
//Return Value:
//
//   Status of operation
//
//--*/
//
//{
//    printf("Remove SIS on \"%s\"\n",DevName);
//    return ERROR_SUCCESS;
//}


//
//  Main FUNCTION
//

void __cdecl 
main(
   int argc,
   char *argv[])

/*++

Routine Description:

   This is the program entry point and main processing routine for the
   installation console mode application. 

Arguments:

   argc - The count of arguments passed into the command line.
   argv - Array of arguments passed into the command line.

Return Value:

   None.

--*/

{
    char *param;
#       define OP_UNKNOWN   0
#       define OP_CREATE    1
#       define OP_DELETE    2
    int operation = OP_UNKNOWN;
    int servicesState = OP_UNKNOWN;
    int i;
    DWORD status;

    //
    // Begin by displaying an introduction message to the user to let them
    // know that the application has started.
    //
    
//    printf("\nSIS/GROVELER Simple Installation Aid\n"
//           "Copyright (c) 2000  Microsoft Corporation\n\n");
    
    //
    // Obtain a handle to the service control manager requesting all access
    //
    
    scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    //
    // Verify that a handle could be obtained.
    //
    
    if (!scm) {
                                 
      //
      // A handle could not be obtained, report error.
      //
    
      DisplayError(GetLastError(),
                   "The Service Control Manager could not be opened, ");
      return;
    }

    try {

        //
        //  Parase parameters then perform the operations that we can
        //

        for (i=1; i < argc; i++)  {

            param = argv[i];

            //
            //  See if a SWITCH
            //

            if ((param[0] == '-') || (param[0] == '/')) {

                //
                //  We have a switch header, make sure it is 1 character long
                //

                if (param[2] != 0) {
                    DisplayError(ERROR_INVALID_PARAMETER,
                                 "Parsing \"%s\", ",
                                 param);
                    DisplayUsage();
                    return;
                }

                //
                //  Figure out the switch
                //

                switch (param[1]) {

                    case '?':
                    case 'h':
                    case 'H':
                        DisplayUsage();
                        return;

                    case 'i':
                    case 'I':
                        operation = OP_CREATE;
                        break;

                    case 'u':
                    case 'U':
                        operation = OP_DELETE;
                        break;

                    case 'n':
                    case 'N':
                        MakeCommonStoreDirHidden = FALSE;
                        break;

                    case 'a':
                    case 'A':
                        UseSystemACL = FALSE;
                        break;

                    default:
                        DisplayError(ERROR_INVALID_PARAMETER,
                                 "Parsing \"%s\", ",
                                 param);
                        DisplayUsage();
                        return;
                }
            } else {

                //
                //  Execute the given operation
                //

                switch (operation) {

                    case OP_CREATE:
                        if (servicesState != OP_CREATE)  {

                            status = CreateServices();
                            if (ERROR_SUCCESS != status) {

                                goto Cleanup;
                            }
                            servicesState = OP_CREATE;
                        }

                        status = InitVolume(param);
                        if (ERROR_SUCCESS != status) {

                            goto Cleanup;
                        }

                        status = SetRegistryValue(
                                        L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup",
                                        L"Single Instance Storage",
                                        REG_MULTI_SZ,
                                        (const BYTE *)BackupExludeList,
                                        sizeof(BackupExludeList));
                        if (ERROR_SUCCESS != status) {

                            goto Cleanup;
                        }
                        break;

                    case OP_DELETE:
                        if (servicesState != OP_DELETE) {

                            status = DeleteServices();
                            if (ERROR_SUCCESS != status) {

                                goto Cleanup;
                            }
                            servicesState = OP_DELETE;
                        }
//                      status = CleanupVolume(param);
//                      if (ERROR_SUCCESS != status) {
//
//                          goto Cleanup;
//                      }
                        break;
                }
            }
        }

        //
        //  See if any operation was performed.  If not then no drive letter was
        //  specified, so do what ever operation they said without a drive letter.
        //

        if (servicesState == OP_UNKNOWN)  {

            switch (operation)  {
                case OP_UNKNOWN:
                    DisplayUsage();
                    break;

                case OP_CREATE:
                    CreateServices();
                    break;

                case OP_DELETE:
                    DeleteServices();
                    break;
            }
        }

        Cleanup: ;

    } finally {

        CloseServiceHandle(scm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\sisenum\sisenum.cxx ===
#include "std.hxx"


class CException
{
protected:
    CException(
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        const DWORD  dwLine) :
            m_pcszDescription(pcszDescription),
            m_pcszFile(pcszFile),
            m_dwLine(dwLine) {}
public:
    PCTSTR GetDescription()  { return m_pcszDescription; }
    PCTSTR GetFile()         { return m_pcszFile; }
    DWORD  GetLine()         { return m_dwLine; }

    virtual void Throw() = 0;
protected:
    PCTSTR m_pcszDescription;
    PCTSTR m_pcszFile;
    DWORD  m_dwLine;
};


class CMemoryException : public CException
{
public:
    CMemoryException(
        DWORD  dwSize,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwSize(dwSize) {}
public:
    DWORD  GetSize() { return m_dwSize; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwSize;
};


class CApiException : public CException
{
public:
    CApiException(
        DWORD  dwGleCode,
        PCTSTR pcszDescription,
        PCTSTR pcszFile,
        DWORD  dwLine) :
            CException(pcszDescription, pcszFile, dwLine),
            m_dwGleCode(dwGleCode) {}
public:
    DWORD  GetError() { return m_dwGleCode; }
    void Throw() { throw *this; }
protected:
    DWORD  m_dwGleCode;
};


#define THROW_API_EXCEPTION(description) \
    throw CApiException(                 \
        GetLastError(),                  \
        description,                     \
        _T(__FILE__),                    \
        __LINE__)



void CountReparsePoints(PCTSTR pcszInput);
void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir);
HANDLE xOpenReparseIndex(PCTSTR pcszVolume);
BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo);
HANDLE xOpenVolume(PCTSTR pcszVolume);
void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId);


extern "C"
void __cdecl _tmain(int argc, PTSTR argv[], PTSTR envv[])
{
    if (argc==2)
    {
        CountReparsePoints(
                argv[1]);
    }
    else
    {
        _tprintf(
            _T("sisenum: Enumerates and lists all SIS files on a given volume.\n")
            _T("Usage: sisenum <location> <count>"));
    }
}


void CountReparsePoints(PCTSTR pcszInput)
{
    PTSTR pszVolume = NULL;
    DWORD dwCount = 0;
    HANDLE hIndex = INVALID_HANDLE_VALUE;
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    FILE_REPARSE_POINT_INFORMATION ReparseInfo;
    try
    {
        xGetRootDirectory(
            pcszInput,
            &pszVolume);

        hIndex = xOpenReparseIndex(
            pszVolume);

        hVolume = xOpenVolume(
            pszVolume);

        BOOL fDone = xGetNextReparseRecord(
            hIndex,
            &ReparseInfo);

        while (!fDone)
        {
            if (IO_REPARSE_TAG_SIS==ReparseInfo.Tag)
            {
                dwCount++;
                DisplayFileName(
                    pszVolume,
                    hVolume,
                    ReparseInfo.FileReference);
            }
            fDone = xGetNextReparseRecord(
                hIndex,
                &ReparseInfo);

        }

        CloseHandle(hIndex);
        hIndex = INVALID_HANDLE_VALUE;

        _tprintf(
            _T("This volume (%s) contains %u SIS files.\n"),
            pszVolume,
            dwCount);
    }
    catch (CApiException& e)
    {
        _tprintf(
            _T("Failure: %s\nFile:    %s\nLine:    %u\nError:   %u"),
            e.GetDescription(),
            e.GetFile(),
            e.GetLine(),
            e.GetError());
    }
    catch (CMemoryException& e)
    {
        _tprintf(
            _T("Out of memory.\n"));
    }

    if (hIndex!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hIndex);
    }
    if (hVolume!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            hVolume);
    }
    delete []pszVolume;
}


void xGetRootDirectory(PCTSTR pcszInput, PTSTR* pszRootDir)
{
    DWORD dwBufferSize = MAX_PATH;
    PTSTR pszTemp;

    *pszRootDir = NULL;

    BOOL bResult;
    DWORD dwGleCode;

    do
    {
        pszTemp = new TCHAR[dwBufferSize];
        bResult = GetVolumePathName(
            pcszInput,
            pszTemp,
            dwBufferSize);

        if (!bResult)
        {
            delete []pszTemp;
            dwGleCode = GetLastError();
            if (ERROR_BUFFER_OVERFLOW==dwGleCode)
            {
                dwBufferSize *= 2;
            }
            else
            {
                THROW_API_EXCEPTION(_T("GetVolumePathName failed."));
            }
        }
    } while (!bResult);
    *pszRootDir = pszTemp;
}


HANDLE xOpenReparseIndex(PCTSTR pcszVolume)
{
    HANDLE hReparseIndex;
    PTSTR pszReparseIndex = NULL;

    pszReparseIndex = new TCHAR[_tcslen(pcszVolume)+64];
    _tcscpy(
        pszReparseIndex,
        pcszVolume);
    PathAddBackslash(pszReparseIndex);
    _tcscat(
        pszReparseIndex,
        _T("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

   hReparseIndex = CreateFile(
       pszReparseIndex,
       GENERIC_READ,
       FILE_SHARE_READ,
       NULL,
       OPEN_EXISTING,
       FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
       NULL);

   delete []pszReparseIndex;

   if (INVALID_HANDLE_VALUE == hReparseIndex)
   {
       THROW_API_EXCEPTION(_T("Unable to open reparse index."));
   }

   return hReparseIndex;
}


HANDLE xOpenVolume(PCTSTR pcszVolume)
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    PTSTR pszVolumeName = NULL;

    pszVolumeName = new TCHAR[MAX_PATH];

    BOOL bResult = GetVolumeNameForVolumeMountPoint(
        pcszVolume,
        pszVolumeName,
        MAX_PATH);

    if (bResult)
    {
        hVolume = CreateFile(
            pszVolumeName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
            NULL);
    }

    delete []pszVolumeName;

    if (INVALID_HANDLE_VALUE == hVolume)
    {
        THROW_API_EXCEPTION(_T("Unable to open volume."));
    }

   return hVolume;
}


BOOL xGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION ReparseInfo)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS status = NtQueryDirectoryFile(hIndex,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        ReparseInfo,
        sizeof(FILE_REPARSE_POINT_INFORMATION),
        FileReparsePointInformation,
        TRUE,
        NULL,
        FALSE);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            THROW_API_EXCEPTION(_T("Unable to open reparse index."));
        }
        bResult = TRUE;
    }

    return bResult;
}


void DisplayFileName(
    PTSTR pszVolume,
    HANDLE hVolume,
    LONGLONG llFileId)
{
    UNICODE_STRING          usIdString;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK         IoStatusBlock;

    struct {
        FILE_NAME_INFORMATION   FileInformation;
        WCHAR                   FileName[MAX_PATH];
    } NameFile;

    ZeroMemory(
        &NameFile,
        sizeof(NameFile));

    usIdString.Length = sizeof(LONGLONG);
    usIdString.MaximumLength = sizeof(LONGLONG);
    usIdString.Buffer = (PWCHAR)&llFileId;

    InitializeObjectAttributes(
            &ObjectAttributes,
            &usIdString,
            OBJ_CASE_INSENSITIVE,
            hVolume,
            NULL);      // security descriptor

    status = NtCreateFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_BY_FILE_ID,
                NULL,           // EA buffer
                0);             // EA length

    if (NT_SUCCESS(status))
    {
        status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            &(NameFile.FileInformation),
            sizeof(NameFile),
            FileNameInformation);

        if (NT_SUCCESS(status))
        {
            wprintf(L"%s\n",NameFile.FileInformation.FileName);
        }
        else
        {
            _tprintf(_T("Unable to query file name.\n"));
        }
    }
    else
    {
        _tprintf(_T("Unable to open file by ID.\n"));
    }

    if (hFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\rpget\rpget.c ===
/*++

	Program Description:

        prints out rptag info..

	Modification History:

		09/29/97        anandn          created
        modified from rptag_stress.c code..

--*/


#include "rpget.h"


THREAD CHAR gszLogMsg[LINE_LENGTH];	// log message string, local to thread

USHORT gMaxDataBuffSize = MAXIMUM_REPARSE_DATA_BUFFER_SIZE -
			FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer);


//
// main
//
 
VOID __cdecl main(INT argc, CHAR* argv[]) {

	BOOL fSuccess;

	OPTIONS Options;	// command line options
	

	PBYTE pOutBuff = NULL;

	PUCHAR pDataBuff;
	USHORT usDataBuffSize;

    if (argc<2) {
        printf("Usage: %s filename\n",argv[0]);
        ExitProcess(1);
    }
    
	fSuccess = RPGet( argv[1], &pOutBuff );

	if ( ! fSuccess ) {
        printf("ERROR: RPGet failed\n");
        ExitProcess(1);
    }

	//
	// print out rp buffer
	//

    printf("\n");
    printf("ReparseTag = %Xh\n",  
        (((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseTag));

    printf("ReparseDataLength = %d\n", 
        ((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseDataLength);

    printf("Reserved = %d\n", 
        ((PREPARSE_DATA_BUFFER) pOutBuff)->Reserved);

    printf("Dumping GenericReparseBuffer:\n");

    DumpBuff((PBYTE) (((PREPARSE_DATA_BUFFER) pOutBuff)->GenericReparseBuffer.DataBuffer), 
        (WORD) ((PREPARSE_DATA_BUFFER) pOutBuff)->ReparseDataLength);

}




BOOL
RPGet( CHAR szFileName[], BYTE **ppOutBuff) 
{

	BOOL fSuccess;
	DWORD dwRc = 0;
	DWORD gle;
	DWORD dwOutBuffLen;

	HANDLE hFile;

	__try {


		hFile = RPOpen( szFileName, "rpf" );

        // if open fails..try as directory..

        if (hFile == INVALID_HANDLE_VALUE) {
            hFile = RPOpen( szFileName, "rpd" );
        }

        if (hFile == INVALID_HANDLE_VALUE) {
            printf("error opening %s\n", szFileName);
            return FALSE;
        }
		
		dwOutBuffLen = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;

		*ppOutBuff = (PBYTE) calloc( dwOutBuffLen, 1);

		if (NULL == *ppOutBuff) {
            printf("error callocing OutBuff in RPGet\n");
			return FALSE;
		}


        SetLastError( ERROR_SUCCESS );

		//
		// try the fsctl..
		//
	
		fSuccess = DeviceIoControl( hFile,
			FSCTL_GET_REPARSE_POINT,
			NULL,
			0,
			*ppOutBuff,
			dwOutBuffLen,
			&dwRc,
			NULL);

        printf("dwRc= %ld\n", dwRc);

		if ( ! fSuccess ) {

			gle = GetLastError();

				    printf("ERROR: FSCTL_GET_REPARSE_POINT in RPGet\n");
                    printf("GLE  : %ld\n",GetLastError());
					return FALSE;
		}

		return TRUE;

	} __finally {

	}
}


VOID
DumpBuff( PBYTE pData, WORD wSize )
{

	WORD i=0;
	WORD j=0;
	CHAR szData[LINE_LENGTH];
    WORD NumLines;

    NumLines = wSize/8;
   
    if (NumLines) {
 
	for( i=0; i < NumLines; i++) {

		szData[0] = '\0';

		for( j=0; j<8; j++) {

    		sprintf(szData,TEXT("%s %02X"), szData, *(pData + i*8 + j));

			if (j==3) {
				sprintf(szData, TEXT("%s -"), szData);
			}

		}
		
		sprintf(szData, TEXT("%s  "), szData);

		for( j=0; j<8; j++) {

			if (*(pData + i*8 + j) >  ' ') {
				sprintf(szData,TEXT("%s%c"), szData, *(pData + i*8 + j));
			} else {
				sprintf(szData,TEXT("%s."), szData);
		    }

		}

	  sprintf(gszLogMsg, TEXT("%05d:%s"), i*8, szData);
	  printf("%s\n", gszLogMsg );

      }
    }

    wSize %= 8;

    if (wSize) { 

		szData[0] = '\0';

		for( j=0; j<8; j++) {

			if (j >= wSize) {
				sprintf(szData,TEXT("%s   "), szData);
			} else {
				sprintf(szData,TEXT("%s %02X"), szData, *(pData + i*8 + j));
			}

			if (j==3) {
				sprintf(szData, TEXT("%s -"), szData);
			}

		}
		
		sprintf(szData, TEXT("%s  "), szData);

		for( j=0; j<8; j++) {

			if (j >= wSize) {
				sprintf(szData,TEXT("%s "), szData);
			} else {

				if (*(pData + i*8 + j) >  ' ') {
					sprintf(szData,TEXT("%s%c"), szData, *(pData + i*8 + j));
				} else {
					sprintf(szData,TEXT("%s."), szData);
			    }
			}

		}

	sprintf(gszLogMsg, TEXT("%05d:%s"), i*8, szData);
	printf("%s\n", gszLogMsg );

    }
}




//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
           WCHAR *pwszFile,
           ULONG CreateOptions,
           ULONG DesiredAccess,
           ULONG ShareAccess,
           ULONG CreateDisposition,
           IO_STATUS_BLOCK *IoStatusBlock,
           HANDLE *ObjectHandle)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;

    RtlDosPathNameToNtPathName_U(
                                pwszFile,
                                &str,
                                NULL,
                                NULL);

    InitializeObjectAttributes(
                              &ObjectAttributes,
                              &str,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

    Status = NtCreateFile(
                         ObjectHandle,
                         DesiredAccess | SYNCHRONIZE,
                         &ObjectAttributes,
                         IoStatusBlock,
                         NULL,                    // pallocationsize (none!)
                         FILE_ATTRIBUTE_NORMAL,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         NULL,                    // EA buffer (none!)
                         0);

    RtlFreeHeap (RtlProcessHeap(), 0, str.Buffer);

    if (!NT_SUCCESS( Status )) {
        printf("NtCreateFile Status %Xh\n", Status);
    }

    return (Status);
}



//----------------------------------------------------------------------------
//
//  RPOpen
//
// This function opens a file / directory in the specified mode 
// and if unsuccessful returns NULL
// INPUT - NAME and OPTION
//
//----------------------------------------------------------------------------


HANDLE
RPOpen (LPSTR szFileName, 
        LPSTR szOption )
{
    DWORD   dwOption = 0;
    DWORD   dwAccess = 0;
    DWORD   dwDisposition = 0;
    HANDLE  hFile;
    NTSTATUS Status ;
    DWORD dwLastErr ;

    IO_STATUS_BLOCK IoStatusBlock ;

    WCHAR   wszFileName[MAX_PATH];


    if (!_stricmp (szOption, "rpf")) {

        dwOption      = FILE_NON_DIRECTORY_FILE |
                        FILE_OPEN_REPARSE_POINT;

        dwAccess      = FILE_READ_DATA |
                        FILE_WRITE_DATA |
                        FILE_WRITE_ATTRIBUTES |
                        FILE_READ_ATTRIBUTES;

        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "rpd")) {

        dwOption      = FILE_OPEN_REPARSE_POINT;


        dwAccess      = FILE_WRITE_DATA ;


        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "d")) {

        dwOption      =  FILE_OPEN_REPARSE_POINT ;

        dwAccess      =  FILE_WRITE_DATA ;

        dwDisposition = FILE_OPEN_IF ;

    } else if (!_stricmp (szOption, "f")) {

        dwOption      = FILE_NON_DIRECTORY_FILE;

        dwAccess      = FILE_READ_DATA |
                        FILE_WRITE_DATA    |
                        FILE_LIST_DIRECTORY |
                        FILE_WRITE_ATTRIBUTES |
                        FILE_READ_ATTRIBUTES;

        dwDisposition = OPEN_ALWAYS ;
    }

    SzToWsz (wszFileName, szFileName);   

    if ( (0 == lstrcmp ( szOption , "f") )  || 
         (0 == lstrcmp ( szOption , "rpf") ) ) {

        hFile = CreateFile ( szFileName ,
                             GENERIC_READ | GENERIC_WRITE   ,
							 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             NULL ,
                             dwDisposition ,
                             dwOption | FILE_OPEN_NO_RECALL,
                             NULL ) ;


        if ( INVALID_HANDLE_VALUE == hFile ) {
          //  printf( TEXT("ERROR: CreateFile in RPOpen\n") );
		}

    } else {

        Status = OpenObject (wszFileName,
                             dwOption,
                             dwAccess,
                             FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                             dwDisposition,
                             &IoStatusBlock,
                             &hFile);

        if (!NT_SUCCESS (Status)) {
            printf( TEXT("OpenObject in RPOpen\n") );
        }

    }

    return hFile;
}


VOID
SzToWsz (
        OUT WCHAR *Unicode,
        IN char *Ansi
        )
{
    while (*Unicode++ = *Ansi++)
        ;
}



VOID
WszToSz (
        OUT char *Ansi,
        IN WCHAR *Unicode
        )
{
    while (*Ansi++ = (char) *Unicode++)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkdebug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkdebug.c

Abstract:

    Contains routines for debugging reference count problems.

Author:

    David Treadwell (davidtr) 30-Sept-1991

Revision History:

--*/

#include "precomp.h"
#include "blkdebug.tmh"
#pragma hdrstop

//
// This entire module is conditionalized out if SRVDBG2 is not defined.
//

#if SRVDBG2

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeReferenceHistory )
#pragma alloc_text( PAGE, SrvTerminateReferenceHistory )
#endif
#if 0
NOT PAGEABLE -- SrvUpdateReferenceHistory
NOT PAGEABLE -- SrvdbgClaimOrReleaseHandle
#endif


VOID
SrvInitializeReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN ULONG InitialReferenceCount
    )

{
    PVOID caller, callersCaller;

    ULONG historyTableSize = sizeof(REFERENCE_HISTORY_ENTRY) *
                                             REFERENCE_HISTORY_LENGTH;

    PAGED_CODE( );

    Block->History.HistoryTable = ALLOCATE_NONPAGED_POOL(
                                     historyTableSize,
                                     BlockTypeDataBuffer
                                     );
    //
    // It we weren't able to allocate the memory, don't track references
    // and dereferences.
    //

    if ( Block->History.HistoryTable == NULL ) {
        Block->History.NextEntry = -1;
    } else {
        Block->History.NextEntry = 0;
        RtlZeroMemory( Block->History.HistoryTable, historyTableSize );
    }

    Block->History.TotalReferences = 0;
    Block->History.TotalDereferences = 0;

    //
    // Account for the initial reference(s).
    //

    RtlGetCallersAddress( &caller, &callersCaller );

    while ( InitialReferenceCount-- > 0 ) {
        SrvUpdateReferenceHistory( Block, caller, callersCaller, FALSE );
    }

    return;

} // SrvInitializeReferenceHistory


VOID
SrvUpdateReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN PVOID Caller,
    IN PVOID CallersCaller,
    IN BOOLEAN IsDereference
    )

{
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Debug, &oldIrql );

    if ( IsDereference ) {
        Block->History.TotalDereferences++;
    } else {
        Block->History.TotalReferences++;
    }

    if ( Block->History.HistoryTable != 0 ) {

        PREFERENCE_HISTORY_ENTRY entry;
        PREFERENCE_HISTORY_ENTRY priorEntry;

        entry = &Block->History.HistoryTable[ Block->History.NextEntry ];

        if ( Block->History.NextEntry == 0 ) {
            priorEntry =
                &Block->History.HistoryTable[ REFERENCE_HISTORY_LENGTH-1 ];
        } else {
            priorEntry =
                &Block->History.HistoryTable[ Block->History.NextEntry-1 ];
        }

        entry->Caller = Caller;
        entry->CallersCaller = CallersCaller;

        if ( IsDereference ) {
            entry->NewReferenceCount = priorEntry->NewReferenceCount - 1;
            entry->IsDereference = (ULONG)TRUE;
        } else {
            entry->NewReferenceCount = priorEntry->NewReferenceCount + 1;
            entry->IsDereference = (ULONG)FALSE;
        }

        Block->History.NextEntry++;

        if ( Block->History.NextEntry >= REFERENCE_HISTORY_LENGTH ) {
            Block->History.NextEntry = 0;
        }
    }

    RELEASE_GLOBAL_SPIN_LOCK( Debug, oldIrql );

} // SrvUpdateReferenceHistory


VOID
SrvTerminateReferenceHistory (
    IN PBLOCK_HEADER Block
    )

{
    PAGED_CODE( );

    if ( Block->History.HistoryTable != 0 ) {
        DEALLOCATE_NONPAGED_POOL( Block->History.HistoryTable );
    }

    return;

} // SrvTerminateReferenceHistory

#endif // SRVDBG2


#if SRVDBG_HANDLES

#define HANDLE_HISTORY_SIZE 512

struct {
    ULONG HandleTypeAndOperation;
    PVOID Handle;
    ULONG Location;
    PVOID Data;
} HandleHistory[HANDLE_HISTORY_SIZE];

ULONG HandleHistoryIndex = 0;

VOID
SrvdbgClaimOrReleaseHandle (
    IN HANDLE Handle,
    IN PSZ HandleType,
    IN ULONG Location,
    IN BOOLEAN Release,
    IN PVOID Data
    )
{
    ULONG index;
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Debug, &oldIrql );
    index = HandleHistoryIndex;
    if ( ++HandleHistoryIndex >= HANDLE_HISTORY_SIZE ) {
        HandleHistoryIndex = 0;
    }
    RELEASE_GLOBAL_SPIN_LOCK( Debug, oldIrql );

    HandleHistory[index].HandleTypeAndOperation =
        (*(PULONG)HandleType << 8) | (Release ? 'c' : 'o');
    HandleHistory[index].Handle = Handle;
    HandleHistory[index].Location = Location;
    HandleHistory[index].Data = Data;

    return;

} // SrvdbgClaimOrReleaseHandle

#endif // SRVDBG_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\smbtrsup\makefile.inc ===
$(O)\smbtrsup.def: smbtrsup.src
    $(TARGET_CPP) /EP $(CDEFINES) smbtrsup.src > $(O)\smbtrsup.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkconn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkconn.c

Abstract:

    This module implements routines for managing connection blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkconn.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKCONN

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateConnection )
#pragma alloc_text( PAGE, SrvCloseConnectionsFromClient )

#if !defined(DBG) || DBG == 0
#pragma alloc_text( PAGE, SrvFreeConnection )
#endif

#endif
#if 0
NOT PAGEABLE -- SrvCloseConnection
NOT PAGEABLE -- SrvCloseFreeConnection
NOT PAGEABLE -- SrvDereferenceConnection
NOT PAGEABLE -- SrvQueryConnections
#endif

CHAR DisconnectReasonText[((USHORT)DisconnectReasons)+1][32] = {
    "Idle Connection",
    "Endpoint Closing",
    "2nd Sess Setup on Conn",
    "Transport Issued Disconnect",
    "Session Deleted",
    "Bad SMB Packet",
    "Suspected DOS",
    "Cancelled/Failed Receive",
    "Stale IPX Conn",
    "Unknown"
};

VOID
SrvAllocateConnection (
    OUT PCONNECTION *Connection
    )

/*++

Routine Description:

    This function allocates a Connection Block from the system nonpaged
    pool.

Arguments:

    Connection - Returns a pointer to the connection block, or NULL if
        no pool was available.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    ULONG i;
    PPAGED_CONNECTION pagedConnection;

    PAGED_CODE( );

    //
    // Attempt to allocate from nonpaged pool.
    //

    connection = ALLOCATE_NONPAGED_POOL( sizeof(CONNECTION), BlockTypeConnection );
    *Connection = connection;

    if ( connection == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateConnection: Unable to allocate %d bytes from"
                "nonpaged pool",
            sizeof( CONNECTION ),
            NULL
            );
        return;
    }

    RtlZeroMemory( connection, sizeof(CONNECTION) );

    pagedConnection = ALLOCATE_HEAP_COLD(
                        sizeof(PAGED_CONNECTION),
                        BlockTypePagedConnection );

    if ( pagedConnection == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateConnection: Unable to allocate %d bytes from"
                "paged pool",
            sizeof( PAGED_CONNECTION ),
            NULL
            );
        goto error_exit;
    }


    IF_DEBUG(HEAP) {
        KdPrint(( "SrvAllocateConnection: Allocated connection at %p\n",
                    connection ));
    }

    RtlZeroMemory( pagedConnection, sizeof(PAGED_CONNECTION) );

    SET_BLOCK_TYPE_STATE_SIZE( connection, BlockTypeConnection, BlockStateInitializing, sizeof( CONNECTION ) );

    connection->PagedConnection = pagedConnection;
    pagedConnection->PagedHeader.NonPagedBlock = connection;
    pagedConnection->PagedHeader.Type = BlockTypePagedConnection;

    connection->BlockHeader.ReferenceCount = 2;  // allow for Active status
                                                    //  and caller's pointer

    InitializeListHead( &pagedConnection->TransactionList );

    connection->SmbDialect = SmbDialectIllegal;
    connection->CachedFid = (ULONG)-1;

    //
    // Allocate session table.
    //

    SrvAllocateTable(
        &pagedConnection->SessionTable,
        SrvInitialSessionTableSize,
        FALSE
        );
    if ( pagedConnection->SessionTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate tree connect table.
    //

    SrvAllocateTable(
        &pagedConnection->TreeConnectTable,
        SrvInitialTreeTableSize,
        FALSE
        );
    if ( pagedConnection->TreeConnectTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate file table.
    //

    SrvAllocateTable(
        &connection->FileTable,
        SrvInitialFileTableSize,
        TRUE
        );
    if ( connection->FileTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Allocate search table.
    //

    SrvAllocateTable(
        &pagedConnection->SearchTable,
        SrvInitialSearchTableSize,
        FALSE
        );
    if ( pagedConnection->SearchTable.Table == NULL ) {
        goto error_exit;
    }

    //
    // Initialize core search list heads
    //

    InitializeListHead( &pagedConnection->CoreSearchList );

    //
    // Initialize the locks that protect the connection and its data.
    //

    INITIALIZE_SPIN_LOCK( &connection->SpinLock );
    INITIALIZE_SPIN_LOCK( &connection->Interlock );

    INITIALIZE_LOCK( &connection->Lock, CONNECTION_LOCK_LEVEL, "ConnectionLock" );
    INITIALIZE_LOCK( &connection->LicenseLock, LICENSE_LOCK_LEVEL, "LicenseLock" );

    //
    // Initialize the client machine name string.
    //

    pagedConnection->ClientMachineNameString.Buffer =
                            pagedConnection->LeadingSlashes;
    pagedConnection->ClientMachineNameString.Length = 0;
    pagedConnection->ClientMachineNameString.MaximumLength =
            (USHORT)((2 + COMPUTER_NAME_LENGTH + 1) * sizeof(WCHAR));

    pagedConnection->LeadingSlashes[0] = '\\';
    pagedConnection->LeadingSlashes[1] = '\\';

#ifdef INCLUDE_SMB_PERSISTENT
    pagedConnection->PersistentId = 0;
    pagedConnection->PersistentFileOffset = 0;
    pagedConnection->PersistentState = PersistentStateFreed;
#endif

    //
    // Initialize the oem client machine name string
    //

    connection->OemClientMachineNameString.Buffer =
                                            connection->OemClientMachineName;

    connection->OemClientMachineNameString.MaximumLength =
                                (USHORT)(COMPUTER_NAME_LENGTH + 1);


    //
    // Initialize count of sessions.
    //
    // *** Already done by RtlZeroMemory.

    //pagedConnection->CurrentNumberOfSessions = 0;

    //
    // Initialize the in-progress work item list, the outstanding
    // oplock breaks list, and the cached-after-close lists.
    //

    InitializeListHead( &connection->InProgressWorkItemList );
    InitializeListHead( &connection->OplockWorkList );
    InitializeListHead( &connection->CachedOpenList );
    InitializeListHead( &connection->CachedDirectoryList );

    // Initialize the CachedTransactionList
    ExInitializeSListHead( &connection->CachedTransactionList );

    SET_INVALID_CONTEXT_HANDLE(connection->NegotiateHandle);

    //
    // Indicate that security signatures are not active
    //
    connection->SmbSecuritySignatureActive = FALSE;

    //
    // Indicate that no IPX saved response buffer has been allocated.
    //

    connection->LastResponse = connection->BuiltinSavedResponse;

    //
    // Initialize the search hash table list.
    //

    for ( i = 0; i < SEARCH_HASH_TABLE_SIZE ; i++ ) {
        InitializeListHead( &pagedConnection->SearchHashTable[i].ListHead );
    }

    INITIALIZE_REFERENCE_HISTORY( connection );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Allocations );

    return;

error_exit:

    if ( pagedConnection != NULL ) {
        if ( pagedConnection->SessionTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->SessionTable );
        }
        if ( pagedConnection->TreeConnectTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->TreeConnectTable );
        }
        if ( pagedConnection->SearchTable.Table != NULL ) {
            SrvFreeTable( &pagedConnection->SearchTable );
        }
        FREE_HEAP( pagedConnection );
    }

    if ( connection != NULL ) {
        if ( connection->FileTable.Table != NULL ) {
            SrvFreeTable( &connection->FileTable );
        }
        DEALLOCATE_NONPAGED_POOL( connection );
        *Connection = NULL;
    }

    return;

} // SrvAllocateConnection

VOID
SrvCloseConnection (
    IN PCONNECTION Connection,
    IN BOOLEAN RemoteDisconnect
    )

/*++

Routine Description:

    This function closes a connection (virtual circuit).

    *** This routine must NOT be entered with the connection lock held!
        It may be entered with the endpoint lock held.

Arguments:

    Connection - Supplies a pointer to a Connection Block

    RemoteDisconnect - Indicates whether this call is being made in
        response to a notification by the transport provider.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PLIST_ENTRY listEntry;
    USHORT i;
    KIRQL oldIrql;
    PRFCB rfcb;

    ASSERT( !ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Connection->Lock)) );

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // If the connection hasn't already been closed, do so now.
    //

    if ( GET_BLOCK_STATE(Connection) == BlockStateActive ) {

#if SRVDBG29
        {
            ULONG conn = (ULONG)Connection;
            if (RemoteDisconnect) conn |= 1;
            if (Connection->DisconnectPending) conn |= 2;
            UpdateConnectionHistory( "CLOS", Connection->Endpoint, Connection );
        }
#endif
        IF_DEBUG(TDI) KdPrint(( "Closing connection (%s) at %p for %z\n",
                    DisconnectReasonText[(USHORT)Connection->DisconnectReason], Connection, (PCSTRING)&Connection->OemClientMachineNameString ));

        IF_DEBUG( ERRORS ) {
            if( RemoteDisconnect == FALSE ) {
                KdPrint(( "SrvCloseConnection: forcibly closing connection %p (%s)\n", Connection, DisconnectReasonText[(USHORT)Connection->DisconnectReason] ));
            }
        }

        SET_BLOCK_STATE( Connection, BlockStateClosing );

        RELEASE_LOCK( &Connection->Lock );

        //
        // If the connection is on the need-resource queue (waiting for
        // a work item) or the disconnect queue (a Disconnect having
        // been indicated by the transport), remove it now, and
        // dereference it.  (Note that the connection can't go away yet,
        // because the initial reference is still there.)
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        //
        // Invalidate the cached connection
        //

        if ( Connection->OnNeedResourceQueue ) {

            SrvRemoveEntryList(
                &SrvNeedResourceQueue,
                &Connection->ListEntry
                );

            Connection->OnNeedResourceQueue = FALSE;
            DEBUG Connection->ReceivePending = FALSE;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            SrvDereferenceConnection( Connection );

        } else if ( Connection->DisconnectPending ) {

            SrvRemoveEntryList(
                &SrvDisconnectQueue,
                &Connection->ListEntry
                );

            DEBUG Connection->DisconnectPending = FALSE;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            SrvDereferenceConnection( Connection );

            //
            // If there's a disconnect pending, then don't try to shut
            // down the connection later.
            //

            RemoteDisconnect = TRUE;

        } else {

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        }

        //
        // If this is not a remote disconnect, issue a TdiDisconnect
        // request now.
        //
        // *** This is currently done as a synchronous request.  It may
        //     be better to do this asynchronously.
        //

        if ( !RemoteDisconnect && !Connection->Endpoint->IsConnectionless ) {
            SrvDoDisconnect( Connection );
        }

        //
        // Close all active sessions.  (This also causes all open files
        // and pending transactions to be closed.)
        //

        SrvCloseSessionsOnConnection( Connection, NULL );

        //
        // Close all active tree connects.
        //
        // *** Reference the tree connect for the same reasons as we
        //     referenced the session; see above.

        tableHeader = &Connection->PagedConnection->TreeConnectTable;

        ACQUIRE_LOCK( &Connection->Lock );

        for ( i = 0; i < tableHeader->TableSize; i++ ) {

            PTREE_CONNECT treeConnect =
                        (PTREE_CONNECT)tableHeader->Table[i].Owner;

            if ( treeConnect != NULL &&
                    GET_BLOCK_STATE( treeConnect ) == BlockStateActive ) {

                SrvReferenceTreeConnect( treeConnect );
                RELEASE_LOCK( &Connection->Lock );

                SrvCloseTreeConnect( treeConnect );

                SrvDereferenceTreeConnect( treeConnect );
                ACQUIRE_LOCK( &Connection->Lock );
            }
        }

        //
        // If there is state associated with a extended security negotiate,
        // free it up.
        //

        if (IS_VALID_CONTEXT_HANDLE(Connection->NegotiateHandle)) {
            DeleteSecurityContext( &Connection->NegotiateHandle );
        }

        SET_INVALID_CONTEXT_HANDLE( Connection->NegotiateHandle );

        RELEASE_LOCK( &Connection->Lock );

        //
        // Cancel all outstanding oplock break requests.
        //

        while ( (listEntry = ExInterlockedRemoveHeadList(
                                &Connection->OplockWorkList,
                                Connection->EndpointSpinLock
                                )) != NULL ) {

            //
            // Remove this work item from the connection queue and
            // return it to the free queue.
            //

            rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
            rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif
            SrvDereferenceRfcb( rfcb );

        }

        //
        // Close RFCBs that are cached after having been closed by the
        // client.
        //

        SrvCloseCachedRfcbsOnConnection( Connection );

        //
        // Dereference the connection (to indicate that it's no longer
        // open).  This may cause the connection block to be deleted.
        //

        SrvDereferenceConnection( Connection );

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Closes );

    } else {

        RELEASE_LOCK( &Connection->Lock );
    }

    return;

} // SrvCloseConnection


VOID
SrvCloseConnectionsFromClient (
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyIfNoSessions
    )

/*++

Routine Description:

    This routine closes all connections from a given remote machine name
    except the connection passed in.  This is used in the Session Setup
    SMB when the client indicates that he believes that he has exactly
    one connection to this server; if there are others, we know that
    they are not valid.

Arguments:

    Connection - Address of connection to keep around.  This is used
        for the machine name.

    OnlyIfNoSessions - Kill off the duplicate connections only if they do
        not have any established sessions.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    PPAGED_CONNECTION testPagedConnection;
    PCONNECTION testConnection;
    BOOLEAN Connectionless = Connection->Endpoint->IsConnectionless == 1;
    BOOLEAN IsIPAddress = (Connection->ClientIPAddress != 0);

    PAGED_CODE( );

    //
    // We need to look at the name of every client for which the server
    // has a connection.  Connection lists are stored off endpoints, so
    // walk the global endpoint list and the list of connections on each
    // endpoint.
    //

    IF_DEBUG(TDI) {
        KdPrint(( "SrvCloseConnectionsFromClient entered for connection "
                    "%p, OemName %z, looking for %wZ\n", Connection,
                    (PCSTRING)&Connection->OemClientMachineNameString,
                    &pagedConnection->ClientMachineNameString));
    }

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {


        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, or if the types don't match,
        // skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ||
             endpoint->IsConnectionless != Connectionless ) {
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // If this endpoint doesn't have the same netbios name as the
        // endpoint of the passed-in connection then skip it.  This is
        // to allow servers to have more than one name on the network.
        //

        if( Connection->Endpoint->TransportAddress.Length !=
            endpoint->TransportAddress.Length ||

            !RtlEqualMemory( Connection->Endpoint->TransportAddress.Buffer,
                             endpoint->TransportAddress.Buffer,
                             endpoint->TransportAddress.Length ) ) {

            //
            // This connection is for an endpoint having a different network
            //  name than does this endpoint.  Skip this endpoint.
            //

            listEntry = listEntry->Flink;
            continue;
        }

#if 0
        //
        // If this endpoint doesn't have the same transport name as the one
        //  on which the client is connecting, then skip it.  This is for
        //  multihomed servers.
        //
        if( Connection->Endpoint->TransportName.Length !=
            endpoint->TransportName.Length ||

            !RtlEqualMemory( Connection->Endpoint->TransportName.Buffer,
                             endpoint->TransportName.Buffer,
                             endpoint->TransportName.Length ) ) {

                //
                // This connection is for an endpoint coming in over a different
                //  stack instance.
                //
                listEntry = listEntry->Flink;
                continue;
        }
#endif

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            testConnection = WalkConnectionTable( endpoint, &index );
            if ( testConnection == NULL ) {
                break;
            }

            if( testConnection == Connection ) {
                //
                // Skip ourselves!
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }

            testPagedConnection = testConnection->PagedConnection;

            if( OnlyIfNoSessions == TRUE &&
                testPagedConnection->CurrentNumberOfSessions != 0 ) {

                //
                // This connection has sessions.  Skip it.
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }


            if( Connectionless ) {
                //
                // Connectionless clients match on IPX address...
                //

                if( !RtlEqualMemory( &Connection->IpxAddress,
                                     &testConnection->IpxAddress,
                                     sizeof(Connection->IpxAddress) ) ) {

                    SrvDereferenceConnection( testConnection );
                    continue;
                }

            } else {

                //
                // If the IP address matches, then nuke this client
                //
                if( IsIPAddress &&
                       Connection->ClientIPAddress == testConnection->ClientIPAddress ) {
                    goto nuke_it;
                }

                //
                // If the computer name matches, then nuke this client
                //
                if ( RtlCompareUnicodeString(
                         &testPagedConnection->ClientMachineNameString,
                         &pagedConnection->ClientMachineNameString,
                         TRUE
                         ) == 0 ) {
                    goto nuke_it;
                }

                //
                // Neither the IP address nor the name match -- skip this client
                //
                SrvDereferenceConnection( testConnection );
                continue;
            }

nuke_it:
            //
            // We found a connection that we need to kill.  We
            // have to release the lock in order to close it.
            //

            RELEASE_LOCK( &SrvEndpointLock );

            IF_DEBUG(TDI) {
                KdPrint(( "SrvCloseConnectionsFromClient closing "
                            "connection %p, MachineNameString %Z\n",
                            testConnection,
                            &testPagedConnection->ClientMachineNameString ));
            }

#if SRVDBG29
            UpdateConnectionHistory( "CFC1", testConnection->Endpoint, testConnection );
            UpdateConnectionHistory( "CFC2", testConnection->Endpoint, Connection );
#endif
            testConnection->DisconnectReason = DisconnectNewSessionSetupOnConnection;
            SrvCloseConnection( testConnection, FALSE );

            ACQUIRE_LOCK( &SrvEndpointLock );

            //
            // Dereference the connection to account for the reference
            // from WalkConnectionTable.
            //

            SrvDereferenceConnection( testConnection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // SrvCloseConnectionsFromClient


VOID
SrvCloseFreeConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function closes a free connection.  This is a connection that
    is not active -- has already been closed via SrvCloseConnection --
    and is no longer needed.

    *** WARNING!  This routine frees the storage occupied by Connection!

Arguments:

    Connection - Supplies a pointer to a Connection Block

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    KIRQL oldIrql;

    ASSERT( Connection->BlockHeader.ReferenceCount == 0 );

    endpoint = Connection->Endpoint;

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // Remove the connection from the endpoint's connection table.
    //

    if ( Connection->Sid != 0 ) {
        ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );
        SrvRemoveEntryTable(
            &endpoint->ConnectionTable,
            Connection->SidIndex
            );
        RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );
        Connection->Sid = 0;
    }

    //
    // Decrement the count of connections for the endpoint.
    //

    ExInterlockedAddUlong(
        &endpoint->TotalConnectionCount,
        (ULONG)-1,
        &GLOBAL_SPIN_LOCK(Fsd)
        );

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // Close the connection file object.  Remove the additional
    // reference.
    //

    if ( !endpoint->IsConnectionless ) {
        SRVDBG_RELEASE_HANDLE( pagedConnection->ConnectionHandle, "CON", 1, Connection );
        SrvNtClose( pagedConnection->ConnectionHandle, FALSE );
        ObDereferenceObject( Connection->FileObject );
    }

    //
    // Dereference the endpoint.
    //

    SrvDereferenceEndpoint( endpoint );

    //
    // Free the storage occupied by the connection.
    //

    SrvFreeConnection( Connection );

    return;

} // SrvCloseFreeConnection


VOID
SrvDereferenceConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function decrements the reference count on a connection.  If the
    reference count goes to zero, the connection block is deleted.

    The connection lock must not be held when this routine is called,
    because the global endpoint lock, which has a lower level, must be
    acquired.

Arguments:

    Connection - Address of connection

Return Value:

    None.

--*/

{
    ULONG oldCount;
    PENDPOINT endpoint;
    KIRQL oldIrql;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    ASSERT( GET_BLOCK_TYPE( Connection ) == BlockTypeConnection );
    ASSERT( (LONG)Connection->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Connection, TRUE );

    //
    // Perform an interlocked decrement of the connection block's
    // reference count.
    //
    // *** Note that we don't hold a lock between the time we decrement
    //     the reference count and the time we delete the connection
    //     block.  Normally this would imply that the FSD could
    //     reference the block in between.  However, the transport
    //     provider guarantees that it won't deliver any more events
    //     after a remote Disconnect event or after a local
    //     TdiDisconnect request, and one of those two things has to
    //     happen before the reference count can go to 0 (see
    //     SrvCloseConnection).
    //

    oldCount = ExInterlockedAddUlong(
                   &Connection->BlockHeader.ReferenceCount,
                   (ULONG)-1,
                   Connection->EndpointSpinLock
                   );
    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing connection %p; old refcnt %lx\n",
                    Connection, oldCount ));
    }

    if ( oldCount == 1 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( GET_BLOCK_STATE(Connection) != BlockStateActive );
#if SRVDBG29
        if ( GET_BLOCK_STATE(Connection) != BlockStateClosing ) {
            KdPrint(( "SRV: Connection is not CLOSING with refcnt 0!\n" ));
            DbgBreakPoint( );
        }
#endif

        //
        // Free the space allocated for client Domain, OS Name, and
        // LAN type.
        //

        if ( Connection->ClientOSType.Buffer != NULL ) {
            DEALLOCATE_NONPAGED_POOL( Connection->ClientOSType.Buffer );
            Connection->ClientOSType.Buffer = NULL;
        }

        //
        // Keep the WORK_QUEUE statistic correct
        //
        if( Connection->CurrentWorkQueue )
            InterlockedDecrement( &Connection->CurrentWorkQueue->CurrentClients );

        // (Always TRUE) ASSERT( Connection->CurrentWorkQueue->CurrentClients >= 0 );

        endpoint = Connection->Endpoint;

        ACQUIRE_LOCK( &SrvEndpointLock );

        //
        // If the connection hasn't been marked as not reusable (e.g.,
        // because a disconnect failed), and the endpoint isn't closing,
        // and it isn't already "full" of free connections, put this
        // connection on the endpoint's free connection list.
        // Otherwise, close the connection file object and free the
        // connection block.
        //

        if ( !Connection->NotReusable &&
             (GET_BLOCK_STATE(endpoint) == BlockStateActive) &&
             (endpoint->FreeConnectionCount < SrvFreeConnectionMaximum) ) {

            //
            // Reinitialize the connection state.
            //
            // !!! Should probably reset the connection's table sizes,
            //     if they've grown.
            //

            SET_BLOCK_STATE( Connection, BlockStateInitializing );
            pagedConnection->LinkInfoValidTime.QuadPart = 0;
            pagedConnection->Throughput.QuadPart = 0;
            pagedConnection->Delay.QuadPart = 0;
            pagedConnection->CurrentNumberOfSessions = 0;
            pagedConnection->ClientMachineNameString.Length = 0;
            Connection->ClientCapabilities = 0;
            Connection->SmbDialect = SmbDialectIllegal;
            Connection->DisconnectPending = FALSE;
            Connection->ReceivePending = FALSE;
            Connection->OplocksAlwaysDisabled = FALSE;
            Connection->CachedFid = (ULONG)-1;
            Connection->InProgressWorkContextCount = 0;
            Connection->IsConnectionSuspect = FALSE;
            Connection->DisconnectReason = DisconnectReasons;
            Connection->OperationsPendingOnTransport = 0;

            //
            // Put the connection on the free list.
            //

            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

#if SRVDBG29
            UpdateConnectionHistory( "KEEP", endpoint, Connection );
#endif
            SrvInsertTailList(
                &endpoint->FreeConnectionList,
                &Connection->EndpointFreeListEntry
                );

            endpoint->FreeConnectionCount++;

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            RELEASE_LOCK( &SrvEndpointLock );

        } else {

            RELEASE_LOCK( &SrvEndpointLock );

            SrvCloseFreeConnection( Connection );

        }

    }

    return;

} // SrvDereferenceConnection


VOID
SrvFreeConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function returns a Connection Block to the system nonpaged
    pool.

Arguments:

    Connection - Address of connection

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY listEntry;
    PNONPAGED_HEADER header;
    PTRANSACTION transaction;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

#if 0
    //
    // ENSURE WE ARE NOT STILL IN THE CONNECTION TABLE FOR THE ENDPOINT!
    //
    if( Connection->Endpoint ) {

        PTABLE_HEADER tableHeader = &Connection->Endpoint->ConnectionTable;
        USHORT i;
        KIRQL oldIrql;

        ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
        for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
            ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }

        for( i = 0; i < tableHeader->TableSize; i++ ) {
            if( (PCONNECTION)tableHeader->Table[i].Owner == Connection ) {

                DbgPrint( "SRV: SrvFreeConnection(%p), but connection still in endpoint %p ConnectionTable\n",
                    Connection, Connection->Endpoint );

                DbgPrint( "    Entry number %d, addr %p\n", i, &tableHeader->Table[i] );
                DbgPrint( "    Connection->Sid %X, IPXSID %d\n", Connection->Sid, IPXSID_INDEX(Connection->Sid));

                DbgBreakPoint();
                break;
            }
        }

        for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
    }
#endif

    //
    // Free cached transactions.
    //

    listEntry = ExInterlockedPopEntrySList( &Connection->CachedTransactionList,
                                            &Connection->SpinLock );

    while ( listEntry != NULL ) {

        header = CONTAINING_RECORD( listEntry, NONPAGED_HEADER, ListEntry );
        transaction = header->PagedBlock;

        DEALLOCATE_NONPAGED_POOL( header );
        FREE_HEAP( transaction );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Frees );

        listEntry = ExInterlockedPopEntrySList(
                        &Connection->CachedTransactionList,
                        &Connection->SpinLock );

    }

    //
    // Free the search, session, tree, and file tables.
    //

    SrvFreeTable( &pagedConnection->SearchTable );
    SrvFreeTable( &Connection->FileTable );
    SrvFreeTable( &pagedConnection->TreeConnectTable );
    SrvFreeTable( &pagedConnection->SessionTable );

    //
    // Free the IPX saved response buffer, if there is one.
    //

    if ( Connection->DirectHostIpx == TRUE &&
         Connection->LastResponse != Connection->BuiltinSavedResponse ) {

        DEALLOCATE_NONPAGED_POOL( Connection->LastResponse );
    }

    //
    // Delete the lock on the connection.
    //

    DELETE_LOCK( &Connection->Lock );

    //
    // Delete the license server lock
    //
    DELETE_LOCK( &Connection->LicenseLock );

    //
    // Free the connection block.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Connection, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Connection->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Connection );

    FREE_HEAP( pagedConnection );
    DEALLOCATE_NONPAGED_POOL( Connection );
    IF_DEBUG(HEAP) {
        KdPrint(( "SrvFreeConnection: Freed connection block at %p\n",
                    Connection ));
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.ConnectionInfo.Frees );

    return;

} // SrvFreeConnection

#if DBG

NTSTATUS
SrvQueryConnections (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesWritten
    )

{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PBLOCK_INFORMATION blockInfo = Buffer;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;

    *BytesWritten = 0;

    //
    // We need to look at the name of every client for which the server
    // has a connection.  Connection lists are stored off endpoints, so
    // walk the global endpoint list and the list of connections on each
    // endpoint.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Put information about the endpoint into the output buffer.
        //

        if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
            blockInfo->Block = endpoint;
            blockInfo->BlockType = (ULONG)BlockTypeEndpoint;
            blockInfo->BlockState = (ULONG)endpoint->BlockHeader.State;
            blockInfo->ReferenceCount = endpoint->BlockHeader.ReferenceCount;
            blockInfo++;
        } else {
            SrvDereferenceEndpoint( endpoint );
            RELEASE_LOCK( &SrvEndpointLock );
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // Walk the connection table, writing information about each
        // connection to the output buffer.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
                blockInfo->Block = connection;
                blockInfo->BlockType = (ULONG)BlockTypeConnection;
                blockInfo->BlockState = (ULONG)connection->BlockHeader.State;
                blockInfo->ReferenceCount =
                    connection->BlockHeader.ReferenceCount;
                blockInfo++;
                SrvDereferenceConnection( connection );
            } else {
                SrvDereferenceConnection( connection );
                SrvDereferenceEndpoint( endpoint );
                RELEASE_LOCK( &SrvEndpointLock );
                return STATUS_BUFFER_OVERFLOW;
            }

        } // walk connection list

        //
        // Walk the free connection list, writing information about each
        // connection to the output buffer.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        for ( connectionListEntry = endpoint->FreeConnectionList.Flink;
              connectionListEntry != &endpoint->FreeConnectionList;
              connectionListEntry = connectionListEntry->Flink ) {

            connection = CONTAINING_RECORD(
                            connectionListEntry,
                            CONNECTION,
                            EndpointFreeListEntry
                            );

            if ( (PCHAR)(blockInfo + 1) <= (PCHAR)Buffer + BufferLength ) {
                blockInfo->Block = connection;
                blockInfo->BlockType = (ULONG)BlockTypeConnection;
                blockInfo->BlockState = (ULONG)connection->BlockHeader.State;
                blockInfo->ReferenceCount =
                    connection->BlockHeader.ReferenceCount;
                blockInfo++;
            } else {
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
                RELEASE_LOCK( &SrvEndpointLock );
                return STATUS_BUFFER_OVERFLOW;
            }

        } // walk free connection list

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

    *BytesWritten = (ULONG)((PCHAR)blockInfo - (PCHAR)Buffer);

    return STATUS_SUCCESS;

} // SrvQueryConnections
#endif // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkdir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkdir.c

Abstract:

    This module implements routines for managing cached directory names

Author:

    Isaac Heizer

Revision History:

--*/

#include "precomp.h"
#include "blkdir.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKDIR

BOOLEAN
SrvIsDirectoryCached (
    IN  PWORK_CONTEXT     WorkContext,
    IN  PUNICODE_STRING   DirectoryName
)
{
    PLIST_ENTRY listEntry;
    PCACHED_DIRECTORY cd;
    ULONG directoryNameHashValue;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;
    LARGE_INTEGER timeNow;

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //

    if( connection->CachedDirectoryCount == 0 || !SMB_IS_UNICODE( WorkContext ) ) {
        return FALSE;
    }

    KeQueryTickCount( &timeNow );
    timeNow.LowPart -= (SrvFiveSecondTickCount >> 1 );

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

top:
    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // Is this element too old?
        //
        if( cd->TimeStamp < timeNow.LowPart ) {
            //
            // This element is more than 2.5 seconds old.  Toss it out
            //
            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
            goto top;
        }

        if( cd->Tid != WorkContext->TreeConnect->Tid ) {
            continue;
        }

        //
        // Is the requested entry a subdir of this cache entry?
        //
        if( DirectoryName->Length < cd->DirectoryName.Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              DirectoryName->Length ) == DirectoryName->Length &&
            cd->DirectoryName.Buffer[ DirectoryName->Length / sizeof( WCHAR ) ] == L'\\' ) {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            return TRUE;

        //
        // Not a subdir -- is it an exact match?
        //
        } else  if( DirectoryName->Length == cd->DirectoryName.Length &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return TRUE;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return FALSE;
}

VOID
SrvCacheDirectoryName (
    IN  PWORK_CONTEXT      WorkContext,
    IN  PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

    This routine remembers 'DirectoryName' for further fast processing of the CheckPath SMB

Arguments:

    WorkContext - Pointer to the work context block

    DirectoryName - Fully canonicalized name of the directory we're caching

++*/

{
    CLONG blockLength;
    PCACHED_DIRECTORY cd;
    KIRQL oldIrql;
    PCONNECTION connection = WorkContext->Connection;
    PLIST_ENTRY listEntry;
    LARGE_INTEGER timeNow;
    USHORT tid;

    if( SrvMaxCachedDirectory == 0 ) {
        return;
    }

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //
    if( !SMB_IS_UNICODE( WorkContext ) ) {
        return;
    }

    KeQueryTickCount( &timeNow );
    timeNow.LowPart -= ( SrvFiveSecondTickCount >> 1 );

    tid = WorkContext->TreeConnect->Tid;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Search the directory cache and see if this directory is already cached. If so,
    //  don't cache it again.
    //

top:
    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // Is this element too old?
        //
        if( cd->TimeStamp < timeNow.LowPart ) {
            //
            // This element is more than 2.5 seconds old.  Toss it out
            //
            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
            goto top;
        }

        if( cd->Tid != tid ) {
            continue;
        }

        //
        // Is the new entry a subdir of this cache entry?
        //
        if( DirectoryName->Length < cd->DirectoryName.Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              DirectoryName->Length ) == DirectoryName->Length &&
            cd->DirectoryName.Buffer[ DirectoryName->Length / sizeof( WCHAR ) ] == L'\\' ) {

            //
            // It is a subdir -- no need to cache it again
            //
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            return;
        }

        //
        // Is the cache entry a subdir of the new entry?
        //
        if( cd->DirectoryName.Length < DirectoryName->Length &&
            RtlCompareMemory( DirectoryName->Buffer, cd->DirectoryName.Buffer,
                              cd->DirectoryName.Length ) == cd->DirectoryName.Length &&
            DirectoryName->Buffer[ cd->DirectoryName.Length / sizeof( WCHAR ) ] == L'\\' ) {

            //
            // We can remove this entry
            //

            RemoveEntryList( listEntry );
            connection->CachedDirectoryCount--;
            DEALLOCATE_NONPAGED_POOL( cd );
    
            //
            // We want to cache this new longer entry
            //
            break;
        }

        //
        // Not a subdir -- is it an exact match?
        //
        if( cd->DirectoryName.Length == DirectoryName->Length &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            //
            // This entry is already in the cache -- no need to recache
            //
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;
        }
    }

    //
    // This directory name is not already in the cache.  So add it.
    //

    blockLength = sizeof( CACHED_DIRECTORY ) + DirectoryName->Length + sizeof(WCHAR);

    cd = ALLOCATE_NONPAGED_POOL( blockLength, BlockTypeCachedDirectory );

    if( cd == NULL ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvCacheDirectoryName: Unable to allocate %d bytes from pool",
            blockLength,
            NULL
            );

        return;
    }

    cd->Type = BlockTypeCachedDirectory;
    cd->State = BlockStateActive;
    cd->Size = (USHORT)blockLength;
    // cd->ReferenceCount = 1;              // not used

    //
    // Set the timestamp of this entry.  Remember, we subtracted 
    //  ticks up above from timeNow -- put them back in now.
    //
    cd->TimeStamp = timeNow.LowPart + ( SrvFiveSecondTickCount >> 1 );

    //
    // Store the directory name as it was passed into us
    //
    cd->DirectoryName.Length = DirectoryName->Length;
    cd->DirectoryName.MaximumLength = (USHORT)DirectoryName->MaximumLength;
    cd->DirectoryName.Buffer = (PWCH)(cd + 1);
    RtlCopyMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer, DirectoryName->Length );

    cd->Tid = tid;

    InsertHeadList(
        &connection->CachedDirectoryList,
        &cd->ListEntry
    );

    //
    // Check the number of elements in the cache.  If getting too large, close oldest one.
    //
    if( connection->CachedDirectoryCount++ < SrvMaxCachedDirectory ) {
        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        return;
    }

    //
    // Remove the last entry from the cache
    //
    cd = CONTAINING_RECORD(
                connection->CachedDirectoryList.Blink,
                CACHED_DIRECTORY,
                ListEntry
             );

    RemoveEntryList( &cd->ListEntry );
    connection->CachedDirectoryCount--;

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    DEALLOCATE_NONPAGED_POOL( cd );

    return;
}

VOID
SrvRemoveCachedDirectoryName(
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
)
{
    PLIST_ENTRY listEntry;
    PCACHED_DIRECTORY cd;
    ULONG directoryNameHashValue;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;
    USHORT tid;

    if( connection->CachedDirectoryCount == 0 ) {
        return;
    }

    //
    // DirectoryName must point to memory in nonpaged pool, else we can't touch
    //   it under spinlock control.  If the incomming SMB is UNICODE, we know that
    //   the name is in the smb buffer, and is therefore in nonpaged pool.  Otherwise
    //   we can't trust it and we're better off just not trying to cache it.
    //
    if( !SMB_IS_UNICODE( WorkContext ) ) {
        return;
    }

    COMPUTE_STRING_HASH( DirectoryName, &directoryNameHashValue );

    tid = WorkContext->TreeConnect->Tid;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedDirectoryList.Flink;
          listEntry != &connection->CachedDirectoryList;
          listEntry = listEntry->Flink ) {

        cd = CONTAINING_RECORD( listEntry, CACHED_DIRECTORY, ListEntry );

        //
        // See if this entry is an exact match for what was requested
        //
        if( cd->DirectoryName.Length == DirectoryName->Length &&
            cd->Tid == tid &&
            RtlCompareMemory( cd->DirectoryName.Buffer, DirectoryName->Buffer,
                              DirectoryName->Length ) == DirectoryName->Length ) {

            //
            // Remove this entry from the list and adjust the count
            //
            RemoveEntryList( &cd->ListEntry );
            connection->CachedDirectoryCount--;

            ASSERT( (LONG)connection->CachedDirectoryCount >= 0 );

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            DEALLOCATE_NONPAGED_POOL( cd );

            return;
        }

    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;
}

VOID
SrvCloseCachedDirectoryEntries(
    IN PCONNECTION Connection
    )
/*++
Routine Description:

    This routine closes all the cached directory entries on the connection

Arguments:

    Connection - Pointer to the connection structure having the cache

++*/
{
    KIRQL oldIrql;
    PCACHED_DIRECTORY cd;

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &oldIrql );

    while( Connection->CachedDirectoryCount > 0 ) {

        cd = CONTAINING_RECORD( Connection->CachedDirectoryList.Flink, CACHED_DIRECTORY, ListEntry );

        RemoveEntryList( &cd->ListEntry );

        Connection->CachedDirectoryCount--;

        DEALLOCATE_NONPAGED_POOL( cd );
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\access.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    access.c

Abstract:

    This module contains routines for interfacing to the security
    system in NT.

--*/

#include "precomp.h"
#include "access.tmh"
#pragma hdrstop
#include <ntlmsp.h>

#define BugCheckFileId SRV_FILE_ACCESS

#if DBG
ULONG SrvLogonCount = 0;
ULONG SrvNullLogonCount = 0;
#endif


#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

typedef struct _LOGON_INFO {
    PWCH WorkstationName;
    ULONG WorkstationNameLength;
    PWCH DomainName;
    ULONG DomainNameLength;
    PWCH UserName;
    ULONG UserNameLength;
    PCHAR CaseInsensitivePassword;
    ULONG CaseInsensitivePasswordLength;
    PCHAR CaseSensitivePassword;
    ULONG CaseSensitivePasswordLength;
    CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH];
    LUID LogonId;
    CtxtHandle  Token;
    USHORT Uid;
    BOOLEAN     HaveHandle;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogOffTime;
    USHORT Action;
    BOOLEAN GuestLogon;
    BOOLEAN EncryptedLogon;
    BOOLEAN NtSmbs;
    BOOLEAN IsNullSession;
    BOOLEAN IsAdmin;
    CHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    CHAR LanManSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} LOGON_INFO, *PLOGON_INFO;

NTSTATUS
DoUserLogon (
    IN PLOGON_INFO LogonInfo,
    IN BOOLEAN SecuritySignatureDesired,
    IN PCONNECTION Connection OPTIONAL,
    IN PSESSION Session
    );

NTSTATUS
AcquireExtensibleSecurityCredentials (
    VOID
    );

NTSTATUS
SrvGetLogonId(
    PCtxtHandle  Handle,
    PLUID LogonId
    );

ULONG SrvHaveCreds = 0;

//
// 24 hours short of never, in case any utc/local conversions are done
//
#define SRV_NEVER_TIME  (0x7FFFFFFFFFFFFFFFI64 - 0xC92A69C000I64)

#define HAVENTLM        1
#define HAVEEXTENDED    2

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvValidateUser )
#pragma alloc_text( PAGE, DoUserLogon )
#pragma alloc_text( PAGE, SrvIsAdmin )
#pragma alloc_text( PAGE, SrvFreeSecurityContexts )
#pragma alloc_text( PAGE, AcquireLMCredentials )
#pragma alloc_text( PAGE, AcquireExtensibleSecurityCredentials )
#pragma alloc_text( PAGE, SrvValidateSecurityBuffer )
#pragma alloc_text( PAGE, SrvGetUserAndDomainName )
#pragma alloc_text( PAGE, SrvReleaseUserAndDomainName )
#pragma alloc_text( PAGE, SrvGetExtensibleSecurityNegotiateBuffer )
#pragma alloc_text( PAGE, SrvGetLogonId )
#pragma alloc_text( PAGE, SrvInitializeSmbSecuritySignature )
#pragma alloc_text( PAGE, SrvAddSecurityCredentials )
#endif


NTSTATUS
SrvValidateUser (
    OUT CtxtHandle *Token,
    IN PSESSION Session OPTIONAL,
    IN PCONNECTION Connection OPTIONAL,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PCHAR CaseInsensitivePassword,
    IN CLONG CaseInsensitivePasswordLength,
    IN PCHAR CaseSensitivePassword OPTIONAL,
    IN CLONG CaseSensitivePasswordLength,
    IN BOOLEAN SmbSecuritySignatureIfPossible,
    OUT PUSHORT Action  OPTIONAL
    )

/*++

Routine Description:

    Validates a username/password combination by interfacing to the
    security subsystem.

Arguments:

    Session - A pointer to a session block so that this routine can
        insert a user token.

    Connection - A pointer to the connection this user is on.

    UserName - ASCIIZ string corresponding to the user name to validate.

    CaseInsensitivePassword - ASCII (not ASCIIZ) string containing
        password for the user.

    CaseInsensitivePasswordLength - Length of Password, in bytes.
        This includes the null terminator when the password is not
        encrypted.

    CaseSensitivePassword - a mixed case, Unicode version of the password.
        This is only supplied by NT clients; for downlevel clients,
        it will be NULL.

    CaseSensitivePasswordLength - the length of the case-sensitive password.

    Action - This is part of the sessionsetupandx response.

Return Value:

    NTSTATUS from the security system.

--*/

{
    NTSTATUS status;
    LOGON_INFO logonInfo;
    PPAGED_CONNECTION pagedConnection;
    UNICODE_STRING domainName;

    PAGED_CODE( );

    INVALIDATE_SECURITY_HANDLE( *Token );

    if( ARGUMENT_PRESENT( Session ) ) {
        INVALIDATE_SECURITY_HANDLE( Session->UserHandle );
    }

    RtlZeroMemory( &logonInfo, sizeof( logonInfo ) );

    //
    // Load input parameters for DoUserLogon into the LOGON_INFO struct.
    //
    // If this is the server's initialization attempt at creating a null
    // session, then the Connection and Session pointers will be NULL.
    //

    domainName.Buffer = NULL;
    domainName.Length = 0;

    if ( ARGUMENT_PRESENT(Connection) ) {

        pagedConnection = Connection->PagedConnection;

        logonInfo.WorkstationName =
                    pagedConnection->ClientMachineNameString.Buffer;
        logonInfo.WorkstationNameLength =
                    pagedConnection->ClientMachineNameString.Length;

        RtlCopyMemory(
            logonInfo.EncryptionKey,
            pagedConnection->EncryptionKey,
            MSV1_0_CHALLENGE_LENGTH
            );

        logonInfo.NtSmbs = CLIENT_CAPABLE_OF( NT_SMBS, Connection );

        ASSERT( ARGUMENT_PRESENT(Session) );

        SrvGetUserAndDomainName( Session, NULL, &domainName );

        logonInfo.DomainName = domainName.Buffer;
        logonInfo.DomainNameLength = domainName.Length;

    } else {

        ASSERT( !ARGUMENT_PRESENT(Session) );

        logonInfo.WorkstationName = StrNull;
        logonInfo.DomainName = StrNull;
    }

    if ( ARGUMENT_PRESENT(UserName) ) {
        logonInfo.UserName = UserName->Buffer;
        logonInfo.UserNameLength = UserName->Length;
    } else {
        logonInfo.UserName = StrNull;
    }

    logonInfo.CaseSensitivePassword = CaseSensitivePassword;
    logonInfo.CaseSensitivePasswordLength = CaseSensitivePasswordLength;

    logonInfo.CaseInsensitivePassword = CaseInsensitivePassword;
    logonInfo.CaseInsensitivePasswordLength = CaseInsensitivePasswordLength;

    INVALIDATE_SECURITY_HANDLE( logonInfo.Token );

    if ( ARGUMENT_PRESENT(Action) ) {
        logonInfo.Action = *Action;
    }

    if( ARGUMENT_PRESENT(Session) ) {
        logonInfo.Uid = Session->Uid;
    }

    //
    // Attempt the logon.
    //

    status = DoUserLogon( &logonInfo, SmbSecuritySignatureIfPossible, Connection, Session );

    if( logonInfo.HaveHandle ) {
        *Token = logonInfo.Token;
    }

    if( domainName.Buffer ) {
        SrvReleaseUserAndDomainName( Session, NULL, &domainName );
    }

    if ( NT_SUCCESS(status) ) {

        //
        // The logon succeeded.  Save output data.
        //

        if ( ARGUMENT_PRESENT(Session) ) {

            Session->LogonId = logonInfo.LogonId;

            Session->KickOffTime = logonInfo.KickOffTime;
            Session->LogOffTime = logonInfo.LogOffTime;

            Session->GuestLogon = logonInfo.GuestLogon;
            Session->EncryptedLogon = logonInfo.EncryptedLogon;
            Session->IsNullSession = logonInfo.IsNullSession;
            Session->IsAdmin = logonInfo.IsAdmin;

            if( logonInfo.HaveHandle ) {
                Session->UserHandle = logonInfo.Token;
            } else {
                INVALIDATE_SECURITY_HANDLE( Session->UserHandle );
            }

            RtlCopyMemory(
                Session->NtUserSessionKey,
                logonInfo.NtUserSessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );
            RtlCopyMemory(
                Session->LanManSessionKey,
                logonInfo.LanManSessionKey,
                MSV1_0_LANMAN_SESSION_KEY_LENGTH
                );

            SET_BLOCK_STATE( Session, BlockStateActive );
        }

        if ( ARGUMENT_PRESENT(Action) ) {
            *Action = logonInfo.Action;
            if( logonInfo.GuestLogon ) {
                *Action |= SMB_SETUP_GUEST;
            }
        }
    }

    return status;

} // SrvValidateUser


NTSTATUS
DoUserLogon (
    IN PLOGON_INFO LogonInfo,
    IN BOOLEAN SecuritySignatureDesired,
    IN PCONNECTION Connection OPTIONAL,
    IN OPTIONAL PSESSION Session
    )

/*++

Routine Description:

    Validates a username/password combination by interfacing to the
    security subsystem.

Arguments:

    LogonInfo - Pointer to a block containing in/out information about
        the logon.

Return Value:

    NTSTATUS from the security system.

--*/

{
    NTSTATUS status, subStatus;
    ULONG actualUserInfoBufferLength;
    ULONG oldSessionCount;
    LUID LogonId;
    ULONG Catts = 0;
    LARGE_INTEGER Expiry;
    ULONG BufferOffset;
    SecBufferDesc InputToken;
    SecBuffer InputBuffers[2];
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;
    PNTLM_AUTHENTICATE_MESSAGE NtlmInToken = NULL;
    PAUTHENTICATE_MESSAGE InToken = NULL;
    PNTLM_ACCEPT_RESPONSE OutToken = NULL;
    ULONG NtlmInTokenSize;
    ULONG InTokenSize;
    ULONG OutTokenSize;
    ULONG_PTR AllocateSize;

    ULONG profileBufferLength;

    PAGED_CODE( );

    LogonInfo->IsNullSession = FALSE;
    LogonInfo->IsAdmin = FALSE;

#if DBG
    SrvLogonCount++;
#endif

    //
    // If this is a null session request, use the cached null session
    // token, which was created during server startup ( if we got one! )
    //

    if ( (LogonInfo->UserNameLength == 0) &&
         (LogonInfo->CaseSensitivePasswordLength == 0) &&
         ( (LogonInfo->CaseInsensitivePasswordLength == 0) ||
           ( (LogonInfo->CaseInsensitivePasswordLength == 1) &&
             (*LogonInfo->CaseInsensitivePassword == '\0') ) ) ) {

        if( CONTEXT_NULL( SrvNullSessionToken ) ) {

            if( SrvFspActive ) {
                return STATUS_ACCESS_DENIED;
            }

        } else {

            LogonInfo->IsNullSession = TRUE;

#if DBG
            SrvNullLogonCount++;
#endif

            LogonInfo->HaveHandle = TRUE;
            LogonInfo->Token = SrvNullSessionToken;

            LogonInfo->KickOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
            LogonInfo->LogOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;

            LogonInfo->GuestLogon = FALSE;
            LogonInfo->EncryptedLogon = FALSE;

            return STATUS_SUCCESS;
        }
    }

    //
    // First make sure we have a credential handle
    //

    if ((SrvHaveCreds & HAVENTLM) == 0) {

        status = AcquireLMCredentials();

        if (!NT_SUCCESS(status)) {
            goto error_exit;
        }
    }

    //
    // Figure out how big a buffer we need.  We put all the messages
    // in one buffer for efficiency's sake.
    //

    NtlmInTokenSize = sizeof(NTLM_AUTHENTICATE_MESSAGE);
    NtlmInTokenSize = (NtlmInTokenSize + 3) & 0xfffffffc;

    InTokenSize = sizeof(AUTHENTICATE_MESSAGE) +
            LogonInfo->UserNameLength +
            LogonInfo->WorkstationNameLength +
            LogonInfo->DomainNameLength +
            LogonInfo->CaseInsensitivePasswordLength +
            ROUND_UP_COUNT(LogonInfo->CaseSensitivePasswordLength, sizeof(USHORT));


    InTokenSize = (InTokenSize + 3) & 0xfffffffc;

    OutTokenSize = sizeof(NTLM_ACCEPT_RESPONSE);
    OutTokenSize = (OutTokenSize + 3) & 0xfffffffc;

    //
    // Round this up to 8 byte boundary because the out token needs to be
    // quad word aligned for the LARGE_INTEGER.
    //

    AllocateSize = ((NtlmInTokenSize + InTokenSize + 7) & 0xfffffff8) + OutTokenSize;

    status = STATUS_SUCCESS ;

    InToken = ExAllocatePool( PagedPool, AllocateSize );

    if ( InToken == NULL )
    {
        status = STATUS_NO_MEMORY ;

    }

    if ( !NT_SUCCESS(status) ) {

        actualUserInfoBufferLength = (ULONG)AllocateSize;

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvValidateUser: ExAllocatePool failed: %X\n.",
            status,
            NULL
            );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_VIRTUAL_MEMORY,
            status,
            &actualUserInfoBufferLength,
            sizeof(ULONG),
            NULL,
            0
            );

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto error_exit;
    }

    //
    // Zero the input tokens
    //

    RtlZeroMemory(
        InToken,
        InTokenSize + NtlmInTokenSize
        );

    NtlmInToken = (PNTLM_AUTHENTICATE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
    OutToken = (PNTLM_ACCEPT_RESPONSE) ((PUCHAR) (((ULONG_PTR) NtlmInToken + NtlmInTokenSize + 7) & ~7));

    //
    // First set up the NtlmInToken, since it is the easiest.
    //

    RtlCopyMemory(
        NtlmInToken->ChallengeToClient,
        LogonInfo->EncryptionKey,
        MSV1_0_CHALLENGE_LENGTH
        );

    NtlmInToken->ParameterControl = 0;


    //
    // Okay, now for the tought part - marshalling the AUTHENTICATE_MESSAGE
    //

    RtlCopyMemory(  InToken->Signature,
                    NTLMSSP_SIGNATURE,
                    sizeof(NTLMSSP_SIGNATURE));

    InToken->MessageType = NtLmAuthenticate;

    BufferOffset = sizeof(AUTHENTICATE_MESSAGE);

    //
    // LM password - case insensitive
    //

    InToken->LmChallengeResponse.Buffer = BufferOffset;
    InToken->LmChallengeResponse.Length =
        InToken->LmChallengeResponse.MaximumLength =
            (USHORT) LogonInfo->CaseInsensitivePasswordLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->CaseInsensitivePassword,
                    LogonInfo->CaseInsensitivePasswordLength);

    BufferOffset += ROUND_UP_COUNT(LogonInfo->CaseInsensitivePasswordLength, sizeof(USHORT));

    //
    // NT password - case sensitive
    //

    InToken->NtChallengeResponse.Buffer = BufferOffset;
    InToken->NtChallengeResponse.Length =
        InToken->NtChallengeResponse.MaximumLength =
            (USHORT) LogonInfo->CaseSensitivePasswordLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->CaseSensitivePassword,
                    LogonInfo->CaseSensitivePasswordLength);

    BufferOffset += LogonInfo->CaseSensitivePasswordLength;

    //
    // Domain Name
    //

    InToken->DomainName.Buffer = BufferOffset;
    InToken->DomainName.Length =
        InToken->DomainName.MaximumLength =
            (USHORT) LogonInfo->DomainNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->DomainName,
                    LogonInfo->DomainNameLength);

    BufferOffset += LogonInfo->DomainNameLength;

    //
    // Workstation Name
    //

    InToken->Workstation.Buffer = BufferOffset;
    InToken->Workstation.Length =
        InToken->Workstation.MaximumLength =
            (USHORT) LogonInfo->WorkstationNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->WorkstationName,
                    LogonInfo->WorkstationNameLength);

    BufferOffset += LogonInfo->WorkstationNameLength;


    //
    // User Name
    //

    InToken->UserName.Buffer = BufferOffset;
    InToken->UserName.Length =
        InToken->UserName.MaximumLength =
            (USHORT) LogonInfo->UserNameLength;

    RtlCopyMemory(  BufferOffset + (PCHAR) InToken,
                    LogonInfo->UserName,
                    LogonInfo->UserNameLength);

    BufferOffset += LogonInfo->UserNameLength;



    //
    // Setup all the buffers properly
    //

    InputToken.pBuffers = InputBuffers;
    InputToken.cBuffers = 2;
    InputToken.ulVersion = 0;
    InputBuffers[0].pvBuffer = InToken;
    InputBuffers[0].cbBuffer = InTokenSize;
    InputBuffers[0].BufferType = SECBUFFER_TOKEN;
    InputBuffers[1].pvBuffer = NtlmInToken;
    InputBuffers[1].cbBuffer = NtlmInTokenSize;
    InputBuffers[1].BufferType = SECBUFFER_TOKEN;

    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = OutToken;
    OutputBuffer.cbBuffer = OutTokenSize;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    SrvStatistics.SessionLogonAttempts++;

    status = AcceptSecurityContext(
                &SrvLmLsaHandle,
                NULL,
                &InputToken,
                ASC_REQ_ALLOW_NON_USER_LOGONS | ASC_REQ_ALLOW_NULL_SESSION,
                SECURITY_NATIVE_DREP,
                &LogonInfo->Token,
                &OutputToken,
                &Catts,
                (PTimeStamp) &Expiry
                );

    status = MapSecurityError( status );

    if ( !NT_SUCCESS(status) ) {

        INVALIDATE_SECURITY_HANDLE( LogonInfo->Token );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvValidateUser: LsaLogonUser failed: %X",
            status,
            NULL
            );

        ExFreePool( InToken );


        goto error_exit;
    }

    LogonInfo->KickOffTime = OutToken->KickoffTime;
    // Sspi will return time in LocalTime, convert to SystemTime
    ExLocalTimeToSystemTime( &Expiry, &LogonInfo->LogOffTime );
    //LogonInfo->LogOffTime = Expiry;
    LogonInfo->GuestLogon = (BOOLEAN)(OutToken->UserFlags & LOGON_GUEST);
    LogonInfo->EncryptedLogon = (BOOLEAN)!(OutToken->UserFlags & LOGON_NOENCRYPTION);
    LogonInfo->LogonId = OutToken->LogonId;
    LogonInfo->HaveHandle = TRUE;

    if ( (OutToken->UserFlags & LOGON_USED_LM_PASSWORD) &&
        LogonInfo->NtSmbs ) {

        ASSERT( MSV1_0_USER_SESSION_KEY_LENGTH >=
                MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        RtlZeroMemory(
            LogonInfo->NtUserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            LogonInfo->NtUserSessionKey,
            OutToken->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

        //
        // Turn on bit 1 to tell the client that we are using
        // the lm session key instead of the user session key.
        //

        LogonInfo->Action |= SMB_SETUP_USE_LANMAN_KEY;

    } else {

        RtlCopyMemory(
            LogonInfo->NtUserSessionKey,
            OutToken->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

    }

    //
    // If we have a session and we didn't do a guest logon, start up
    //   security signatures if requested
    //

    if ( ARGUMENT_PRESENT( Connection ) &&
        SecuritySignatureDesired &&
        LogonInfo->GuestLogon == FALSE &&
        ( SrvSmbSecuritySignaturesRequired ||
          SrvEnableW9xSecuritySignatures   ||
          CLIENT_CAPABLE_OF(NT_STATUS, Connection) )
        )
        {

        SrvInitializeSmbSecuritySignature(
                    Connection,
                    LogonInfo->NtUserSessionKey,
                    ((OutToken->UserFlags & LOGON_USED_LM_PASSWORD) != 0) ?
                        LogonInfo->CaseInsensitivePassword :
                            LogonInfo->CaseSensitivePassword,
                    ((OutToken->UserFlags & LOGON_USED_LM_PASSWORD) != 0) ?
                        LogonInfo->CaseInsensitivePasswordLength :
                            LogonInfo->CaseSensitivePasswordLength
                    );
    }

    RtlCopyMemory(
        LogonInfo->LanManSessionKey,
        OutToken->LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    ExFreePool( InToken );

    //
    // Note whether or not this user is an administrator
    //

    LogonInfo->IsAdmin = SrvIsAdmin( LogonInfo->Token );

    //
    // One last check:  Is our session count being exceeded?
    //   We will let the session be exceeded by 1 iff the client
    //   is an administrator.
    //

    if( LogonInfo->IsNullSession == FALSE ) {

        oldSessionCount = ExInterlockedAddUlong(
                          &SrvStatistics.CurrentNumberOfSessions,
                          1,
                          &GLOBAL_SPIN_LOCK(Statistics)
                          );

        SrvInhibitIdlePowerDown();

        if ( ARGUMENT_PRESENT(Session) && (!Session->IsSessionExpired && oldSessionCount >= SrvMaxUsers) ) {
            if( oldSessionCount != SrvMaxUsers || !LogonInfo->IsAdmin ) {

                ExInterlockedAddUlong(
                    &SrvStatistics.CurrentNumberOfSessions,
                    (ULONG)-1,
                    &GLOBAL_SPIN_LOCK(Statistics)
                    );

                DeleteSecurityContext( &LogonInfo->Token );
                INVALIDATE_SECURITY_HANDLE( LogonInfo->Token );

                status = STATUS_REQUEST_NOT_ACCEPTED;
                SrvAllowIdlePowerDown();
                goto error_exit;
            }
        }
    }

    return STATUS_SUCCESS;

error_exit:

    return status;

} // DoUserLogon

BOOLEAN
SrvIsAdmin(
    CtxtHandle  Handle
)
/*++

Routine Description:

    Returns TRUE if the user represented by Handle is an
      administrator

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    TRUE if the user is an administrator.  FALSE otherwise.

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    HANDLE                   NullHandle = NULL;
    BOOLEAN                  retval  = FALSE;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    status = ImpersonateSecurityContext( &Handle );

    if( !NT_SUCCESS( status ) )
        return FALSE;

    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( &SrvAdminSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_READ,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );

    //
    // Revert back to our original identity
    //

    REVERT( );
    return retval;
}

BOOLEAN
SrvIsNullSession(
    CtxtHandle  Handle
)
/*++

Routine Description:

    Returns TRUE if the user represented by Handle is an
      anonymous logon

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    TRUE if the user is an anonymous logon.  FALSE otherwise.

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    HANDLE                   NullHandle = NULL;
    BOOLEAN                  retval  = FALSE;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    status = ImpersonateSecurityContext( &Handle );

    if( !NT_SUCCESS( status ) )
        return FALSE;

    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( &SrvNullSessionSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_READ,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );

    //
    // Revert back to our original identity
    //

    REVERT( );
    return retval;
}

NTSTATUS
SrvGetLogonId(
    PCtxtHandle  Handle,
    PLUID LogonId
)
/*++

Routine Description:

    Returns the Logon Id for the requested context.

Arguments:

    Handle - Represents the user we're interested in

Return Value:

    Error codes from ImpersonateSecurityContext and SeQueryAuthenticationId.

--*/
{
    NTSTATUS                 Status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;

    PAGED_CODE();

    //
    // Impersonate the client
    //
    Status = ImpersonateSecurityContext( Handle );

    if( !NT_SUCCESS( Status ) )
        return MapSecurityError(Status);

    SeCaptureSubjectContext( &SubjectContext );

    SeLockSubjectContext( &SubjectContext );

    Status = SeQueryAuthenticationIdToken(
                SubjectContext.ClientToken,
                LogonId
                );

    SeUnlockSubjectContext( &SubjectContext );
    SeReleaseSubjectContext( &SubjectContext );

    REVERT( );

    return(Status);
}


NTSTATUS
SrvValidateSecurityBuffer(
    IN PCONNECTION Connection,
    IN OUT PCtxtHandle Handle,
    IN PSESSION Session,
    IN PCHAR Buffer,
    IN ULONG  BufferLength,
    IN BOOLEAN SecuritySignaturesRequired,
    OUT PCHAR ReturnBuffer,
    IN OUT PULONG ReturnBufferLength,
    OUT PLARGE_INTEGER Expiry,
    OUT PCHAR NtUserSessionKey,
    OUT PLUID LogonId,
    OUT PBOOLEAN IsGuest
    )

/*++

Routine Description:

    Validates a Security Buffer sent from the client

Arguments:

    Handle - On successful return, contains the security context handle
        associated with the user login.

    Session - Points to the session structure for this user

    Buffer - The Buffer to validate

    BufferLength - The length in bytes of Buffer

    SecuritySignaturesRequired - Are we required to generate a security
        signature for the SMBs?

    ReturnBuffer - On return, contains a security buffer to return to the
        client.

    ReturnBufferLength - On return, size in bytes of ReturnBuffer.  On entry,
            the largest buffer we can return.

    Expiry - The time after which this security buffer is no longer valid.

    NtUserSessionKey - If STATUS_SUCCESS, the session key is returned here. This
        must point to a buffer at least MSV1_0_USER_SESSION_KEY_LENGTH big.

    LogonId - If successful, receives the logon id for this context.

    IsGuest - If successful, TRUE if the client has been validated as a guest

Return Value:

    NTSTATUS from the security system.  If STATUS_SUCCESS is returned, the user
        has been completely authenticated.

Notes:

    BUGBUG

    AcceptSecurityContext() needs to return the KickOffTime (ie, the logon
    hours restriction) so that the server can enfore it. The contact person
    is MikeSw for this.

--*/

{
    NTSTATUS Status;
    ULONG Catts;
    PUCHAR AllocateMemory = NULL;
    ULONG maxReturnBuffer = *ReturnBufferLength;
    ULONG_PTR AllocateLength = MAX(BufferLength, maxReturnBuffer );
    BOOLEAN virtualMemoryAllocated = FALSE;
    SecBufferDesc InputToken;
    SecBuffer InputBuffer;
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;
    SecPkgContext_NamesW SecNames;
    SecPkgContext_SessionKey SecKeys;
    ULONG oldSessionCount;
    TimeStamp LocalExpiry = {0};

    *ReturnBufferLength = 0;
    *IsGuest = FALSE;

    if ( (SrvHaveCreds & HAVEEXTENDED) == 0 ) {
        return STATUS_ACCESS_DENIED;
    }

    RtlZeroMemory( &SecKeys, sizeof( SecKeys ) );
    RtlZeroMemory( &SecNames, sizeof( SecNames ) );

    InputToken.pBuffers = &InputBuffer;
    InputToken.cBuffers = 1;
    InputToken.ulVersion = 0;
    InputBuffer.pvBuffer = Buffer;
    InputBuffer.cbBuffer = BufferLength;
    InputBuffer.BufferType = SECBUFFER_TOKEN;

    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = ReturnBuffer ;
    OutputBuffer.cbBuffer = maxReturnBuffer ;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    SrvStatistics.SessionLogonAttempts++;
    Catts = 0;

    Status = AcceptSecurityContext(
                    &SrvExtensibleSecurityHandle,
                    IS_VALID_SECURITY_HANDLE( *Handle ) ? Handle : NULL,
                    &InputToken,
                    ASC_REQ_EXTENDED_ERROR | ASC_REQ_ALLOW_NULL_SESSION |
                            ASC_REQ_DELEGATE | ASC_REQ_FRAGMENT_TO_FIT,
                    SECURITY_NATIVE_DREP,
                    Handle,
                    &OutputToken,
                    &Catts,
                    &LocalExpiry);

    Status = MapSecurityError( Status );

    //
    // If there is a return buffer to be sent back, copy it into the caller's
    // buffers now.
    //
    if ( NT_SUCCESS(Status) || (Catts & ASC_RET_EXTENDED_ERROR) ) {

        if( Status == STATUS_SUCCESS ) {
            NTSTATUS qcaStatus;
            SecPkgContext_UserFlags userFlags;

            // Sspi will return time in LocalTime, convert to UTC
            // Enable dynamic reauthentication if possible or required
            if( SrvEnforceLogoffTimes || CLIENT_CAPABLE_OF( DYNAMIC_REAUTH, Connection ) )
            {
                ExLocalTimeToSystemTime (&LocalExpiry, Expiry);
            }
            else
            {
                Expiry->QuadPart = SRV_NEVER_TIME ;
            }


            //
            // The user has been completely authenticated.  See if the session
            // count is being exceeded.  We'll allow it only if the new client
            // is an administrator.
            //

            oldSessionCount = ExInterlockedAddUlong(
                              &SrvStatistics.CurrentNumberOfSessions,
                              1,
                              &GLOBAL_SPIN_LOCK(Statistics)
                              );

            SrvInhibitIdlePowerDown();

            if ( !Session->IsSessionExpired && oldSessionCount >= SrvMaxUsers ) {
                if( oldSessionCount != SrvMaxUsers ||
                        !SrvIsAdmin( *Handle ) ) {

                    ExInterlockedAddUlong(
                        &SrvStatistics.CurrentNumberOfSessions,
                        (ULONG)-1,
                        &GLOBAL_SPIN_LOCK(Statistics)
                        );

                    DeleteSecurityContext( Handle );

                    INVALIDATE_SECURITY_HANDLE( *Handle );

                    Status = STATUS_REQUEST_NOT_ACCEPTED;
                    SrvAllowIdlePowerDown();
                    goto exit;
                }
            }

            //
            // Figure out if we validated the client as GUEST
            //
            qcaStatus = QueryContextAttributes(
                            Handle,
                            SECPKG_ATTR_USER_FLAGS,
                            &userFlags);


            if( NT_SUCCESS( MapSecurityError( qcaStatus ) ) ) {

                if( userFlags.UserFlags & LOGON_GUEST ) {
                    *IsGuest = TRUE;
                }

            } else {
                SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, qcaStatus );
            }

            //
            // Get the Logon Id for this context
            //
            Status = SrvGetLogonId( Handle, LogonId );

            //
            // Capture the session key for this context
            //
            RtlZeroMemory( (PVOID) NtUserSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH );

            qcaStatus = QueryContextAttributes(
                            Handle,
                            SECPKG_ATTR_SESSION_KEY,
                            &SecKeys);

            if( NT_SUCCESS( MapSecurityError( qcaStatus ) ) ) {

                RtlCopyMemory(
                    (PVOID) NtUserSessionKey,
                    SecKeys.SessionKey,
                    MIN(MSV1_0_USER_SESSION_KEY_LENGTH, SecKeys.SessionKeyLength)
                    );

                //
                // Start the security signatures, if required.  We do not do security signatures
                //   if we have a null session or a guest logon.
                //
                if( NT_SUCCESS( Status ) &&
                    SecuritySignaturesRequired &&
                    *IsGuest == FALSE &&
                    Connection->SmbSecuritySignatureActive == FALSE &&
                    !SrvIsNullSession( *Handle ) ) {

                    //
                    // Start the sequence number generation
                    //
                    SrvInitializeSmbSecuritySignature(
                                    Connection,
                                    NULL,
                                    SecKeys.SessionKey,
                                    SecKeys.SessionKeyLength
                                    );
                }

                FreeContextBuffer( SecKeys.SessionKey );

            } else {

                SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, qcaStatus );
            }

            if( !NT_SUCCESS( Status ) ) {
                DeleteSecurityContext( Handle );
                INVALIDATE_SECURITY_HANDLE( *Handle );
            }
        }

        ASSERT( OutputBuffer.cbBuffer <= maxReturnBuffer );

        //
        // If it fits, and a buffer was returned, send it to the client.  If it doesn't fit,
        //  then log the problem.
        //
        if( OutputBuffer.cbBuffer <= maxReturnBuffer ) {
            if( OutputBuffer.cbBuffer != 0 ) {
                *ReturnBufferLength = OutputBuffer.cbBuffer;
            }
        } else {
            SrvLogServiceFailure( SRV_SVC_SECURITY_PKG_PROBLEM, OutputBuffer.cbBuffer );
        }
    }

exit:

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            PUCHAR pValidate = (PUCHAR) OutputBuffer.pvBuffer ;

            ASSERT( ( pValidate[0] != 0 ) ||
                    ( pValidate[1] != 0 ) ||
                    ( pValidate[2] != 0 ) ||
                    ( pValidate[3] != 0 ) );
        }
    }
#endif


    if( NT_SUCCESS( Status ) && Status != STATUS_SUCCESS ) {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return Status;

} // SrvValidateSecurityBuffer

NTSTATUS
SrvGetUserAndDomainName (
    IN PSESSION Session,
    OUT PUNICODE_STRING UserName OPTIONAL,
    OUT PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description

    Return the user and domain names associated with the Session

Arguments:
    IN PSESSION Session : The session

Return Value:
    IN OUT PUNICODE_STRING UserName
    IN OUT PUNICODE_STRING DomainName

Note:
    The caller must call SrvReleaseUserAndDomainName() when finished

--*/
{
    SecPkgContext_NamesW SecNames;
    NTSTATUS status;
    UNICODE_STRING fullName, tmpUserName, tmpDomainName;
    USHORT i, fullNameLength;

    PAGED_CODE();

    if( !IS_VALID_SECURITY_HANDLE( Session->UserHandle ) ) {

        if( ARGUMENT_PRESENT( UserName ) ) {
            *UserName = Session->NtUserName;
        }
        if( ARGUMENT_PRESENT( DomainName ) ) {
            *DomainName = Session->NtUserDomain;
        }

        return STATUS_SUCCESS;
    }

    if( ARGUMENT_PRESENT( UserName ) ) {
        UserName->Buffer = NULL;
        UserName->Length = 0;
    }

    if( ARGUMENT_PRESENT( DomainName ) ) {
        DomainName->Buffer = NULL;
        DomainName->Length = 0;
    }

    //
    // If it's the NULL session, then there are no names to be returned!
    //
    if( Session->IsNullSession == TRUE ) {
        return STATUS_SUCCESS;
    }

    SecNames.sUserName = NULL;

    status = QueryContextAttributesW(
                    &Session->UserHandle,
                    SECPKG_ATTR_NAMES,
                    &SecNames
            );

    status = MapSecurityError( status );

    if (!NT_SUCCESS(status)) {
        if( Session->LogonSequenceInProgress == FALSE ) {
            //
            // If the client is in the middle of an extended logon sequence,
            //   then failures of this type are expected and we don't want
            //   to clutter the event log with them
            //
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
        }
        return status;
    }

    //
    // See if we have a NULL user names.  This shouldn't happen, but
    //  might if a security package is incomplete or something
    //
    if( SecNames.sUserName == NULL || *SecNames.sUserName == L'\0' ) {

        if( SecNames.sUserName != NULL ) {
            FreeContextBuffer( SecNames.sUserName );
        }
        return STATUS_SUCCESS;
    }

    //
    // The return SecNames.sUserName should be in domainname\username format.
    //  We need to split it apart.
    //
    RtlInitUnicodeString( &fullName, SecNames.sUserName );

    fullNameLength = fullName.Length / sizeof(WCHAR);

    tmpDomainName.Buffer = fullName.Buffer;

    for (i = 0; i < fullNameLength && tmpDomainName.Buffer[i] != L'\\'; i++) {
         NOTHING;
    }

    if( tmpDomainName.Buffer[i] != L'\\' ) {
        FreeContextBuffer( SecNames.sUserName );
        return STATUS_INVALID_ACCOUNT_NAME;
    }

    tmpDomainName.Length = i * sizeof(WCHAR);
    tmpDomainName.MaximumLength = tmpDomainName.Length;

    tmpUserName.Buffer = &tmpDomainName.Buffer[i + 1];
    tmpUserName.Length = fullName.Length - tmpDomainName.Length - sizeof(WCHAR);
    tmpUserName.MaximumLength = tmpUserName.Length;

    if( ARGUMENT_PRESENT( UserName ) ) {
        status = RtlUpcaseUnicodeString( UserName, &tmpUserName, TRUE);
        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
            FreeContextBuffer( SecNames.sUserName );
            return status;
        }
    }

    if( ARGUMENT_PRESENT( DomainName ) ) {
        status = RtlUpcaseUnicodeString( DomainName, &tmpDomainName, TRUE );
        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_LSA_LOOKUP_PACKAGE, status );
            FreeContextBuffer( SecNames.sUserName );
            if( UserName != NULL ) {
                RtlFreeUnicodeString( UserName );
            }
            return status;
        }
    }

    FreeContextBuffer( SecNames.sUserName );

    return STATUS_SUCCESS;
}

VOID
SrvReleaseUserAndDomainName(
    IN PSESSION Session,
    IN OUT PUNICODE_STRING UserName OPTIONAL,
    IN OUT PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description

    This is the complement of SrvGetUserAndDomainName.  It frees the memory
        if necessary.

--*/

{
    PAGED_CODE();

    if( ARGUMENT_PRESENT( UserName ) &&
        UserName->Buffer != NULL &&
        UserName->Buffer != Session->NtUserName.Buffer ) {

        RtlFreeUnicodeString( UserName );
    }

    if( ARGUMENT_PRESENT( DomainName ) &&
        DomainName->Buffer != NULL &&
        DomainName->Buffer != Session->NtUserDomain.Buffer ) {

        RtlFreeUnicodeString( DomainName );

    }
}


NTSTATUS
SrvFreeSecurityContexts (
    IN PSESSION Session
    )

/*++

Routine Description:

    Releases any context obtained for security purposes

Arguments:

    IN PSESSION Session : The session

Return Value:

    NTSTATUS

--*/

{
    SECURITY_STATUS status;

    if( IS_VALID_SECURITY_HANDLE( Session->UserHandle ) ) {

        if ( !CONTEXT_EQUAL( Session->UserHandle, SrvNullSessionToken ) ) {

            status = DeleteSecurityContext( &Session->UserHandle );
            INVALIDATE_SECURITY_HANDLE( Session->UserHandle );

            if( NT_SUCCESS( status ) &&
                !Session->LogonSequenceInProgress ) {

                ExInterlockedAddUlong(
                    &SrvStatistics.CurrentNumberOfSessions,
                    (ULONG)-1,
                    &GLOBAL_SPIN_LOCK(Statistics)
                    );

                SrvAllowIdlePowerDown();
            }

        }
    }

    return STATUS_SUCCESS;

} // SrvFreeSecurityContexts


NTSTATUS
AcquireLMCredentials (
    VOID
    )
{
    UNICODE_STRING Ntlm;
    NTSTATUS status;
    TimeStamp Expiry;

    RtlInitUnicodeString( &Ntlm, L"NTLM" );

    //
    // We pass in 1 for the GetKeyArg to indicate that this is
    // downlevel NTLM, to distinguish it from NT5 NTLM.
    //

    status = AcquireCredentialsHandle(
                NULL,                   // Default principal
                (PSECURITY_STRING) &Ntlm,
                SECPKG_CRED_INBOUND,    // Need to define this
                NULL,                   // No LUID
                NULL,                   // No AuthData
                NULL,                   // No GetKeyFn
                NTLMSP_NTLM_CREDENTIAL, // GetKeyArg
                &SrvLmLsaHandle,
                &Expiry
                );

    if ( !NT_SUCCESS(status) ) {
        status = MapSecurityError(status);
        return status;
    }
    SrvHaveCreds |= HAVENTLM;

    return status;

} // AcquireLMCredentials

#ifndef EXTENSIBLESSP_NAME
#define EXTENSIBLESSP_NAME NEGOSSP_NAME_W
#endif


NTSTATUS
AcquireExtensibleSecurityCredentials (
    VOID
    )

/*++

Routine Description:

    Acquires the handle to the security negotiate package.

Arguments:

    none.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING NegotiateName;
    TimeStamp Expiry;
    NTSTATUS status ;


    RtlInitUnicodeString( &NegotiateName, EXTENSIBLESSP_NAME );

    status = AcquireCredentialsHandle(
                NULL,                   // Default principal
                (PSECURITY_STRING) &NegotiateName,
                SECPKG_CRED_INBOUND,    // Need to define this
                NULL,                   // No LUID
                NULL,                   // No AuthData
                NULL,                   // No GetKeyFn
                NULL,                   // No GetKeyArg
                &SrvExtensibleSecurityHandle,
                &Expiry
                );


    if ( !NT_SUCCESS(status) ) {
        status = MapSecurityError(status);
        return status;
    }
    SrvHaveCreds |= HAVEEXTENDED;

    return status;

} // AcquireExtensibleSecurityCredentials

VOID
SrvAddSecurityCredentials(
    IN PANSI_STRING ComputerNameA,
    IN PUNICODE_STRING DomainName,
    IN DWORD PasswordLength,
    IN PBYTE Password
)
/*++

Routine Description:

    In order for mutual authentication to work, the security subsystem needs to know
    all the names the server is using, as well as any passwords needed to decrypt
    the security information associated with the server name.  This routine informs
    the security subsystem.

Arguments:

    ComputerName, DomainName - these are the names the clients will be using to access this system

    PasswordLength, Password - this is the secret the security system needs to know to decode the
        passed security information

--*/
{
    NTSTATUS status;
    UNICODE_STRING ComputerName;
    PUSHORT p;
    PVOID VirtualMem ;
    SIZE_T Size ;
    PSEC_WINNT_AUTH_IDENTITY Auth ;
    PUCHAR Where ;
    UNICODE_STRING NegotiateName;
    TimeStamp Expiry;

    PAGED_CODE();

    status = RtlAnsiStringToUnicodeString( &ComputerName, ComputerNameA, TRUE );

    if( !NT_SUCCESS( status ) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(( "SRV: SrvAddSecurityCredentials, status %X at %d\n", status, __LINE__ ));
        }
        return;
    }

    if ((SrvHaveCreds & HAVEEXTENDED) == 0) {
        if (status = AcquireExtensibleSecurityCredentials()) {
            return ;
        }
    }

    //
    // Trim off any trailing blanks
    //
    for( p = &ComputerName.Buffer[ (ComputerName.Length / sizeof( WCHAR )) - 1 ];
         p > ComputerName.Buffer;
         p-- ) {

        if( *p != L' ' )
            break;
    }

    ComputerName.Length = (USHORT)((p - ComputerName.Buffer + 1) * sizeof( WCHAR ));

    if( ComputerName.Length ) {
        //
        // Tell the security subsystem about this name.
        //
        RtlInitUnicodeString( &NegotiateName, EXTENSIBLESSP_NAME );

        Size = ComputerName.Length + sizeof( WCHAR ) +
               DomainName->Length + sizeof( WCHAR ) +
               PasswordLength +
               sizeof( SEC_WINNT_AUTH_IDENTITY ) ;


        VirtualMem = NULL ;

        status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &VirtualMem,
                    0,
                    &Size,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( status ) )
        {
            Auth = (PSEC_WINNT_AUTH_IDENTITY) VirtualMem ;

            Where = (PUCHAR) (Auth + 1);

            Auth->User = (PWSTR) Where ;

            Auth->UserLength = ComputerName.Length / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                ComputerName.Buffer,
                ComputerName.Length );

            Where += ComputerName.Length ;

            Auth->Domain = (PWSTR) Where ;

            Auth->DomainLength = DomainName->Length / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                DomainName->Buffer,
                DomainName->Length );

            Where += DomainName->Length ;

            Auth->Password = (PWSTR) Where ;

            Auth->PasswordLength = PasswordLength / sizeof( WCHAR );

            RtlCopyMemory(
                Where,
                Password,
                PasswordLength );

            Auth->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ;


            status = AddCredentials(
                        &SrvExtensibleSecurityHandle,                   // Default principal
                        NULL,
                        (PSECURITY_STRING) &NegotiateName,
                        SECPKG_CRED_INBOUND,    // Need to define this
                        Auth,                   // Auth data
                        NULL,                   // No GetKeyFn
                        NULL,                   // No GetKeyArg
                        &Expiry );

            NtFreeVirtualMemory(
                NtCurrentProcess(),
                &VirtualMem,
                &Size,
                MEM_RELEASE );

        }

    }

    //
    // Free up our memory
    //
    RtlFreeUnicodeString( &ComputerName );
}

NTSTATUS
SrvGetExtensibleSecurityNegotiateBuffer(
    OUT PCtxtHandle Token,
    OUT PCHAR Buffer,
    OUT USHORT *BufferLength
    )

{

    NTSTATUS Status;
    ULONG Attributes;
    TimeStamp Expiry;
    SecBufferDesc OutputToken;
    SecBuffer OutputBuffer;

    if ((SrvHaveCreds & HAVEEXTENDED) == 0) {
        if (Status = AcquireExtensibleSecurityCredentials()) {
            *BufferLength = 0;
            return(Status);
        }
    }


    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = 0;
    OutputBuffer.cbBuffer = 0;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    Status = AcceptSecurityContext (
                   &SrvExtensibleSecurityHandle,
                   NULL,
                   NULL,
                   ASC_REQ_INTEGRITY | ASC_REQ_CONFIDENTIALITY |
                        ASC_REQ_ALLOCATE_MEMORY | ASC_REQ_ALLOW_NULL_SESSION |
                        ASC_REQ_DELEGATE,
                   SECURITY_NATIVE_DREP,
                   Token,
                   &OutputToken,
                   &Attributes,
                   &Expiry);

     if (!NT_SUCCESS(Status)) {
        *BufferLength = 0;
        return(Status);
     }

     if (OutputBuffer.cbBuffer >=
            (SrvReceiveBufferSize - sizeof(PRESP_NT_NEGOTIATE))) {

         Status = STATUS_INVALID_BUFFER_SIZE;

         SrvLogServiceFailure( SRV_SVC_LSA_CALL_AUTH_PACKAGE, Status);

         *BufferLength = 0;

     } else {

         RtlCopyMemory(Buffer, OutputBuffer.pvBuffer, OutputBuffer.cbBuffer);

         *BufferLength = (USHORT) OutputBuffer.cbBuffer;

     }

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            PDWORD pdwValidate = (DWORD*)OutputBuffer.pvBuffer;
            ASSERT( *pdwValidate != 0 );
        }
    }
#endif


     FreeContextBuffer(OutputBuffer.pvBuffer);

     return( Status );

}

VOID SRVFASTCALL
SrvInitializeSmbSecuritySignature(
    IN OUT PCONNECTION Connection,
    IN PUCHAR SessionKey OPTIONAL,
    IN PUCHAR ChallengeResponse,
    IN ULONG ChallengeResponseLength
    )
/*++

Routine Description:

    Initializes the security signature generator for a session by calling MD5Update
    on the session key, challenge response

Arguments:

    SessionKey - Either the LM or NT session key, depending on which
        password was used for authentication, must be at least 16 bytes
    ChallengeResponse - The challenge response used for authentication, must
        be at least 24 bytes

--*/
{
    RtlZeroMemory( &Connection->Md5Context, sizeof( Connection->Md5Context ) );

    MD5Init( &Connection->Md5Context );

    if( ARGUMENT_PRESENT( SessionKey ) ) {
        MD5Update( &Connect